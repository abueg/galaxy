#include <sys/types.h>
#include <sys/stat.h>
#include <malloc.h>

#ifndef WIN32
#include <unistd.h>
#include <alloca.h>
#else
#define copysign _copysign
#define isnan _isnan
#define alloca _alloca 
#endif

#include <sys/wait.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <omp.h>

#include "constants.h"
#include "parameters.h"
#include "globals.h"
#include "Calign.h"
#include "Ccontig.h"
#include "hash.h"

#if (USE_SSE==1 && USE_RFLOAT==1)
#include <immintrin.h>
#endif

// #undef DEBUG
// #define DEBUG 2

static Ident Id("$Header: http://svn.bnm.local:81/svn/Informatics/RefAligner/branches/11442/refalign.cpp 11578 2020-08-31 22:42:04Z tanantharaman $");



#define SCORE_INIT_DELAY 1 /* minimize memory by calling score_init() just for the ref contigs currently being processed */


#define AUTONOISE_FP 1

#define KEEP_MULTIMATCHES 0 /* NEW9 : Even without -MultiMatches, if -hashMultiMatch was used AND -bestRef was NOT used, keep multiple sets of alignments (NOT YET IMPLEMENTED) */

#define EXTSPLIT_MINMEM 1 /* reduce memory used for split contigs by compacting memory of trimmed map */

#define SCORE_MINMEM RAscoremem /* free score memory before calling refine() then reallocate it after returning */

#define EXTENDWT_DELAY (splitFiltMinWT >= 0.0) /* WAS300 splitFiltMinWT > 0.0 */ /* delay application of -extendWT to main contig, so it applies even if -extsplit is NOT used AND has no effect on -extsplit map weights */

#define EXTSPLIT_OUTLIER_RANGE 1 /* check for indel anywhere in the outlier ref range, when query range > 1 label interval */
#define EXTSPLIT_BALANCED 1 /* separate bin for balance outliers + endoutliers (each endoutlier will also be in largest outlier bin) */
#define EXTSPLIT_DELBIN 1 /* separate KBend bins for deletions (vs insertions) */

#define EXTSPLIT_BIAS 1 /* NEW8 */ /* 0 : bias extsplit breakpoint (in case of tied number of endoutliers) in favor of including as much of original contig as possible (OLD)
				      1 : bias extsplit breakpoint (in case of tied number of endoutliers) in favor of including as little of original contig as possible (NEW) */
#define EXTSPLIT_SPACING_FIX ExtsplitSpacingFix /* If >= 1 : Requires extend & split minimum spacing and distance to end of contig to be lesser of 
								    1. (extendSplitFP + extendSplitEndSpacing - 1) Labels
								    2. Xlambda * extendSplitEndSpacingX kb 
						             Also limit scanning range to Xrange = Xlambda * extendSplitSpacingX kb, provided peak has been verified
						   If >= 2:  Limit scanning range to Xrange, even if peak has NOT been verified by that point (requires EXTSPLIT_VERIFYPEAK == 0)
						*/
#define EXTSPLIT_VERIFYPEAK ExtsplitVerifyPeak /* verify that extend&split endoutlierL[] and endoutlierR[] values are decreasing on both sides, before calling a peak (and splitting) */

#define EXTSPLIT_RANGE 1 /* keep track of range of alignment index (with alignments sorted by midpoint on ref) for each endoutlierL[i] and endoutlierR[i] coverage value (for speed up) */
#define EXTSPLIT_FORK (USE_MIC ? 0 : 1) /* After generating all contig splits reduce number of threads to EXTSPLIT_FORK and then fork into multiple jobs each processing a different range of refid values
					   NOTE : Due to libgomp using suspended thread pools that do NOT work after a fork, this only works for EXTSPLIT_FORK == 1
					   NOTE2 : scif IO calls do not seem to work after fork in parent on MIC (even if it seems to work for on child job) */
#define EXTSPLIT_FORK_MEM (USE_MIC ? 0.2 : 0.4) /* Gb of memory per forked Refine (per thread) : nlimits number of forked jobs */

#define EXTSPLIT_KEEPMAPS keepsplitmaps /* NEW8 */ /* 0 : delete maps with endoutliers used for splits from original contig (OLD)
						      1 : keep maps with endoutliers used for splits in original contig (relying on reduced BestRefWT to suppress them in subsequent rounds) (NEW) */

#define HASH_FILL 7 /* WAS4 0 */ /* try to fill up hashtable buffer, when at least 1/(HASH_FILL+1) of the entries were discarded due to hash_threshold */

#define VMRSS_SLEEP 0.050 /* ReCheck VmRSS no more than once every VMRSS_SLEEP seconds (in each thread) */
#define VMRSS_CHECK 0.050 /* Check VmRSS no more than once every VMRSS_CHECK seconds (across all threads) */
#define VMRSS_DELAY 0.0  /* WAS 0.100 */ /* Delay checking VmRSS by at least this number of seconds to allow refalignXYSd to touch memory : NOTE it can take 1 sec per GB for a single thread to touch memory, so this is not a viable method to guarantee staying within -maxmem. See MEMCHECK for alternate method */
#define MADVISE_HWM !CACHE /* apply madvise(DONT_NEED) only to memory actually touched since last allocation or madvise(), rounded to nearest page (NOTE : will not work with CACHE) */
#define MEMCHECK 2 /* NEW410 : Recheck memory after initializing arrays in refalignXYsd (up to MEMECHECK times) if VmRSS+VmSwap > MaxMemSiz * RA_MAX_MEM */
#define VMRSS_CHECK2 0.001 /* For MEMCHECK, only recheck VmRSS if it has been at least VMRSS_CHECK2 seconds since the last global check */

#define MATCHGROUP_HEAP 1 /* WAS 0 */ /* Use heap to sort matchgroup list */

#define EARLY_ALIGN_FILTER 0  /* NOTE : not correctly implemented for all use cases (eg SV) */ // filter out below threshold alignments earlier, so the thresholds do not have to be checked so often 

#define MAXCOV_FIX 1e-9 /* If != 0 : Ignore coverage for intervals smaller than MAXCOV_FIX, to avoid ambiguous ordering of unaligned sites */

#define COMPRESS_CONTIG 1 /* WAS 0 */ 

#define SITECNT_FIX 1 /* remove labels in build_contig() consensus derived from maps that have been filtered out due to -MaxCov  */

#define FPDEBUG 0 // SDDEBUG

#define REPEATMASK_FIX 1 // avoid updating A->G and A->score in RepeatScore (when updating A->Lij,A->Lijx)

#define REPEATREC_FIX 1 // enforce median repeat size based shift range for -RepeatRec

#define MINSNR_FIX 1 
#define SNR_BESTREF_FIX 1 /* see SNRtotLL() */

#define MAX_REPEATCHECK 150 /* skip repeat check for alignments with more than this many labels */
#define MAX_STACKDEPTH (MSAN ? 64 : 1000) /* maximum recursion call depth for RepeatScore() */

#define MAX_ALLOCA 128 /* maximum doubles to allocate on stack, to avoid stack overflow */

#define MULTIMATCH_TRIM 1 /* trim off shared left end of lower scoring matchgroup vs higher scoring matchgroup and save the remaining part of the matchgroup.
			     If MULTIMATCHES_DUPFIX this also applies to MultiMatchesRemoveDupes */
#define MULTIMATCH_TRIMFIX 1 /* save matchgroup if shared left end consists of a single label pair, provided the right end offset differs by at least MultiMatches (kb) from the higher scoring matchgroup  */

#define MULTIMATCHESTOTSCORE_FIX 0 /* HERE HERE TRY 1 */ /* Improve MultiMatchesFilter>=2 by trimming left end of truncted contigs if MultiMatchesTotScore >= 2 */

#define MULTIMATCHES_FILTER 0.01 /* WAS11 2.0 */ /* If != 0 : Filter initial list of match groups not only by -S2 but also by -A2 (using bounds) and -L2, and 
						    filter out matchgroups with -ve score in last interval (J - J1) less than -MULTIMATCHES_FILTER
						    Also filter out if last 2 intervals add up to less than (RefSplitStitch >= 2 ?  biasend2_values[J2] : 0.0) -MULTIMATCHES_FILTER */
#define MULTIMATCHES_MINMEM 1 /* Minimize memory used by matchgroup[] arrays to nore more than (MINMEM+1)/MINMEM times the amount needed */
#define MULTIMATCHES_DUPFIX 2 /* Fix MultiMatchesDupes to apply MULTIMATCH_TRIM and save the partial matchgroups */
#define MULTIMATCHES_ORDERFIX 1 /* fix MultiMatchesDupes() when q fragment scores higher than Malign[i] or Malign[0..j-1] */

#define MMPEN_FIX 1 /* FIX handling of MM_PEN */
#define MM_PEN (MMPEN_FIX ? MultiMatchesDupesMMPen : 0.01) /* score must improve by at least this amount before MultiMatchesDupes is allowed to break up a higher scoring matchgroup */
#define DUPFIX_MAXCNT 0 /* avoid possible infinite loop in MultiMatchesDupes() by limiting a certain case to this many times per call */

#define REPEAT_OUTLIER 1 /* optimize outlier locations to maximize Pvalue during repeat scoring */
#define REPEAT_TRIM 1 /* trim right unaligned end from shifted alignment, since this always lowers confidence due to 1-2 extra misaligned labels */

#define MINSNR_BT 0.25 /* backtrack ratio (per iteration) for minSNR[0] optimization */

#define MERGE_OUTLIERS 1 /* Merge back to back -ve scoring intervals in all alignments (if MultiMatches && RefSplit) if seperated by +ve score of no more than log(1/Rsplit) 
			    Using Rsplit = 1.0 will effectively disable this */
#define MERGE_OUTLIERS_CUTFLIP 1 /* apply MERGE_OUTLIERS during -CutFlip */

// #define REFSPLIT_DELAY 1 /* Delay application of -RefSplit until after all -MultiMatch alignments are found and merged, then split these alignments based on Psplit,RefSplitMinLabels,Rsplit */

#define OUTLIER_MARGIN (USE_RFLOAT ? 0.001 : 1e-8) /* absolute score emargin used to classify an interval as outlier during parameter estimation */
#define SCORE_MARGIN (USE_RFLOAT ? (RELEASE ? 1e-4 : 1e-5) : 1e-10) /* relative score accuracy margin (to trigger inconsistency assertions) */
#define ASCORE_MARGIN (USE_RFLOAT ? (RELEASE ? 1e-2 : 1e-3) : 1e-7) /* absolute score accuracy margin (to trigger inconsistency assertions) */

#define RSCORE_MARGIN (USE_RFLOAT ? (RELEASE ? 1e-6 : 1e-7) : 1e-10) /* relative score error per aligned interval */
#define ISCORE_MARGIN (USE_RFLOAT ? (RELEASE ? 1e-4 : 1e-5) : 1e-10) /* absolute score error per aligned interval */

#define FENCE (DEBUG>=2 ? 32 : 0) /* size of fence before and after each row of data : currently only used with DIAGNONAL >=2 */

#define RESDATA ResEstimate /* optimize res and resSD values */

#define STITCH 0 /* support stitching signal (still being developed) */

#define MIS_VITERBI 1 /* WAS 0 */ /* use Viterbi scoring of misaligned sites */

#define LFLOAT FLOAT /* WAS RFLOAT */ /* floating point precision used by logLR() and resLL() for parameter estimation */
#define LZERO ZERO /* WAS RZERO */

#define FN_ADJUST 0 /* TRY 1 */ /* Adjust False Negative penalty based on expected number of resolvable labels in reference interval E(I,n) = sum(i=1..n) Pr(Y[I-i+1]-Y[I-i])
				   Replace (n-1)*FnPenalty by max(0.0,E(I,n)-1.0)*FnPenalty in scoring functions : HERE : need to update local use of (n-1)*FnPenalty */

#define FN_GM 1 /* (SCORE_APPROX <= 1 && !MIS_VITERBI) */ /* Use Golden Mean search to optimize FN (instead of just counting misaligned sites) : slower but more accurate for high density data with many misresolved sites */

#define MINMEM 1 /* WAS 0 */ /* minimize memory usage by reallocating lightweight heap each iteration of giter (and if >=2 after each iteration of refid) */
#define MINMEM_GC 0 /* TRY 1 : known assertion failure */ /* compress alignments into a single Calign_block  after every multithreaded section */

#define FIX_OUTLIER_MIS 1 /* fix scoring of outliers to not including misalignment scores Sm() (from between alignment intervals) */

#define DIAGONAL 2 /* > 0 : with hashtable offset, diagonalize alignment array to increase speed and (if >= 2) reduce real memory usage */
#define MIN_MEM RA_MIN_MEM /* minimize virtual memory usage by possibly reallocating memory in each call of refalignXYsd() */
#define MIN_MEM_DEBUG 0
#define CACHE bool(1) /* improve cache usage of memory by avoiding changing start of arrays (slight increase in total memory use) */
#define ALIGN 16 /* alignment of (I,J) based 2-D arrays in elements (int or RFLOAT) : size in bytes should be a multiple of cache line size (must be power of 2) */
#define ALIGN2 1024 /* alignment of (K,I,J) based 3-D arrays in elements (int or RFLOAT) : size in bytes should be a multiple of page size (must be power of 2) */
#define PADDING ((USE_MIC||USE_AVX512) ? 64 : USE_AVX ? 32 : 0) /* Pad Allocated memory blocks by this many bytes : should correspond to size of mm512 or mm256 vector in bytes */		   

//#define RANGE_SITE HASHRANGE /* based hashdelta range on number of sites rather than distance : faster when reference label density is higher than query label density */


#define EXTSPLIT_TRACE 0
#define EXTSPLIT_REFID 1LL
#define EXTSPLIT_NREFID 58537LL
#define EXTSPLIT_I 268

#undef TRACE
#define TRACE 0 /* (giter==RefRepeats-1) */ /* Trace alignment scoring for specified rmap->id, nanomap->id, orientation, I,K,J */

#define REPEATCHECK 0 /* additional tracing (if PVERB>=2) if repeat check fails */
#define SHIFT_TRACE 0  

#define REF_TRACE 4LL
#define MAP_TRACE 242LL
#define OR_TRACE 0
#define I_TRACE -1 // 5 
#define K_TRACE 0 
#define J_TRACE 52

#define SPLIT_TRACE 0
#define SPLIT_LEFT 50 // left end if Y[] index range to display
#define SPLIT_RIGHT 58 // right end of Y[] index range to display
#define SPLIT_MAP -1LL // limit tracing of alignments to map id == SPLIT_MAP (or trace all maps if -1)
#define SPLIT_ALIGNID -1 // limit tracing to specified alignid (or trace all alignments if -1)
#define SPLIT_LL -1
#define SPLIT_LR -1
#define SPLIT_RL 52
#define SPLIT_RR 56

#define TVERB (rmap->id == REF_TRACE && nanomap->id == MAP_TRACE && orientation == OR_TRACE)

#define PVERB ((TRACE && TVERB) ? 2 : 0) /* Display detailed alignment information for all alignments above threshold */


#define BESTREF_PV BestRefPV /* with -BestRef chose best reference based on LogPV instead of score */

#define RESBIAS_TRACE ((WITH_RESBIAS && VERB>=2 && giter==1) ? 1 : 0) // TRACE resbias estimation, molecule by molecule (2 : also trace backtrack)

#define RESBIAS_MAXERR2 2 /* WAS 0 */ /* >=1 : limit gaussian error to outlier limit in each interval, if err is changed due to resbias
					 >=2 : propagate limit to subsequent estimation of sf,sr etc */
#define RESBIAS_MONOTONIC 2 /* force resbias[] to be monotonic */
#define RESBIAS_BOUNDS 2 /* WAS 0 */ /* >=1 : bound resbias[] values by nearby piecewise constant values
					>=2 : further bound resbias[0][k=0,1] to meanbias[k] (from below)
				     */

#define RESBIAS_BACKTRACK 1 /* WAS 1 */ /* don't change resbias if LL decreases (sometimes this happens because the alignments are no longer optimal) */
#define RESBIAS_FIXBINS 1 /* estimate bin boundaries only once, to enable RESBIAS_BACKTRACK_PARTIAL */
#define RESBIAS_BACKTRACK_PARTIAL 21 /* TRY 1 */ /* N >= 1 : perform partial backtrack of resbias if LL decreases, before full backtrack 
						   N >= 2 : perform seperate backtrack for each value resbias[0][0..N-2] (provided the bin has at least RESBIAS_MINSAMPLE_BT samples) */
#define RESBIAS_MINSAMPLE_BT 0 /* see RESBIAS_BACKTRACK_PARTIAL */

#define RESBIAS_MINSAMPLE (RESBIAS_BACKTRACK_PARTIAL >= 2 ? 4 : 128) /* minimum number of samples per bin */
#define RESBIAS_MAXSLOPE 0.99 /* maximum linear slope allowed */

#define FIX_CONSTRAINT 1 /* TRY 1,2 */ /* > 0 : more conservative RepeatRec constraint */

#define HASH_DEBUG 0 /* To debug HASH_STREAM with verbose buffer update messages (2 = very verbose, each match is displayed) */

#define FLAT_MEMORY 1 /* Use flat memory for AL.field(I,K,J) : faster but uses 4x more virtual memory */

#define DEFER_BP (!MultiMatches) /* defer computation of DP backpointer (G,T,H) to allow recurrance to be faster (no branch penalty, just a max operator) */

#define SCORE_ALLREF 1 /* average scoring function over all reference maps */

#define REFSCORE 1 /* new scoring method with Bias a function of X length and sites M only */

#define NEW 2  /* 1 : handle end outliers using local alignment if PoutlierEnd > 0.0 (works just like -local -PoutlierEnd 1 without Bias for outlier ends)
		  2 : Add Bias for outlier ends if PoutlierEnd > 0.0 (makes alignment independent of Bias factor if biasWTend = 1) */

#define RESDATA_FIX 1 /* Use updated x interval estimates to reflect changes due to -resbias and scaling (bpp) */

#define SCAN_FRATE_FIX 1 /* include -Frate*Xlengths in LL when doing per-scan scaling */

#define WITH_RESBIAS 1 /* Specify REFDEBUG debugging test case (0 = assertion without -resbias, 1 = asssertion failure with -resbias) */

#define SDDEBUG 0 /* more detailed output of SD,SF,SR,SE based logLR() updates */

#define RESBIAS_DEBUG 1 /* extra field origx added to Cinterval and used in debugging code */

#define REFDEBUG ((DEBUG>=3 && REFSCORE && SIMPLE_BIAS && FAST_OUTLIER) ? (SDDEBUG ? 2 : 1) : 0)

#define REFDEBUG_STRICT 0 /* Guarantee that logLR() always improves by :
			     >=1 : Estimate Kmax[] only once before first -M iteration
				   Disable lookahead in -resEstimate (see resLL())
                             >=2 : Restrict C scaling factor to values <= 1.0 (see NOTE at Cscale declaration in refalign_allpairs)
			           Disable bounding of error parameters
			           Disable -resbias
			  */

#define EXTENDONLY 0 /* with -extendonly limit 3-D recurrance : will slow down regular case 0.5% but may speed up this case (also may change result) */

#define LOAD_ALIGNED 0 // segfaults

#include "RGentigRefScore.h"

static double origScoreThreshold = -10000.0;/* ScoreThreshold before applying -MapRate */
static double origLogPvThreshold = 10.0;/* LogPvThreshold before applying -MapRate or -TE */
 
static int origMapScale = 0;/* If query maps were rescaled */

#define ENDFIX 3 /* WAS 1 */  /* 1 : allow for sizing error at ends
				 2 : Also use ends with Sbnd() in sizing error estimation
				 3 : Also include ends with Send() in sizing error estimation, when y < C*x, for greater agreement with logLR()
			      */
#define ENDFIX2 1 /* WAS 0 */ /* more thorough, but slightly slower, checking for sizing error at ends of alignments */

#define FAST Mfast /* 1 : limit alignment to best refid,orientation and scaling from previous iteration, if score was > FAST_SCORE \
		      2 : Also limit alignment to best alignment location from previous iteration +- DELTA_Y */
#define FAST_SCORE 10.0 

#define FP_DIST err_dist /* seperately count fp and fn sites that are at least this distance from the nearest aligned site : NOT YET IMPLEMENTED */

// #define MINSITES AlignedSiteThreshold /* minimum sites for a chimeric fragment : smaller fragments are ignored since it is not possible to align them reliably */

#define PRESERVE_MAXCOV 1 /* WAS 0 */ /* With -refine avoid deleting maps if they reduce coverage anywhere below MaxCov, otherwise reduce maps in increasing order of logPV (faster) */


static int vector_warning = 0;

#if USE_MIC
#define memcpy _mm512_memcpy
#endif

extern Cmap **YYmap,**XXmap;

extern double zscore(double pvalue);

static long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0, realVmRSS = 0;
static double lastGetmem = 0.0;/* wtime() value the last time getmem() was called to update VmSize,VmRSS,VmSwap */

/** right end of match group (for array of all match groups with -MultiMatches) */
class Cmatchgroup {
public:
  int I;
  int K;
  int J;
  int R;
  int IL,KL,JL;/* originally A->IL(I,K,J) : may not match if alignment was truncated */
  RFLOAT score;/* originally A->Tscore(I,K,J) : may not match if alignment was truncated */
  double logPV;
  double maxoutlier;/* largest outlier : used to speed up MultiMatchesTotScore >= 2 by limiting to cases with maxoutlier > MultiMatchesDelta */
  int stitch;/* Only used with -RefSplitStitch : 1 IFF left end was truncated due to overlap with higher scoring matchgroup (but no further) and could still be stitched back if original matchgroup is split by RefSplit */
  RFLOAT Fscore;/* matches score or approximate truncated score : used by MultiMatchesFilter >= 2 */
};


/** consensus site linked list */
class Csite {
public:
  FLOAT loc;/**< location of site relative to left end of original reference (can extend beyond ends of reference map) */
  int I;/**< index into reference map (or -1 if site is not present on reference map, -2 if this is a map end) */
  int site;/**< index into contig */
#if DEBUG>=2
  int m;/* For I == -1, the alignment index that produced this unaligned location */
  int J;/* for I == -1, the map site that produced this unaligned location */
#endif
};

static Ccontig *gcontig = 0;

/* qsort() intcmp function to sort index m into gcontig->contig[], so that gcontig->contig[m].mapid are in ascending order */

static inline int CcontigMapidInc(int *p1, int *p2)
{
  return gcontig->contig[*p1].mapid - gcontig->contig[*p2].mapid;
}

/* qsort() intcmp function to sort Csites pointer array in ascending order of loc */
static inline int CsiteLocInc(Csite **p1, Csite **p2)
{
  FLOAT loc1 = p1[0]->loc;
  FLOAT loc2 = p2[0]->loc;
  return (loc1 > loc2) ? 1 : (loc1 < loc2) ? -1 : 0;
}

/** aligned interval statistics */
class Cinterval {
public:
  double x,y;/**< Query and Reference interval sizes that aligned with each other (includes previous -bpp,-ScanScaling & -resbias correction plus -ScaleDelta correction unless -ScaleDeltaBPP) */
  double resvar;/**< resolution error (errL*errL + errR*errR) : Only used if RES_VARIANCE >= 1*/
  double maxerr2;/* maximum value of (x-y)^^2 before interval becomes an outlier */
  //  double err;/**< normalized error (x-y)/sqrt(SF[0]*SF[0]+y*SD[0]*fabs(SD[0])+y*y*SR[0]*SR[0] + resvar*SE[0]*SE[0]) */
  double rawx;/* Query map interval size based on rawsite[0] before applying -resbias adjustments (-bpp,-ScanScaling corrections have already been applied)*/

  int refid;
  int mapid;/**< map that aligned with reference is Gmap[mapid] */
  int orientation;

  int L,R;/**< left and right end of aligned interval Gmap[mapid]->site[0][L..R] */
  short end;/**< 1 IFF this is an end interval, with sizing error term due to Sbnd(), hence no log(SF[0]*SF[0]+fabs(SD[0])*SD[0]*y+SR[0]*SR[0]*y*y+SE[0]*SE[0]*resvar) term
	       Also this term disappears if y >= C*x (eg due to scaling C < 1) 
	     */
  short stitch;/**< 0 : regular interval without stitch point
		!= 0 : this interval has an image stitch point, -1 or 1 depending on orientation of Query map */
#if REFDEBUG >= 1 || RESBIAS_DEBUG
  double origx;
#endif
};

static RFLOAT aNaN = nan("NaN");

class Cresdata {
public:
  Calign *align;/* Y == refmap[align->mapid1]->site[0] */
  int U;/* score segment in alignment (0 == left end, 1 == first internal alignment interval etc) */

  int I,K;/* interval that did NOT resolve is Y[I-K .. I] */
  int n,T;/* If n != 0 : interval that resolved is Y[I-K-n .. I-K] and its size is Yc(Y,I,K) - Yc(Y,I-K-n,T) */
  int J,m;/* If n != 0 : interval X[J-m..J] that aligned with Yc(Y,I,K) - Yc(Y,I-K-n,T) (NOTE: J is always valid to support REFDEBUG) */
  int outlier;/* If n != 0 : Force interval to be scored as outlier, or NOT (required with REFDEBUG_STRICT) */
  double x;/* If n != 0 size of interval X[J-m..J] */

  /* Following fields only valid if Ip != 0 and describe an alternate alignment with unresolved interval that is one site larger than Y[I-K..I] */
  int Ip;/* Alternate larger interval that did NOT resolve is Y[Ip-K-1 .. Ip] */
  int I1,K1,n1,T1,J1,m1;/* If n1 != 0 : original interval that resolved if Ip,K+1 is NOT used (same as I,K,n,T,J,m if I==Ip, otherwise the next aligned interval if I+1==Ip) */
  int I2,K2,n2,T2;/* If n1 != 0 : alternate interval that resolved if IP,K+1 is used with same J1,m1 (same as I,K+1,n-1,T,J,m if I==Ip, otherwise the next aligned interval reduced by 1 ref label at left end) */
  double x1;/* If n1 != 0 : corresponding size of interval X[J1-m1..J1] */

  /* NOTE 
     Let Sint  == (n ? Sint(x, Yc(Y,I,K) - Yc(Y,I-K-n,T), m,n,J,I,K,T,Y) : Sm(0,I,K,Y))
         Sintp == (n ? Sint(x, Yc(Y,Ip,K+1) - Yc(Y,I-K-n,T), m, n-1 + (Ip-I), J, Ip, K+1, T, Y) : Sm(0,Ip,K+1,Y))
         Sint1 == Sint(x1, Yc(Y,I1,K1) - Yc(Y,I1-K1-n1,T1), m1, n1, J1, I1, K1, T1, Y)
         Sint2 == Sint(x1, Yc(Y,I2,K2) - Yc(Y,I2-K2-n2,T2), m1, n2, J1, I2, K2, T2, Y)

     score is larger of the following two expressions of res,resKB (If Ip == 0, only the first expression is used) :
     
     Sint

     n1 ? Sintp + Sint2 - Sint1 : Sm(0,Ip,K+1,Y) + FnPenalty

  */
  Cresdata()
  {
    if(DEBUG>=2){
      align = NULL;
      U = I = K = n = T = J = m = -999;
      outlier = -1;
      Ip = -999;
      I1 = K1 = n1 = T1 = J1 = m1 = -999;
      I2 = K2 = n2 = T2 = -999;
      
      x = x1 = aNaN;
    }
  }
};

static lightweight_heap *rs_heap = NULL;

static CHashMatch *hashpairs1 = 0, *hashpairs2 = 0;
static CHashMatch *nexthash1 = 0, *nexthash2 = 0;/* nexthash1 points into hashpairs1[0..numhashpairs1-1] to the next unused entry */
static size_t maxhashpairs1 = 0, maxhashpairs2 = 0;
static size_t numhashpairs1 = 0, numhashpairs2 = 0;

static int refid1 = -1, refid2 = -1;/* current and next scheduled first index into refmap[] (last index used is returned by loadhash2()) */
static CHashMatch **hashmatch1 = 0, **hashmatch2 = 0;/* hashmatch1[mapid=0..nummaps-1] points to the first location in hashpairs1[] for HashTable matches for (refid1,mapid) */

static int *YidListMem = NULL;
static int *YidList1 = 0, *YidList2 = 0;
static int *XidList1 = 0, *XidList2 = 0;
static CHashMatch **phashListMem = NULL;
static CHashMatch **phashList1 = 0, **phashList2 = 0;
static int NumPair1 = 0, NumPair2 = 0, MaxPair = 0;/* HERE : try changing to size_t to reduce warnings */
static int refidend1 = -1, refidend2 = -1;/* current and next scheduled index range into refmap[] are refid1..refidend1 and refid2..refidend2 respectively */

static int BinaryFormat = 0;    
static FILE *HashFP = NULL;
static size_t MatchMax = 0;
static size_t totalhashpairs = 0;

static void maxhashalloc(size_t num, size_t numhashpairs, size_t &maxhashpairs, CHashMatch * &hashpairs)
{
  size_t newmax = num;
  if(newmax <= maxhashpairs)
    return;
  if(maxhashpairs > 0 && newmax < maxhashpairs * 2)
    newmax = maxhashpairs * 2;

  if(VERB && HASH_DEBUG){
    printf("maxhashalloc:&hashpairs=%p,hashpairs=%p,maxhashpairs=%llu->%llu, size=%llu bytes\n",&hashpairs, hashpairs,(unsigned long long)maxhashpairs,(unsigned long long)newmax,(unsigned long long)newmax*sizeof(CHashMatch));
    fflush(stdout);
  }

  if(maxhashpairs <= 0)
    hashpairs = new CHashMatch[newmax+1];
  else {
    CHashMatch *orighashpairs = hashpairs;
    hashpairs = new CHashMatch[newmax+1];
    for(size_t i = 0; i < numhashpairs; i++)
      hashpairs[i] = orighashpairs[i];
    hashpairs[numhashpairs].id1 = 0;
    delete [] orighashpairs;
  }
  maxhashpairs = newmax;
  if(VERB && HASH_DEBUG){
    printf("maxhashalloc:hashpairs=%p,maxhashpairs=%llu: wall time=%0.6f secs\n",hashpairs,(unsigned long long)maxhashpairs, wtime());
    fflush(stdout);
  }
}

static int alignidLogPVDec(size_t *p1, size_t *p2)
{
  size_t alignid1 = *p1;
  size_t alignid2 = *p2;
  double logPV1 = alignment[alignid1]->logPV;
  double logPV2 = alignment[alignid2]->logPV;
  
  return (logPV1 < logPV2) ? 1 : (logPV1 > logPV2) ? -1 : 0;
}

static int SVQrystartposInc(xmapEntry **pp1, xmapEntry **pp2)
{
  double start1 = pp1[0]->qrystartpos;
  double start2 = pp2[0]->qrystartpos;
  double end1 = pp1[0]->qryendpos;
  double end2 = pp2[0]->qryendpos;
  double left1 = min(start1,end1);
  double left2 = min(start2,end2);
  double right1 = max(start1,end1);
  double right2 = max(start2,end2);
  return (left1 > left2) ? 1 : (left1 < left2) ? -1 : 
    (right1 > right2) ? 1 : (right1 < right2) ? -1 : 0;
}

// #include "qsort.c"

/* qsort() intcmp function to sort CHashMatch array in increasing order of id2,orientation,(-hashscore),offset */
static inline int ChashIdInc(CHashMatch *p1, CHashMatch *p2)
{
  return CHashMatchIncId1(p1,p2);
}


/** load data into specified hash buffer (hashpairs[0..numhashpairs-1], plus a invalid entry at hashpairs[numhashpairs]) 
    Then copy hashtable entries to YidList[],XidList[],pHashList[] until we have MaxPair Entries (or we reach end of hashtable).
    First expected refid value (on YidList[]) is specified.
    Make sure not to start new refid value (on YidList[]) unless all mapid values are available and will fit in XidList[] : Return last refid value processed (or -1 if none) */
static int loadhash2(int refid, int nummaps, CHashMatch* &nexthash, CHashMatch *&hashpairs, size_t &numhashpairs, size_t &maxhashpairs, int *YidList, int *XidList, CHashMatch **phashList, int &NumPair)
{
  if(DEBUG) assert(BinaryFormat && HashFP);

  if(VERB>=2 && HASH_DEBUG){
    printf("loadhash2(refid=%d,nummaps=%d,hashpairs=%p(hashpairs1=%p,hashpairs2=%p),nexthash=%lu,numhashpairs=%lu/%lu):numhashpairs2=%lu: starting\n",
	   refid,nummaps,hashpairs,hashpairs1,hashpairs2,nexthash-hashpairs,numhashpairs,maxhashpairs,numhashpairs2);
    fflush(stdout);
  }

  /* check if the 2nd buffer already has the data we need */
  if(hashpairs == hashpairs1 && refid == refid2 && refidend2 >= refid2 ){/* just swap the two buffers */
    if(VERB && HASH_DEBUG){
      #pragma omp critical
      {
	if(nexthash2 < &hashpairs2[numhashpairs2])
	  printf("Swapping Buffers: Matches1=%llu/%llu,NumPair1=%d,refid1=%d..%d, Matches2=%llu/%llu(id1=%lld..%lld,id2=%lld..%lld),NumPair2=%d,refid2=%d..%d, refid=%d: CPU time=%0.6f, wall time=%0.6f\n",
		 (unsigned long long)(&hashpairs1[numhashpairs1]-nexthash1), (unsigned long long)numhashpairs1, NumPair1,refid1, refidend1, 
		 (unsigned long long)(&hashpairs2[numhashpairs2]-nexthash2), (unsigned long long)numhashpairs2, 
		 (long long)nexthash2->id1,(long long)hashpairs2[numhashpairs2-1].id1,
		 (long long)nexthash2->id2,(long long)hashpairs2[numhashpairs2-1].id2, 
		 NumPair2, refid2, refidend2, refid, mtime(), wtime());
	else
	  printf("Swapping Buffers: Matches1=%llu/%llu,NumPair1=%d,refid1=%d..%d, Matches2=%llu/%llu,NumPair2=%d,refid2=%d..%d, refid=%d: CPU time=%0.6f, wall time=%0.6f\n",
		 (unsigned long long)(&hashpairs1[numhashpairs1]-nexthash1), (unsigned long long)numhashpairs1, NumPair1,refid1, refidend1, 
		 (unsigned long long)(&hashpairs2[numhashpairs2]-nexthash2), (unsigned long long)numhashpairs2, NumPair2, refid2, refidend2, refid, mtime(), wtime());
	fflush(stdout);
      }
    }

    /* there should be no data left in 1st buffer */
    if(DEBUG) assert(nexthash1 == &hashpairs1[numhashpairs1]);
    if(DEBUG) assert(YidList == YidList1 && XidList == XidList1 && phashList == phashList1);
    if(DEBUG) assert(NumPair1 == 0);
    
    /* swap the two sets of buffers */
    CHashMatch *hashtmp = hashpairs1; hashpairs1 = hashpairs2; hashpairs2 = hashtmp;
    hashtmp = nexthash1; nexthash1 = nexthash2; nexthash2 = hashtmp;
    if(DEBUG) assert(maxhashpairs1 == maxhashpairs2);
    size_t tmpSize = numhashpairs1; numhashpairs1 = numhashpairs2; numhashpairs2 = tmpSize;

    int *tmpList = YidList1; YidList1 = YidList2; YidList2 = tmpList;
    tmpList = XidList1; XidList1 = XidList2; XidList2 = tmpList;
    CHashMatch **phashtmp = phashList1; phashList1 = phashList2; phashList2 = phashtmp;
    int tmpPair = NumPair1;NumPair1 = NumPair2; NumPair2 = tmpPair;

    refid1 = refid2; refid2 = -1;
    refidend1 = refidend2; refidend2 = -1;

    /* NOTE : there will sometimes be surplus data in hashpairs1[] starting at nexthash1 that is not in YidList1[],XidList1[],phashList1[] */

    return refidend1;
  }
  
  if(DEBUG) assert(nexthash2 == &hashpairs2[numhashpairs2]);/* there should be no data left in 2nd buffer */

  if(hashpairs==hashpairs1){
    CHashMatch *end1 = &hashpairs1[numhashpairs1];
    if(nexthash1 < end1 && nexthash1 > hashpairs1){/* copy surplus data in 1st buffer to start of buffer : should happen rarely */
      if(VERB && HASH_DEBUG){
	#pragma omp critical
	{
	  printf("copying %llu entries from hashpairs1[%llu..%llu] to hashpairs1[0..%llu] (id1=%lld..%lld,id2=%lld..%lld): cpu time=%0.6f, wall time=%0.6f secs\n",
		 (unsigned long long)(end1-nexthash1), (unsigned long long)(nexthash1-hashpairs1), (unsigned long long)(end1-hashpairs1)-1, (unsigned long long)(end1-nexthash1)-1, 
		 (long long)nexthash1->id1, (long long)end1[-1].id1, (long long)nexthash1->id2, (long long)end1[-1].id2, mtime(), wtime());
	  fflush(stdout);
	}
      }

      int len = end1-nexthash1;

#ifndef VALGRIND
      if(USE_MIC ? (nexthash1 - hashpairs1)*sizeof(CHashMatch) >= 512 : (nexthash1-hashpairs1) >= len)
	memcpy(hashpairs1, nexthash1, len * sizeof(CHashMatch));
      else
#endif
	memmove(hashpairs1, nexthash1, len * sizeof(CHashMatch));

      numhashpairs1 = len;
      nexthash1 = hashpairs1;

      hashpairs1[numhashpairs1].id1 = -1;    /* initialize invalid entry at hashpairs[numhashpairs] */
    }
  }

  if(hashpairs==hashpairs2){
    CHashMatch *end1 = &hashpairs1[numhashpairs1];
    if(nexthash1 < end1){/* copy surplus data in 1st buffer to start of 2nd buffer : This happens only during multi-threaded section */
      if(VERB && HASH_DEBUG){
	#pragma omp critical
	{
	  printf("copying %llu entries from hashpairs1[%llu..%llu] to hashpairs2[0..%llu] (id1=%lld..%lld,id2=%lld..%lld): cpu time=%0.6f, wall time=%0.6f secs\n",
		 (unsigned long long)(end1-nexthash1), (unsigned long long)(nexthash1-hashpairs1), (unsigned long long)(end1-hashpairs1)-1, (unsigned long long)(end1-nexthash1)-1, 
		 (long long)nexthash1->id1, (long long)end1[-1].id1, (long long)nexthash1->id2, (long long)end1[-1].id2, mtime(), wtime());
	  fflush(stdout);
	}
      }
      size_t len = end1-nexthash1;
      memcpy(hashpairs2, nexthash1, len * sizeof(CHashMatch));
      numhashpairs2 = len;
      nexthash2 = hashpairs2;
      numhashpairs1 = 0;
      nexthash1 = hashpairs1;

      hashpairs2[numhashpairs2].id1 = -1;    /* initialize invalid entry at hashpairs[numhashpairs] */
    }
  }
  
  /* update refid1 or refid2 */
  if(hashpairs==hashpairs1){
    refid1 = refid;
    refidend1 = -1;
  } else {
    if(DEBUG) assert(hashpairs==hashpairs2);
    refid2 = refid;
    refidend2 = -1;
  }

  /* first fill up current buffer with data from HashFP */
  int HashEof = hash_eof(HashFP);
  if(HashEof && numhashpairs <= 0)
    return -1;

  size_t cur = numhashpairs;/* entries left */
  size_t num = maxhashpairs - numhashpairs;/* space left */
  int id1max = numhashpairs <= 0 ? -1 : hashpairs[numhashpairs-1].id1;

  while(!HashEof){
    int linecnt = 0;/* Not Used for Binary File input */
    if(VERB && HASH_DEBUG){
      #pragma omp critical
      {
	printf("loadhash2(refid=%d):numhashpairs=%llu,maxhashpairs=%llu,num=%llu:Calling hash_read(Hash,0,&hashpairs[numhashpairs],num,linecnt):CPU time=%0.6f, wall time=%0.6f secs\n",
	       refid,(unsigned long long)numhashpairs,(unsigned long long)maxhashpairs,(unsigned long long)(maxhashpairs - numhashpairs),mtime(),wtime());
	fflush(stdout);
      }
    }
    numhashpairs += hash_read(HashFP, 0, &hashpairs[numhashpairs], num, linecnt);
    HashEof = hash_eof(HashFP);
    if(VERB && HASH_DEBUG && numhashpairs > cur){
      #pragma omp critical
      {
	printf("loadhash2(refid=%d):Read in next %llu Matches (total=%llu/%llu) (EOF=%d) into hashpairs%d[]: cpu time=%0.6f, wall time=%0.6f secs (totalhashpairs=%llu,cur=%llu,nexthash=%llu,numhashpairs=%llu,id1=%lld..%lld,id2=%lld..%lld)\n", 
	       refid,(unsigned long long)(numhashpairs-cur), (unsigned long long)(totalhashpairs + numhashpairs - cur), (unsigned long long)MatchMax, HashEof, hashpairs==hashpairs1 ? 1 : 2, mtime(), wtime(), 
	       (unsigned long long)totalhashpairs,(unsigned long long)cur,(unsigned long long)(nexthash-hashpairs),(unsigned long long)numhashpairs,
	       (long long)nexthash->id1, (long long)hashpairs[numhashpairs-1].id1, (long long)nexthash->id2, (long long)hashpairs[numhashpairs-1].id2);
	for(size_t i = cur; i < numhashpairs; i++)
	  if(XXmap[hashpairs[i].id2]->id == MAP_TRACE){
	    printf("hashpairs[%llu]:id1=%d(%lld),id2=%d(%lld),orientation=%d,offset=%d,hashscore=%d\n",
		   (unsigned long long)i,hashpairs[i].id1,YYmap[hashpairs[i].id1]->id,hashpairs[i].id2,XXmap[hashpairs[i].id2]->id,
		   hashpairs[i].orientation,hashpairs[i].offset,hashpairs[i].hashscore);
	    fflush(stdout);
	  }
	fflush(stdout);
      }
    }
    id1max = hashpairs[numhashpairs-1].id1;

    if(DEBUG>=2){    /* check if hash pairs are in ascending order of id1,id2,orientation,(-hashscore),offset */
      size_t i;
      for(i = 1; i < numhashpairs; i++)
	if(ChashIdInc(&hashpairs[i-1],&hashpairs[i]) > 0)
	  break;
      if(i < numhashpairs){
	printf("Hashtable must be sorted in ascending order of id1,id2,orientation,offset\n");
	printf("totalhashpairs=%llu,numhashpairs=%llu,cur=%llu\n",(unsigned long long)totalhashpairs,(unsigned long long)numhashpairs,(unsigned long long)cur);
	for(size_t j = i-1; j <= i; j++)
	  printf("hashpairs[%llu]:id1=%lld,id2=%lld,orientation=%d,offset=%d\n",(unsigned long long)j,(long long)hashpairs[j].id1,(long long)hashpairs[j].id2,hashpairs[j].orientation,hashpairs[j].offset);
	fflush(stdout);exit(1);
      }
    }

    /* remove entries with score < hash_threshold */
    size_t j = cur;
    for(size_t i = cur; i < numhashpairs; i++){
      if(hashpairs[i].hashscore < hash_threshold)
	continue;
      hashpairs[j++] = hashpairs[i];
    }
    totalhashpairs += numhashpairs - cur;
    if(VERB && HASH_DEBUG && j < numhashpairs){
      #pragma omp critical
      {
	printf("Reduced matches from %llu to %llu due the hashscore < %d\n",(unsigned long long)numhashpairs, (unsigned long long)j, hash_threshold);
	fflush(stdout);
      }
    }
    numhashpairs = j;

    hashpairs[numhashpairs].id1 = -1;    /* initialize invalid entry at hashpairs[numhashpairs] */

    if(!HASH_FILL)
      break;

    cur = numhashpairs;
    num = maxhashpairs - numhashpairs;
    if(num * (HASH_FILL+1) < maxhashpairs)
      break;
  }

  CHashMatch *orignext = nexthash;
  if(VERB && HASH_DEBUG){
    #pragma omp critical
    {
      printf("refid=%d:nexthash= &hashpairs%d[%llu],hashpairs[numhashpairs-1].id1=%d,id1max=%d\n",
	     refid,hashpairs==hashpairs1 ? 1 : 2, (unsigned long long)(nexthash-hashpairs), hashpairs[numhashpairs-1].id1,id1max);
      fflush(stdout);
    }
  }

  /* use data in current buffer to create YidList[], XidList[], phashList[] */
  if(DEBUG && hashpairs == hashpairs1) assert(NumPair1 == 0);
  if(DEBUG && hashpairs == hashpairs2) assert(NumPair2 == 0);

  CHashMatch *end = &hashpairs[numhashpairs];
  if(DEBUG && nexthash < end && !(nexthash->id1 >= refid)){
    printf("refid=%d:nexthash= &hashpairs%d[%llu],end-nexthash=%llu,nexthash->id1=%d,refid1=%d,refid2=%d\n",
	   refid,hashpairs==hashpairs1 ? 1 : 2, (unsigned long long)(nexthash-hashpairs), (unsigned long long)(end-nexthash),nexthash->id1,refid1,refid2);
    fflush(stdout);
    assert(nexthash->id1 >= refid);
  }
  int origrefid = refid;
  int mapid = -1;
  if(id1max <= nexthash->id1 && !HashEof){/* need to enlarge buffers to hold complete set of all hashmatches for nexthash->id1 */
    printf("refid=%d:nexthash->id1=%d,numhashpairs=%lu,hashpairs[numhashpairs-1].id1=%d,id1max=%d,nummaps=%d,MaxPair=%d,num=%lu,maxMatchesPerRefid=%lu\n",
	   refid,nexthash->id1,numhashpairs,hashpairs[numhashpairs-1].id1,id1max,nummaps,MaxPair,num,maxMatchesPerRefid);
    printf("loadhash2(): Increase size of hashtable buffer maxhashpairs=%lu to hold all hashtable matches from any single refid\n", maxhashpairs);
    fflush(stdout);exit(1);
  }

  int id1start = nexthash->id1;

  //  int id2max = hashpairs[numhashpairs-1].id2;
  for(NumPair= 0; NumPair < MaxPair; ){
    if(nexthash >= end-1){/* next to end of current read buffer : check if this is EOF */
      if(!HashEof && nexthash->id1 > refid){// NOTE : if !hashEof and nexthash->id1 == refid, then the last entry read with id1 == id1max > refid must have been filtered out 
	if(DEBUG>=2 && !(nexthash >= end || nexthash->id1 > refid)){
	  #pragma omp critical
	  {
	    printf("refid=%d..%d:nexthash = &hashpairs[%lu], end = &hashpairs[%lu], maxhashpairs=%lu, HashEof= %d, id1start=%d,id1max=%d, NumPair=%d/%d, nexthash->id1=%d\n",
		   origrefid,refid, nexthash - hashpairs, end - hashpairs, maxhashpairs, HashEof, id1start, id1max, NumPair, MaxPair, nexthash->id1);
	    fflush(stdout);
	    assert(nexthash >= end || nexthash->id1 > refid);/* NOTE : this should be the case since the last id1 at &end[-1] == hashpairs[numhashpairs-1] should not be copied unless HashEof */
	  }
	}
	break;/* reuse last entry in next Yid iteration since it may come in a pair of entries (both orientations) that are needed together */
      }
      /* EOF : force break out of Yid loop, unless the last entry still needs to be processed */
      if(nexthash >= end)
	break;
    }

    if(DEBUG>=2) assert(origrefid <= nexthash->id1 && nexthash->id1 < numrefmaps && refmap[nexthash->id1]->id >= 0);
    if(DEBUG>=2) assert(0 <= nexthash->id2 && nexthash->id2 < nummaps && gmap[nexthash->id2]->id >= 0);

    if(VERB && (VERB>=2 || HASH_DEBUG) && nexthash->id1 > refid){
      #pragma omp critical
      {
	printf("refid=%d..%d:nexthash= &hashpairs[%lu]:id1=%d,NumPair=%d/%d\n",origrefid,refid,nexthash-hashpairs,nexthash->id1,NumPair,MaxPair);
	fflush(stdout);
      }
    }

    /* don't start a new refid (id1) unless we can complete all mapid (id2) values for this new refid  : this is typically handled at end of loop by backtracking, to avoid terminating prematurely */
    if(!HashEof && nexthash->id1 >= id1max) {/* last id will be incomplete unless HashEof==1 */
      if(VERB && (VERB>=2 || HASH_DEBUG)){
	#pragma omp critical
	{
	  printf("refid=%d..%d:nexthash->id1=%d,end-nexthash=%llu,nummaps=%d,MaxPair=%d,NumPair=%d\n",
		 origrefid,refid,nexthash->id1,(unsigned long long)(end-nexthash),nummaps,MaxPair,NumPair);
	  fflush(stdout);
	}
      }
      if(DEBUG && !(nexthash->id1 > refid)){
	#pragma omp critical
	{
	  printf("refid=%d..%d:nexthash->id1=%d,id1max=%d,end-nexthash=%llu,numhashpairs=%llu/%llu,nexthash-hashpairs=%llu,orignexthash-hashpairs=%llu,nummaps=%d,MaxPair=%d,NumPair=%d\n",
		 origrefid,refid,nexthash->id1,id1max,(unsigned long long)(end-nexthash),(unsigned long long)numhashpairs, (unsigned long long)((hashpairs==hashpairs1) ? maxhashpairs1 : maxhashpairs2),
		 (unsigned long long)(nexthash-hashpairs),(unsigned long long)(orignext-hashpairs),nummaps,MaxPair,NumPair);
	  fflush(stdout);
	  assert(nexthash->id1 > refid);
	}
      }
      break;
    }

    YidList[NumPair] = refid = nexthash->id1;
    XidList[NumPair] = mapid = nexthash->id2;

    phashList[NumPair++] = nexthash++;

    /* skip all subsequent entries in hashtable with the same pair of maps as lastYid,lastXid :
       This happens when both orientation or different offsets are in the HashTable */
    while(nexthash < end && nexthash->id1 == refid && nexthash->id2 == mapid)
      nexthash++;
  }

  /* make sure last refid is complete (can be incomplete if NumPair >= MaxPair) */
  if(DEBUG && !HashEof) assert(nexthash < end || (nexthash[-1].id1 <= refid && id1max > refid));
			       
  if((!HashEof || nexthash < end) && nexthash > orignext && NumPair >= MaxPair){/* need to undo last incomplete refid */
    if(DEBUG) assert(refid > origrefid);
    int id1 = nexthash->id1;
    if(DEBUG) assert(id1 == refid);
    while(nexthash[-1].id1 >= id1)
      nexthash--;
    while(NumPair > 0 && YidList[NumPair-1] >= refid)
      NumPair--;
    refid--;
  }
  if(VERB && HASH_DEBUG){
    #pragma omp critical
    {
      printf("Used %llu/%llu matches from hashpairs%d[%llu..%llu] to create YidList[],XidList[] with nummaps=%d: NumPair=%d/%d alignments for refid=%d..%d, nexthash=%llu(id1=%d,id2=%d): cpu time=%0.6f, wall time=%0.6f\n", 
	     (unsigned long long)(nexthash-orignext), (unsigned long long)(end-orignext), hashpairs==hashpairs1 ? 1 : 2, (unsigned long long)(orignext-hashpairs), (unsigned long long)(end-hashpairs) -1, 
	     nummaps, NumPair, MaxPair, origrefid, refid, (unsigned long long)(nexthash-hashpairs), nexthash->id1, nexthash->id2, mtime(), wtime());
      fflush(stdout);
    }
  }
  if(DEBUG && nexthash < end && nexthash > orignext) assert(id1max > nexthash[-1].id1);

  if(DEBUG>=2){
    for(int i = 0; i < NumPair; i++){
      int rid = YidList[i];
      assert(origrefid <= rid && rid <= refid);
    }
  }

  /* update refidend1 or refidend2 */
  if(hashpairs==hashpairs1){
    refidend1 = refid;
  } else {
    if(DEBUG) assert(hashpairs==hashpairs2);
    refidend2 = refid;
  }

  return refid;
}

static int CmatchgroupScoreDec(Cmatchgroup *p1, Cmatchgroup *p2)
{
  RFLOAT score1 = p1->score;
  RFLOAT score2 = p2->score;

  return (score1 < score2) ? 1 : (score1 > score2) ? -1 : 0;
}

static inline int CalignLogPVDec(Calign **pp1, Calign **pp2)
{
  double logPV1 = pp1[0]->logPV;
  double logPV2 = pp2[0]->logPV;

  return (logPV1 < logPV2) ? 1 : (logPV1 > logPV2) ? -1 : 0;
}

static inline int CalignQryIncLogpvDec(Calign **pp1, Calign **pp2)
{
  Calign *p1 = pp1[0];
  Calign *p2 = pp2[0];

  int qryid1 = XXmap[p1->mapid2]->id;
  int qryid2 = XXmap[p2->mapid2]->id;

  if(qryid1 > qryid2) 
    return 1;
  if(qryid1 < qryid2)
    return -1;

  if(p1->logPV < p2->logPV)
    return 1;
  if(p1->logPV > p1->logPV)
    return -1;
  
  if(p1->score < p2->score)
    return 1;
  if(p1->score > p2->score)
    return -1;

  return 0;
}

static inline int CalignSiteRangeDec(Calign **pp1, Calign **pp2)
{
  Calign *p1 = pp1[0];
  Calign *p2 = pp2[0];
  int U1 = p1->numpairs;
  int U2 = p2->numpairs;
  int range1 = max(p1->sites1[U1 - 1] - p1->sites1[0], p1->sites2[U1 - 1] - p2->sites2[0]);
  int range2 = max(p2->sites1[U2 - 1] - p2->sites1[0], p2->sites2[U2 - 1] - p2->sites2[0]);

  return (range1 < range2) ? 1 : (range1 > range2) ? -1 : 0;
}

static inline int CalignRefSiteInc(Calign **pp1, Calign **pp2)
{
  Calign *p1 = pp1[0];
  Calign *p2 = pp2[0];
  int U1 = p1->numpairs;
  int U2 = p2->numpairs;
  int I1 = p1->sites1[0] - p1->sitesK1[0] + p1->sites1[U1-1];
  int I2 = p2->sites1[0] - p2->sitesK1[0] + p2->sites1[U2-1];

  return I1 - I2;
}

static inline int CalignScoreDec(Calign **pp1, Calign **pp2)
{
  double score1 = pp1[0]->score;
  double score2 = pp2[0]->score;

  return (score1 < score2) ? 1 : (score1 > score2) ? -1 : 0;
}

static inline int CalignMapidInc(Calign **pp1, Calign **pp2)
{
  int id1 = pp1[0]->mapid2;
  int id2 = pp2[0]->mapid2;

  return (id1 > id2) ? 1 : (id1 < id2) ? -1 : 0;
}

static int ErrorRawxInc(Cinterval *p1, Cinterval *p2)
{
  return (p1->rawx > p2->rawx) ? 1 : (p1->rawx < p2->rawx) ? -1 : 0;
}

/* Sort in ascending order of mapid, L */
static int ErrorIdInc(Cinterval *p1, Cinterval *p2)
{
  return (p1->mapid > p2->mapid) ? 1 : (p1->mapid < p2->mapid) ? -1 :
    (p1->L > p2->L) ? 1 : (p1->L < p2->L) ? -1 : 0;
}

static int DoubleInc(double *p1, double *p2)
{
  double val1 = *p1;
  double val2 = *p2;
  return (val1 > val2) ? 1 : (val1 < val2) ? -1 : 0;
}

static int CmapIdInc(Cmap **p1, Cmap **p2)
{
  /* Cannot return p1[0]->id - p2[0]->id since that may be out of range for integer */
  return (p1[0]->id > p2[0]->id) ? 1 : (p1[0]->id < p2[0]->id) ? -1 : 0;
}

static int logPVdec(Calign **p1, Calign **p2)
{
  Calign *align1 = p1[0];
  Calign *align2 = p2[0];
  return (align1->logPV < align2->logPV) ? 1 : (align1->logPV > align2->logPV) ? -1 : 0;
}

class CmapPv {
public:
  int contigid;/**< index into gcontig->contig[] */
  double LogPv;
  int discard;
};

static int mapPVinc(CmapPv *p1, CmapPv *p2)
{
  if(p1->LogPv > p2->LogPv)
    return 1;
  if(p1->LogPv < p2->LogPv)
    return -1;
  int mapid1 = Gmap[gcontig->contig[p1->contigid].mapid]->mapid;
  int mapid2 = Gmap[gcontig->contig[p2->contigid].mapid]->mapid;
  if(DEBUG>=2) assert(mapid1 != mapid2);
  return (mapid1 > mapid2) ? 1 : (mapid1 < mapid2) ? -1 : 0;
}

static RFLOAT ChimScore = MINSCORE;

/* compute log Likelihood for current res & resSD */
static double resLL(Cresdata *resdata, int numresdata, int numthreads, double *Tarray1, int verb)
{
  if(VERB>=2 || verb){
    printf("resLL:numresdata=%d,res=%0.6f,resSD=%0.6f\n",numresdata,res[0],resSD[0]);
    fflush(stdout);
  }

  /* update score_init() parameters resKB and IresSD */
  resKB = res[0] * PixelLen;
  IresSD = 1.0/(resSD[0] * PixelLen * sqrt(2.0));

  double Lsum = 0.0;
  for(int tid = 0; tid < numthreads; tid++)
    Tarray1[tid] = 0.0;
      
  #pragma omp parallel num_threads(numthreads) if(numthreads > 1 && !verb)
  {
    int tid = 0;
#ifdef _OPENMP
    tid = omp_get_thread_num ();
#endif

    double myLsum = 0.0;

#if !USE_MIC
    #pragma omp for schedule(static,64)
#endif
    for(int i = 0; i < numresdata; i++){
      if(USE_MIC && !(((i / 64) % numthreads) == tid)){ // NOTE : simulates #prama omp for schedule(static,64)
        continue;
      }

      Cresdata *pres = &resdata[i];
      Calign *align = pres->align;
      int refid = align->mapid1;
      int mapid = align->mapid2;
      if(DEBUG>=2) assert(0 <= refid && refid < numrefmaps);
      if(DEBUG>=2 && !(0 <= mapid && (mapid < nummaps || (startmaps <= mapid && mapid < totalmaps)))){
	printf("resdata[%d]:align->mapid1=%d,numrefmaps=%d\n",i,resdata[i].align->mapid1,numrefmaps);
	fflush(stdout);
	assert(0 <= mapid && (mapid < nummaps || (startmaps <= mapid && mapid < totalmaps)));
      }
      int orientation = align->orientation;
      FLOAT *Y = refmap[refid]->site[0];
      double LL1 = pres->n ? 
	(REFDEBUG_STRICT ? 
	 Sint(pres->x, Yc(Y,pres->I,pres->K) - Yc(Y,pres->I - pres->K - pres->n, pres->T), pres->m, pres->n, pres->J, pres->I, pres->K, pres->T, Y, pres->outlier) : 
	 Sint(pres->x, Yc(Y,pres->I,pres->K) - Yc(Y,pres->I - pres->K - pres->n, pres->T), pres->m, pres->n, pres->J, pres->I, pres->K, pres->T, Y)) : 
	Sm(0,pres->I,pres->K,Y);
      double LL2 = -1e+10;
      LL1 = max(LL2,LL1);
      if(!REFDEBUG_STRICT && pres->Ip > 0){
	if(DEBUG) assert(pres->Ip == pres->I || pres->Ip == pres->I + 1);
	if(pres->n1){
	  double Sintp = pres->n ? 
	    Sint(pres->x, Yc(Y,pres->Ip,pres->K + 1) - Yc(Y,pres->I - pres->K - pres->n, pres->T), pres->m, pres->n - 1 + pres->Ip - pres->I, pres->J, pres->Ip, pres->K + 1, pres->T, Y) : 
	    Sm(0, pres->Ip, pres->K + 1, Y);
	  //	  double Sint1 = Sint(pres->x1, Yc(Y,pres->I2,pres->K2) - Yc(Y,pres->I2 - pres->K2 - pres->n2, pres->T2), pres->m1, pres->n2, pres->J1, pres->I2, pres->K2, pres->T2, Y);
	  //	  double Sint2 = Sint(pres->x1, Yc(Y,pres->I1,pres->K1) - Yc(Y,pres->I1 - pres->K1 - pres->n1, pres->T1), pres->m1, pres->n1, pres->J1, pres->I1, pres->K1, pres->T1, Y);
	  //	  LL2 = max(LL2,Sintp) + max(LL2,Sint1) - max(LL2,Sint2);
	  double Sint1 = Sint(pres->x1, Yc(Y,pres->I1,pres->K1) - Yc(Y,pres->I1 - pres->K1 - pres->n1, pres->T1), pres->m1, pres->n1, pres->J1, pres->I1, pres->K1, pres->T1, Y);
	  double Sint2 = Sint(pres->x1, Yc(Y,pres->I2,pres->K2) - Yc(Y,pres->I2 - pres->K2 - pres->n2, pres->T2), pres->m1, pres->n2, pres->J1, pres->I2, pres->K2, pres->T2, Y);
	  LL2 = max(LL2,Sintp) + max(LL2,Sint2) - max(LL2,Sint1);
	} else {
	  double Sm2 = Sm(0, pres->Ip, pres->K + 1, Y) + FnPenalty;
	  LL2 = max(LL2, Sm2);
	}
      }
      myLsum += max(LL1,LL2);

      LFLOAT Pen = 0.0;
      if(REFDEBUG_STRICT && pres->U == 0){/* duplicate code from logLR() for left end score */
	FLOAT *X = Gmap[mapid]->site[0];
	int M = Gmap[mapid]->numsite[0];
	int I = pres->I;
	int K = pres->K;
	int J = pres->J;
	int Lij = align->Lij1;
	int Lijx = align->Lij2;
	LFLOAT scale = ScaleDeltaBPP ? 1.0 : (align->scaleID > 1) ? ScaleFactor[align->scaleID] : 1.0;

	LFLOAT x = scale * ((orientation==0) ? X[J] : X[M+1] - X[M+1 - J]);
	LFLOAT xLijx_1 = (Lijx <= 0) ? 0.0 : scale * ((align->orientation==0) ? X[Lijx-1] : X[M+1] - X[M+1-(Lijx-1)]);

	int n = I - K - Lij + 1;
	int m = J;
	if(DEBUG>=2) assert(n >= 1);
	if(DEBUG>=2) assert(m >= 1);

	LFLOAT xB = max(LZERO, x - resKB2);
	if(VERB>=2 && verb)
	  printf("\t M=%d,I=%d,K=%d,J=%d,Lij=%d,scale=%0.4f,x=%0.3f,n=%d,m=%d,xB=%0.3f:Yc(I,K)=%0.3f,",M,I,K,J,Lij,scale,x,n,m,xB,Yc(Y,I,K));

	if(align->Lend <= -2){/* end outlier */
	  Pen = ChimScore;
	} else if(ENDFIX && x <= Yc(Y,I,K) && Lij > 0 && Yc(Y,I,K)-Y[Lij-1] < x){ /* Sbnd(x,Y[I,K]-Y[Lij-1],m,n) : NOTE RES_VARIANCE is ignored */
	  LFLOAT y = Yc(Y,I,K)-Y[Lij-1];
	  LFLOAT var = QUADRATIC_VARIANCE ? (SF[0]*SF[0] + fabs(SD[0])*SD[0]*y + SR[0]*SR[0]*y*y) : (SF[0]*SF[0] + fabs(SD[0])*SD[0]*y);
	  LFLOAT err = x-y;
	  Pen = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */ - err*err*0.5/var;
	  if(VERB>=2 && verb){
	    printf("Y[Lij-1]=%0.3f,y=%0.3f,var=%0.6f,err=%0.6f,Frate=%0.6f,FnPenalty=%0.6f,FpPenalty=%0.6f:Pen=%0.6e\n",Y[Lij-1],y,var,err,Frate,FnPenalty,FpPenalty,Pen);
	    fflush(stdout);
	  }
	} else if(ENDFIX && extend && x >= Yc(Y,I,K) && Lijx > 0 && x - xLijx_1 < Yc(Y,I,K)){/* Sbnd(x-xLijx_1, Yc(Y,I,K), J+1-Lijx, I-K) */
	  LFLOAT y = Yc(Y,I,K);
	  LFLOAT var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
	  if(QUADRATIC_VARIANCE)
	    var += SR[0]*SR[0]*y*y;
	  x = x - xLijx_1;
	  xB = max(LZERO,x-resKB2);
	  LFLOAT err = x - y;
	  m = J+1-Lijx;
	  n = I-K;
	  if(DEBUG>=2) assert(m >= 1);
	  if(DEBUG>=2) assert(n >= 1);
	  Pen = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */ - err*err*0.5/var;
	} else { /* Send(min(x,Yc(Y,I,K)),J+1-max(1,Lijx),I-K+1 - max(1,Lij)) */
	  if(extend){
	    x = min(x,Yc(Y,I,K));
	    xB = max(LZERO,x-resKB2);
	    m = J+1-max(1,Lijx);
	    n = I-K+1 - max(1,Lij);
	    if(DEBUG>=2) assert(m >= 1);
	    if(DEBUG>=2) assert(n >= 1);
	  }
	  Pen = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */;
	  if(VERB>=2 && verb){
	    printf("Frate=%0.6f,FnPenalty=%0.6f,FpPenalty=%0.6f:Pen=%0.6e\n",Frate,FnPenalty,FpPenalty,Pen);
	    fflush(stdout);
	  }
	}
      }
      if(REFDEBUG_STRICT && pres->U == align->numpairs - 1){/* duplicate code from logLR() for right end score */
	FLOAT *X = Gmap[mapid]->site[0];
	int M = Gmap[mapid]->numsite[0];
	int N = refmap[refid]->numsite[0];
	int H = pres->I;
	int D = pres->K;
	int G = pres->J;
	int Rij = align->Rij1;
	int Rijx = align->Rij2;
	LFLOAT scale = ScaleDeltaBPP ? 1.0 : (align->scaleID > 1) ? ScaleFactor[align->scaleID] : 1.0;
	
	LFLOAT x = scale * ((align->orientation==0) ? X[M+1]-X[G] : X[M + 1 - G]);
	LFLOAT xRijx_1 = (Rijx > M) ? 0.0 : scale * ((align->orientation==0) ? X[M+1] - X[Rijx+1] : X[M+1-(Rijx+1)]);

	int n = Rij - H + 1;
	int m = M + 1 - G;
	if(DEBUG>=2) assert(n >= 1);
	if(DEBUG>=2) assert(m >= 1);

	LFLOAT xB = max(LZERO,x-resKB2);
	if(align->Rend <= -2){/* end outier */
	  Pen = ChimScore;
	} else if(ENDFIX && x <= Y[N+1]-Yc(Y,H,D) && Rij <= N && Y[Rij+1]-Yc(Y,H,D) < x){  /* Sbnd(x,Y[Rij+1]-Yc(Y,H,D),M+1-G,Rij+1-I) */
	  LFLOAT y = Y[Rij+1]-Yc(Y,H,D);
	  LFLOAT var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y + SR[0]*SR[0]*y*y;
	  LFLOAT err = x-y;
	  Pen = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */ - err*err*0.5/var;
	} else if(ENDFIX && extend && x >= Y[N+1] - Yc(Y,H,D) && Rijx <= M && x - xRijx_1 < Y[N+1]-Yc(Y,H,D)){/* Sbnd(x-xRijx_1, Y[N+1]-Yc(Y,H,D), Rijx+1-G,min(N,Rij)+1-H) */
	  LFLOAT y = Y[N+1] - Yc(Y,H,D);
	  LFLOAT var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
	  if(QUADRATIC_VARIANCE)
	    var += SR[0]*SR[0]*y*y;
	  x = x - xRijx_1;
	  xB = max(LZERO,x-resKB2);
	  LFLOAT err = x - y;
	  m = Rijx + 1 - G;
	  n = min(N,Rij) + 1 - H;
	  if(DEBUG>=2) assert(m >= 1);
	  if(DEBUG>=2) assert(n >= 1);
	  Pen = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */ - err*err*0.5/var;
	} else {
	  if(extend){
	    x = min(x, Y[N+1]-Yc(Y,H,D));
	    xB = max(LZERO,x-resKB2);
	    m = min(M,Rijx)+1-G;
	    n = min(N,Rij)+1-H;
	    if(DEBUG>=2) assert(m >= 1);
	    if(DEBUG>=2) assert(n >= 1);
	  }
	  Pen = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */;
	}
      }
      if(REFDEBUG_STRICT)
	myLsum += Pen;

      if(VERB>=2 || verb || (DEBUG>=2 && (!(isfinite(LL2) || (LL2 < 0.0 && isinf(LL2))) || (!(isfinite(LL1) || (LL1 < 0.0 && isinf(LL1)))) || !isfinite(Pen) || !(isfinite(myLsum) || (myLsum < 0.0 && isinf(myLsum)))))){
        #pragma omp critical
	{
	  printf("mapid=%d(id=%lld),refid=%d(id=%lld),or=%d,U=%d:I=%d,K=%d,n=%d",
		 mapid,XXmap[mapid]->id,refid,YYmap[refid]->id,orientation,pres->U,pres->I,pres->K,pres->n);
	  double sm = Sm(0, pres->Ip, pres->K, Y);
	  if(pres->n){
	    double sint = (REFDEBUG_STRICT ? 
			   Sint(pres->x, Yc(Y,pres->I,pres->K) - Yc(Y,pres->I - pres->K - pres->n, pres->T), pres->m, pres->n, pres->J, pres->I, pres->K, pres->T, Y, pres->outlier) : 
			   Sint(pres->x, Yc(Y,pres->I,pres->K) - Yc(Y,pres->I - pres->K - pres->n, pres->T), pres->m, pres->n, pres->J, pres->I, pres->K, pres->T, Y));
	    printf("(T=%d,J=%d,m=%d,x=%0.3f,y=%0.3f(%0.3f ... %0.3f,%0.3f),Sint=%0.6f, Sm=%0.6f)\n",pres->T,pres->J,pres->m,pres->x,Yc(Y,pres->I,pres->K) - Yc(Y,pres->I - pres->K - pres->n, pres->T),
		   Yc(Y,pres->I - pres->K - pres->n, pres->T), Y[pres->I - pres->K], Y[pres->I], sint, sm);
	    fflush(stdout);
	    if(DEBUG && !(isfinite(sint) || (!IsNan(sint) && sint >= -1e+10))){
	      fflush(stdout);
              assert(isfinite(sint) || (!IsNan(sint) && sint >= -1e+10));
            }
	  } else
	    printf("(Sm=%0.6f)\n",sm);
	  printf("\tIp=%d",pres->Ip);
	  if(!REFDEBUG_STRICT && pres->Ip){
	    if(!pres->n1)
	      printf("(Sm=%0.6f,FnPen=%0.6f)",Sm(0, pres->Ip, pres->K + 1, Y), FnPenalty);
	    else {
	      double Sintp = pres->n ? 
		Sint(pres->x, Yc(Y,pres->Ip,pres->K + 1) - Yc(Y,pres->I - pres->K - pres->n, pres->T), pres->m, pres->n - 1 + pres->Ip - pres->I, pres->J, pres->Ip, pres->K + 1, pres->T, Y) : 
		Sm(0, pres->Ip, pres->K + 1, Y);
	      double Sint1 = Sint(pres->x1, Yc(Y,pres->I1,pres->K1) - Yc(Y,pres->I1 - pres->K1 - pres->n1, pres->T1), pres->m1, pres->n1, pres->J1, pres->I1, pres->K1, pres->T1, Y);
	      double Sint2 = Sint(pres->x1, Yc(Y,pres->I2,pres->K2) - Yc(Y,pres->I2 - pres->K2 - pres->n2, pres->T2), pres->m1, pres->n2, pres->J1, pres->I2, pres->K2, pres->T2, Y);
	      printf(",I1=%d,K1=%d,n1=%d,T1=%d,J1=%d,m1=%d,x1=%0.3f,y1=%0.3f,I2=%d,K2=%d,n2=%d,T2=%d,y2=%0.3f(Sintp=%0.6f,Sint1=%0.6f,Sint2=%0.6f)\n",
		     pres->I1,pres->K1,pres->n1,pres->T1,pres->J1,pres->m1,pres->x1,Yc(Y,pres->I1,pres->K1) - Yc(Y,pres->I1 - pres->K1 - pres->n1, pres->T1),
		     pres->I2,pres->K2,pres->n2,pres->T2,Yc(Y,pres->I2,pres->K2) - Yc(Y,pres->I2 - pres->K2 - pres->n2, pres->T2),Sintp,Sint1,Sint2);

	      double yR = Yc(Y,pres->Ip,pres->K+1), yL = Yc(Y,pres->I-pres->K-pres->n,pres->T);
	      printf("  Sintp:x=%0.6f,y=%0.6f(%0.6f - %0.6f),m=%d,n-1+Ip-I=%d,J=%d,Ip=%d,K+1=%d,T=%d\n", pres->x, yR - yL, yR, yL, pres->m, pres->n - 1 + pres->Ip - pres->I, pres->J,pres->Ip,pres->K+1,pres->T);

	      double yR1 = Yc(Y,pres->I1,pres->K1), yL1 = Yc(Y,pres->I1 - pres->K1 - pres->n1,pres->T1);
	      printf("  Sint1:x1=%0.6f,y1=%0.6f(%0.6f - %0.6f),m1=%d,n1=%d,J1=%d,I1=%d,K1=%d,T1=%d,resL=%0.4f,resR=%0.4f\n",pres->x1,yR1-yL1,yR1,yL1,pres->m1,pres->n1,pres->J1,pres->I1,pres->K1,pres->T1,
		     Y[pres->I1 - pres->K1 - pres->n1] - Y[pres->I1 - pres->K1 - pres->n1 - pres->T1], Y[pres->I1] - Y[pres->I1 - pres->K1]);

	      double yR2 = Yc(Y,pres->I2,pres->K2), yL2 = Yc(Y,pres->I2 - pres->K2 - pres->n2,pres->T2);
	      printf("  Sint2:x1=%0.6f,y2=%0.6f(%0.6f - %0.6f),m1=%d,n2=%d,J1=%d,I2=%d,K2=%d,T2=%d,resL=%0.4f,resR=%0.4f\n",
		     pres->x1,yR2-yL2,yR2,yL2,pres->m1,pres->n2,pres->J1,pres->I2,pres->K2,pres->T2, 
		     Y[pres->I2 - pres->K2 - pres->n2] - Y[pres->I2 - pres->K2 - pres->n2 - pres->T2], Y[pres->I2] - Y[pres->I2-pres->K2]);
	      Sint2 = Sint(pres->x1, Yc(Y,pres->I2,pres->K2) - Yc(Y,pres->I2 - pres->K2 - pres->n2, pres->T2), pres->m1, pres->n2, pres->J1, pres->I2, pres->K2, pres->T2, Y, true/* verbose */);
	    }
	  }
	  printf("\t LL1=%0.6f,LL2=%0.6f:LL=%0.6f,Pen=%0.6f:LLsum=%0.6f (score=%0.6f,logPV=%0.2f,numpairs=%d)\n",LL1,LL2,max(LL1,LL2),Pen,myLsum, align->score, align->logPV, align->numpairs);
	  fflush(stdout);
	  if(DEBUG>=2) assert(isfinite(LL1) || (LL1 < 0.0 && isinf(LL1)));
	  if(DEBUG>=2) assert(isfinite(LL2) || (LL2 < 0.0 && isinf(LL2)));
	  if(DEBUG>=2) assert(isfinite(Pen));
	  if(DEBUG>=2) assert(isfinite(myLsum) || (myLsum < 0.0 || isinf(myLsum)));
	}
      }
    }
    
    if(DEBUG) assert(isfinite(myLsum) || (myLsum < 0.0 || isinf(myLsum)));
    Tarray1[tid] = myLsum;
  }
  qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
  for(int tid = 0; tid < numthreads; tid++)
    Lsum += Tarray1[tid];
  
  if(VERB>=2 || verb){
    printf("resLL:numresdata=%d,res=%0.6f,resSD=%0.6f:LLsum=%0.6f\n",numresdata,res[0],resSD[0],Lsum);
    fflush(stdout);
  }
  return Lsum;
}

/* return true if number of EndOutliers <= AlignedEndOutlierThreshold */
static inline bool AlignedEndOutlier(Calign *align)
{
  int EndOutlierCnt = (align->Lend <= -2 ? 1 : 0) + (align->Rend <= -2 ? 1 : 0);
  return (EndOutlierCnt <= AlignedEndOutlierThreshold);
}

/* return true if number of EndOutliers <= AlignedEndOutlierThreshold2 */
static inline bool AlignedEndOutlier2(Calign *align)
{
  int EndOutlierCnt = (align->Lend <= -2 ? 1 : 0) + (align->Rend <= -2 ? 1 : 0);
  return (EndOutlierCnt <= AlignedEndOutlierThreshold2);
}

static inline FLOAT AlignedLength(Calign *align, FLOAT *Y)
{
  int U = align->numpairs;
  if(U <= 1)
    return 0.0;
  if(DEBUG>=2 && !(align->sites1[0] <= align->sites1[U-1])){
    printf("AlignedLength:U=%d,align->sites1[0]=%d,align->sites1[U-1]=%d\n",U,align->sites1[0],align->sites1[U-1]);
    fflush(stdout);
    assert(align->sites1[0] <= align->sites1[U-1]);
  }
  FLOAT len = Y[align->sites1[U - 1]] - Y[align->sites1[0]];
  if(DEBUG>=2 && !((U > 1) ? (len > 0.0) : (len >= 0.0))){
    printf("AlignedLength:U=%d,Y[%d]=%0.3f, Y[%d]=%0.3f: len=%0.3f\n",U,align->sites1[U-1],Y[align->sites1[U-1]],align->sites1[0],Y[align->sites1[0]],len);
    fflush(stdout);
    assert((U > 1) ? (len > 0.0) : (len >= 0.0));
  }
  return len;
}

/* return true of all alignment thresholds are satisfied */
static int AlignedThreshold(Calign *align, FLOAT *Y, double ScoreThresh = ScoreThreshold, double LogPvThresh = LogPvThreshold)
{
  if(DEBUG/* HERE HERE >=2 */ && align->numpairs > 0) assert(align->noutliers >= 0 && align->maxoutlier >= 0.0 && align->maxoutlierLabels >= 0 &&
								  (align->noutliers <= 0 || align->maxoutlier > 0.0 || align->maxoutlierLabels > 0));

  return (align->numpairs >= AlignedSiteThreshold && 
	  align->score > ScoreThresh && 
	  align->logPV > LogPvThresh && 
	  min(999.0,align->maxoutlier) <= AlignedOutlierThreshold && min(999,align->maxoutlierLabels) < AlignedOutlierLabels && 
	  AlignedEndOutlier(align) && 
	  AlignedLength(align,Y) >= AlignedLengthThreshold) ? 1 : 0;
}

static int maxerrors = 0, numerrors = 0;
static Cinterval *errors = NULL;

static int maxresdata = 0, numresdata = 0;
static Cresdata *resdata = NULL;

/* append error information of current interval to errors[0..numerrors-1] */
static void appenderror(double x,
			double y,
			double resvar,
                        double maxerr2,
			int mapid,
			int L, int R,
			int end,
			int stitch,
			int refid, Calign *align, int I, int K, int RI, int RK/* for debug only */)
{
  if(numerrors >= maxerrors){
    int newmax = max(1024,maxerrors*2);
    Cinterval *newerrors = new Cinterval[newmax];
    if(numerrors > 0){
      if(DEBUG) assert(errors != NULL);
      memcpy(newerrors,errors,numerrors*sizeof(Cinterval));
    }
    delete [] errors;
    errors = newerrors;
    maxerrors = newmax;
  }
  Cinterval *perr = &errors[numerrors++];

  perr->x = x;
  if(DEBUG>=2) assert(x > 0.0);
  perr->y = y;
  if(RES_VARIANCE)
    perr->resvar = resvar;
  if(RESBIAS_MAXERR2){
    if(DEBUG>=2 && x > y && !align->scaleID){
      double err = x - y;
      if(!(err * err <= maxerr2 * 1.01)){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:L=%d,R=%d,end=%d:x=%0.6f,y=%0.6f,err=%0.6f,maxerr=%0.6f\n",
	       refid,YYmap[refid]->id,mapid,XXmap[mapid]->id,align->orientation,align->scaleID,L,R,end,x,y,err,sqrt(maxerr2));
	//	printf("\t ScaleDelta=%d, ScaleDeltaSize= %0.6f\n",ScaleDelta,ScaleDeltaSize);
	fflush(stdout);
	assert(err * err <= maxerr2 * 1.01);
      }
    }
    perr->maxerr2 = maxerr2;
  }

  perr->refid = refid;
  perr->mapid = mapid;
  perr->orientation = align->orientation;

  perr->L = L;
  perr->R = R;
  perr->end = end;
  if(STITCH)
    perr->stitch = stitch;

  if(DEBUG>=2){
    Cmap *pmap = Gmap[mapid];
    FLOAT *X = pmap->site[0];
//    int M = pmap->numsite[0];
    if(!(fabs(X[R]-X[L] - x) <= 1e-6)){
      double err = x - y;
      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:J=%d(I=%d,K=%d),RJ=%d(RI=%d,RK=%d),end=%d:x=%0.6f,y=%0.6f,err=%0.6f,maxerr=%0.6f,X[RJ]-X[J]= %0.6f\n",
	       refid,YYmap[refid]->id,mapid,XXmap[mapid]->id,align->orientation,align->scaleID,L,I,K,R,RI,RK,end,x,y,err,sqrt(maxerr2), X[R]-X[L]);
      fflush(stdout);
      assert(fabs(X[R]-X[L] - x) <= 1e-6);
    }
  }

  if(VERB>=2 && mapid==11){
    double err = x - y;
    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:J=%d(I=%d,K=%d),RJ=%d(RI=%d,RK=%d),end=%d:x=%0.6f,y=%0.6f,err=%0.6f,maxerr=%0.6f\n",
	   refid,YYmap[refid]->id,mapid,XXmap[mapid]->id,align->orientation,align->scaleID,L,I,K,R,RI,RK,end,x,y,err,sqrt(maxerr2));
    fflush(stdout);
  }
}

static void appendres(Calign *align,
		      FLOAT *X, FLOAT *Y,
		      int M, int N, 
		      int I, int K, int J, 
		      int H, int D, int G, int T,
		      FLOAT x, double escale, int outlier
		      )
{
  if(numresdata >= maxresdata){
    int newmax = max(1024,numresdata*2);
    Cresdata *newresdata = new Cresdata[newmax];
    if(numresdata > 0){
      if(DEBUG) assert(resdata != NULL);
      memcpy(newresdata,resdata,numresdata*sizeof(Cresdata));
    }
    delete [] resdata;
    resdata = newresdata;
    maxresdata = newmax;
  }
  Cresdata *pres = &resdata[numresdata++];

  pres->align = align;
  if(DEBUG>=2) assert(0 <= align->mapid1 && align->mapid1 < numrefmaps);
  if(DEBUG>=2) assert(0 <= align->mapid2 && (align->mapid2 < nummaps || (NoSplit <= 1 && startmaps <= align->mapid2 && align->mapid2 < totalmaps)));
  if(VERB>=2){
    printf("resdata[%d]:align=%p:align->mapid1=%d,align->mapid2=%d\n",numresdata-1,pres->align,align->mapid1,align->mapid2);
    fflush(stdout);
  }

  pres->I = I;
  pres->K = K;
  pres->J = J;// to support REFDEBUG
  pres->U = T;

  FLOAT delY1 = (I-K > 1) ? Y[I-K] - Y[I-K-1] : 9999.0;
  FLOAT delY2 = (I < N) ? Y[I+1]-Y[I] : 9999.0;

  if(T <= 0){/* left end  align site */

    pres->n = 0;

    if(K >= KMAX)
      pres->Ip = 0;
    else if(delY1 < delY2){/* expand deres interval Y[I-K..I] to the left to Y[I-K-1..I] */
      pres->Ip = I;
      pres->n1 = 0;
    } else { /* expand deres interval Y[I-K..I] to the right to Y[I-K .. I+1] */
      if(align->numpairs <= T+1){/* no further aligned sites */
	if(I >= N)/* cannot expand deres interval to right, since there are no more sites */
	  pres->Ip = 0;
	else {
	  pres->Ip = I+1;
	  pres->n1 = 0;
	}
      } else {/* next aligned site is present */
	int In = align->sites1[1];
	int Kn = align->sitesK1[1];
	int Jn = align->sites2[1];
	if(I+1 >= In-Kn) /* cannot expand deres interval to right, since there is no unaligned site before next aligned site */
	  pres->Ip = 0;
	else {
	  pres->Ip = I+1;
	  
	  /* original resolved interval */
	  pres->I1 = In;
	  pres->K1 = Kn;
	  pres->n1 = In - Kn - I;
	  pres->T1 = K;
	  pres->J1 = Jn;
	  pres->m1 = Jn - J;
	  pres->x1 = escale * (align->orientation ? X[M+1-J] - X[M+1-Jn] : X[Jn] - X[J]);
	  
	  /* alternate resolved interval */
	  pres->I2 = In;
	  pres->K2 = Kn;
	  pres->n2 = In - Kn - I - 1;
	  pres->T2 = K + 1;
	}
      }
    }
  } else {/* right aligned site of an aligned interval */

    pres->m = J-G;
    pres->n = I-K-H;
    pres->T = D;
    pres->x = x;
    if(REFDEBUG_STRICT)
      pres->outlier = outlier;

    if(K >= KMAX)
      pres->Ip = 0;
    else if(delY1 < delY2){/* try to expand deres interval Y[I-K..I] to the left to Y[I-K-1..I] */
      if(I-K-1 >= H) /* cannot expand deres interval to left, since there is no unaligned site before previous aligned site */
	pres->Ip = 0;
      else {
	pres->Ip = I;
	
	/* original resolved interval */
	pres->I1 = I;
	pres->K1 = K;
	pres->n1 = I - K - H;
	pres->T1 = D;
	pres->J1 = J;
	pres->m1 = J - G;
	pres->x1 = x;
	
	/* alternate resolved interval */
	pres->I2 = I;
	pres->K2 = K + 1;
	pres->n2 = I - K - 1 - H;
	pres->T2 = D;
      }
    } else {/* try to expand deres interval Y[I-K..I] to the right to Y[I-K..I+1] */
      if(align->numpairs <= T + 1){/* no further aligned sites */
	if(I >= N)/* cannot expand deres interval to right, since there are no more sites */
	  pres->Ip = 0;
	else {
	  pres->Ip = I + 1;
	  pres->n1 = 0;
	}
      } else {/* next aligned site is present */
	int In = align->sites1[T+1];
	int Kn = align->sitesK1[T+1];
	int Jn = align->sites2[T+1];
	if(I + 1 >= In - Kn) /* cannot expand deres interval to right, since there is no unaligned site before next aligned site */
	  pres->Ip = 0;
	else {
	  pres->Ip = I + 1;
	  
	  /* original resolved interval Y[I .. In - Kn] */
	  pres->I1 = In;
	  pres->K1 = Kn;
	  pres->n1 = In - Kn - I;
	  pres->T1 = K;
	  pres->J1 = Jn;
	  pres->m1 = Jn - J;
	  pres->x1 = escale * (align->orientation ? X[M+1-J] - X[M+1-Jn] : X[Jn] - X[J]);
	  
	  /* alternate resolved interval Y[I+1 .. In-Kn] */
	  pres->I2 = In;
	  pres->K2 = Kn;
	  pres->n2 = In - Kn - I - 1;
	  pres->T2 = K + 1;
	}
      }
    }
  }
}

/** Flat Array based Dynamic programming data */
class AL {
public:
  long long Kstride;/**< distance between K index increments == maxN*maxM */
  long long Istride;/**< distance between I index increments <= M */
  int kmax;/**< largest value of Kmax[1..N] */
  /* NOTE : the J index stride is always 1 */

  int KMAX;/* largest possible value of kmax over all reference contigs */
  long long firstindex;/* lowest index in arrays */
  long long stride;/* allocated range of index values : used range is (1LL + (CACHE ? KMAX : kmax)) * Kstride */

#define ARRAY(type, field) type *field##_base; inline type& field(int I, int K, int J) { return field##_base[I*Istride + K*Kstride + J];}
  
  ARRAY(RFLOAT, score);
  ARRAY(RFLOAT, Uscore);// only used with DEFER_BP or -MultiMatches to remember score based on Unaligned left end only
  ARRAY(RFLOAT, rscore);// only used with -RepeatRec : score with alignments constrained relative to best alignment 
  ARRAY(RFLOAT, Tscore);// only used with -MultiMatches : total score (corresponding to right end type R)

  ARRAY(int, G);/* previous value of I */
  ARRAY(int, T);/* previous value of K */
  ARRAY(int, H);/* previous value of J */
  ARRAY(int, Lij);
  ARRAY(int, Rij);
  ARRAY(int, Lijx);
  ARRAY(int, Rijx);

  ARRAY(int, shift);// only used with -RepeatRec : corresponds to (bestJ-bestJ2)-(bestI-bestI2) when rscore,rG,rT,rH were last computed
                    // Also used by -MultiMatchesFilter 2 to flag entries used by higher scoring matchgroups to detect strict subsets quickly
  ARRAY(int, rG);// only used with -RepeatRec : corresponds to rscore
  ARRAY(int, rT);// only used with -RepeatRec : corresponds to rscore
  ARRAY(int, rH);// only used with -RepeatRec : corresponds to rscore

  ARRAY(int, IL);// only used with -MultiMatches : left end of best alignment score
  ARRAY(int, KL);// only used with -MultiMatches : left end of best alignment score
  ARRAY(int, JL);// only used with -MultiMatches : left end of best alignment score
  ARRAY(int, R);// only used with -MultiMatches : see Tscore

#undef ARRAY

  AL() { 
    score_base = Uscore_base = NULL; 
    G_base = T_base = H_base = Lij_base = Rij_base = Lijx_base = Rijx_base = NULL;

    rscore_base = NULL;
    shift_base = rG_base = rT_base = rH_base = NULL;

    Tscore_base = NULL;
    IL_base = KL_base = JL_base = R_base = NULL;
  };
};

static long long DPsizF = 2;/* number of RFLOAT fields in DP */
static long long DPsizI = 7;/* number of int fields in DP */

static int chimpaircnt;/**< count how many chimeric pairs are next to each other (within 20 * Ylambda) */

static int giter;

static long long pcnt = 0;/**< sum over I=1..N of Kmax[I]+1  (for debugging memory allocation) */

/** extract alignment with right end at Y[I,K],X[J] from A[] and return number of aligned labels (U) and updated I : requires resSD > 0.0 */
static int alignExtract(AL *A, int &I, int K, int J, int bestR, RFLOAT bestscore, 
			FLOAT *Y, FLOAT *X, int N, int M, 
			int *Ilist, int *Klist, int *Jlist, double *iscore, double *outscore, 
			Cmap *rmap, Cmap *nanomap,
			int refid, int mapid, int orientation, int rev, int scaleID, int verb, 
			int IL = -1)// If IL >= 0 : terminate alignment extraction when I == IL 
{
  Cprtab **PRtabY = PRtab[refid + rev * grefend];

  int U = 0;
    
  //  int origI = I, origJ = J, origK = K;

  /* right end segment */
  // NOTE : if PoutlierEnd > 0.0, bestR <= -2 may be caused either by local alignment or PoutlierEnd
  outscore[0] = iscore[0] = bestscore - A->score(I,K,J);
  if(DEBUG) assert(isfinite(iscore[0]));
  if((VERB>=2 || TRACE) && verb){
    if(MultiMatches)
      printf("alignExtract:refid=%d(id=%lld)mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:I=%d,K=%d,J=%d,R=%d,IL=%d,score=%0.6f,N=%d,M=%d:score(I,K,J)= %0.6f, Tscore(I,K,J)= %0.6f, iscore[0]= %0.6f\n",
	     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,I,K,J,bestR,IL,bestscore,N,M,A->score(I,K,J),A->Tscore(I,K,J),iscore[0]);
    else
      printf("alignExtract:refid=%d(id=%lld)mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:I=%d,K=%d,J=%d,R=%d,IL=%d,score=%0.6f,N=%d,M=%d:score(I,K,J)= %0.6f, iscore[0]= %0.6f\n",
	     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,I,K,J,bestR,IL,bestscore,N,M,A->score(I,K,J),iscore[0]);
    fflush(stdout);
  }

  double iscoresum = iscore[0], errsum = 0.0, perrsum = 0.0;// NEW7 : used for debugging

  while(I > 0){
    if(DEBUG>=2){
      assert(0 <= K && K <= KMAX);
      assert(I-K >= 1 && I <= N);
      if(!(J >= 1 && J <= M)){
	#pragma omp critical
	{
	  printf("alignExtract:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:I=%d,K=%d,J=%d,bestR=%d,bestscore=%0.6f,N=%d,M=%d,IL=%d\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,I,K,J,bestR,bestscore,N,M,IL);
	  fflush(stdout);
	  assert(J >= 1 && J <= M);
	}
      }
    }
    Ilist[U] = I;
    Klist[U] = K;
    Jlist[U] = J;
    
    RFLOAT score = (I == IL && IL != A->IL(I,K,J)) ? A->Uscore(I,K,J) : A->score(I,K,J);
    if(DEBUG) assert(isfinite(score));

    int G = (I == IL && IL != A->IL(I,K,J)) ? (A->Uscore(I,K,J) > ChimScore + PRtabY[K][I].Sm ? -1 : -2) : A->G(I,K,J);
    if(DEBUG && IL >= 0) assert(I >= IL);

    if(G > 0){
      int T = A->T(I,K,J);
      int H = A->H(I,K,J);	    
      if(DEBUG>=2) assert(H > 0 && 0 <= T && T <= KMAX);
      iscore[U+1] = score - A->score(G,T,H);
      if(DEBUG>=2) assert(isfinite(iscore[U+1]));
      RFLOAT x = X[J] - X[H];
      RFLOAT y = Yc(Y,I,K) - Yc(Y,G,T);

      if(maptype){
	RFLOAT Bias,Pen,Gauss,PenSm;
	SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	outscore[U+1] = Bias + Pen + Gauss + PenSm;

	if((REFSPLIT_FIX/* WAS7 >=2 */ || DEBUG>=2 || PVERB) /* && !(REFSPLIT_FIX>=2 && OUTLIER_TYPE1 && outlierExtend) */){
	  RFLOAT OutPen = OutlierPenalty;
	  if(outlierBC)
	    OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
	  if(OUTLIER_LTYPE==0)
	    OutPen -= (x+y) * OutlierLambdaInv;
	  else
	    OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD CODE
	  RFLOAT iscore2 = (OUTLIER_TYPE1 == 0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
	    OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
#else // NEW CODE
	  RFLOAT iscore2 = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen * OUTLIER_TYPE1 + OutPen) + PenSm;
#endif
	  
	  if(REFSPLIT_FIX/* WAS7 >=2 */)
	    iscore[U+1] = iscore2;
          if((VERB/* HERE HERE >=2 */||TRACE) && verb){// NEW7
	    errsum += iscore[U+1] - iscore2;
	    perrsum += max(iscore[U+1],outscore[U+1]) - iscore[U+1];
	    iscoresum += iscore[U+1];

	    printf("\t U=%d:I=%d,K=%d,J=%d,G=%d,T=%d,H=%d:x=%0.4f,y=%0.4f:Bias=%0.6f,Pen=%0.6f,Gauss=%0.6f,PenSm=%0.6f,OutPen=%0.6f,OutBias=%0.6f:outscore[U]= %0.6f, iscore[U]= %0.6f, iscore2= %0.6f(err= %0.6f)(sum:iscore= %0.6f, err= %0.6f, err2= %0.6f))\n",
		   U+1,I,K,J,G,T,H,x,y,Bias,Pen,Gauss,PenSm,OutPen,OutlierBias,outscore[U+1],iscore[U+1],iscore2,iscore[U+1]-iscore2, iscoresum, errsum, perrsum);
	    fflush(stdout);
	  }

	  if(!(REFSPLIT_FIX/* WAS7 >=2 */ || (((OUTLIER_TYPE1 && outlierExtend) ? iscore[U+1] - iscore2 : fabs(iscore[U+1] - iscore2))  < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN))
	     || !(outscore[U+1] <= iscore2 + ISCORE_MARGIN /* NEW33 */+ RSCORE_MARGIN * fabs(iscore2))){
	    #pragma omp critical
	    {
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:I=%d,J=%d,K=%d:G=%d,T=%d,H=%d:U=%d,x=%0.3f,y=%0.3f,Bias=%0.9f,OutBias=%0.9f,Pen=%0.9f,Gauss=%0.9f,Sm=%0.9f,OutPen=%0.9f,outscore[U+1]=%0.9f:iscore2=%0.9f,iscore[U+1]=%0.9f(err=%0.9f):score=%0.9f,score(G,T,H)=%0.9f\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,I,J,K,G,T,H,U,x,y,Bias,OutlierBias,Pen,Gauss,PenSm,OutPen,outscore[U+1],iscore2,iscore[U+1],fabs(iscore2-iscore[U+1]), score, A->score(G,T,H));
	      //	      printf("    original I=%d,K=%d,J=%d,R=%d,IL=%d\n",origI,origK,origJ,bestR,IL);
	      SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,1);
	      fflush(stdout);

	      if(REFSPLIT_FIX<=0 /* WAS7 1 */){
		if(OUTLIER_TYPE1 && outlierExtend)
		  assert(iscore[U+1] - iscore2 < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN);
		else
		  assert(fabs(iscore[U+1] - iscore2) < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN);
	      }
	      assert(outscore[U+1] <= iscore2 + ISCORE_MARGIN /* NEW33 */+ RSCORE_MARGIN * fabs(iscore2));
	      if(!RELEASE) assert(0);
	    }
	  }
	}
	if(REFSPLIT_FIX)// NEW7
	  iscore[U+1] = max(iscore[U+1], outscore[U+1]);// NEW3 : only needed if OUTLIER_TYPE1 && outlierExtend
      } else if(OUTLIER_DELTA(x-y)){
	RFLOAT Bias,Pen,Gauss,PenSm;
	SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	outscore[U+1] = Bias + Pen + Gauss + PenSm;

	if((REFSPLIT_FIX/* WAS7 >=2 */ || DEBUG>=2 || PVERB) /* && !(REFSPLIT_FIX>=2 && OUTLIER_TYPE && outlierExtend) */){
	  RFLOAT OutPen = OutlierPenalty;
	  if(outlierBC)
	    OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
	  OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD CODE
	  RFLOAT iscore2 = (OUTLIER_TYPE==0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
	    OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
#else // NEW CODE
	  RFLOAT iscore2 = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE + OutPen) + PenSm;
#endif

	  if(REFSPLIT_FIX/* WAS7 >=2 */)
	    iscore[U+1] = iscore2;
          if((VERB/* HERE HERE >=2 */||TRACE) && verb){// NEW7
	    errsum += iscore[U+1] - iscore2;
	    perrsum += max(iscore[U+1],outscore[U+1]) - iscore[U+1];
	    iscoresum += iscore[U+1];

	    printf("\t U=%d:I=%d,K=%d,J=%d,G=%d,T=%d,H=%d:x=%0.4f,y=%0.4f:Bias=%0.6f,Pen=%0.6f,Gauss=%0.6f,PenSm=%0.6f,OutPen=%0.6f,OutBias=%0.6f:outscore[U]= %0.6f, iscore[U]= %0.6f, iscore2= %0.6f(err= %0.6f)(sum:iscore= %0.6f, err= %0.6f, err2= %0.6f))\n",
		   U+1,I,K,J,G,T,H,x,y,Bias,Pen,Gauss,PenSm,OutPen,OutlierBias,outscore[U+1],iscore[U+1],iscore2,iscore[U+1]-iscore2, iscoresum, errsum, perrsum);
	    fflush(stdout);
	  }

	  if(!(REFSPLIT_FIX/* WAS7 >=2 */ || (((OUTLIER_TYPE && outlierExtend) ? iscore[U+1] - iscore2 : fabs(iscore[U+1] - iscore2))  < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN))
	     || !(outscore[U+1] <= iscore2 + ISCORE_MARGIN /* NEW33 */+ RSCORE_MARGIN * fabs(iscore2))){
	    #pragma omp critical
	    {
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:I=%d,J=%d,K=%d:G=%d,T=%d,H=%d:U=%d,x=%0.6f,y=%0.6f,Bias=%0.9f,OutBias=%0.9f,Pen=%0.9f,Gauss=%0.9f,Sm=%0.9f,OutlierPenalty=%0.9f,outscore[U+1]=%0.9f:iscore2=%0.9f,iscore[U+1]=%0.9f(err=%0.9f):score=%0.9f,score(G,T,H)=%0.9f\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,I,J,K,G,T,H,U,x,y,Bias,OutlierBias,Pen,Gauss,PenSm,OutlierPenalty,outscore[U+1],iscore2,iscore[U+1],fabs(iscore2-iscore[U+1]), score, A->score(G,T,H));

	      SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,1);
	      fflush(stdout);
	      
	      if(REFSPLIT_FIX<=0 /* WAS7 1 */){
		if(OUTLIER_TYPE && outlierExtend)
		  assert(iscore[U+1] - iscore2 < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN);
		else
		  assert(fabs(iscore[U+1] - iscore2) < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN);
	      }
	      assert(outscore[U+1] <= iscore2 + ISCORE_MARGIN /* NEW33 */+ RSCORE_MARGIN * fabs(iscore2));
	      if(!RELEASE) assert(0);
	    }
	  }
	}
	if(REFSPLIT_FIX)// NEW7	
	  iscore[U+1] = max(iscore[U+1], outscore[U+1]);// NEW3 : only needed if OUTLIER_TYPE && outlierExtend
      } else {/* maptype == 0 && !(OUTLIER_DELTA(x-y)) */
	outscore[U+1] = iscore[U+1];

	if(VERB/* HERE HERE >=2 */ && verb){// NEW7
	  iscoresum += iscore[U+1];
	  if(MultiMatches)
	    printf("\t U=%d:I=%d,K=%d,J=%d: IL(I,K,J)= %d, Uscore(I,K,J)= %0.6f, score(I,K,J)= %0.6f: outscore[U]=iscore[U]= %0.6f, iscoresum= %0.6f\n", 
		   U+1, I,K,J, A->IL(I,K,J), A->Uscore(I,K,J), A->score(I,K,J), score, iscoresum);
	  else
	    printf("\t U=%d:I=%d,K=%d,J=%d: Uscore(I,K,J)= %0.6f, score(I,K,J)= %0.6f: outscore[U]=iscore[U]= %0.6f, iscoresum= %0.6f\n", 
		   U+1, I,K,J, A->Uscore(I,K,J), A->score(I,K,J), score, iscoresum);
	  fflush(stdout);
	}
      }
      K = T;
      J = H;
    } else {/* left end segment */
      outscore[U+1] = iscore[U+1] = score;
      if(DEBUG>=2) assert(isfinite(iscore[U+1]));
      // NOTE : if PoutlierEnd > 0.0, G <= -2 may be caused either by local alignment or PoutlierEnd
    }
    U++;
    I = G;
  }

  if(DEBUG) assert(U > 0);
  if(DEBUG) assert(I <= (isLinear ? -1 : 0));
  
  return U;
}

/** take existing alignment and return pvalue logFP() */
__attribute__ ((noinline)) double alignFP(Calign *p, FLOAT *Y, FLOAT *X, int N, int M,
					  int orientation, int Yid, int Xid, double lscore, int verb)
{
  int U = p->numpairs;
  
  if(U <= 1)
    return 0.0;

  /* allocate alignment fragment sizes */

  FLOAT *Xfrag, *Yfrag;
  if(U > MAX_ALLOCA){
    Xfrag = new FLOAT[2*(U-1)];
    Yfrag = &Xfrag[U-1];
  } else {
    Xfrag = (FLOAT *) alloca((U-1)*sizeof(FLOAT));
    Yfrag = (FLOAT *) alloca((U-1)*sizeof(FLOAT));
  }
  int misscnt = 0;
  double falsecnt = 0.0;
  /* If PVALUE_FIX==1 : If first or last aligned interval is outlier, force LogPV to 0 (since LogPV is not valid in this case and we never want an alignment like this anyway)
     If PVALUE_FIX==2 : Instead just penalize LogPV by including misaligned labels of outlier in non-outlier misaligned labels (rather than as part of OutlierMN correction) 
  */
  int OutlierCnt = 0;/* number of internal outliers */
  double logOutlierMN = 0.0;

  int I= -1, K= -1, J= -1, G= -1, D= -1,H= -1;
  int F = 0;/* segment (aligned interval) count */
  int EndOutlierCnt = 0;
  for(int T = 0; T < U; T++, G = I, D = K, H = J){
    I = p->sites1[T];
    K = p->sitesK1[T];
    J = p->sites2[T];
    if(DEBUG/* HERE >=2 */ && !(p->outscore[T] <= p->iscore[T] + SCORE_MARGIN * fabs(p->outscore[T]) + ASCORE_MARGIN)){
      if(T > 0){
	Yfrag[F] = Yc(Y,I,K) - Yc(Y,G,D);
	Xfrag[F] = X[J] - X[H];
	int m = max(1,J-H);
	int n = max(1,I-K-G);
	logOutlierMN += log((double)(m*n));
	printf("alignFP:T=%d:I=%d,K=%d,J=%d,G=%d,D=%d,H=%d: F=%d,x= %0.4f,y= %0.4f,m=%d,n=%d:OutlierCnt=%d,logOutlierMN= %0.6f: iscore= %0.9f, outscore= %0.9f\n",
	       T,I,K,J,G,D,H,F,Xfrag[F],Yfrag[F],m,n,OutlierCnt,logOutlierMN, p->iscore[T],p->outscore[T]);
      } else
	printf("alignFP:T=%d:I=%d,K=%d,J=%d: iscore= %0.9f, outscore= %0.9f\n",
	       T,I,K,J, p->iscore[T],p->outscore[T]);
      fflush(stdout);

      assert(p->outscore[T] <= p->iscore[T] + SCORE_MARGIN * fabs(p->outscore[T]) + ASCORE_MARGIN);
    }

    if(PVres >= 2 && K > 0)
      for(int k = 0; k < K; k++)
	falsecnt += Pr(Y[I-k] - Y[I-k-1]);
    if(T > 0){
      if(DEBUG>=2) assert(G > 0 && H > 0);
      Yfrag[F] = Yc(Y,I,K) - Yc(Y,G,D);
      Xfrag[F] = X[J] - X[H];
      if(p->iscore[T] > p->outscore[T] + (FLOAT)0.01 || (outlierExtend && (H >= J || G >= I-K))){
	if(OUTLIER_PV){
	  OutlierCnt++;
	  int m = max(1,J-H);
	  int n = max(1,I-K-G);
	  logOutlierMN += log((double)(m*n));
	  //	  if(DEBUG>=2) assert(OutlierMN > 0);
	  if((VERB>=2 || TRACE) && verb){
	    //	    #pragma omp critical
	    {
	      printf("T=%d:I=%d,K=%d,J=%d,G=%d,D=%d,H=%d: F=%d,Yik= %0.4f,Xj= %0.4f,x= %0.4f,y= %0.4f,m=%d,n=%d:OutlierCnt=%d,logOutlierMN= %0.6f: iscore= %0.6f, outscore= %0.6f\n",
		     T,I,K,J,G,D,H,F,Yc(Y,I,K),X[J],Xfrag[F],Yfrag[F],m,n,OutlierCnt,logOutlierMN, p->iscore[T],p->outscore[T]);
	      if(PVALUE_FIX && (T==1 || T== U-1))
		printf("\t logPV = 0 since outlier is not permitted for first or last aligned interval\n");
	      fflush(stdout);
	    }
	  }
	  if(PVALUE_FIX > 0 && (T==1 || T== U-1)){
	    if(PVALUE_FIX == 1){
	      if(U > MAX_ALLOCA)
		delete [] Xfrag;
	      return 0.0;
	    }
	    logOutlierMN -= log((double)(m*n));	    
	    misscnt += n-1;
	    falsecnt += m-1;
	  }
	}
	continue;
      }
      if(DEBUG>=2) assert(Yfrag[F] > 0.0);
      if(DEBUG>=2) assert(Xfrag[F] > 0.0);
      F++;
      misscnt += I-K-G-1;
      falsecnt += J-H-1;
      if((VERB>=2 || TRACE) && verb){
	printf("T=%d:I=%d,K=%d,J=%d,G=%d,D=%d,H=%d: F=%d,Yik= %0.4f,Xj= %0.4f,x= %0.4f,y= %0.4f:fp=%0.2f,fn=%d,E=%d,OutlierCnt=%d,logOutlierMN= %0.6f : iscore= %0.6f, outscore= %0.6f\n",
	       T,I,K,J,G,D,H,F,Yc(Y,I,K),X[J],Xfrag[F-1],Yfrag[F-1],falsecnt,misscnt,EndOutlierCnt,OutlierCnt,logOutlierMN, p->iscore[T],p->outscore[T]);
	fflush(stdout);
      }
    } else {/* left end */
      int Lijy = (p->Lend <= -2)  ? p->Lij1 : max(1,p->Lij1);
      int Lijx = (p->Lend <= -2) ? p->Lij2 : max(1,p->Lij2);

      if(I-K > Lijy)
	misscnt += I - K - Lijy;
      if(J > Lijx)
	falsecnt += J - Lijx;
      if(p->Lend <= -2)
	EndOutlierCnt++;
      if((VERB>=2 || TRACE) && verb){
	printf("T=%d:I=%d,K=%d,J=%d:G=%d,Lijy= %d, Lijx= %d, Yik= %0.4f,Xj= %0.4f, fp= %0.2f, fn= %d, E=%d, logOutlierMN= %0.6f\n",
	       T,I,K,J,p->Lend,Lijy,Lijx,Yc(Y,I,K),X[J],falsecnt,misscnt, EndOutlierCnt, logOutlierMN);
	fflush(stdout);
      }
    }
  }

  /* right end */
  int Rijy = (p->Rend <= -2) ? p->Rij1 : min(N,p->Rij1);
  int Rijx = (p->Rend <= -2) ? p->Rij2 : min(M,p->Rij2);
  if(I < Rijy)
    misscnt += Rijy - I;
  if(J < Rijx)
    falsecnt += Rijx - J;
  if(p->Rend <= -2)
    EndOutlierCnt++;
  if(DEBUG && !((Poutlier <= 0.0) ? F== U-1 : F <= U-1)){
    #pragma omp critical
    {
      printf("alignFP:rid=%d(id=%lld),mid=%d(id=%lld),or=%d:U=%d,F=%d,Poutlier= %0.3e:\n",Yid,YYmap[Yid]->id,Xid,XXmap[Xid]->id,p->orientation,U,F,Poutlier);
      fflush(stdout);
    }

    if(!verb)
      (void)alignFP(p,Y,X,N,M,orientation,Yid,Xid,lscore,1); 
    assert((Poutlier <= 0.0) ? F== U-1 : F <= U-1);
    assert(0);
  }
  //  if(DEBUG) assert(OutlierMN > 0);

#if 0
  if(OUTLIER_PV && OutlierMN > 1e+300){
    G = D = H = -1;
    for(int T = 0; T < U; T++, G = I, H = J, D = K){
      I = p->sites1[T];
      K = p->sitesK1[T];
      J = p->sites2[T];
      if(T > 0 && (p->iscore[T] > p->outscore[T] + (FLOAT)0.01 || (outlierExtend && (H >= J || G >= I-K)))){
	int m = J-H;
	int n = I-K-G;
	logOutlierMN += log((double)(m*n));
      }
    }
  } else
    logOutlierMN = log(OutlierMN);
#endif

  if(DEBUG>=2) assert(EndOutlierCnt == (p->Lend <= -2 ? 1 : 0) + (p->Rend <= -2 ? 1 : 0));
  int EndOutlierNL = 1;
  if(OUTLIER_PV && EndOutlierPV && EndOutlierCnt >= 1){
    if(EndOutlierCnt >= 2){
      int L = min(p->sites1[U-1] - p->sites1[0], p->sites2[U-1] - p->sites2[0]);
      if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
      if(DEBUG && !CutFlip) assert(p->Nrange <= N && p->Mrange <= M);
      int T = min(p->Nrange,p->Mrange);
      EndOutlierNL = max(L,T) - L + 1;
      if((DEBUG>=1+RELEASE && !(EndOutlierNL > 0)) || ((VERB>=2 || TRACE) && verb)){
	printf("Yid=%d(id=%lld),Xid=%d(id=%lld),or=%d:U=%d,p->sites1[0,U-1]=%d,%d, p->sites2[0,U-1]= %d,%d, Nrange=%d,Mrange=%d,N=%d,M=%d,CutFlip=%d : T=%d,L=%d,EndOutlierNL=%d\n",
	       Yid,YYmap[Yid]->id,Xid,XXmap[Xid]->id,p->orientation,U,p->sites1[0],p->sites1[U-1],p->sites2[0],p->sites2[U-1],p->Nrange,p->Mrange,N,M,CutFlip,T,L,EndOutlierNL);
	fflush(stdout);
	assert(EndOutlierNL > 0);
      }
      EndOutlierNL = max(2, EndOutlierNL);
    } else
      EndOutlierNL = 2;
  }

  if((VERB>=2 || TRACE) && verb){
    printf("T=%d:I=%d,K=%d,J=%d:Rijy= %d, Rijx= %d, Yik= %0.4f,Xj= %0.4f, fp= %0.2f, fn= %d, E=%d, logOutlierMN= %0.6f, EndOutlierNL=%d\n",
	   U,I,K,J,Rijy,Rijx,Yc(Y,I,K),X[J],falsecnt,misscnt,EndOutlierCnt, logOutlierMN, EndOutlierNL);
    fflush(stdout);
  }

  if(DEBUG>=2 && !(misscnt>=0)){
    #pragma omp critical
    {
      printf("alignFP:Yid=%d,Xid=%d,or=%d:N=%d,M=%d,score=%0.4f:I=%d,J=%d,Rijy=%d,misscnt=%d\n",
	     Yid,Xid,orientation,N,M,lscore,I,J,Rijy,misscnt);
      fflush(stdout);
      assert(misscnt >= 0);
    }
  }
  double logFP = pvalue(Yfrag, Xfrag, F, misscnt,falsecnt,OutlierCnt,logOutlierMN, EndOutlierNL, Ylambda, res[0]*PixelLen, verb, Yid, Xid,orientation);
  if(DEBUG && !(isfinite(logFP))){
    (void)pvalue(Yfrag,Xfrag,F, misscnt, falsecnt, OutlierCnt, logOutlierMN, EndOutlierNL,Ylambda,res[0]*PixelLen,1,Yid,Xid,orientation);
    fprintf(stderr,"alignFP:I=%d,K=%d,J=%d:logFP=%e,misscnt=%d(Rijy=%d),falsecnt=%0.1f(Rijx=%d),Outliers=%d,logMN=%0.6f\n",
	    I,K,J,logFP,misscnt,Rijy,falsecnt,Rijx,OutlierCnt,logOutlierMN);
    fflush(stderr);
    assert(isfinite(logFP));
  }

  if(U > MAX_ALLOCA)
    delete [] Xfrag;

  return logFP;
}

static int memcheck_printed = 0;

//static long long MultiMatchTrim_MaxCnt = 0;/* largest number of MULTIMATCH_TRIM matchgroup comparisons for a single query/ref map pair */
//static long long MM_refid, MM_mapid;
//static int MM_or,MM_rev;

/** extract alignment with right end at Y[I,K],X[J] from A[][] and call logFP() : requires resSD > 0.0 */
/* NOTE : alignFPsd() is called from within some critical sections and should NOT use its own critical sections */
static __attribute__ ((noinline)) double alignFPsd(AL *A, int I, int J,int K, 
						   FLOAT *Y, FLOAT *X,
						   int N, int M,
						   int Nrange, int Mrange,// IMAX-IMIN+1 and jmax-jmin+1 : normally same as N,M unless -CutFlip or -hashGrouped was used
						   int Rend,
                                                   int orientation, int rev, int scaleID,
						   int refid, int mapid,int shift,/* If shift != 0 : use A->rscore,rG,rT,rH instead of score,G,T,H : used with -RepeatRec */
						   int verb, 
						   int &numpairs, 
						   int &Lend,
						   int IL,// If IL >= 0 : terminate alignment extraction when I == IL : used with -MultiMatch
						   double *Piscore, double *Poutscore, // If != NULL : update iscore and outscore as with alignExtract
						   int *Ilist = 0, int *Klist = 0, int *Jlist = 0, int *outlier = 0,
						   int Filter = 0/*, Cmatchgroup *p=0*/) /* If Filter > 0, if one of the first Filter-1 entries in A already has shift > 0 update matchgroup p to truncate the left end and return 0.
											    Should match truncation code in refalignXYsd when MultiMatchFilter < 2. Typically Filter == AlignedSiteThreshold2 IFF MultiMatchFilter>=2.
											 */
{
  Cprtab **PRtabY = PRtab[refid + rev * grefend];

  if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(Mrange == M);

  /* allocate space to store alignment in reverse order */
  int Umax = min(M,N);// HERE : should allocate Ilist[],Klist[],Jlist[] in parent, since these arrays can be quite large when aligning consensus maps
  int heap = 0;
  if(!Ilist){
    if(Umax > MAX_ALLOCA){
      heap = 1;
      Ilist = new int[Umax*4];
      Klist = &Ilist[Umax];
      Jlist = &Ilist[Umax*2];
      outlier = &Ilist[Umax*3];
    } else {
      Ilist = (int *)alloca(Umax * sizeof(int));
      Klist = (int *)alloca(Umax * sizeof(int));
      Jlist = (int *)alloca(Umax * sizeof(int));
      outlier = (int *)alloca(Umax * sizeof(int));
    }
  }

  if(DEBUG && shift) assert(RepeatRec);

  if((VERB>=2||TRACE) && verb){
    if(MultiMatches)
      printf("alignFPsd:refid=%d,mapid=%d,or=%d,rev=%d,sc=%d,shift=%d:I=%d,J=%d,K=%d,N=%d,M=%d,R=%d,IL=%d:score(I,K,J)= %0.6f, Tscore(I,K,J)= %0.7f, shift(I,K,J)= %d\n",
	     refid,mapid,orientation,rev,scaleID,shift,I,J,K,N,M,Rend,IL,shift ? A->rscore(I,K,J) : A->score(I,K,J),A->Tscore(I,K,J), (RepeatRec || MultiMatchesFilter>=2) ? A->shift(I,K,J) : 0);
    else if(RepeatRec || MultiMatchesFilter>=2)
      printf("alignFPsd:refid=%d,mapid=%d,or=%d,rev=%d,sc=%d,shift=%d:I=%d,J=%d,K=%d,N=%d,M=%d,R=%d,IL=%d:score(I,K,J)= %0.6f, shift(I,K,J)= %d\n",
	     refid,mapid,orientation,rev,scaleID,shift,I,J,K,N,M,Rend,IL,shift ? A->rscore(I,K,J) : A->score(I,K,J),A->shift(I,K,J));
    else
      printf("alignFPsd:refid=%d,mapid=%d,or=%d,rev=%d,sc=%d,shift=%d:I=%d,J=%d,K=%d,N=%d,M=%d,R=%d,IL=%d:score(I,K,J)= %0.6f\n",
	     refid,mapid,orientation,rev,scaleID,shift,I,J,K,N,M,Rend,IL,A->score(I,K,J));
    fflush(stdout);
  }

  //  int origI = I, origK = K, origJ = J;

  double cumscore = MultiMatches ? A->Tscore(I,K,J) - A->score(I,K,J) : 0.0; // NEW7 only used with Piscore != 0 OR if verb != 0
  if(Piscore){
    if(DEBUG) assert(MultiMatches);// this means A->Tscore(I,K,J) is valid and equivalent to bestscore in alignExtract()
    Poutscore[0] = Piscore[0] = cumscore;
    if(DEBUG) assert(isfinite(Piscore[0]));
  }

  int U = 0;

  while(I > 0){
    if(DEBUG>=2){
      assert(I-K >= 1 && I <= N);
      if(!(J >= 1 && J <= M)){
	printf("alignFPsd():refid=%d,mapid=%d,or=%d,shift=%d:I=%d,K=%d,J=%d,M=%d,N=%d\n",refid,mapid,orientation,shift,I,K,J,M,N);
	fflush(stdout);
        assert(J >= 1 && J <= M);
      }
    }

    if(DEBUG>=2) assert(U < Umax);
    Ilist[U] = I;
    Klist[U] = K;
    Jlist[U] = J;

    if(U/* WAS6 U+1 */ < Filter && A->shift(I,K,J) > 0 && !(RefSplitStitch>=2 && cumscore > (RFLOAT)0.0)){// early return to support -MultiMatchesFilter 2
      if(DEBUG>=2) assert(MultiMatchesFilter >= 2);
      numpairs = U;// WAS6 U+1
      return 0.0;
    }

    RFLOAT score = (I == IL && IL != A->IL(I,K,J)) ? A->Uscore(I,K,J) : shift ? A->rscore(I,K,J) : A->score(I,K,J);
    int G = (I == IL && IL != A->IL(I,K,J)) ? (A->Uscore(I,K,J) > ChimScore + PRtabY[K][I].Sm ? -1 : -2)  : shift ? A->rG(I,K,J) : A->G(I,K,J);

    if(DEBUG>=1+RELEASE/* HERE HERE >=2 */ && !TRACE && shift && shift != A->shift(I,K,J)){// NOTE : If TRACE, this function may be called in debug print statements in non-standard way
      printf("alignFPsd():refid=%d,mapid=%d,or=%d,shift=%d:I=%d,K=%d,J=%d,M=%d,N=%d: A->shift(I,K,J)= %d\n",refid,mapid,orientation,shift,I,K,J,M,N,A->shift(I,K,J));
      fflush(stdout);
      assert(shift == A->shift(I,K,J));// NEW147
    }

    if(G > 0){
      int T = shift ? A->rT(I,K,J) : A->T(I,K,J);
      int H = shift ? A->rH(I,K,J) : A->H(I,K,J);
      if(DEBUG>=2 && !(H > 0 && T >= 0)){
	if(shift)
	  printf("alignFPsd():refid=%d,mapid=%d,or=%d,shift=%d:I=%d,K=%d,J=%d,M=%d,N=%d:score=%0.6f,G=%d,T=%d,H=%d,A->rH(I,K,J)=%d,A->rT(I,K,J)=%d,A->shift(I,K,J)=%d,A->rscore(I,K,J)=%0.6f\n",
		 refid,mapid,orientation,shift,I,K,J,M,N,score,G,T,H, A->rH(I,K,J),A->rT(I,K,J),A->shift(I,K,J),A->rscore(I,K,J));
	else
	  printf("alignFPsd():refid=%d,mapid=%d,or=%d,shift=%d:I=%d,K=%d,J=%d,M=%d,N=%d:score=%0.6f,G=%d,T=%d,H=%d,A->H(I,K,J)=%d,A->T(I,K,J)=%d,A->shift(I,K,J)=%d\n",
		 refid,mapid,orientation,shift,I,K,J,M,N,score,G,T,H, A->H(I,K,J),A->T(I,K,J), (RepeatRec || MultiMatchesFilter >= 2) ? A->shift(I,K,J) : 0);
	fflush(stdout);
	assert(T >= 0);
	assert(H > 0);
      }
      if(DEBUG>=2) assert(U+1 < M);
      double iscore = score - (shift ? A->rscore(G,T,H) : A->score(G,T,H));
      cumscore += iscore;
      if(Piscore){
	Piscore[U+1] = iscore;
	if(DEBUG>=2) assert(isfinite(Piscore[U+1]));
      }
      RFLOAT x = X[J] - X[H];
      RFLOAT y = Yc(Y,I,K) - Yc(Y,G,T);

      if(maptype){
	RFLOAT Bias,Pen,Gauss,PenSm;
	SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	double outscore = Bias + Pen + Gauss + PenSm;
	if(Piscore){
	  Poutscore[U+1] = outscore;
	  if(REFSPLIT_FIX<=0 /* WAS7 1 */)
	    Piscore[U+1] = max(outscore, iscore);// NEW3
	}
	outlier[U+1] = (iscore > outscore + (FLOAT)0.01 || (outlierExtend && (H >= J || G >= I-K))) ? 1 : 0;

        if(REFSPLIT_FIX/* WAS7 >=2 */ || ((VERB/* HERE HERE >=2 */||TRACE) && verb)){
	  RFLOAT OutPen = OutlierPenalty;
	  if(outlierBC)
	    OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
	  if(OUTLIER_LTYPE==0)
	    OutPen -= (x+y) * OutlierLambdaInv;
	  else
	    OutPen -= fabs(x-y) * OutlierLambdaInv;

	  double iscore2 = (OUTLIER_TYPE1 == 0.0 || (REPEAT_OUTLIER && shift)) ? OutlierBias + max(Bias + Pen + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
#if 0 // OLD CODE
  	    OutlierBias + Pen + max(Bias + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
#else // NEW CODE
	    OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen * OUTLIER_TYPE1 + OutPen) + PenSm;
#endif

	  if(REFSPLIT_FIX/* WAS7 >=2 */ && Piscore)
	    Piscore[U+1] = max(outscore, iscore2);

	  if((VERB>=2||TRACE) && verb){
#if 0 // OLD CODE
	    RFLOAT OutlierPen = (OUTLIER_TYPE1 == 0) ? OutlierBias + OutPen + Bias * biasWToutlier + PenSm :
	      OutlierBias + Pen + Bias * biasWToutlierF + OutPen + PenSm;
#else // NEW CODE
	    RFLOAT OutlierPen = OutlierBias + Pen*OUTLIER_TYPE1 + Bias * biasWToutlierF + OutPen + PenSm;
#endif

	    double AscoreGTH = shift ? A->rscore(G,T,H) : A->score(G,T,H);

	    printf("U=%d:I=%d,K=%d,J=%d,shift=%d:G=%d,T=%d,H=%d:y=%0.4f,x=%0.4f,outlier=%d:iscore2=%0.6f(sum=%0.6f,score(I,K,J)=%0.6f,score[G][T][H]=%0.6f),outscore=%0.6f(Bias=%0.6f,Pen=%0.6f,Gauss=%0.6f,Sm=%0.6f),Outlier=%0.6f(OutPen=%0.6f:Out=%0.6f,BC=%0.6f,Lambda=%0.6f)\n",
		   U,I,K,J,(RepeatRec || MultiMatchesFilter>=2) ? A->shift(I,K,J) : 0,G,T,H,y,x,outlier[U+1],iscore2,cumscore,score,AscoreGTH,outscore,Bias,Pen,Gauss,PenSm,OutlierPen,OutPen,OutlierPenalty,
		   outlierBC ? OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G] : 0.0, -fabs(x-y)*OutlierLambdaInv);
	    fflush(stdout);
	  }
	}
      } else if(OUTLIER_DELTA(x-y)){
	RFLOAT Bias,Pen,Gauss, PenSm;
	SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	double outscore = Bias + Pen + Gauss + PenSm;
	if(Piscore){
	  Poutscore[U+1] = outscore;
	  if(REFSPLIT_FIX <= 0 /* WAS7 1 */)
	    Piscore[U+1] = max(outscore,iscore);// NEW3
	}
	outlier[U+1] = (iscore > outscore + (FLOAT)0.01 || (outlierExtend && (H >= J || G >= I-K))) ? 1 : 0;

	if(REFSPLIT_FIX/* WAS7 >=2 */ || ((VERB/* HERE HERE >=2 */||TRACE) && verb)){
	  RFLOAT OutPen = OutlierPenalty;
	  if(outlierBC)
	    OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
	  OutPen -= fabs(x-y) * OutlierLambdaInv;
	
	  double iscore2 = (OUTLIER_TYPE==0 || (REPEAT_OUTLIER && shift)) ? OutlierBias + max(Bias + Pen + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
#if 0 // OLD CODE
	    OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
#else // NEW CODE
	    OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen * OUTLIER_TYPE + OutPen) + PenSm;
#endif

	  if(REFSPLIT_FIX/* WAS7 >=2 */ && Piscore)
	    Piscore[U+1] = max(outscore, iscore2);

	  if((VERB>=2||TRACE) && verb){
#if 0 // OLD CODE
	    RFLOAT OutlierPen = (OUTLIER_TYPE==0) ? OutlierBias + OutPen + Bias * biasWToutlierF + PenSm :
	      OutlierBias + Pen + Bias * biasWToutlierF + OutPen + PenSm;
#else // NEW CODE
	    RFLOAT OutlierPen = OutlierBias + Pen*OUTLIER_TYPE + Bias * biasWToutlierF + OutPen + PenSm;
#endif
	    double AscoreGTH = shift ? A->rscore(G,T,H) : A->score(G,T,H);
	    double OutlierPenaltyBC_IKGJH =  outlierBC ? OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G] : 0.0;
	    int AshiftIKJ = (RepeatRec || MultiMatchesFilter>=2) ? A->shift(I,K,J) : 0;
	    int outUp1 = outlier[U+1];

	    printf("U=%d:I=%d,K=%d,J=%d,shift=%d:G=%d,T=%d,H=%d:y=%0.4f,x=%0.4f,outlier=%d:iscore2=%0.6f(sum=%0.6f,score(I,K,J)=%0.6f,score[G][T][H]=%0.6f,shift=%d),outscore=%0.6f(Bias=%0.6f,Pen=%0.6f,Gauss=%0.6f,Sm=%0.6f),Outlier=%0.6f(OutPen=%0.6f:Out=%0.6f,BC=%0.6f,Lambda=%0.6f)\n",
		   U,I,K,J,AshiftIKJ,G,T,H,y,x,outUp1,iscore2,cumscore,score, AscoreGTH, shift, outscore,Bias,Pen,Gauss,PenSm,OutlierPen,OutPen,OutlierPenalty,
		   OutlierPenaltyBC_IKGJH, -fabs(x-y)*OutlierLambdaInv);
	    fflush(stdout);
	  }
	}
      } else {/* score is NOT an outlier since outlier size exceeds outlierMax */
	if(Piscore)
	  Poutscore[U+1] = Piscore[U+1];
	outlier[U+1] = 0;

	if((VERB>=2||TRACE) && verb){
	  RFLOAT Bias,Pen,Gauss, PenSm;
	  SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	  double outscore = Bias + Pen + Gauss + PenSm;	
	  double iscore2 = outscore;

	  printf("U=%d:I=%d,K=%d,J=%d,shift=%d:G=%d:y=%0.4f,x=%0.4f,maptype=%d:outlier=%d:iscore2=%0.6f(sum=%0.6f,score(I,K,J)=%0.6f),outscore=%0.6f(Bias=%0.6f,Pen=%0.6f,Gauss=%0.6f,Sm=%0.6f)\n",
		 U,I,K,J,(RepeatRec || MultiMatchesFilter>=2) ? A->shift(I,K,J) : 0,G,y,x,maptype,outlier[U+1],iscore2,cumscore,score,outscore,Bias,Pen,Gauss,PenSm);
	  fflush(stdout);
	}
      }
      K = T;
      J = H;
    } else {/* left end segment */
      if(Piscore){
	Poutscore[U+1] = Piscore[U+1] = score;
	if(DEBUG>=2) assert(isfinite(Piscore[U+1]));
	// NOTE : if PoutlierEnd > 0.0, G <= -2 may be caused either by local alignment or PoutlierEnd
      }
      if((VERB>=2||TRACE) && verb){
	double AscoreIKJ = shift ? A->rscore(I,K,J) : A->score(I,K,J);

	if(MultiMatches)
	  printf("U=%d:I=%d,K=%d,J=%d,shift=%d:G=%d,IL=%d,A->IL(I,K,J)=%d,score=%0.6f(Uscore(I,K,J)=%0.6f,score(I,K,J)=%0.6f)\n",
		 U,I,K,J,(RepeatRec || MultiMatchesFilter>=2) ? A->shift(I,K,J) : 0,G,IL,A->IL(I,K,J),score,A->Uscore(I,K,J), AscoreIKJ);
	else
	  printf("U=%d:I=%d,K=%d,J=%d,shift=%d:G=%d,IL=%d,score=%0.6f(Uscore(I,K,J)=%0.6f,score(I,K,J)=%0.6f)\n",
		 U,I,K,J,(RepeatRec || MultiMatchesFilter>=2) ? A->shift(I,K,J) : 0,G,IL,score,A->Uscore(I,K,J), AscoreIKJ);
	fflush(stdout);
      }
    }
    U++;
    I = G;
  }
  if(DEBUG) assert(U > 0);
  if(DEBUG) assert(U <= Umax);
    
  Lend = I;

  numpairs = U;

  double prevLogFP;
  if(shift)
    prevLogFP = 0.0;

  /* allocate alignment fragment sizes */
  FLOAT *Xfrag, *Yfrag;
  if(U > MAX_ALLOCA){
    Xfrag = new FLOAT[2*(U-1)];
    Yfrag = &Xfrag[U-1];
  } else {
    Xfrag = (FLOAT *)alloca((U-1)*sizeof(FLOAT));
    Yfrag = (FLOAT *)alloca((U-1)*sizeof(FLOAT));
  }

Lrepeat:
  int misscnt = 0;
  double falsecnt = 0.0;
  int OutlierCnt = 0;/* number of internal outliers */
  double logOutlierMN = 0.0;/* product over all outlier of m x n (the number of intervals in the internal outlier aligned segment) */

  int G= I, H= J, D= K;
  int F = 0;/* segment (aligned interval) count */
  int EndOutlierCnt = 0;
  /* If PVALUE_FIX : If first or last aligned interval is outlier, force LogPV to 0 (since LogPV is not valid in this case and we never want an alignment like this anyway)
     If PVALUE_FIX==2 : Instead just penalize LogPV by including misaligned labels of outlier in non-outlier misaligned labels (rather than as part of OutlierMN correction)  */

  for(int T=0; T < U; T++, G = I, H = J, D = K){
    I = Ilist[U-1-T];
    K = Klist[U-1-T];
    J = Jlist[U-1-T];
    if(PVres >= 2 && K > 0)
      for(int k = 0; k < K; k++)
	falsecnt += Pr(Y[I-k] - Y[I-k-1]);// HERE : should this be incrementing falsecnt or misscnt ? makes no difference to Pvalue
    if(T > 0){
      if(DEBUG>=2) assert(G > 0 && H > 0);
      if(VERB/* HERE */ >=2 && verb){
	printf("T=%d:I=%d,K=%d,J=%d:G=%d,D=%d,H=%d:outlier=%d\n",
	       T,I,K,J,G,D,H,outlier[U-T]);
	fflush(stdout);
      }
      Yfrag[F] = Yc(Y,I,K) - Yc(Y,G,D);
      Xfrag[F] = X[J] - X[H];
      if(outlier[U-T]){
	if(OUTLIER_PV){
	  OutlierCnt++;
	  int m = max(1,J-H);
	  int n = max(1,I-K-G);
	  logOutlierMN += log((double)(m*n));
	  //	  if(DEBUG>=2) assert(OutlierMN > 0);
	  if((VERB>=2||TRACE) && verb){
	    //	    #pragma omp critical
	    {
	      printf("T=%d:I=%d,K=%d,J=%d:G=%d,D=%d,H=%d: F=%d,x= %0.4f,y= %0.4f,m=%d,n=%d:OutlierCnt=%d,logOutlierMN= %0.6f\n",
		     T,I,K,J,G,D,H,F,Xfrag[F],Yfrag[F],m,n,OutlierCnt,logOutlierMN);
	      if(PVALUE_FIX && (T==1 || T==U-1))
		printf("\t logPV = 0 since outlier is not permitted for first or last aligned interval\n");
	      fflush(stdout);
	    }
	  }
	  if(PVALUE_FIX && (T==1 || T==U-1)){
	    if(PVALUE_FIX <= 1){
	      if(heap)
		delete [] Ilist;
	      if(U > MAX_ALLOCA)
		delete [] Xfrag;
	      return 0.0;
	    }
	    logOutlierMN -= log((double)(m*n));	    
	    misscnt += n-1;
	    falsecnt += m-1;
	  }
	}	
	continue;
      }
      if(DEBUG>=2) assert(Yfrag[F] > 0.0);
      if(DEBUG>=2) assert(Xfrag[F] > 0.0);
      F++;
      misscnt += I-K-G-1;
      falsecnt += J-H-1;
      if((VERB>=2||TRACE) && verb){
	printf("T=%d:I=%d,K=%d,J=%d:G=%d,D=%d,H=%d: F=%d,x= %0.4f,y= %0.4f:fp=%0.2f,fn=%d,E=%d,OutlierCnt=%d,logOutlierMN= %0.6f\n",
	       T,I,K,J,G,D,H,F,Xfrag[F-1],Yfrag[F-1],falsecnt,misscnt,EndOutlierCnt,OutlierCnt,logOutlierMN);
	fflush(stdout);
      }
    } else {/* left end */
      int Lij = (G <= -2) ? I-K : max(1,A->Lij(I,K,J));
      int Lijx = (G <= -2) ? J : extend ? max(1,A->Lijx(I,K,J)) : 1;
      if(I-K > Lij)
	misscnt += I - K - Lij;
      if(J > Lijx)
	falsecnt += J - Lijx;
      if(G <= -2 && !(REPEAT_TRIM && shift))
	EndOutlierCnt++;
      if((VERB>=2||TRACE) && verb){
	printf("T=%d:I=%d,K=%d,J=%d:G=%d,Lijy= %d,Lijx= %d, fp= %0.2f,fn= %d, E=%d, logOutlierMN= %0.6f : A(I,K,J).Lij=%d,A(I,K,J).Lijx=%d\n",
	       T,I,K,J,G,Lij,Lijx,falsecnt,misscnt, EndOutlierCnt, logOutlierMN, A->Lij(I,K,J),A->Lijx(I,K,J));
	fflush(stdout);
      }
    }
  }
  if(DEBUG) assert(I==Ilist[0]);
  if(DEBUG) assert(K==Klist[0]);
  if(DEBUG) assert(J==Jlist[0]);
  /* right end */
  //  int Rijx = extend ? min(M,A->Rijx(I,K,J)) : (Rend <= -2 ? J : M);
  int Rij = (Rend <= -2) ? I : min(N,A->Rij(I,K,J));
  int Rijx = (Rend <= -2) ? J : extend ? min(M,A->Rijx(I,K,J)) : M;
  if(I < Rij)
    misscnt += Rij-I;
  if(J < Rijx)
    falsecnt += Rijx-J;
  if(DEBUG) assert((Poutlier <= 0.0) ? F== U-1 : F <= U-1);
  if(Rend <= -2 && !(REPEAT_TRIM && shift))
    EndOutlierCnt++;
  if((VERB>=2 || TRACE) && verb){
    printf("T=%d:I=%d,K=%d,J=%d:Rend=%d,Rijy= %d, Rijx= %d, fp= %0.2f, fn= %d, E=%d, logOutlierMN= %0.6f: A(I,K,J).Rij=%d, A(I,K,J).Rijx=%d\n",
	   U,I,K,J,Rend,Rij,Rijx,falsecnt,misscnt,EndOutlierCnt, logOutlierMN, A->Rij(I,K,J),A->Rijx(I,K,J));
    fflush(stdout);
  }
  
#if 0
  double logOutlierMN = 0.0;
  if(OUTLIER_PV && OutlierMN > 1e+300){
    G = D = H = -1;
    for(int T = 0; T < U; T++, G = I, H = J, D = K){
      I = Ilist[U-1-T];
      K = Klist[U-1-T];
      J = Jlist[U-1-T];
      if(T > 0){
	if(outlier[U-T]){
	  int m = J-H;
	  int n = I-K-G;
	  logOutlierMN += log((double)(m*n));
	}
      }
    }
  } else
    logOutlierMN = log(OutlierMN);
#endif

  int EndOutlierNL = 1;
  if(OUTLIER_PV && EndOutlierPV && EndOutlierCnt >= 1){
    if(EndOutlierCnt >= 2 && EndOutlierPV >= 2){
      int L = min(Ilist[0] - Ilist[U-1], Jlist[0] - Jlist[U-1]);
      int T = min(Nrange, Mrange);
      EndOutlierNL = T - L + 1;
      if(DEBUG>=1+RELEASE && !(EndOutlierNL > 0)){
	printf("U=%d,Ilist[0]=%d,Ilist[U-1]=%d,Jlist[0]=%d,Jlist[U-1]=%d,L=%d,N=%d,M=%d,T=%d,EndOutlierNL=%d\n",
	       U,Ilist[0],Ilist[U-1],Jlist[0],Jlist[U-1],L,N,M,T,EndOutlierNL);
	fflush(stdout);
	assert(EndOutlierNL > 0);
      }
      EndOutlierNL = max(2, EndOutlierNL);
    } else
      EndOutlierNL = 2;
  }

  double logFP = pvalue(Yfrag,Xfrag,F, misscnt,falsecnt,OutlierCnt,logOutlierMN,EndOutlierNL,Ylambda,res[0]*PixelLen,verb,refid,mapid,orientation);
  if(DEBUG && !(isfinite(logFP))){
    (void)pvalue(Yfrag,Xfrag,F, misscnt,falsecnt,OutlierCnt,logOutlierMN,EndOutlierNL,Ylambda,res[0]*PixelLen,1,refid,mapid,orientation);
    fprintf(stderr,"alignFP:I=%d,J=%d:logFP=%e,misscnt=%d(Rij=%d),falsecnt=%0.1f(Rijx=%d),Outliers=%d,logMN=%0.6f\n",
	    I,J,logFP,misscnt,Rij,falsecnt,Rijx,OutlierCnt,logOutlierMN);
    fflush(stderr);
    assert(isfinite(logFP));
  }
  
  if(shift){
    if(logFP > prevLogFP){/* try converting interval with largest relative error into outlier to see if that improves logFP */
      G = Ilist[U-1];
      D = Klist[U-1];
      H = Jlist[U-1];
  
      double maxrelerr = 0.0;
      int maxT = -1;

      for(int T = 1; T < U; T++, G = I, H = J, D = K){
	I = Ilist[U-1-T];
	K = Klist[U-1-T];
	J = Jlist[U-1-T];
	if(outlier[U-T])
	  continue;
	double y = Yc(Y,I,K) - Yc(Y,G,D);
	double x = X[J] - X[H];
	if(fabs(x-y) > maxrelerr * (x + y)){
	  maxrelerr = fabs(x-y)/(x+y);
	  maxT = T;
	}
      }
      if(maxT > 0 && 
	 !(PVALUE_FIX && (maxT==1 || maxT==U-1))){//  If maxT is first or last interval, skip this (HERE : could consider turning it into an endoutlier but that is more complicated)
	outlier[U-maxT] = 1;
	if(VERB/* HERE */ >=2 && verb){
	  printf("Repeating after converting interval T=%d..%d (relerr=%0.6f)to outlier\n",maxT-1,maxT,maxrelerr);
	  fflush(stdout);
	}
	prevLogFP = logFP;
	goto Lrepeat;
      }
    } else
      logFP = prevLogFP;
  }

  if(heap)
    delete [] Ilist;
  if(U > MAX_ALLOCA)
    delete [] Xfrag;

  return logFP;
}

class RepeatScoreRoot {
public:
  int scaleID;
  int *Kmax;
  int *JMIN;
  int *JMAX;
  int *Imin;
  int *Imax;
  int refid;
  int mapid;
  int N; int M;
  CHashMatch *phash;
  int tid;
  Cprtab **PRtabY;
  CYPen ****YPenR;
  int localtype;
  int IMIN;
  int IMAX;
  RFLOAT maxUscore;
  int bestI; int bestK; int bestJ;/* right end of best alignment */
  int U; int *Ilist; int *Klist; int *Jlist; /* best alignment */
  int bestI2; int bestK2; int bestJ2;/* right end of shifted alignment */
  double MinShiftKb; double MaxShiftKb;
  int shift; /* == bestJ - bestJ2 - (bestI - bestI2) */
};

static int stackoverflow_warning = 0;
static int checkRepeat_warning = 0;

static RFLOAT RepeatScore(RepeatScoreRoot *r,/* rarely used args */
			  Cmap *rmap,
			  Cmap *nanomap,
			  int orientation,
			  int rev,
			  FLOAT *Y,
			  FLOAT *X,
			  AL *A,
			  CXPen *XPen,
			  Calign *align,
			  int I, int K, int J, /* Current location in shifted alignment : updated A->rscore(I,K,J),A->rG(I,K,J),A->rH(I,K,J) recursively */
			  int T2,
			  int depth)
{
  if(VERB>=2 && depth > 0 && !(depth % 1000)){
    #pragma omp critical
    {
      int tid = 0;
#ifdef _OPENMP
      tid = omp_get_thread_num ();
#endif
      printf("RepeatScore recursion depth=%d, tid=%d\n",depth,tid);
      fflush(stdout);
    }
  }

  if(DEBUG/* HERE HERE >=2 */) assert(r->IMIN <= I && I <= r->IMAX);
  if(DEBUG/* HERE HERE >=2 */) assert(r->JMIN[I] <= J && J <= r->JMAX[I]);

  if(DEBUG>=2) assert(r->shift != 0);

  if(PVERB>=3 && r->shift == SHIFT_TRACE){
    printf("RepeatScore Start:rid=%lld,mid=%lld,or=%d,rev=%d:depth=%d:I=%d,K=%d,J=%d,T2=%d,shift=%d,A->shift(I,K,J)=%d\n",
	   rmap->id,nanomap->id,orientation,rev,depth,I,K,J,T2,r->shift, A->shift(I,K,J));
    fflush(stdout);
  }

  if(A->shift(I,K,J) == r->shift){
    /* NEW72 : A->rscore(I,K,J) is valid, but not all recursive score A->rscore(G,T,H) may still be valid : if needed recompute them so logPV() can be computed */
    int G = A->rG(I,K,J);
    if(G >= 0){
      int T = A->rT(I,K,J);
      int H = A->rH(I,K,J);
      (void)RepeatScore(r,rmap,nanomap,orientation,rev,Y,X,A,XPen,align,G,T,H,T2,depth+1);
    }

    if(PVERB>=3 && r->shift == SHIFT_TRACE){
      printf("RepeatScore Result:rid=%lld,mid=%lld,or=%d:depth=%d:I=%d,K=%d,J=%d,T2=%d,shift=%d,A->shift(I,K,J)=%d,A->rscore(I,K,J)=%0.4f\n",
	     rmap->id,nanomap->id,orientation,depth,I,K,J,T2,r->shift,A->shift(I,K,J),A->rscore(I,K,J));
      fflush(stdout);
    }

    return A->rscore(I,K,J);
  }

  A->shift(I,K,J) = r->shift;

  /* update A.rscore(I,K,J), A.rG(I,K,J), A.rT(I,K,J) & A.rH(I,K,J) by repeating recurrance computation constrained by alignment shift relative to best alignment remaining between MinShiftKb .. MaxShiftKb */

  /* Reduce index T2, if needed, until I >= (I2 == align->sites1[T2]), and J > (J2 == align->sites2[T2]) so ShiftKb is computed based on nearest location in best alignment
     Also keep MinShiftKb <= Yc(I2,align->siteK1[T2]) - Yc(I,K) + X[J] - X[J2] <= MaxShiftKb (NOTE : Assumes r->shift > 0, otherwise use -MaxShiftKb .. -MinShiftKb) */

  int simpleRepeat = (r->bestJ - r->bestJ2 >= 2 || r->bestI - r->bestI2 >=2) ? 0 : 1;
  if(FIX_CONSTRAINT && (FIX_CONSTRAINT>=2 || !simpleRepeat)){
    while(T2 > 0 && align->sites1[T2] > I)
      T2--;
  } else {
    while(T2 > 0 && align->sites1[T2-1] >= I)
      T2--;
  }

  RFLOAT score = A->Uscore(I,K,J);
  if(DEBUG>=2 && !(isfinite(score) && score <= r->maxUscore)){
    #pragma omp critical
    {
      printf("While Checking for repeats:RepeatRec=%d,MaxShift=%d,LogPvalueRatio=%0.4f,%0.4f,KbShiftRatio=%0.3f,%0.3f,MaxDrop=%d,extend=%d,Lij2=%d,Rij2=%d,M=%d(score=%0.6f,LogPV=%0.2f,numpairs=%d,repeat=%d)\n",
	     RepeatRec,RepeatMaxShift,RepeatLogPvalueRatio,RepeatLogPvalueRatioPerLabel,RepeatKbShiftRatio,RepeatKbShiftRatio2,RepeatMaxLabelDrop,
	     extend,align->Lij2,align->Rij2,r->M,align->score,align->logPV,align->numpairs,align->repeat);
      printf("  refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:I=%d,K=%d,J=%d:IMIN=%d,IMAX=%d,JMIN[I]=%d,JMAX[I]=%d,Kmax[I]=%d:A->Uscore(I,K,J)= %0.6f,A->score(I,K,J)=%0.6f\n",
	     r->refid,rmap->id,r->mapid,nanomap->id,orientation,rev,r->scaleID,I,K,J,r->IMIN,r->IMAX,r->JMIN[I],r->JMAX[I],r->Kmax[I],A->Uscore(I,K,J),A->score(I,K,J));
      printf("  r->maxUscore= %0.6f\n",r->maxUscore);
      fflush(stdout);
      assert(isfinite(score));
      assert(score <= r->maxUscore);
    }
  }
  int bestG = r->localtype;
  int bestH = -1;
  int bestT = -1;

  if(PVERB>=3 && r->shift == SHIFT_TRACE){
    #pragma omp critical
    {
      if(r->bestJ > r->bestJ2)
	printf("Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d,bestJ-bestJ2=%d:I=%d,K=%d,J=%d,shift=%d:A->Uscore(I,K,J)=%0.6f,bestG=%d\n",
	       rmap->id,nanomap->id,orientation,rev,depth,r->bestJ - r->bestJ2,I,K,J,A->shift(I,K,J),score,bestG);
      else
	printf("Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d,bestI-bestI2=%d:I=%d,K=%d,J=%d,shift=%d:A->Uscore(I,K,J)=%0.6f,bestG=%d\n",
	       rmap->id,nanomap->id,orientation,rev,depth,r->bestI - r->bestI2,I,K,J,A->shift(I,K,J),score,bestG);
      fflush(stdout);
    }
  }

  int Gmin = max(r->IMIN,I-K-DELTA_Y);
  int T3 = T2;
	    
  if(depth >= MAX_STACKDEPTH){/* give up and return score based on alignment terminating at this point : may miss very long repeats */
    if(VERB>=2 || !stackoverflow_warning){
      #pragma omp critical
      {
	if(!stackoverflow_warning){
	  stackoverflow_warning = 1;
	  printf("RepeatScore: stack depth = %d exceeds limit : giving up check for repeat for alignments larger than this many labels\n",depth);
	  fflush(stdout);
	}
      }
    }
    goto Lreturn;
  }

  if(maptype) {
    for(int G= I-K; --G >= Gmin;){
      FLOAT XG;/* best estimate of original alignment location on X[] corresponding to Y[G] */
      int origT3 = T3;
      while(T3 < r->U - 1 && align->sites1[T3] - align->sitesK1[T3] < G)
	T3++;
      while(T3 > 0 && align->sites1[T3-1] - align->sitesK1[T3-1] >= G)
	T3--;
      int I3 = align->sites1[T3];
      int K3 = align->sitesK1[T3];
      int J3 = align->sites2[T3];

      if(DEBUG>=2 && !(T3 >= r->U-1 || I3 - K3 >= G)){
	#pragma omp critical
	{
	  printf("While Checking for repeats:RepeatRec=%d,MaxShift=%d,LogPvalueRatio=%0.4f,%0.4f,RepeatKbShiftRatio=%0.3f,%0.3f,MaxDrop=%d,extend=%d,Lij2=%d,Rij2=%d,M=%d(score=%0.6f,LogPV=%0.2f,numpairs=%d,repeat=%d)\n",
		 RepeatRec,RepeatMaxShift,RepeatLogPvalueRatio,RepeatLogPvalueRatioPerLabel,RepeatKbShiftRatio,RepeatKbShiftRatio2,RepeatMaxLabelDrop,
		 extend,align->Lij2,align->Rij2,r->M,align->score,align->logPV,align->numpairs,align->repeat);
	  printf("Yid=%d(id=%lld),Xid=%d(id=%lld),or=%d:bestI=%d,bestK=%d,bestJ=%d,score=%0.4f,logPV=%0.2f,numpairs=%d:bestI2=%d,bestK2=%d,bestJ2=%d,maptype=%d:\n",
		 r->refid,rmap->id,r->mapid,nanomap->id,orientation, r->bestI,r->bestK,r->bestJ,align->score,align->logPV,align->numpairs,r->bestI2,r->bestK2,r->bestJ2,maptype);
	  printf("U=%d,T2=%d,I=%d,K=%d,J=%d,G=%d:T3=%d->%d:I3=%d,K3=%d,J3=%d\n",
		 r->U,T2,I,K,J,G,origT3, T3,I3,K3,J3);
	  fflush(stdout);
	  assert(T3 >= r->U - 1 || I3 - K3 >= G);
	}
      }
			
      int T4 = T3;
      while(T4 > 0 && align->sites1[T4] > G)
	T4--;
      int I4 = align->sites1[T4];

      if(DEBUG>=2 && !(T4 <= 0 || I4 <= G)){
	#pragma omp critical
	{
	  printf("While Checking for repeats:RepeatRec=%d,MaxShift=%d,LogPvalueRatio=%0.4f,%0.4f,KbShiftRatio=%0.3f,%0.3f,MaxDrop=%d,extend=%d,Lij2=%d,Rij2=%d,M=%d(score=%0.6f,LogPV=%0.2f,numpairs=%d,repeat=%d)\n",
		 RepeatRec,RepeatMaxShift,RepeatLogPvalueRatio,RepeatLogPvalueRatioPerLabel,RepeatKbShiftRatio,RepeatKbShiftRatio2,RepeatMaxLabelDrop,
		 extend,align->Lij2,align->Rij2,r->M,align->score,align->logPV,align->numpairs,align->repeat);
	  printf("Yid=%d(id=%lld),Xid=%d(id=%lld),or=%d:bestI=%d,bestK=%d,bestJ=%d,score=%0.4f,logPV=%0.2f,numpairs=%d:bestI2=%d,bestK2=%d,bestJ2=%d,maptype=%d:\n",
		 r->refid,rmap->id,r->mapid,nanomap->id,orientation, r->bestI,r->bestK,r->bestJ,align->score,align->logPV,align->numpairs,r->bestI2,r->bestK2,r->bestJ2,maptype);
	  printf("U=%d,T2=%d,I=%d,K=%d,J=%d,G=%d:T3=%d->%d,T4=%d:I3=%d,K3=%d,J3=%d,I4=%d\n",
		 r->U,T2,I,K,J,G,origT3, T3, T4, I3,K3,J3, I4);
	  fflush(stdout);
	  assert(T4 <= 0 || I4 <= G);
	}
      }
      origT3 = T3;

      if(G < I4){
	int K4 = align->sitesK1[T4];
	int J4 = align->sites2[T4];
	if(I4 - K4  <= G)
	  XG = X[J4];
	else
	  XG = X[J4] - (Yc(Y,I4,K4) - Y[G]);
      } else if(I3-K3 > I4){
	if(DEBUG>=2) assert(I4 <= G && G <= I3-K3);
	if(DEBUG>=2) assert(Y[I3-K3] > Y[I4]);
	FLOAT Gfrac = (Y[G] - Y[I4])/(Y[I3 - K3] - Y[I4]);
	int J4 = align->sites2[T4];
	XG = X[J4] + Gfrac * (X[J3] - X[J4]);
      } else  {
	if(DEBUG>=2 && !(I3-K3 == I4)){
	  #pragma omp critical
	  {
	    int K4 = align->sitesK1[T4];
	    int J4 = align->sites2[T4];			
	    printf("While Checking for repeats:RepeatRec=%d,MaxShift=%d,LogPvalueRatio=%0.4f,%0.4f,KbShiftRatio=%0.3f,%0.3f,MaxDrop=%d,extend=%d,Lij2=%d,Rij2=%d,M=%d(score=%0.6f,LogPV=%0.2f,numpairs=%d,repeat=%d)\n",
		   RepeatRec,RepeatMaxShift,RepeatLogPvalueRatio,RepeatLogPvalueRatioPerLabel,RepeatKbShiftRatio,RepeatKbShiftRatio2,RepeatMaxLabelDrop,
		   extend,align->Lij2,align->Rij2,r->M,align->score,align->logPV,align->numpairs,align->repeat);
	    printf("Yid=%d(id=%lld),Xid=%d(id=%lld),or=%d:bestI=%d,bestK=%d,bestJ=%d,score=%0.4f,logPV=%0.2f,numpairs=%d:bestI2=%d,bestK2=%d,bestJ2=%d,maptype=%d:\n",
		   r->refid,rmap->id,r->mapid,nanomap->id,orientation, r->bestI,r->bestK,r->bestJ,align->score,align->logPV,align->numpairs,r->bestI2,r->bestK2,r->bestJ2,maptype);

	    printf("T2=%d,I=%d,K=%d,J=%d,G=%d:T3=%d->%d,T4=%d:I3=%d,K3=%d,J3=%d,I4=%d,K4=%d,J4=%d\n",
		   T2,I,K,J,G,origT3, T3,T4,I3,K3,J3,I4,K4,J4);
	    fflush(stdout);
	    assert(I3-K3 == I4);
	  }
	}
	if(DEBUG>=2) assert(T3 == T4);
	XG = X[J3];
      }

      if(FIX_CONSTRAINT && (FIX_CONSTRAINT>=2 || !simpleRepeat)){
	while(T3 > 0 && align->sites1[T3] > G)
	  T3--;
      } else {
	while(T3 > 0 && align->sites1[T3-1] >= G)
	  T3--;
      }
      I3 = align->sites1[T3];
      K3 = align->sitesK1[T3];
      J3 = align->sites2[T3];

      int Hmin, Hmax, HminG = -1;
      FLOAT XHmin,XHmax;
      if(REPEATREC_FIX ? (r->shift > 0) : (r->bestJ > r->bestJ2)){ /* H must satisfy the constraint: H < J3 AND -MaxShiftKb <= Y[G] - Yc(G,T) + X[H] - XG <= -MinShiftKb */
	XHmax = XG - Y[G];
	XHmin = XHmax;
	Hmin = max(r->JMIN[G],J-DELTA_X);
	Hmax = min(r->JMAX[G],min(J,J3)-1);/* H must be <= this value */
	if(I3 < G && T3 < r->U - 1){
	  int I3 = align->sites1[T3+1];
	  int K3 = align->sitesK1[T3+1];
	  int J3 = align->sites2[T3+1];
	  if(X[J3] - Yc(Y,I3,K3) > XHmax)
	    XHmax = X[J3] - Yc(Y,I3,K3);
	  if(X[J3] - Yc(Y,I3,K3) < XHmin)
	    XHmin = X[J3] - Yc(Y,I3,K3);
	  if(Hmax < J3 - 1)
	    Hmax = min(r->JMAX[G],min(J,J3)-1);/* H must be <= this value */
	}
	if(G < I3 && T3 > 0){
	  int I3 = align->sites1[T3-1];
	  int K3 = align->sitesK1[T3-1];
	  int J3 = align->sites2[T3-1];
	  if(X[J3] - Yc(Y,I3,K3) > XHmax)
	    XHmax = X[J3] - Yc(Y,I3,K3);
	  if(X[J3] - Yc(Y,I3,K3) > XHmin)
	    XHmin = X[J3] - Yc(Y,I3,K3);
	  if(Hmax < J3 - 1)
	    Hmax = min(r->JMAX[G],min(J,J3)-1);/* H must be <= this value */
	}
	XHmax -= r->MinShiftKb;
	XHmin -= r->MaxShiftKb;
      } else {	if(DEBUG/* >=2 */ && !REPEATREC_FIX) assert(r->bestI > r->bestI2);
	/* H must satisfy the constraint: H > J3 AND MinShiftKb <= Y[G] - Yc(G,T) + X[H] - XG <= MaxShiftKb */
	XHmin = XG - Y[G];//Yc(Y,I3,K3);
	XHmax = XHmin;
	Hmin = max(r->JMIN[G],J-DELTA_X);
	HminG = max(Hmin,  J3+1);/* H must be >= this value */
	Hmax = min(r->JMAX[G],J-1);
	if(I3 < G && T3 < r->U - 1){
	  int I3 = align->sites1[T3+1];
	  int K3 = align->sitesK1[T3+1];
	  int J3 = align->sites2[T3+1];
	  if(X[J3] - Yc(Y,I3,K3) < XHmin)
	    XHmin = X[J3] - Yc(Y,I3,K3);
	  if(X[J3] - Yc(Y,I3,K3) > XHmax)
	    XHmax = X[J3] - Yc(Y,I3,K3);
	  if(HminG > J3+1)
	    HminG = max(Hmin,J3+1);
	}
	if(G < I3 && T3 > 0){
	  int I3 = align->sites1[T3-1];
	  int K3 = align->sitesK1[T3-1];
	  int J3 = align->sites2[T3-1];
	  if(X[J3] - Yc(Y,I3,K3) < XHmin)
	    XHmin = X[J3] - Yc(Y,I3,K3);
	  if(X[J3] - Yc(Y,I3,K3) > XHmax)
	    XHmax = X[J3] - Yc(Y,I3,K3);
	  if(HminG > J3+1)
	    HminG = max(Hmin,J3+1);
	}
	XHmin += r->MinShiftKb;
	XHmax += r->MaxShiftKb;
      }

      for(int T = r->Kmax[G]; T >= 0; T--){
	FLOAT XHTmax = Yc(Y,G,T) + XHmax;/* X[H] must be <= this value */
	FLOAT XHTmin = Yc(Y,G,T) + XHmin;/* X[H] must be >= this value */
	if(DEBUG>=2) assert(G-T >= 1);
	RFLOAT deltaY,Ivar,GaussY,Sm;
	RFLOAT penY = SintY(I-K-G,I,K,T,deltaY,Ivar,GaussY,Sm,r->YPenR);

	if(REPEATREC_FIX ? (r->shift > 0) : (r->bestJ > r->bestJ2)){
	  for(int H = Hmin; H <= Hmax; H++){
	    if(DEBUG>=2) assert(H >= r->JMIN[G]);
	    if(DEBUG>=2) assert(H <= r->JMAX[G]);
	    if(X[H] < XHTmin && H < Hmax)
	      continue;
	    if(X[H] > XHTmax)
	      break;
	    int m = J-H;
	    RFLOAT deltaX = XPen->deltaX[m][J];
	    RFLOAT newscore = RepeatScore(r,rmap,nanomap,orientation,rev,Y,X,A,XPen,align,G,T,H,T2,depth+1) + 
	      SintX_maptype1(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J]);
	    if(newscore > score){
	      if(PVERB>=3 && r->shift == SHIFT_TRACE){
		#pragma omp critical
		{
		  printf("\t I=%d,K=%d,J=%d,G=%d,T=%d,H=%d,depth=%d,shift=%d,%0.3f:x=%0.3f,y=%0.3f,A->rscore(G,T,H)=%0.6f(shift=%d,p=%d,%d,%d),delta=%0.6f:score=%0.6f->%0.6f\n",
			 I,K,J,G,T,H,depth,A->shift(I,K,J),X[H]-XHTmin + r->MinShiftKb,deltaX,deltaY,
			 A->rscore(G,T,H), A->shift(G,T,H),A->rG(G,T,H),A->rT(G,T,H),A->rH(G,T,H), newscore - A->rscore(G,T,H), score, newscore);
		  fflush(stdout);
		}
	      }
	      score = newscore;
	      bestG = G;
	      bestH = H;
	      bestT = T;
	    } else if(PVERB>=3 && r->shift == SHIFT_TRACE){
	      #pragma omp critical
	      {
		printf("\t I=%d,K=%d,J=%d,G=%d,T=%d,H=%d,depth=%d,shift=%d,%0.3f:x=%0.3f,y=%0.3f,A->rscore(G,T,H)=%0.6f(shift=%d,p=%d,%d,%d),delta=%0.6f,newscore=%0.6f:score=%0.6f,bestG=%d,bestT=%d,bestH=%d\n",
		       I,K,J,G,T,H,depth, A->shift(I,K,J),X[H]-XHTmin+ r->MinShiftKb,deltaX,deltaY,
		       A->rscore(G,T,H),A->shift(G,T,H),A->rG(G,T,H),A->rT(G,T,H),A->rH(G,T,H),newscore - A->rscore(G,T,H),newscore,score,bestG,bestT,bestH);
		fflush(stdout);
	      }
	    }
	  }
	} else { if(DEBUG/* >=2*/ && !REPEATREC_FIX) assert(r->bestI > r->bestI2);
	  for(int H = Hmax; H >= HminG; H--){
	    if(DEBUG>=2) assert(H >= r->JMIN[G]);
	    if(DEBUG>=2) assert(H <= r->JMAX[G]);
	    if(X[H] > XHTmax && H > HminG)
	      continue;
	    if(X[H] < XHTmin)
	      break;
	    int m = J-H;
	    RFLOAT deltaX = XPen->deltaX[m][J];
	    RFLOAT newscore = RepeatScore(r,rmap,nanomap,orientation,rev,Y,X,A,XPen,align,G,T,H,T2,depth+1) + 
	      SintX_maptype1(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J]);
	    if(newscore > score){
	      if(PVERB>=3 && r->shift == SHIFT_TRACE){
		#pragma omp critical
		{
		  printf("Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d,bestI-bestI2=%d:I=%d,K=%d,J=%d,shift=%d,G=%d,T=%d,H=%d:x=%0.3f,y=%0.3f,A->rscore(G,T,H)=%0.4f,delta=%0.4f,shift(G,T,H)=%d:score=%0.4f->%0.4f\n",
			 rmap->id,nanomap->id,orientation,rev,depth,r->bestI-r->bestI2,I,K,J,A->shift(I,K,J),G,T,H,deltaX,deltaY,A->rscore(G,T,H),newscore - A->rscore(G,T,H),A->shift(G,T,H),score,newscore);
		  fflush(stdout);
		}
	      }
	      score = newscore;
	      bestG = G;
	      bestH = H;
	      bestT = T;
	    } else if(PVERB>=3 && r->shift == SHIFT_TRACE){
	      #pragma omp critical
	      {
		printf("Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d,bestI-bestI2=%d:I=%d,K=%d,J=%d,shift=%d,G=%d,T=%d,H=%d:x=%0.3f,y=%0.3f,A->rscore(G,T,H)=%0.4f,delta=%0.4f,shift(G,T,H)=%d,newscore=%0.4f:score=%0.4f\n",
		       rmap->id,nanomap->id,orientation,rev,depth,r->bestI-r->bestI2,I,K,J,A->shift(I,K,J),G,T,H,deltaX,deltaY,A->rscore(G,T,H),newscore - A->rscore(G,T,H),A->shift(G,T,H),newscore,score);
		fflush(stdout);
	      }
	    }
	  }
	} /* r->shift < 0 */
      } /* for(T = Kmax[G]; T >= 0; T--) */
    }/* for(G = I-K; --G >= Gmin;) */
  } else {/* maptype==0 */
    for(int G= I-K; --G >= Gmin;){
      FLOAT XG;/* best estimate of original alignment location on X[] corresponding to Y[G] */
      while(T3 < r->U - 1 && align->sites1[T3] - align->sitesK1[T3] < G)
	T3++;
      while(T3 > 0 && align->sites1[T3-1] - align->sitesK1[T3-1] >= G)
	T3--;
      int I3 = align->sites1[T3];
      int K3 = align->sitesK1[T3];
      int J3 = align->sites2[T3];
      if(DEBUG>=2) assert(T3 >= r->U-1 || I3 - K3 >= G);

      int T4 = T3;
      while(T4 > 0 && align->sites1[T4] > G)
	T4--;
      int I4 = align->sites1[T4];
      if(DEBUG>=2) assert(T4 <= 0 || I4 <= G);

      if(G < I4){
	int K4 = align->sitesK1[T4];
	int J4 = align->sites2[T4];
	if(I4 - K4  <= G)
	  XG = X[J4];
	else
	  XG = X[J4] - (Yc(Y,I4,K4) - Y[G]);
      } else if(I3-K3 > I4){
	if(DEBUG>=2) assert(I4 <= G && G <= I3-K3);
	if(DEBUG>=2 && !(Y[I3-K3] > Y[I4])){
	  printf("rid=%lld,mid=%lld,or=%d,bestI=%d,bestK=%d,bestJ=%d,bestI2=%d,bestK2=%d,bestJ2=%d:\n\t U=%d,T2=%d,I=%d,K=%d,J=%d,Gmin=%d:G=%d,T3=%d,I3=%d,K3=%d,J3=%d,T4=%d,I4=%d,Y[I3-K3]=%0.6f,Y[I4]=%0.6f\n",
		 rmap->id,nanomap->id,orientation,r->bestI,r->bestK,r->bestJ,r->bestI2,r->bestK2,r->bestJ2,r->U,T2,I,K,J,Gmin,G,T3,I3,K3,J3,T4,I4,Y[I3-K3],Y[I4]);
	  fflush(stdout);
	  assert(Y[I3-K3] > Y[I4]);
	}
	FLOAT Gfrac = (Y[G] - Y[I4])/(Y[I3 - K3] - Y[I4]);
	int J4 = align->sites2[T4];
	XG = X[J4] + Gfrac * (X[J3] - X[J4]);
      } else  {
	if(DEBUG>=2) assert(I3-K3 == I4);
	if(DEBUG>=2) assert(T3 == T4);
	XG = X[J3];
      }
		    
      if(FIX_CONSTRAINT && (FIX_CONSTRAINT>=2 || !simpleRepeat)){
	while(T3 > 0 && align->sites1[T3] > G)
	  T3--;
      } else {
	while(T3 > 0 && align->sites1[T3-1] >= G)
	  T3--;
      }
      I3 = align->sites1[T3];
      K3 = align->sitesK1[T3];
      J3 = align->sites2[T3];

      int Hmin,Hmax,HminG = -1;
      FLOAT XHmin,XHmax;
      if(REPEATREC_FIX ? (r->shift > 0) : (r->bestJ > r->bestJ2)){ /*  H must satisfy the constraint: H < J3 AND -MaxShiftKb <= Y[G] - Yc(G,T) + X[H] - XG <= -MinShiftKb */
	XHmax = XG - Y[G];
	XHmin = XHmax;
	Hmax = min(r->JMAX[G],min(J,J3)-1);
	Hmin = max(r->JMIN[G],J-DELTA_X);
	if(I3 < G && T3 < r->U - 1){
	  int I3 = align->sites1[T3+1];
	  int K3 = align->sitesK1[T3+1];
	  int J3 = align->sites2[T3+1];
	  if(X[J3] - Yc(Y,I3,K3) > XHmax)
	    XHmax = X[J3] - Yc(Y,I3,K3);
	  if(X[J3] - Yc(Y,I3,K3) < XHmin)
	    XHmin = X[J3] - Yc(Y,I3,K3);
	  if(Hmax < J3 - 1)
	    Hmax = min(r->JMAX[G],min(J,J3)-1);/* H must be <= this value */
	}
	if(G < I3 && T3 > 0){
	  int I3 = align->sites1[T3-1];
	  int K3 = align->sitesK1[T3-1];
	  int J3 = align->sites2[T3-1];
	  if(X[J3] - Yc(Y,I3,K3) > XHmax)
	    XHmax = X[J3] - Yc(Y,I3,K3);
	  if(X[J3] - Yc(Y,I3,K3) > XHmin)
	    XHmin = X[J3] - Yc(Y,I3,K3);
	  if(Hmax < J3 - 1)
	    Hmax = min(r->JMAX[G],min(J,J3)-1);/* H must be <= this value */
	}
	XHmax -= r->MinShiftKb;
	XHmin -= r->MaxShiftKb;
      } else {
	if(DEBUG>=2 && !REPEATREC_FIX) assert(r->bestI > r->bestI2);
	/* H must satisfy the constraint: H > J3 AND MinShiftKb <= Y[G] - Yc(G,T) + X[H] - XG <= MaxShiftKb */
	XHmin = XG - Y[G];// Yc(Y,I3,K3);
	XHmax = XHmin;
	Hmin = max(r->JMIN[G],J-DELTA_X);		  
	HminG = max(Hmin,J3+1);/* H must be >= than this value */
	Hmax = min(r->JMAX[G],J-1);

	if(I3 < G && T3 < r->U - 1){
	  int I3 = align->sites1[T3+1];
	  int K3 = align->sitesK1[T3+1];
	  int J3 = align->sites2[T3+1];
	  if(X[J3] - Yc(Y,I3,K3) < XHmin)
	    XHmin = X[J3] - Yc(Y,I3,K3);
	  if(X[J3] - Yc(Y,I3,K3) > XHmax)
	    XHmax = X[J3] - Yc(Y,I3,K3);
	  if(HminG > J3+1)
	    HminG = max(Hmin,J3+1);
	}		    
	if(G < I3 && T3 > 0){
	  int I3 = align->sites1[T3-1];
	  int K3 = align->sitesK1[T3-1];
	  int J3 = align->sites2[T3-1];
	  if(X[J3] - Yc(Y,I3,K3) < XHmin)
	    XHmin = X[J3] - Yc(Y,I3,K3);
	  if(HminG > J3+1)
	    HminG = max(Hmin,J3+1);
	}
	XHmin += r->MinShiftKb;
	XHmax += r->MaxShiftKb;
      }

      for(int T = r->Kmax[G]; T >= 0; T--){
	FLOAT XHTmax = Yc(Y,G,T) + XHmax;/* X[H] must be <= this value */
	FLOAT XHTmin = Yc(Y,G,T) + XHmin;/* X[H] must be >= this value */
	if(DEBUG>=2) assert(G-T >= 1);
	RFLOAT deltaY,Ivar,GaussY,Sm;
	RFLOAT penY = SintY(I-K-G,I,K,T,deltaY,Ivar,GaussY,Sm,r->YPenR);

	if(REPEATREC_FIX ? (r->shift > 0) : (r->bestJ > r->bestJ2)){
	  for(int H = Hmin; H <= Hmax; H++){
	    if(DEBUG>=2) assert(H >= r->JMIN[G]);
	    if(DEBUG>=2) assert(H <= r->JMAX[G]);
	    if(X[H] < XHTmin && H < Hmax)
	      continue;
	    if(X[H] > XHTmax)
	      break;
	    int m = J-H;
	    RFLOAT deltaX = XPen->deltaX[m][J];
	    RFLOAT repscore = RepeatScore(r,rmap,nanomap,orientation,rev,Y,X,A,XPen,align,G,T,H,T2,depth+1);
	    RFLOAT sint = SintX_maptype0(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J],0);
	    RFLOAT newscore = repscore + sint;
	    if(newscore > score){
	      if(PVERB>=3){
		#pragma omp critical
		{
		  printf("\t I=%d,K=%d,J=%d,G=%d,T=%d,H=%d:x=%0.3f,y=%0.3f,A->rscore(G,T,H)=%0.4f(p=%d,%d,%d),delta=%0.4f:score=%0.4f->%0.4f(rep=%0.4f,sint=%0.4f)\n",
			 I,K,J,G,T,H,deltaX,deltaY,A->rscore(G,T,H),A->rG(G,T,H),A->rT(G,T,H),A->rH(G,T,H),newscore - A->rscore(G,T,H),score,newscore,repscore,sint);
		  fflush(stdout);
		}
	      }
	      score = newscore;
	      bestG = G;
	      bestH = H;
	      bestT = T;
	      if(DEBUG>=2) assert(A->shift(G,T,H) == r->shift && r->shift != 0);
	    } else if(PVERB>=3){
	      #pragma omp critical
	      {
		printf("\t I=%d,K=%d,J=%d,G=%d,T=%d,H=%d:x=%0.3f,y=%0.3f,A->rscore(G,T,H)=%0.4f(p=%d,%d,%d),delta=%0.4f,newscore=%0.4f(rep=%0.4f,sint=%0.4f):score=%0.4f\n",
		       I,K,J,G,T,H,deltaX,deltaY,A->rscore(G,T,H),A->rG(G,T,H),A->rT(G,T,H),A->rH(G,T,H),newscore- A->rscore(G,T,H),newscore,repscore,sint,score);
		fflush(stdout);
	      }
	    }
	  }
	} else {
	  if(DEBUG>=2 && !REPEATREC_FIX) assert(r->bestI > r->bestI2);
	  for(int H = Hmax; H >= HminG; H--){
	    if(DEBUG>=2) assert(H >= r->JMIN[G]);
	    if(DEBUG>=2) assert(H <= r->JMAX[G]);
	    if(X[H] > XHTmax && H > HminG)
	      continue;
	    if(X[H] < XHTmin)
	      break;
	    // end DELTA
	    int m = J-H;
	    RFLOAT deltaX = XPen->deltaX[m][J];
	    RFLOAT repscore = RepeatScore(r,rmap,nanomap,orientation,rev,Y,X,A,XPen,align,G,T,H,T2,depth+1);
	    RFLOAT sint = SintX_maptype0(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J],0);
	    RFLOAT newscore = repscore + sint;
	    if(newscore > score){
	      if(PVERB>=3){
		#pragma omp critical
		{
		  printf("Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d,bestI-bestI2=%d:I=%d,K=%d,J=%d,G=%d,T=%d,H=%d:x=%0.3f,y=%0.3f,A->rscore(G,T,H)=%0.4f,delta=%0.4f:score=%0.4f->%0.4f(rep=%0.4f,sint=%0.4f)\n",
			 rmap->id,nanomap->id,orientation,rev,depth,r->bestI - r->bestI2,I,K,J,G,T,H,deltaX,deltaY,A->rscore(G,T,H),newscore - A->rscore(G,T,H),score,newscore,repscore,sint);
		  fflush(stdout);
		}
	      }
	      score = newscore;
	      bestG = G;
	      bestH = H;
	      bestT = T;
	      if(DEBUG>=2) assert(A->shift(G,T,H) == r->shift && r->shift != 0);
	    } else if(PVERB>=3){
	      #pragma omp critical
	      {
		printf("Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d,bestI-bestI2=%d:I=%d,K=%d,J=%d,G=%d,T=%d,H=%d:x=%0.3f,y=%0.3f,A->rscore(G,T,H)=%0.4f,delta=%0.4f,newscore=%0.4f(rep=%0.4f,sint=%0.4f):score=%0.4f\n",
		       rmap->id,nanomap->id,orientation,rev,depth,r->bestI-r->bestI2,I,K,J,G,T,H,deltaX,deltaY,A->rscore(G,T,H),newscore - A->rscore(G,T,H),newscore,repscore,sint,score);
		fflush(stdout);
	      }
	    }
	  }
	} /* r->shift < 0 */
      }
    }
  }/* maptype == 0 */

  if(PVERB>=3 && r->shift == SHIFT_TRACE){
    #pragma omp critical
    {
      if(bestG > 0)
	printf("  Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d:I=%d,K=%d,J=%d,Gmin=%d:shift=%d,rscore=%0.6e->%0.6f,rG=%d,rT=%d,rH=%d,JMIN[G]=%d,JMAX[G]=%d\n",
	       rmap->id,nanomap->id,orientation,rev,depth,I,K,J,Gmin,A->shift(I,K,J),A->Uscore(I,K,J),score,bestG,bestH,bestT,r->JMIN[bestG],r->JMAX[bestG]);
      else
	printf("  Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d:I=%d,K=%d,J=%d,Gmin=%d:shift=%d,rscore=%0.6e->%0.6f,rG=%d,rT=%d,rH=%d\n",
	       rmap->id,nanomap->id,orientation,rev,depth,I,K,J,Gmin,A->shift(I,K,J),A->Uscore(I,K,J),score,bestG,bestH,bestT);
      fflush(stdout);
    }
  }

  if(DEBUG>=2 && bestG > 0){
    assert(r->shift == A->shift(I,K,J));
    assert(r->shift != 0);
    assert(bestT >= 0);
    assert(bestH > 0);
  }

 Lreturn:
  A->rscore(I,K,J) = score;
  A->rG(I,K,J) = bestG;
  A->rH(I,K,J) = bestH;
  A->rT(I,K,J) = bestT;
	    
  if(bestG == -1 /* WAS440 bestG < 0 */){/* left end : check if we need to initialize Lijx,Lijy used in alignFPsd() (NOTE : may mess up a regular alignment that relies on "uninitialized" Lijx,Lij) */
    if(extend && !(I-K <= DELTA_Y || J <= DELTA_X)){/* initialize A->Lijx(I,K,J) */
      int Lijx = 0;
      FLOAT y = Yc(Y,I,K);
      /* update Lijx by incrementing it until X[Lijx] overlaps Y */
      while(X[J]-X[Lijx] > y)
	Lijx++;
      if(DEBUG>=2)	    assert(Lijx <= J && !(X[J]-X[Lijx] > y) && (Lijx==0 || X[J]-X[Lijx-1] > y));
      A->Lijx(I,K,J) = Lijx;
    }
    if(!(J <= DELTA_X || (extend && I-K <= DELTA_Y))){/* initialize A->Lij(I,K,J) */
      RFLOAT AscoreIKJ = A->score(I,K,J), score;

      if(extend){ /* this is the commonly used case */
	//        int origLij = A->Lij(I,K,J),origLijx= A->Lijx(I,K,J);

	int Lijk = 0;
	FLOAT y = Yc(Y,I,K);

	/* update Lijk by incrementing it until Y[Lijk] overlaps X */
	while(y-X[J] > Y[Lijk])
	  Lijk++;
	if(DEBUG>=2)  assert(Lijk <= I && !(y-X[J] > Y[Lijk]) && (Lijk<=0 || y-X[J] > Y[Lijk-1]));
	int Lijky = A->Lij(I,K,J) = min(Lijk,I-K);

	int Lijkx = A->Lijx(I,K,J);
	RFLOAT Smjik = r->PRtabY[K][I].Sm /* Sm(J,I,K,Y)*/;
	if((score = Send(min(X[J],y),J+1-max(1,Lijkx),I-K+1-max(1,Lijky),I-K,r->refid,0) + Smjik) > AscoreIKJ){
	  AscoreIKJ = score;
	  if(!REPEATMASK_FIX)
	    A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */
	}
	if(ENDFIX && Lijkx <= 0){
	  for(int U= Lijky; U < I-K; U++){
	    RFLOAT bound = Sbnd(X[J],y-Y[U],J,I-K-U,I-K, r->refid) + Smjik;
	    if(bound > AscoreIKJ){
	      AscoreIKJ = bound;
	      if(!REPEATMASK_FIX)
		A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */
	      A->Lij(I,K,J) = U+1;/* NOTE : dont update Lijk, since it is being used by next p's Lij estimate */
	      if(!ENDFIX2)
		continue;
	    }
	    if(!ENDFIX2)
	      break;
	  }
	}
	if(ENDFIX && Lijk <= 0){
	  for(int U= Lijkx; U < J; U++){
	    RFLOAT bound = Sbnd(X[J]-X[U],y,J-U,I-K,I-K, r->refid) + Smjik;
	    if(bound > AscoreIKJ){
	      AscoreIKJ = bound;
	      if(!REPEATMASK_FIX)
		A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */
	      Lijkx = U+1;
	      if(!ENDFIX2)
		continue;
	    }
	    if(!ENDFIX2)
	      break;
	  }
	  A->Lijx(I,K,J) = Lijkx;
	}
	/*	if(VERB>=2 && rmap->id==REF_TRACE && nanomap->id==MAP_TRACE && orientation == OR_TRACE && I==7 && K==0 && J==8)
	  printf("\t I=%d,K=%d,J=%d:Updated Lijx= %d -> %d,Lij= %d -> %d\n", 
	  I,K,J,origLijx,A->Lijx(I,K,J),origLij,A->Lij(I,K,J));*/
      } else {/* extend == 0 */
	int Lijk = 0;
	FLOAT y = Yc(Y,I,K);
	/* update Lijk by incrementing it until Y[Lijk] overlaps X */
	while(y-Y[Lijk] > X[J])
	  Lijk++;
	if(DEBUG>=2) assert(Lijk <= I && !(y-Y[Lijk] > X[J]) && (Lijk==0 || y-Y[Lijk-1] > X[J]));
	A->Lij(I,K,J) = min(Lijk,I-K);

	int Lijkx = 0;
	if(Lijk > 0){
	  RFLOAT Smjik = r->PRtabY[K][I].Sm /* Sm(J,I,K,Y)*/;
	  if((score = Send(min(X[J],y),J+1-max(1,Lijkx),I-K+1-max(1,A->Lij(I,K,J)),I-K,r->refid,0) + Smjik) > AscoreIKJ){
	    AscoreIKJ = score;
	    if(!REPEATMASK_FIX)
	      A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */
	  }
	  if(ENDFIX && Lijkx <= 0){
	    for(int U= A->Lij(I,K,J);U < I-K; U++){
	      RFLOAT bound = Sbnd(X[J],y-Y[U],J,I-K-U,I-K,r->refid) + Smjik;
	      if(bound > AscoreIKJ){
		AscoreIKJ = bound;
		if(!REPEATMASK_FIX)
		  A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */
		A->Lij(I,K,J) = U+1;/* NOTE : dont update Lijk, since it is being used by next p's Lij estimate */
		if(!ENDFIX2)
		  continue;
	      }
	      if(!ENDFIX2)
		break;
	    }
	  }
	  if(DEBUG>=2) assert(!(ENDFIX && Lijk <= 0));
	}/* Lijk > 0 */
	if(ISLINEAR && isLinear){/* try to align left ends of X and Y */
	  RFLOAT Lend = Sint((RFLOAT)X[J],y,J,I-K,J,I,K,0,r->PRtabY,Y)/* includes Sm(J,I,K,Y)*/;
	  if(Lend > AscoreIKJ){
	    AscoreIKJ = Lend;
	    if(!REPEATMASK_FIX)
	      A->G(I,K,J) = A->H(I,K,J) = A->T(I,K,J) = 0;
	  }
	}
      }
    }
  }
  
  if(PVERB>=3 && r->shift == SHIFT_TRACE){
    #pragma omp critical
    {
      if(bestG > 0)
	printf("RepeatScore Result:Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d:I=%d,K=%d,J=%d,shift=%d:Gmin=%d:rscore=%0.6e->%0.6f,rG=%d,rT=%d,rH=%d,JMIN[G]=%d,JMAX[G]=%d\n",
	       rmap->id,nanomap->id,orientation,rev,depth,I,K,J,A->shift(I,K,J),
	       Gmin,A->Uscore(I,K,J),A->rscore(I,K,J),bestG,bestH,bestT,r->JMIN[bestG],r->JMAX[bestG]);
      else
	printf("RepeatScore Result:Yid=%lld,Xid=%lld,or=%d,rev=%d,depth=%d:I=%d,K=%d,J=%d,shift=%d:Gmin=%d:rscore=%0.6e->%0.6f,rG=%d,rT=%d,rH=%d\n",
	       rmap->id,nanomap->id,orientation,rev,depth,I,K,J,A->shift(I,K,J),
	       Gmin,A->Uscore(I,K,J),A->rscore(I,K,J),bestG,bestH,bestT);
      fflush(stdout);
    }
  }

  return A->rscore(I,K,J);// WAS72 score
}

void __attribute__ ((noinline)) checkRepeat(FLOAT *Y, int N,
					    FLOAT *X, int M,
					    int orientation,
					    int rev,
					    int scaleID,
					    int *Kmax,
					    AL *A,
					    int *JMIN, int *JMAX,/* preallocated memory JMIN[1..maxN],JMAX[1..maxN], for use with hashtable offset information for diagonalized arrays */
					    int *Imin, int *Imax,/* preallocated memory Imin[1..maxM],Imax[1..maxM], for use with hashtable offset information for diagonalized arrays */
					    Calign *align,
					    Cmap *rmap, Cmap *nanomap,
					    int refid, int mapid,/**< NOTE : due to multithreading, Gmap[] or refmap[] may be outdated cache values, but nanomap and rmap will correctly represent Gmap[mapid] & refmap[refid] */
					    CXPen *XPen,
					    CHashMatch *phash, /**< If != 0, limit map offset to within hashdelta of phash->offset (in kb) */
					    int tid,
					    Cprtab **PRtabY,
					    CYPen ****YPenR,
					    int localtype,
					    int IMIN, int IMAX,
					    int jmin, int jmax,
					    RFLOAT maxUscore,
					    RFLOAT *biasend2_values,
					    int bestI, int bestK, int bestJ,/* right end of best alignment */
					    int U, int *Ilist, int *Klist, int *Jlist /* best alignment */
					    )
// HERE HERE : should specify left end of best alignment and constrain shifted alignment to not extend beyond left end of both ref & qry
{
  if(align->numpairs > MAX_REPEATCHECK){// NEW402
    align->repeat = 0;
    if(VERB>=2 || !checkRepeat_warning){
      #pragma omp critical
      {
	if(!checkRepeat_warning){
	  checkRepeat_warning = 1;
	  printf("checkRepeat: Not checking repeats for alignments larger than %d labels\n",MAX_REPEATCHECK);
	  fflush(stdout);
	}
      }
    }
    return;
  }

  if(PVERB>=2){
    #pragma omp critical
    {
      printf("Checking for repeats:RepeatRec=%d,MaxShift=%d,LogPvalueRatio=%0.4f,%0.4f,KbShiftRatio=%0.3f,%0.3f,MaxDrop=%d,extend=%d,Lij2=%d,Rij2=%d,M=%d(score=%0.6f,LogPV=%0.2f,np=%d,I=%d,K=%d,J=%d,repeat=%d)\n",
	     RepeatRec,RepeatMaxShift,RepeatLogPvalueRatio,RepeatLogPvalueRatioPerLabel,RepeatKbShiftRatio,RepeatKbShiftRatio2,RepeatMaxLabelDrop,
	     extend,align->Lij2,align->Rij2,M,align->score,align->logPV,align->numpairs,bestI,bestK,bestJ,align->repeat);
      fflush(stdout);
    }
  }

  double minPvalue = LogPvThreshold * RepeatLogPvalueRatio /* WAS89 LogPvThreshold + log(RepeatPvalueRatio)/log(10.0)*/;

  int Umax = min(M,N);
  int *Ilist2, *Klist2, *Jlist2;
  if(Umax > MAX_ALLOCA){
    Ilist2 = new int[Umax*3];
    Klist2 = &Ilist2[Umax];
    Jlist2 = &Ilist2[Umax*2];
  } else {
    Ilist2 = (int *)alloca(Umax * sizeof(int));
    Klist2 = (int *)alloca(Umax * sizeof(int));
    Jlist2 = (int *)alloca(Umax * sizeof(int));
  }
	
#if REPEATREC_FIX >= 1
  // NEW105 : switch to shift loop and MinShiftKb and MaxShiftKb based on median kb shift for original alignment shifted by "shift" aligned labels
  int np = align->numpairs;
  double *kbShift;
  if(np > MAX_ALLOCA)
    kbShift = new double[np - 1];
  else
    kbShift = (double *)alloca((np-1) * sizeof(double));

  for(int ishift = 1; !align->repeat && ishift <= RepeatMaxShift; ishift++){
    if(np - ishift <= 0)
      continue;

    /* create kbShift[0.. np-ishift-1] and compute its median */
    for(int k = 0; k < np - ishift; k++){
      int J = align->sites2[k];
      int nJ = align->sites2[k + ishift];
      kbShift[k] = X[nJ] - X[J];
    }
    qsort(kbShift,np-ishift,sizeof(double), (intcmp *)DoubleInc);
    double Shift = ((np-ishift)%2) ? kbShift[(np-ishift)/2] : 0.5 * (kbShift[(np-ishift)/2] + kbShift[(np-ishift)/2 - 1]);/* Median value of kbShift[0..np-ishift-1] */

    double MinShiftKb = Shift * RepeatKbShiftRatio; /* minimum offset shift along entire alignment */
    double MaxShiftKb = Shift * RepeatKbShiftRatio2;/* maximum offset shift along entire alignment (to avoid creating new outliers) */

    /* locate rightmost pair of (re)aligned labels with offset falling within MinShiftKb .. MaxShiftKb */
    int kI = np-1, kJ = np-2;
    int bestI2 = align->sites1[kI];
    int bestK2 = align->sitesK1[kI];
    int bestJ2 = align->sites2[kJ];
    double ShiftKb = X[bestJ] - X[bestJ2] - (Yc(Y,bestI,bestK) - Yc(Y,bestI2,bestK2));
    while(!(MinShiftKb <= ShiftKb && ShiftKb <= MaxShiftKb)){
      if(PVERB>=3){
	printf("jshift=%d: np=%d,kI=%d,kJ=%d,bestI=%d->%d,bestK=%d->%d,bestJ=%d->%d,ShiftKb= %0.3f (min=%0.3f, median= %0.3f, max= %0.3f)\n",
	       ishift,np,kI,kJ,bestI,bestI2,bestK,bestK2,bestJ,bestJ2,ShiftKb,MinShiftKb,Shift,MaxShiftKb);
	fflush(stdout);
      }
      if(ShiftKb < MinShiftKb){/* increase ShiftKb by decreasing kJ */
	if(--kJ < 0)
	  break;
	bestJ2 = align->sites2[kJ];
      } else {/* decrease ShiftKb by decreasing kI */
	if(DEBUG) assert(ShiftKb > MaxShiftKb);
	if(--kI < 0)
	  break;
	bestI2 = align->sites1[kI];
	bestK2 = align->sitesK1[kI];
      }
      ShiftKb = X[bestJ] - X[bestJ2] - (Yc(Y,bestI,bestK) - Yc(Y,bestI2,bestK2));
    }

    if(!(MinShiftKb <= ShiftKb && ShiftKb <= MaxShiftKb))
      continue;

    if(!(IMIN <= bestI2 && bestI2 <= IMAX && JMIN[bestI2] <= bestJ2 && bestJ2 <= JMAX[bestI2]))
      continue;/* cannot compute alternate alignment : If there is a repeat it should be caught by an alignment shift in the opposite direction */

    if(PVERB>=2){
      printf("jshift=%d: np=%d,kI=%d,kJ=%d,bestI=%d->%d,bestK=%d->%d,bestJ=%d->%d,ShiftKb= %0.3f (min=%0.3f, median= %0.3f, max= %0.3f)\n",
	     ishift,np,kI,kJ,bestI,bestI2,bestK,bestK2,bestJ,bestJ2,ShiftKb,MinShiftKb,Shift,MaxShiftKb);
      fflush(stdout);
    }
#else

  int ishift;

  int bestI2 = bestI;
  int bestK2 = bestK;
  int bestJ2 = bestJ;

  for(bestJ2 = max(JMIN[bestI], align->sites2[max(0,U-1-RepeatMaxShift)]); !align->repeat && bestJ2 < bestJ; bestJ2++){
    double MinShiftKb = (X[bestJ]-X[bestJ2]) * RepeatKbShiftRatio; /* minimum offset shift along entire alignment */
    double MaxShiftKb = (X[bestJ]-X[bestJ2]) * RepeatKbShiftRatio2;/* maximum offset shift along entire alignment (to avoid creating new outliers) */
#endif

    /* back track best alignment from (bestI2,bestJ2) and compute its Pvalue and keep offset shift along entire alignment between MinShiftKb .. MaxShiftKb */	
    int I = bestI2;
    int K = bestK2;
    int J = bestJ2;

    if(PVERB>=3){
      #pragma omp critical
      {
	printf("Yid=%d(id=%lld),Xid=%d(id=%lld),or=%d:bestI=%d,bestK=%d,bestJ=%d,score=%0.4f,logPV=%0.2f,numpairs=%d:bestI2=%d,bestK2=%d,bestJ2=%d,maptype=%d:\n",
	       refid,rmap->id,mapid,nanomap->id,orientation, bestI,bestK,bestJ,align->score,align->logPV,align->numpairs,bestI2,bestK2,bestJ2,maptype);
	printf("  Best alignment(and with J offset=%d, I offset=%d) before updating backtrack:\n", bestJ - bestJ2, bestI - bestI2);
	for(int T = 0; T < U; T++){
	  int I = Ilist[U-1-T];
	  int K = Klist[U-1-T];
	  int J = Jlist[U-1-T];
	  if(T > 0)
	    printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d) (Y=%0.3f X=%0.3f):score= %0.6f,G=%d,T=%d,H=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],
		   Yc(Y,I,K) - Yc(Y,Ilist[U-T],Klist[U-T]), X[J] - X[Jlist[U-T]],A->score(I,K,J),A->G(I,K,J),A->T(I,K,J),A->H(I,K,J));
	  else
	    printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d):score=%0.6f,G=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],A->score(I,K,J),A->G(I,K,J));
	  fflush(stdout);

	  int J2 = J - (bestJ - bestJ2);
	  if(DEBUG) assert(IMIN <= I && I <= IMAX);
	  if(J2 >= 1 && JMIN[I] <= J2 && J2 <= JMAX[I]){
	    for(int K2 = 0; K2 <= K; K2++){
	      for(int I2 = I-K; I2 <= I; I2 += max(1,K)){
		if(Kmax[I2] < K)
		  continue;
		int G2 = A->G(I2,K2,J2);
		if(G2 > 0){
		  int T2 = A->T(I2,K2,J2);
		  int H2 =  A->H(I2,K2,J2);
		  FLOAT y = Yc(Y,I2,K2) - Yc(Y,G2,T2);
		  FLOAT x = X[J2] - X[H2];
		  FLOAT sint = Sint(x,y,J2-H2,I2-K2-G2,J2,I2,K2,T2,Y);
		  int numpairs, Lend;
		  
		  if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);

		  printf("\t    I2=%d,K2=%d,J2=%d (Y=%0.3f,X=%0.3f),sint=%0.6f:score=%0.6f,logPV=%0.3f,G2=%d,T2=%d,H2=%d,pscore=%0.6f\n",
			 I2,K2,J2,y,x, sint, A->score(I2,K2,J2), alignFPsd(A, I2, J2, K2, Y, X, N, M, IMAX-IMIN+1,jmax-jmin+1,-2, orientation, rev, scaleID, refid, mapid, 0, 0, numpairs, Lend, -1,0,0), G2, T2, H2, A->score(G2,T2,H2));
		} else
		  printf("\t    I2=%d,K2=%d,J2=%d:score=%0.6f,G2=%d\n",I2,K2,J2,A->score(I2,K2,J2),G2);
	      }
	    }
	  }
	}
	fflush(stdout);
      }
    }

    /* First compute bestscore2, bestR2 with rightmost alignment at (I,K,J) */
    /* NOTE: A->score(I,K,J) will be added to bestscore2 last, unlike for bestscore at bestI,bestK,bestJ */
    int bestR2 = -1;
    RFLOAT bestscore2 = MINSCORE;
    if(REPEAT_TRIM){
      bestR2 = localtype;
      bestscore2 = 0.0;
    } else if(PoutlierEnd > 0.0){
      bestR2 = localtype;
      bestscore2 = biasend2_values[J];
    }

    FLOAT Yik = Yc(Y,I,K);
    FLOAT y = Y[N+1] - Yik;

    if(!(J >= M+1-DELTA_X || (extend && I >= N+1-DELTA_Y))){	  /* need to initialize Rij, since this case was not previously initialized */
      int Rijk = N+1;
      /* update Rijk by decrementing it until Y[Rijk] overlaps X */
      while(Y[Rijk] > X[M+1]-X[J]+Yik)
	Rijk--;
      if(DEBUG>=2)    assert(Rijk >= I-K && !(Y[Rijk] > X[M+1]-X[J]+Yik) && (Rijk > N || Y[Rijk+1] > X[M+1]-X[J]+Yik));
      A->Rij(I,K,J) = max(Rijk,I);
    }
    if(extend && !(J >= M+1-DELTA_X || I >= N+1-DELTA_Y)){	  /* need to initialize Rijx, since this case was not previously initialized */
      int Rijkx = M+1;
      /* update Rijkx by decrementing it until X[Rijkx] overlaps Y */
      while(X[Rijkx] > y+X[J])
	Rijkx--;
      if(DEBUG>=2) assert(Rijkx >= J && !(X[Rijkx] > y+X[J]) && (Rijkx > M || X[Rijkx+1] > y+X[J]));
      A->Rijx(I,K,J) = Rijkx;
    }
	  
    int *ARijIK = &A->Rij(I,K,0);
    int *ARijxIK = &A->Rijx(I,K,0);
    if(extend || ARijIK[J] <= N){
      int Rijx = (extend ? ARijxIK[J] : M+1);
      if(DEBUG>=2) assert(Rijx >= J && Rijx <= M+1);
      RFLOAT score = Send(min(X[M+1]-X[J],y),min(M,Rijx)+1-J,min(N,ARijIK[J])+1-I, min(N,ARijIK[J]), refid,0);
      if(DEBUG>=2)assert(isfinite(score));
      int linear = -1;/* end type : -1 = normal, 0 = chr end, -2 = local, -3 = outlier */
      if(ENDFIX && Rijx > M){
	int Rij = ARijIK[J];
	for(int U = Rij; U > I; U--){
	  RFLOAT bound = Sbnd(X[M+1]-X[J],Y[U]-Yik,M+1-J,U-I,U-1,refid);
	  if(DEBUG>=2)assert(isfinite(bound));
	  if(bound > score){
	    score = bound;
	    Rij = U-1;
	    if(!ENDFIX2)
	      continue;
	  }
	  if(!ENDFIX2)
	    break;
	}
	ARijIK[J] = Rij;
      }
      if(ENDFIX && ARijIK[J] > N && N+1-I <= DELTA_YEND){/* only possible if extend==1 */
	if(DEBUG>=2) assert(extend);
	for(int U = Rijx;U > J;U--){
	  RFLOAT bound = Sbnd(X[U]-X[J],y,U-J,N+1-I,N,refid);
	  if(DEBUG>=2)assert(isfinite(bound));
	  if(bound > score){
	    score = bound;
	    Rijx = U-1;
	    if(!ENDFIX2)
	      continue;
	  }
	  if(!ENDFIX2)
	    break;
	}
	if(DEBUG>=2) assert(Rijx >= J && Rijx <= M+1);
	ARijxIK[J] = Rijx;
      }
      if(ISLINEAR && isLinear){/* try to align right ends of X and Y */
	RFLOAT Rend = Sint(X[M+1]-X[J],y,M+1-J,N+1-I,J,N+1,0, K,PRtabY,Y);// - PRtabY[K][I].Sm;
	if(Rend > score){
	  score = Rend;
	  linear = 0;
	}
      }
      if(score > bestscore2){
	bestscore2 = score;
	bestR2 = linear;
      }
    }

    /* Now backtrack to extract best alignment starting at (I,K,J)==(bestI2,bestK2,bestJ2) constrained by requiring J to be less than in the best alignment for the same I */
    /* NOTE : A.rscore, A.rG, A.rT and A.rH will be updated by repeating the recurrance computation contrained by J being less than in the best alignment */
    if(DEBUG>=2) assert(U == align->numpairs);

    int shift = REPEATREC_FIX ? ishift : bestJ - bestJ2 - (bestI - bestI2);
    RepeatScoreRoot r = {scaleID,Kmax,JMIN,JMAX,Imin,Imax,refid,mapid,N,M,phash,tid,PRtabY,YPenR,localtype,IMIN,IMAX,maxUscore,bestI,bestK,bestJ,U,Ilist,Klist,Jlist,bestI2,bestK2,bestJ2,MinShiftKb,MaxShiftKb,shift};

    RFLOAT Ascore = RepeatScore(&r,rmap,nanomap,orientation,rev,Y,X,A,XPen,align,I,K,J,U-1,0); 
    bestscore2 += Ascore;

    /* extract already computed alignment from A.rscore,A.rG,A.rT,A.rH  */
    int U2 = 0;
    if(1 /* WAS108 PVERB || DEBUG>=2 */){
      while(I > 0){
	if(DEBUG>=2){
	  assert(I-K >= 1 && I <= N);
	  assert(J >= 1 && J <= M);
	  assert(IMIN <= I && I <= IMAX);
	  assert(0 <= K && K <= Kmax[I]);
	  assert(JMIN[I] <= J && J <= JMAX[I]);
	}
	Ilist2[U2] = I;
	Klist2[U2] = K;
	Jlist2[U2] = J;
  
	int G = A->rG(I,K,J);
	int T = A->rT(I,K,J);
	int H = A->rH(I,K,J);
	if(PVERB>=3 || (DEBUG>=2 && A->shift(I,K,J) != shift)){
	  printf("U2=%d : I=%d,K=%d,J=%d: A->rscore(I,K,J)= %0.4f, G=%d,T=%d,H=%d : A->shift(I,K,J)= %d, shift= %d\n",U2,I,K,J,A->rscore(I,K,J), G,T,H,A->shift(I,K,J), shift);
	  fflush(stdout);
	  if(DEBUG>=2) assert(A->shift(I,K,J) == shift);
	}
	I = G;
	K = T;
	J = H;
	U2++;
      }
      if(DEBUG) assert(U2 > 0);
      if(DEBUG) assert(U2 <= Umax);
      if(DEBUG) assert(I <= (isLinear ? -1 : 0));
    }
	  
    /* HERE : check alternate right ends of the alignment to find the one with the best logPV2 (see next T2 loop below) : limit to 1 or 2 aligned site deletions, otherwise alignments crossing repeat boundaries and 70% in the repeat may be flagged as repeats */

    int numpairs = -1, Lend = -1;
    if(DEBUG) assert(shift != 0);

    if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);

    double logPV2 = alignFPsd(A,bestI2,bestJ2,bestK2,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,bestR2,orientation,rev,scaleID,refid,mapid, shift/* use rG,rT,rH*/, (PVERB>=2) ? 1 : 0, numpairs,Lend,-1,0,0);
    if(logPV2 >= max(align->logPV * RepeatLogPvalueRatio, minPvalue) && 
       (RepeatMaxLabelDrop < 0 || U2 >= align->numpairs - abs(bestJ - bestJ2) - RepeatMaxLabelDrop) &&
	(logPV2 / (U2-1)) >= (align->logPV / (align->numpairs-1)) * RepeatLogPvalueRatioPerLabel ){

      align->repeat = REPEATREC_FIX ? shift : bestJ - bestJ2;
      if(DEBUG) assert(align->repeat > 0);

      if(PVERB>=2){
	#pragma omp critical
	{
	  // NOTE : score2 may not be correct or consistent with the shifted alignment, but we are only relying on logPV2 to detect repeats
	  printf("Yid=%d(id=%lld),Xid=%d(id=%lld),or=%d:bestI=%d,bestK=%d,bestJ=%d,score=%0.4f,logPV=%0.2f,numpairs=%d:bestI2=%d,bestK2=%d,bestJ2=%d,score2=%0.4f,logPV2=%0.2f (repeat=%d confirmed),maptype=%d,U2=%d:\n",
		 refid,rmap->id,mapid,nanomap->id,orientation, bestI,bestK,bestJ,align->score,align->logPV,align->numpairs,bestI2,bestK2,bestJ2,bestscore2,logPV2,align->repeat,maptype,U2);
	  for(int T2 = 0; T2 < U2; T2++){
	    int I = Ilist2[U2-1-T2];
	    int K = Klist2[U2-1-T2];
	    int J = Jlist2[U2-1-T2];
	    if(DEBUG>=2 && !(A->shift(I,K,J) == shift)){
	      printf("\t U2=%d,T2=%d: I=%d,K=%d,J=%d: A->shift(I,K,J)= %d, shift= %d\n", U2,T2, I, K, J, A->shift(I,K,J), shift);
	      fflush(stdout);
	      assert(A->shift(I,K,J) == shift);
	    }
	    RFLOAT rscore = A->rscore(I,K,J);
	    int G = A->rG(I,K,J);
	    int numpairs,Lend;
	    if(T2 > 0){
	      int T = A->rT(I,K,J);
	      int H = A->rH(I,K,J);
	      FLOAT y = Yc(Y,I,K) - Yc(Y,Ilist2[U2-T2],Klist2[U2-T2]);
	      FLOAT x = X[J] - X[Jlist2[U2-T2]];
	      FLOAT sint = Sint(x,y,J-H,I-K-G,J,I,K,T,Y);
	      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	      printf("   T=%d/%d:I=%d,K=%d,J=%d (Y=%0.3f X=%0.3f),sint=%0.6f:rscore=%0.6f,logPV=%0.3f,rG=%d,rT=%d,rH=%d\n",T2,U2,I,K,J,
		     y, x, sint, rscore,  alignFPsd(A, I, J, K, Y, X, N, M, IMAX-IMIN+1, jmax-jmin+1, -2, orientation, rev, scaleID, refid, mapid,shift,0,numpairs,Lend,-1,0,0),  G,T,H);
            } else
	      printf("   T=%d/%d:I=%d,K=%d,J=%d:rscore=%0.6f,rG=%d\n",T2,U2,I,K,J, rscore, G);
	  }
	  fflush(stdout);

	  if(PVERB>=3){
	    printf("  Best alignment(and with J offset=%d, I offset=%d):\n", bestJ - bestJ2, bestI - bestI2);
	    for(int T = 0; T < U; T++){
	      int I = Ilist[U-1-T];
	      int K = Klist[U-1-T];
	      int J = Jlist[U-1-T];
	      int numpairs,Lend;
	      if(T > 0){
		if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
		printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d) (Y=%0.3f X=%0.3f):score= %0.6f,logPV=%0.3f,G=%d,T=%d,H=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],
		       Yc(Y,I,K) - Yc(Y,Ilist[U-T],Klist[U-T]), X[J] - X[Jlist[U-T]],A->score(I,K,J),
		       alignFPsd(A, I, J, K, Y, X, N, M, IMAX-IMIN+1, jmax-jmin+1, -2, orientation, rev, scaleID, refid, mapid, 0, 0, numpairs,Lend,-1,0,0), A->G(I,K,J),A->T(I,K,J),A->H(I,K,J));
	      } else
		printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d):score=%0.6f,G=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],A->score(I,K,J),A->G(I,K,J));
	      fflush(stdout);

	      int J2 = J - (bestJ - bestJ2);
	      if(DEBUG) assert(IMIN <= I && I <= IMAX);
	      if(J2 >= 1 && JMIN[I] <= J2 && J2 <= JMAX[I]){
		for(int K2 = 0; K2 <= K; K2++){
		  for(int I2 = I-K; I2 <= I; I2 += max(1,K)){
		    if(Kmax[I2] < K)
		      continue;
		    if(shift == A->shift(I2,K2,J2)){
		      RFLOAT rscore = A->rscore(I2,K2,J2);
		      int G2 = A->rG(I2,K2,J2);
		      int T2 = A->rT(I2,K2,J2);
		      int H2 = A->rH(I2,K2,J2);
		      int numpairs,Lend;
		      if(G2 > 0){
			int pshift = A->shift(G2,T2,H2);
			if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
			printf("\t    I2=%d,K2=%d,J2=%d (Y=%0.3f,X=%0.3f):shift=%d,rscore=%0.6f,logPV=%0.3f,rG=%d,rT=%d,rH=%d,pscore=%0.6f(pshift=%d)\n",
			       I2,K2,J2,Yc(Y,I2,K2) - Yc(Y,G2,T2), X[J2] - X[H2], shift,rscore,
			       alignFPsd(A, I2, J2, K2, Y, X, N, M, IMAX-IMIN+1,jmax-jmin+1,-2, orientation, rev, scaleID, refid, mapid, bestJ - bestJ2, 0, numpairs,Lend,-1,0,0), G2, T2, H2, 
			       pshift == shift ? A->rscore(G2,T2,H2) : A->score(G2,T2,H2) , pshift);
		      } else
			printf("\t    I2=%d,K2=%d,J2=%d:shift=%d,rscore=%0.6f,rG=%d\n",I2,K2,J2,shift,rscore,G2);
		    }
		  }
		}
	      }
	    }
	    fflush(stdout);
	  }
	}
      }
      break;
    } else if(PVERB>=2 && (PVERB>=3 || REPEATCHECK)){
      #pragma omp critical
      {
	printf("Yid=%d(id=%lld),Xid=%d(id=%lld),or=%d:bestI=%d,bestK=%d,bestJ=%d,score=%0.4f,logPV=%0.2f,numpairs=%d:bestI2=%d,bestK2=%d,bestJ2=%d,score2=%0.4f,logPV2=%0.2f,min=%0.2f,%0.2f (No repeat at shiftJ=%d),maptype=%d:,U2=%d\n",
	       refid,rmap->id,mapid,nanomap->id,orientation, bestI,bestK,bestJ,align->score,align->logPV,align->numpairs,bestI2,bestK2,bestJ2,bestscore2,
	       logPV2,minPvalue,align->logPV*RepeatLogPvalueRatio,bestJ - bestJ2,maptype,U2);
	int shift = bestJ - bestJ2;
	for(int T2 = 0; T2 < U2; T2++){
	  int I = Ilist2[U2-1-T2];
	  int K = Klist2[U2-1-T2];
	  int J = Jlist2[U2-1-T2];
	  int numpairs,Lend;
	  if(DEBUG>=2) assert(shift == A->shift(I,K,J));
	  RFLOAT rscore = A->rscore(I,K,J);
	  int G = A->rG(I,K,J);
	  if(T2 > 0){
	    int T = A->rT(I,K,J);
	    int H = A->rH(I,K,J);
	    FLOAT y = Yc(Y,I,K) - Yc(Y,Ilist2[U2-T2],Klist2[U2-T2]);
	    FLOAT x = X[J] - X[Jlist2[U2-T2]];
	    FLOAT sint = Sint(x,y,J-H,I-K-G,J,I,K,T,Y);
	    if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	    printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d) (Y=%0.3f X=%0.3f),sint=%0.6f:rscore= %0.6f,logPV=%0.3f,rG=%d,rT=%d,rH=%d\n",T2,U2,I,K,J,JMIN[I],JMAX[I],
		   y,x, sint, rscore, alignFPsd(A, I, J, K, Y, X, N, M, IMAX-IMIN+1, jmax-jmin+1,-2, orientation, rev, scaleID, refid, mapid, shift, 0, numpairs,Lend,-1,0,0),  G,T,H);
          } else
	    printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d):rscore=%0.6f,rG=%d\n",T2,U2,I,K,J,JMIN[I],JMAX[I], rscore,G);
	}	      
	fflush(stdout);

	if(PVERB>=3){
	  printf("  Best alignment(and with J offset=%d, I offset=%d):\n", bestJ - bestJ2,bestI-bestI2);
	  for(int T = 0; T < U; T++){
	    int I = Ilist[U-1-T];
	    int K = Klist[U-1-T];
	    int J = Jlist[U-1-T];
	    int numpairs,Lend;
	    if(T > 0){
	      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	      printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d) (Y=%0.3f X=%0.3f):score= %0.6f,logPV=%0.3f,G=%d,T=%d,H=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],
		     Yc(Y,I,K) - Yc(Y,Ilist[U-T],Klist[U-T]), X[J] - X[Jlist[U-T]],A->score(I,K,J),
		     alignFPsd(A,I,J,K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,-2,orientation,rev,scaleID,refid,mapid,0,0,numpairs,Lend,-1,0,0),A->G(I,K,J),A->T(I,K,J),A->H(I,K,J));
	    } else
	      printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d):score=%0.6f,G=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],A->score(I,K,J),A->G(I,K,J));
	    fflush(stdout);

	    int J2 = J - (bestJ - bestJ2);
	    if(DEBUG) assert(IMIN <= I && I <= IMAX);
	    if(J2 >= 1 && JMIN[I] <= J2 && J2 <= JMAX[I]){
	      for(int K2 = 0; K2 <= K; K2++){
		for(int I2 = I-K; I2 <= I; I2 += max(1,K)){
		  if(Kmax[I2] < K)
		    continue;
		  if(shift == A->shift(I2,K2,J2)){
		    RFLOAT rscore = A->rscore(I2,K2,J2);
		    int G2 = A->rG(I2,K2,J2);
		    int T2 = A->rT(I2,K2,J2);
		    int H2 = A->rH(I2,K2,J2);
		    int numpairs,Lend;
		    if(G2 > 0){
		      FLOAT y = Yc(Y,I2,K2) - Yc(Y,G2,T2);
		      FLOAT x = X[J2] - X[H2];
		      FLOAT sint = Sint(x,y,J2-H2,I2-K2-G2,J2,I2,K2,T2,Y);
		      int pshift = A->shift(G2,T2,H2);
		      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
		      double logPV = alignFPsd(A, I2, J2, K2, Y, X, N, M, IMAX-IMIN+1,jmax-jmin+1,-2, orientation, rev, scaleID, refid, mapid, shift, (PVERB>=2 ? 1 : 0), numpairs,Lend,-1,0,0);

		      printf("\t    I2=%d,K2=%d,J2=%d (Y=%0.3f,X=%0.3f),sint=%0.6f:shift=%d,rscore=%0.6f,logPV=%0.3f,rG=%d,rT=%d,rH=%d,pscore=%0.6f(pshift=%d)\n",
			     I2,K2,J2,y,x,sint, shift, rscore, logPV, G2, T2, H2, 
			     (pshift == shift) ? A->rscore(G2,T2,H2) : A->score(G2,T2,H2) , pshift);
		    } else
		      printf("\t    I2=%d,K2=%d,J2=%d:shift=%d,rscore=%0.6f,rG=%d\n",I2,K2,J2,shift,rscore,G2);
		  }
		}
	      }
	    }
	  }
	  fflush(stdout);
	}
      }
    }
  } // 	for(bestJ2 = max(1,bestJ - RepeatMaxShift); bestJ2 < bestJ; bestJ2++)

#if REPEATREC_FIX >= 1
  // NEW105 : switch to shift loop and MinShiftKb and MaxShiftKb based on median kb shift for original alignment shifted by "shift" aligned labels
  for(int ishift = 1; !align->repeat && ishift <= RepeatMaxShift; ishift++){
    if(np - ishift <= 0)
      continue;

    /* create kbShift[0.. np-ishift-1] and compute its median */
    for(int k = 0; k < np - ishift; k++){
      int J = align->sites2[k];
      int nJ = align->sites2[k + ishift];
      kbShift[k] = X[nJ] - X[J];
    }
    qsort(kbShift,np-ishift,sizeof(double), (intcmp *)DoubleInc);
    double Shift = ((np-ishift)%2) ? kbShift[(np-ishift)/2] : 0.5 * (kbShift[(np-ishift)/2] + kbShift[(np-ishift)/2 - 1]);/* Median value of kbShift[0..np-ishift-1] */

    double MinShiftKb = Shift * RepeatKbShiftRatio; /* minimum offset shift along entire alignment */
    double MaxShiftKb = Shift * RepeatKbShiftRatio2;/* maximum offset shift along entire alignment (to avoid creating new outliers) */

    /* locate rightmost pair of (re)aligned labels with offset falling within MinShiftKb .. MaxShiftKb */
    int kI = np-2, kJ = np-1;
    int bestI2 = align->sites1[kI];
    int bestK2 = align->sitesK1[kI];
    int bestJ2 = align->sites2[kJ];
    double ShiftKb = (Yc(Y,bestI,bestK) - Yc(Y,bestI2,bestK2)) - (X[bestJ] - X[bestJ2]);
    while(!(MinShiftKb <= ShiftKb && ShiftKb <= MaxShiftKb)){
      if(PVERB>=3){
	printf("ishift=%d: np=%d,kI=%d,kJ=%d,bestI=%d->%d,bestK=%d->%d,bestJ=%d->%d,ShiftKb= %0.3f (min=%0.3f, median= %0.3f, max= %0.3f)\n",
	       ishift,np,kI,kJ,bestI,bestI2,bestK,bestK2,bestJ,bestJ2,ShiftKb,MinShiftKb,Shift,MaxShiftKb);
	fflush(stdout);
      }
      if(ShiftKb < MinShiftKb){/* increase ShiftKb by decreasing kI */
	if(--kI < 0)
	  break;
	bestI2 = align->sites1[kI];
	bestK2 = align->sitesK1[kI];
      } else {/* decrease ShiftKb by decreasing kI */
	if(DEBUG) assert(ShiftKb > MaxShiftKb);
	if(--kJ < 0)
	  break;
	bestJ2 = align->sites2[kJ];
      }
      ShiftKb = (Yc(Y,bestI,bestK) - Yc(Y,bestI2,bestK2)) - (X[bestJ] - X[bestJ2]);
    }

    if(!(MinShiftKb <= ShiftKb && ShiftKb <= MaxShiftKb))
      continue;

    if(!(IMIN <= bestI2 && bestI2 <= IMAX && JMIN[bestI2] <= bestJ2 && bestJ2 <= JMAX[bestI2]))
      continue;/* cannot compute altnerate alignment : If there is a repeat it should be caught by an alignment shift in the opposite direction */

    if(PVERB>=2){
      printf("ishift=%d: np=%d,kI=%d,kJ=%d,bestI=%d->%d,bestK=%d->%d,bestJ=%d->%d,ShiftKb= %0.3f (min=%0.3f, median= %0.3f, max= %0.3f)\n",
	     ishift,np,kI,kJ,bestI,bestI2,bestK,bestK2,bestJ,bestJ2,ShiftKb,MinShiftKb,Shift,MaxShiftKb);
      fflush(stdout);
    }

#else
  if(DEBUG && !align->repeat) assert(bestJ2 == bestJ);

  for(bestI2 = max(Imin[bestJ], align->sites1[max(0,U-1-RepeatMaxShift)]); !align->repeat && bestI2 < bestI-bestK; bestI2++){
    for(bestK2 = 0; bestK2 <= Kmax[bestI2]; bestK2++){
      double MinShiftKb = (Yc(Y,bestI,bestK) - Yc(Y,bestI2,bestK2)) * RepeatKbShiftRatio; /* minimum offset shift along entire alignment */
      double MaxShiftKb = (Yc(Y,bestI,bestK) - Yc(Y,bestI2,bestK2)) * RepeatKbShiftRatio2;/* maximum offset shift along entire alignment (to avoid creating new outliers) */
#endif

      /* back track best alignment from (bestI2,bestK2,bestJ2) and compute its Pvalue and keep offset shift along entire alignment between MinShiftKb .. MaxShiftKb */	
      int I = bestI2;
      int K = bestK2;
      int J = bestJ2;

      /* First compute bestscore2, bestR2 with rightmost alignment at (I,K,J) */
      int bestR2 = -1;
      RFLOAT bestscore2 = MINSCORE;
      /* NOTE: A->score(I,K,J) will be added to bestscore2 last, unlike for bestscore at bestI,bestK,bestJ */
      if(REPEAT_TRIM){
	bestR2 = localtype;
	bestscore2 = 0.0;
      } else if(PoutlierEnd > 0.0){
	bestR2 = localtype;
	bestscore2 = biasend2_values[J];
      }

      FLOAT Yik = Yc(Y,I,K);
      FLOAT y = Y[N+1] - Yik;

      if(!(J >= M+1-DELTA_X || (extend && I >= N+1-DELTA_Y))){	  /* need to initialize Rij, since this case was not previously initialized */
	int Rijk = N+1;
	/* update Rijk by decrementing it until Y[Rijk] overlaps X */
	while(Y[Rijk] > X[M+1]-X[J]+Yik)
	  Rijk--;
	if(DEBUG>=2)	    assert(Rijk >= I-K && !(Y[Rijk] > X[M+1]-X[J]+Yik) && (Rijk > N || Y[Rijk+1] > X[M+1]-X[J]+Yik));
	A->Rij(I,K,J) = max(Rijk,I);
      }
      if(extend && !(J >= M+1-DELTA_X || I >= N+1-DELTA_Y)){	  /* need to initialize Rijx, since this case was not previously initialized */
	int Rijkx = M+1;
	/* update Rijkx by decrementing it until X[Rijkx] overlaps Y */
	while(X[Rijkx] > y+X[J])
	  Rijkx--;
	if(DEBUG>=2) assert(Rijkx >= J && !(X[Rijkx] > y+X[J]) && (Rijkx > M || X[Rijkx+1] > y+X[J]));
	A->Rijx(I,K,J) = Rijkx;
      }
      int *ARijIK = &A->Rij(I,K,0);
      int *ARijxIK = &A->Rijx(I,K,0);
      if(extend || ARijIK[J] <= N){
	int Rijx = (extend ? ARijxIK[J] : M+1);
	if(DEBUG>=2) assert(Rijx >= J && Rijx <= M+1);
	RFLOAT score = Send(min(X[M+1]-X[J],y),min(M,Rijx)+1-J,min(N,ARijIK[J])+1-I,min(N,ARijIK[J]),refid,0);
	if(DEBUG>=2)assert(isfinite(score));
	int linear = -1;/* end type : -1 = normal, 0 = chr end, -2 = local, -3 = outlier */
	if(ENDFIX && Rijx > M){
	  int Rij = ARijIK[J];
	  for(int U = Rij; U > I; U--){
	    RFLOAT bound = Sbnd(X[M+1]-X[J],Y[U]-Yik,M+1-J,U-I,U-1,refid);
	    if(DEBUG>=2)assert(isfinite(bound));
	    if(bound > score){
	      score = bound;
	      Rij = U-1;
	      if(!ENDFIX2)
		continue;
	    }
	    if(!ENDFIX2)
	      break;
	  }
	  ARijIK[J] = Rij;
	}
	if(ENDFIX && ARijIK[J] > N && N+1-I <= DELTA_YEND){/* only possible if extend==1 */
	  if(DEBUG>=2) assert(extend);
	  for(int U = Rijx; U > J;U--){
	    RFLOAT bound = Sbnd(X[U]-X[J],y,U-J,N+1-I,N,refid);
	    if(DEBUG>=2)assert(isfinite(bound));
	    if(bound > score){
	      score = bound;
	      Rijx = U-1;
	      if(!ENDFIX2)
		continue;
	    }
	    if(!ENDFIX2)
	      break;
	  }
	  if(DEBUG>=2) assert(Rijx >= J && Rijx <= M+1);
	  ARijxIK[J] = Rijx;
	}
	if(ISLINEAR && isLinear){/* try to align right ends of X and Y */
	  RFLOAT Rend = Sint(X[M+1]-X[J],y,M+1-J,N+1-I,J,N+1,0,K,PRtabY,Y); // - PRtabY[K][I].Sm;
	  if(Rend > score){
	    score = Rend;
	    linear = 0;
	  }
	}
	if(score > bestscore2){
	  bestscore2 = score;
	  bestR2 = linear;
	}
      }

      /* Now backtrack to extract best alignment starting at (I,K,J)==(bestI2,bestK2,bestJ2) constrained by requiring J to be less than in the best alignment for the same I */
      /* NOTE : A.rscore, A.rG, A.rT and A.rH will be updated by repeating the recurrance computation contrained by J being less than in the best alignment */
      if(DEBUG>=2) assert(U == align->numpairs);

      int shift = REPEATREC_FIX ? -ishift : bestJ - bestJ2 - (bestI - bestI2);
      RepeatScoreRoot r = {scaleID,Kmax,JMIN,JMAX,Imin,Imax,refid,mapid,N,M,phash,tid,PRtabY,YPenR,localtype,IMIN,IMAX,maxUscore,bestI,bestK,bestJ,U,Ilist,Klist,Jlist,bestI2,bestK2,bestJ2,MinShiftKb,MaxShiftKb,shift};

      RFLOAT Ascore = RepeatScore(&r,rmap,nanomap,orientation,rev,Y,X,A,XPen,align,I,K,J,U-1,0); 
      bestscore2 += Ascore;

      /* extract already computed alignment from A.rscore,A.rG,A.rT,A.rH */
      int U2 = 0;
      while(I > 0){
	if(DEBUG>=2){
	  assert(I-K >= 1 && I <= N);
	  assert(J >= 1 && J <= M);
	}
	Ilist2[U2] = I;
	Klist2[U2] = K;
	Jlist2[U2] = J;
	      
	int G = A->rG(I,K,J);
	int T = A->rT(I,K,J);
	int H = A->rH(I,K,J);
	I = G;
	K = T;
	J = H;
	U2++;
      }

      if(DEBUG) assert(U2 > 0);
      if(DEBUG) assert(I <= (isLinear ? -1 : 0));

      int numpairs,Lend;
      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
      double logPV2 = alignFPsd(A,bestI2,bestJ2,bestK2,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,bestR2,orientation,rev,scaleID,refid,mapid, shift/* use rG,rT,rH*/, (PVERB>=2) ? 1 : 0, numpairs,Lend,-1,0,0);

      if(logPV2 >= max(align->logPV * RepeatLogPvalueRatio, minPvalue) &&
	 (RepeatMaxLabelDrop < 0 || U2 >= align->numpairs - abs(bestI - bestI2) - RepeatMaxLabelDrop) &&
	(logPV2 / (U2-1)) >= (align->logPV / (numpairs-1)) * RepeatLogPvalueRatioPerLabel ){

	align->repeat = REPEATREC_FIX ? abs(shift) : bestI - bestI2;
	if(DEBUG) assert(align->repeat > 0);
	if(PVERB>=2){
	  #pragma omp critical
	  {
	    printf("Yid=%d(id=%lld),Xid=%d(id=%lld),or=%d:bestI=%d,bestK=%d,bestJ=%d,score=%0.4f,logPV=%0.2f,numpairs=%d:bestI2=%d,bestK2=%d,bestJ2=%d,score2=%0.4f,logPV2=%0.2f (repeat=%d confirmed),U2=%d\n",
		   refid,rmap->id,mapid,nanomap->id,orientation, bestI,bestK,bestJ,align->score,align->logPV,align->numpairs,bestI2,bestK2,bestJ2,bestscore2,logPV2,align->repeat,U2);
	    for(int T2 = 0; T2 < U2; T2++){
	      int I = Ilist2[U2-1-T2];
	      int K = Klist2[U2-1-T2];
	      int J = Jlist2[U2-1-T2];
	      RFLOAT rscore = A->rscore(I,K,J);
	      int numpairs,Lend;
	      int G = A->rG(I,K,J);
	      if(T2 > 0){
		int T = A->rT(I,K,J);
		int H = A->rH(I,K,J);
		FLOAT y = Yc(Y,I,K) - Yc(Y,Ilist2[U2-T2],Klist2[U2-T2]);
		FLOAT x = X[J] - X[Jlist2[U2-T2]];
		FLOAT sint = Sint(x,y,J-H,I-K-G,J,I,K,T,Y);
		if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
		printf("   T=%d/%d:I=%d,K=%d,J=%d (Y=%0.3f X=%0.3f),sint=%0.6f:rscore=%0.6f,logPV=%0.2f,rG=%d,rT=%d,rH=%d\n",T2,U2,I,K,J,
		       y,x,sint,rscore, alignFPsd(A, I, J, K, Y, X, N, M, IMAX-IMIN+1,jmax-jmin+1,-2, orientation, rev, scaleID,refid, mapid, shift, 0, numpairs,Lend,-1,0,0),  G,T,H);
	      } else
		printf("   T=%d/%d:I=%d,K=%d,J=%d:rscore=%0.6f,rG=%d\n",T2,U2,I,K,J,rscore,G);
	    }
	    fflush(stdout);

	    if(PVERB>=3){
	      printf("  Best alignment (A) (and with I offset=%d, J offset=%d):\n", bestI - bestI2, bestJ - bestJ2);
	      if(DEBUG) assert(shift == -(bestI - bestI2));
	      for(int T = 0; T < U; T++){
		int I = Ilist[U-1-T];
		int K = Klist[U-1-T];
		int J = Jlist[U-1-T];
		int numpairs,Lend;
		if(T > 0){
		  if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
		  printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d) (Y=%0.3f X=%0.3f):score= %0.6f,logPV=%0.3f,G=%d,T=%d,H=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],
			 Yc(Y,I,K) - Yc(Y,Ilist[U-T],Klist[U-T]), X[J] - X[Jlist[U-T]],A->score(I,K,J),
			 alignFPsd(A, I, J, K, Y, X, N, M, IMAX-IMIN+1,jmax-jmin+1,-2, orientation, rev, scaleID, refid, mapid, 0, 0, numpairs,Lend,-1,0,0), A->G(I,K,J),A->T(I,K,J),A->H(I,K,J));
		} else
		  printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d):score=%0.6f,G=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],A->score(I,K,J),A->G(I,K,J));
		int I2 = I - (bestI - bestI2);
		if(IMIN <= I2 && I2 <= IMAX && JMIN[I2] <= J && J <= JMAX[I2]){
		  for(int K2 = 0; K2 <= Kmax[I2] && I2-K2 >= 1; K2++){
		    int J2 = J;

		    if(shift == A->shift(I2,K2,J2)){
		      RFLOAT rscore = A->rscore(I2,K2,J2);
		      int G2 = A->rG(I2,K2,J2);
		      int T2 = A->rT(I2,K2,J2);
		      int H2 = A->rH(I2,K2,J2);
		      int numpairs,Lend;
		      if(G2 > 0){
			FLOAT y = Yc(Y,I2,K2) - Yc(Y,G2,T2);
			FLOAT x = X[J2] - X[H2];
			FLOAT sint = Sint(x,y,J2-H2,I2-K2-G2,J2,I2,K2,T2,Y);
			int pshift = A->shift(G2,T2,H2);
			if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
			printf("\t    I2=%d,K2=%d,J2=%d (Y=%0.3f,X=%0.3f),sint=%0.6f:shift=%d,rscore=%0.6f,logPV=%0.3f,rG=%d,rT=%d,rH=%d,pscore=%0.6f(pshift=%d)\n",
			       I2,K2,J2,y,x,sint, shift, rscore, alignFPsd(A, I2, J2, K2, Y, X, N, M, IMAX-IMIN+1,jmax-jmin+1,-2, orientation, rev, scaleID, refid, mapid, shift, 0, numpairs,Lend,-1,0,0), G2,T2,H2, 
			       (pshift == -(bestI-bestI2)) ? A->rscore(G2,T2,H2) : A->score(G2,T2,H2),pshift);
		      } else
			printf("\t    I2=%d,K2=%d,J2=%d:shift=%d,rscore=%0.6f,G=%d\n",I2,K2,J2,shift,rscore,G2);
		    }
		  }
		}
	      }
	    }
	  }
	  fflush(stdout);
	}
	break;
      } else if(PVERB>=2 && (PVERB>=3 || REPEATCHECK)){
	#pragma omp critical
	{
	  printf("Yid=%d(id=%lld),Xid=%d(id=%lld),or=%d:bestI=%d,bestK=%d,bestJ=%d,score=%0.4f,logPV=%0.2f,numpairs=%d:bestI2=%d,bestK2=%d,bestJ2=%d,bestR2=%d,score2=%0.4f,logPV2=%0.2f,min=%0.2f,%0.2f (No repeat at shiftI = %d),U2=%d:\n",
		 refid,rmap->id,mapid,nanomap->id,orientation, bestI,bestK,bestJ,align->score,align->logPV,align->numpairs,bestI2,bestK2,bestJ2,bestR2,bestscore2,
		 logPV2, minPvalue,align->logPV*RepeatLogPvalueRatio, bestI - bestI2,U2);
	  int shift = -(bestI-bestI2);
	  for(int T2 = 0; T2 < U2; T2++){
	    int I = Ilist2[U2-1-T2];
	    int K = Klist2[U2-1-T2];
	    int J = Jlist2[U2-1-T2];
	    int numpairs,Lend;
	    if(DEBUG>=2) assert(A->shift(I,K,J) == shift);
	    int G = A->rG(I,K,J);
	    if(T2 > 0){
	      int T = A->rT(I,K,J);
	      int H = A->rH(I,K,J);
	      FLOAT y = Yc(Y,I,K) - Yc(Y,Ilist2[U2-T2],Klist2[U2-T2]);
	      FLOAT x = X[J] - X[Jlist2[U2-T2]];
	      FLOAT sint = Sint(x,y,J-H,I-K-G,J,I,K,T,Y);

	      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	      printf("   T=%d/%d:I=%d,K=%d,J=%d (Y=%0.3f X=%0.3f),sint=%0.6f:rscore=%0.6f,logPV=%0.3f,rG=%d,rT=%d,rH=%d\n",T2,U2,Ilist2[U2-1-T2],Klist2[U2-1-T2],Jlist2[U2-1-T2],
		     y, x, sint, A->rscore(I,K,J), alignFPsd(A, I, J, K, Y, X, N, M, IMAX-IMIN+1,jmax-jmin+1,-2, orientation, rev, scaleID, refid, mapid, shift, 0, numpairs,Lend,-1,0,0), G, T, H);
            } else
	      printf("   T=%d/%d:I=%d,K=%d,J=%d:rscore=%0.6f,rG=%d\n",T2,U2,Ilist2[U2-1-T2],Klist2[U2-1-T2],Jlist2[U2-1-T2],A->rscore(I,K,J),G);
          }
	  fflush(stdout);
	      
	  if(PVERB>=3){
	    printf("  Best alignment (B) (and with I offset=%d, J offset=%d):\n", bestI - bestI2, bestJ - bestJ2);
	    for(int T = 0; T < U; T++){
	      int I = Ilist[U-1-T];
	      int K = Klist[U-1-T];
	      int J = Jlist[U-1-T];
	      int numpairs,Lend;
	      if(T > 0){
		if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
		printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d) (Y=%0.3f X=%0.3f):score= %0.6f,logPV=%0.3f,G=%d,T=%d,H=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],
		       Yc(Y,I,K) - Yc(Y,Ilist[U-T],Klist[U-T]), X[J] - X[Jlist[U-T]],A->score(I,K,J),
		       alignFPsd(A, I, J, K, Y, X, N, M, IMAX-IMIN+1,jmax-jmin+1,-2, orientation, rev, scaleID, refid, mapid, 0, 0, numpairs,Lend,-1,0,0), A->G(I,K,J),A->T(I,K,J),A->H(I,K,J));
	      } else
		printf("   T=%d/%d:I=%d,K=%d,J=%d(%d..%d):score=%0.6f,G=%d\n",T,U,I,K,J,JMIN[I],JMAX[I],A->score(I,K,J),A->G(I,K,J));
	      int I2 = I - (bestI - bestI2);
	      if(IMIN <= I2 && I2 <= IMAX && JMIN[I2] <= J && J <= JMAX[I2]){
		for(int K2 = 0; K2 <= Kmax[I2] && I2-K2 >= 1; K2++){
		  int J2 = J;

		  if(shift == A->shift(I2,K2,J2)){
		    RFLOAT rscore = A->rscore(I2,K2,J2);
		    int G2 = A->rG(I2,K2,J2);
		    int T2 = A->rT(I2,K2,J2);
		    int H2 = A->rH(I2,K2,J2);
		    int numpairs,Lend;
		    if(G2 > 0){
		      FLOAT y = Yc(Y,I2,K2) - Yc(Y,G2,T2);
		      FLOAT x = X[J2] - X[H2];
		      FLOAT sint = Sint(x,y,J2-H2,I2-K2-G2,J2,I2,K2,T2,Y);
		      int pshift = A->shift(G2,T2,H2);
		      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
		      printf("\t    I2=%d,K2=%d,J2=%d (Y=%0.3f,X=%0.3f),sint=%0.6f:shift=%d,rscore=%0.6f,logPV=%0.3f,rG=%d,rT=%d,rH=%d,pscore=%0.6f(pshift=%d)\n",
			     I2,K2,J2,y,x,sint, shift, rscore, 
			     alignFPsd(A, I2, J2, K2, Y, X, N, M, IMAX-IMIN+1,jmax-jmin+1,-2, orientation, rev, scaleID, refid, mapid, shift, 0, numpairs,Lend,-1,0,0), G2,T2,H2, 
			     (pshift == shift) ? A->rscore(G2,T2,H2) : A->score(G2,T2,H2), pshift);
		    } else
		      printf("\t    I2=%d,K2=%d,J2=%d:shift=%d,rscore=%0.6f,G=%d\n",I2,K2,J2,shift,rscore,G2);
		  }
		}
	      }
	    }
	    fflush(stdout);
	  }
	}
      }
#if REPEATREC_FIX >= 1
  } // for ishift = 1 .. RepeatMaxShift
#else
    }// for bestK2 = ...
  }// for bestI2 = ...
#endif

  if(Umax > MAX_ALLOCA)
    delete [] Ilist2;
#if REPEATREC_FIX >= 1
  if(np > MAX_ALLOCA)
    delete [] kbShift;
#endif

  /* NEW147 : Need to reset A->shift[] to 0 everywhere to since the same shift value can mean different relative shifts depending on the starting point (right most aligned label) */
  for(int I = IMIN; I <= IMAX; I++){
    if(DEBUG>=2) assert(Kmax[I] >= 0 && Kmax[I] <= I-1 && Kmax[I] <= KMAX);
    for(int K = 0; K <= Kmax[I]; K++){
      int jmin = JMIN[I], jmax = JMAX[I];
      if(DEBUG>=2) assert(JMIN[I] <= JMAX[I]);

      memset_int(&A->shift(I,K,jmin), 0, jmax-jmin+1);
    }
  }
}

long long *FmemSiz = NULL;// FmemSiz[tid] is the allocated (virtual) memory size for Fmem/Imem for thread tid  : only defined if MIN_MEM_DEBUG OR RA_MIN_TIME
long long *FmemHWM = NULL;// FmemHWM[tid] is the largest (virtual) memory size used for Fmem/Imem for thread tid since it was allocated : only defined if RA_MIN_TIME
double *FmemTime = NULL;// FmemTime[tid] is the wtime() value when Fmem/Imem was last allocated or had madvise(Fmem,FmemHWM[tid],MADV_DONTNEED) called : only defined if RA_MIN_TIME

double *FmemMadv = NULL;// FmemMadv[tid] is the sum of FmemHWM[tid] for each time madvise(Fmem,FmemHWM[tid],MADV_DONTNEED) is called in thread tid
double *FmemSleep = NULL;// FmemSleep[tid] is the sum of sleep times due to memory shortage for thread tid
double *FmemBT = NULL;// FmemBT[tid] is the sum of time wasted backtracking to LwaitForMemory for thread tid

long long *FmemRsiz = NULL;// FmemSiz[tid] is the estimated amount of real memory that will be used : only define if MIN_MEM_DEBUG

static long long vmemTotsiz = 0, memTotsiz = 0;
static int PausedThreads = 0, NumThreads = 0;// current number of threads paused waiting for memory
static long long MaxMemSiz = 0;// maximum real memory target (see -maxmem)
static long long MaxMemSiz2;// MaxMemSiz * 0.9 : Max Value of VmRSS + VmSwap + nMemSiz

struct timespec tm;

#include <sys/mman.h>

/* Break up matchgroups using the RefSplit heuristic, when number of labels of -ve scoring region (in ref OR query) exceed RefSplitMinLabels
   
   Also merge -ve scoring regions into a single outlier by adjusting the G,T,H backpointers.
   
   May reallocate matchgroup[0..maxmatchgroup-1] and increase nummatchgroup
 */

static void MatchgroupRefSplit(Cmatchgroup * &matchgroup,
			       Cmatchgroup ** &mheap,
			       int &nummatchgroup,
			       int &maxmatchgroup,
			       AL *A,
			       int *Ilist, int *Klist, int *Jlist,// int *outlier,
			       double *iscore, double *outscore, double *cumiscore,
			       FLOAT *Y, int N,
			       FLOAT *X, int M,
			       int orientation, int rev, int scaleID,
			       Cmap *rmap, Cmap *nanomap,
			       int refid, int mapid
			       )
{
  double threshold = log(1.0/Psplit);/* A Negative scoring region with score <= -threshold causes a split : If -outlierBC, this threshold is increased by |OutlierPenaltyBC[m]+OutlierPenaltyBC[n]| */
  double pthreshold = log(1.0/(Rsplit ? Rsplit : Psplit)); /* Negative score regions are merged if they are seperated by an aligned subregion with score < pthreshold */

  int orignummatchgroup = nummatchgroup;

  for(int i = nummatchgroup; --i >= 0; ){
    Cmatchgroup *p = &matchgroup[i];

    int I = p->I;
    int K = p->K;
    int J = p->J;
    int IL = p->IL; 
    //    int KL = p->KL; 
    //    int JL = p->JL; 

    int Lend = I;
    int U = alignExtract(A,Lend,K,J,p->R, A->Tscore(I,K,J), Y,X,N,M,Ilist,Klist,Jlist,iscore,outscore,rmap,nanomap,refid,mapid,orientation,rev,scaleID,0,IL);

    if(PVERB>=3 /* HERE HERE && I_TRACE >= 0 && I == I_TRACE && K == K_TRACE && J == J_TRACE*/){
      double scoresum = 0.0;
      for(int T = 0; T <= U; T++)
	scoresum += iscore[T];

      printf("refid=%d(id=%lld,mapid=%d(id=%lld),or=%d,rev=%d,U=%d: matchgroup[%d]:I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,R=%d,score= %0.6f, iscore[0..U]= %0.6f\n",
	      refid,rmap->id,mapid,nanomap->id,orientation,rev,U,i,I,K,J,p->IL,p->KL,p->JL,p->R,p->score,scoresum);
      fflush(stdout);
    }

    /* NOTE : compared to RefSplit code in refalignXYsd :
       pscore[t = 0..U] = p->outscore[t] == outscore[U-t]
       p->iscore[t = 0..U] == iscore[U-t]
       p->sites1[t = 0 .. U-1] == Ilist[U-1-t]
       p->sitesK1[t] == Klist[U-1-t]
       p->sites2[t] == Jlist[U-1-t]
    */
       
#define pscore(t) outscore[U - (t)]
#define iscore(t) iscore[U - (t)]    
#define sites1(t) Ilist[U-1 - (t)]
#define sitesK1(t) Klist[U-1 - (t)]
#define sites2(t) Jlist[U-1 - (t)]

    double score = 0.0;/* cumulative outscore = sum(pscore[0..T-1]) */
    double iscoresum = 0.0;/* cumulative iscore = sum(p->iscore[0..T-1]) */
    //    double cumiscore[U+1];/* cumiscore[i = 0..T] = sum(p->iscore[0..i]) */

    int iLWM = -1;/* end of most recent potential alignment index break (-1 = left end, U = right end) :
		         iLWM is the value in range lastiHWM .. T-1 with lowest value for pscore[lastiHWM+1..iLWM] AND no subinterval with score >= pthreshold
			 The internal region lastiHWM+1..iLWM becomes fixed once HWM > LWM + pthreshold OR (T==U && iWHM > iLWM) :
			   The region lastiHWM+1..iLWM is merged into a single outlier IFF pscore[lastiHWM+1..iLWM] < -threshold - |OutlierPenaltyBC[m]+OutlierPenaltyBC[n]| 
			   The region lastiHWM+1..iLWM becomes an actual break IFF pscore[lastiHWM+1..iLWM] < -threshold - |OutlierPenaltyBC[m]+OutlierPenaltyBC[n]| AND max(m,n) >= RefSplitMinLabels.
			 NOTE : Split alignments are not saved unless they include at least A2 aligned labels */
    double LWM = 0.0;/* sum(pscore[0..iLWM]) */
    int iHWM = -1;/* highest value for sum(pscore[iLWM+1..iHWM]) for iLWM <= iHWM < T <= U AND no subinterval from iLWM+1 to T-1 with score < -threshold - |OutlierPenaltyBC[m]+OutlierPenaltyBC[n]| */
    double HWM = 0.0;/* sum(pscore[0..iHWM]) */
    int lastbreak = -1;/* end of most recent actual alignment index break interval (-1 = left end, U = right end) */
    int lastiHWM = -1;/* start of next potential break (corresponds to a previous iHWM value : lastbreak <= lastiHWM <= iLWM <= iHWM */
    double lastHWM = 0.0;/* sum(pscore[0..lastiHWM] : a previous HWM value that has not yet been exceed by HWM */

    if(PVERB>=3 /* && I_TRACE >= 0 && I == I_TRACE && K == K_TRACE && J == J_TRACE*/){
#pragma omp critical
      {
        printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:checking matchgroup[%d] for RefSplits: numpairs=%d,score=%0.6f, threshold=%0.6f,pthreshold=%0.6f:\n",
	  refid,rmap->id,mapid,nanomap->id,orientation,rev,i,U, p->score,threshold,pthreshold);
        fflush(stdout);
      }
    }

    for(int T = 0; T <= U; T++){
      /* PRE: -1 <= lastbreak <= lastiHWM <= iLWM <= iHWM <= T-1 :
	 lastHWM = sum(pscore[0..lastiHWM]
	 LWM = sum(pscore[0..iLWM])
	 HWM = sum(pscore[0..iHWM])
	 score = sum(pscore[0..T-1])
	 iscoresum = sum(iscore[0..T-1])
	 cumiscore[i = 0..T-1] = sum(iscore[0..i])
	 HWM <= LWM+pthreshold
	 HWM <= lastHWM
	 If iLWM > lastiHWM : pscore[lastiHWM+1] < 0.0 && pscore[iLWM] < 0.0
      */      
      if(DEBUG>=2){
	assert(-1 <= lastbreak);
	assert(lastbreak <= lastiHWM);
	assert(lastiHWM <= iLWM);
	assert(iLWM <= iHWM);
	assert(iHWM <= T - 1);
	assert(HWM <= LWM + pthreshold);/* otherwise lastiHWM .. iLWM would have been fixed (and resulted in an actual break subject to BC && RefSplitMinLabels) */
	assert(HWM <= lastHWM);/* otherwise matchgroup lastbreak .. lastiHWM would have been extended to iHWM */
	if(iLWM > lastiHWM){
	  assert(pscore(lastiHWM+1) <= (RELEASE ? 0.000001 : 0.0));
	  assert(pscore(iLWM) < 0.0);
	}
      }
      
      double inc = pscore(T);
      cumiscore[T] = iscoresum += iscore(T);

      if(PVERB>=3 /* HERE HERE && I_TRACE >= 0 && I == I_TRACE && K == K_TRACE && J == J_TRACE*/){
#pragma omp critical
	{
	  if(T < U)
	    printf("T=%d/%d:lastbreak=%d,lastiHWM=%d,iLWM=%d,iHWM=%d,lastHWM=%0.6f,LWM=%0.6f,HWM=%0.6f,outscore[0..T-1]=%0.6f:outscore[T]=%0.6f (iscore[T]=%0.6f,cum=%0.6f),I=%d,K=%d,J=%d\n",
	      T,U,lastbreak,lastiHWM,iLWM,iHWM,lastHWM,LWM,HWM,score,inc,iscore(T),iscoresum,sites1(T),sitesK1(T),sites2(T));
	  else
	    printf("T=%d/%d:lastbreak=%d,lastiHWM=%d,iLWM=%d,iHWM=%d,lastHWM=%0.6f,LWM=%0.6f,HWM=%0.6f,outscore[0..T-1]=%0.6f:outscore[T]=%0.6f (iscore[T]=%0.6f,cum=%0.6f)\n",
	      T,U,lastbreak,lastiHWM,iLWM,iHWM,lastHWM,LWM,HWM,score,inc,iscore(T),iscoresum);
	  fflush(stdout);
        }
      }
      
      if(score + inc > LWM + pthreshold || (T==U && iHWM > iLWM)){
	if(DEBUG/* HERE >=2 */ && T < U) assert(score+inc > HWM);/* this guarantees that potential alignment break interval lastiHWM+1..iLWM will be reset below to lastiHWM = iLWM = iHWM = T */
	
	if(lastiHWM < 0 && iLWM > 0){/* NEW3 : check if left end should be trimmed */
	  int I = sites1(iLWM);
	  int K = sitesK1(iLWM);
	  if(cumiscore[iLWM] /* WAS LWM */ < ChimScore + PRtab[refid][K][I].Sm){
	    if(PVERB>=3 /* HERE HERE && I_TRACE >= 0 && I == I_TRACE && K == K_TRACE && J == J_TRACE*/){
#pragma omp critical
	      {
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: trimming off left end of alignment up to iLWM=%d (I=%d,K=%d,J=%d)\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,rev,U,iLWM,I,K,sites2(iLWM));
		fflush(stdout);
	      }
	    }
	    lastbreak = iLWM;
	    lastiHWM = iLWM = iHWM;
	    lastHWM = LWM = HWM;
	  }
	} else if(lastiHWM >= 0 && iLWM > lastiHWM){ /* The potential break interval is now fixed at lastiHWM+1 .. iLWM : check if it is an actual break. Then resume search for next break */

	  /* check if lastHWM - LWM > threshold + |OutlierPenaltyBC[m] + OutlierPenaltyBC[n]| AND max(m,n) >= RefSplitMinLabels : If so, schedule break in alignment from lastiHWM+1 .. iLWM */
	  int IL = sites1(lastiHWM), IR = sites1(iLWM);
	  int KL = sitesK1(lastiHWM), KR = sitesK1(iLWM);
	  int JL = sites2(lastiHWM), JR = sites2(iLWM);
	  int n = IR-KR-IL;
	  int m = JR-JL;
	  if(DEBUG/* HERE >=2 */) assert(n < max(maxN,maxM));
	  if(DEBUG/* HERE >=2 */) assert(m < max(maxN,maxM));
	  if(DEBUG/* HERE >=2 */) assert(pscore(lastiHWM+1) < 0.0);
	  if(DEBUG/* HERE >=2 */) assert(pscore(iLWM) < 0.0);

	  if(lastHWM - LWM > threshold - OutlierPenaltyBC[n] - OutlierPenaltyBC[m]){/* potential alignment index break satisfies -ve score threshold */
	    if(max(m,n) >= RefSplitMinLabels*2){/* actual alignment index break (NOTE : Factor of 2x needed to avoid missing smaller CutFlipPaste matchgroups not found by hashtable) */
	      if(lastiHWM + 1 - max(0,lastbreak) >= min(2,AlignedSiteThreshold2)){
		/* copy matchgroup from lastbreak to lastiHWM into a separate alignment */

		if(nummatchgroup + 1 > maxmatchgroup){/* reallocate matchgroup[] */
		  int nmax = max(1024, (nummatchgroup + 1)*(MULTIMATCHES_MINMEM+1)/MULTIMATCHES_MINMEM);
		  Cmatchgroup *nmatchgroup;
		  if(MATCHGROUP_HEAP){
		    nmatchgroup = new Cmatchgroup[2*nmax];
		    delete [] mheap;
		    mheap = new Cmatchgroup*[nmax+1];
		  } else
		    nmatchgroup = new Cmatchgroup[nmax];
		  if(nummatchgroup > 0)
		    memcpy(nmatchgroup, matchgroup, nummatchgroup * sizeof(Cmatchgroup));
		  if(maxmatchgroup > 0)
		    delete [] matchgroup;
		  matchgroup = nmatchgroup;
		  maxmatchgroup = nmax;
		  p = &matchgroup[i];
		}
		Cmatchgroup *r = &matchgroup[nummatchgroup++];

		int S = max(0,lastbreak);
		r->I = IL;
		r->K = KL;
		r->J = JL;
		r->R = A->R(r->I,r->K,r->J);
		r->IL = sites1(S);
		r->KL = sitesK1(S);
		r->JL = sites2(S);
		r->score = A->Tscore(r->I,r->K,r->J) + A->Uscore(r->IL,r->KL,r->JL) - A->score(r->IL,r->KL,r->JL);
		  
		if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && r->I == I_TRACE && r->K == K_TRACE && r->J == J_TRACE*/){
#pragma omp critical
		  {
		    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: splitting alignment from lastbreak=%d to lastiHWM=%d into matchgroup[%d]:I=%d..%d,J=%d..%d,score=%0.6f\n",
			   refid,rmap->id,mapid,nanomap->id,orientation,rev,U,lastbreak,lastiHWM,nummatchgroup-1,r->IL,r->I,r->JL,r->J,r->score);
		    fflush(stdout);
		  }
		}
	      } else {
		if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE*/){
#pragma omp critical
		  {
		    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: split alignment from lastbreak=%d to lastiHWM=%d is too short due to -A2 %d (discarding)\n",
			   refid,rmap->id,mapid,nanomap->id,orientation,rev,U,lastbreak,lastiHWM,AlignedSiteThreshold2);
		    fflush(stdout);
		  }
		}
	      }
		
	      lastbreak = iLWM;
	      lastiHWM = iLWM = iHWM;
	      lastHWM = LWM = HWM;
	    } /* actual alignment index break */
	    else if(MERGE_OUTLIERS && iLWM > lastiHWM + 1){/* merge potential alignment index break lastiHWM to iLWM into a single outlier */
	      int I = sites1(iLWM);
	      int K = sitesK1(iLWM);
	      int J = sites2(iLWM);
	      int IL = A->G(I,K,J) = sites1(lastiHWM);
	      int KL = A->T(I,K,J) = sitesK1(lastiHWM);
	      int JL = A->H(I,K,J) = sites2(lastiHWM);
		
	      if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE*/){
#pragma omp critical
		{
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: Merging interval lastiHWM=%d to iLWM=%d (ref=%0.3f..%0.3f) into single outlier interval(I=%d,K=%d,J=%d,G=%d,D=%d,H=%d,x=%0.3f,y=%0.3f)\n",
			 refid,rmap->id,mapid,nanomap->id,orientation,rev,U,lastiHWM,iLWM, Yc(Y,IL,KL),Yc(Y,I,K), I,K,J,IL,KL,JL,X[J]-X[JL],Yc(Y,I,K)-Yc(Y,IL,KL));
		  fflush(stdout);
		}
	      }
	    } /* merged potential alignment index break lastiWHM+1 .. iLWM into a single outlier */
	  } /* potential alignment index break satisfies -ve score threshold */
	} /* else if(lastiHWM >= 0 && iLWM > lastiHWM) */
      } /* if(score + inc > LWM + pthreshold) */

      score += inc;
      if(score < LWM){/* extend the previous (potential) alignment break interval (lastHWM+1 to iLWM) to T */
	iLWM = iHWM = T;
	LWM = HWM = score;
      } else if(score >= HWM){
	iHWM = T;
	HWM = score;
	if(HWM >= lastHWM             /* keep extending lastbreak ... lastiHWM matchgroup to T */
	   || HWM - LWM > pthreshold){/* stop extending potential alignment break interval (lastiHWM to iLWM) and initialize new potential alignment break interval at T */
	  lastiHWM = iLWM = iHWM;
	  lastHWM = LWM = HWM;
	}
      }
	    
      /* POST : -1 <= lastbreak <= lastiHWM <= iLWM <= iHWM <= T :
	 lastHWM = sum(pscore[0..lastiHWM])
	 LWM = sum(pscore[0..iLWM])
	 HWM = sum(pscore[0..iHWM])
	 score = sum(pscore[0..T])
	 iscoresum = sum(iscore[0..T])
	 cumiscore[i = 0..T] = sum(iscore[0..i])
	 HWM <= LWM+pthreshold
	 HWM <= lastHWM
	 If iLWM > lastiHWM : pscore[lastiHWM+1] <= 0.0 && pscore[iLWM] < 0.0
      */
      if(DEBUG>=2){
	assert(-1 <= lastbreak);
	assert(lastbreak <= lastiHWM);
	assert(lastiHWM <= iLWM);
	assert(iLWM <= iHWM);
	assert(iHWM <= T);
	assert(HWM <= LWM + pthreshold);
	assert(HWM <= lastHWM);
	if(iLWM > lastiHWM){
	  if(!(pscore(lastiHWM+1) <= 0.0)){
#pragma omp critical
	    {
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:checking matchgroup[%d] for RefSplits:U=%d,score=%0.6f,threshold=%0.6f,pthreshold=%0.6f:\n",
	        refid,rmap->id,mapid,nanomap->id,orientation,rev,i,U,p->score,threshold,pthreshold);
	      printf("After T=%d/%d:lastbreak=%d,lastiHWM=%d,iLWM=%d,iHWM=%d:lastHWM= %0.6f, LWM= %0.6f, HWM= %0.6f, score= %0.6f, pscore[lastiHWM+1]= %0.6f, pscore[T]= %0.6f, inc= %0.7f\n",
	        T,U,lastbreak,lastiHWM,iLWM,iHWM,lastHWM,LWM,HWM,score,pscore(lastiHWM+1),pscore(T),inc);
	      fflush(stdout);
	      assert(pscore(lastiHWM+1) <= (RELEASE ? 0.00001 : 0.0));
	    }
	  }
        } // iLWM > lastiHWM
      } // DEBUG>=2
    } // for(T = 0; T < U; T++)
	    
    int trimmed = 0;

    if(lastbreak > 0){/* trim current alignment down to lastbreak .. U */
      double origscore = p->score;
      p->IL = sites1(lastbreak);
      p->KL = sitesK1(lastbreak);
      p->JL = sites2(lastbreak);
      if(cumiscore[U] - cumiscore[lastiHWM] /* WAS score - lastHWM */ < ChimScore && lastiHWM < U-1){/* trim right end of alignment beyond lastiHWM */

	// check if region right of iLWM satisfies AlignedSiteThreshold2 and has +ve score
	int rightend = 0;
	if(U - iLWM >= min(2,AlignedSiteThreshold2)){// NEW37
	  int I = sites1(iLWM);
	  int K = sitesK1(iLWM);
	  int J = sites2(iLWM);
	  double nscore = A->Tscore(p->I,p->K,p->J) + A->Uscore(I,K,J) - A->score(I,K,J);
	  if(nscore > 0.0){/* copy matchgroup from iLWM to right end into a seperate alignment */
	    rightend = 1;
	    if(nummatchgroup + 1 > maxmatchgroup){/* reallocate matchgroup[] */
	      int nmax = max(1024, (nummatchgroup + 1)*(MULTIMATCHES_MINMEM+1)/MULTIMATCHES_MINMEM);
	      Cmatchgroup *nmatchgroup;
	      if(MATCHGROUP_HEAP){
		nmatchgroup = new Cmatchgroup[2*nmax];
		delete [] mheap;
		mheap = new Cmatchgroup*[nmax+1];
	      } else
		nmatchgroup = new Cmatchgroup[nmax];
	      if(nummatchgroup > 0)
		memcpy(nmatchgroup, matchgroup, nummatchgroup * sizeof(Cmatchgroup));
	      if(maxmatchgroup > 0)
		delete [] matchgroup;
	      matchgroup = nmatchgroup;
	      maxmatchgroup = nmax;
	      p = &matchgroup[i];
	    }
	    Cmatchgroup *r = &matchgroup[nummatchgroup++];

	    r->I = p->I;
	    r->K = p->K;
	    r->J = p->J;
	    r->R = p->R;
	    r->IL = I;
	    r->KL = K;
	    r->JL = J;
	    r->score = nscore;
	    if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE*/){
#pragma omp critical
	      {
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: splitting alignment from iLWM=%d to right end into matchgroup[%d]:I=%d..%d,J=%d..%d,score=%0.6f,ChimScore=%0.6f (A)\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,rev,U,iLWM,nummatchgroup-1,r->IL,r->I,r->JL,r->J,r->score,ChimScore);
		fflush(stdout);
	      }
	    }
	  }
	} // if(U-iLWM >= min(2,AlignedSiteThreshold2))

	if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE */ && !rightend){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: trimmed right end from iLWM=%d is too short to form a seperate matchgroup\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,U,iLWM);
	  fflush(stdout);
	}

	if(lastiHWM - lastbreak + 1 < min(2,AlignedSiteThreshold2) /* NEW37 */)
	  trimmed = 2;
	else {
	  trimmed = 1;
	  p->I = sites1(lastiHWM);
	  p->K = sitesK1(lastiHWM);
	  p->J = sites2(lastiHWM);
	  p->R = A->R(p->I,p->K,p->J);
	}
      }  //  if(cumiscore[U] - cumiscore[lastiHWM] < ChimScore && lastiHWM < U-1)

      if(trimmed < 2)
	p->score = A->Tscore(p->I,p->K,p->J) + A->Uscore(p->IL,p->KL,p->JL) - A->score(p->IL,p->KL,p->JL);

      if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE */){
	if(!trimmed)
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: truncating matchgroup[%d] from lastbreak=%d to right end:score=%0.6f->%0.6f\n",
	      refid,rmap->id,mapid,nanomap->id,orientation,rev,U,i,lastbreak,origscore,p->score);
	else if(trimmed == 1)
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: truncating matchgroup[%d] from lastbreak=%d to lastiHWM=%d:score=%0.6f->%0.6f\n",
	      refid,rmap->id,mapid,nanomap->id,orientation,rev,U,i,lastbreak,lastiHWM,origscore,p->score);
	else
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: discarding matchgroup[%d] :  lastbreak=%d, lastiHWM=%d, A2=%d\n",
	      refid,rmap->id,mapid,nanomap->id,orientation,rev,U,i,lastbreak,lastiHWM,AlignedSiteThreshold2);
	fflush(stdout);
      }
    } else if(lastiHWM > 0/* NEW47 */ && cumiscore[U] - cumiscore[lastiHWM] < ChimScore && lastiHWM < U-1){/* trim right end of alignment beyond lastiHWM */
      // check if region right of iLWM satisfies AlignedSiteThreshold and has +ve score
      int rightend = 0;
      if(U - iLWM >= min(2,AlignedSiteThreshold2)){// NEW37
	int I = sites1(iLWM);
	int K = sitesK1(iLWM);
	int J = sites2(iLWM);
	double nscore = A->Tscore(p->I,p->K,p->J) + A->Uscore(I,K,J) - A->score(I,K,J);
	if(nscore > 0.0){/* copy matchgroup from iLWM to right end into a seperate alignment */
	  rightend = 1;
	  if(nummatchgroup + 1 > maxmatchgroup){/* reallocate matchgroup[] */
	    int nmax = max(1024, (nummatchgroup + 1)*(MULTIMATCHES_MINMEM+1)/MULTIMATCHES_MINMEM);
	    Cmatchgroup *nmatchgroup;
	    if(MATCHGROUP_HEAP){
	      nmatchgroup = new Cmatchgroup[2*nmax];
	      delete [] mheap;
	      mheap = new Cmatchgroup*[nmax+1];
	    } else
	      nmatchgroup = new Cmatchgroup[nmax];
	    if(nummatchgroup > 0)
	      memcpy(nmatchgroup, matchgroup, nummatchgroup * sizeof(Cmatchgroup));
	    if(maxmatchgroup > 0)
	      delete [] matchgroup;
	    matchgroup = nmatchgroup;
	    maxmatchgroup = nmax;
	    p = &matchgroup[i];
	  }
	  Cmatchgroup *r = &matchgroup[nummatchgroup++];

	  r->I = p->I;
	  r->K = p->K;
	  r->J = p->J;
	  r->R = p->R;
	  r->IL = I;
	  r->KL = K;
	  r->JL = J;
	  r->score = nscore;
	  if(PVERB>=3 /* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE*/){
#pragma omp critical
	    {
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: splitting alignment from iLWM=%d to right end into matchgroup[%d]:I=%d..%d,J=%d..%d,score=%0.6f,ChimScore=%0.6f (B)\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,rev,U,iLWM,nummatchgroup-1,r->IL,r->I,r->JL,r->J,r->score,ChimScore);
	      fflush(stdout);
	    }
	  }
	}
      }  // if(U-iLWM >= min(2,AlignedSiteThreshold2))
      if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE */ && !rightend){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: trimmed right end from iLWM=%d is too short to form a seperate matchgroup\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,U,iLWM);
	fflush(stdout);
      }

      if(lastiHWM + 1 < min(2,AlignedSiteThreshold2)/* NEW37 */){
	trimmed = 2;

	if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE*/){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: discarding matchgroup[%d] :  lastbreak=%d, lastiHWM=%d, A2=%d\n",
	      refid,rmap->id,mapid,nanomap->id,orientation,rev,U,i,lastbreak,lastiHWM,AlignedSiteThreshold2);
	  fflush(stdout);
	}
      } else {
	double origscore = p->score;
	int I = p->I, K = p->K, J = p->J;

	p->I = sites1(lastiHWM);
	p->K = sitesK1(lastiHWM);
	p->J = sites2(lastiHWM);
	p->R = A->R(p->I,p->K,p->J);
	p->score = A->Tscore(p->I,p->K,p->J) + A->Uscore(p->IL,p->KL,p->JL) - A->score(p->IL,p->KL,p->JL);

	if(PVERB>=3 /* && I_TRACE >= 0 && I == I_TRACE && K == K_TRACE && J == J_TRACE */){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,U=%d: truncating matchgroup[%d] right of lastiHWM=%d:score=%0.6f->%0.6f, ChimScore=%0.6f,cumiscore[U,lastiHWM]=%0.6f,%0.6f\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,U,i,lastiHWM,origscore,p->score,ChimScore,cumiscore[U],cumiscore[lastiHWM]);
	  fflush(stdout);
        }
      }
    }

    if(trimmed >= 2)/* mark matchgroup[i] for deletion by setting p->IL == p->I */
      p->I = p->IL;
  } // for( i = nummatchgroups; --i >= 0;)
  
  /* remove matchgroups marked for deletion with IL == I */
  int j = 0;
  for(int i = 0; i < nummatchgroup; i++){
    Cmatchgroup *p = &matchgroup[i];
    if(p->IL == p->I){
      if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE*/){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d: Removed matchgroup[%d]: I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d:score=%0.6f\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,i,p->I,p->K,p->J,p->IL,p->KL,p->JL,p->score);
	fflush(stdout);
      }
      continue;
    }

    if(i > j){
      if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE*/){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d: Moved matchgroup[%d -> %d]: I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d:score=%0.6f\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,i,j,p->I,p->K,p->J,p->IL,p->KL,p->JL,p->score);
	fflush(stdout);
      }
      matchgroup[j] = matchgroup[i];
    } else {
      if(PVERB>=3/* HERE HERE && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE*/){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d: Keeping matchgroup[%d]: I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d:score=%0.6f\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,i,p->I,p->K,p->J,p->IL,p->KL,p->JL,p->score);
	fflush(stdout);
      }
    }
    j++;
  }
  nummatchgroup = j;

  if(PVERB){
#pragma omp critical
    {
      printf("MatchgroupRefSplit: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d: nummatchgroups= %d -> %d\n",
	     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,orignummatchgroup,nummatchgroup);

      fflush(stdout);
    }
  }
}

/* Below heap[] is a Max-Heap wrt the ordering of Cmatchgroup->Fscore */
/* Pre : heap[1..heapcnt] is a Max-Heap except for heap[1] being (possible) too small
   Post : heap[1..heapcnt] is a Max-Heap.
   Children of heap[i] are heap[2i] and heap[2i+1]
*/
static void sift_down(Cmatchgroup* heap[], int heapcnt)
{
  int i = 1, j;
  Cmatchgroup *pI = heap[i];
  double scoreI = pI->Fscore;
  while((j = 2*i) <= heapcnt){
    if(j < heapcnt && heap[j]->Fscore < heap[j+1]->Fscore){
      if(scoreI >= heap[j+1]->Fscore)
	break;
      heap[i] = heap[j+1];
      i = j+1;
    } else {
      if(scoreI >= heap[j]->Fscore)
	break;
      heap[i] = heap[j];
      i = j;
    }
  }
  heap[i] = pI;
}

/* Pre : heap[1..heapcnt] is a Max-Heap except for heap[heapcnt] being (possibly) too large
   Post : heap[1..heapcnt] is a Max-Heap.

   Parent of heap[j] is heap[j/2]
*/
static void sift_up(Cmatchgroup* heap[], int heapcnt)
{ 
  int i = heapcnt;
  Cmatchgroup *heapI = heap[i];
  double scoreI = heapI->Fscore;
  for(int j; i > 1; i = j){
    j = i/2;
    if(scoreI <= heap[j]->Fscore)
      break;
    heap[i] = heap[j];
  }
  heap[i] = heapI;
}

/* return largest scoring matchgroup pointer from heap[1..heapcnt] after removing it from the heap[] */
static inline Cmatchgroup *heap_extract(Cmatchgroup* heap[], int &heapcnt)
{
  Cmatchgroup *ret = heap[1];
  
  heap[1] = heap[heapcnt--];
  sift_down(heap,heapcnt);

  return ret;
}

/* insert matchgroup pointer p into heap[1..heapcnt] */
static inline void heap_insert(Cmatchgroup* heap[], int &heapcnt, Cmatchgroup *p)
{
  heap[++heapcnt] = p;
  sift_up(heap,heapcnt);
}

static int localtype = -2;

#include "refalign_3Drecurrance.cpp"

/** version of refalignXY for resSD > 0 with 3-D recurrance based alignment.
Exectution of dynamic programming routine as described in TA's whitepaper .  
Currently a long function >2000 lines. Hardware specific implementations regulated
by the USE_MIC preprocessor directives. 

initialize: 
Perform DP, many control structures {enumerate}
Find the best result, check for circularity, chimerism.
Perform traceback
Identfy and store best alignment and second best.
*/
static __attribute__ ((noinline)) void refalignXYsd(FLOAT *Y, int N,
						    FLOAT *X, int M,
						    int orientation, 
						    int scaleID,
						    int *Kmax,
						    AL *A,
						    RFLOAT * &Fmem, /**< preallocated memory Fmem[0 ... pcnt*maxM*DPsizF - 1] to be used to reallocate A->field[I][K][] of type RFLOAT */
						    int * &Imem, /**< preallocated memory Imem[0 ... pcnt*maxM*DPsizI - 1] to be used to reallocate by A->field[I][K][] of type int */
						    long long &StrideMax,/* If (DIAGONAL>=2 && MIN_MEM && hashdelta) : the current allocated number of elements per array */
						    long long &KstrideMax, /* If (DIAGONAL>=2 && MIN_MEM && CACHE && hashdelta) : the Kstride value used with stride <= StrideMax */
						    int *JMIN, int *JMAX,/* preallocated memory JMIN[1..maxN],JMAX[1..maxN], for use with hashtable offset information for diagonalized arrays */
						    int *Imin, int *Imax,/* preallocated memory Imin[1..maxM],Imax[1..maxM], for use with hashtable offset information for diagonalized arrays */
						    Calign *align,
						    Cmap *rmap, Cmap *nanomap,
						    int refid, int mapid,/**< NOTE : due to multithreading, Gmap[] or refmap[] may be outdated cache values, but nanomap and rmap will correctly represent Gmap[mapid] & refmap[refid] */
						    CXPen *XPen,
						    CHashMatch *phash, /**< If != 0, limit map offset to within hashdelta of phash->offset (in kb) */
						    int tid, int numthreads,
						    int &maxmatchgroup, /* size of matchgroup & mheap memory allocated : can be increased, if needed */
						    Cmatchgroup * &matchgroup, /* memory for matchgroup[0..maxmatchgroup-1 (extends to 2*maxmatchgroup-1 if MATCHGROUP_HEAP)] */
						    Cmatchgroup ** &mheap, /* If MATCHGROUP_HEAP : memory for mheap[0..maxmatchgroup] */
						    double hashdelta,
						    double hashdeltaAdjust,
						    double ScoreThreshold2, double LogPvThreshold2, int AlignedSiteThreshold2,
						    int IMIN = 1, int IMAX = -1,
						    int jmin = 1, int jmax = -1,
						    int rev = 0 /* 1 if Y is reversed */
						    )
{
  if(DEBUG>=2 && align->Malign){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
    for(int i = 0; i < align->multimax; i++)
      for(int j = i+1; j < align->multimax; j++)
	if(align->Malign[i] == align->Malign[j]){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers):tid=%d\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax,tid);
	  fflush(stdout);
	  assert(align->Malign[i] != align->Malign[j]);
	}
  }

  if(DEBUG>=2){
    for(int I = 1; I <= N+1; I++)
      assert(Y[I] >= Y[I-1]);

    for(int J = 1; J <= M+1; J++)
      assert(X[J] >= X[J-1]);
  }

  if(PVERB>=2){
    #pragma omp critical
    {
      printf("refalignXYsd: tid=%d,refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:IMIN=%d,IMAX=%d,jmin=%d,jmax=%d,hashdelta= %0.1f,wt=%0.6f\n",
	     tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,IMIN,IMAX,jmin,jmax,hashdelta,wtime());
      fflush(stdout);
    }
  }

  int origIMIN = IMIN;
  int origIMAX = IMAX;
  int origjmin = jmin;
  int origjmax = jmax;

  if(IMAX < 0)
    IMAX = N;
  if(jmax < 0)
    jmax = M;

  if(M <= 0){
    if(DEBUG) assert(minSNRestimate);
    return;
  }

  if(DEBUG>=2){
    assert(Y[0] == 0.0);
    for(int i = 1; i <= N+1; i++)
      assert(Y[i] > Y[i-1]);
    assert(X[0] == 0.0);
    for(int j = 1; j <= M+1; j++){
      if(!(X[j] > X[j-1])){
	#pragma omp critical
	{
	  printf("refalignXYsd:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:M=%d,j=%d,X[j-1]=%0.8f,X[j]=%0.8f\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,M,j,X[j-1],X[j]);
	  for(int t = 0; t <= M+1; t++)
	    printf("X[%d]= %0.8f\n",t,X[t]);
	  fflush(stdout);
	  assert(X[j] > X[j-1]);
	}
      }
    }
  }

  if(DEBUG && SCORE_INIT_DELAY && !(grefend > refid)){
    #pragma omp critical
    {
      printf("refid=%d,numrefmaps=%d,grefend=%d\n",refid,numrefmaps,grefend);
      fflush(stdout);
      assert(grefend > refid);
    }
  }
  if(DEBUG && !SCORE_INIT_DELAY) assert(grefend == numrefmaps);

  XPen_init(X,M,XPen);
  Cprtab **PRtabY = PRtab[refid + rev * grefend];
  CYPen ****YPenR = YPen[refid + rev * grefend];

  localtype = (NEW && PoutlierEnd > 0.0) ? -3 : -2;

  int Jmin1 = jmin, Jmax1 = jmax;/* only used if DIAGONAL >= 2 and is the allocated J range for index I==IMIN.
				    Allocated J range for other I are:
				    If (Jmax1-Jmin1+1 <  jmax-jmin+1) : Jmin1+(I-IMIN) ... Jmax1+(I-IMIN)
				    If (Jmax1-Jmin1+1 >= jmax-jmin+1) : Jmin1 ... Jmax1 
				 */

  if(FAST && nanomap->align->mapid1>=0 && !rev){
    Calign_brief *palign = nanomap->align;
    if(orientation == palign->orientation && scaleID == palign->scaleID && (!BestRef || palign->mapid1 == refid)){
      if(FAST>=2 && nanomap->align->score > FAST_SCORE){
	int U = palign->numpairs;
	if(U >= 2){
	  IMIN = max(1,palign->sites1_0 - DELTA_Y);
	  IMAX = min(N,palign->sites1_M + DELTA_Y);
	}
      }
    } else {/* effectively skip this alignment */
      IMIN = 1;
      IMAX = 0;
    }
  }

  /* Note: I and I - Kmax[I] must be monotonically non-decreasing functions of I (unless Kmax[I] < 0)*/
  if(DEBUG>=2){
    int Tmax = 1;
    for(int I=IMIN; I <= IMAX; I++){
      if(Kmax[I] < 0)
	continue;
      assert(I-Kmax[I] >= 1);
      if(!(I-Kmax[I] >= Tmax)){
	printf("refalignXYsd:mapid=%d,orientation=%d\n",mapid,orientation);
	printf("I=%d,Kmax[I]=%d,Tmax=%d\n",I,Kmax[I],Tmax);
	assert(I-Kmax[I] >= Tmax);
      }
      if(I-Kmax[I] > Tmax)
	Tmax = I-Kmax[I];
    }
  }

#ifdef VALGRIND
  int ival = -555555555;
#else
  int ival = -5555;
#endif

  if(DEBUG>=2 && DIAGONAL <= 1){/* set all A->*score(I,K,J)  = nan("NaN") */
    for(int I = 1; I <= N; I++){
      for(int K = 0; K <= Kmax[I]; K++){
	for(int J = 1; J <= M; J++){
	  A->score(I,K,J) = aNaN;
	  A->Uscore(I,K,J) = aNaN;
	  A->Rijx(I,K,J) = A->Lijx(I,K,J) = A->Rij(I,K,J) =  A->Lij(I,K,J) = A->H(I,K,J) = A->T(I,K,J) = A->G(I,K,J) = ival;
	}
      }
    }
  }

  if(PVERB>=2 && phash){
    #pragma omp critical
    {
      printf("refalignXYsd:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:phash=%p(offset=%d,hashscore=%d,or=%d,sc=%d),hashdelta= %0.1f,N=%d,M=%d,Y[N+1]=%0.3f,X[M+1]=%0.3f,I=%d..%d (tid=%d) wtime= %0.6f secs\n",
	     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,phash,phash->offset,phash->hashscore,phash->orientation,phash->scaleID,hashdelta,N,M,Y[N+1],X[M+1],IMIN,IMAX,tid, wtime());
      fflush(stdout);
    }
  }

  double wt2 = 0.0;
  int retries = 0;/* number of times we jumped to LwaitForMemory */
  long long nMemSiz = 0;
  double realratio = 1.0;

 LwaitForMemory:

  if(phash && hashdelta){/* use hashtable information to limit range IMIN...IMAX (If DIAGONAL : also adjust JMIN[I]..JMAX[I] and reallocate A->field[][][]) */
    double offset = phash->offset;

    if(rev){ /* need to correct offset since both Y and X are reversed */
      /* newoffset + offset + X[M+1] == Y[N+1] */
      if(PVERB){
	printf("\t refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:offset = %0.3f -> %0.3f (X[M+1]= %0.3f, Y[N+1]= %0.3f)\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,offset, Y[N+1] - X[M+1] - offset, X[M+1], Y[N+1]);
	fflush(stdout);
      }
      offset = Y[N+1] - X[M+1] - offset;
    }

    if(!(OFFSET_SCALE_FIX && hashScaleDelta) && scaleID != 0 ){    /* need to slightly correct offset if scaleID != 0 */
      FLOAT scale = ScaleFactor[scaleID];
      offset -= 0.5 * X[M+1] * (1.0 - 1.0 / scale);
    }

    if(nanomap->origmap){/* correct phash->offset since it is based on original map of which nanomap is a sub-fragment */
      if(DEBUG) assert(HashMultiMatch);
      if(rev || scaleID != 0){
	printf("-MultiMatchRev or -ScaleDelta not implemented without -nosplit 2\n");
	fflush(stdout);
	if(DEBUG) assert(NoSplit < 2);
	if(DEBUG) assert(!(MultiMatches && MultiMatchesRev) && !ScaleDelta);
      }
      Cmap *origmap = nanomap->origmap;
      FLOAT *origX = origmap->site[0];
      if(DEBUG) assert(!origmap->origmap);
      if(!orientation){
	int L = nanomap->left[0];
	offset = phash->offset + origX[L] - X[1];
      } else {
	int R = nanomap->right[0];
	int origM = origmap->numsite[0];
	offset = phash->offset + (origX[origM+1] - origX[R]) - (X[M+1] - X[M]);
      }
    }

    //    double len = min(Y[N+1],X[M+1]);
    double deltaoffset =  max(Ylambda*DELTA_Y,Xtheta*DELTA_X);
    double offsetSD = max(deltaoffset, hashdelta * 2.0 * OffsetKB /* WAS hashdelta * max(Ylambda,Xtheta)*/);
    int ioffsetSD = floor(hashdelta + 0.9999);
    ioffsetSD = max(ioffsetSD, max(DELTA_X,DELTA_Y));

    int startjmin = jmin;
    int startjmax = jmax;

    if(ShiftOffset1 <= 30){  /* update jmin and jmax based on phash->MinLoc2 and phash->MaxLoc2 */
      // NEW401: If rev==1, then phash->MinLoc2 and phash->MaxLoc2 needs to be relative to right end of X
      for(;jmin < jmax; jmin++)
	if(X[jmin+1] + offsetSD/* NEW78 */ >= (rev ? X[M+1] - phash->MaxLoc2 : phash->MinLoc2))
	  break;
      for(;jmin < jmax; jmax--)
	if(X[jmax-1] - offsetSD/* NEW78 */ <= (rev ? X[M+1] - phash->MinLoc2 : phash->MaxLoc2))
	  break;

      //      jmin = max(startjmin, jmin - ioffsetSD);
      //      jmax = min(startjmax, jmax + ioffsetSD);

      Jmin1 = jmin;
      Jmax1 = jmax;
    }

    if(VERB && MIN_MEM_DEBUG && StrideMax <= 0){
      #pragma omp critical
      {
	if(ShiftOffset1 <= 30)
	
	  printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:offset=%0.1f,deltaoffset=%0.3f,offsetSD=%0.3f,ioffsetSD=%d: hashscore=%d,hashdelta=%0.1f,OffsetKB=%0.3f,Ylambda=%0.3f,Xtheta=%0.3f,DELTA_X=%d,DELTA_Y=%d,jmin=%d,jmax=%d,M=%d(Loc2=%0.1f .. %0.1f kb)\n",
	       tid,refid,rmap->id,mapid,nanomap->id,orientation,offset,deltaoffset,offsetSD,ioffsetSD,phash->hashscore,hashdelta,OffsetKB,Ylambda,Xtheta,DELTA_X,DELTA_Y,jmin,jmax,M,phash->MinLoc2,phash->MaxLoc2);
	else
	  printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:offset=%0.1f,deltaoffset=%0.3f,offsetSD=%0.3f,ioffsetSD=%d: hashscore=%d,hashdelta=%0.1f,OffsetKB=%0.3f,Ylambda=%0.3f,Xtheta=%0.3f,DELTA_X=%d,DELTA_Y=%d,jmin=%d,jmax=%d,M=%d\n",
		 tid,refid,rmap->id,mapid,nanomap->id,orientation,offset,deltaoffset,offsetSD,ioffsetSD,phash->hashscore,hashdelta,OffsetKB,Ylambda,Xtheta,DELTA_X,DELTA_Y,jmin,jmax,M);
	fflush(stdout);
      }
    }

    if(PVERB){
      #pragma omp critical
      {
	if(ShiftOffset1 <= 30)
	  printf("refalignXYsd:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:phash=%p(offset=%d,offset=%0.1f kb,hashscore=%d,or=%d,sc=%d),hashdelta=%0.1f:\n  offsetSD=%0.6f(%d):deltaoffset=%0.6f,Ylambda=%0.6f,Xtheta=%0.6f,Y[N+1]=%0.3f,X[M+1]=%0.3f,jmin=%d,jmax=%d(Loc2=%0.1f .. %0.1f,X[]=%0.1f..%0.1f kb):wall time=%0.6f secs\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,phash,phash->offset,offset,phash->hashscore,phash->orientation, phash->scaleID,hashdelta, offsetSD, ioffsetSD, deltaoffset, Ylambda, Xtheta, Y[N+1],X[M+1], jmin, jmax, phash->MinLoc2,phash->MaxLoc2,X[jmin],X[jmax],wtime());
	else
	  printf("refalignXYsd:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:phash=%p(offset=%d,offset=%0.1f kb,hashscore=%d,or=%d,sc=%d),hashdelta=%0.1f:\n\t offsetSD=%0.6f(%d):deltaoffset=%0.6f,Ylambda=%0.6f,Xtheta=%0.6f,Y[N+1]=%0.3f,X[M+1]=%0.3f,jmin=%d,jmax=%d:wall time=%0.6f secs\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,phash,phash->offset,offset,phash->hashscore,phash->orientation,phash->scaleID, hashdelta, offsetSD, ioffsetSD, deltaoffset, Ylambda, Xtheta, Y[N+1],X[M+1], jmin, jmax, wtime());
	fflush(stdout);
      }
    }

    if(HASHRANGE){
      int origIMIN = IMIN, origIMAX = IMAX;
      while(IMIN < IMAX && Y[IMIN+1]-X[jmin] < offset)
	IMIN++;
      while(IMIN < IMAX && Y[IMAX-1]-X[jmax] > offset)
	IMAX--;
      IMIN = max(origIMIN/* WAS 1 */, IMIN - ioffsetSD);
      IMAX = min(origIMAX/* WAS N */, IMAX + ioffsetSD);
    } else {
      while(IMIN < IMAX && Y[IMIN+1]-X[jmin] < offset - offsetSD)
	IMIN++;
      while(IMIN < IMAX && Y[IMAX-1]-X[jmax] > offset + offsetSD)
	IMAX--;
    }

    for(int I = IMIN; I <= IMAX; I++){
      JMIN[I] = jmin;
      JMAX[I] = jmax;
    }

    if(DIAGONAL){
      for(int I = IMIN; I <= IMAX; I++){
	if(HASHRANGE){
	  while(JMIN[I] < JMAX[I] && Y[I] - X[JMIN[I]+1] > offset)
	    JMIN[I]++;
	  while(JMIN[I] < JMAX[I] && Y[I] - X[JMAX[I]-1] < offset)
	    JMAX[I]--;
	  JMIN[I] = max(jmin, JMIN[I] - ioffsetSD);
	  JMAX[I] = min(jmax, JMAX[I] + ioffsetSD);
	} else {
	  while(JMIN[I] < JMAX[I] && Y[I] - X[JMIN[I]+1] > offset + offsetSD)
	    JMIN[I]++;
	  while(JMIN[I] < JMAX[I] && Y[I] - X[JMAX[I]-1] < offset - offsetSD)
	    JMAX[I]--;
	}
      }

      if(PVERB>=2){
	printf("IMIN= %d, IMAX= %d, jmin= %d->%d, jmax= %d->%d,Y[]=%0.1f..%0.1f,X[]=%0.1f..%0.1f kb: hashdelta=%0.1f,deltaoffset=%0.4f,offsetSD=%0.4f,ioffsetSD=%d\n",
	       IMIN,IMAX,startjmin,jmin,startjmax,jmax,Y[IMIN],Y[IMAX],X[jmin],X[jmax],hashdelta,deltaoffset,offsetSD,ioffsetSD);
	if(PVERB>=3)
	  for(int I = IMIN; I <= IMAX; I++)
	    printf("\t I= %d: JMIN[I]= %d, JMAX[I]= %d (Y[I]= %0.4f, X[JMIN[I]]= %0.4f, X[JMAX[I]]= %0.4f, X[JMIN[i]+ioffsetSD]= %0.4f, X[Jmax[i]-ioffsetSD]= %0.4f\n",
		   I,JMIN[I],JMAX[I], Y[I], X[JMIN[I]],X[JMAX[I]], X[min(jmax,JMIN[I] + ioffsetSD)], X[max(jmin,JMAX[I]-ioffsetSD)]);
	fflush(stdout);
      }

      long long jcnt1 = 0, jcnt2 = 0;
      if(MIN_MEM_DEBUG)
	for(int I = IMIN; I <= IMAX; I++)
	  jcnt1 += JMAX[I] - JMIN[I] + 1;

      /* enforce monotonic restrictions IMIN .. IMAX :
	 1. JMIN[I=IMAX..IMIN] is a non-increasing function as I decreases.
	 2. JMAX[I=IMIN..IMAX] is a non-decreasing function as I increase.
      */
      for(register int I = IMAX; --I >= IMIN;)
	JMIN[I] = min(JMIN[I],JMIN[I+1]);
      for(register int I = IMIN; ++I <= IMAX;)
	JMAX[I] = max(JMAX[I],JMAX[I-1]);

      if(MIN_MEM_DEBUG || RA_MIN_TIME)
	for(int I = IMIN; I <= IMAX; I++)
	  jcnt2 += JMAX[I] - JMIN[I] + 1;

      if(PVERB>=3){
	printf("IMIN= %d, IMAX= %d, jmin= %d, jmax= %d: hashdelta=%0.1f,deltaoffset=%0.4f,offsetSD=%0.4f,ioffsetSD=%d\n",IMIN,IMAX,jmin,jmax,hashdelta,deltaoffset,offsetSD,ioffsetSD);
	for(int I = IMIN; I <= IMAX; I++)
	  printf("\t I= %d: JMIN[I]= %d, JMAX[I]= %d (Y[I]= %0.4f, X[JMIN[I]]= %0.4f, X[JMAX[I]]= %0.4f)\n",I,JMIN[I],JMAX[I], Y[I], X[JMIN[I]],X[JMAX[I]]);
	fflush(stdout);
      }

      long long origStrideMax = StrideMax;
      long long origKstrideMax = KstrideMax;

      if(DIAGONAL>=2){
	/* Re-allocate A->field[I][K][] based on JMIN[],JMAX[] for more compact real memory usage */
	/* expand band so boundaries are exactly diagonal (index slope = 1:1) */
	Jmin1 = 1;
	Jmax1 = 0;
	/*	Jmin1 = JMIN[IMIN];
		Jmax1 = JMAX[IMIN];*/
	for(int I = IMIN; I <= IMAX; I++){
	  Jmin1 = min(Jmin1,JMIN[I]-(I-IMIN));
	  Jmax1 = max(Jmax1,JMAX[I]-(I-IMIN));
	}

	int kmax = Kmax[IMIN];
	for(int I = IMIN+1; I <= IMAX; I++)
	  kmax = max(kmax,Kmax[I]);

	int deltaJ = Jmax1-Jmin1+1;
	if(deltaJ >= (jmax-jmin+1)/* WAS M */){/* revert to non-diagonal method base(I=IMIN..IMAX,K=0..kmax,J=jmin..jmax) = base[I*Istride + K*Kstride + J - firstindex] */
	  Jmin1 = jmin;// WAS 1
	  Jmax1 = jmax;// WAS M
	  deltaJ = Jmax1-Jmin1+1;
	  A->Istride = jmax-jmin+1;// WAS M
	} else
	  A->Istride = deltaJ - 1;

	if(DEBUG && sizeof(A->Istride) <= 4 && !(((long long)A->Istride) * ((long long)IMAX) <= (long long)MASK_LL(31))){// NEW7
	  printf("ERROR in refalign.cpp:IMIN=%d,IMAX=%d,N=%d; jmin=%d,jmax=%d,M=%d; deltaJ= %d, A->Istride= %lld : A->Istride * IMAX = %lld overflows 32 bit integer: Change Istride to 64 bit int\n",
		 IMIN,IMAX,N,jmin,jmax,M,deltaJ,A->Istride, (long long)A->Istride * (long long)IMAX);
	  assert(((long long)A->Istride) * ((long long)IMAX) <= (long long)MASK_LL(31));
	}

	if(FENCE > 0){
	  Jmin1 -= FENCE;
	  Jmax1 += FENCE;
	  deltaJ += 2*FENCE;
	  A->Istride += 2*FENCE;
	}

	A->kmax = kmax;
	A->Kstride = (IMAX - IMIN + 1LL) * deltaJ;
	if(CACHE && ALIGN)
	  A->Kstride = (A->Kstride + ALIGN - 1) & (~(ALIGN-1));
	long long stride = (1LL + (CACHE ? A->KMAX : A->kmax)) * A->Kstride;
	if(CACHE && ALIGN2)
	  stride = (stride + ALIGN2 - 1) & (~(ALIGN2-1));
	long long firstindex = IMIN * A->Istride + Jmin1;
	A->firstindex = firstindex;// NEW147
	A->stride = stride;// NEW147

	realratio = max(((double)min(deltaJ, 1024)) /* 1 page = 1024 ints or floats */ / deltaJ, ((double)jcnt2)/A->Kstride);

	if(VERB && MIN_MEM_DEBUG){
          #pragma omp critical(vmemTotsiz)
          {
	    double InvGB = 1e-9;
	    long long memsiz = (stride * (DPsizF * sizeof(RFLOAT) + DPsizI * sizeof(int)) + PADDING*3);
	    getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
	    realVmRSS = VmRSS;
            printf("tid=%d:rid=%lld,mid=%lld,or=%d:deltaJ=%d,M=%d,N=%d,IMIN=%d,IMAX=%d,kmax=%d,kstride=%lld,jcnt=%lld,jmean=%0.1f(%0.3f%%):stride=%lldk(Max=%lld),vmem= %0.3f, mem= %0.3f (Tot=%0.2f, %0.2f),VmRSS=%0.2f,VmSwap=%0.2f Gb\n",
		     tid,rmap->id,nanomap->id,orientation,deltaJ,M,N,IMIN,IMAX,(CACHE ? A->KMAX : A->kmax) , A->Kstride, jcnt2, ((double)jcnt2)/(IMAX-IMIN+1), realratio * 100.0,stride/1000,StrideMax/1000,
		   memsiz * InvGB, memsiz * InvGB * realratio, vmemTotsiz * InvGB, memTotsiz * InvGB, VmRSS*InvGB, VmSwap*InvGB);
            fflush(stdout);
	    if(DEBUG>=2 && !(VmRSS <= VmHWM)){
	      printf("tid=%d: VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: wt= %0.6f\n",tid,VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9,VmSize*1e-9,wtime());
	      fflush(stdout);
	      assert(VmRSS <= VmHWM);
	    }
          }
        }

        if(DEBUG && CACHE && (bool(ALIGN) || bool(ALIGN2)) && stride <= StrideMax && !(A->Kstride <= KstrideMax)){
	  #pragma omp critical
	  {
	    printf("tid=%d,rid=%lld,mid=%lld,or=%d:IMIN=%d,IMAX=%d,N=%d,deltaJ=%d:A->kmax=%d(KMAX=%d),A->Kstride=%lld(KstrideMax=%lld),stride=%lld(StrideMax=%lld)\n",
		   tid,rmap->id,nanomap->id,orientation,IMIN,IMAX,N,deltaJ,A->kmax,KMAX,A->Kstride,KstrideMax,stride,StrideMax);
	    fflush(stdout);
	    assert(A->Kstride <= KstrideMax);
	  }
	}

	double wt = RA_MIN_TIME ? wtime() : 0.0;

	nMemSiz = (stride * (DPsizF * sizeof(RFLOAT) + DPsizI*sizeof(int)) + PADDING*3 + PAGE-1) & ~(PAGE-1);/* required amount of memory */

	if(RA_MIN_TIME && MIN_MEM < 8 && MaxMemSiz > 0){/* Pause this thread if not enough memory is available */
	  int WAIT_TICKS = floor(1.0/VMRSS_SLEEP + 0.5);
	  int waitcnt = 0;
	  double waittime = 0.0;
	  long long myvmemTotsiz;

	  long long maxVmRSS1 = MaxMemSiz - nMemSiz*realratio;// maxmimum VmRSS allowed for jobs expected to use less than 10% of the per thread amount (so total will fit within 100% of memory)
	  long long maxVmRSS2 = MaxMemSiz2 - nMemSiz*realratio;// maximum VmRSS allowed for large memory alignments (must fit within 90% of memory)

	  bool SmallJob = nMemSiz*realratio < MaxMemSiz / (NumThreads * 10);
	  long long maxVmRSS = SmallJob ? maxVmRSS1 : maxVmRSS2;// maximum VmRSS allowed for current alignment

	  bool madvise_called = false;
	  bool memfound = false;
	  bool ThreadPaused = false;

	  while(!memfound){
	    double wt = wtime();
	    
	    #pragma omp atomic read
	    myvmemTotsiz = vmemTotsiz;
	    
	    if(DEBUG) assert(myvmemTotsiz >= 0);

	    if(myvmemTotsiz + nMemSiz <= MaxMemSiz){ // total virtual memory is <= MaxMemSiz : no need to check VmRSS in critical section
	      if(VERB>=3){
		long long rVmSize,rVmRSS,rVmSwap,rVmHWM;// local copies, so global shared values are not modified
		getmem(rVmSize,rVmRSS,rVmSwap,&rVmHWM);
                #pragma omp critical(vmemTotsiz)
		{
		  printf("tid=%d: vmemTotsiz= %0.3f, nMemSiz= %0.3f Gb: no need to check VmRSS (VmSize= %0.3f, VmRSS= %0.3f, VmHWM= %0.3f, VmSwap= %0.3f Gb, rid=%lld,mid=%lld)\n",
			 tid, vmemTotsiz*1e-9,nMemSiz*1e-9, rVmSize*1e-9, rVmRSS*1e-9, rVmHWM*1e-9, rVmSwap*1e-9, rmap->id,nanomap->id);
		  fflush(stdout);
		}
	      }
	      if(madvise_called)
		FmemTime[tid] = wt;// update FmemTime[tid] in case this thread has been paused
	      break;
	    }

	    if(!madvise_called && FmemHWM[tid] > 0 && (VmRSS + VmSwap > maxVmRSS || (VmRSS + VmSwap > MaxMemSiz /* maxVmRSS */ * RA_MAX_MEM && wt - FmemTime[tid] >= RA_MIN_TIME))){
	      long long sVmSize,sVmRSS,sVmSwap,sVmHWM;// local copies, so global shared values are not modified
	      if(VERB>=3)
		getmem(sVmSize,sVmRSS,sVmSwap,&sVmHWM);
	      long long HWMsiz = MADVISE_HWM ? FmemHWM[tid] : FmemSiz[tid];
	      FmemMadv[tid] += HWMsiz;
	      if(madvise(&Fmem[-PADDING/sizeof(RFLOAT)],HWMsiz,MADV_DONTNEED)){
		int eno = errno;
		char *err = strerror(eno);
		printf("tid=%d:madvise(%p,%lld,MADV_DONTNEED) failed (FmemHWM[tid]=%lld):errno=%d:%s\n",tid,&Fmem[-PADDING/sizeof(RFLOAT)],HWMsiz,FmemHWM[tid],eno,err);
		fflush(stdout);exit(1);
	      }
	      if(VERB>=3){
		long long rVmSize,rVmRSS,rVmSwap,rVmHWM;// local copies, so global shared values are not modified
		getmem(rVmSize,rVmRSS,rVmSwap,&rVmHWM);

		printf("tid=%d:called madvise() on %0.4f/%0.4f Gb: VmRSS= %0.4f -> %0.4f(HWM=%0.2f), VmSwap= %0.4f Gb: wt= %0.6f\n", 
		       tid, FmemHWM[tid] * 1e-9, FmemSiz[tid] * 1e-9,sVmRSS*1e-9,rVmRSS*1e-9,rVmHWM*1e-9,rVmSwap*1e-9,wtime());
		fflush(stdout);
	      }
	      madvise_called = true;
	      FmemHWM[tid] = 0;
	      FmemTime[tid] = wt;
	    }

            #pragma omp critical(vmemTotsiz) // shared global variables : vmemTotsiz, VmSize, VmRSS, VmSwap, lastGetmem
	    {
	      if(wt > lastGetmem + VMRSS_CHECK){
	        getmem(VmSize,VmRSS,VmSwap,&VmHWM);
		realVmRSS = VmRSS;
		if(DEBUG>=2 && !(VmRSS <= VmHWM)){
	          printf("tid=%d: VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: wt= %0.6f\n",tid,VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9,VmSize*1e-9,wtime());
		  fflush(stdout);
	          assert(VmRSS <= VmHWM);
	        }
		lastGetmem = wt;
	      }
	      if(VmRSS + VmSwap <= maxVmRSS || PausedThreads + (ThreadPaused ? 0 : 1) >= NumThreads){
		if(VMRSS_DELAY > 0.0){
		  if(VmRSS + VmSwap <= maxVmRSS)
		    lastGetmem = max(lastGetmem, wt + VMRSS_DELAY - VMRSS_CHECK);// make sure no other thread updates VmRSS for next VMRSS_DELAY seconds
		  VmRSS += nMemSiz * realratio;// temporarily increase estimate of VmRSS by estimated new real memory used by current thread
		}
		memfound = true;// cannot break out of critical section
		if(ThreadPaused){
		  PausedThreads--;
		  ThreadPaused = false;
		}
	      } else if(!ThreadPaused){
		PausedThreads++;
		ThreadPaused = true;
	      }
	    }

	    if(memfound){
	      if(VERB/* HERE >=2 */ && (waittime > 10.0 /*||VmSwap*1e-9 >= 0.0*/) ){
                #pragma omp critical(vmemTotsiz)
	        {
		  if(VMRSS_DELAY)
		    printf("tid=%d: MaxMemSiz= %0.1f (Lim= %0.2f,%0.2f), vmemTotsiz= %0.2f Gb, VmRSS= %0.2f -> %0.2f(HWM=%0.2f), VmSwap= %0.2f Gb: After %0.2f seconds got vMem=%0.4f,Mem=%0.4f Gb of memory (rid=%lld,mid=%lld,N=%d,M=%d),Madv=%d,Paused Threads=%d/%d:wall=%0.6f,%0.6f\n",
			   tid, (SmallJob ? MaxMemSiz : MaxMemSiz2)*1e-9, maxVmRSS*1e-9, MaxMemSiz*RA_MAX_MEM, vmemTotsiz*1e-9, realVmRSS*1e-9, VmRSS*1e-9, VmHWM*1e-9, VmSwap*1e-9, waittime, nMemSiz*1e-9,nMemSiz*realratio*1e-9, rmap->id,nanomap->id,N,M,madvise_called,PausedThreads,NumThreads,lastGetmem,wt);
		  else
		    printf("tid=%d: MaxMemSiz= %0.1f (Lim= %0.2f,%0.2f), vmemTotsiz= %0.2f Gb, VmRSS= %0.2f(HWM=%0.2f), VmSwap= %0.2f Gb: After %0.2f seconds got vMem=%0.4f,Mem=%0.4f Gb of memory (rid=%lld,mid=%lld,N=%d,M=%d),Madv=%d,Paused Threads=%d/%d:wall=%0.6f,%0.6f\n",
			   tid, (SmallJob ? MaxMemSiz : MaxMemSiz2)*1e-9, maxVmRSS*1e-9, MaxMemSiz*1e-9*RA_MAX_MEM, vmemTotsiz*1e-9, VmRSS*1e-9, VmHWM*1e-9, VmSwap*1e-9, waittime, nMemSiz*1e-9,nMemSiz*realratio*1e-9, rmap->id,nanomap->id,N,M,madvise_called,PausedThreads,NumThreads,lastGetmem,wt);
		  fflush(stdout);
	        }
	      }
	      if(madvise_called)
		FmemTime[tid] = wt;// update FmemTime[tid] in case this thread has been paused
	      break;
	    }
	    
	    if(!madvise_called && FmemHWM[tid] > 0){
	      long long sVmSize,sVmRSS,sVmSwap,sVmHWM;
	      if(VERB>=3)
		getmem(sVmSize,sVmRSS,sVmSwap,&sVmHWM);

	      long long HWMsiz = MADVISE_HWM ? FmemHWM[tid] : FmemSiz[tid];
	      FmemMadv[tid] += HWMsiz;
	      if(madvise(&Fmem[-PADDING/sizeof(RFLOAT)], HWMsiz, MADV_DONTNEED)){
		int eno = errno;
		char *err = strerror(eno);
		printf("tid=%d:madvise(%p,%lld,MADV_DONTNEED) failed (FmemSiz[tid]=%lld,FmemHWM[tid]=%lld):errno=%d:%s\n",tid,&Fmem[-PADDING/sizeof(RFLOAT)],HWMsiz,FmemSiz[tid],FmemHWM[tid],eno,err);
		fflush(stdout);exit(1);
	      }
	      if(VERB>=3){
		long long rVmSize,rVmRSS,rVmSwap,rVmHWM;// local copies, so global shared values are not modified
		getmem(rVmSize,rVmRSS,rVmSwap,&rVmHWM);

		printf("tid=%d:called madvise() on %0.4f/%0.4f Gb: VmRSS= %0.4f -> %0.4f(HWM=%0.2f), VmSwap= %0.4f Gb: wt= %0.6f\n", 
		       tid, FmemHWM[tid] * 1e-9, FmemSiz[tid] * 1e-9,sVmRSS*1e-9,rVmRSS*1e-9,rVmHWM*1e-9,rVmSwap*1e-9, wtime());
		fflush(stdout);
	      }
	      madvise_called = true;
	      FmemHWM[tid] = 0;
	      FmemTime[tid] = wt;
	    }

	    if(VERB/* HERE >=2 */ && (((waitcnt % WAIT_TICKS) == 0 && ((waitcnt/WAIT_TICKS) % 60) == RA_MIN_TIME + 9) /* ||VmSwap*1e-9 >= 0.0*/)){
              #pragma omp critical(vmemTotsiz)
    	      {
	        printf("tid=%d: MaxMemSiz= %0.1f (Lim= %0.2f), vmemTotsiz= %0.2f Gb, VmRSS= %0.2f -> %0.2f(HWM=%0.2f), VmSwap= %0.2f Gb: waited %0.2f seconds for vMem=%0.4f,Mem=%0.4f Gb of memory (rid=%lld,mid=%lld,N=%d,M=%d),Paused Threads=%d/%d:wall=%0.6f,%0.6f\n",
		tid, (SmallJob ? MaxMemSiz : MaxMemSiz2)*1e-9, maxVmRSS*1e-9, vmemTotsiz*1e-9, realVmRSS*1e-9,VmRSS*1e-9, VmHWM*1e-9, VmSwap*1e-9, waittime, nMemSiz*1e-9,nMemSiz*realratio*1e-9, rmap->id,nanomap->id,N,M,PausedThreads,NumThreads,lastGetmem,wt);
		fflush(stdout);
	      }
	    }

	    // sleep VMRSS_SLEEP seconds 
            struct timespec rem, nt = tm;
	    while(nanosleep(&nt,&rem) < 0)
	      nt = rem;

	    waitcnt++;
	    waittime += VMRSS_SLEEP;
	    FmemSleep[tid] += VMRSS_SLEEP;
	  }// while(!memfound)
        }// RA_MIN_TIME && MaxMemSiz > 0

        wt2 = (RA_MIN_TIME && MEMCHECK) ? wtime() : 0.0;

	int MemBins = max(2,MIN_MEM);/* Allow for some extra memory of 1 part per MemBins and reduce memory when need drops below (MemBins-1)/(MemBins+1) (unless RA_MIN_TIME > 0) */

	if(MIN_MEM && (stride > StrideMax || MIN_MEM >= 8 || (MIN_MEM >= 2 && RA_MIN_TIME <= 0 && stride * (MemBins+1) < StrideMax * (MemBins-1)))){
	  size_t origmemsiz = (MIN_MEM_DEBUG || RA_MIN_TIME) ? FmemSiz[tid] : 0ul;
	  size_t origRmemsiz = MIN_MEM_DEBUG ? FmemRsiz[tid] : 0ul;

	  if(RA_MIN_TIME){// Using mmap/madvise/munmap 
	    if(Fmem && munmap(&Fmem[-PADDING/sizeof(RFLOAT)], FmemSiz[tid])){
	      int eno = errno;
	      char *err = strerror(eno);

              #pragma omp critical
	      {
	        printf("munmap(%p,%lld) failed: errno=%d:%s\n",Fmem, FmemSiz[tid], eno, err);
	        dumpmemmap();
	        fflush(stdout);exit(1);
	      }
	    }
	  } else // Using POSIX_MEMALIGN/free
	    if(Fmem) free(&Fmem[-PADDING/sizeof(RFLOAT)]);

	  KstrideMax = A->Kstride * ((MIN_MEM >= 8/* || RA_MIN_TIME*/) ? MemBins : MemBins+1) / MemBins;
	  if(CACHE && ALIGN){
	    long long origKstrideMax = KstrideMax;
	    KstrideMax = (KstrideMax + ALIGN - 1) & (~(ALIGN-1));
	    if(DEBUG>=2 && !(KstrideMax >= origKstrideMax)){
	      #pragma omp critical
	      {
		printf("origKstrideMax=0x%llx(%lld),ALIGN=0x%x(%d),KstrideMax=0x%llx(%lld)\n",
		       origKstrideMax,origKstrideMax,ALIGN,ALIGN,KstrideMax,KstrideMax);
		fflush(stdout);
		assert(KstrideMax >= origKstrideMax);
	      }
	    }
	  }

	  StrideMax = (1LL + (CACHE ? A->KMAX : A->kmax)) * KstrideMax;
	  if(CACHE && ALIGN2){
	    long long origStrideMax = StrideMax;
	    StrideMax = (StrideMax + ALIGN2 - 1) & (~(ALIGN2 - 1));
	    if(DEBUG>=2) assert(StrideMax >= origStrideMax);
	  }
	  if(DEBUG) assert(stride <= StrideMax);

	  if(CACHE && ALIGN2){/* increase KstrideMax to largest possible value <= StrideMax / (1LL + A->KMAX) */
	    int origKstrideMax = KstrideMax;
	    KstrideMax = (StrideMax / (1LL + A->KMAX)) & (~(ALIGN - 1));
	    if(DEBUG>=2) assert(KstrideMax >= origKstrideMax);
	    if(DEBUG>=2){
	      long long newStrideMax = (1LL + A->KMAX) * KstrideMax;
	      newStrideMax = (newStrideMax + ALIGN2 - 1) & (~(ALIGN2 - 1));	      
	      assert(newStrideMax == StrideMax);
	    }
	  }

	  size_t memsiz = (StrideMax * (DPsizF * sizeof(RFLOAT) + DPsizI*sizeof(int)) + PADDING*3 + PAGE-1) & ~(PAGE-1);

	  if(MIN_MEM_DEBUG || RA_MIN_TIME){
	    #pragma omp atomic update
	    vmemTotsiz += memsiz - origmemsiz;
          }
          if(MIN_MEM_DEBUG){
	    size_t Rmemsiz = memsiz * realratio;

	    #pragma omp atomic update
	    memTotsiz += Rmemsiz - origRmemsiz;
	  }

	  if(RA_MIN_TIME){// using mmap/madvise/munmap
	    char *newmem = (char *)mmap(NULL, memsiz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	    if(newmem == MAP_FAILED){
	      int eno = errno;
	      char *err = strerror(eno);
	    
              #pragma omp critical
	      {
	        printf("refalign: mmap of %lu bytes failed (nMemSiz= %lld):errno=%d:%s\n", memsiz,nMemSiz,eno,err);
		if(RA_MIN_TIME && MaxMemSiz > 0){
	          long long sVmSize,sVmRSS,sVmSwap,sVmHWM;// local copies, so global shared values are not modified
		  getmem(sVmSize,sVmRSS,sVmSwap,&sVmHWM);
	          printf("\tVmSize= %0.4f, VmRSS= %0.4f,%0.4f, VmHWM= %0.4f, VmSwap= %0.4f, nMemSiz= %0.4f, MaxMemSiz= %0.1f Gb\n",
		     sVmSize*1e-9,VmRSS*1e-9,sVmRSS*1e-9,sVmHWM*1e-9,sVmSwap*1e-9,nMemSiz*1e-9, MaxMemSiz*1e-9);
		  fflush(stdout);
	        }
		dumpmemmap();
		fflush(stdout);exit(1);
	      }
	    }
	    Fmem = (RFLOAT *)newmem;
	    if(VERB>=3){
	      long long rVmSize,rVmRSS,rVmSwap,rVmHWM;// local copies, so global shared values are not modified
	      getmem(rVmSize,rVmRSS,rVmSwap,&rVmHWM);

	      printf("tid=%d:called munmap()+mmap():memsiz=%0.4f -> %0.4f Gb: VmRSS= %0.4f (HWM=%0.2f), VmSwap= %0.4f Gb: wt= %0.6f\n", 
		tid, FmemHWM[tid] * 1e-9, memsiz * 1e-9, rVmRSS*1e-9,rVmHWM*1e-9,rVmSwap*1e-9,wtime());
	      fflush(stdout);
	    }
	  } else // using POSIX_MEMAIGN/free
	    POSIX_MEMALIGN(Fmem, PAGE, memsiz);

	  Fmem += PADDING/sizeof(RFLOAT);

	  Imem = (int *) &Fmem[DPsizF * StrideMax];

	  if(MIN_MEM_DEBUG || RA_MIN_TIME) FmemSiz[tid] = memsiz;
          if(RA_MIN_TIME){
	    FmemHWM[tid] = 0;
	    FmemTime[tid] = wt;
	  }
	  if(MIN_MEM_DEBUG) FmemRsiz[tid] = memsiz * realratio;

	  if(VERB/* HERE HERE >=2 */ && MaxVirtMem <= 0.0 && tid==0 && MIN_MEM_DEBUG){
	    #pragma omp critical
	    {
	      long long jcnt = 0;
	      for(int I = IMIN; I <= IMAX; I++)
		jcnt += JMAX[I] - JMIN[I] + 1;
	      size_t TotFmem = 0, TotFmemR = 0;
	      if(FmemSiz){
		for(int i = 0; i < numthreads; i++){
		  TotFmem += FmemSiz[i];
		  TotFmemR += FmemRsiz[i];
		}
	      }
	      double InvGB = 0.001 * 0.001 * 0.001;
	
	      printf("tid=%d,rid=%d(%lld),mid=%d(%lld),or=%d:Allocated %0.3f Gb for Fmem[],Imem[] (TotMem=%0.3f,Real=%0.3f Gb) : StrideMax=%lld->%lld,KstrideMax=%lld->%lld,stride=%lld,Fmem=%p,Imem=%p,firstindex=%lld,hashdelta=%0.1f\n",
		     tid, refid, rmap->id,mapid,nanomap->id,orientation,memsiz * InvGB,TotFmem * InvGB, TotFmemR * InvGB, origStrideMax, StrideMax, origKstrideMax, KstrideMax,
		     stride, Fmem, Imem,firstindex, hashdelta);
	      printf("   IMIN=%d,IMAX=%d,N=%d,M=%d,Y[IMIN,IMAX,N+1]=%0.3f,%0.3f,%0.3f,X[M+1]=%0.3f,Istride=%lld,Kstride=%lld,kmax=%d,Jmin1=%d,Jmax1=%d,deltaJ=%d(JMIN[IMIN]=%d,JMAX[IMIN]=%d,JMIN[IMAX]=%d,JMAX[IMAX]=%d),jcnt=%lld,%lld(%0.3f%%)\n",
		     IMIN,IMAX,N,M,Y[IMIN],Y[IMAX],Y[N+1],X[M+1],A->Istride,A->Kstride,(CACHE ? A->KMAX : A->kmax),Jmin1,Jmax1,deltaJ,JMIN[IMIN],JMAX[IMIN],JMIN[IMAX],JMAX[IMAX],jcnt1,jcnt, ((double)jcnt)/A->Kstride);
	      fflush(stdout);
	    }
	  }
	}

	if(RA_MIN_TIME){
	  if(0&& FmemHWM[tid] > 0 && wt - FmemTime[tid] >= RA_MIN_TIME && VmRSS + VmSwap > MaxMemSiz * RA_MAX_MEM){	// Is this still needed
	    long long sVmSize,sVmRSS,sVmSwap,sVmHWM;// local copies, so global shared values are not modified
	    if(VERB>=3)
	      getmem(sVmSize,sVmRSS,sVmSwap,&sVmHWM);
	    long long HWMsiz = MADVISE_HWM ? FmemHWM[tid] : FmemSiz[tid];
	    FmemMadv[tid] += HWMsiz;
	    if(madvise(&Fmem[-PADDING/sizeof(RFLOAT)],HWMsiz,MADV_DONTNEED)){
	      int eno = errno;
	      char *err = strerror(eno);
	      printf("tid=%d:madvise(%p,%lld,MADV_DONTNEED) failed (FmemSiz[tid]=%lld,FmemHWM[tid]=%lld):errno=%d:%s\n",tid,&Fmem[-PADDING/sizeof(RFLOAT)],HWMsiz,FmemSiz[tid],FmemHWM[tid],eno,err);
	      fflush(stdout);exit(1);
	    }
	    if(VERB>=3){
	      long long rVmSize,rVmRSS,rVmSwap,rVmHWM;// local copies, so global shared values are not modified
	      getmem(rVmSize,rVmRSS,rVmSwap,&rVmHWM);
	      
	      printf("tid=%d:called madvise() on %0.4f/%0.4f Gb: VmRSS= %0.4f -> %0.4f(HWM=%0.2f), VmSwap= %0.4f Gb:wt= %0.6f\n", 
		     tid, FmemHWM[tid] * 1e-9, FmemSiz[tid] * 1e-9,sVmRSS*1e-9,rVmRSS*1e-9,rVmHWM*1e-9,rVmSwap*1e-9,wtime());
	      fflush(stdout);
	    }
	    FmemHWM[tid] = 0;
	    FmemTime[tid] = wt;
	  }

	  FmemHWM[tid] = max(FmemHWM[tid],nMemSiz);
	}

	if(CACHE){
	  if(DEBUG) assert(A->kmax <= A->KMAX);
	  if(DEBUG) assert(stride <= StrideMax);
	  if(DEBUG) assert(A->Kstride <= KstrideMax);
	  A->Kstride = KstrideMax;
	  A->stride = stride = StrideMax;
	  if(DEBUG && !ALIGN2) assert(stride == (1LL + (CACHE ? A->KMAX : A->kmax)) * A->Kstride);
	  if(DEBUG && bool(ALIGN2)) assert(stride >= (1LL + (CACHE ? A->KMAX : A->kmax)) * A->Kstride);
	}

	if(DEBUG>=2){
	  for(int I = IMIN; I <= IMAX; I++){
	    assert(I * A->Istride + JMIN[I] >= firstindex);
	    assert(I * A->Istride + A->kmax * A->Kstride + JMAX[I] < firstindex + stride);
	  }
	}

	if(DEBUG) assert(stride <= StrideMax);

	long long mcnt = 0;
#define FBLOCK(field) { \
	  A->field##_base = &Fmem[mcnt - firstindex];	\
	  mcnt += stride;				\
	  if(0&& RA_MIN_TIME){/* touch all memory that will be used so it is reflected in VmRss as soon as possible */ \
	    /*	    if(sizeof(RFLOAT) != sizeof(int)) memset(&A->field##_base[firstindex], 0, sizeof(RFLOAT) * (1LL + (CACHE ? A->KMAX : A->kmax)) * A->Kstride); */ \
	    /* else memset_int((int *)(&A->field##_base[firstindex]), 0, (1LL + (CACHE ? A->KMAX : A->kmax)) * A->Kstride); */ \
	    for(int I = IMIN; I <= IMAX; I++)   			                            \
	      for(int K = 0; K <= Kmax[I]; K++)      			                            \
	         memset(&A->field(I,K,JMIN[I]), 0, sizeof(RFLOAT)*(JMAX[I]-JMIN[I]+1));             \
	  }                                                                                         \
	}
	FBLOCK(score);
	FBLOCK(Uscore);
	if(RepeatRec)
	  FBLOCK(rscore);
	if(MultiMatches){
	  FBLOCK(Tscore);
	}
#undef FBLOCK

	if(DEBUG && !(mcnt <= stride * DPsizF)){
	  #pragma omp critical
	  {
	    printf("tid=%d:rid=%lld,mid=%lld,or=%d:N=%d,M=%d,maxM=%lld,maxN=%lld:deltaJ=%d,kmax=%d,Istride=%lld,Kstride=%lld,stride=%lld,pcnt=%lld,mcnt=%lld,DPsizF=%lld,IMAX=%d,IMIN=%d,FENCE=%d,PADDING=%d\n",
		   tid,rmap->id,nanomap->id,orientation,N,M,maxM,maxN,deltaJ,kmax,A->Istride,A->Kstride,stride,pcnt,mcnt,DPsizF,IMIN,IMAX,FENCE,PADDING);
	    fflush(stdout);
	    assert(mcnt <= stride * DPsizF);
	  }
	}

	if(PVERB){
	  printf("refid=%lld,mapid=%lld,or=%d,rev=%d:re-allocating A:IMIN=%d,IMAX=%d,Jmin1=%d,Jmax1=%d,deltaJ=%d,kmax=%d,Istride=%lld,Kstride=%lld,stride=%lld,firstindex=%lld\n",
		 rmap->id,nanomap->id,orientation,rev,IMIN,IMAX,Jmin1,Jmax1,deltaJ,A->kmax,A->Istride,A->Kstride,stride,firstindex);
	  fflush(stdout);
	}

	mcnt = 0;

#define BLOCK(field) { \
	  A->field##_base = &Imem[mcnt - firstindex];	\
	  mcnt += stride;				\
	  if(0&& RA_MIN_TIME){/* touch all memory that will be used so it is reflected in VmRss as soon as possible : HERE HERE see pairalign.cpp for a better way */ \
	    /* memset(&A->field##_base[firstindex], 0, sizeof(int) * (1LL + (CACHE ? A->KMAX : A->kmax)) * A->Kstride); */ \
	    /* memset_int(&A->field##_base[firstindex], 0, (1LL + (CACHE ? A->KMAX : A->kmax)) * A->Kstride); */ \
	    for(int I = IMIN; I <= IMAX; I++)     			\
	      for(int K = 0; K <= Kmax[I]; K++)   			\
	    	memset(&A->field(I,K,JMIN[I]), 0, sizeof(int)*(JMAX[I]-JMIN[I]+1)); \
	  }                                             \
	}
	BLOCK(G);
	BLOCK(T);
	BLOCK(H);
	BLOCK(Lij);
	BLOCK(Rij);
	BLOCK(Lijx);
	BLOCK(Rijx);
	if(RepeatRec || MultiMatchesFilter >= 2)
	  BLOCK(shift);
	if(RepeatRec){
	  BLOCK(rG);
	  BLOCK(rT);
	  BLOCK(rH);
	}
	if(MultiMatches){
	  BLOCK(IL);
	  BLOCK(KL);
	  BLOCK(JL);
	  BLOCK(R);
	}
#undef BLOCK

	//	if(DEBUG) assert(mcnt <= min(stride, pcnt * (maxM + 2*FENCE)) * DPsizI);
	if(DEBUG) assert(mcnt <= stride * DPsizI);

        if(DEBUG>=2){/* set all score,Uscore = nan("NaN") and all other fields to ival */
	  for(long long t = DPsizF * stride; --t >= 0;)
	    Fmem[t] = aNaN;
	  for(long long t = DPsizI * stride; --t >= 0;)
	    Imem[t] = ival;
	  //	  memset_int(Imem, ival, stride * DPsizI);
	}
	
	if(VERB>=3 && RA_MIN_TIME){/* display time and VmRSS */
	  long long rVmSize,rVmRSS,rVmSwap,rVmHWM;// local copies, so global shared values are not modified
	  getmem(rVmSize,rVmRSS,rVmSwap,&rVmHWM);

	  printf("tid=%d:refid=%lld,mapid=%lld,or=%d,rev=%d: touched memory: VmRSS= %0.4f(HWM=%0.2f),VmSwap= %0.4f Gb:wt= %0.6f\n",
		 tid, rmap->id,nanomap->id,orientation,rev,rVmRSS*1e-9,rVmHWM*1e-9,rVmSwap*1e-9,wtime());
	  fflush(stdout);
	}
      }
    }

    if(PVERB>=2){
      #pragma omp critical
      {
	size_t cnt = 0;
	if(DEBUG) assert(1 <= IMIN && IMAX <= N);
	for(int I = IMIN; I <= IMAX; I++)
	  cnt += JMAX[I]-JMIN[I]+1;
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:offset=%0.3f,offsetSD=%0.3f,IMIN=%d,IMAX=%d,N=%d,M=%d,cnt=%llu/%llu/%llu,Kstride=%lld,kmax=%d\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,offset,offsetSD,IMIN,IMAX,N,M,(unsigned long long)cnt,
	       (unsigned long long)(IMAX-IMIN+1)*M,(unsigned long long)N*M,A->Kstride,A->kmax);
	if(PVERB>=3){
	  for(int I = IMIN; I <= IMAX; I++){
	    if(Jmax1 - Jmin1 + 1 < M)
	      printf("I=%d:JMIN[I]= %d, JMAX[I]= %d (allocated J range = %d .. %d)\n",I,JMIN[I],JMAX[I], Jmin1+(I-IMIN), Jmax1+(I-IMIN));
	    else
	      printf("I=%d:JMIN[I]= %d, JMAX[I]= %d (allocated J range = %d .. %d)\n",I,JMIN[I],JMAX[I], Jmin1, Jmax1);
	  }
	}
	fflush(stdout);
      }
    }
  } else {// no hashtable information used
    for(int I = IMIN; I <= IMAX; I++){
      JMIN[I] = jmin;
      JMAX[I] = jmax;
    }
  }

  if(DEBUG && DIAGONAL>=2) assert(A->Istride <= (jmax-jmin+1) + 2*FENCE);

  if(DEBUG>=2){
    for(int I = IMIN; I <= IMAX; I++){
      if(!(1 <= JMIN[I] && JMIN[I] <= JMAX[I] && JMAX[I] <= M)){
	#pragma omp critical
	{
	  printf("refid=%d,mapid=%d(id=%lld),or=%d:IMIN=%d,IMAX=%d:I=%d,JMIN[I]=%d,JMAX[I]=%d,N=%d,M=%d\n",
		 refid,mapid,nanomap->id,orientation,IMIN,IMAX,I,JMIN[I],JMAX[I],N,M);
	  fflush(stdout);
	  assert(1 <= JMIN[I] && JMIN[I] <= JMAX[I] && JMAX[I] <= M);
	}
      }
    }
  }

  /* compute Imin[],Imax[] from IMIN,IMAX,JMIN[],JMAX[] : same code as at end of setlimit() */
  for(int J = 1; J <= M; J++){
    Imin[J] = N+1;
    Imax[J] = 0;
  }
  for(int I = IMIN; I <= IMAX; I++){
    for(int J = JMIN[I]; J <= JMAX[I]; J++){
      Imin[J] = min(Imin[J],I);
      Imax[J] = max(Imax[J],I);
    }
  }
  if(DEBUG>=2)
    for(register int J = 1; J <= M; J++)
      for(register int I = Imin[J]; I <= Imax[J]; I++)
	assert(JMIN[I] <= J && J <= JMAX[I]);

  if(DEBUG>=2 && !phash){
    for(int I = IMIN; I <= IMAX; I++){
      assert(JMIN[I] == 1);
      assert(JMAX[I] == M);
    }    
    for(int J = 1; J <= M; J++){
      assert(Imin[J] == IMIN);
      assert(Imax[J] == IMAX);
    }
  }

  if(PVERB>=2){
    #pragma omp critical
    {
      printf("refalignXYsd(): refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:IMIN=%d,IMAX=%d,N=%d,M=%d\n",
	     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,IMIN,IMAX,N,M);
      fflush(stdout);
    }
  }

  if(DEBUG>=2 && PVERB>=2 && IMIN <= I_TRACE && I_TRACE <= IMAX && JMIN[I_TRACE] <= J_TRACE && J_TRACE <= JMAX[I_TRACE]){
    #pragma omp critical
    {
      printf("0: refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:A->score(I=%d,K=%d,J=%d)=%0.6f\n",refid,rmap->id,mapid,nanomap->id,orientation,rev,I_TRACE,K_TRACE,J_TRACE,A->score(I_TRACE,K_TRACE,J_TRACE));
      fflush(stdout);
    }
  }

  RFLOAT *biasend_values, *biasend2_values;
  if(M > MAX_ALLOCA){
    biasend_values = new RFLOAT[(M+1)*2];// HERE HERE : move this memory to end of Fmem+Imem memory block
    biasend2_values = &biasend_values[M+1];
  } else {
    biasend_values = (RFLOAT *)alloca((M+1)*sizeof(RFLOAT));
    biasend2_values = (RFLOAT *)alloca(sizeof(RFLOAT)*(M+1));
  }
  
  for(int J= 1; J <= M; J++)
    biasend_values[J] = BiasEnd2(X[J],J);

  /* initialize A->score[I= IMIN..IMAX][K=0..Kmax[I]][J=JMIN[I]..JMAX[I]] : scored as EndOutlier (ChimScore) + Sm + Bias*/
  /* Also Rij,Lij,G (and if MultiMatches : IL,KL,JL etc) */
  for(int I = IMIN; I <= IMAX; I++){
    if(DEBUG>=2) assert(Kmax[I] >= 0 && Kmax[I] <= I-1 && Kmax[I] <= KMAX);
    for(int K = 0; K <= Kmax[I]; K++){
      RFLOAT score = ChimScore + PRtabY[K][I].Sm;
      RFLOAT *AscoreIK = &A->score(I,K,0);
      int *ARijxIK = &A->Rijx(I,K,0);
      int *ALijxIK = &A->Lijx(I,K,0);
      int jmin = JMIN[I], jmax = JMAX[I];
      if(DEBUG>=2) assert(JMIN[I] <= JMAX[I]);
      if(DEBUG>=2 && !phash) assert(JMIN[I]==1 && JMAX[I]==M);

#pragma ivdep
#pragma simd
      for(int J= jmin; J <= jmax; J++){
	AscoreIK[J] = (NEW>=2) ? biasend_values[J] + score : score;
	if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));
      }
#pragma simd
      for(int J = jmin; J <= jmax; J++){
	ARijxIK[J] = J;
	ALijxIK[J] = J;
      }

      memset_int(&A->G(I,K,jmin), localtype, jmax-jmin+1);
      memset_int(&A->Lij(I,K,jmin), I-K, jmax-jmin+1);
      memset_int(&A->Rij(I,K,jmin), I, jmax-jmin+1);
      if(RepeatRec || MultiMatchesFilter >= 2)
	memset_int(&A->shift(I,K,jmin), 0, jmax-jmin+1);

      if(MultiMatches){
	int *AJLxIK = &A->JL(I,K,0);

	for(int J = jmin; J <= jmax; J++)
	  AJLxIK[J] = J;

	memset_int(&A->IL(I,K,jmin), I, jmax-jmin+1);
	memset_int(&A->KL(I,K,jmin), K, jmax-jmin+1);
      }
    }
  }
  
  if(extend){
    /* initialize A->Lijx[I=IMIN..IMAX][K=0..Kmax[I]][J=JMIN[I]..JMAX[I]] as leftmost site in X that overlaps Y with Y[I-K .. I] aligned with X[J] */
    /* only cases where I-K <= DELTA_Y OR J <= DELTA_X are initialized (all other cases can be assumed to use Lijx = 0) */
    int I = IMIN;
    for(; I <= IMAX; I++){
      int Lijx = 0;
      for(int K= 0; K <= Kmax[I]; K++){
	Lijx = 0;
	int Jmax = (I-K <= DELTA_Y) ? JMAX[I] : min(DELTA_X, JMAX[I]);
	FLOAT y = Yc(Y,I,K);
	for(int J= JMIN[I]; J <= Jmax; J++){ /* update Lijx by incrementing it until X[Lijx] overlaps Y */
	  while(X[J]-X[Lijx] > y)
	    Lijx++;
	  if(DEBUG>=2 && !(Lijx <= J && !(X[J]-X[Lijx] > y) && (Lijx==0 || X[J]-X[Lijx-1] > y))){
	    printf("refid=%d,mapid=%d:I=%d,K=%d,J=%d,M=%d,N=%d:Lijx=%d,X[J]=%0.8f,X[Lijx]=%0.8f,y=%0.8f,X[max(0,Lijx-1)]=%0.8f\n",
		   refid,mapid,I,K,J,M,N,Lijx,X[J],X[Lijx],y,X[max(0,Lijx-1)]);
	    fflush(stdout);
	    assert(Lijx <= J && !(X[J]-X[Lijx] > y) && (Lijx==0 || X[J]-X[Lijx-1] > y));
	  }
	  A->Lijx(I,K,J) = Lijx;
	}
      }
      if(Lijx==0 && (!DIAGONAL || JMAX[I] >= (I-Kmax[I] <= DELTA_Y ? M : DELTA_X)))
	break;
    }
    I++;
    for(; I <= IMAX; I++){
      for(int K= 0; K <= Kmax[I]; K++){
	int Jmax = (I-K <= DELTA_Y) ? JMAX[I] : min(DELTA_X,JMAX[I]);
	if(Jmax >= JMIN[I])
	  memset_int(&A->Lijx(I,K,JMIN[I]),0,Jmax-JMIN[I]+1);
      }
    }
  }

  if(PVERB>=2 && IMIN <= I_TRACE && I_TRACE <= IMAX && JMIN[I_TRACE] <= J_TRACE && J_TRACE <= JMAX[I_TRACE]){
    #pragma omp critical
    {
      printf("1: refid=%d(%lld),mapid=%d(%lld),or=%d:A->score(I=%d,K=%d,J=%d)=%0.6f\n",refid,rmap->id,mapid,nanomap->id,orientation,I_TRACE,K_TRACE,J_TRACE,A->score(I_TRACE,K_TRACE,J_TRACE));
      fflush(stdout);
    }
  }

  /* initialize A->Lij[I=Imin[J]..Imax[J]][K=0..Kmax[I]][J=1..M] as leftmost site in Y that overlaps X with Y[I-K .. I] aligned with X[J] */
  /* update A->score[I=1..N][K=0..Kmax[I]][J=1..M] with left ends unaligned (but NOT endoutlier) and Y[I-K .. I] aligned with X[J] (along with G) */
  /* only cases where J <= DELTA_X (OR extend && I-K <= DELTA_Y) are initialized */
  if(extend){/* this is the commonly used case */
    int J = 1;
    for(; J <= M; J++){
      int ImKmax = (J <= DELTA_X) ? Imax[J] : min(DELTA_Y, Imax[J]);
      int ImKmin = max(1, Imin[J] - KMAX);
      int maxLij = 0, Lij;
      
      if(1){ // NEW440 : speed up by initializating Lij for I = max(1,Imin[J]-KMAX), K==0, by decrementing from I, since Lij value will typically be close to I
	Lij = ImKmin;
	FLOAT y = Yc(Y,Lij,0);
	while(Lij > 0 && y - X[J] <= Y[Lij-1])
	  Lij--;
      } else
	Lij = 0;

      for(int ImK = ImKmin; ImK <= ImKmax; ImK++){
	int Lijk = Lij;
	int I;
	for(int K = max(0, Imin[J] - ImK); (I = ImK + K) <= Imax[J] && K <= Kmax[I]; K++){
	  if(DEBUG>=2) assert(I >= Imin[J]);
	  FLOAT y = Yc(Y,I,K);
	  RFLOAT score;
	  RFLOAT *AscoreIKJ = &A->score(I,K,J);

	  /* update Lijk by incrementing it until Y[Lijk] overlaps X */
	  while(y - X[J] > Y[Lijk])
	    Lijk++;
	  if(DEBUG>=2 && !(Lijk <= I && !(y - X[J] > Y[Lijk]) && (Lijk <= 0 || y - X[J] > Y[Lijk-1]))){
            #pragma omp critical
	    {
	      printf("refid=%d,mapid=%d(%lld),or=%d:J=%d,ImK=%d,K=%d,I=%d:Lij=%d,Lijk=%d,y=%0.6f,Y[Lijk]=%0.6f,y-Y[Lijk]=%0.6f,X[J]=%0.6f\n",
		     refid,mapid,nanomap->id,orientation,J,ImK,K,I,Lij,Lijk,y,Y[Lijk],y-Y[Lijk],X[J]);
	      if(Lijk!= 0)
		printf("    Y[Lijk-1]=%0.6f,y-Y[Lijk-1]=%0.6f\n",Y[Lijk-1],y-Y[Lijk-1]);
	      fflush(stdout);
	      assert(Lijk <= I && !(y - X[J] > Y[Lijk]) && (Lijk <= 0 || y - X[J] > Y[Lijk-1]));
	    }
	  }
	  int Lijky = A->Lij(I,K,J) = min(Lijk, I - K);
	  if(K==0)
	    Lij = Lijk;
	  maxLij = max(maxLij, Lijk);

	  int Lijkx = A->Lijx(I,K,J);
	  RFLOAT Smjik = PRtabY[K][I].Sm /* Sm(J,I,K,Y)*/;
	  if((score = Send(min(X[J],y),J+1-max(1,Lijkx),I-K+1-max(1,Lijky),I-K,refid,0) + Smjik) > AscoreIKJ[0]){
	    if(PVERB>=2 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
	      int n = I-K+1-max(1,Lijky);
	      printf("   A->score(I=%d,K=%d,J=%d)=%0.6f -> %0.6f, Send=%0.6f(x= %0.4f,y= %0.4f,m= %d,n= %d), Sm= %0.6f, Lijx=%d,Lij=%d,G=%d -> -1 (Y[%d] - Y[%d] = %0.4f, Y[%d]= %0.4f)\n",
		     I,K,J,A->score(I,K,J),score, Send(min(X[J],y),J+1-max(1,Lijkx),n,I-K,refid,0), X[J],y,J+1-max(1,Lijkx),n, Smjik, Lijkx, Lijky,A->G(I,K,J), Lij,max(0,Lij-n),Y[Lij] - Y[max(0,Lij-n)], Lij, Y[Lij]);
	      fflush(stdout);
	    }
	    AscoreIKJ[0] = score;
	    if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));

	    A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */
	  } else if(PVERB>=3 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
	    printf("   A->score(I=%d,K=%d,J=%d)=%0.6f, Send=%0.6f(x= %0.4f,y= %0.4f,m= %d,n= %d), Sm= %0.6f (sum=%0.6f), Lijx=%d,Lij=%d\n",
		   I,K,J,A->score(I,K,J), Send(min(X[J],y),J+1-max(1,Lijkx),I-K+1-max(1,Lijky),I-K,refid,0), X[J],y,J+1-max(1,Lijkx),I-K+1-max(1,Lijky), Smjik, score, Lijkx, Lijky);
	    fflush(stdout);
	  }

	  if(ENDFIX && Lijkx <= 0){
	    for(int U= Lijky; U < I-K; U++){
	      RFLOAT bound = Sbnd(X[J],y-Y[U],J,I-K-U,I-K,refid) + Smjik;
	      if(bound > AscoreIKJ[0]){
		if(PVERB>=2 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
		  printf("   A->score(I=%d,K=%d,J=%d)=%0.6f -> %0.6f, Sbnd=%0.6f(x= %0.4f,y= %0.4f,m= %d,n= %d), Sm= %0.6f, U=%d,Lijx=%d,Lij=%d -> %d, G=%d -> -1\n",
			 I,K,J,A->score(I,K,J),bound, Sbnd(X[J],y-Y[U],J,I-K-U,I-K,refid), X[J],y-Y[U],J,I-K-U, Smjik, U, Lijkx,Lijky, U+1, A->G(I,K,J));
		  fflush(stdout);
		}
		AscoreIKJ[0] = bound;
		if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));
		A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */	      
		A->Lij(I,K,J) = U+1;/* NOTE : dont update Lijk, since it is being used by next p's Lij estimate */
		if(!ENDFIX2)
		  continue;
	      }
	      if(!ENDFIX2)
		break;
	    }
	  }
	  if(ENDFIX && Lijk <= 0){
	    for(int U= Lijkx; U < J; U++){
	      RFLOAT bound = Sbnd(X[J]-X[U],y,J-U,I-K,I-K,refid) + Smjik;
	      if(bound > AscoreIKJ[0]){
		AscoreIKJ[0] = bound;
		if(PVERB>=2 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
		  printf("   A->score(I=%d,K=%d,J=%d)=%0.6f -> %0.6f, Sbnd= %0.6f(x= %0.4f,y= %0.4f,m= %d,n= %d), Sm= %0.6f,U=%d,Lij=%d,Lijx=%d -> %d\n",
			 I,K,J,A->score(I,K,J),bound,Sbnd(X[J]-X[U],y,J-U,I-K,I-K,refid),X[J]-X[U],y,J-U,I-K,Smjik,U,Lijk,Lijkx,U+1);
		  fflush(stdout);
		}
		if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));
		A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */
		Lijkx = U+1;
		if(!ENDFIX2)
		  continue;
	      }
	      if(!ENDFIX2)
		break;
	    }
	    A->Lijx(I,K,J) = Lijkx;
	  }

	  if(ISLINEAR && isLinear){/* try to align left ends of X and Y */
	    RFLOAT Lend = Sint((RFLOAT)X[J],y,J,I-K,J,I,K,0,PRtabY,Y)/* includes Sm(J,I,K,Y)*/;
	    if(Lend > AscoreIKJ[0]){
	      AscoreIKJ[0] = Lend;
	      if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));
	      A->G(I,K,J) = A->H(I,K,J) = A->T(I,K,J) = 0;
	    }
	  }
	} /* K loop */
      } /* ImK loop */
      if(maxLij <= 0 && (!DIAGONAL || Imax[J] >= (J <= DELTA_X ? N : DELTA_Y))){
	if(!DIAGONAL || J <= DELTA_X || Imax[J] >= DELTA_Y + KMAX)
	  break;/* all subsequent Lij values will be 0 */

	int ImK = DELTA_Y, K = 1;
	for(; K <= KMAX; K++){
	  int I = ImK + K;
	  if(I > N || K > Kmax[I])
	    break;
	}
	K--;
	if(Imax[J] >= DELTA_Y + K){
	  if(DEBUG>=2 && Imin[J] <= DELTA_Y + K){
	    double y = Yc(Y,DELTA_Y+K,K);
	    if(!(y < X[J])){
	      #pragma omp critical
	      {
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:J=%d,ImKmax=%d,Imax[J]=%d,maxLij=%d,DELTA_Y=%d,K=%d,Yc(Y,DELTA_Y+K,K)=%0.6f,X[J]=%0.6f\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,J,ImKmax,Imax[J],maxLij,DELTA_Y,K,y,X[J]);
		fflush(stdout);
		assert(y < X[J]);
	      }
	    }
	  }
	  break;/* all subsequent Lij values will be 0, since all subsequent J values (and hence Imax[J]) will be larger, but the largest I value is DELTA_Y + K */
	}
      }
    }/* J loop */

    if(PVERB>=2 && IMIN <= I_TRACE && I_TRACE <= IMAX && JMIN[I_TRACE] <= J_TRACE && J_TRACE <= JMAX[I_TRACE]){
      printf("4: refid=%d(%lld),mapid=%d(%lld),or=%d:A->score(I=%d,K=%d,J=%d)=%0.6f\n",refid,rmap->id,mapid,nanomap->id,orientation,I_TRACE,K_TRACE,J_TRACE,A->score(I_TRACE,K_TRACE,J_TRACE));
      fflush(stdout);
    }

    for(J++; J <= M; J++){/* all Lij values will be 0  */
      int ImKmax = (J <= DELTA_X) ? Imax[J] : min(DELTA_Y,Imax[J]);

      for(int ImK = max(1,Imin[J]-KMAX); ImK <= ImKmax; ImK++){
	int I;
	for(int K = max(0,Imin[J]-ImK); (I=ImK+K) <= Imax[J] && K <= Kmax[I]; K++){
	  if(DEBUG>=2) assert(I >= Imin[J]);
	  FLOAT y = Yc(Y,I,K);

	  A->Lij(I,K,J) = 0;

	  int Lijkx = A->Lijx(I,K,J);
	  if(DEBUG>=2 && !(Lijkx > 0)){
	    #pragma omp critical
	    {
	      printf("refid=%d,mapid=%d(%lld),or=%d:I=%d,K=%d,J=%d:A->Lijx(I,K,J)=%d:Yc(Y,I,K)=%0.8f,X[J]=%0.8f\n",refid,mapid,nanomap->id,orientation,I,K,J,A->Lijx(I,K,J),y,X[J]);
	      fflush(stdout);
	      assert(Lijkx > 0);
	    }
	  }
	  RFLOAT Smjik = PRtabY[K][I].Sm /* Sm(J,I,K,Y)*/;
	  RFLOAT score = Send(min(X[J],y),J+1-Lijkx,I-K,I-K,refid,0) + Smjik;
	  if(PVERB>=2 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
	    if(score > A->score(I,K,J))
	      printf("   A->score(I=%d,K=%d,J=%d)=%0.6f -> %0.6f, Send=%0.6f(x= %0.4f,y= %0.4f,m= %d,n= %d), Sm= %0.6f, Lijx=%d,Lij=0,G=%d -> -1\n",
		     I,K,J,A->score(I,K,J),score, Send(min(X[J],y),J+1-Lijkx,I-K,I-K,refid,0), X[J],y,J+1-Lijkx,I-K, Smjik, Lijkx, A->G(I,K,J));
	    else
	      printf("   A->score(I=%d,K=%d,J=%d)=%0.6f, Send=%0.6f(x= %0.4f,y= %0.4f,m= %d,n= %d), Sm= %0.6f (sum= %0.6f), Lijx=%d,Lij=0,G=%d\n",
		     I,K,J,A->score(I,K,J), Send(min(X[J],y),J+1-Lijkx,I-K,I-K,refid,0), X[J],y,J+1-Lijkx,I-K, Smjik, score, Lijkx, A->G(I,K,J));
	    fflush(stdout);
	  }
	  if(ENDFIX){
	    for(int U= Lijkx; U < J; U++){
	      RFLOAT bound = Sbnd(X[J]-X[U],y,J-U,I-K,I-K,refid) + Smjik;
	      if(bound > score){
		if(PVERB>=2 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
		  if(bound > A->score(I,K,J))
		    printf("   A->score(I=%d,K=%d,J=%d)=%0.6f -> %0.6f, Sbnd= %0.6f(x= %0.4f,y= %0.4f,m= %d,n= %d), Sm= %0.6f,U=%d,Lij=%d,Lijx=%d -> %d,G=%d -> -1\n",
			   I,K,J,A->score(I,K,J),bound,Sbnd(X[J]-X[U],y,J-U,I-K,I-K,refid),X[J]-X[U],y,J-U,I-K,Smjik,U,0,Lijkx,U+1,A->G(I,K,J));
		  else
		    printf("   A->score(I=%d,K=%d,J=%d)=%0.6f, Sbnd= %0.6f(x= %0.4f,y= %0.4f,m= %d,n= %d), Sm= %0.6f,U=%d,Lij=%d,Lijx=%d -> %d,G=%d\n",
			   I,K,J,A->score(I,K,J),Sbnd(X[J]-X[U],y,J-U,I-K,I-K,refid),X[J]-X[U],y,J-U,I-K,Smjik,U,0,Lijkx,U+1,A->G(I,K,J));
		  fflush(stdout);
		}
		score = bound;
		Lijkx = U+1;
		if(!ENDFIX2)
		  continue;
	      }
	      if(!ENDFIX2)
		break;
	    }
	    A->Lijx(I,K,J) = Lijkx;
	  }
	  if(score > A->score(I,K,J)){
	    if(PVERB>=2 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
	      printf("5: A->score(I=%d,K=%d,J=%d)=%0.6f -> %0.6f,G=%d -> -1\n",I,K,J,A->score(I,K,J),score,A->G(I,K,J));
	      fflush(stdout);
	    }
	    A->score(I,K,J) = score;
	    if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));
	    A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */
	  }

	  if(ISLINEAR && isLinear){/* try to align left ends of X and Y */
	    RFLOAT Lend = Sint((RFLOAT)X[J],y,J,I-K,J,I,K,0,PRtabY,Y)/* includes Sm(J,I,K,Y)*/;
	    if(Lend > A->score(I,K,J)){
	      if(PVERB>=2 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
		printf("6: A->score(I=%d,K=%d,J=%d)=%0.6f -> %0.6f\n",I,K,J,A->score(I,K,J),Lend);
		fflush(stdout);
	      }
	      A->score(I,K,J) = Lend;
	      if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));
	      A->G(I,K,J) = A->H(I,K,J) = A->T(I,K,J) = 0;
	    }
	  }
	} /* K loop */
      } /* ImK loop */
    } /* J loop */
  } else {/* extend == 0 : no need to compute Lijx */
    int Jmax = min(M, DELTA_X);
    for(int J=1; J <= Jmax; J++){
      int Lij = 0;
      int ImKmax = Imax[J];
      if(TRACE && rmap->id==REF_TRACE && nanomap->id== MAP_TRACE && orientation==OR_TRACE && J==J_TRACE){
	printf("refid=%d,mapid=%d,or=%d:J=%d,Imin[J]=%d,Imax[J]=%d:ImK=%d..%d\n",refid,mapid,orientation,J,Imin[J],Imax[J],max(1,Imin[J]-KMAX),ImKmax);
	fflush(stdout);
      }
      for(int ImK = max(1,Imin[J]-KMAX); ImK <= ImKmax; ImK++){
	int Lijk = Lij;
	int I;
	for(int K = max(0,Imin[J] - ImK); (I = ImK + K) <= Imax[J] && K <= Kmax[I]; K++){
	  if(DEBUG>=2) assert(I >= Imin[J]);
	  FLOAT y = Yc(Y,I,K);
	  RFLOAT score;

	  /* update Lijk by incrementing it until Y[Lijk] overlaps X[J] */
	  while(y - Y[Lijk] > X[J])
	    Lijk++;
	  if(DEBUG>=2) assert(Lijk <= I && !(y-Y[Lijk] > X[J]) && (Lijk==0 || y-Y[Lijk-1] > X[J]));
	  A->Lij(I,K,J) = min(Lijk,I-K);
	  
	  if(PVERB && J==J_TRACE && I==I_TRACE && K==K_TRACE){
	    #pragma omp critical
	    {
	      printf("refid=%d,mapid=%d,or=%d:I=%d,K=%d,J=%d:Lijk=%d,X[J]=%0.4f,Yc(Y,I,K)=%0.4f,Y[Lijk]=%0.4f,Y[Lijk+1]=%0.4f\n",
		     refid,mapid,orientation,I,K,J,Lijk,X[J],Yc(Y,I,K),Y[Lijk],Y[Lijk+1]);
	      fflush(stdout);
	    }
	  }

	  if(K==0)
	    Lij = Lijk;

	  int Lijkx = 0;

	  if(Lijk > 0){
	    RFLOAT Smjik = PRtabY[K][I].Sm /* Sm(J,I,K,Y)*/;
	    if((score = Send(min(X[J],y),J+1-max(1,Lijkx),I-K+1-max(1,A->Lij(I,K,J)),I-K,refid,0) + Smjik) > A->score(I,K,J)){
	      if(PVERB>=2 && J==J_TRACE && I==I_TRACE && K==K_TRACE){
		#pragma omp critical
		{
		  printf("refid=%d,mapid=%d,or=%d:I=%d,K=%d,J=%d:Lij=%d,score=%0.6f -> %0.6f(Send=%0.6f,Sm=%0.6f,y=%0.4f,X[J]=%0.4f),G=%d -> -1\n",
			 refid,mapid,orientation,I,K,J,A->Lij(I,K,J),A->score(I,K,J),score,Send(min(X[J],y),J+1-max(1,Lijkx),I-K+1-max(1,A->Lij(I,K,J)),I-K,refid,0),Smjik,y,X[J],A->G(I,K,J));
		  fflush(stdout);
		}
	      }
	      A->score(I,K,J) = score;
	      if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));
	      A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */
	    }

	    if(ENDFIX && Lijkx <= 0){
	      for(int U= A->Lij(I,K,J);U < I-K; U++){
		RFLOAT bound = Sbnd(X[J],y-Y[U],J,I-K-U,I-K,refid) + Smjik;
		if(PVERB && J==J_TRACE && I==I_TRACE && K==K_TRACE){
		  #pragma omp critical
		  {
		    printf("refid=%d,mapid=%d,or=%d:I=%d,K=%d,J=%d,U=%d:Lij=%d,bound=%0.6f(Sbnd=%0.6f,Sm=%0.6f,y=%0.4f,Y[U]=%0.4f),score=%0.6f\n",
			   refid,mapid,orientation,I,K,J,U,A->Lij(I,K,J),bound,Sbnd(X[J],y-Y[U],J,I-K-U,I-K,refid),Smjik,y,Y[U],A->score(I,K,J));
		    if(U+1 < I-K)
		      printf("         U=%d:bound=%0.6f(Sbnd=%0.6f,Sm=%0.6f,y=%0.4f,Y[U]=%0.4f)\n",
			     U+1,Sbnd(X[J],y-Y[U+1],J,I-K-U-1,I-K,refid) + Smjik, Sbnd(X[J],y-Y[U+1],J,I-K-U-1,I-K,refid),Smjik,y,Y[U+1]);
		    fflush(stdout);
		  }
		}
		if(bound > A->score(I,K,J)){
		  A->score(I,K,J) = bound;
		  if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));
		  A->G(I,K,J) = -1;/* no further aligned sites, but no local alignment */	      
		  A->Lij(I,K,J) = U+1;/* NOTE : dont update Lijk, since it is being used by next p's Lij estimate */
		  if(!ENDFIX2)
		    continue;
		}
		if(!ENDFIX2)
		  break;
	      }
	    }
	    if(DEBUG>=2) assert(!(ENDFIX && Lijk <= 0));
	  } /* Lijk > 0 */
	  if(ISLINEAR && isLinear){/* try to align left ends of X and Y */
	    RFLOAT Lend = Sint((RFLOAT)X[J],y,J,I-K,J,I,K,0,PRtabY,Y)/* includes Sm(J,I,K,Y)*/;
	    if(Lend > A->score(I,K,J)){
	      A->score(I,K,J) = Lend;
	      if(DEBUG>=2) assert(isfinite(A->score(I,K,J)));
	      A->G(I,K,J) = A->H(I,K,J) = A->T(I,K,J) = 0;
	    }
	  }
	}
      }
    }
  }/* extend == 0 */

  if(PVERB>=2 && IMIN <= I_TRACE && I_TRACE <= IMAX && JMIN[I_TRACE] <= J_TRACE && J_TRACE <= JMAX[I_TRACE]){
    printf("7: refid=%d(%lld),mapid=%d(%lld),or=%d:A->score(I=%d,K=%d,J=%d)=%0.6f,G=%d\n",refid,rmap->id,mapid,nanomap->id,orientation,I_TRACE,K_TRACE,J_TRACE,A->score(I_TRACE,K_TRACE,J_TRACE),A->G(I_TRACE,K_TRACE,J_TRACE));
    fflush(stdout);
  }

  /* initialize A->Rij(I= Imin[J]..Imax[J], K=0..Kmax[I], J= M+1-DELTA_X to M) as rightmost site/end in Y that overlaps X when
     Y[I-K..I] is aligned with X[J] */
  /* only cases where J >= M+1-DELTA_X (OR extend && I >= N+1-DELTA_Y) are initialized */
  int Jmin = (!extend && M >= DELTA_X) ? M+1-DELTA_X : 1;
  for(int J= Jmin; J <= M; J++){
    int imin = (J >= M+1-DELTA_X) ? Imin[J] : max(Imin[J], N+1-DELTA_Y);
    int Rij;
    if(1){// NEW440 : initialize Rij by incrementing from Imax[J] with K=0
      Rij = Imax[J];
      FLOAT y = Yc(Y,Rij,0);
      while(Rij <= N && Y[Rij+1] <= X[M+1]-X[J]+y)
	Rij++;
    } else
      Rij = N+1;

    for(int I= Imax[J]; I >= imin; I--){
      int Rijk = Rij;
      int *ARijI0J = &A->Rij(I,0,J);
      long long Kstride = A->Kstride;

      for(int K= 0; K <= Kmax[I]; K++){
	FLOAT y = Yc(Y,I,K);
	/* update Rijk by decrementing it until Y[Rijk] overlaps X[J..M+1] */
	while(Y[Rijk] > X[M+1]-X[J]+y)
	  Rijk--;
	if(DEBUG>=2 && !(Rijk >= I-K && !(Y[Rijk] > X[M+1]-X[J]+y + 1e-10) && (Rijk > N || Y[Rijk+1] +1e-10 > X[M+1]-X[J]+y))){
	  #pragma omp critical
	  {
	    printf("refid=%d(%lld),mapid=%d(%lld),or=%d:N=%d,M=%d,J=%d,I=%d(%d..%d),K=%d:y=%0.10f,Rijk=%d,X[M+1]-X[J]+y=%0.10f,Y[Rijk]=%0.10f,Y[Rijk+1]=%0.10f(delta=%0.6e,%d)\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,N,M,J,I,Imax[J],imin,K,y,Rijk,X[M+1]-X[J]+y,Y[Rijk],Y[min(N,Rijk)+1],Y[min(N,Rijk)+1] - (X[M+1]-X[J]+y),(Y[min(N,Rijk)+1] > X[M+1]-X[J]+y) ? 1 : 0);
	    fflush(stdout);
	    assert(Rijk >= I-K && !(Y[Rijk] > X[M+1]-X[J]+y + 1e-10) && (Rijk > N || Y[Rijk+1] + 1e-10 > X[M+1]-X[J]+y));
	  }
	}
	*ARijI0J = max(Rijk,I);
	ARijI0J += Kstride;
	if(K==0)
	  Rij = Rijk;
      }
    }
  }

  if(extend){
    /* initialize A->Rijx(I= IMIN..IMAX, K=0..Kmax[I], J= JMIN[I] to JMAX[I]) as rightmost site in X that overlaps Y when
       Y[I-K .. I] is aligned with X[J] */
    /* only cases where I >= N+1-DELTA_Y OR J >= M+1-DELTA_X are initialized (all other cases can be assumed to use Rijx == M+1) */
    for(int I= IMIN; I <= IMAX; I++){
      for(int K= 0; K <= Kmax[I]; K++){
	FLOAT y = Y[N+1] - Yc(Y,I,K);
	if(DEBUG>=2) assert(y >= 0.0);
	int Rijkx = M+1;
	int Jmin = (I >= N+1 - DELTA_Y) ? JMIN[I] : max(JMIN[I],M+1 - DELTA_X);
	for(int J= JMAX[I]; J >= Jmin; J--){
	  /* update Rijkx by decrementing it until X[Rijkx] overlaps Y */
	  while(X[Rijkx] > y+X[J]){
	    Rijkx--;
	    if(DEBUG>=2) assert(Rijkx >= 0);
	  }
	  if(DEBUG>=2) assert(Rijkx >= J && !(X[Rijkx] > y+X[J]) && (Rijkx > M || X[Rijkx+1] > y+X[J]));
	  A->Rijx(I,K,J) = Rijkx;
	}
      }
    }
  }

  RFLOAT maxUscore = -1e30;// for debugging

  if((DEFER_BP && !outlierExtend) || RepeatRec || MultiMatches){
    for(int I = IMIN; I <= IMAX; I++){
      int jmin = JMIN[I];
      int jmax = JMAX[I];
      size_t len = (jmax-jmin+1)*sizeof(A->score(I,0,1));

      for(int K = 0; K <= Kmax[I]; K++)
	memcpy(&A->Uscore(I,K,jmin), &A->score(I,K,jmin), len);
    }
    if(DEBUG>=2){
      maxUscore = -1e30;
      for(int I = IMIN; I <= IMAX; I++){
	int jmin = JMIN[I];
	int jmax = JMAX[I];
	for(int K = 0; K <= Kmax[I]; K++){
	  for(int J = jmin; J <= jmax; J++){
	    RFLOAT score = A->Uscore(I,K,J);
	    assert(isfinite(score));
	    maxUscore = max(score,maxUscore);
	  }
	}
      }
      if(PVERB>=2){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:max Uscore= %0.6f\n",refid,rmap->id,mapid,nanomap->id,orientation,rev,maxUscore);
	fflush(stdout);
      }
    }
  }

  // recheck VmRSS as in pairalign.cpp
  if(MEMCHECK && DIAGONAL>=2 && phash && hashdelta && RA_MIN_TIME && MaxMemSiz > 0 && MIN_MEM < 8 && retries < MEMCHECK && VmRSS + VmSwap > MaxMemSiz * RA_MAX_MEM){
    double wt = wtime();

    #pragma omp critical(vmemTotsiz)
    {
      if(wt - lastGetmem > VMRSS_CHECK2){
	getmem(VmSize,VmRSS,VmSwap,&VmHWM);
	lastGetmem = wt;
      }
    }

    if(VmRSS + VmSwap > MaxMemSiz){
      retries++;
      FmemBT[tid] += wt - wt2;

      if(VERB){
        #pragma omp critical(vmemTotsiz)	
	{
	  if(memcheck_printed < retries){
	    printf("tid=%d: MaxMemSiz= %0.1f (Lim=%0.2f), vmemTotsiz= %0.2f Gb, VmRSS= %0.2f(HWM=%0.2f), VmSwap= %0.2f Gb: After %0.2f seconds:retries=%d for vMem=%0.4f,Mem=%0.4f Gb memory (rid=%lld,mid=%lld,N=%d,M=%d),Paused Threads=%d/%d:wall=%0.6f\n",
		 tid, MaxMemSiz*1e-9, MaxMemSiz*1e-9*RA_MAX_MEM, vmemTotsiz*1e-9, VmRSS*1e-9, VmHWM*1e-9, VmSwap*1e-9, wt-wt2, retries,
		 nMemSiz*1e-9, realratio * nMemSiz*1e-9, rmap->id,nanomap->id,N,M,PausedThreads,NumThreads,wt);
	    fflush(stdout);
          }
	  memcheck_printed = retries;
	}
      }
      goto LwaitForMemory;
    }
  }

  if(PVERB>=2){
    long long rVmSize,rVmRSS,rVmSwap,rVmHWM;// local copies, so global shared values are not modified
    getmem(rVmSize,rVmRSS,rVmSwap,&rVmHWM);
    printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:IMIN=%d,IMAX=%d: Before 3-D recurrance: VmSize= %0.3f, VmRSS= %0.3f, VmSwap= %0.3f, VmHWM= %0.3f Gb (tid=%d)\n",
	   refid,rmap->id, mapid, nanomap->id, orientation,rev,scaleID,IMIN,IMAX, rVmSize*1e-9, rVmRSS*1e-9, rVmSwap*1e-9, rVmHWM*1e-9, tid);
    fflush(stdout);
  }

  /* Dynamic programming 3D recurrance */

#if USE_MIC
  if(USE_MIC && DEFER_BP && !EXTENDONLY && DELTA_X==4 /* && DELTA_Y==6 */ && !outlierExtend && !outlierBC){ /* original vectorized code written by Vladimir */
    refalign_3Drecurrance(Y,N,X,M,IMIN,IMAX,JMIN,JMAX,Kmax,A,refid,mapid,orientation,scaleID,rev,rmap,nanomap,YPenR,XPen,PRtabY,tid,numthreads);
  } else
#endif
  {/* general case :  Newer vectorized code in refalign_3Drecurrance.cpp is simpler and faster for AVX256 */
    if(maptype == 0)
      refalign_3Drecurrance<0>(Y,N,X,M,IMIN,IMAX,JMIN,JMAX,Kmax,A,refid,mapid,orientation,scaleID,rev,rmap,nanomap,YPenR,XPen,PRtabY,tid,numthreads);
    else
      refalign_3Drecurrance<1>(Y,N,X,M,IMIN,IMAX,JMIN,JMAX,Kmax,A,refid,mapid,orientation,scaleID,rev,rmap,nanomap,YPenR,XPen,PRtabY,tid,numthreads);
  }

  int nummatchgroup = 0, numprefiltered = 0, cntmatchgroup = 0;

  /* locate best alignment result */
  /* only check results where J >= M+1-DELTA_X OR (extend && I >= N+1-DELTA_Y) except for local alignment (PoutlierEnd > 0) */
  RFLOAT bestscore = MINSCORE, bestscore2 = MINSCORE;
  int bestI = -1, bestK = 0, bestJ = -1, bestR = -2;/* bestR = right end alignment type */
  FLOAT bestYik= 0.0;
  int bestIL = -1;/* only used with MultiMatch to record alignments truncated on the left end at I == bestIL (if bestIL >= 0) */

  for(int J=1; J<=M ; J++)
    biasend2_values[J] =  ChimScore + ((NEW>=2) ? BiasEnd2(X[M+1]-X[J],M+1-J) : (RFLOAT)0.0f);
  
  if(PVERB >= 2){
    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:bestscore=%0.8e,bestI=%d,bestJ=%d,bestK=%d,bestR=%d\n",refid,rmap->id,mapid,nanomap->id,orientation,bestscore,bestI,bestK,bestJ,bestR);
    fflush(stdout);
  }

  for(int I=IMIN; I <= IMAX; I++){
    RFLOAT bscore = MINSCORE;
    int bK = 0, bJ = -1, bR = -1;
    FLOAT bYik = -1e30;
    int jmax = JMAX[I];

    for(int K = 0; K <= Kmax[I]; K++){
      FLOAT Yik = Yc(Y,I,K);

      if(PoutlierEnd > 0.0){/* consider right end local alignments */
	RFLOAT *AscoreIK = &A->score(I,K,0);
	RFLOAT newscore = bscore;
	if(MultiMatches){
	  RFLOAT *ATscoreIK = &A->Tscore(I,K,0);
	  int *ARIK = &A->R(I,K,0);
	  for(int J = JMIN[I]; J <= jmax; J++){
	    if(DEBUG>=2) assert(isfinite(AscoreIK[J]));
	    RFLOAT nscore = AscoreIK[J] + biasend2_values[J];
	    if(PVERB>=2 && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d,R=%d,G=%d,T=%d,H=%d:A->score(I,K,J)=%0.6f,biasend2_values[J]=%0.6f,A->Tscore(I,K,J) -> %0.6f,M=%d,N=%d,newscore=%0.6f,bscore=%0.6f\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,I,K,J,localtype,A->G(I,K,J),A->T(I,K,J),A->H(I,K,J),A->score(I,K,J),biasend2_values[J],nscore,M,N,newscore,bscore);
	      fflush(stdout);
	    }
	    ATscoreIK[J] = nscore;
	    ARIK[J] = localtype;
	    newscore = max(newscore, nscore);
	  }
	} else {
	  for(int J = JMIN[I]; J <= jmax; J++){
	    if(DEBUG>=2) assert(isfinite(AscoreIK[J]));
	    newscore = max(newscore, AscoreIK[J] + biasend2_values[J]);
	  }
	}

	if(newscore > bscore){
	  if(PVERB>=2 && MultiMatches && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d..%d,R=%d:newscore=%0.6f,bscore=%0.6f\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,I,K,JMIN[I],jmax,localtype,newscore,bscore);
	    fflush(stdout);
	  }
	  // NOTE : due to rounding, score >= newscore may fail for all J, even if newscore > bscore
	  for(int J = JMIN[I]; J <= jmax; J++){
	    RFLOAT score = AscoreIK[J] + biasend2_values[J];
	    if(PVERB>=3 && I==16 && K==0){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d:A->score(I,K,J)=%0.6f,biasend2_values[J]=%0.6f,score= %0.6f,newscore=%0.6f,bscore=%0.6f\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,I,K,J,AscoreIK[J],biasend2_values[J],score,newscore,bscore);
	      fflush(stdout);
	    }
	    if(score > bscore){
	      if(PVERB>=2 && MultiMatches && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){// NEW7
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d,R=%d,G=%d,T=%d,H=%d:A->score(I,K,J)=%0.6f,biasend2_values[J]=%0.6f,newscore=%0.6f,bscore=%0.6f -> %0.6f, A->Tscore(I,K,J)= %0.6f\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,I,K,J,localtype,A->G(I,K,J),A->T(I,K,J),A->H(I,K,J),AscoreIK[J],biasend2_values[J],newscore,bscore,score, A->Tscore(I,K,J));
		fflush(stdout);
	      }
	      bscore = score;
	      bK = K;
	      bJ = J;
	      bR = localtype;/* local alignment (-2) OR EndOutlier (-3) */
	      bYik = Yik;
	      // if(score >= newscore) break;
	    }
	  }
	}
      } else if(MultiMatches){/* initialize all A->Tscore(I,K,*) to MINSCORE if PoutlierEnd == 0.0 */
	RFLOAT *ATscoreIK = &A->Tscore(I,K,0);
	int *ARIK = &A->R(I,K,0);
	for(int J = JMIN[I]; J <= jmax; J++){
	  ATscoreIK[J] = MINSCORE;
	  ARIK[J] = localtype;
	}
      }

      FLOAT y = Y[N+1] - Yik;
      int *ARijIK = &A->Rij(I,K,0);
      int *ARijxIK = &A->Rijx(I,K,0);
      int Jmin = (extend && I >= N+1-DELTA_Y) ? JMIN[I] : max(JMIN[I],M+1-DELTA_X);
      //      int Jmax = JMAX[I];
      for(int J= Jmin ; J <= jmax; J++){
	if(extend || ARijIK[J] <= N){
	  int Rijx = (extend ? ARijxIK[J] : M+1);
	  if(DEBUG>=2) assert(Rijx >= J && Rijx <= M+1);
	  RFLOAT score = Send(min(X[M+1]-X[J],y),min(M,Rijx)+1-J,min(N,ARijIK[J])+1-I,min(N,ARijIK[J]),refid,0);
	  if(PVERB>=2 && I_TRACE>=0 && I==I_TRACE && K==K_TRACE && J==J_TRACE && (!MultiMatches || A->score(I,K,J) + score > A->Tscore(I,K,J))){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d:A->score(I,K,J)=%0.6f,Send()=%0.6f(x=%0.4f,m=%d,n=%d),Rij=%d,Rijx=%d,Tscore(I,K,J) -> %0.6f,M=%d,N=%d\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,I,K,J,A->score(I,K,J),score,min(X[M+1]-X[J],y),min(M,Rijx)+1-J,min(N,ARijIK[J])+1-I,ARijIK[J],Rijx,A->score(I,K,J)+score,M,N);
	    fflush(stdout);
	  }
	  if(DEBUG>=2)assert(isfinite(score));
	  int linear = -1;/* end type : -1 = normal, 0 = chr end, -2 = local, -3 = outlier */
	  if(ENDFIX && Rijx > M){
	    int Rij = ARijIK[J];
	    for(int U = Rij; U > I; U--){
	      RFLOAT bound = Sbnd(X[M+1]-X[J],Y[U]-Yik,M+1-J,U-I,U-1,refid);
	      if(DEBUG>=2)assert(isfinite(bound));
	      if(bound > score){
		score = bound;
		if(PVERB>=2 && MultiMatches && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE && A->score(I,K,J) + score > A->Tscore(I,K,J)){
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d:A->score(I,K,J)=%0.6f,U=%d,Sbnd()=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),Rij=%d->%d,Rijx=%d,Tscore(I,K,J) -> %0.6f,M=%d,N=%d\n",
			 refid,rmap->id,mapid,nanomap->id,orientation,I,K,J,A->score(I,K,J),U,score,X[M+1]-X[J],Y[U]-Yik,M+1-J,U-I,Rij,U-1,Rijx,A->score(I,K,J)+score,M,N);
		  fflush(stdout);
		}
		Rij = U-1;
		if(!ENDFIX2)
		  continue;
	      }
	      if(!ENDFIX2)
		break;
	    }
	    ARijIK[J] = Rij;
	  }
	  if(ENDFIX && ARijIK[J] > N && N+1-I <= DELTA_YEND){/* only possible if extend==1 */
	    if(DEBUG>=2) assert(extend);
	    for(int U = Rijx;U > J;U--){
	      RFLOAT bound = Sbnd(X[U]-X[J],y,U-J,N+1-I,N-I,refid);
	      if(DEBUG>=2)assert(isfinite(bound));
	      if(bound > score){
		score = bound;
		if(PVERB>=2 && MultiMatches && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE && A->score(I,K,J) + score > A->Tscore(I,K,J)){
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d:A->score(I,K,J)=%0.6f,U=%d,Sbnd()=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),Rijx=%d->%d,Tscore(I,K,J) -> %0.6f,M=%d,N=%d\n",
			 refid,rmap->id,mapid,nanomap->id,orientation,I,K,J,A->score(I,K,J),U,score,X[U]-X[J],y,U-J,N+1-I,Rijx,U-1,A->score(I,K,J)+score,M,N);
		  fflush(stdout);
		}
		Rijx = U-1;
		if(!ENDFIX2)
		  continue;
	      }
	      if(!ENDFIX2)
		break;
	    }
	    if(DEBUG>=2) assert(Rijx >= J && Rijx <= M+1);
	    ARijxIK[J] = Rijx;
	  }
	  if(ISLINEAR && isLinear){/* try to align right ends of X and Y */
	    RFLOAT Rend = Sint(X[M+1]-X[J],y,M+1-J,N+1-I,J,N+1,0,K,PRtabY,Y);// - PRtabY[K][I].Sm;
	    if(Rend > score){
	      score = Rend;
	      linear = 0;
	    }
	  }
	  RFLOAT pscore = A->score(I,K,J);
	  if(DEBUG>=2 && !isfinite(pscore)){
	    #pragma omp critical
	    {
	      printf("refid=%lld,mapid=%lld,orientation=%d:N=%d,M=%d:I=%d,K=%d,J=%d,JMIN[I]=%d,JMAX[I]=%d:Rijx(I,K,J)=%d,Rij(I,K,J)=%d,A->score(I,K,J)=%0.8e,score=%0.8e\n",
		     rmap->id,nanomap->id,orientation,N,M,I,K,J,JMIN[I],JMAX[I],A->Rijx(I,K,J),A->Rij(I,K,J),A->score(I,K,J),score);
	      fflush(stdout);
	      assert(isfinite(pscore));
	    }
	  }
	  score += pscore;
	  if(MultiMatches && score > A->Tscore(I,K,J)){
	    if(PVERB>=2 && MultiMatches && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d:A->score(I,K,J)=%0.6f,Tscore(I,K,J) -> %0.6f,M=%d,N=%d\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,I,K,J,A->score(I,K,J),score,M,N);
	      fflush(stdout);
	    }
	    A->Tscore(I,K,J) = score;
	    A->R(I,K,J) = linear;
	  }
	  if(score > bscore){
	    if(DEBUG>=2){
	      assert(I-K >= 1 && I >= IMIN && I <= IMAX);
	      assert(J >= JMIN[I] && J <= JMAX[I]);
	    }
	    if(PVERB>=3){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:bscore=%0.6f -> %0.6f: I= %d,K= %d, J= %d, R= %d\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,bscore,score,I,K,J,linear);
	      fflush(stdout);
	    }
	    bscore = score;
	    bK = K;
	    bJ = J;
	    bR = linear;
	    bYik = Yik;
	  }
	}
      }
    }

    /* alignment may be trying to wrap around (X[bJ] >= Y[I-bK..I]) */
    if(DEBUG && bJ >= 1) assert(bYik == Yc(Y,I,bK));

    if(bscore > bestscore + 1e-8){
      bestscore = bscore;
      bestI = I;
      bestJ = bJ;
      bestK = bK;
      bestR = bR;
      bestYik = bYik;
      if(PVERB>=3 && MultiMatches){
	RFLOAT bestExtend = (bestJ < 0) ? 1e10 : max(X[bestJ] - bestYik,X[M+1]-X[bestJ] - (Y[N+1]-bestYik));
	RFLOAT bExtend = max(X[bJ] - bYik, X[M+1]-X[bJ] - (Y[N+1]-bYik));
	printf("refid=%d,mapid=%d,orientation=%d:bestI=I=%d,N=%d,bestJ=bJ=%d,M=%d,bestK=bK=%d:bscore=%0.8e,extend=%0.3f,bestR=bR=%d,Y[I]=%0.3f,X[bJ]=%0.3f(bestscore=%0.8e,Extend=%0.3f,Y[bestI]=%0.3f,X[bestJ]=%0.3f),X[M+1]=%0.3f,Y[N+1]=%0.3f, Tscore(bestI,bestK,bestJ)= %0.6f\n",
	       refid,mapid,orientation,I,N,bJ,M,bK,bscore,bExtend,bR,bYik,X[bJ],bestscore,bestExtend,Y[bestI],X[bestJ],X[M+1],Y[N+1], A->Tscore(bestI,bestK,bestJ));
	fflush(stdout);
      }
      if(DEBUG) assert(isfinite(bscore));
      if(DEBUG){
	assert(bestI >= IMIN && bestI-bestK >= 1 && bestI <= IMAX);
	if(DEBUG && !(1 <= JMIN[bestI] && JMIN[bestI] <= bestJ && bestJ <= JMAX[bestI] && JMAX[bestI] <= M)){
	  RFLOAT bestExtend = (bestJ < 0) ? 1e10 : max(X[bestJ] - bestYik,X[M+1]-X[bestJ] - (Y[N+1]-bestYik));
	  RFLOAT bExtend = max(X[bJ] - bYik, X[M+1]-X[bJ] - (Y[N+1]-bYik));
	  printf("mapid=%d,orientation=%d:N=%d,M=%d:I=%d,bJ=%d,bK=%d:bscore=%0.8e,extend=%0.3f,bR=%d,Y[I]=%0.3f,X[bJ]=%0.3f(bestscore=%0.8e,Extend=%0.3f,bestI=%d,bestJ=%d,Y[bestI]=%0.3f,X[bestJ]=%0.3f),X[M+1]=%0.3f,Y[N+1]=%0.3f\n",
		 mapid,orientation,N,M,I,bJ,bK,bscore,bExtend,bR,bYik,X[bJ],bestscore,bestExtend,bestI,bestJ,Y[bestI],X[bestJ],X[M+1],Y[N+1]);
	  printf("bestJ=%d,JMIN[I]=%d,JMAX[I]=%d\n",bestJ,JMIN[I],JMAX[I]);
	  fflush(stdout);
	  assert(1 <= JMIN[bestI] && JMIN[bestI] <= bestJ && bestJ <= JMAX[bestI] && JMAX[bestI] <= M);
	}
	assert(bestR <= -2 || bestJ >= M+1 - DELTA_X || (extend && bestI >= N+1-DELTA_Y));
      }
    }
  }

  int bestLI = -1, bestLK = 0, bestLJ = -1, bestL = -2;
  int bestLI2 = -1, bestLK2 = 0, bestLJ2 = -1, bestL2 = -2;

  if(DEFER_BP && !outlierExtend && bestI >= 0){/* compute G,T,H values along best alignment path */
    if(DELTA_X == 4 && !outlierBC){/* special optimized case */
      int I = bestI;
      int K = bestK;
      int J = bestJ;

#define VAR_BLOCK(m)				\
      RFLOAT *deltaX##m = XPen->deltaX[m];	\
      RFLOAT *Pen##m = XPen->Pen[m];		\
      RFLOAT *Bias##m = XPen->Bias[m];  	\
      RFLOAT *PenBias##m = XPen->PenBias[m];
    
      VAR_BLOCK(1);
      VAR_BLOCK(2);
      VAR_BLOCK(3);
      VAR_BLOCK(4);
#undef VAR_BLOCK

      while(I >= 0){
	/* update G, T, H by repeating recurrance computation */
	RFLOAT score = A->Uscore(I,K,J);
	if(DEBUG>=2) assert(isfinite(score));
	if(DEBUG>=2) assert(score <= maxUscore);
      
	int bestG = A->G(I,K,J);
	int bestH = A->H(I,K,J);
	int bestT = A->T(I,K,J);
	int Gmin = max(IMIN,I-K-DELTA_Y);
      
	if(maptype) {

	  for(int G= I-K; --G >= Gmin;){
	    int Hmin = max(JMIN[G],J-DELTA_X);
	    int Hmax = min(JMAX[G],J-1);
	    for(int T = Kmax[G]; T >= 0; T--){
	      if(DEBUG>=2) assert(G-T >= 1);
	      RFLOAT deltaY,Ivar,GaussY,Sm;
	      RFLOAT penY = SintY(I-K-G,I,K,T,deltaY,Ivar,GaussY,Sm,YPenR);
	      RFLOAT *AscoreGT = &A->score(G,T,0);

	      // Unroll the iterations of H : Assumes DELTA_X == 4
#define   BLOCK(m) {							\
		int H=J-m;						\
		if(H>=Hmin && (!DIAGONAL || H<=Hmax)) {			\
		  if(DEBUG>=2) assert(H >= JMIN[G]);                    \
		  if(DEBUG>=2) assert(H <= JMAX[G]);                    \
		  RFLOAT newscore = AscoreGT[H] + SintX_maptype1(deltaX##m[J],deltaY,penY,GaussY,Sm,Ivar,Pen##m[J],Bias##m[J],PenBias##m[J]); \
		  if(newscore > score){					\
		    if(VERB>=3 && refid==0 && mapid==414 && !orientation && I==472 && K==0 && J==162) \
		      printf("refid=%d,mapid=%d,or=%d:I=%d,K=%d,J=%d,N=%d,M=%d:G=%d,T=%d,H=%d:A->score(G,T,H)=%0.8f,SintX()=%0.8f,newscore=%0.8f\n", \
			     refid,mapid,orientation,I,K,J,N,M,G,T,H,A->score(G,T,H), \
			     SintX_maptype1(deltaX##m[J],deltaY,penY,GaussY,Sm,Ivar, Pen##m[J], Bias##m[J], PenBias##m[J]),newscore); \
		    score = newscore;					\
		    bestG = G;						\
		    bestH = H;						\
		    bestT = T;						\
		  }							\
		}							\
	      }
	
	      BLOCK(4);
	      BLOCK(3);
	      BLOCK(2);
	      BLOCK(1);
#undef BLOCK
	    }
	  }
	} else {/* maptype==0 */
	  for(int G= I-K; --G >= Gmin;){
	    int Hmin = max(JMIN[G],J-DELTA_X);
	    int Hmax = min(JMAX[G],J-1);
	    for(int T = Kmax[G]; T >= 0; T--){
	      if(DEBUG>=2) assert(G-T >= 1);
	      RFLOAT deltaY,Ivar,GaussY,Sm;
	      RFLOAT penY = SintY(I-K-G,I,K,T,deltaY,Ivar,GaussY,Sm,YPenR);
	      RFLOAT *AscoreGT = &A->score(G,T,0);

	      // Unroll the 4 iterations of H : Assumes DELTA_X == 4
#define   BLOCK(m) {							\
		int H=J-m;						\
		if(H>=Hmin && (!DIAGONAL || H<=Hmax)) {			\
		  if(DEBUG>=2) assert(H >= JMIN[G]); \
		  if(DEBUG>=2) assert(H <= JMAX[G]); \
		  RFLOAT newscore = AscoreGT[H] + SintX_maptype0(deltaX##m[J],deltaY,penY,GaussY,Sm,Ivar,Pen##m[J],Bias##m[J],PenBias##m[J], 0); \
		  if(PVERB && I== I_TRACE && K== K_TRACE && J== J_TRACE && newscore > score){ \
		    /* RFLOAT err = deltaX##m[J] - deltaY; */		\
	            RFLOAT SintX = SintX_maptype0(deltaX##m[J],deltaY,penY,GaussY,Sm,Ivar, Pen##m[J], Bias##m[J], PenBias##m[J], 1); \
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d:I=%d,K=%d,J=%d,N=%d,M=%d:G=%d,T=%d,H=%d:A->score(G,T,H)=%0.8f,deltaX=%0.4f,deltaY=%0.4f,penY=%0.6f,Sm=%0.6f,Ivar=%0.8f,GaussY=%0.6f,SintX()=%0.8f\n\t OutlierPenalty=%0.6f,Xbias=%0.6f,XPen=%0.6f,OutlierLambdaInv=%0.8f,newscore=%0.8f,score=%0.8f(G=%d,T=%d,H=%d)\n", \
			   refid,rmap->id,mapid,nanomap->id,orientation,I,K,J,N,M,G,T,H,A->score(G,T,H), deltaX##m[J],deltaY, penY,Sm,Ivar,GaussY, \
			   SintX,OutlierPenalty,Bias##m[J],Pen##m[J], OutlierLambdaInv, newscore,score,bestG,bestT,bestH); \
		    fflush(stdout);\
		  } \
		  if(newscore > score){					\
		    score = newscore;					\
		    bestG = G;						\
		    bestH = H;						\
		    bestT = T;						\
		  }							\
		}							\
	      }
	
	      BLOCK(4);
	      BLOCK(3);
	      BLOCK(2);
	      BLOCK(1);
#undef BLOCK
	    }
	  }
	}/* maptype == 0 */

	if(DEBUG>=2 && !(score < -10.0 || fabs(A->score(I,K,J) - score) < (USE_RFLOAT ? 1e-4 : 1e-8))){
          #pragma omp critical
	  {
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:M=%d,N=%d:I=%d,K=%d,J=%d:A->score(I,K,J)=%0.8f,score=%0.8f,G=%d,T=%d,H=%d,Gmin=%d,maptype=%d,A->Uscore(I,K,J)=%0.8f\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,M,N,I,K,J,A->score(I,K,J),score, bestG, bestT, bestH,Gmin,maptype,A->Uscore(I,K,J));
	    fflush(stdout);
	    assert(score < -10.0 || fabs(A->score(I,K,J) - score) < (USE_RFLOAT ? 1e-4 : 1e-8));
	  }
	}
	A->G(I,K,J) = bestG;
	A->H(I,K,J) = bestH;
	A->T(I,K,J) = bestT;
	I = bestG;
	K = bestT;
	J = bestH;
      }
    } else {/* general case DELTA_X != 4 */
      int I = bestI;
      int K = bestK;
      int J = bestJ;

      while(I >= 0){
	/* update G, T, H by repeating recurrance computation */
	RFLOAT score = A->Uscore(I,K,J);
	if(DEBUG>=2) assert(isfinite(score));
	if(DEBUG>=2) assert(score <= maxUscore);
      
	int bestG = A->G(I,K,J);
	int bestH = A->H(I,K,J);
	int bestT = A->T(I,K,J);
	int Gmin = max(IMIN,I-K-DELTA_Y);
      
	if(maptype) {
	  for(int G= I-K; --G >= Gmin;){
	    int Hmin = max(JMIN[G],J-DELTA_X);
	    int Hmax = min(JMAX[G],J-1);
	    for(int T = Kmax[G]; T >= 0; T--){
	      if(DEBUG>=2) assert(G-T >= 1);
	      RFLOAT deltaY,Ivar,GaussY,Sm;
	      RFLOAT penY = SintY(I-K-G,I,K,T,deltaY,Ivar,GaussY,Sm,YPenR);
	      RFLOAT OutPenBC = OutlierPenaltyBC[I-K-G];
	      RFLOAT *AscoreGT = &A->score(G,T,0);

	      for(int H = Hmax; H >= Hmin; H--){
		if(DEBUG>=2) assert(H >= JMIN[G]);
		if(DEBUG>=2) assert(H <= JMAX[G]);
		int m = J-H;
		RFLOAT deltaX = XPen->deltaX[m][J];
		//		RFLOAT newscore = AscoreGT[H] + SintX_maptype1(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J],0);
		RFLOAT newscore = AscoreGT[H] + SintX(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J], OutPenBC + OutlierPenaltyBC[m]);
		if(newscore > score){
		  score = newscore;
		  bestG = G;
		  bestH = H;
		  bestT = T;
		}
	      }
	    }
	  }
	} else {/* maptype==0 */
	  for(int G= I-K; --G >= Gmin;){
	    int Hmin = max(JMIN[G],J-DELTA_X);
	    int Hmax = min(JMAX[G],J-1);
	    for(int T = Kmax[G]; T >= 0; T--){
	      if(DEBUG>=2) assert(G-T >= 1);
	      RFLOAT deltaY,Ivar,GaussY,Sm;
	      RFLOAT penY = SintY(I-K-G,I,K,T,deltaY,Ivar,GaussY,Sm,YPenR);
	      RFLOAT OutPenBC = OutlierPenaltyBC[I-K-G];
	      RFLOAT *AscoreGT = &A->score(G,T,0);

	      for(int H = Hmax; H >= Hmin; H--){/* remaining iterations if DELTA_X > 4 */
		if(DEBUG>=2) assert(H >= JMIN[G]);
		if(DEBUG>=2) assert(H <= JMAX[G]);
		int m = J-H;
		RFLOAT deltaX = XPen->deltaX[m][J];
		//		RFLOAT newscore = AscoreGT[H] + SintX_maptype0(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J],0);
		RFLOAT newscore = AscoreGT[H] + SintX(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J], OutPenBC + OutlierPenaltyBC[m]);
		if(newscore > score){
		  score = newscore;
		  bestG = G;
		  bestH = H;
		  bestT = T;
		}
	      }
	    }
	  }
	}/* maptype == 0 */

	if(DEBUG>=2) assert(score < -10.0 || fabs(A->score(I,K,J) - score) < (USE_RFLOAT ? 1e-4 : 1e-8));
	A->G(I,K,J) = bestG;
	A->H(I,K,J) = bestH;
	A->T(I,K,J) = bestT;
	if(bestG < 0){
	  bestLI = I;
	  bestLK = K;
	  bestLJ = J;
	  bestL = bestG;
	}
	I = bestG;
	K = bestT;
	J = bestH;
      }
    }
  }

  if(bestI < 0){/* no valid alignment found */
    if(VERB >= 2-PVERB && IMIN < IMAX){
      #pragma omp critical
      {
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,scaleID=%d:bestscore=%0.4f(I=%d,K=%d,J=%d,R=%d),align:score=%0.6f,or=%d,rev=%d,scaleID=%d: no valid alignment(IMIN=%d,IMAX=%d,N=%d)!\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,align->score,align->orientation,align->rev,align->scaleID,IMIN,IMAX,N);
	if(nanomap->align->mapid1>=0){
	  Calign_brief *palign = nanomap->align;
	  printf("    palign:orientation=%d,scaleID=%d,score=%0.4f,logPV=%0.4f,pairs=%d,mapid1=%d,mapid2=%d\n",
		 palign->orientation,palign->scaleID,palign->score,palign->logPV,palign->numpairs,palign->mapid1,palign->mapid2);
	}
	fflush(stdout);
      }
    }

    if(DEBUG>=2){/* check that unused array elements are still NaN */
      if(DIAGONAL == 1){
	for(int I = 1; I <= N; I++){
	  for(int J = 1; J <= M; J++){
	    if(IMIN <= I && I <= IMAX && JMIN[I] <= J && J <= JMAX[I])
	      continue;
	    for(int K = 0; K <= Kmax[I]; K++){
	      assert(IsNan(A->score(I,K,J)));
	      assert(IsNan(A->Uscore(I,K,J)));
	      assert(A->Rijx(I,K,J)== ival);
	      assert(A->Lijx(I,K,J)== ival);
	      assert(A->Rij(I,K,J)== ival);
	      assert(A->Lij(I,K,J)== ival);
	      assert(A->H(I,K,J)== ival);
	      assert(A->T(I,K,J)== ival);
	      assert(A->G(I,K,J)== ival);
	    }
	  }
	}
      }
      if(DIAGONAL>=2 && !MIN_MEM){
	for(int I = IMIN; I <= IMAX; I++){
	  int jmin = (A->Istride < M+2*FENCE) ? Jmin1+(I-IMIN) : Jmin1;
	  int jmax = (A->Istride < M+2*FENCE) ? Jmax1+(I-IMIN) : Jmax1;
	  for(int J = jmin; J <= jmax; J++){
	    if(JMIN[I] <= J && J <= JMAX[I])
	      continue;
	    for(int K = 0; K <= Kmax[I]; K++){
		if(!IsNan(A->score(I,K,J))){
		#pragma omp critical
		{
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,scaleID=%d:I=%d,K=%d,J=%d,JMIN[I]=%d,JMAX[I]=%d:A->score(I,K,J)=%0.6f (expected NaN),maxN=%lld,maxM=%lld,Jmin1=%d,Jmax1=%d,A->Istride=%lld,FRENCE=%d\n",
			 refid,rmap->id,mapid,nanomap->id,orientation,scaleID,I,K,J,JMIN[I],JMAX[I],A->score(I,K,J),maxN,maxM,Jmin1,Jmax1,A->Istride,FENCE);
		  fflush(stdout);
		  assert(IsNan(A->score(I,K,J)));
		}
	      }
	      assert(IsNan(A->Uscore(I,K,J)));
	      assert(A->Rijx(I,K,J)== ival);
	      assert(A->Lijx(I,K,J)== ival);
	      assert(A->Rij(I,K,J)== ival);
	      assert(A->Lij(I,K,J)== ival);
	      assert(A->H(I,K,J)== ival);
	      assert(A->T(I,K,J)== ival);
	      assert(A->G(I,K,J)== ival);
	    }
	  }
	}
      }
    }

    if(M > MAX_ALLOCA)
      delete [] biasend_values;

    return;
  }

  if(hashdeltaAdjust > 0.0 && (hashdeltaLim <= 0.0 || hashdelta < hashdeltaLim) && bestscore > 0.0){
    double margin = hashdelta * max(Ylambda,Xlambda);/* how close did the alignment get to the hashdelta boundary (in kb) */
    //     double minmargin = max(hashdelta * 0.5, hashdeltaAdjust) * max(Ylambda,Xlambda);/* if margin drops below this value, hashdelta will be adjusted to raise margin back to this value or more */
    double minmargin = hashdeltaAdjust * max(Ylambda, Xlambda);

    if(PVERB>=2){
      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f(I=%d,K=%d,J=%d), checking for hashdelta margin\n",
	     refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ);
      fflush(stdout);
    }

    int I = bestI;
    int K = bestK;
    int J = bestJ;
    int Im = -1, Jm = -1, Km = -1;

    RFLOAT cumscore = 0.0;

    while(I >= 0){
      int jmin = JMIN[I];
      int jmax = JMAX[I];
      if(PVERB>=3){
        RFLOAT score = A->score(I,K,J);
	int G = A->G(I,K,J);
	if(G > 0){
	  int T = A->T(I,K,J);
	  int H = A->H(I,K,J);
	  RFLOAT x = X[J] - X[H];
	  RFLOAT y = Yc(Y,I,K) - Yc(Y,G,T);
	  
	  if(maptype){
	    RFLOAT Bias,Pen,Gauss,PenSm;
	    SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	    //	      FLOAT iscore = score - A->score(G,T,H); 
	    if(outlierExtend){// cannot use XPen which is only allocated for m <= DELTA_X
	      int n = I-K-G;
	      int m = J-H;
	      RFLOAT OutPen = OutlierPenalty;
	      if(outlierBC)
		OutPen += OutlierPenaltyBC[m] + OutlierPenaltyBC[n];
	      if(OUTLIER_LTYPE==0)
		OutPen -= (x+y) * OutlierLambdaInv;
	      else
		OutPen -= fabs(x-y) * OutlierLambdaInv;
	    
	      RFLOAT outscore = Bias + Pen + Gauss + PenSm;
#if 0 // OLD
	      RFLOAT iscore = (OUTLIER_TYPE1 == 0) ? OutlierBias + max(Bias + Pen + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
		OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
	      RFLOAT OutlierPen = (OUTLIER_TYPE1 == 0) ? OutlierBias + OutPen + Bias * biasWToutlier + PenSm :
		OutlierBias + Pen + Bias * biasWToutlierF + OutPen + PenSm;
#else // NEW
	      RFLOAT iscore = OutlierBias + max(Bias + Pen + Gauss, OutPen + Pen*OUTLIER_TYPE1 + Bias * biasWToutlierF) + PenSm;
	      RFLOAT OutlierPen = OutlierBias + Pen*OUTLIER_TYPE1 + Bias * biasWToutlierF + OutPen + PenSm;
#endif
	      int outlier = (iscore > outscore + (RFLOAT)0.01 || (outlierExtend && (H >= J || G >= I-K))) ? 1 : 0;
	      cumscore += iscore;

	      printf(" I=%d,K=%d,J=%d(%d..%d),G=%d,T=%d,H=%d,M=%d:y=%0.4f,x=%0.4f,outlier=%d:iscore=%0.6f(cum=%0.6f,score(I,K,J)=%0.6f,score(G,T,H)=%0.6f),outscore=%0.6f(Bias=%0.6f,Pen=%0.6f,Gauss=%0.6f,Sm=%0.6f),Outlier=%0.6f(OutPen=%0.6f)\n",
		  I,K,J,jmin,jmax,G,T,H,M,y,x,outlier,iscore,cumscore,score,A->score(G,T,H),outscore,Bias,Pen,Gauss,PenSm,OutlierPen,OutPen);
	    } else {
	      int n = I-K-G;
	      int m = J-H;
	      RFLOAT sint = Sint(x,y,m,n,J,I,K,T,Y);
	      RFLOAT yy,Ivar,GaussY,Sm;
	      RFLOAT PenY = SintY(n,I,K,T,yy,Ivar,GaussY,Sm,YPenR);
	      if(DEBUG>=2) assert(fabs(y - yy) < 1e-7);
	      if(DEBUG>=2) assert(fabs(x - XPen->deltaX[J-H][J]) < 1e-7);
	      RFLOAT sintX = SintX(x,y,PenY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J],OutlierPenaltyBC[m]+OutlierPenaltyBC[n]);
	      RFLOAT OutPen = OutlierPenalty;
	      if(outlierBC)
		OutPen += OutlierPenaltyBC[m] + OutlierPenaltyBC[n];
	      if(OUTLIER_LTYPE==0)
		OutPen -= (x+y) * OutlierLambdaInv;
	      else
		OutPen -= fabs(x-y) * OutlierLambdaInv;
	    
	      RFLOAT outscore = Bias + Pen + Gauss + PenSm;
#if 0 // OLD
	      RFLOAT iscore = (OUTLIER_TYPE1 == 0) ? OutlierBias + max(Bias + Pen + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
		OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
	      RFLOAT OutlierPen = (OUTLIER_TYPE1 == 0) ? OutlierBias + OutPen + Bias * biasWToutlier + PenSm :
		OutlierBias + Pen + Bias * biasWToutlierF + OutPen + PenSm;
#else // NEW
	      RFLOAT iscore = OutlierBias + max(Bias + Pen + Gauss, OutPen + Pen*OUTLIER_TYPE1 + Bias * biasWToutlierF) + PenSm;
	      RFLOAT OutlierPen = OutlierBias + Pen*OUTLIER_TYPE1 + Bias * biasWToutlierF + OutPen + PenSm;
#endif
	      int outlier = (iscore > outscore + (RFLOAT)0.01 || (outlierExtend && (H >= J || G >= I-K))) ? 1 : 0;
	      cumscore += iscore;
	    
	      printf(" I=%d,K=%d,J=%d(%d..%d),G=%d,T=%d,H=%d,M=%d:y=%0.4f,x=%0.4f,outlier=%d:iscore=%0.6f(cum=%0.6f,Sint=%0.6f,SintX=%0.6f,score(I,K,J)=%0.6f,score(G,T,H)=%0.6f),outscore=%0.6f(Bias=%0.6f,Pen=%0.6f,Gauss=%0.6e),Outlier=%0.6f(OutPen=%0.6f)\n",
		  I,K,J,jmin,jmax,G,T,H,M,y,x,outlier,iscore,cumscore,sint,sintX,score,A->score(G,T,H),outscore,Bias,Pen,Gauss,OutlierPen,OutPen);
	    }
	  } else if(OUTLIER_DELTA(x-y)){
	    RFLOAT Bias,Pen,Gauss, PenSm;
	    SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	    //	RFLOAT iscore = score - A->score(G,T,H); 
	    RFLOAT OutPen = OutlierPenalty;
	    if(outlierBC)
	      OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
	    OutPen -= fabs(x-y) * OutlierLambdaInv;
	
	    RFLOAT outscore = Bias + Pen + Gauss + PenSm;
#if 0 // OLD
	    RFLOAT iscore = (OUTLIER_TYPE==0) ? OutlierBias + max(Bias + Pen + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
	      OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
	    RFLOAT OutlierPen = (OUTLIER_TYPE==0) ? OutlierBias + OutPen + Bias * biasWToutlierF + PenSm :
	      OutlierBias + Pen + Bias * biasWToutlierF + OutPen + PenSm;
#else // NEW
	    RFLOAT iscore = OutlierBias + max(Bias + Pen + Gauss, OutPen + Pen*OUTLIER_TYPE + Bias * biasWToutlierF) + PenSm;
	    RFLOAT OutlierPen = OutlierBias + Pen*OUTLIER_TYPE + Bias * biasWToutlierF + OutPen + PenSm;
#endif
	    int outlier = (iscore > outscore + (RFLOAT)0.01 || (outlierExtend && (H >= J || G >= I-K))) ? 1 : 0;
	    cumscore += iscore;
	    
	    printf(" I=%d,K=%d,J=%d(%d..%d),G=%d,T=%d,H=%d,M=%d:y=%0.4f,x=%0.4f,outlier=%d:iscore=%0.6f(cum=%0.6f,score(I,K,J)=%0.6f,score(G,T,H)=%0.6f),outscore=%0.6f(Bias=%0.6f,Pen=%0.6f,Gauss=%0.6e),Outlier=%0.6f(OutPen=%0.6f)\n",
		   I,K,J,jmin,jmax,G,T,H,M,y,x,outlier,iscore,cumscore,score,A->score(G,T,H),outscore,Bias,Pen,Gauss,OutlierPen,OutPen);
	  } else {
	    RFLOAT Bias,Pen,Gauss, PenSm;
	    SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	    RFLOAT outscore = Bias + Pen + Gauss + PenSm;	
	    RFLOAT iscore = outscore;
	    int outlier = 0;
	    cumscore += iscore;

	    printf(" I=%d,K=%d,J=%d(%d..%d),G=%d,T=%d,H=%d,M=%d:y=%0.4f,x=%0.4f,outlier=%d:iscore=%0.6f(cum=%0.6f,score(I,K,J)=%0.6f,score(G,T,H)=%0.6f),outscore=%0.6f(Bias=%0.6f,Pen=%0.6f,Gauss=%0.6e)\n",
		   I,K,J,jmin,jmax,G,T,H,M,y,x,outlier,iscore,cumscore,score,A->score(G,T,H),outscore,Bias,Pen,Gauss);
	

	  }
        } else
	  printf(" I=%d,K=%d,J=%d(%d..%d),G=%d,M=%d:score=%0.6f:margin=%0.3f: new margins=%0.3f,%0.3f\n",I,K,J,jmin,jmax,G,M,score,margin,X[jmax]-X[J],X[J]-X[jmin]);
	fflush(stdout);
      }

      int G = A->G(I,K,J);
      int T = A->T(I,K,J);
      int H = A->H(I,K,J);

      if(!(I==bestI && K==bestK && J==bestJ && G < 0)){
	if(X[jmax] - X[J] < margin && jmax < M){
	  margin = X[jmax] - X[J];
	  if(TRACE){
	    Im = I;
	    Jm = J;
	    Km = K;
	  }
	}
	if(X[J] - X[jmin] < margin && jmin > 1){
	  margin = X[J] - X[jmin];
	  if(TRACE){
	    Im = I;
	    Jm = J;
	    Km = K;
	  }
	}
      }
      
      I = G;
      K = T;
      J = H;
    }

    if(margin < minmargin){
      //      int hashadjust = hashdeltaAdjust;
      double hashadjust = max(hashdeltaAdjust, (minmargin - margin) / max(Ylambda,Xlambda));
      if(hashdeltaLim > 0.0)
	hashadjust = min(hashadjust, hashdeltaLim - hashdelta);

      if(PVERB){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f(I=%d,K=%d,J=%d),margin=%0.3f kb (I=%d,K=%d,J=%d(%d..%d)), minmargin= %0.3f kb : increasing hashdelta = %0.1f -> %0.1f (multicnt=%d,hashdeltaLim=%0.1f)\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ,margin,Im,Km,Jm, Im > 0 ? JMIN[Im] : -1, Im > 0 ? JMAX[Im] : -1, minmargin,hashdelta,hashdelta+hashadjust, align->multicnt, hashdeltaLim);
	fflush(stdout);
      }
      
      if(M > MAX_ALLOCA)
	delete [] biasend_values;

      return refalignXYsd(Y,N,X,M,orientation,scaleID,Kmax,A,Fmem,Imem,StrideMax,KstrideMax,JMIN,JMAX,Imin,Imax,align,rmap,nanomap,refid,mapid,XPen,phash,tid,numthreads,maxmatchgroup,matchgroup, mheap, hashdelta + hashadjust,hashdeltaAdjust,ScoreThreshold2,LogPvThreshold2,AlignedSiteThreshold2,origIMIN,origIMAX,origjmin,origjmax,rev);
    } else if(PVERB){
      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:bestscore=%0.6f(I=%d,K=%d,J=%d),margin=%0.3f kb (I=%d,K=%d,J=%d(%d..%d)), minmargin= %0.3f kb : unchanged hashdelta = %0.1f (multicnt=%d)\n",
	     refid,rmap->id,mapid,nanomap->id,orientation,bestscore,bestI,bestK,bestJ,margin,Im,Km,Jm, Im > 0 ? JMIN[Im] : -1, Im > 0 ? JMAX[Im] : -1, minmargin,hashdelta, align->multicnt);
      fflush(stdout);
    }
  }

  int *Ilist, *Klist, *Jlist, *outlier;
  double *iscore, *outscore, *cumiscore;
  int *Ilist2, *Klist2, *Jlist2;
  double *iscore2, *outscore2;
  if(M > MAX_ALLOCA){
    Ilist = new int[M*7];// HERE HERE : move this memory to end of Fmem+Imem memory block
    Klist = &Ilist[M];
    Jlist = &Ilist[M*2];
    outlier = &Ilist[M*3];
    Ilist2 = &Ilist[M*4];
    Klist2 = &Ilist[M*5];
    Jlist2 = &Ilist[M*6];

    iscore = new double[(M+1)*5];// HERE HERE : move this memory to end of Fmem+Imem memory block
    outscore = &iscore[M+1];
    iscore2 = &iscore[(M+1)*2];
    outscore2 = &iscore[(M+1)*3];
    cumiscore = &iscore[(M+1)*4];

  } else {
    Ilist = (int *)alloca(M*sizeof(int));
    Klist = (int *)alloca(M*sizeof(int));
    Jlist = (int *)alloca(M*sizeof(int));
    outlier = (int *)alloca(M*sizeof(int));
    iscore = (double *)alloca((M+1)*sizeof(double));
    outscore = (double *)alloca((M+1)*sizeof(double));
    cumiscore = (double *)alloca((M+1)*sizeof(double));

    Ilist2 = (int *)alloca(M*sizeof(int));
    Klist2 = (int *)alloca(M*sizeof(int));
    Jlist2 = (int *)alloca(M*sizeof(int));
    iscore2 = (double *)alloca((M+1)*sizeof(double));
    outscore2 = (double *)alloca((M+1)*sizeof(double));
  }

  // New location of MultiMatches code after hashdeltaAdjust
  if(MultiMatches){/* save matchgroups with score >= ScoreThreshold2 and apply MULTIMATCHES_FILTER */
    int pjmin = jmin, pjmax = jmax;
    for(int I=IMIN; I <= IMAX; I++){
      int jmax = JMAX[I];
      int jmin = (PoutlierEnd > 0.0) ? JMIN[I] : (extend && I >= N+1-DELTA_Y) ? JMIN[I] : max(JMIN[I],M+1-DELTA_X);

      for(int K = 0; K <= Kmax[I]; K++){
	if(MULTIMATCHES_MINMEM && nummatchgroup + jmax - jmin >= maxmatchgroup){/* reallocate matchgroup[] */
	  int nmax = max(1024, (nummatchgroup + jmax - jmin + 1)*(MULTIMATCHES_MINMEM+1)/MULTIMATCHES_MINMEM);
	  if(PVERB>=2){
            #pragma omp critical
	    {
	      if(phash)
		printf("tid=%d:refid=%d,mapid=%d,or=%d,IMIN=%d,IMAX=%d,M=%d,offset=%d kb:increasing maxmatchgroup from %d to %d\n",tid,refid,mapid,orientation,IMIN,IMAX,M,phash->offset,maxmatchgroup,nmax);
	      else
		printf("tid=%d:refid=%d,mapid=%d,or=%d,IMIN=%d,IMAX=%d,M=%d:increasing maxmatchgroup from %d to %d\n",tid,refid,mapid,orientation,IMIN,IMAX,M,maxmatchgroup,nmax);
	      fflush(stdout);
	    }
	  }

          Cmatchgroup *nmatchgroup;
          if(MATCHGROUP_HEAP){
	    nmatchgroup = new Cmatchgroup[2*nmax];
	    delete [] mheap;
	    mheap = new Cmatchgroup*[nmax+1];
	  } else
	    nmatchgroup = new Cmatchgroup[nmax];
	  if(nummatchgroup > 0)
	    memcpy(nmatchgroup, matchgroup, nummatchgroup * sizeof(Cmatchgroup));
	  if(maxmatchgroup > 0)
	    delete [] matchgroup;
	  matchgroup = nmatchgroup;
	  maxmatchgroup = nmax;
	}

	Cmatchgroup *p = &matchgroup[nummatchgroup];
	Cmatchgroup *q = p;
	if(PVERB>=2 && I_TRACE > 0 && I==I_TRACE && K==K_TRACE){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:I=%d,K=%d: checking matchgroups with J=%d..%d\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,I,K,jmin,jmax);
	  fflush(stdout);
	}
	for(int J = jmin; J <= jmax; J++){
	  RFLOAT score = A->Tscore(I,K,J);
	  if(score < ScoreThreshold2 - 0.0001){
	    if(PVERB>=2 && I_TRACE > 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
	      printf("Filtered matchgroup due to -S2 %0.3f : refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:I=%d,K=%d,J=%d,Tscore=%0.6f,R=%d,IL=%d,KL=%d,JL=%d,Len= %0.4f\n",
		     ScoreThreshold2, refid,rmap->id,mapid,nanomap->id,orientation,rev,I,K,J,score,A->R(I,K,J),A->IL(I,K,J),A->KL(I,K,J),A->JL(I,K,J), Y[I] - Y[A->IL(I,K,J)]);
	      fflush(stdout);
	    }
	    continue;
	  }
	  if(DEBUG>=2) assert(nummatchgroup + (p-q) < maxmatchgroup);
	  p->IL = A->IL(I,K,J);
	  p->JL = A->JL(I,K,J);
	  if(DEBUG) assert(p->IL >= 0);// checking if IL can ever be < 0 : If not why is the code checking for p->IL < 0 later ??? Use p->IL == A->IL(I,K,J) instead
	  if(MULTIMATCHES_FILTER != 0.0){
	    numprefiltered++;
	    if(min(I - p->IL, J - p->JL) + 1 < AlignedSiteThreshold2 /* -A2 failed */
	       || Y[I] - Y[p->IL] < AlignedLengthThreshold2){ /* -L2 failed) */
	      if(PVERB>=2 && I_TRACE > 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
		printf("Filtered matchgroup due to -A2 %d -L2 %0.1f : refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:I=%d,K=%d,J=%d,Tscore=%0.6f,R=%d,IL=%d,KL=%d,JL=%d,Len= %0.4f\n",
		       AlignedSiteThreshold2, AlignedLengthThreshold2, refid,rmap->id,mapid,nanomap->id,orientation,rev,I,K,J,score,A->R(I,K,J),p->IL,A->KL(I,K,J),p->JL, Y[I] - Y[p->IL]);
		fflush(stdout);
	      }
	      continue;
	    }
	    if(1 /* PoutlierEnd > 0.0 */){
	      int G = A->G(I,K,J);
	      int T = A->T(I,K,J);
	      int H = A->H(I,K,J);
	      if(DEBUG>=2) assert(I > p->IL && G > 0);
	      if(DEBUG>=2) assert(isfinite(A->Tscore(G,T,H)));
	      if(score - A->Tscore(G,T,H) < -MULTIMATCHES_FILTER){
		if(PVERB>=2 && I_TRACE > 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
		  printf("Filtered matchgroup w/ poor right end interval: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:I=%d,K=%d,J=%d,Tscore=%0.6f,R=%d,IL=%d,KL=%d,JL=%d\n\tG=%d,T=%d,H=%d,A->Tscore(G,T,H)=%0.6f\n",
			 refid,rmap->id,mapid,nanomap->id,orientation,rev,I,K,J,score,A->R(I,K,J),p->IL,A->KL(I,K,J),p->JL,G,T,H,A->Tscore(G,T,H));
		  if(I_TRACE >= 0 && I== I_TRACE && K== K_TRACE && J== J_TRACE){
		    int U = -1, Lend = -1;
		    if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(pjmax-pjmin+1 == M);
		    double logPV = alignFPsd(A,I,J,K,Y,X,N,M,IMAX-IMIN+1,pjmax-pjmin+1,p->R,orientation,rev,scaleID, refid,mapid,0, 0/* verb */, U,Lend,p->IL,iscore,outscore,Ilist,Klist,Jlist,outlier);
		    printf("\t LogPV=%0.2f, iscore[0]= %0.6f, numpairs=%d\n",logPV,iscore[0],U);
		    for(int t = 0; t < U; t++){
		      int pI = Ilist[t];
		      int pK = Klist[t];
		      int pJ = Jlist[t];
		      RFLOAT pscore = A->score(pI,pK,pJ);
		      
		      if(t == U-1)
			printf("      %d:I=%d,T=%d,J=%d: score=%0.6f(Sm=%0.6f,iscore[%d]=%0.6f,Uscore=%0.6f)\n",U-1-t,pI,pK,pJ,pscore, Sm(0,pI,pK,Y), t+1,iscore[t+1], A->Uscore(pI,pK,pJ));
		      else {
			int pG = Ilist[t+1];
			int pT = Klist[t+1];
			int pH = Jlist[t+1];
			printf("      %d:I=%d,T=%d,J=%d (G=%d,T=%d,H=%d) score=%0.6f(Sm=%0.6f,iscore[%d]=%0.6f),y=%0.3f,x=%0.3f\n",U-1-t,pI,pK,pJ,pG,pT,pH,pscore, Sm(0,pI,pK,Y), t+1,iscore[t+1], Yc(Y,pI,pK)-Yc(Y,pG,pT), X[pJ]-X[pH]);
		      }
		    }
		  }
		  fflush(stdout);
		}
		continue;
	      }
	      if(G > p->IL){/* filter out based on last 2 intervals */
		int G2 = A->G(G,T,H);
		int T2 = A->T(G,T,H);
		int H2 = A->H(G,T,H);
		if(score - A->Tscore(G2,T2,H2) < (RefSplitStitch >= 2 ? biasend2_values[H2] : 0.0) - MULTIMATCHES_FILTER){

		  if(PVERB>=2 && I_TRACE > 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
		    printf("Filtered matchgroup w/ poor right end 2 intervals: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:I=%d,K=%d,J=%d,Tscore=%0.6f,R=%d,IL=%d,KL=%d,JL=%d\n\tG2=%d,T2=%d,H2=%d,A->Tscore(G2,T2,H2)=%0.6f\n",
			   refid,rmap->id,mapid,nanomap->id,orientation,rev,I,K,J,score,A->R(I,K,J),p->IL,A->KL(I,K,J),p->JL,G2,T2,H2,A->Tscore(G2,T2,H2));
		    fflush(stdout);
		  }
		  continue;
		}
	      }
	    }
	  }
	  p->I = I;
	  p->K = K;
	  p->J = J;
	  p->R = A->R(I,K,J);
	  p->KL = A->KL(I,K,J);
	  p->score = score;
	  if(PVERB>=2 && I_TRACE > 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
	    printf("matchgroup[%ld]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:I=%d,K=%d,J=%d,Tscore=%0.6f,R=%d,IL=%d,KL=%d,JL=%d\n",
              	p-matchgroup,refid,rmap->id,mapid,nanomap->id,orientation,rev,I,K,J,score,p->R,p->IL,p->KL,p->JL);
	    fflush(stdout);
	  }
	  p++;
	}
	nummatchgroup += p - q;
	if(DEBUG) assert(nummatchgroup <= maxmatchgroup);
      }
    }
    if(PVERB>=2){
      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:nummatchgroup=%d\n",refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,nummatchgroup);
      fflush(stdout);
    }
  }

  FLOAT MinSpacing = X[M+1] * SecondSpacing;
  int bestI2= -1,bestK2= 0,bestJ2= -1, bestR2 = -2;/* bestR2 = right end alignment type */
  FLOAT bestYik2 = 0.0;

  if(SecondBest){/* locate 2nd best alignment that is at least X[M+1] * SecondSpacing from best alignment (right end location) */
    /*    RFLOAT *biasend2_values = (RFLOAT *)alloca(sizeof(*biasend2_values)*(M+1));
    for(int J=1; J<=M ; J++)
    biasend2_values[J] = ChimScore + ((NEW>=2) ? BiasEnd2(X[M+1]-X[J],M+1-J) : (RFLOAT)0.0f); */
	
    for(int I=IMIN; I <= IMAX; I++){
      RFLOAT bscore = LARGE_NEGATIVE;
      int bK = 0, bJ = -1, bR = -1;
      FLOAT bYik = -1e30;
      int jmin = JMIN[I], jmax = JMAX[I];

      for(int K = 0; K <= Kmax[I]; K++){
	FLOAT Yik = Yc(Y,I,K);
	if(fabs(Yik - bestYik) < MinSpacing)
	  continue;

	if(NEW && PoutlierEnd > 0.0){/* consider right end local alignments */
	  for(int J = jmin; J <= jmax; J++){
	    RFLOAT score = A->score(I,K,J) + biasend2_values[J];
	    if(score > bscore){
	      bscore = score;
	      bK = K;
	      bJ = J;
	      bR = localtype;/* local alignment (-2) OR outlier (-3) */
	      bYik = Yik;
	    }
	  }
	}

	FLOAT y = Y[N+1] - Yik;
	int Jmin = (extend && I >= N+1-DELTA_Y) ? jmin : max(jmin,M+1-DELTA_X);
	for(int J= Jmin ; J <= jmax; J++){
	  if(extend || A->Rij(I,K,J) <= N){
	    int Rijx = (extend ? A->Rijx(I,K,J) : M+1);
	    if(DEBUG>=2) assert(Rijx >= J && Rijx <= M+1);
	    RFLOAT score = Send(min(X[M+1]-X[J],y),min(M,Rijx)+1-J,min(N,A->Rij(I,K,J))+1-I, min(N,A->Rij(I,K,J)), refid,0);
	    int linear = -1;/* end type : -1 = normal, 0 = chr end, -2 = local, -3 = outlier */
	    if(ENDFIX && Rijx > M)
	      for(int U= A->Rij(I,K,J); U > I; U--){
		RFLOAT bound = Sbnd(X[M+1]-X[J],Y[U]-Yik,M+1-J,U-I,U-1,refid);
		if(bound > score){
		  score = bound;
		  if(!ENDFIX2)
		    continue;
		}
		if(!ENDFIX2)
		  break;
	      }
	    if(ENDFIX && A->Rij(I,K,J) > N && N+1-I <= DELTA_YEND){/* only possible if extend==1 */
	      if(DEBUG>=2) assert(extend);
	      for(int U= Rijx;U > J;U--){
		RFLOAT bound = Sbnd(X[U]-X[J],y,U-J,N+1-I,N,refid);
		if(bound > score){
		  score = bound;
		  Rijx = U-1;
		  if(!ENDFIX2)
		    continue;
		}
		if(!ENDFIX2)
		  break;
	      }
	      if(DEBUG>=2) assert(Rijx >= J && Rijx <= M+1);
	    }
	    if(ISLINEAR && isLinear){/* try to align right ends of X and Y */
	      RFLOAT Rend = Sint(X[M+1]-X[J],y,M+1-J,N+1-I,J,N+1,0,K,PRtabY,Y);// - PRtabY[K][I].Sm;
	      if(Rend > score){
		score = Rend;
		linear = 0;
	      }
	    }
	    score += A->score(I,K,J);
	    if(score > bscore){
	      if(DEBUG){
		assert(I-K >= 1 && I >= IMIN && I <= IMAX);
		assert(J >= JMIN[I] && J <= JMAX[I]);
	      }
	      bscore = score;
	      bK = K;
	      bJ = J;
	      bR = linear;
	      bYik = Yik;
	    }
	  }
	}
      }

      if(DEBUG && bJ >= 1) assert(bYik == Yc(Y,I,bK));

      if(bscore > bestscore2 + 1e-8){
	bestscore2 = bscore;
	bestI2 = I;
	bestJ2 = bJ;
	bestK2 = bK;
	bestR2 = bR;
	bestYik2 = bYik;
	if(DEBUG){
	  assert(bestI2 >= IMIN && bestI2-bestK2 >= 1 && bestI2 <= IMAX);
	  assert(bestJ2 >= JMIN[bestI2] && bestJ2 <= JMAX[bestI2]);
	  assert(bestR2 <= -2 || bestJ2 >= M+1 - DELTA_X || (extend && bestI2 >= N+1-DELTA_Y));
	  assert(fabs(bestYik2-bestYik) >= MinSpacing);
	}
      }
    }

    if(DEFER_BP && !outlierExtend){/* compute G,T,H values along 2nd best alignment path */
      int I = bestI2;
      int K = bestK2;
      int J = bestJ2;

      while(I >= 0){
	/* update G, T, H by repeating recurrance computation */
	RFLOAT score = A->Uscore(I,K,J);
      
	int bestG = A->G(I,K,J);
	int bestH = A->H(I,K,J);
	int bestT = A->T(I,K,J);
	int Gmin = max(IMIN,I-K-DELTA_Y);
      
	if(maptype) {
	  for(int G= I-K; --G >= Gmin;){
	    int Hmin = max(JMIN[G],J-DELTA_X);
	    int Hmax = min(JMAX[G],J-1);
	    for(int T = Kmax[G]; T >= 0; T--){
	      if(DEBUG>=2) assert(G-T >= 1);
	      RFLOAT deltaY,Ivar,GaussY,Sm;
	      RFLOAT penY = SintY(I-K-G,I,K,T,deltaY,Ivar,GaussY,Sm,YPenR);
	      RFLOAT OutPenBC = OutlierPenaltyBC[I-K-G];
	      RFLOAT *AscoreGT = &A->score(G,T,0);

	      for(int H = Hmax; H >= Hmin; H--){
		if(DEBUG>=2) assert(H >= JMIN[G]);
		if(DEBUG>=2) assert(H <= JMAX[G]);
		int m = J-H;
		RFLOAT deltaX = XPen->deltaX[m][J];
		//		RFLOAT newscore = AscoreGT[H] + SintX_maptype1(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J]);
		RFLOAT newscore = AscoreGT[H] + SintX(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J], OutPenBC + OutlierPenaltyBC[m]);
		if(newscore > score){
		  score = newscore;
		  bestG = G;
		  bestH = H;
		  bestT = T;
		}
	      }
	    }
	  }
	} else {/* maptype==0 */
	  for(int G= I-K; --G >= Gmin;){
	    int Hmin = max(JMIN[G],J-DELTA_X);
	    int Hmax = min(JMAX[G],J-1);
	    for(int T = Kmax[G]; T >= 0; T--){
	      if(DEBUG>=2) assert(G-T >= 1);
	      RFLOAT deltaY,Ivar,GaussY,Sm;
	      RFLOAT penY = SintY(I-K-G,I,K,T,deltaY,Ivar,GaussY,Sm,YPenR);
	      RFLOAT OutPenBC = OutlierPenaltyBC[I-K-G];
	      RFLOAT *AscoreGT = &A->score(G,T,0);

	      for(int H = Hmax; H >= Hmin; H--){/* remaining iterations if DELTA_X > 4 */
		if(DEBUG>=2) assert(H >= JMIN[G]);
		if(DEBUG>=2) assert(H <= JMAX[G]);
		int m = J-H;
		RFLOAT deltaX = XPen->deltaX[m][J];
		//		RFLOAT newscore = AscoreGT[H] + SintX_maptype0(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J],0);
		RFLOAT newscore = AscoreGT[H] + SintX(deltaX,deltaY,penY,GaussY,Sm,Ivar,XPen->Pen[m][J],XPen->Bias[m][J],XPen->PenBias[m][J], OutPenBC + OutlierPenaltyBC[m]);
		if(newscore > score){
		  score = newscore;
		  bestG = G;
		  bestH = H;
		  bestT = T;
		}
	      }
	    }
	  }
	}/* maptype == 0 */

	if(DEBUG>=2) assert(score < -10.0 || fabs(A->score(I,K,J) - score) < (USE_RFLOAT ? 1e-4 : 1e-8));
	A->G(I,K,J) = bestG;
	A->H(I,K,J) = bestH;
	A->T(I,K,J) = bestT;
	if(bestG < 0){
	  bestLI2 = I;
	  bestLK2 = K;
	  bestLJ2 = J;
	  bestL2 = bestG;
	}
	I = bestG;
	K = bestT;
	J = bestH;
      }
      if(bestLI2 == bestLI && bestLK2 == bestLK && bestLJ2 == bestLJ){/* left end of 2nd best alignment matches best alignment : can happen due to outliers if SecondSpacing is small */
	if(PVERB >= 2){
	  #pragma omp critical
	  {
	    printf("WARNING: refid=%d,mapid=%d(id=%lld),or=%d: 2nd best alignment discarded due to left ends(%d,%d,%d) matching best alignment : try increasing SecondSpacing=%0.4f\n",
		   refid,mapid,nanomap->id,orientation, bestLI, bestLK, bestLJ, SecondSpacing);
	    printf("     Right ends for best alignment = %d,%d,%d (y=%0.6f), for 2nd best alignment = %d,%d,%d (y=%0.6f),bestL=%d,bestL2=%d\n",
		   bestI,bestK,bestJ,Yc(Y,bestI,bestK), bestI2,bestK2,bestJ2,Yc(Y,bestI2,bestK2),bestL,bestL2);
	    fflush(stdout);
	  }
	}
	bestscore2 = MINSCORE;
      }
    }
    if(PVERB>=2){
      #pragma omp critical
      {
	if(bestscore2 > MINSCORE)
	  printf("refid=%d,mapid=%d(id=%lld),or=%d:bestscore2= %0.4f, bestI2=%d,bestK2=%d,bestJ2=%d,bestR2=%d(y=%0.4f): bestLI2=%d,bestLK2=%d,bestLJ2=%d,bestL2=%d\n",
		 refid,mapid,nanomap->id,orientation,bestscore2,bestI2,bestK2,bestJ2,bestR2,Yc(Y,bestI2,bestK2),bestLI2,bestLK2,bestLJ2,bestL2);
	else
	  printf("refid=%d,mapid=%d(id=%lld),or=%d:bestscore2= %0.4e\n", refid,mapid,nanomap->id,orientation,bestscore2);
	fflush(stdout);
      }
    }
  } // if(SecondBest)


  // NOTE : MULTIMATCHES_FILTER can remove the bestscore from matchgroups, if the rightmost iscore[] is < -MULTIMATCHES_FILTER
  if(DEBUG && (MULTIMATCHES_FILTER==0.0 || PVERB) && MultiMatches && bestscore >= ScoreThreshold2 && nummatchgroup <= 0){
    printf("WARNING : tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d: %d/%d/%d matchgroups (bestscore= %0.6f, S2= %0.6f)\n",
	   tid,refid,rmap->id,mapid,nanomap->id,orientation,nummatchgroup,numprefiltered,cntmatchgroup,bestscore, ScoreThreshold2);
    fflush(stdout);
    if(MULTIMATCHES_FILTER==0.0) assert(nummatchgroup >= 1);
  }

  if(MultiMatches && nummatchgroup >= 1){
    if(PVERB>=2){
      #pragma omp critical
      {
	printf("tid=%d:refid=%d,mapid=%d,or=%d: Before sorting %d matchgroups by score\n",tid,refid,mapid,orientation,nummatchgroup);
	fflush(stdout);
      }
    }

    int heapcnt = 0;

#if MATCHGROUP_HEAP
    /* store matchgroups in a Max-heap, since this is faster than sorting, especially if MultiMatchesFilter >=2 */
    Cmatchgroup **heap = mheap;
    Cmatchgroup *nmatchgroup = &matchgroup[maxmatchgroup];

    if(MultiMatchesFilter){
      for(int t = 0; t < nummatchgroup; t++){
	Cmatchgroup *p = &matchgroup[t];
	p->Fscore = p->score;      
	heap_insert(heap,heapcnt, p);
      }
      if(PVERB>=2){
	memcpy(nmatchgroup, matchgroup, nummatchgroup * sizeof(Cmatchgroup));
	qsort(nmatchgroup,nummatchgroup,sizeof(Cmatchgroup),(intcmp *)CmatchgroupScoreDec);
      }
    } else {
      qsort(matchgroup,nummatchgroup,sizeof(Cmatchgroup),(intcmp *)CmatchgroupScoreDec);
      nmatchgroup = matchgroup;
    }
#else
    qsort(matchgroup,nummatchgroup,sizeof(Cmatchgroup),(intcmp *)CmatchgroupScoreDec);
#endif

    if(PVERB/**/){
      #pragma omp critical
      {
	if(MULTIMATCHES_FILTER != 0.0)
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:bestscore=%0.6f(I=%d,K=%d,J=%d,R=%d,IL=%d):sorted %d/%d/%d matchgroups with score >= %0.6f(%0.6f(I=%d,K=%d,J=%d) .. %0.6f)(previous matchgroups=%d),tid=%d: wall time=%0.6f\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,bestIL,nummatchgroup,numprefiltered,cntmatchgroup,
		 ScoreThreshold2,matchgroup[0].score,matchgroup[0].I,matchgroup[0].K,matchgroup[0].J, matchgroup[nummatchgroup-1].score, align->multicnt,tid,wtime());
	else
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:bestscore=%0.6f(I=%d,K=%d,J=%d,R=%d,IL=%d):sorted %d/%d matchgroups with score >= %0.6f(%0.6f(I=%d,K=%d,J=%d) .. %0.6f)(previous matchgroups=%d),tid=%d\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,bestIL,nummatchgroup,cntmatchgroup,
		 ScoreThreshold2,matchgroup[0].score,matchgroup[0].I,matchgroup[0].K,matchgroup[0].J, matchgroup[nummatchgroup-1].score, align->multicnt,tid);
	if(PVERB>=2){
	  for(int i = 0; i < nummatchgroup; i++){
	    Cmatchgroup *p = MATCHGROUP_HEAP ? &nmatchgroup[i] : &matchgroup[i];
	    if(i >= 10 && !(MATCHGROUP_HEAP && p==heap[1]) && /* !(p->I==24278 && p->K==0 && (p->J==2693 || p->J==2682)) &&*/ !(I_TRACE > 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE))
	      continue;

	    int numpairs = 0,Lend;
	    int I = p->I;
	    int K = p->K;
	    int J = p->J;
	    int IL = p->IL; // A->IL(I,K,J);
	    int KL = p->KL; // A->KL(I,K,J);
	    int JL = p->JL; // A->JL(I,K,J);
	    if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	    double logPV = alignFPsd(A,I,J,K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid,0, 0 /* verb */, numpairs,Lend,IL,0,0);
	    printf("   %d:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d (offset=%0.3f .. %0.3f):numpairs=%d,score= %0.6f, LogPv= %0.2f, Len= %0.1f\n",
		   i,I,K,J,p->R,IL,KL,JL,Yc(Y,IL,KL)-X[JL],Yc(Y,I,K)-X[J],numpairs,p->score,logPV, Yc(Y,I,K) - Yc(Y,IL,KL));
	  }
	}
	fflush(stdout);
      }
    }

    if(MultiMatchesFilter){/* filter early based on LogPvThreshold2 & AlignedSiteThreshold2. If MultiMatchesFilter >= 2 also apply a fast subset filter */
      double wtstart = PVERB ? wtime() : 0.0;

      if(!MATCHGROUP_HEAP && MultiMatchesFilter >= 2){
	for(int i = 0; i < nummatchgroup; i++){
	  Cmatchgroup *p = &matchgroup[i];	
	  p->Fscore = p->score;
	}
      }

      int j = 0;

      for(int i = 0; i < nummatchgroup; i++){
      LrepeatiF:
#if MATCHGROUP_HEAP
	Cmatchgroup *p = heap_extract(heap,heapcnt);
#else
	Cmatchgroup *p = &matchgroup[i];
#endif

	int numpairs = -1, Lend = -1;

        if(PVERB/* HERE HERE >=3 */ && (i < 10 /* || (p->I==24278 && p->K==0 && (p->J==2693 || p->J==2682)) */ || (I_TRACE > 0 && p->I==I_TRACE && p->K==K_TRACE && p->J==J_TRACE))){
	  int I = p->I;
	  int K = p->K;
	  int J = p->J;
	  int IL = p->IL; // A->IL(I,K,J);
	  int KL = p->KL; // A->KL(I,K,J);
	  int JL = p->JL; // A->JL(I,K,J);
	  printf("   %d:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d:score= %0.6f,Fscore= %0.6f, Len= %0.1f: checking for -MultiMatchesFilter %d (A->shift(I,K,J)= %d)\n",
		 i,I,K,J,p->R,IL,KL,JL,p->score,p->Fscore, Yc(Y,I,K) - Yc(Y,IL,KL), MultiMatchesFilter, A->shift(I,K,J));
	  fflush(stdout);
	}

	if(MultiMatchesFilter >= 2){
	  if(DEBUG>=2){
	    assert(IMIN <= p->I && p->I <= IMAX);
	    assert(0 <= p->K && p->K <= Kmax[p->I]);
	    assert(JMIN[p->I] <= p->J && p->J <= JMAX[p->I]);
	  }
	  if(A->shift(p->I,p->K,p->J))
	    continue;
	}

        int Filter = (MultiMatchesFilter >= 2) ? (MultiMatchesTotScore ? min(AlignedSiteThreshold2, MinDupSites) : AlignedSiteThreshold2)/* WAS6 AlignedSiteThreshold2 */ : 0;

	if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	p->logPV = alignFPsd(A,p->I,p->J,p->K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid,0, 0, numpairs,Lend,p->IL, iscore,outscore,Ilist, Klist, Jlist, outlier, Filter);
	if(p->logPV <= LogPvThreshold2 || numpairs < AlignedSiteThreshold2)
	  continue;

	if(DEBUG/* HERE >=2 */) assert(LogPvThreshold2 >= 0.0);

	int t = numpairs, I= -1,K = -1, J = -1;
	if(MultiMatchesFilter >= 2  /* && !((DEBUG>=2 && RefSplitStitch>=2) || PVERB)*/) {/* check if matchgroup[i] overlaps a previous alignment matchgroup[0..j-1] (with entries in A marked with shift > 0) */
	  double cumscore = 0.0;
	  double maxdeltascore = 0.0, maxcumscore = 0.0;
	  int tmax = 0;
	  for(t= 0; t < numpairs; t++){
	    I = Ilist[t];
	    K = Klist[t];
	    J = Jlist[t];
	    cumscore += iscore[t];
	    if(DEBUG>=2){
	      assert(IMIN <= I && I <= IMAX);
	      assert(0 <= K && K <= Kmax[I]);
	      assert(JMIN[I] <= J && J <= JMAX[I]);
	    }
	    if(MULTIMATCHESTOTSCORE_FIX && MultiMatchesTotScore >= 2){	    // keep track of best possible left end truncation (similar to use with -MultiMatchesTotScore later)
	      RFLOAT ndeltascore = A->Uscore(I,K,J) - A->score(I,K,J);
	      if(ndeltascore > maxdeltascore){
		tmax = t;
		maxdeltascore = ndeltascore;
		maxcumscore = cumscore;
	      }
	    }

	    if(A->shift(I,K,J))
	      break;
	  }

	  if(/* TVERB */  PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:I=%d,K=%d,J=%d,IL=%d -> %d,KL=%d -> %d,JL=%d -> %d: t=%d,%d,pairs=%d,cumscore=iscore[%d..%d]= %0.6f, iscore[%d]= %0.6f, A->Uscore(IL,KL,JL)= %0.6f, p->score = %0.6f -> %0.6f\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,rev,p->I,p->K,p->J,p->IL,I,p->KL,K,p->JL,J,t,tmax,numpairs,0,min(numpairs-1,t),cumscore, min(numpairs,t+1), iscore[min(numpairs,t+1)], A->Uscore(I,K,J), p->score, cumscore + A->Uscore(I,K,J));
	    if(PVERB>=3){
	      double iscoresum = 0.0;
	      for(int k = 0; k < numpairs && k <= t; k++){
		iscoresum += iscore[k];
		printf("k=%5d:G=%d,T=%d,H=%d,iscore[k] = %0.6f, sum= %0.6f\n",k, Ilist[k],Klist[k],Jlist[k],iscore[k],iscoresum);
	      }
	      fflush(stdout);
	      if(DEBUG && !(fabs(iscoresum - cumscore) < 1e-5)){
		printf("\t iscoresum= %0.6f, cumscore= %0.6f (err= %0.6f)\n", iscoresum, cumscore, cumscore - iscoresum);
		fflush(stdout);
		assert(fabs(iscoresum - cumscore) < 1e-5);
	      }
	    }
	  }

	  if(MULTIMATCHESTOTSCORE_FIX && MultiMatchesTotScore >= 2){
	    if(DEBUG && t == numpairs && !(maxdeltascore <= 1e-5)){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:I=%d,K=%d,J=%d,IL=%d -> %d,KL=%d -> %d,JL=%d -> %d: t=%d,%d,pairs=%d,cumscore=iscore[%d..%d]= %0.6f, iscore[%d]= %0.6f, A->Uscore(IL,KL,JL)= %0.6f, p->score = %0.6f -> %0.6f\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,rev,p->I,p->K,p->J,p->IL,I,p->KL,K,p->JL,J,t,tmax,numpairs,0,min(numpairs-1,t),cumscore, min(numpairs,t+1), iscore[min(numpairs,t+1)], A->Uscore(I,K,J), p->score, cumscore + A->Uscore(I,K,J));
	      printf("\t maxdeltascore= %0.6f\n",maxdeltascore);
	      fflush(stdout);
	      assert(maxdeltascore <= 1e-5);
	    }
	    if(tmax < t){
	      t = tmax;
	      I = Ilist[t];
	      K = Klist[t];
	      J = Jlist[t];
	      cumscore = maxcumscore;
	      if(/* TVERB */  PVERB>=2 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:I=%d,K=%d,J=%d,IL=%d -> %d,KL=%d -> %d,JL=%d -> %d: t -> %d,pairs=%d,cumscore=iscore[%d..%d]= %0.6f, iscore[%d]= %0.6f, A->Uscore(IL,KL,JL)= %0.6f, p->score = %0.6f -> %0.6f (left end trimmed)\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,rev,p->I,p->K,p->J,p->IL,I,p->KL,K,p->JL,J,t,numpairs,0,min(numpairs-1,t),cumscore, min(numpairs,t+1), iscore[min(numpairs,t+1)], A->Uscore(I,K,J), p->score, cumscore + A->Uscore(I,K,J));
		fflush(stdout);
	      }
	    }
	  }

	  if(t/* WAS6 t+1 */ < Filter && !(RefSplitStitch>=2 && cumscore > (RFLOAT)0.0)){/* matchgroup[i] would be filtered later */
	    if(DEBUG) assert(j > 0);/* at least one previous matchgroup should always survive */

	    if(PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
	      printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:i=%d/%d:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d (offset= %0.3f .. %0.3f): U=%d,score= %0.6f, LogPv= %0.2f, Len= %0.1f : Uniq=%d(A2=%d,D2=%dshift=%d): discarded(heapcnt=%d)\n",
		     tid,refid,rmap->id,mapid,nanomap->id,orientation,i,nummatchgroup,p->I,p->K,p->J,p->R,p->IL,p->KL,p->JL,Yc(Y,p->I,p->K)-X[p->J],Yc(Y,p->IL,p->KL)-X[p->JL],numpairs,p->score,p->logPV,Y[p->I] - Y[p->IL], 
		     t, AlignedSiteThreshold2,MinDupSites,(t < numpairs) ? A->shift(I,K,J) : -1,heapcnt);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(t >= Filter);// since alignFPsd() above should have return logPV == 0.0
	    continue;
	  }

	  if(MULTIMATCH_TRIM && t < numpairs){
	    /* DO NOT immediately mark A->shift with this truncated matchgroup, since this may block a higher scoring matchgroup that has not been checked yet.
	       Instead the truncated/rescored matchgroup needs to be re-ordered and rechecked later (see MULTIMATCH_TRIM below, but consider using heap instead of sorted array)
	       NOTE : The matchgroups is not actually truncated, only a temporary score (Fscore) is updated. However if the truncated length is below Filter, it would be discarded already (see above code block) */

	    p->Fscore = cumscore + A->Uscore(I,K,J);

#if MATCHGROUP_HEAP
	    if(heapcnt >= 1 && p->Fscore < heap[1]->Fscore){/* postpone dealing with matchgroup[i] based on expected truncated score */
	      if(PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
		printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:i=%d/%d:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d (offset= %0.3f .. %0.3f): U=%d,score= %0.6f, LogPv= %0.2f, Len= %0.1f : Uniq=%d(A2=%d,shift=%d):Fscore=%0.6f:inserting matchgroup[i=%d] back into heap[1..%d]: heap[1]->Fscore= %0.6f\n",
		       tid,refid,rmap->id,mapid,nanomap->id,orientation,i,nummatchgroup,p->I,p->K,p->J,p->R,p->IL,p->KL,p->JL,Yc(Y,p->I,p->K)-X[p->J],Yc(Y,p->IL,p->KL)-X[p->JL],numpairs,p->score,p->logPV,Y[p->I] - Y[p->IL], 
		       t, AlignedSiteThreshold2,(t < numpairs) ? A->shift(I,K,J) : -1, p->Fscore,i,heapcnt, heap[1]->Fscore);
		fflush(stdout);
	      }	    
	      heap_insert(heap,heapcnt,p);
	      goto LrepeatiF;// NOTE : this is needed so that highest scoring matchgroup is re-extracted from heap[1..heapcnt] and p updated, since it is not the same matchgroup as before
	    }
#else
	    if(i+1 < nummatchgroup && p->Fscore < matchgroup[i+1].Fscore){/* postpone dealing with matchgroup[i] based on expected truncated score */

	      /* resort matchgroup[i..nummatchgroup-1] based on Fscore */
	      int k = i+1;
	      for(; k < nummatchgroup; k++)
		if(matchgroup[k].Fscore <= p->Fscore)
		  break;
	      k--;
	      if(DEBUG) assert(k > i);
	      if(PVERB>=3 && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){		
		printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:i=%d/%d:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d (offset= %0.3f .. %0.3f): U=%d,score= %0.6f, LogPv= %0.2f, Len= %0.1f : Uniq=%d(A2=%d,shift=%d):Fscore=%0.6f:moving matchgroup[i=%d] to matchgroup[k=%d]\n",
		       tid,refid,rmap->id,mapid,nanomap->id,orientation,i,nummatchgroup,p->I,p->K,p->J,p->R,p->IL,p->KL,p->JL,Yc(Y,p->I,p->K)-X[p->J],Yc(Y,p->IL,p->KL)-X[p->JL],numpairs,p->score,p->logPV,Y[p->I] - Y[p->IL], 
		       t, AlignedSiteThreshold2,(t < numpairs) ? A->shift(I,K,J) : -1, p->Fscore,i,k);
		fflush(stdout);
	      }	    
	      
	      Cmatchgroup tmp = matchgroup[i];
	      for(int t = i; t < k; t++)
		matchgroup[t] = matchgroup[t+1];
	      matchgroup[k] = tmp;
	      goto LrepeatiF;// NOTE : this is needed so that p and all related variables are updated, since matchgroup[i] is not the same matchgroup as before
	    }
#endif // !MATCHGROUP_HEAP
	  }
	} // if (MultiMatchesFilter >= 2)

#if MATCHGROUP_HEAP
	nmatchgroup[j] = *p;
#else
	if(j < i)
	  matchgroup[j] = *p;
#endif
	j++;

	if(MultiMatchesFilter >= 2) /* mark all unique entries in A corresponding to current alignment with shift = j */
	  for(int T = 0; T < t; T++)
	    A->shift(Ilist[T],Klist[T],Jlist[T]) = j;

	if(PVERB>=3 && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){		
	  if(MultiMatchesFilter >= 2){
	    if(DEBUG && t < numpairs){
	      assert(IMIN <= I && I <= IMAX);
	      assert(0 <= K && K <= Kmax[I]);
	      assert(JMIN[I] <= J && J <= JMAX[I]);
	    }
	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:i=%d/%d:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d (offset= %0.3f .. %0.3f): U=%d,score= %0.6f, LogPv= %0.2f, Len= %0.1f : Uniq=%d(A2=%d,shift=%d), mcnt=%d\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,i,nummatchgroup,p->I,p->K,p->J,p->R,p->IL,p->KL,p->JL,Yc(Y,p->I,p->K)-X[p->J],Yc(Y,p->IL,p->KL)-X[p->JL],numpairs,p->score,p->logPV,Y[p->I] - Y[p->IL], 
		   t, AlignedSiteThreshold2,(t < numpairs) ? A->shift(I,K,J) : -1,j);
	  } else
	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:i=%d/%d:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d (offset= %0.3f .. %0.3f): U=%d,score= %0.6f, LogPv= %0.2f, Len= %0.1f : mcnt=%d\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,i,nummatchgroup,p->I,p->K,p->J,p->R,p->IL,p->KL,p->JL,Yc(Y,p->I,p->K)-X[p->J],Yc(Y,p->IL,p->KL)-X[p->JL],numpairs,p->score,p->logPV,Y[p->I] - Y[p->IL], j);
	  fflush(stdout);
	}
      }
      
      int orignummatchgroup = nummatchgroup;
      nummatchgroup = j;

#if MATCHGROUP_HEAP
      memcpy(matchgroup,nmatchgroup, sizeof(Cmatchgroup)*nummatchgroup);
#endif

      if(MultiMatchesFilter>=2 && RepeatRec && RepeatMaxShift > 0){/* reset A->shift values to 0, since it will be used by checkRepeat() */
	for(int i = 0; i < nummatchgroup; i++){
	  Cmatchgroup *p = &matchgroup[i];	
	  int numpairs = -1,Lend = -1;
	  if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	  (void)alignFPsd(A,p->I,p->J,p->K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid,0, 0, numpairs,Lend,p->IL, 0, 0, Ilist, Klist, Jlist, outlier);

	  for(int t = 0; t < numpairs; t++){
	    int I = Ilist[t];
	    int K = Klist[t];
	    int J = Jlist[t];
	    if(DEBUG>=2){
	      assert(IMIN <= I && I <= IMAX);
	      assert(0 <= K && K <= Kmax[I]);
	      assert(JMIN[I] <= J && J <= JMAX[I]);
	    }

	    A->shift(I,K,J) = 0;
	  }
	}
      }

      if(PVERB && nummatchgroup < orignummatchgroup){
        double wt = wtime();

#pragma omp critical	
        {
          if(MultiMatches >= 2)
  	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:bestscore=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d:reduced %d matchgroups to %d due to T2=%0.2f,A2=%d and subsets (previous matchgroups=%d):wtime= %0.6f(del= %0.6f)\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,bestIL,orignummatchgroup,nummatchgroup,
		   LogPvThreshold2, AlignedSiteThreshold2, align->Malign ? align->multicnt : 0, wt,wt-wtstart);
	  else
	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:bestscore=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d:reduced %d matchgroups to %d due to T2=%0.2f,A2=%d (previous matchgroups=%d):wtime= %0.6f(del= %0.6f)\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,bestIL,orignummatchgroup,nummatchgroup,
		   LogPvThreshold2, AlignedSiteThreshold2, align->Malign ? align->multicnt : 0, wt,wt-wtstart);

	  if(PVERB/* HERE HERE >=3 */){
	    for(int i = 0; i < nummatchgroup; i++){
	      Cmatchgroup *p = &matchgroup[i];
	      if(i >= 10 && /* !(p->I==24278 && p->K==0 && (p->J==2693 || p->J==2682)) && */ !(I_TRACE > 0 && p->I==I_TRACE && p->K == K_TRACE && p->J == J_TRACE))
		continue;
	      int numpairs = 0,Lend;
	      int I = p->I;
	      int K = p->K;
	      int J = p->J;
	      int IL = p->IL; // A->IL(I,K,J);
	      int KL = p->KL; // A->KL(I,K,J);
	      int JL = p->JL; // A->JL(I,K,J);
	      
	      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	      double logPV = alignFPsd(A,I,J,K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid,0, (PVERB && I== I_TRACE && K== K_TRACE && J== J_TRACE) ? 1 : 0 /* verb */, numpairs,Lend,IL,0,0);
	      printf("   %d:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d (offset=%0.3f .. %0.3f):numpairs=%d,score= %0.6f, LogPv= %0.2f, Len= %0.1f\n",
		     i,I,K,J,p->R,IL,KL,JL,Yc(Y,I,K)-X[J],Yc(Y,IL,KL)-X[JL],numpairs,p->score,logPV, Yc(Y,I,K) - Yc(Y,IL,KL));
	    }
	  }

	  fflush(stdout);
	}
      }
    }

    if(REFSPLIT_FIX>=2 && RefSplit){ /* Break up matchgroups at -ve scoring region whenever number of labels of -ve scoring region (in ref OR query) exceed RefSplitMinLabels */
      MatchgroupRefSplit(matchgroup,mheap,nummatchgroup,maxmatchgroup, A, Ilist,Klist,Jlist,iscore,outscore,cumiscore,Y,N,X,M,orientation,rev,scaleID,rmap,nanomap,refid,mapid);
      
      // NOTE : for merged outliers the score is the sum of the scores of the original intervals : the correct score of the new merged outliers is computed after resolving overlapped matchgroups
    }

    if((MultiMatchesFilter >= 2 && MULTIMATCH_TRIM) || (REFSPLIT_FIX>=2 && RefSplit)){/* resort matchgroups since they may have been re-ordered */
      if(PVERB){
        printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:re-sorting %d matchgroups\n",tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,nummatchgroup);
	fflush(stdout);
      }
      qsort(matchgroup,nummatchgroup,sizeof(Cmatchgroup),(intcmp *)CmatchgroupScoreDec);

      if(PVERB/* HERE HERE >=3 */){
	printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:After MatchgroupRefSplit & re-sorting %d matchgroups\n",
	       tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,nummatchgroup);
	fflush(stdout);
	for(int i = 0; i < nummatchgroup; i++){
	  Cmatchgroup *p = &matchgroup[i];
	  if(i >= 10 && !(I_TRACE > 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE))
	    continue;
	  int numpairs = 0,Lend;
	  int I = p->I;
	  int K = p->K;
	  int J = p->J;
	  int IL = p->IL; // A->IL(I,K,J);
	  int KL = p->KL; // A->KL(I,K,J);
	  int JL = p->JL; // A->JL(I,K,J);
	  int verb = 0;
	  //	  if((I==39461 && K==0 && J==44901) || (I==39204 && K==0 && J==44640)) verb = 1;
	  if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	  double logPV = alignFPsd(A,I,J,K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid,0, verb, numpairs,Lend,IL,0,0);
	  printf("   %d:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d (offset=%0.3f .. %0.3f):numpairs=%d,score= %0.6f, LogPv= %0.2f, Len= %0.1f\n",
		 i,I,K,J,p->R,IL,KL,JL,Yc(Y,I,K)-X[J],Yc(Y,IL,KL)-X[JL],numpairs,p->score,logPV, Yc(Y,I,K) - Yc(Y,IL,KL));
	}
      }
    }

    if(DEBUG>=2){/* check that matchgroups are in descending order of score */
      for(int i = 1; i < nummatchgroup; i++){
	if(!(matchgroup[i].score <= matchgroup[i-1].score)){
	  printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d: i=%d/%d:matchgroup[i-1].score= %0.6f, matchgroup[i].score= %0.6f\n",
		 tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,i,nummatchgroup,matchgroup[i-1].score,matchgroup[i].score);
	  fflush(stdout);
	  assert(matchgroup[i].score <= matchgroup[i-1].score);
	}
      }
    }

    if(nummatchgroup > 0){
      if(DEBUG && !MultiMatchesFilter && MULTIMATCHES_FILTER==0.0 && !(fabs(matchgroup[0].score - bestscore) < 1e-6)){
#pragma omp critical
	{
	  Cmatchgroup *p = &matchgroup[0];	
	  printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:bestscore=%0.6f,bestI=%d,bestK=%d,bestJ=%d,bestR=%d,bestIL=%d;matchgroup[0]:score=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d\n",
		 tid,refid,rmap->id,mapid,nanomap->id,orientation,bestscore,bestI,bestK,bestJ,bestR,bestIL,p->score,p->I,p->K,p->J,p->R,p->IL);
	  fflush(stdout);
	  assert(fabs(matchgroup[0].score - bestscore) < 1e-6);
	}
      }
      if(!(matchgroup[0].I == bestI && matchgroup[0].K == bestK && matchgroup[0].J == bestJ && matchgroup[0].R == bestR)){
	Cmatchgroup *p = &matchgroup[0];

	if(PVERB){
#pragma omp critical
	  {
	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f->%0.6f,bestI=%d->%d,bestK=%d->%d,bestJ=%d->%d,bestR=%d->%d,bestIL=%d,%d (replaced best match due to score rounding error)\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,p->score,bestI,p->I,bestK,p->K,bestJ,p->J,bestR,p->R,bestIL,p->IL);
	    fflush(stdout);
	  }
	}
      
	bestscore = p->score;
	bestI = p->I;
	bestK = p->K;
	bestJ = p->J;
	bestR = p->R;
	bestIL = p->IL;
        bestYik = Yc(Y,bestI,bestK);// NEW21
      } else if(bestIL < 0)
	bestIL = matchgroup[0].IL;

      /* Keep any matchgroup that relative to every higher scoring matchgroup:
	 1. Has at least MultiMatches unique aligned sites (or just shift, if MULTIMATCHES_FIX) in reference OR query.
      OR 2. Differs in offset at both alignment ends by at least MultiMatchesDelta (kb) in same direction.
      OR 3. Differs in offset at right end of alignment by at least MultiMatchesDelta (kb) AND share at most the left end aligned pair.
      
      Eliminate all other matchgroups, but if MULTIMATCH_TRIM, first check each current matchgroup about to be eliminated : If it overlaps a higher scoring matchgroup (with identical label pairs), try to
      truncate the left end of the current matchgroup to eliminate all but 1 common label pair and save the truncated matchgroup as a new matchgroup to be rechecked later. 

      If MultiMatchesTotScore try to maximize the total score:
        1. Check the score of the first non-shared aligned segment of both the current matchgroup and the higher scoring matchgroup.
        2. If the higher scoring matchgroup has a -ve score that is worse than for the current matchgroup, swap the higher scoring matchgroup with the current matchgroup, then truncate the left end of the current matchgroup etc.
      */

      //      long long MultiMatchTrimCnt = 0;
      if(DEBUG>=1+RELEASE && MultiMatchesTotScore >= 2)
	for(int i = 0; i < nummatchgroup; i++)
	  matchgroup[i].maxoutlier = -1.0;

      int j = 0; // WAS37 j = 1;

      for(int i = 0; i < nummatchgroup; i++){
      Lrepeati:

	if(DEBUG) assert(i == 0 || i >= j);
	Cmatchgroup *p = &matchgroup[i];
	if(DEBUG>=1+RELEASE && REFSPLIT_FIX/* NEW7 */ && i+1 < nummatchgroup && !(p->score + 1e-6 >= matchgroup[i+1].score)){// matchgroup[i..nummatchgroup-1] should be sorted by score
	  #pragma omp critical
	  {
	    printf("WARNING: refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d/%d,j=%d: matchgroup[i].score= %0.6f, matchgroup[i+1].score= %0.6f\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,nummatchgroup,j,p->score,matchgroup[i+1].score);
	    fflush(stdout);
	    assert(p->score + 1e-5 >= matchgroup[i+1].score);
	  }
	}

	if(RefSplitStitch>=2) p->stitch = 0;// initialize
	int I = p->I;
	int K = p->K;
	int J = p->J;
	int IL = p->IL; // A->IL(I,K,J);
	int KL = p->KL; // A->KL(I,K,J);
	int JL = p->JL; // A->JL(I,K,J);
	double offsetL = 0.0, offsetR = 0.0;
	if(MultiMatchesDelta > 0){
	  offsetL = Yc(Y,IL,KL) - X[JL];
	  offsetR = Yc(Y,I,K) - X[J];
	}

	if(DEBUG>=2){
	  for(int t = i+1; t < nummatchgroup; t++){
	    if(!(matchgroup[t-1].score >= matchgroup[t].score - 1e-6)){
	      if(MultiMatchesTotScore >= 2)
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d/%d:p->score=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d:comparing with previous confirmed %d matchgroups: wtime= %0.6f\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,nummatchgroup,p->score,I,K,J,p->R,IL,KL,JL, min(i,j), wtime());
	      else
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d/%d:p->score=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d:comparing with previous confirmed %d matchgroups: wtime= %0.6f\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,nummatchgroup,p->score,I,K,J,p->R,IL,KL,JL, min(i,j), wtime());
	      printf("\t i=%d,nummatchgroup=%d,multicnt=%d: t=%d,matchgroup[t-1].score=%0.6f,matchgroup[t].score=%0.6f\n",  i,nummatchgroup,align->multicnt,t,matchgroup[t-1].score,matchgroup[t].score);
	      fflush(stdout);
	      assert(matchgroup[t-1].score >= matchgroup[t].score - 1e-6);
	    }
	  }
	}

	int U = -1;
	int Lend = -1;
	if(!MultiMatchesFilter){/* old code */
	  Lend = I;
	  if(DEBUG && IL >= 0) assert(IMIN <= IL && IL <= IMAX && JMIN[IL] <= p->JL && p->JL <= JMAX[IL]);
	  U = alignExtract(A, Lend, K, J, p->R, A->Tscore(I,K,J), Y,X,N,M,Ilist,Klist,Jlist,iscore,outscore,rmap,nanomap,refid,mapid, orientation,rev,scaleID,0,IL);
	} else { // new code : recheck logPV since it costs almost nothing and avoid keeping higher scoring alignments that are below -T2 or -A2 threshold
	  if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	  p->logPV = alignFPsd(A,I,J,K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid,0,0,U,Lend,p->IL,iscore,outscore,Ilist,Klist,Jlist,outlier);

	  if(/* TVERB */ PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:After calling alignFPsd:I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,pairs=U=%d:p->logPV= %0.2f, p->score= %0.6f, iscore[0]= %0.6f, iscore[U]= %0.6f \n",
		   refid,rmap->id,mapid,nanomap->id,orientation,rev,p->I,p->K,p->J,p->IL,p->KL,p->JL,U, p->logPV, p->score, iscore[0],iscore[U]);
	    if(PVERB>=3){
	      double iscoresum = 0.0;
	      for(int k = 0; k < U; k++){
		iscoresum += iscore[k];
		printf("  k=%5d:U-k=%5d:G=%d,T=%d,H=%d,iscore[k]= %0.6f, sum= %0.6f\n",k, U-k,Ilist[k], Klist[k],Jlist[k],iscore[k],iscoresum);
	      }
	    }
	    fflush(stdout);
	  }

	  if(p->logPV <= LogPvThreshold2 || U < AlignedSiteThreshold2)
	    continue;
	}
	
	int Iout = -1, Kout = -1, Jout = -1;
	if(MultiMatchesTotScore >= 2){/* compute largest sizing error p->maxoutlier */
	  p->maxoutlier = -1.0;

	  int lastI = Ilist[0],I;
	  int lastK = Klist[0],K;
	  int lastJ = Jlist[0],J;
	  for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
	    I = Ilist[t];
	    K = Klist[t];
	    J = Jlist[t];
	    
	    if(DEBUG>=2) assert(lastJ >= J && lastI >= I);
	    double x = X[lastJ] - X[J];
	    double y = Yc(Y,lastI,lastK) - Yc(Y,I,K);
	    double maxoutlier = fabs(y-x);
	    if(maxoutlier > p->maxoutlier){
	      p->maxoutlier = maxoutlier;
	      Iout = I;
	      Kout = K;
	      Jout = J;
	    }
	  } 
	}

	FLOAT score = 0.0;
	if(REFSPLIT_FIX <= 0 /* WAS7 1 */ || PVERB>=3)
	  for(int t = 0; t <= U; t++)
	    score += iscore[t];

	if((PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE) ||
	   (DEBUG>=1+RELEASE && !(REFSPLIT_FIX>=1 /* WAS7 2 */ || ((((maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE) && outlierExtend) ? p->score - score : fabs(p->score - score)) < (IL >= 0 ? 1.0 : 1e-5))))){
#pragma omp critical
	  {
	    if(i==0)
	      printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d,j=%d,I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,L=%d(G=%d),p->score=%0.6f(score=%0.6f),LogPV=%0.2f,iscore[0]=%0.6f,Tscore=%0.6f,numpairs=%d,maxOut=%0.3f(I=%d,K=%d,J=%d)\n\t:matchgroup[%d/%d]: M=%d,N=%d\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,j,I,K,J,p->R,IL,KL,JL,Lend,A->G(IL,KL,JL),p->score,score,p->logPV,iscore[0],A->Tscore(I,K,J),U,p->maxoutlier,Iout,Kout,Jout,i,nummatchgroup,M,N);
	    else if(MultiMatchesFilter)
	      printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d,j=%d,I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,L=%d(G=%d),p->score=%0.6f(score=%0.6f),LogPV=%0.2f,iscore[0]=%0.6f,Tscore=%0.6f,numpairs=%d,maxOut=%0.3f(I=%d,K=%d,J=%d):\n\t checking matchgroup[%d/%d] for overlap with matchgroup[0..%d]: M=%d,N=%d\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,j,I,K,J,p->R,IL,KL,JL,Lend,A->G(IL,KL,JL),p->score,score,p->logPV,iscore[0],A->Tscore(I,K,J),U,p->maxoutlier,Iout,Kout,Jout,i,nummatchgroup,j-1,M,N);
	    else
	      printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d,j=%d,I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,L=%d(G=%d),p->score=%0.6f(score=%0.6f),LogPV=%0.2f,iscore[0]=%0.6f,Tscore=%0.6f,numpairs=%d,maxOut=%0.3f(I=%d,K=%d,J=%d):\n\t checking matchgroup[%d/%d] for overlap with matchgroup[0..%d]: M=%d,N=%d\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,j,I,K,J,p->R,IL,KL,JL,Lend,A->G(IL,KL,JL),p->score,score,p->logPV,iscore[0],A->Tscore(I,K,J),U,p->maxoutlier,Iout,Kout,Jout,i,nummatchgroup,j-1,M,N);
	    if(PVERB>=3){
	      for(int t = 0; t < U; t++){
		int pI = Ilist[t];
		int pK = Klist[t];
		int pJ = Jlist[t];
		RFLOAT pscore = A->score(pI,pK,pJ);
		
		if(t == U-1)
		  printf("      %d:I=%d,T=%d,J=%d: score=%0.6f(Sm=%0.6f,iscore[%d]=%0.6f,Uscore=%0.6f)\n",U-1-t,pI,pK,pJ,pscore, Sm(0,pI,pK,Y), t+1,iscore[t+1], A->Uscore(pI,pK,pJ));
		else {
		  int pG = Ilist[t+1];
		  int pT = Klist[t+1];
		  int pH = Jlist[t+1];
		  printf("      %d:I=%d,T=%d,J=%d (G=%d,T=%d,H=%d) score=%0.6f(Sm=%0.6f,iscore[%d]=%0.6f),y=%0.3f,x=%0.3f\n",U-1-t,pI,pK,pJ,pG,pT,pH,pscore, Sm(0,pI,pK,Y), t+1,iscore[t+1], Yc(Y,pI,pK)-Yc(Y,pG,pT), X[pJ]-X[pH]);
		}
	      }
	      for(int k = 0; k < j; k++){
		Cmatchgroup *q = &matchgroup[k];
		printf("   matchgroup[%d/%d]:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,score=%0.6f\n",
		       k,j,q->I,q->K,q->J,q->R,q->IL,q->KL,q->JL,q->score);
		fflush(stdout);
		if(DEBUG && k > 0) assert(matchgroup[k-1].score >= q->score);
	      }
	    }
	    if(DEBUG && !MultiMatchesTotScore) assert(matchgroup[j-1].score >= matchgroup[i].score);
	    if(DEBUG){
	      for(int k = i+1; k < nummatchgroup; k++){
		if(DEBUG && ! (matchgroup[k-1].score >= matchgroup[k].score)){
		  Cmatchgroup *q = &matchgroup[k-1];
		  printf("   matchgroup[%d]:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,score=%0.6f\n",
			 k-1,q->I,q->K,q->J,q->R,q->IL,q->KL,q->JL,q->score);
		  q = &matchgroup[k];
		  printf("   matchgroup[%d]:I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,score=%0.6f\n",
			 k,q->I,q->K,q->J,q->R,q->IL,q->KL,q->JL,q->score);
		  fflush(stdout);
		  assert(matchgroup[k-1].score >= matchgroup[k].score);
		}
	      }
	    }
	  
	    if(DEBUG>=1+RELEASE && REFSPLIT_FIX <= 0 /* WAS7 1 */ && !((((maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE) && outlierExtend) ? p->score - score : fabs(p->score - score)) < (IL >= 0 ? 1.0 : 1e-5))){
	      printf("    p->score=%0.6f,score=%0.6f,IL=%d\n",p->score,score,IL);
	      fflush(stdout);
	      assert((((maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE) && outlierExtend) ? p->score - score : fabs(p->score - score)) < (IL >= 0 ? 1.0 : 1e-5));
	    }
	  }
	}

        if(REFSPLIT_FIX <= 0 /* WAS7 1 */){
	  if(PVERB/* HERE HERE >=3 */ && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
	    printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:i=%d/%d: matchgroup[i]:I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,score=%0.6f -> %0.6f\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,rev,i,nummatchgroup,p->I,p->K,p->J,p->IL,p->KL,p->JL,p->score,score);
	    fflush(stdout);
	  }
	  p->score = score;
	}

	if(PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
	  if(MultiMatchesTotScore >= 2)
	    printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d/%d:p->score=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,numpairs=%d,maxOut=%0.3f:comparing with previous confirmed %d matchgroups: wtime= %0.6f\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,nummatchgroup,p->score,I,K,J,p->R,IL,KL,JL, U, p->maxoutlier, min(i,j), wtime());
	  else
	    printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d/%d:p->score=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,numpairs=%d:comparing with previous confirmed %d matchgroups: wtime= %0.6f\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,nummatchgroup,p->score,I,K,J,p->R,IL,KL,JL, U, min(i,j), wtime());
	  fflush(stdout);
	}

	if(i <= 0){
	  bestscore = p->score;
	  // WAS37 continue;
	}

	if(DEBUG>=1+RELEASE){
	  for(int t = 1; t < j; t++){
	    if(DEBUG && !(matchgroup[t].score <= matchgroup[t-1].score + 1e-6)){
	      if(MultiMatchesTotScore >= 2)
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d/%d:p->score=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,numpairs=%d,maxOut=%0.3f:comparing with previous confirmed %d matchgroups: wtime= %0.6f\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,nummatchgroup,p->score,I,K,J,p->R,IL,KL,JL, U, p->maxoutlier, min(i,j), wtime());
	      else
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d/%d:p->score=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d,KL=%d,JL=%d,numpairs=%d:comparing with previous confirmed %d matchgroups: wtime= %0.6f\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,nummatchgroup,p->score,I,K,J,p->R,IL,KL,JL, U, min(i,j), wtime());
	      printf("\t i=%d,j=%d->%d,nummatchgroup=%d,multicnt=%d: t=%d,matchgroup[t-1].score=%0.6f,matchgroup[t].score=%0.6f\n",  i,j-1,j,nummatchgroup,align->multicnt,t,matchgroup[t-1].score,matchgroup[t].score);
	      fflush(stdout);
	      
	      assert(matchgroup[t].score <= matchgroup[t-1].score + 1e-6);
	    }
	  }
	}

	int pchanged = 0;
	int k = 0;
	for(; k < j; k++){
	  if(DEBUG) assert(j <= i);
	  Cmatchgroup *q = &matchgroup[k];
	  if(DEBUG>=2 && !(REFSPLIT_FIX <= 0 /* WAS7 1 */ || MultiMatchesTotScore) && !(q->score >= p->score)){
#pragma omp critical
	    {
	      printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,k=%d,p->score=%0.6f,q->score=%0.6f\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,i,k,p->score,q->score);
	      fflush(stdout);
	      assert(q->score >= p->score);
	    }
	  }

#if 1 // NOTE : play it safe and avoid checking matchgroup[k] if its score is < p->score (so we don't accidentally delete the higher scoring matchgroup)
	  if((REFSPLIT_FIX <= 0 /* WAS7 1 */ || MultiMatchesTotScore) && !(q->score >= p->score)){// NEW
	    k = j;/* matchgroup[i] will be kept since all higher scoring matchgroups have been checked */
	    break;
	  }
#endif

	  int I2 = q->I;
	  int K2 = q->K;
	  int J2 = q->J;
	  int IL2 = q->IL; // A->IL(I2,K2,J2);
	  int KL2 = q->KL; // A->KL(I2,K2,J2);
	  int JL2 = q->JL; // A->JL(I2,K2,J2);

	  if(MULTIMATCHES_FIX){

	    if(J >= J2 + MultiMatches && JL2 + MultiMatches <= JL)
	      continue;/* at least MultiMatches shift right in labels in Query at both ends */
	    if(JL + MultiMatches <= JL2 && J2 >= J + MultiMatches)
	      continue;/* at least MultiMatches shift left in labels in Query at both ends */
	    if(I >= I2 + MultiMatches && IL2-KL2 + MultiMatches <= IL-KL)
	      continue;/* at least MultiMatches distinct labels in Reference at both ends */
	    if(IL-KL + MultiMatches <= IL2-KL2 && I2 >= I + MultiMatches)
	      continue;/* at least MultiMatches distinct labels in Reference at both ends */

	  } else {

	    if(J >= (max(J2,JL)) + MultiMatches && JL2 + MultiMatches <= (min(J2,JL)))
	      continue;/* at least MultiMatches distinct labels in Query at both ends */
	    if(JL + MultiMatches <= (min(J,JL2)) && J2 >= (max(J,JL2)) + MultiMatches)
	      continue;/* at least MultiMatches distinct labels in Query at both ends */
	    if(I >= (max(I2,IL-KL)) + MultiMatches && IL2-KL2 + MultiMatches <= (min(I2,IL-KL)))
	      continue;/* at least MultiMatches distinct labels in Reference at both ends */
	    if(IL-KL + MultiMatches <= (min(I,IL2-KL2)) && I2 >= (max(I,IL2-KL2)) + MultiMatches)
	      continue;/* at least MultiMatches distinct labels in Reference at both ends */
          }

	  int tI2 = -1, U2 = -1;

	  if(MultiMatchesDelta > 0.0){
	    /* check if offset is different at both alignment ends by at least MultiMatchesDelta kb (in same direction) */
	    double offsetL2 = Yc(Y,IL2,KL2) - X[JL2];
	    double offsetR2 = Yc(Y,I2,K2) - X[J2];
	    if(min(offsetL2 - offsetL, offsetR2 - offsetR) > MultiMatchesDelta)  
	      continue;
	    if(min(offsetL - offsetL2, offsetR - offsetR2) > MultiMatchesDelta)  
	      continue;

	    if(DEBUG && MULTIMATCH_TRIM && MultiMatchesTotScore>=2) assert(p->maxoutlier >= 0.0 && q->maxoutlier >= 0.0);

	    if(PVERB>=3&& I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
	      if(MultiMatchesTotScore >= 2)
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,score=%0.6f,logPV=%0.2f,maxOut=%0.3f,offsetL=%0.4f,offsetR=%0.4f:k=%d,I2=%d,K2=%d,J2=%d,IL2=%d,KL2=%d,JL2=%d,score2=%0.6f,logPV2=%0.2f,maxout2=%0.3f,offsetL2=%0.4f,offsetR2=%0.4f\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,i,I,K,J,IL,KL,JL,p->score,p->logPV,p->maxoutlier,offsetL,offsetR,k,I2,K2,J2,IL2,KL2,JL2,q->score,q->logPV,q->maxoutlier,Yc(Y,IL2,KL2)-X[JL2],Yc(Y,I2,K2)-X[J2]);
	      else
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,score=%0.6f,logPV=%0.2f,offsetL=%0.4f,offsetR=%0.4f:k=%d,I2=%d,K2=%d,J2=%d,IL2=%d,KL2=%d,JL2=%d,score2=%0.6f,logPV2=%0.2f,offsetL2=%0.4f,offsetR2=%0.4f\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,i,I,K,J,IL,KL,JL,p->score,p->logPV,offsetL,offsetR,k,I2,K2,J2,IL2,KL2,JL2,q->score,q->logPV,Yc(Y,IL2,KL2)-X[JL2],Yc(Y,I2,K2)-X[J2]);
	      printf("\t A->IL(I,K,J)=%d(KL=%d,JL=%d), A->IL(I2,K2,J2)=%d(KL=%d,JL=%d)\n",A->IL(I,K,J),A->KL(I,K,J),A->JL(I,K,J),A->IL(I2,K2,J2),A->KL(I2,K2,J2),A->JL(I2,K2,J2));
	      fflush(stdout);

	      if(DEBUG && MULTIMATCH_TRIM && MultiMatchesTotScore>=2) assert(p->maxoutlier >= 0.0 && q->maxoutlier >= 0.0);
	    }

	    /* check if left ends of alignments are the same : If so try to truncate left end of alignment[i] to remove the common portion and recheck */
	    if(MULTIMATCH_TRIM && ((A->IL(I,K,J) == A->IL(I2,K2,J2) && A->KL(I,K,J) == A->KL(I2,K2,J2) && A->JL(I,K,J) == A->JL(I2,K2,J2)) || DEBUG>=2) &&
	       (fabs(offsetR2 - offsetR) > MultiMatchesDelta || (MultiMatchesTotScore>=2 && max(p->maxoutlier,q->maxoutlier) > MultiMatchesTotDelta))){/* Check for shared left end of alignment[i] */
	      if(PVERB>=3 && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){		
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,k=%d,p->score=%0.6f,q->score=%0.6f: Will try to truncate left end of alignment[i] (p)\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,i,k,p->score,q->score);
		fflush(stdout);
	      }
	      //	      MultiMatchTrimCnt++;

	      if(tI2 < 0){
		tI2 = I2;
		U2 = alignExtract(A, tI2, K2, J2, q->R, A->Tscore(I2,K2,J2), Y,X,N,M,Ilist2,Klist2,Jlist2,iscore2,outscore2, rmap,nanomap,refid,mapid, orientation,rev,scaleID,0,IL2);
	      }

	      /* locate rightmost aligned site of alignment[i] that matches an aligned site in alignment[k] (if any)*/
	      int r1 = U-1;
	      int r2 = U2-1;
	      while(r1 >= 0 && r2 >= 0){
		if(Ilist[U-1-r1] < Ilist2[U2-1-r2]){
		  r2--;
		  continue;
		}
		if(Ilist[U-1-r1] > Ilist2[U2-1-r2]){
		  r1--;
		  continue;
		}
		if(Jlist[U-1-r1] < Jlist2[U2-1-r2]){
		  r2--;
		  continue;
		}
		if(Jlist[U-1-r1] > Jlist2[U2-1-r2]){
		  r1--;
		  continue;
		}
		if(Klist[U-1-r1] == Klist2[U2-1-r2])/* overlap match found */
		  break;
		if(r1 > 0)
		  r1--;
		else
		  r2--;
	      }

	      if(DEBUG>=2 && r1 >= 0 && r2 >= 0) assert(Ilist[U-1-r1] == Ilist2[U2-1-r2] && Jlist[U-1-r1] == Jlist2[U2-1-r2] && Klist[U-1-r1] == Klist2[U2-1-r2]);

	      if(DEBUG>=2 && r1 >= 0 && r2 >= 0) assert(A->IL(I,K,J) == A->IL(I2,K2,J2) && A->KL(I,K,J) == A->KL(I2,K2,J2) && A->JL(I,K,J) == A->JL(I2,K2,J2));

	      /* recompute offsetR,offsetR2 based on nearby (on reference) aligned labels */
	      double CoffsetR = offsetR, CoffsetR2 = offsetR2;
	      int Cr1 = r1, Cr2 = r2;
	      if(1){
		int r1 = U-1, r2 = U2-1;
		if(Ilist[U-1-r1] < Ilist2[U2-1-r2]){/* decrease r2 until labels on reference are as close as possible */
		  while(r2 > 0){
		    if(Ilist[U-1-r1] < Ilist2[U2-r2]){
		      r2--;
		      continue;
		    }
		    if(fabs(Yc(Y,Ilist[U-1-r1],Klist[U-1-r1]) - Yc(Y,Ilist2[U2-1-r2],Klist2[U2-1-r2])) > fabs(Yc(Y,Ilist[U-1-r1],Klist[U-1-r1]) - Yc(Y,Ilist2[U2-r2],Klist2[U2-r2])))
		      r2--;
		    break;
		  }
		} else {/* decrease r1 until labels on reference are as close as possible */
		  while(r1 > 1){
		    if(Ilist[U-r1] > Ilist2[U2-1-r2]){
		      r1--;
		      continue;
		    }
		    if(fabs(Yc(Y,Ilist[U-1-r1],Klist[U-1-r1]) - Yc(Y,Ilist2[U2-1-r2],Klist2[U2-1-r2])) > fabs(Yc(Y,Ilist[U-r1],Klist[U-r1]) - Yc(Y,Ilist2[U2-1-r2],Klist2[U2-1-r2])))
		      r1--;
		    break;
		  }
		}
		CoffsetR = Yc(Y,Ilist[U-1-r1],Klist[U-1-r1]) - X[Jlist[U-1-r1]];
		CoffsetR2 = Yc(Y,Ilist2[U2-1-r2],Klist2[U2-1-r2]) - X[Jlist2[U2-1-r2]];
		Cr1 = r1;
		Cr2 = r2;
	      }

	      if(MULTIMATCH_TRIMFIX && r1 == 0 && r2 >= 0 /* && Ilist[U-1-r1] == Ilist2[U2-1-r2] && Jlist[U-1-r1] == Jlist2[U2-1-r2] && Klist[U-1-r1] == Klist2[U2-1-r2] */){
		// This is needed to avoid infinite loop, since "trimmed" off matchgroup[i] would be unchanged
		if((PVERB/* HERE >=3 */) || (DEBUG>=1+RELEASE && p->IL == A->IL(I,K,J) /* WAS p->IL < 0 */ && !(fabs(p->score - A->Tscore(I,K,J)) < 1e-5))){		
#pragma omp critical
		  {
		    if(fabs(CoffsetR2 - CoffsetR) > MultiMatchesDelta)
		      printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,k=%d,j=%d,I=%d,K=%d,J=%d:U=%d,U2=%d,r1=%d,r2=%d:IKJ[U-1-r1]=%d,%d,%d, Cr1=%d,Cr2=%d, CoffsetR=%0.3f,%0.3f: preserving matchgroup[i]\n",
			     refid,rmap->id,mapid,nanomap->id,orientation,i,k,j,I,K,J,U,U2,r1,r2,Ilist[U-1-r1],Klist[U-1-r1],Jlist[U-1-r1],Cr1,Cr2,CoffsetR,CoffsetR2);

		    else
		      printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,k=%d,j=%d,I=%d,K=%d,J=%d:U=%d,U2=%d,r1=%d,r2=%d:IKJ[U-1-r1]=%d,%d,%d, Cr1=%d,Cr2=%d, CoffsetR=%0.3f,%0.3f: discarding matchgroup[i]\n",
			     refid,rmap->id,mapid,nanomap->id,orientation,i,k,j,I,K,J,U,U2,r1,r2,Ilist[U-1-r1],Klist[U-1-r1],Jlist[U-1-r1],Cr1,Cr2,CoffsetR,CoffsetR2);

		    printf("\tIL= %d, A->IL(I,K,J)= %d, p->score= %0.8f, A->Tscore(I,K,J)= %0.8f\n",p->IL, A->IL(I,K,J), p->score, A->Tscore(I,K,J));
		    fflush(stdout);
		    if(DEBUG>=2 /* HERE HERE 1+RELEASE */ && p->IL == A->IL(I,K,J) /* WAS p->IL < 0 */) assert(fabs(p->score - A->Tscore(I,K,J)) < 1e-5);// untrimmed score should match original score
		  }
		}

		if(fabs(CoffsetR2 - CoffsetR) > MultiMatchesDelta)
		  continue; // next k

		break;// discard matchgroup[i]
	      }


	      RFLOAT deltascore = -1e+37;
	      int T = r1;

	      if(r1 > 0 && r2 > 0 && U - r1 -1 >= 1 && MultiMatchesTotScore){/* try to maximize total score : check if matchgroup[k] has a gap just left of r2 and would improve score (from trimming) more than matchgroup[i] */
		RFLOAT origdeltascore = -1e+37;
		int bT = T;
		for(; T < U; T++){
		  int nIL = Ilist[U-1-T];
		  int nKL = Klist[U-1-T];
		  int nJL = Jlist[U-1-T];
		  if(DEBUG>=2) assert(0 <= nKL && 1 <= nIL - nKL && nIL <= N);
		  if(DEBUG>=2) assert(1 <= nJL && nJL <= M);
		  RFLOAT ndeltascore = A->Uscore(nIL,nKL,nJL) - A->score(nIL,nKL,nJL);
		  if(ndeltascore > deltascore){
		    bT = T;
		    deltascore = ndeltascore;
		    if(T == r1)
		      origdeltascore = deltascore;
		  }
		  if(PVERB>=3){
#pragma omp critical
		    {
		      printf("    T=%d/%d:nIL=%d,nKL=%d,nJL=%d:score=%0.6f->%0.6f(bT=%d,bscore=%0.6f)\n",T,U,nIL,nKL,nJL,p->score,p->score+ndeltascore,bT,A->Tscore(I,K,J) + deltascore);
		      fflush(stdout);
		    }
		  }
		}
		T = bT;
		if(DEBUG) assert(T >= r1);

                RFLOAT deltascore2 = -1e+37, origdeltascore2 = -1e+37;
		int T2 = r2, minT2 = r2;
		int bT2 = T2;
		for(; T2 < U2; T2++){
		  int nIL2 = Ilist2[U2-1-T2];
		  int nKL2 = Klist2[U2-1-T2];
		  int nJL2 = Jlist2[U2-1-T2];
		  if(DEBUG>=2) assert(0 <= nKL2 && 1 <= nIL2-nKL2 && nIL2 <= N);
		  if(DEBUG>=2) assert(1 <= nJL2 && nJL2 <= M);
		  RFLOAT ndeltascore2 = A->Uscore(nIL2,nKL2,nJL2) - A->score(nIL2,nKL2,nJL2);
		  if(ndeltascore2 > deltascore2){
		    bT2 = T2;
		    deltascore2 = ndeltascore2;
		    if(T2 == r2)
		      origdeltascore2 = deltascore2;
		    else if(minT2 == r2) /* NEW */
		      minT2 = T2;/* first T2 value > r2 that improves truncation score (used to avoid needless breakup of matchgroup[k] at internal outliers) */
		  }
		  if(PVERB>=3){
#pragma omp critical
		    {
		      printf("    T2=%d/%d:nIL2=%d,nKL2=%d,nJL2=%d:score2=%0.6f->%0.6f(bT2=%d,bscore2=%0.6f)\n",T2,U2,nIL2,nKL2,nJL2,q->score,q->score+ndeltascore2,bT2,A->Tscore(I2,K2,J2) + deltascore2);
		      fflush(stdout);
		    }
		  }
		}
		T2 = bT2;
		if(DEBUG) assert(T2 >= r2);

		// If MultiMatchesTotScore >= 2, make sure trimming of q is due to an outlier of at least MultiMatchesTotDelta (rather than misaligned labels), to avoid unecessary breaking up of q
		double TrimOutlier2 = -1.0;
		if(MultiMatchesTotScore>=2){
		  int lastI2 = Ilist2[U2-1-r2];
		  int lastK2 = Klist2[U2-1-r2];
		  int lastJ2 = Jlist2[U2-1-r2];

		  int I2 = Ilist2[U2-1-T2];
		  int K2 = Klist2[U2-1-T2];
		  int J2 = Jlist2[U2-1-T2];
		  
		  double x = X[J2] - X[lastJ2];
		  double y = Yc(Y,I2,K2) - Yc(Y,lastI2,lastK2);
		  TrimOutlier2 = fabs(x-y);
		}

		/* make sure matchgroup[i] does not have a -ve scoring right end (at or right of merge point r1) that would make it inferior to a truncated version : If so don't break the larger matchgroup[k] */
		double maxPscore = p->score;
		int maxT = U-1;
		for(int t = U-1; --t >=r1;){
		  int nI = Ilist[U-1-t];
		  int nK = Klist[U-1-t];
		  int nJ = Jlist[U-1-t];
		  if(A->Tscore(nI,nK,nJ) > maxPscore){
		    maxPscore = A->Tscore(nI,nK,nJ);
		    maxT = t;
		  }
		}

		if(PVERB>=3 && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE && MultiMatchesTotScore){		
		  if(MultiMatchesTotScore >= 2)
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,k=%d,I=%d,K=%d,J=%d:U=%d,U2=%d,r1=%d,r2=%d:I(r1)=%d,K(r1)=%d,J(r1)=%d:delscore2=%0.6f(T2=%d),|x2-y2|=%0.3f,minT2=%d,delscore=%0.6f(T=%d),maxP=%0.6f(maxT=%d)\n",
			   refid,rmap->id,mapid,nanomap->id,orientation,i,k,I,K,J,U,U2,r1,r2,Ilist[U-1-r1],Klist[U-1-r1],Jlist[U-1-r1],deltascore2-origdeltascore2,T2,TrimOutlier2,minT2,
			   deltascore-origdeltascore,T,maxPscore - p->score, maxT);
		  else
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,k=%d,I=%d,K=%d,J=%d:U=%d,U2=%d,r1=%d,r2=%d:I(r1)=%d,K(r1)=%d,J(r1)=%d:delscore2=%0.6f(T2=%d),minT2=%d,delscore=%0.6f(T=%d),maxP=%0.6f(maxT=%d)\n",
			   refid,rmap->id,mapid,nanomap->id,orientation,i,k,I,K,J,U,U2,r1,r2,Ilist[U-1-r1],Klist[U-1-r1],Jlist[U-1-r1],deltascore2-origdeltascore2,T2,minT2,deltascore-origdeltascore,T,maxPscore - p->score, maxT);
		  fflush(stdout);
		}

		if(deltascore2 - origdeltascore2 > deltascore - origdeltascore + 0.001 && U - T - 1 >= T2 - minT2 /* WAS minT2 - r2*/ /* + 1 */ && maxT == U-1
		   && (MultiMatchesTotScore < 2 || TrimOutlier2 >= MultiMatchesTotDelta)){/* keep matchgroup[i] and truncate matchgroup[k] */

		  // truncate unique right portion of matchgroup[k] at left side if score can be improved (but not with RefSplitStitch, unless original score was <  biasend2_values[JL]
		  if(RefSplitStitch >= 2){/* otherwise we already computed the best truncation */
		    int bT2 = T2;
		    for(; T2 < U2; T2++){
		      int nIL2 = Ilist2[U2-1-T2];
		      int nKL2 = Klist2[U2-1-T2];
		      int nJL2 = Jlist2[U2-1-T2];
		      if(DEBUG>=2) assert(0 <= nKL2 && 1 <= nIL2-nKL2 && nIL2 <= N);
		      if(DEBUG>=2) assert(1 <= nJL2 && nJL2 <= M);
		      RFLOAT ndeltascore2 = A->Uscore(nIL2,nKL2,nJL2) - A->score(nIL2,nKL2,nJL2);
		      if(ndeltascore2 > deltascore2){
			bT2 = T2;
			deltascore2 = ndeltascore2;
		      }
		      if(PVERB>=3){
#pragma omp critical
			{
			  printf("    T2=%d/%d:nIL2=%d,nKL2=%d,nJL2=%d:score2=%0.6f->%0.6f(bT2=%d,bscore2=%0.6f)\n",T2,U2,nIL2,nKL2,nJL2,q->score,q->score+ndeltascore2,bT2,A->Tscore(I2,K2,J2) + deltascore2);
			  fflush(stdout);
			}
		      }
		      if(RefSplitStitch>=2 && T2==r2 && A->Tscore(I2,K2,J2) + deltascore > biasend2_values[nJL2])
			break;// don't trim 
		    }
		    T2 = bT2;
		    if(DEBUG) assert(T2 >= r2);
		  }

		  int nIL2 = Ilist2[U2-1-T2];
		  int nKL2 = Klist2[U2-1-T2];
		  int nJL2 = Jlist2[U2-1-T2];
		  if(DEBUG) assert(0 <= nKL2 && 1 <= nIL2 - nKL2 && nIL2 <= N);
		  if(DEBUG) assert(1 <= nJL2 && nJL2 <= M);

		  int qchanged = 0;// NOTE : 0 means delete q, 1 means save q (matchgroup[k])

		  if((RefSplitStitch>=2 && T2 == r2) || (U2-T2 >= AlignedSiteThreshold2 && (REFSPLIT_FIX || A->Tscore(I2,K2,J2) + deltascore2 >= ScoreThreshold2))){
		    RFLOAT pdeltascore2 = A->Uscore(IL2,KL2,JL2) - A->score(IL2,KL2,JL2);

		    if((PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE) || (DEBUG && !REFSPLIT_FIX && !(RefSplitStitch >= 2 && q->stitch) && !(q->IL == A->IL(I2,K2,J2) /* WAS q->IL < 0 */ ? (deltascore2 <= 1e-6) : (deltascore2 <= pdeltascore2 + 1e-6))) ){		
#pragma omp critical
		      {
			printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,k=%d,I2=%d,K2=%d,J2=%d,IL2=%d->%d,KL2=%d->%d,JL2=%d->%d,Tscore(I2,K2,J2)=%0.6f,delta2=%0.6f->%0.6f,score2=%0.6f->%0.6f,(U=%d,r1=%d,U2=%d->%d,T2(r2)=%d->%d):keeping MG i, truncated MG k\n",
			       refid,rmap->id,mapid,nanomap->id,orientation,i,k,I2,K2,J2,IL2,nIL2,KL2,nKL2,JL2,nJL2,A->Tscore(I2,K2,J2),pdeltascore2,deltascore2,q->score,A->Tscore(I2,K2,J2) + deltascore2,U,r1,U2,U2-T2,r2,T2);
			fflush(stdout);

			if(DEBUG && !(REFSPLIT_FIX>=2 && RefSplit)/* NEW17 */ && q->IL == A->IL(I2,K2,J2) /* WAS q->IL < 0 */) assert(deltascore2 <= 1e-6);// first truncation should make total score get worse
			if(DEBUG && !(REFSPLIT_FIX>=2 && RefSplit)/* NEW17 */ && RefSplitStitch < 2 && q->IL != A->IL(I2,K2,J2) /* WAS q->IL >= 0 */) assert(deltascore2 <= pdeltascore2 + 1e-6);// further truncation should make total score get worse  unless MatchgroupRefSplit() merged outliers AND split alignments 
		      }
		    }

		    if(DEBUG) assert(!(q->IL == nIL2 && q->KL == nKL2 && q->JL == nJL2));/* make sure q is actually going to change (be truncated) */

		    q->IL = nIL2;
		    q->KL = nKL2;
		    q->JL = nJL2;
		    if(DEBUG>=2){
		      double Uscore = A->Uscore(q->IL,q->KL,q->JL);
		      double Ascore = A->score(q->IL,q->KL,q->JL);
		      if((/* TVERB */ PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE) ||
			 !(fabs(Uscore - Ascore - deltascore2) < ASCORE_MARGIN + fabs(deltascore2) * SCORE_MARGIN)){
#pragma omp critical
			{			
			  printf("refid=%d(%lld),mapid=%d(%lld),or=%d:I2=%d,K2=%d,J2=%d,IL2=%d->%d,KL2=%d,JL2=%d: matchgroup[k=%d].score= %0.6f -> %0.6f, A->Uscore(IL2,KL2,JL2)= %0.6f, A->score(IL2,KL2,JL2)= %0.6f, deltascore2= %0.6f (err= %0.6f)\n",
				 refid,rmap->id,mapid,nanomap->id,orientation,I2,K2,J2,A->IL(I2,K2,J2),q->IL,q->KL,q->JL,k,q->score, A->Tscore(I2,K2,J2) + deltascore2, Uscore,Ascore,deltascore, deltascore2 - (Uscore - Ascore));
			  fflush(stdout);
			  assert(fabs(Uscore - Ascore - deltascore2) < ASCORE_MARGIN + fabs(deltascore2) * SCORE_MARGIN);
			}
		      }
		    }
		    q->score = A->Tscore(I2,K2,J2) + deltascore2;
		    if(RefSplitStitch && T2 == r2)
		      q->stitch = 1;
		    qchanged = 1;
		  } // else delete matchgroup[k] since qchanged = 0

		  // move matchgroup[k] out of matchgroup[0..j-1], decreasing j
		  Cmatchgroup tmp = *q, Ptmp = *p;
		  j--;
		  for(int t = k; t < j; t++)
		    matchgroup[t] = matchgroup[t+1];

		  int t = 0;
		  if(qchanged){// add tmp (original matchgroup[k]) to matchgroup[i .. nummatchgroup-1], decreasing i by 1
		    i--;
		    if(DEBUG) assert(i >= j); /* matchgroup[i] is now a previously discarded matchgroup OR i == j and matchgroup[j+1] was just copied to matchgroup[j] */

		    for(t = i+1; t < nummatchgroup; t++){
		      if(tmp.score >= matchgroup[t].score)
			break;
		      matchgroup[t-1] = matchgroup[t];
		    }
		    matchgroup[t-1] = tmp;
		    if(PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
#pragma omp critical
		      {
			printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d->%d,j=%d->%d,moved matchgroup[k=%d] to matchgroup[%d] : both original matchgroup[i] and matchgroup[k] will be rechecked against higher scoring matchgroups\n",
			       refid,rmap->id,mapid,nanomap->id,orientation,i+1,i,j+1,j,k,t-1);
			fflush(stdout);		    
		      }
		    }
		  } else {
		    if(PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
                      #pragma omp critical
		      {
			if(j==0)
			  printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:j=%d->%d, i=%d: deleted matchgroup[k=%d]\n",
				 refid,rmap->id,mapid,nanomap->id,orientation,rev,j+1,j,i,k);
			else
			  printf("refid=%d(%lld),mapid=%d(%lld),or=%d:j=%d->%d, i=%d: deleted matchgroup[k=%d] : will continue checking matchgroup[i] against higher scoring matchgroups\n",
				 refid,rmap->id,mapid,nanomap->id,orientation,j+1,j,i,k);
			fflush(stdout);		    
		      }
		    }
		  }

		  if(j==0){/* special case : restart outer loop */
		    if((PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE) || (DEBUG && !(!pchanged && j <= i && j <= k))){
                      #pragma omp critical
		      {
			printf("refid=%d(%lld),mapid=%d(%lld),or=%d:moving matchgroup[%d] to matchgroup[0] : continuing outer loop at j=1,i=%d\n", refid,rmap->id,mapid,nanomap->id,orientation,i,i+1);
			fflush(stdout);		    
			if(DEBUG) assert(!pchanged && j <= i && j <= k);
		      }
		    }
		    break;/*  k >= j && j <= i will force copy of matchgroup[i] to matchgroup[j] and increment j to 1 and then continue with next i in outer loop */
		  }

		  // matchgroup[i] may have changed : restart at top of i loop (if matchgroup[i] has changed) or continue at previous k (otherwise)
		  if(qchanged && t-1 == i)
		    goto Lrepeati;// NOTE : this is needed so that p and all related variables (U,I,K,J etc) are updated, since matchgroup[i] is not the same matchgroup as before
		  
		  p = &matchgroup[i];/* If qchanged : original matchgroup[i] was shift left by one slot, so p needs to be updated */
		  if(DEBUG>=2) assert(Ptmp.I == matchgroup[i].I && Ptmp.K == matchgroup[i].K && Ptmp.J == matchgroup[i].J && Ptmp.IL == matchgroup[i].IL);
		  k--;
		  continue;
		}
	      }

	      if(r1 > 0 && r2 >=0 && U - r1 - 1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2)){/* rightmost overlap match found (except r1==0) AND unique right portion of matchgroup[i] is large enough to save */
		if(DEBUG) assert(p->IL >= 0);// Why is p->IL < 0 checked below ? Instead use p->IL == A->IL(I,K,J)

		if((PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE) || (DEBUG>=2 && p->IL == A->IL(I,K,J) /* WAS p->IL < 0 */ && !(fabs(p->score - A->Tscore(I,K,J)) < SCORE_MARGIN))){		
#pragma omp critical
		  {
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,k=%d,I=%d,K=%d,J=%d:U=%d,U2=%d,r1=%d,r2=%d:Ilist[U-1-r1]=%d,Klist[U-1-r1]=%d,Jlist[U-1-r1]=%d: truncating MG i\n",
			   refid,rmap->id,mapid,nanomap->id,orientation,i,k,I,K,J,U,U2,r1,r2,Ilist[U-1-r1],Klist[U-1-r1],Jlist[U-1-r1]);
		    printf("    p->IL= %d, A->IL(I,K,J)= %d, p->score= %0.8f, A->Tscore(I,K,J)= %0.8f\n",p->IL, A->IL(I,K,J), p->score, A->Tscore(I,K,J));
		    fflush(stdout);
		    if(DEBUG>=2 && p->IL == A->IL(I,K,J) /* WAS p->IL < 0 */) assert(fabs(p->score - A->Tscore(I,K,J)) < SCORE_MARGIN);// untrimmed score should match original score
		  }
		}

		// truncate unique right portion of matchgroup[i] at left side if score can be improved (but not with RefSplitStitch, unless original score was <  biasend2_values[JL]
		if(!(MultiMatchesTotScore && r2 > 0) || RefSplitStitch >= 2){/* otherwise we already computed the best truncation */
		  int bT = T;
		  for(; T < U; T++){
		    int nIL = Ilist[U-1-T];
		    int nKL = Klist[U-1-T];
		    int nJL = Jlist[U-1-T];
		    if(DEBUG>=2) assert(0 <= nKL && 1 <= nIL - nKL && nIL <= N);
		    if(DEBUG>=2) assert(1 <= nJL && nJL <= M);
		    RFLOAT ndeltascore = A->Uscore(nIL,nKL,nJL) - A->score(nIL,nKL,nJL);
		    if(ndeltascore > deltascore){
		      bT = T;
		      deltascore = ndeltascore;
		    }
		    if(PVERB>=3){
#pragma omp critical
		      {
		        printf("    T=%d/%d:nIL=%d,nKL=%d,nJL=%d:score=%0.6f->%0.6f(bT=%d,bscore=%0.6f)\n",T,U,nIL,nKL,nJL,p->score,p->score+ndeltascore,bT,A->Tscore(I,K,J) + deltascore);
			fflush(stdout);
		      }
		    }
		    if(RefSplitStitch>=2 && T==r1 && A->Tscore(I,K,J) + deltascore > biasend2_values[nJL])
		      break;// don't trim 
		  }
		  T = bT;
		}

		int nIL = Ilist[U-1-T];
		int nKL = Klist[U-1-T];
		int nJL = Jlist[U-1-T];
		if(DEBUG) assert(0 <= nKL && 1 <= nIL - nKL && nIL <= N);
		if(DEBUG) assert(1 <= nJL && nJL <= M);

		if((RefSplitStitch>=2 && T == r1) || (U-T >= AlignedSiteThreshold2 && (REFSPLIT_FIX || A->Tscore(I,K,J) + deltascore >= ScoreThreshold2))){
		  RFLOAT pdeltascore = A->Uscore(IL,KL,JL) - A->score(IL,KL,JL);

		  if((PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE) || 
		     (DEBUG && !REFSPLIT_FIX && !(RefSplitStitch>=2 && p->stitch) && !(p->IL == A->IL(I,K,J) /* WAS < 0 */ ? (deltascore <= 1e-6) : (deltascore <= pdeltascore + 1e-6))) ){		
#pragma omp critical
		    {
		      printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,I=%d,K=%d,J=%d,IL=%d->%d,KL=%d->%d,JL=%d->%d,Tscore(I,K,J)=%0.6f,delta=%0.6f->%0.6f,score=%0.6f->%0.6f,(U=%d->%d,T=%d->%d,U2=%d,r2=%d),k=%d:keeping truncated MG i\n",
			     refid,rmap->id,mapid,nanomap->id,orientation,i,I,K,J,IL,nIL,KL,nKL,JL,nJL,A->Tscore(I,K,J),pdeltascore,deltascore,p->score,A->Tscore(I,K,J) + deltascore,U,U-T,r1,T,U2,r2,k);
		      printf("    offsetL=%0.3f->%0.3f,offsetR=%0.3f,offsetL2=%0.3f,offsetR2=%0.3f:\n",offsetL, Yc(Y,nIL,nKL) - X[nJL], offsetR,offsetL2,offsetR2);
		      fflush(stdout);

		      if(DEBUG && p->IL == A->IL(I,K,J) /* WAS p->IL < 0 */) assert(deltascore <= 1e-6);// first truncation should make total score get worse
		      if(DEBUG && RefSplitStitch < 2 && p->IL != A->IL(I,K,J) /* WAS p->IL >= 0 */) assert(deltascore < pdeltascore + 1e-6);// further truncation should make total score get worse
		    }
		  }

		  if(!(p->IL == nIL && p->KL == nKL && p->JL == nJL)){
		    pchanged = 1;
		    p->IL = nIL;
		    p->KL = nKL;
		    p->JL = nJL;
		    if(DEBUG>=2){
		      double Uscore = A->Uscore(p->IL,p->KL,p->JL);
		      double Ascore = A->score(p->IL,p->KL,p->JL);
		      if((/* TVERB */PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE) ||
			 !(fabs(Uscore - Ascore - deltascore) < ASCORE_MARGIN + fabs(deltascore) * SCORE_MARGIN)){
#pragma omp critical
			{			
			  printf("refid=%d(%lld),mapid=%d(%lld),or=%d:I=%d,K=%d,J=%d,IL=%d->%d,KL=%d,JL=%d: matchgroup[i=%d].score= %0.6f -> %0.6f, A->Uscore(IL,KL,JL)= %0.6f, A->score(IL,KL,JL)= %0.6f, deltascore= %0.6f (err= %0.6f)\n",
				 refid,rmap->id,mapid,nanomap->id,orientation,I,K,J,A->IL(I,K,J),p->IL,p->KL,p->JL,i,p->score,A->Tscore(I,K,J) + deltascore, Uscore,Ascore,deltascore, deltascore - (Uscore - Ascore));
			  fflush(stdout);
			  assert(fabs(Uscore - Ascore - deltascore) < ASCORE_MARGIN + fabs(deltascore) * SCORE_MARGIN);
			}
		      }
		    }
		    p->score = A->Tscore(I,K,J) + deltascore;// deltascore == (IL != A->IL(IL,KL,JL)) ? A->Uscore(IL,KL,JL) - A->score(IL,KL,JL) : 0.0
		    if(RefSplit && T == r1)
		      p->stitch = 1;
		  }

		  // NOTE : change in score could be either caused by trimming OR due to correction in p->score (which would be small)
		  if(i+1 < nummatchgroup && p->score < matchgroup[i+1].score){	// need to re-sort matchgroup[i .. nummatchgroup-1], since matchgroup[i].score has decreased

		    Cmatchgroup tmp = *p;
		    int t = i+1;
		    for(; t < nummatchgroup; t++){
		      if(tmp.score >= matchgroup[t].score)
			break;
		      matchgroup[t-1] = matchgroup[t];
		    }
		    if(t > i+1){
		      matchgroup[t-1] = tmp;
		      pchanged = 1;

		      if(PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){		
#pragma omp critical
			{
			  printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d:    moved matchgroup[%d] to matchgroup[%d] due to score reduction\n",
				 refid,rmap->id,mapid,nanomap->id,orientation,i,i,t-1);
			  fflush(stdout);
			}
		      }
		    }
		  }

		  break;// found non-overlapping part of alignment that is above threshold : pchanged == 1 (matchgroup[i] will be saved)
	        } 
	      } // if(r1 > 0 && r2 > 0 ... )
	    }
	  }// if(MultiMatchesDelta > 0.0)

          // matchgroup[i] was not sufficiently unique relative to matchgroup[k] and will be deleted (break out of k loop with pchanged == 0 && k < j)

	  if(PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE && !pchanged){
#pragma omp critical
	    {
	      if(MultiMatchesTotScore >= 2)
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,score=%0.6f,logPV=%0.2f,maxOut=%0.3f,offsetL=%0.4f,offsetR=%0.4f:k=%d,I2=%d,K2=%d,J2=%d,IL2=%d,KL2=%d,JL2=%d,score2=%0.6f,logPV2=%0.2f,maxout2=%0.3f:offsetL2=%0.4f,offsetR2=%0.4f:Deleting matchgroup[%d]\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,i,I,K,J,IL,KL,JL,p->score,p->logPV,p->maxoutlier,offsetL,offsetR,k,I2,K2,J2,IL2,KL2,JL2,q->score,q->logPV,q->maxoutlier,Yc(Y,IL2,KL2)-X[JL2],Yc(Y,I2,K2)-X[J2],i);
	      else
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,score=%0.6f,logPV=%0.2f,offsetL=%0.4f,offsetR=%0.4f:k=%d,I2=%d,K2=%d,J2=%d,IL2=%d,KL2=%d,JL2=%d,score2=%0.6f,logPV2=%0.2f,offsetL2=%0.4f,offsetR2=%0.4f:Deleting matchgroup[%d]\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,i,I,K,J,IL,KL,JL,p->score,p->logPV,offsetL,offsetR,k,I2,K2,J2,IL2,KL2,JL2,q->score,q->logPV,Yc(Y,IL2,KL2)-X[JL2],Yc(Y,I2,K2)-X[J2],i);
	      if(PVERB>=3 && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
		int numpairs = -1, Lend= -1;
		if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
		double logPV = alignFPsd(A,p->I,p->J,p->K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid, 0, (PVERB>=2) ? 1 : 0, numpairs, Lend,p->IL, 0,0);// iscore,outscore,Ilist,Klist,Jlist,outlier);
		printf("logPV=%0.2f,U2=%d,numpairs2=%d:\n",logPV,U,numpairs);

		//	    fflush(stdout);
		for(int T = 0; T < U; T++){
		  int I = Ilist[U-1-T];
		  int K = Klist[U-1-T];
		  int J = Jlist[U-1-T];
		  RFLOAT iscoreT = iscore[U-T];
		  RFLOAT outscoreT = outscore[U-T];
		  RFLOAT Ascore = A->score(I,K,J);
		  if(T > 0)
		    printf("T=%d:I=%d,K=%d,J=%d:x=%0.4f,y=%0.4f:iscore=%0.6f,outscore=%0.6f,A:score=%0.6f\n",
			   T,I,K,J,Yc(Y,I,K)-Yc(Y,Ilist[U-T],Klist[U-T]),X[J]-X[Jlist[U-T]],iscoreT,outscoreT,Ascore);
		  else
		    printf("T=%d:I=%d,K=%d,J=%d:iscore=%0.6f,outscore=%0.6f,A:score=%0.6f\n",
			   T,I,K,J,iscoreT,outscoreT,Ascore);
		}
		printf("T=%d:iscore=%0.6f,outscore=%0.6f\n",U,iscore[0],outscore[0]);
	      }

	      fflush(stdout);
	    }
	  }

	  break;/* alignments are NOT distinct enough */
	}

	if(pchanged){/* matchgroup[i ... nummatchgroup-1] has been changed (trimmed) : need to recheck matchgroup[i] */
	  if(PVERB>=3 && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
#pragma omp critical
	    {
	      printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,score=%0.6f,offsetL=%0.4f,offsetR=%0.4f:k=%d:Rechecking matchgroup[%d]\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,i,I,K,J,IL,KL,JL,p->score,offsetL,offsetR,k,i);
	      fflush(stdout);
	    }
	  }

	  if(DEBUG) assert(p == &matchgroup[i]);// NEW17

	  if(j > 0 && matchgroup[i].score > matchgroup[j-1].score){// NEW17 : matchgroup[i]'s score increased. This can happen if MatchgroupRefSplit merged outliers AND split alignments
	    do {
	      /* move all matchgroups[j-1] into matchgroup[i..nummatchgroup-1], decreasing both i and j  */
	      j--;
	      i--;
	      Cmatchgroup tmp = matchgroup[j];

	      matchgroup[i] = matchgroup[i+1];
	      int t = i+2;
	      for(; t < nummatchgroup; t++){
		if(matchgroup[t].score <= tmp.score)
		  break;
		matchgroup[t-1] = matchgroup[t];
	      }
	      if(PVERB>=3 && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
	        #pragma omp critical
		{
		  printf("\t moved matchgroup[j-1= %d] (score= %0.6f) to matchgroup[%d] and matchgroup[i=%d] (score= %0.6f) to matchgroup[i-1]\n",j,tmp.score,t-1,i+1,matchgroup[i].score);
		  fflush(stdout);
		}
	      }
	      matchgroup[t-1] = tmp;
	    } while (j > 0 && matchgroup[i].score > matchgroup[j-1].score);
	  } else {
	    if(DEBUG) assert(k < j);
	  }

	  i--;
	  continue;/* repeat checking matchgroup[i+1] */
	}

	if(k < j){/* matchgroup[i] is not distinct and not changed (trimmed) : filter out matchgroup[i] */
	  if(PVERB>=3 && I_TRACE >= 0 && I==I_TRACE && K==K_TRACE && J==J_TRACE){
#pragma omp critical
	    {
	      printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,score=%0.6f,offsetL=%0.4f,offsetR=%0.4f:k=%d:Deleting matchgroup[%d]\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,i,I,K,J,IL,KL,JL,p->score,offsetL,offsetR,k,i);
	      fflush(stdout);
	    }
	  }
	  continue;// next i
	}

	if(j < i)
	  matchgroup[j] = matchgroup[i];
	if(MultiMatchesTotScore || REFSPLIT_FIX <= 0 /* WAS7 1 */){/* need to resort position of matchgroup[j] into proper location in matchgroup[0..j], since matchgroup[i] may have larger score than matchgroup[j-1] */
	  Cmatchgroup tmp = matchgroup[j];
	  int k = j - 1;
	  for(;k >= 0; k--){
	    if(matchgroup[k].score >= tmp.score)
	      break;
	    matchgroup[k+1] = matchgroup[k];
	  }
	  if(k+1 < j)
	    matchgroup[k+1] = tmp;
	} 
	j++;

	if(DEBUG>=1+RELEASE/* HERE >=2 */){
	  for(int t = 1; t < j; t++){
	    if(DEBUG && !(matchgroup[t].score <= matchgroup[t-1].score + 1e-6)){
	      printf("WARNING: tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:i=%d,k=%d,j=%d->%d,multicnt=%d: t=%d,matchgroup[t-1].score=%0.6f,matchgroup[t].score=%0.6f(err=%0.6f)\n",
		     tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,k,j-1,j,align->multicnt,t,matchgroup[t-1].score,matchgroup[t].score, matchgroup[t].score - matchgroup[t-1].score);
	      fflush(stdout);
	      
	      assert(matchgroup[t].score <= matchgroup[t-1].score + 1e-6);
	    }
	  }
	}
      } // for (int i = 0; i < nummatchgroup; i++)

      if(PVERB /**/ /* && j > 1 */){
#pragma omp critical
	{
	  printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:bestscore=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d:reduced %d matchgroups to %d distinct matchgroups (previous matchgroups=%d):wtime=%0.6f\n",
		 tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,bestIL,nummatchgroup,j, align->multicnt,wtime());

	  if(PVERB/* >=2 && refid==11 && mapid==1039 && orientation==0*/ ){
	    for(int i = 0; i < j; i++){
	      Cmatchgroup *p = &matchgroup[i];
	      int I = p->I;
	      int K = p->K;
	      int J = p->J;
	      int IL = A->IL(I,K,J);
	      int KL = A->KL(I,K,J);
	      int JL = A->JL(I,K,J);
	      int U, Lend;
	      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	      double logPV = alignFPsd(A,I,J,K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid,0, 0, U, Lend, p->IL, iscore,outscore,Ilist,Klist,Jlist,outlier);
	      if(MultiMatchesFilter)
		printf("   %d:I=%d,K=%d,J=%d,R=%d,IL=%d->%d,KL=%d->%d,JL=%d->%d(offset=%0.3f .. %0.3f,X=%0.1f..%0.1f):numpairs=%d, score= %0.6f -> %0.6f, LogPv= %0.2f -> %0.2f, Len= %0.1f\n",
		       i,I,K,J,p->R,IL,p->IL,KL,p->KL,JL,p->JL,Yc(Y,I,K)-X[J],Yc(Y,IL,KL)-X[JL],X[JL],X[J],  U, A->Tscore(I,K,J),p->score, p->logPV, logPV, Y[I] - Y[IL]);
	      else
		printf("   %d:I=%d,K=%d,J=%d,R=%d,IL=%d->%d,KL=%d->%d,JL=%d->%d(offset=%0.3f .. %0.3f,X=%0.1f..%0.1f):numpairs=%d, score= %0.6f -> %0.6f, LogPv= %0.2f, Len= %0.1f\n",
		       i,I,K,J,p->R,IL,p->IL,KL,p->KL,JL,p->JL,Yc(Y,I,K)-X[J],Yc(Y,IL,KL)-X[JL],X[JL],X[J], U, A->Tscore(I,K,J),p->score, logPV, Y[I] - Y[IL]);
	      if(PVERB>=3){
		for(int T = 0; T < U; T++){
		  int I = Ilist[U-1-T];
		  int K = Klist[U-1-T];
		  int J = Jlist[U-1-T];
		  RFLOAT iscoreT = iscore[U-T];
		  RFLOAT outscoreT = outscore[U-T];
		  RFLOAT Ascore = A->score(I,K,J);
		  if(T > 0)
		    printf("T=%d:I=%d,K=%d,J=%d:x=%0.4f,y=%0.4f:iscore=%0.6f,outscore=%0.6f,A:score=%0.6f\n",
			   T,I,K,J,Yc(Y,I,K)-Yc(Y,Ilist[U-T],Klist[U-T]),X[J]-X[Jlist[U-T]],iscoreT,outscoreT,Ascore);
		  else
		    printf("T=%d:I=%d,K=%d,J=%d:iscore=%0.6f,outscore=%0.6f,A:score=%0.6f\n",
			   T,I,K,J,iscoreT,outscoreT,Ascore);
		}
		printf("T=%d:iscore=%0.6f,outscore=%0.6f\n",U,iscore[0],outscore[0]);
	      }
	    }
	  }
	  fflush(stdout);
	}
      }
      int orignummatchgroup = nummatchgroup;
      nummatchgroup = j;
      if(DEBUG /* NEW37 */  && !MultiMatchesFilter && !(nummatchgroup > 0)){
	#pragma omp critical
	{
	  printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d\n",tid,refid,rmap->id,mapid,nanomap->id,orientation,rev);
	  fflush(stdout);
	  assert(nummatchgroup > 0);
	}
      }

      if(nummatchgroup > 0){// NEW37
	Cmatchgroup *p = &matchgroup[0];
	// NOTE : matchgroup[0] may no longer match bestscore since matchgroups are filtered for -A2 -L2 -S2 before bestscore is filtered for -A -L -S (also MatchMatchesTotScore could filter matchgroups)

	if((ScoreThreshold2 > -1000.0 || MULTIMATCHES_FILTER != 0.0 || MultiMatchesTotScore || REFSPLIT_FIX <= 0 /* WAS7 1 */) && !(p->I == bestI && p->K == bestK && p->J == bestJ && p->R == bestR && p->IL == bestIL)){/* matchgroup[0] may no longer match bestscore */
	  if(PVERB){
#pragma omp critical
	    {
	      printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f->%0.6f,bestI=%d->%d,bestK=%d->%d,bestJ=%d->%d,bestR=%d->%d,bestIL=%d->%d (updated best match due to -MultiMatchesTotScore)\n",
		     tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,p->score,bestI,p->I,bestK,p->K,bestJ,p->J,bestR,p->R,bestIL,p->IL);
	      fflush(stdout);
	    }
	  }
      
	  bestscore = p->score;
	  bestI = p->I;
	  bestK = p->K;
	  bestJ = p->J;
	  bestR = p->R;
	  bestIL = p->IL;
	  bestYik = Yc(Y,bestI,bestK);// NEW21
	}

	if(DEBUG && !(matchgroup[0].I == bestI && matchgroup[0].K == bestK && matchgroup[0].J == bestJ && matchgroup[0].R == bestR && matchgroup[0].IL == bestIL)){
#pragma omp critical
	  {
	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d:reduced %d matchgroups to %d distinct matchgroups (previous matchgroups=%d)\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ,bestR,bestIL,orignummatchgroup,j, align->multicnt);
	    for(int i = 0; i < nummatchgroup; i++){
	      int numpairs = -1, Lend = -1;
	      Cmatchgroup *p = &matchgroup[i];
	      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	      double logPV = alignFPsd(A,p->I,p->J,p->K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid, 0, 0, numpairs, Lend, p->IL, 0,0);
	      int I = p->I;
	      int K = p->K;
	      int J = p->J;
	      int IL = A->IL(I,K,J);
	      int KL = A->KL(I,K,J);
	      int JL = A->JL(I,K,J);
	      printf("   matchgroup[%d]:I=%d,K=%d,J=%d,R=%d,IL=%d->%d,KL=%d->%d,JL=%d->%d,L=%d:score= %0.6f->%0.6f, LogPv= %0.2f, Len= %0.1f\n",
		     i,I,K,J,p->R,IL,p->IL,KL,p->KL,JL,p->JL,A->G(IL,KL,JL),A->Tscore(p->I,p->K,p->J),p->score,logPV,Y[I]-Y[IL]);
	    }
	    fflush(stdout);
	    assert(matchgroup[0].I == bestI && matchgroup[0].K == bestK && matchgroup[0].J == bestJ && matchgroup[0].R == bestR && matchgroup[0].IL == bestIL);
	  }
	}

	if(DEBUG && REFSPLIT_FIX <= 0 /* WAS7 1 */ && !(fabs(matchgroup[0].score - bestscore) < 1e-6)){
#pragma omp critical
	  {
	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d:reduced %d matchgroups to %d distinct matchgroups (previous matchgroups=%d)\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ,bestR,bestIL,orignummatchgroup,j, align->multicnt);
	    printf("\t matchgroup[0].score = %0.7f, bestscore= %0.7f\n",matchgroup[0].score, bestscore);
	    fflush(stdout);
	    assert(fabs(matchgroup[0].score - bestscore) < 1e-6);
	  }
	}

	if(REFSPLIT_FIX /* WAS7 >=2 */)
	  bestscore = matchgroup[0].score;
      }// if nummatchgroup > 0
    }// if nummatchgroup > 0

    /* Compute Pvalue of each remaining matchgroup and eliminate it if it's Pvalue is not above LogPvThreshold2 */
    double logPV0 = -1.0;
    if(1 /* since alignments may have been trimmed */ /* WAS !MultiMatchesFilter */){
      int j = 0;
      int frags = 0;
      for(int i = 0; i < nummatchgroup; i++){
	int numpairs = -1, Lend = -1;
	Cmatchgroup *p = &matchgroup[i];
	if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	p->logPV = alignFPsd(A,p->I,p->J,p->K,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid, 0, 0, numpairs, Lend, p->IL, 0,0);
	if(i==0) logPV0 = p->logPV;
	if(p->logPV < LogPvThreshold2 || numpairs < AlignedSiteThreshold2){
	  if(!(RefSplitStitch>=2 && p->stitch))
	    continue;
	  frags++;
	}
	if(j < i)
	  matchgroup[j] = matchgroup[i];
	j++;
      }
      if(PVERB /* && j > 1 */){
#pragma omp critical
	{
	  if(RefSplitStitch>=2)
	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d:reduced %d matchgroups to %d(frags=%d) due to T2=%0.2f,A2=%d (previous matchgroups=%d):\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ,bestR,bestIL,nummatchgroup,j,frags,LogPvThreshold2, AlignedSiteThreshold2,align->Malign ? align->multicnt : 0);
	  else
	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d:reduced %d matchgroups to %d due to T2=%0.2f,A2=%d (previous matchgroups=%d):\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ,bestR,bestIL,nummatchgroup,j,LogPvThreshold2, AlignedSiteThreshold2,align->Malign ? align->multicnt : 0);
	  for(int i = 0; i < j; i++){
	    Cmatchgroup *p = &matchgroup[i];
	    int I = p->I;
	    int K = p->K;
	    int J = p->J;
	    int IL = A->IL(I,K,J);
	    int KL = A->KL(I,K,J);
	    int JL = A->JL(I,K,J);
	    printf("   %d:I=%d,K=%d,J=%d,R=%d,IL=%d->%d,KL=%d->%d,JL=%d->%d,L=%d:score= %0.6f->%0.6f, LogPv= %0.2f, Len= %0.1f\n",
		   i,I,K,J,p->R,IL,p->IL,KL,p->KL,JL,p->JL,A->G(IL,KL,JL),A->Tscore(p->I,p->K,p->J),p->score,p->logPV,Y[I]-Y[IL]);
	  }
	  fflush(stdout);
	}
      }
      nummatchgroup = j;
    } else if(nummatchgroup > 0)
      logPV0 = matchgroup[0].logPV;

    if(REFSPLIT_FIX /* WAS7 >= 2 */){/* recompute scores of all matchgroups as sum of iscore[0..U] and re-sort matchgroups by score (and filter out any that are now below score threshold) */
      int j = 0;
      for(int i = 0; i < nummatchgroup; i++){
	Cmatchgroup *p = &matchgroup[i];

	int I = p->I;
	int K = p->K;
	int J = p->J;
	int IL = p->IL;
	int Lend = I;
	int U = alignExtract(A,Lend,K,J,p->R, A->Tscore(I,K,J), Y,X,N,M,Ilist,Klist,Jlist,iscore,outscore,rmap,nanomap,refid,mapid,orientation,rev,scaleID, 0/*verb */,IL);

	double scoresum = 0.0;
	for(int T = 0; T <= U; T++)
	  scoresum += iscore[T];

	if(PVERB>=2/* HERE HERE && I_TRACE >= 0 && I == I_TRACE && K == K_TRACE && J == J_TRACE*/ /* && fabs(p->score - scoresum) > 1e-6 */){
	  printf("refid=%d(id=%lld,mapid=%d(id=%lld),or=%d,rev=%d,U=%d: matchgroup[%d]:I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,R=%d,score= %0.6f -> %0.6f (due to merging outliers)\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,U,i,I,K,J,p->IL,p->KL,p->JL,p->R,p->score,scoresum);
	  if(PVERB>=3){
	    double sum = 0.0;
	    for(int T = 0; T <= U; T++){
	      sum += iscore[T];
	      printf("  T=%5d:U-T=%5d: G=%d,T=%d,H=%d,iscore[T]= %0.6f,outscore[T]= %0.6f, iscoresum= %0.6f\n",T,U-T,Ilist[T],Klist[T],Jlist[T],iscore[T],outscore[T],sum);
	    }
	  }
	  fflush(stdout);
	}
	p->score = scoresum;
	
	if(p->score < ScoreThreshold2 || U < AlignedSiteThreshold2)
	  continue;
	if(j < i)
	  matchgroup[j] = matchgroup[i];
	j++;
      }
      if(PVERB && j < nummatchgroup){
        printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f,I=%d,K=%d,J=%d,R=%d,IL=%d:reduced %d matchgroups to %d due to merged outliers & S2=%0.2f,A2=%d (previous matchgroups=%d):\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ,bestR,bestIL,nummatchgroup,j,ScoreThreshold2, AlignedSiteThreshold2,align->Malign ? align->multicnt : 0);
        fflush(stdout);
      }
      nummatchgroup = j;
      
      qsort(matchgroup,nummatchgroup,sizeof(Cmatchgroup),(intcmp *)CmatchgroupScoreDec);      
    }

    if(DEBUG>=2 && MultiMatchesFilter >= 2 && RepeatRec && RepeatMaxShift > 0){/* check that A->shift has been reset to 0 everywhere */
      for(int I = IMIN; I <= IMAX; I++){
	if(DEBUG>=2) assert(Kmax[I] >= 0 && Kmax[I] <= I-1 && Kmax[I] <= KMAX);
	for(int K = 0; K <= Kmax[I]; K++){
	  int jmin = JMIN[I], jmax = JMAX[I];
	  if(DEBUG>=2) assert(JMIN[I] <= JMAX[I]);

	  int *pA = &A->shift(I,K,0);
	  for(int J = jmin; J <= jmax; J++)
	    assert(pA[J] == 0);
	}
      }
    }

    if(nummatchgroup > 0){  /* append remaining matchgroups as complete alignments to align->Malign[0..align->multicnt-1][0] */
      Cmatchgroup *p = &matchgroup[0];

      if(VERB >= 2 ){
	#pragma omp critical
	{
	  printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:bestscore=%0.6f,p->score=%0.6f,bestI=%d,p->I=%d,bestK=%d,p->K=%d,bestJ=%d,p->J=%d,bestR=%d,p->R=%d,bestIL=%d,p->IL=%d,p->logPV=%0.2f\n",
		 tid,refid,rmap->id,mapid,nanomap->id,orientation,bestscore,p->score,bestI,p->I,bestK,p->K,bestJ,p->J,bestR,p->R, bestIL,p->IL,p->logPV);
	  fflush(stdout);
	}
      }

      if(!(bestI == p->I && bestJ == p->J && bestK == p->K && bestR == p->R && bestIL == p->IL)){
	/* NOTE : it is possible that p->score is worse than bestscore IF the correspond align->Malign[i] was filtered due to logPV <= LogPvThreshold */

        if(PVERB){
	  #pragma omp critical
	  {
	    printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f->%0.6f,bestI=%d->%d,bestK=%d->%d,bestJ=%d->%d,bestR=%d->%d,bestIL=%d->%d,logPV=%0.2f->%0.2f (replaced best match due to logPV or IL)\n",
		   tid,refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,p->score,bestI,p->I,bestK,p->K,bestJ,p->J,bestR,p->R,bestIL,p->IL,logPV0, p->logPV);
	    fflush(stdout);
	  }
        }

	/* make sure p->score has not been changed or alignment truncated : this should be the case for the best scoring alignment unless MULTIMATCH_TRIM was applied */
	if(!MULTIMATCH_TRIM){
	  if(DEBUG && !(p->IL == A->IL(p->I,p->K,p->J))){
            #pragma omp critical
	    {
	      if(VERB < 2-PVERB)
		printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:bestscore=%0.6f,p->score=%0.6f,bestI=%d,p->I=%d,bestK=%d,p->K=%d,bestJ=%d,p->J=%d,bestR=%d,p->R=%d,p->logPV=%0.2f\n",
	          tid,refid,rmap->id,mapid,nanomap->id,orientation,bestscore,p->score,bestI,p->I,bestK,p->K,bestJ,p->J,bestR,p->R, p->logPV);
	      printf("p->IL=%d,A->IL(p->I,p->K,p->J)=%d\n",p->IL, A->IL(p->I,p->K,p->J));

	      fflush(stdout);
	      assert(p->IL == A->IL(p->I,p->K,p->J));
	    }
	  }
	  if(DEBUG) assert(p->score == A->Tscore(p->I,p->K,p->J));
	}

	bestscore = p->score;
	bestI = p->I;
	bestK = p->K;
	bestJ = p->J;
	bestR = p->R;
	bestIL = p->IL;
        bestYik = Yc(Y,bestI,bestK);// NEW21
      } else if(REFSPLIT_FIX /* WAS7 >= 2*/) 
	bestscore = p->score;// p->score may have changed due to REFSPLIT_FIX

      if(DEBUG && !(p->logPV > LogPvThreshold2)){
	#pragma omp critical
	{
	  printf("tid=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:bestscore=%0.6f,p->score=%0.6f,bestI=%d,p->I=%d,bestK=%d,p->K=%d,bestJ=%d,p->J=%d,bestR=%d,p->R=%d,bestIL=%d,p->IL=%d,p->logPV=%0.2f(T2=%0.2f),nummatchgroup=%d\n",
		 tid,refid,rmap->id,mapid,nanomap->id,orientation,bestscore,p->score,bestI,p->I,bestK,p->K,bestJ,p->J,bestR,p->R, bestIL,p->IL,p->logPV,LogPvThreshold2,nummatchgroup);
	  fflush(stdout);
	  assert(p->logPV > LogPvThreshold2);
	}
      }

      if(bestscore > ScoreThreshold && !(bestscore > align->score + 1e-8) && !(align->score > ScoreThreshold && align->logPV > LogPvThreshold) && p->logPV > LogPvThreshold){
	if(PVERB){
          #pragma omp critical
	  {
	    printf("tid=%d:refid=%d,mapid=%d,or=%d,rev=%d,sc=%d:align->score=%0.6f,align->logPV=%0.2f,or=%d : discarding to replace with bestscore=%0.6f,logPV=%0.2f,or=%d\n",
		   tid,refid,mapid,orientation,rev,scaleID,align->score,align->logPV,align->orientation,bestscore,p->logPV,orientation);
	    fflush(stdout);
	  }
	}
	align->score = MINSCORE;
	align->numpairs = 0;
      }

      int origmultimax = align->Malign ? align->multimax : 0;

      if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	for(int i = 0; i < align->multimax; i++)
	  for(int j = i+1; j < align->multimax; j++)
	    if(align->Malign[i] == align->Malign[j]){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	      fflush(stdout);
	      assert(align->Malign[i] != align->Malign[j]);
	    }
      }

      if(align->Malign == NULL){
        align->multicnt = 0;
        align->multimax = nummatchgroup;
        align->Malign = new Calign*[align->multimax];
        for(int i = 0; i < align->multimax; i++)
	  align->Malign[i] = new Calign[1];
      } else if(align->multicnt + nummatchgroup > align->multimax) {
        int nmultimax = align->multicnt + nummatchgroup;
	Calign **nMalign = new Calign*[nmultimax];
	for(int t = 0; t < align->multimax; t++)
	  nMalign[t] = align->Malign[t];
	for(int t = align->multimax; t < nmultimax; t++)
	  nMalign[t] = new Calign[1];
	delete [] align->Malign;
	align->Malign = nMalign;
	align->multimax = nmultimax;
      }
      if(DEBUG) assert(align->Malign != NULL);

      if(PVERB>=3 && align->multicnt > 0){// display previous matchgroups 
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:score=%0.6f : previous %d matchgroups (multimax=%d -> %d):\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID, bestscore, align->multicnt,origmultimax,align->multimax);
	for(int t = 0; t < align->multicnt;t++){
	  Calign *p = align->Malign[t];
	  int U = p->numpairs;
	  printf("  Malign[%d]= %p: mapid1=%d(id=%lld),mapid2=%d(id=%lld),or=%d,rev=%d,sc=%d:score=%0.6f,logPV=%0.6f,pairs=%d:I=%d..%d,K=%d..%d,J=%d..%d\n",
		 t,p,p->mapid1,YYmap[p->mapid1]->id,p->mapid2,XXmap[p->mapid2]->id,p->orientation,p->rev,p->scaleID,p->score,p->logPV,U,
		 p->sites1[0],p->sites1[U-1],p->sitesK1[0],p->sitesK1[U-1],p->sites2[0],p->sites2[U-1]);
	}
	for(int t = align->multicnt; t < align->multimax; t++)
	  printf("  Malign[%d]= %p\n",t,align->Malign[t]);
	fflush(stdout);
      }

      if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	for(int i = 0; i < align->multimax; i++)
	  for(int j = i+1; j < align->multimax; j++)
	    if(align->Malign[i] == align->Malign[j]){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		     refid,rmap->id,mapid,nanomap->id,orientation,scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	      fflush(stdout);
	      assert(align->Malign[i] != align->Malign[j]);
	    }
      }

      for(int i = 0; i < nummatchgroup; i++){
        Cmatchgroup *p = &matchgroup[i];
        Calign *malign = align->Malign[align->multicnt++];
	if(DEBUG) assert(align->multicnt <= align->multimax);
      
	if(PVERB>=2){
	  #pragma omp critical
	  {
	    int IL = A->IL(p->I,p->K,p->J);
	    int KL = A->KL(p->I,p->K,p->J);
	    int JL = A->JL(p->I,p->K,p->J);
	    printf("new MG[%d/%d]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:score=%0.6f(S2=%0.3f),logPV=%0.2f(T2=%0.3f):I=%d,K=%d,J=%d,R=%d,IL=%d->%d,KL=%d->%d,JL=%d->%d,Tscore=%0.6f:Malign[%d]=%p\n",
		   i,nummatchgroup,refid,rmap->id,mapid,nanomap->id,orientation,rev,p->score,ScoreThreshold2,p->logPV,LogPvThreshold2,p->I,p->K,p->J,p->R,IL,p->IL,KL,p->KL,JL,p->JL,A->Tscore(p->I,p->K,p->J),
		   align->multicnt-1,malign);
	    fflush(stdout);
	  }
	}

        /* allocate space to store alignment in reverse order */
        int I = p->I;
	int verb = (PVERB>=3 && p->I == 19101 && p->K==0 && p->J==1062 && p->IL==18813 && p->JL==813) ? 1 : 0;
	int U = alignExtract(A, I, p->K, p->J, p->R, A->Tscore(p->I,p->K,p->J), Y,X,N,M,Ilist,Klist,Jlist,iscore,outscore,rmap,nanomap,refid,mapid, orientation,rev,scaleID,verb,p->IL); 

	double score = 0.0;
	for(int t = 0; t <= U; t++)
	  score += iscore[t];

	if(/* TVERB */ PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE /* && p->I == 19101 && p->K==0 && p->J==1062*/){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:i=%d/%d: After calling alignExtract(): matchgroup[i]->score= %0.6f, iscore[%d..%d]= %0.6f,I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d:\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,nummatchgroup,p->score,0,U,score,p->I,p->K,p->J,p->IL,p->KL,p->JL);
	  double iscoresum = 0.0;
	  for(int k = 0; k <= U; k++){
	    iscoresum += iscore[k];
	    printf("  k=%5d:U-k=%5d: G=%d,T=%d,H=%d:outscore[k]= %0.6f, iscore[k]= %0.6f, iscoresum= %0.6f\n",k,U-k,Ilist[k],Klist[k],Jlist[k],outscore[k],iscore[k],iscoresum);
	  }
	  fflush(stdout);
	}

	if((PVERB>=3 /* && I_TRACE >= 0 && p->I==I_TRACE && p->K==K_TRACE && p->J==J_TRACE */ ) || 
	   (DEBUG>=1+RELEASE && !(((REFSPLIT_FIX <= 0 /* WAS7 1 */ && (maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE) && outlierExtend) ? p->score - score : fabs(p->score - score)) < ASCORE_MARGIN + fabs(p->score) * SCORE_MARGIN))){
          #pragma omp critical
	  {
	    double Tscore = A->Tscore(p->I,p->K,p->J);
	    double Uscore = A->Uscore(p->IL,p->KL,p->JL);
	    double Ascore = A->score(p->IL,p->KL,p->JL);
	    printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d,sc=%d:i=%d/%d,I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d,L=%d,p->score=%0.6f,%0.6f(iscore[0..%d]=%0.6f,Tscore=%0.6f,Uscore(IL)=%0.6f,score(IL)=%0.6f),iscore[0]=%0.6f(err=%0.8f),Ascore=%0.6f),logPV=%0.2f:Copying to align->Malign[%d]:\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,i,nummatchgroup,p->I,p->K,p->J,p->IL,p->KL,p->JL,I,p->score,Tscore + Uscore - Ascore, U,score,Tscore,Uscore,Ascore,iscore[0],
		   iscore[0]-(double)(A->Tscore(p->I,p->K,p->J) - A->score(p->I,p->K,p->J)),A->score(p->I,p->K,p->J),p->logPV,align->multicnt-1);
	    if(DEBUG){
	      fflush(stdout);
	      assert(fabs(iscore[0] - (double)(A->Tscore(p->I,p->K,p->J) - A->score(p->I,p->K,p->J))) < 1e-6);
	      assert(p->I == Ilist[0] && p->K == Klist[0] && p->J == Jlist[0]);
	    }
	    
	    double cumiscore = iscore[0];

	    for(int t = 0; t < U; t++){
	      int pI = Ilist[t];
	      int pK = Klist[t];
	      int pJ = Jlist[t];
	      RFLOAT pscore = (pI == p->IL && p->IL != A->IL(pI,pK,pJ)) ? A->Uscore(pI,pK,pJ) : A->score(pI,pK,pJ);// NEW
	      cumiscore += iscore[t+1];
	      
	      if(t == U-1){
		if(p->IL != A->IL(pI,pK,pJ))
		  Tscore += pscore/* WAS score*/ - A->score(pI,pK,pJ);
		printf("      %d:I=%d,T=%d,J=%d(IL=%d,KL=%d,JL=%d),p->IL=%d: score=%0.6f(Sm=%0.6f,iscore[%d]=%0.6f,err=%0.8f,cum:iscore=%0.6f,score=%0.6f,err=%0.8f)\n",
		       U-1-t,pI,pK,pJ,A->IL(pI,pK,pJ),A->KL(pI,pK,pJ),A->JL(pI,pK,pJ),p->IL,pscore, Sm(0,pI,pK,Y), t+1,iscore[t+1], iscore[t+1]-pscore, cumiscore, Tscore, cumiscore - Tscore);
		if(DEBUG){
		  fflush(stdout);
		  assert(fabs(iscore[t+1] - (double)pscore) < 1e-6);
		  if(REFSPLIT_FIX <= 0 /* WAS7 1 */ && p->IL == A->IL(pI,pK,pJ)){
		    if((maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE) && outlierExtend)
		      assert((double)A->Tscore(p->I,p->K,p->J) - cumiscore < 1e-5);
		    else
		      assert(fabs((double)A->Tscore(p->I,p->K,p->J) - cumiscore) < 1e-5);
		  }
		}
	      } else {
		int pG = Ilist[t+1];
		int pT = Klist[t+1];
		int pH = Jlist[t+1];
		printf("      %d:I=%d,T=%d/%d,J=%d(%d..%d) (G=%d,T=%d,H=%d,IL=%d,KL=%d,JL=%d) score=%0.6f(Sm=%0.6f,iscore[%d]=%0.6f,pscore=%0.6f,err=%0.8f,cum:iscore=%0.6f,score=%0.6f,err=%0.8f),y=%0.4f,x=%0.4f\n",
		       U-1-t,pI,pK,Kmax[pI],pJ,JMIN[pI],JMAX[pI],pG,pT,pH,A->IL(pI,pK,pJ),A->KL(pI,pK,pJ),A->JL(pI,pK,pJ),pscore, Sm(0,pI,pK,Y), t+1,iscore[t+1],A->score(pG,pT,pH),iscore[t+1]-(double)(A->score(pI,pK,pJ) - A->score(pG,pT,pH)),
		       cumiscore,Tscore - A->score(pG,pT,pH),cumiscore - (double)(Tscore - A->score(pG,pT,pH)), Yc(Y,pI,pK)-Yc(Y,pG,pT), X[pJ]-X[pH]);
		if(DEBUG>=2 && REFSPLIT_FIX <= 0 /* WAS7 1 */){
	          fflush(stdout);
		  assert(pI != p->IL);
		  if((maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE) && outlierExtend){
		    assert(-(iscore[t+1] - (double)(A->score(pI,pK,pJ) - A->score(pG,pT,pH))) < (USE_RFLOAT ? 1e-4 : 1e-6));
		    assert(-(cumiscore - (double)(A->Tscore(p->I,p->K,p->J) - A->score(pG,pT,pH))) < (USE_RFLOAT ? 1e-2 : 1e-5));
		  } else {
		    assert(fabs(iscore[t+1] - (double)(A->score(pI,pK,pJ) - A->score(pG,pT,pH))) < (USE_RFLOAT ? 1e-4 : 1e-6));
		    assert(fabs(cumiscore - (double)(A->Tscore(p->I,p->K,p->J) - A->score(pG,pT,pH))) < (USE_RFLOAT ? 1e-2 : 1e-5));
		  }
		}
	      }
	    }
	    fflush(stdout);
	    assert(fabs(cumiscore - score) < 1e-8);
	    if(DEBUG>=1+RELEASE){
	      if(REFSPLIT_FIX <= 0 /* WAS7 1 */ && (maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE) && outlierExtend)
		assert(p->score - score < ASCORE_MARGIN + ISCORE_MARGIN*U + fabs(p->score)*SCORE_MARGIN);
	      else
		assert(fabs(p->score - score) < ASCORE_MARGIN + ISCORE_MARGIN*U + fabs(p->score)*SCORE_MARGIN);
	    }
	  }
	}
	if(/* TVERB */ PVERB>=3 && I_TRACE >= 0 && p->I == I_TRACE && p->K == K_TRACE && p->J == J_TRACE){
	  printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:i=%d/%d: matchgroup[i].score=%0.6f -> %0.6f\n", refid,rmap->id,mapid,nanomap->id,orientation,rev,i,nummatchgroup,p->score,score);
	  fflush(stdout);
	}
	p->score = score;// NEW3

	malign->score = p->score;
	malign->orientation = orientation;
	malign->rev = rev;
	malign->mapid1 = refid;
	malign->mapid2 = mapid;
	malign->scaleID = scaleID;
	malign->Nrange = IMAX-IMIN+1;
	malign->Mrange = jmax-jmin+1;
	malign->logPV = p->logPV;
	malign->Lend = I;
	malign->Rend = p->R;
	if(RefSplitStitch>=2)
	  malign->stitch = p->stitch;

	I = Ilist[U-1];
	int K = Klist[U-1];
	int J = Jlist[U-1];

	if(DEBUG>=2 && !(MULTIMATCH_TRIM && MultiMatchesDelta > 0.0)) assert(malign->Lend <= -2 || J <= DELTA_X || (extend && I-K <= DELTA_Y));
	malign->Lij1 = (malign->Lend <= -2) ? I-K : A->Lij(I,K,J);
	if(DEBUG>=2) assert(malign->Lij1 <= I-K && malign->Lij1 >= 0);
	malign->Lij2 = (malign->Lend <= -2) ? J : extend ? A->Lijx(I,K,J) : 0;
	if(DEBUG>=2) assert(malign->Lij2 <= J && malign->Lij2 >= 0);
	if(DEBUG>=2) assert(malign->Rend <= -2 || p->J >= M+1 - DELTA_X || (extend && p->I >= N+1-DELTA_Y));
	malign->Rij1 = (malign->Rend <= -2) ? p->I : A->Rij(p->I,p->K,p->J);
	if(DEBUG>=2) assert(malign->Rij1 >= p->I && malign->Rij1 <= N+1);
	malign->Rij2 = (malign->Rend <= -2) ? p->J : extend ? A->Rijx(p->I,p->K,p->J) : M+1;
	if(DEBUG>=2) assert(malign->Rij2 >= p->J && malign->Rij2 <= M+1);

#if CALIGN_END==0
	malign->LijY = A->Lij(I,K,J);
	malign->LijX = extend ? A->Lijx(I,K,J) : 0;
	malign->RijY = A->Rij(p->I,p->K,p->J);
	malign->RijX = extend ? A->Rijx(p->I,p->K,p->J) : M+1;
#endif	
	
	malign->repeat = -1;
	if(RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0)
	  malign->repeat = 0;
	 
	/* (re)allocate alignment */
	malign->expand_arrays(U);
	malign->numpairs = U;

	if(PVERB>=2/* && I_TRACE >= 0 && p->I==I_TRACE && p->K==K_TRACE && p->J==J_TRACE */){
	  printf("\t Lend=%d,Lij1=%d,Lij2=%d,Rend=%d,Rij1=%d,Rij2=%d\n",malign->Lend,malign->Lij1,malign->Lij2,malign->Rend,malign->Rij1,malign->Rij2);
	  fflush(stdout);
	}

	/* copy alignment from Ilist[],Jlist[] in reverse order */
	if(DEBUG && U > 0) assert(isfinite(iscore[U]) && isfinite(outscore[U]));

	for(int I= 0; I < U; I++){
	  malign->sites1[I] = Ilist[U-1-I];
	  malign->sitesK1[I] = Klist[U-1-I];
	  malign->sites2[I] = Jlist[U-1-I];
	  malign->iscore[I] = iscore[U-I];
	  malign->outscore[I] = outscore[U-I];
	}
	malign->iscore[U] = iscore[0];
	malign->outscore[U] = outscore[0];

	malign->noutliers = 0;
	malign->maxoutlier = 0.0;
	malign->maxoutlierLabels = 0;// NEW302
	int lastI = malign->sites1[0];
	int lastK = malign->sitesK1[0];
	int lastJ = malign->sites2[0];
	for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
	  I = malign->sites1[t];
	  K = malign->sitesK1[t];
	  J = malign->sites2[t];
	  if(malign->outscore[t] + (FLOAT)0.01 < malign->iscore[t]){
	    malign->noutliers++;
	    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	    FLOAT deltaX = X[J] - X[lastJ];
	    if(DEBUG) assert(deltaX > 0.0);
	    FLOAT delta = fabs(deltaY - deltaX);
	    malign->maxoutlier = max(delta,malign->maxoutlier);
	    malign->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, malign->maxoutlierLabels);// NEW302
	  }
	  if(PVERB>= 3){
	    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	    FLOAT deltaX = X[J] - X[lastJ];
	    if(DEBUG) assert(deltaX > 0.0);
	    FLOAT delta = fabs(deltaY - deltaX);
	    printf("matchgroup[%d/%d]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:t=%d/%d:I=%d..%d,K=%d..%d,J=%d..%d,iscore[t]=%0.6f,outscore[t]=%0.6f,delY=%0.3f,delX=%0.3f,out=%0.3f:maxoutlier=%d,%0.3f,%d\n",
		   i,nummatchgroup,refid,rmap->id,mapid,nanomap->id,malign->orientation,malign->rev,malign->scaleID,t,U,lastI,I,lastK,K,lastJ,J,
		   malign->iscore[t],malign->outscore[t],deltaY,deltaX,delta,malign->noutliers,malign->maxoutlier,malign->maxoutlierLabels);
	    fflush(stdout);
	  }
	}
	if(DEBUG/* HERE HERE >=2 */) assert(malign->noutliers >= 0 && malign->maxoutlier >= 0.0 && malign->maxoutlierLabels >= 0 &&
					    (malign->noutliers <= 0 || malign->maxoutlier > 0.0 || malign->maxoutlierLabels > 0));
	
	if(PVERB){
	  #pragma omp critical
	  {
	    double scoresum = 0.0;
	    for(int t = 0; t <= U; t++)
	      scoresum += malign->iscore[t];
	    printf("matchgroup[%d/%d]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:score=%0.6f(S2=%0.3f),logPV=%0.2f(T2=%0.3f),iscore[0..%d]= %0.6f(A2=%d),Len=%0.3f(L2=%0.3f),MaxOutlier=%0.3f,%d(I2=%0.3f,%d),Lend=%d,Rend=%d(E2=%d):\n",
		   i,nummatchgroup,refid,rmap->id,mapid,nanomap->id,malign->orientation,malign->rev,malign->scaleID,malign->score,ScoreThreshold2,malign->logPV,LogPvThreshold2,U,scoresum,
		   AlignedSiteThreshold2,AlignedLength(malign,Y), AlignedLengthThreshold2, malign->maxoutlier, malign->maxoutlierLabels, AlignedOutlierThreshold2, AlignedOutlierLabels2,malign->Lend,malign->Rend, AlignedEndOutlierThreshold2);
	    fflush(stdout);
	  }
	}

	if(DEBUG/* HERE HERE >=2 */) assert(malign->noutliers >= 0 && malign->maxoutlier >= 0.0 && malign->maxoutlierLabels >= 0 &&
					    (malign->noutliers <= 0 || malign->maxoutlier > 0.0 || malign->maxoutlierLabels > 0));

	if(!(U >= AlignedSiteThreshold2 && AlignedEndOutlier2(malign)) && !(RefSplitStitch>=2 && malign->stitch)){
	  if(PVERB){
	    #pragma omp critical
	    {
	      printf("matchgroup[%d/%d]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:score=%0.6f,logPV=%0.2f,numpairs=%d,AlignedSiteThreshold2=%d,Lend=%d,Rend=%d,AlignedEndOutlierThreshold2=%d,multicnt=%d->%d\n",
		     i,nummatchgroup,refid,rmap->id,mapid,nanomap->id,orientation,rev,malign->score,malign->logPV,U,AlignedSiteThreshold2,malign->Lend,malign->Rend,AlignedEndOutlierThreshold2,
		     align->multicnt + (nummatchgroup - i - 1), align->multicnt - 1 + (nummatchgroup - i - 1));
	      fflush(stdout);
	    }
	  }
	  align->multicnt--;
	  continue;
	}
	if(DEBUG/* HERE HERE >=2 */) assert(malign->noutliers >= 0 && malign->maxoutlier >= 0.0 && malign->maxoutlierLabels >= 0 &&
					    (malign->noutliers <= 0 || malign->maxoutlier > 0.0 || malign->maxoutlierLabels > 0));
	if(!(min(999.0,malign->maxoutlier) <= AlignedOutlierThreshold2 && min(999,malign->maxoutlierLabels) <= AlignedOutlierLabels2) && !(RefSplitStitch>=2 && malign->stitch)){
	  if(PVERB>=2){
	    #pragma omp critical
	    {
	      printf("matchgroup[%d/%d]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:score=%0.6f,logPV=%0.2f,numpairs=%d,outlier=%0.3f,I2=%0.3f,%d:multicnt=%d->%d\n",
		     i,nummatchgroup,refid,rmap->id,mapid,nanomap->id,orientation,rev,malign->score,malign->logPV,U,malign->maxoutlier,AlignedOutlierThreshold2,AlignedOutlierLabels2,
		     align->multicnt + (nummatchgroup - i - 1), align->multicnt - 1 + (nummatchgroup - i - 1));
	      fflush(stdout);
	    }
	  }
	  align->multicnt--;
	  continue;
	}
	if(!(AlignedLength(malign,Y) >= AlignedLengthThreshold2) && !(RefSplitStitch>=2 && malign->stitch)){
	  if(PVERB>=2){
	    #pragma omp critical
	    {
	      printf("matchgroup[%d/%d]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:score=%0.6f,logPV=%0.2f,numpairs=%d,Length=%0.3f,AlignedLengthThreshold2=%0.3f:multicnt=%d->%d\n",
		     i,nummatchgroup,refid,rmap->id,mapid,nanomap->id,orientation,rev,malign->score,malign->logPV,U,AlignedLength(malign,Y),AlignedLengthThreshold2,
		     align->multicnt + (nummatchgroup - i - 1), align->multicnt - 1 + (nummatchgroup - i - 1));
	      fflush(stdout);
	    }
	  }
	  align->multicnt--;
	  continue;
	}

	// skip expensive Repeat check if malign fails regular thresholds (which can be more stringent than for alternate alignments) : just assume malign->repeat = 0 in such cases.
	/* NOTE : it is possible that some matchgroup other than matchgroup[0] or matchgroup[i] is the only one to satisfy the regular thresholds, in which case repeat check would never
	   get performed on matchgroup[i] even though it would survive as an alternate alignment */
	if(maptype==0/* NEW405 */ && !AlignedThreshold(malign,Y,ScoreThreshold,LogPvThreshold)){
	  if(PVERB>=2){
            #pragma omp critical
	    {
	       printf("matchgroup[%d/%d]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:score=%0.6f,logPV=%0.2f,numpairs=%d,Length=%0.3f,MaxOutlier=%0.3f (A=%d,S=%0.2f,T=%0.2f,L=%0.1f): skipping repeat check\n",
		      i,nummatchgroup,refid,rmap->id,mapid,nanomap->id,orientation,rev,malign->score,malign->logPV,U,AlignedLength(malign,Y),malign->maxoutlier, 
		      AlignedSiteThreshold,ScoreThreshold,LogPvThreshold,AlignedLengthThreshold);
	       fflush(stdout);
	    }
	  }
	  continue;
	}

	if(RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0 && extend && !(RefSplitStitch>=2 && malign->stitch)){/* check if malign is a repeat */
	  checkRepeat(Y,N,X,M,orientation,rev,scaleID,Kmax,A,JMIN,JMAX,Imin,Imax,malign,rmap,nanomap,refid,mapid,XPen,phash,tid,
		      PRtabY,YPenR,localtype,IMIN,IMAX,jmin,jmax,maxUscore,biasend2_values, p->I,p->K,p->J,U,Ilist,Klist,Jlist);
	  if(PVERB>=2){
            #pragma omp critical
	    {
	      printf("matchgroup[%d/%d]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:score=%0.6f,logPV=%0.2f,numpairs=%d,Length=%0.3f,repeat=%d:multicnt=%d\n",
		     i,nummatchgroup,refid,rmap->id,mapid,nanomap->id,orientation,rev,malign->score,malign->logPV,U,AlignedLength(malign,Y),malign->repeat, align->multicnt + (nummatchgroup - i - 1));
	      fflush(stdout);
	    }
	  }

	  if(malign->repeat){
	    //	    align->multicnt--;// DO NOT delete alternate alignment due to a repeat : the repeat value is there in case it becomes the main alignment
	    continue;// not really needed since this is the last quality test for matchgroup[i] 
	  }
	}
      }
    }

    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }

  }

  if(KEEP_MULTIMATCHES && !MultiMatches && HashMultiMatch && !BestRef && bestscore >= ScoreThreshold){/* keep all alignments that are above thresholds using align->Malign[0..align->multicnt -1] */
    // HERE HERE 
  }

  if(PVERB>=2 || (DEBUG && align->numpairs > 0 && !(!align->rev || rev==1))){
    #pragma omp critical
    {
      if(align->numpairs > 0){
	double scoresum = 0.0;
	for(int t = 0; t <= align->numpairs; t++)
	  scoresum += align->iscore[t];
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.4f(I=%d,K=%d,J=%d,R=%d,IL=%d),align:score=%0.6f,logPV=%0.2f,or=%d,rev=%d,scaleID=%d,Len=%0.3f,iscore[0..%d]= %0.6f,repeat=%d,multi=%d,%d\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ,bestR,bestIL,align->score,align->logPV,align->orientation,align->rev,align->scaleID,
	       AlignedLength(align, align->rev ? Y : YYmap[refid]->site[0]), align->numpairs, scoresum, align->repeat,nummatchgroup,align->multicnt);
      } else
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.4f(I=%d,K=%d,J=%d,R=%d,IL=%d),align:score=%0.6f,logPV=%0.2f,or=%d,rev=%d,scaleID=%d,Len=%0.3f,numpairs=%d,repeat=%d,multi=%d,%d\n",
	       refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ,bestR,bestIL,align->score,align->logPV,align->orientation,align->rev,align->scaleID,
	       AlignedLength(align, align->rev ? Y : YYmap[refid]->site[0]), align->numpairs, align->repeat,nummatchgroup,align->multicnt);
      fflush(stdout);
      if(DEBUG && align->numpairs > 0) assert(!align->rev || rev == 1);
    }
  }

  int error = 0;

  if(bestscore > align->score + 1e-8 && 
     !(MultiMatches && !nummatchgroup && align->multicnt > 0)){ /* backtrack through array to retrieve best alignment starting at right end A[bestI][bestK][bestJ] */

    if(SecondBest && align->score > ScoreThreshold2 && 
       (!GOODMAPS || (align->score > ScoreThreshold && align->logPV > LogPvThreshold && align->numpairs >= AlignedSiteThreshold))){  /* check if we need to save previous best alignment as 2nd best alignment */

      int alignK = align->numpairs;
      FLOAT alignYik = (alignK <= 0) ? -1e30 : Yc(Y,align->sites1[alignK-1],align->sitesK1[alignK-1]);
      if(DEBUG) assert(bestYik >= 0.0);
      Calign *align2;
      if(align->orientation != orientation || fabs(alignYik - bestYik) >= MinSpacing){
	delete [] align->align2;
	align2 = align->align2 = new Calign[1];
	copy(align2, align, 1, 1);
	if(DEBUG) assert(align2->mapid1 == align->mapid1);

	if(PVERB>=2){
	  #pragma omp critical
	  {
	    printf("Converted previous best alignment to 2nd Best:refid=%d,mapid=%d(id=%lld),orientation=%d:score=%0.4f,logPV=%0.2f,numpairs=%d\n",
		   align2->mapid1,align2->mapid2,Gmap[align2->mapid2]->id,align2->orientation,align2->score,align2->logPV,align2->numpairs);
	    fflush(stdout);
	  }
	}

      } else if((align2 = align->align2) && align2->orientation == orientation){/* check if existing 2nd best alignment is now invalid (too close to new best alignment) */
	int numpairs = align2->numpairs;
	int I2 = align2->sites1[numpairs - 1];
	int K2 = align2->sitesK1[numpairs - 1];
	FLOAT alignYik2 = Yc(Y,I2,K2);
	if(fabs(alignYik2 - bestYik) < MinSpacing){
	  if(PVERB>=2){
            #pragma omp critical
	    {
	      printf("Deleting previous 2nd best alignment (too close to new best alignment):refid=%d,mapid=%d(id=%lld),orientation=%d:score=%0.4f,logPV=%0.2f,numpairs=%d\n",
		     align2->mapid1,align2->mapid2,Gmap[align2->mapid2]->id,align2->orientation,align2->score,align2->logPV,align2->numpairs);
	      fflush(stdout);
	    }
	  }
	  delete [] align->align2; align->align2 = NULL;
	}
      }
    }

    if(VERB>=3 && refid==0 && N >= 15518){
      printf("refid=%d,mapid=%d,or=%d:bestI=%d,bestK=%d,bestJ=%d:PRtabY[0][bestI-bestK].LogPr=%0.10e,Y[bestI-bestK]=%0.6f,Y[bestI-bestK-1]=%0.6f\n",
	     refid,mapid,orientation,bestI,bestK,bestJ,PRtabY[0][bestI-bestK].LogPr,Y[bestI-bestK],Y[bestI-bestK-1]);
      fflush(stdout);
    }

    /* compute alignment in reverse order */
    int I = bestI;
    int U = alignExtract(A, I, bestK, bestJ, bestR, MultiMatches ? A->Tscore(bestI,bestK,bestJ)/*NEW*/ : bestscore, 
			 Y, X, N, M, Ilist, Klist, Jlist, iscore, outscore, rmap, nanomap, refid, mapid, orientation, rev, scaleID,/* (PVERB>=2)?1:*/0/*verb*/, bestIL);

    int numpairs = -1, Lend = -1;
    if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
    double logPV = alignFPsd(A,bestI,bestJ,bestK,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,bestR,orientation,rev,scaleID,refid,mapid, 0, /* (PVERB>=2) ? 1 : */ 0/*verb*/, numpairs, Lend, bestIL,0,0);
    if(PVERB>=2 || (DEBUG && numpairs !=U)){
      printf("refid=%d,mapid=%d,or=%d,sc=%d:N=%d,M=%d:bestscore=%0.6f(I=%d,K=%d,J=%d),logPV=%0.2f:I=%d,Lend=%d,U=%d,numpairs=%d\n",
	     refid,mapid,orientation,scaleID,N,M,bestscore,bestI,bestK,bestJ,logPV,I,Lend,U,numpairs);
      fflush(stdout);
      if(DEBUG) assert(numpairs == U);
    }
    if(DEBUG) assert(I == Lend);

    if(bestscore > ScoreThreshold && !(bestscore > align->score + 1e-8) && !(align->score > ScoreThreshold && align->logPV > LogPvThreshold) && logPV > LogPvThreshold){// NEW9
      if(PVERB){
        #pragma omp critical
	{
	  printf("tid=%d:refid=%d,mapid=%d,or=%d,rev=%d,sc=%d:align->score=%0.6f,align->logPV=%0.2f,or=%d : discarding to replace with bestscore=%0.6f,logPV=%0.2f,or=%d\n",
		 tid,refid,mapid,orientation,rev,scaleID,align->score,align->logPV,align->orientation,bestscore,logPV,orientation);
	  fflush(stdout);
	}
      }
      align->score = MINSCORE;
      align->numpairs = 0;
    }

    // NEW8 : If new alignment fails -T -A or -E then keep current alignment even though it has lower score, provided current alignment satisfied -S -T -A and -E AND (scaleID && !SecondBest)
    if((logPV > LogPvThreshold && U >= AlignedSiteThreshold && (Lend <= -2 ? 1 : 0) + (bestR <= -2 ? 1 : 0) <= AlignedEndOutlierThreshold)  ||
       !(!SecondBest && scaleID && align->score > ScoreThreshold && align->logPV > LogPvThreshold && align->numpairs >= AlignedSiteThreshold && AlignedEndOutlier(align))){/* update align->score, align->logPV etc */

      align->score = bestscore;
      align->orientation = orientation;
      align->rev = rev;
      align->scaleID = scaleID;
      align->Nrange = IMAX-IMIN+1;
      align->Mrange = jmax-jmin+1;
      align->logPV = logPV;
      align->Lend = I;
      align->Rend = bestR;

      I = Ilist[U-1];
      int K = Klist[U-1];
      int J = Jlist[U-1];

      if(DEBUG>=2) assert(align->Lend <= -2 || J <= DELTA_X || (extend && I-K <= DELTA_Y));
      align->Lij1 = (align->Lend <= -2) ? I-K : A->Lij(I,K,J);
      if(DEBUG>=2 && !(align->Lij1 <= I-K && align->Lij1 >= 0)){
#pragma omp critical
	{
	  printf("refid=%d,mapid=%d,or=%d:N=%d,M=%d:I=%d,K=%d,J=%d:align->Lend=%d,align->Lij1=%d,A->Lij(I,K,J)=%d,extend=%d,IMIN=%d,IMAX=%d,JMIN[I]=%d,JMAX[I]=%d\n",
		 refid,mapid,orientation,N,M,I,K,J,align->Lend,align->Lij1,A->Lij(I,K,J), extend, IMIN,IMAX,JMIN[I],JMAX[I]);
	  fflush(stdout);
	  assert(align->Lij1 <= I-K && align->Lij1 >= 0);
	}
      }
      align->Lij2 = (align->Lend <= -2) ? J : extend ? A->Lijx(I,K,J) : 0;
      if(DEBUG>=2) assert(align->Lij2 <= J && align->Lij2 >= 0);
      if(DEBUG>=2) assert(align->Rend <= -2 || bestJ >= M+1 - DELTA_X || (extend && bestI >= N+1-DELTA_Y));
      align->Rij1 = (align->Rend <= -2) ? bestI : A->Rij(bestI,bestK,bestJ);
      if(DEBUG>=2) assert(align->Rij1 >= bestI && align->Rij1 <= N+1);
      align->Rij2 = (align->Rend <= -2) ? bestJ : extend ? A->Rijx(bestI,bestK,bestJ) : M+1;
      if(DEBUG>=2) assert(align->Rij2 >= bestJ && align->Rij2 <= M+1);

#if CALIGN_END==0
      align->LijY = A->Lij(I,K,J);
      align->LijX = extend ? A->Lijx(I,K,J) : 0;
      align->RijY = A->Rij(bestI,bestK,bestJ);
      align->RijX = extend ? A->Rijx(bestI,bestK,bestJ) : M+1;
#endif

      align->repeat = -1;

      if(PVERB/* HERE >=3 */ || REFSPLIT_FIX >= 1 /* WAS7 >=2 */){
	double scoresum = 0.0;
	for(int t = 0; t <= U; t++)
	  scoresum += iscore[t];

	if(PVERB/* HERE >=3 */){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,scaleID=%d:bestscore=%0.6f(I=%d,K=%d,J=%d,R=%d,IL=%d),align updated:score=%0.6f,logPV=%0.2f,or=%d,rev=%d,sc=%d,iscore[0..%d]= %0.6f,EndOut=%d\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,bestIL,align->score,align->logPV,align->orientation,align->rev,align->scaleID,
		 U, scoresum, AlignedEndOutlier(align) ? 1 : 0);
	  fflush(stdout);
	  if(DEBUG && REFSPLIT_FIX <= 0 /* WAS7 1 */) assert(fabs(scoresum - bestscore) < ASCORE_MARGIN + SCORE_MARGIN * fabs(bestscore));
	}
	if(REFSPLIT_FIX /* WAS7 >= 2 */)
	  align->score = bestscore = scoresum;
      }

      if(DEBUG && align->numpairs > 0) assert(!align->rev || rev == 1);

      if(RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0)
	align->repeat = 0;

      /* (re)allocate best alignment */
      align->numpairs = 0;
      if(!GOODMAPS || (align->score > ScoreThreshold && align->logPV > LogPvThreshold && U >= AlignedSiteThreshold && AlignedEndOutlier(align))){/* save alignment */
	if(DEBUG) assert(U > 0);	
	align->expand_arrays(U);
	align->numpairs = U;

	/* copy alignment from Ilist[],Jlist[] in reverse order */
	for(int I= 0; I < U; I++){
	  align->sites1[I] = Ilist[U-1-I];
	  align->sitesK1[I] = Klist[U-1-I];
	  align->sites2[I] = Jlist[U-1-I];
	  align->iscore[I] = iscore[U-I];
	  align->outscore[I] = outscore[U-I];
	}
	align->iscore[U] = iscore[0];
	align->outscore[U] = outscore[0];
      
	align->maxoutlier = 0.0;
	align->noutliers = 0;
	align->maxoutlierLabels = 0;// NEW302
	int lastI = align->sites1[0];
	int lastK = align->sitesK1[0];
	int lastJ = align->sites2[0];
	int I,K,J;
	for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
	  I = align->sites1[t];
	  K = align->sitesK1[t];
	  J = align->sites2[t];
	  if(align->outscore[t] + (RFLOAT)0.01 < align->iscore[t]){
	    align->noutliers++;
	    double deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	    double deltaX = X[J] - X[lastJ];
	    if(DEBUG) assert(deltaX > 0.0);
	    double delta = fabs(deltaY-deltaX);
	    align->maxoutlier = max(delta,align->maxoutlier);
	    align->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, align->maxoutlierLabels);// NEW302
	  }
	  if(PVERB>=3){
	    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	    FLOAT deltaX = X[J] - X[lastJ];
	    if(DEBUG) assert(deltaX > 0.0);
	    FLOAT delta = fabs(deltaY - deltaX);
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:t=%d/%d:I=%d..%d,K=%d..%d,J=%d..%d,iscore[t]=%0.6f,outscore[t]=%0.6f,delY=%0.3f,delX=%0.3f,out=%0.3f:maxoutlier=%d,%0.3f,%d\n",
		   refid,rmap->id,mapid,nanomap->id,align->orientation,align->rev,align->scaleID,t,U,lastI,I,lastK,K,lastJ,J,
		   align->iscore[t],align->outscore[t],deltaY,deltaX,delta,align->noutliers,align->maxoutlier,align->maxoutlierLabels);
	    fflush(stdout);
	  }
	}
	if(DEBUG/* HERE HERE >=2 */) assert(align->noutliers >= 0 && align->maxoutlier >= 0.0 && align->maxoutlierLabels >= 0 &&
					    (align->noutliers <= 0 || align->maxoutlier > 0.0 || align->maxoutlierLabels > 0));

	if(PVERB>=2){
	  printf("Updated align : np=%d,Len= %0.3f, AlignedLengthThreshold= %0.3f\n",align->numpairs, AlignedLength(align,align->rev ? Y : YYmap[refid]->site[0]), AlignedLengthThreshold);
	  fflush(stdout);
	}

	if(DEBUG/* HERE HERE >=2 */) assert(align->noutliers >= 0 && align->maxoutlier >= 0.0 && align->maxoutlierLabels >= 0 &&
					    (align->noutliers <= 0 || align->maxoutlier > 0.0 || align->maxoutlierLabels > 0));

	if(AlignedLength(align,align->rev ? Y : YYmap[refid]->site[0]) > AlignedLengthThreshold){

	  /* check if bestscore is a repeat */
	  if(RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0 && extend && !(DEBUG>=2 && error) /* WAS && (align->Lij2 > 0 || align->Rij2 <= M) */ ){
	    checkRepeat(Y,N,X,M,orientation,rev,scaleID,Kmax,A,JMIN,JMAX,Imin,Imax,align,rmap,nanomap,refid,mapid,XPen,phash,tid,
			PRtabY,YPenR,localtype,IMIN,IMAX,jmin,jmax,maxUscore,biasend2_values, bestI,bestK,bestJ,U,Ilist,Klist,Jlist);
	    if(PVERB>=2){
              #pragma omp critical
	      {
	        printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f,logPV=%0.2f,numpairs=%d,Length=%0.3f,repeat=%d\n",
		  refid,rmap->id,mapid,nanomap->id,orientation,rev,align->score,align->logPV,U,AlignedLength(align,Y),align->repeat);
		fflush(stdout);
	      }
	    }
	  }
	} // if(AlignedLength() > AlignedLengthThreshold)
	if(DEBUG && align->numpairs > 0) assert(!align->rev || rev == 1);

      } else if(PVERB>=2){/* else alignment information will not be used */
	printf("Align NOT Updated: score=%0.6f(ScoreThreshold= %0.3f), logPV= %0.2f (LogPvThreshold= %0.2f), U=%d(AlignedSiteThreshold= %d), EndOut=%d\n",
	       align->score, ScoreThreshold, align->logPV, LogPvThreshold, U, AlignedSiteThreshold, AlignedEndOutlier(align));
	fflush(stdout);
      }

      if((PVERB && align->numpairs <= 0 && (PVERB>=2 || giter==RefRepeats-1)) || (DEBUG>=2 && error)){
#pragma omp critical
	{
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,scaleID=%d:bestscore=%0.4f(I=%d,K=%d,J=%d,R=%d,IL=%d),align:score=%0.6f,or=%d,rev=%d,scaleID=%d,logPV=%0.2f,numpairs=%d->%d(IMIN=%d,IMAX=%d,N=%d)!\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,bestIL,align->score,align->orientation,align->rev,align->scaleID,align->logPV,U,align->numpairs,IMIN,IMAX,N);
	  fflush(stdout);
	}
      }

      //    if(DEBUG && align->numpairs > 0 && align->score > ScoreThreshold && align->logPV > LogPvThreshold) assert(U==align->numpairs);

      if((DEBUG>=2 && error && align->numpairs > 0) || (PVERB && align->numpairs > 0 && 
							(PVERB>=2 || (giter==RefRepeats-1 /* &&  nanomap->id== 844564 && align->orientation && rmap->id==257*/ && align->score > ScoreThreshold && align->logPV > LogPvThreshold /* && mapid==126*/ 
								      /* &&(U >= 4 && Yc(Y,align->sites1[U-2],align->sitesK1[U-2]) >= 1096.0 && Yc(Y,align->sites1[1],align->sitesK1[1]) <= 1082.0) */
								      ) /*||  (mapid==1254 && align->orientation) */ /* || fabs(offset-trueoffset) > 2*Ylambda || align->orientation*/))){
#pragma omp critical 
	{
	  RFLOAT offset = Yc(Y,bestI,bestK) /* WAS21 bestYik */ - X[bestJ];
	  Cmap *pmap = nanomap;
	  while(pmap->origmap)
	    pmap = pmap->origmap;
      
	  RFLOAT C = ChimScore;
	  int numpairs,Lend;
	  if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	  (void)alignFPsd(A,bestI,bestJ,bestK,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,bestR,orientation,rev,scaleID,refid,mapid,0,(PVERB>=3) ? 1 : 0, numpairs,Lend,bestIL/* WAS3 -1 */,0,0);
	  if(DEBUG && numpairs != align->numpairs){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:bestscore=%0.6f(I=%d,K=%d,J=%d,R=%d),logPV=%0.2f: align->numpairs=%d (based on alignExtract()), numpairs= %d(based on alignFPsd)\n",
		   refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,align->logPV,align->numpairs,numpairs);
	    fflush(stdout);
	    assert(numpairs == align->numpairs);
	  }

	  double scoresum = 0.0;
	  for(int t = 0; t <= numpairs; t++)
	    scoresum += align->iscore[t];

	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:score=%0.6f(I=%d,K=%d,J=%d,R=%d),logPV=%0.2f,iscore[0..%d]= %0.6f,Len=%0.3f,MaxOutlier=%0.3f:scale=%0.4f,offset=%0.3f(%0.3f-%0.3f),repeat=%d,Lend=%d,Rend=%d,Cscore=%0.4e,multi=%d,fpcnt=%d:%s\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,rev,scaleID,bestscore,bestI,bestK,bestJ,bestR,align->logPV,align->numpairs,scoresum,AlignedLength(align,align->rev ? Y : YYmap[refid]->site[0]),align->maxoutlier, scaleID ? ScaleFactor[scaleID] : 1.0,
		 offset,bestYik,X[bestJ],align->repeat,align->Lend,align->Rend,ChimScore,align->multicnt, M-align->numpairs,pmap->name ? pmap->name : "");
	  if(maxresbias > mres * 0.5)
	    printf("\t sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f,FP=%0.6f,FN=%0.8f,res=%0.8f,resSD=%0.8f,resbiasX[0][0]=%0.6f,resbias[0][0]=%0.8f\n",SF[0],SD[0],SR[0],SE[0],FP[0],FN[0],res[0],resSD[0],resbiasX[0][0],resbias[0][0]);
	  else
	    printf("\t sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f,FP=%0.6f,FN=%0.8f,res=%0.8f,resSD=%0.8f\n",SF[0],SD[0],SR[0],SE[0],FP[0],FN[0],res[0],resSD[0]);
	  int I= -1,J= -1 ,K=0, G= -1,H= -1, D = 0;
	  if(DEBUG) assert(U==align->numpairs);

	  // extern int rverb;
	  //      rverb = 1;

	  for(int T=0; T < U; T++, G=I, H=J, D=K){
	    I = align->sites1[T];
	    K = align->sitesK1[T];
	    J = align->sites2[T];
	    printf("T=%2d:I=%2d,K=%2d,J=%2d:",T,I,K,J);
	    if(T<=0){ /* Left End: display Send(min(X[J],Y[I-K..I]),J+1-max(1,Lijx),I+1-max(1,Lij))+Sm(J,I,K), A->score[I,K,J] */
	      if(DEBUG && align->Lend > -2) assert(J <= DELTA_X || (extend && I-K <= DELTA_Y));
	      int Lij = (align->Lend <= -2) ? I-K : A->Lij(I,K,J);
	      if(DEBUG && align->Lend > -2 && extend) assert(I-K <= DELTA_Y || J <= DELTA_X);
	      int Lijx = (align->Lend <= -2) ? J : extend ? A->Lijx(I,K,J) : 0;

	      if(align->Lend <= -2 && (NEW==1 || align->Lend == -2))
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I,K]=%6.3f,C=%0.6f(%d),Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),C,localtype,Sm(J,I,K,Y),C+Sm(J,I,K,Y),A->score(I,K,J));
	      else if(align->Lend <= -3)
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I,K]=%6.3f,EndPen=%0.6f,BiasEnd=%0.6f,Sm(J,I,K)=%0.6f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),ChimScore,BiasEnd(X[J],J),Sm(J,I,K,Y),BiasEnd(X[J],J)+ChimScore+Sm(J,I,K,Y),A->score(I,K,J));
	      else if(ENDFIX && X[J] <= Yc(Y,I,K) && Lij > 0 && Yc(Y,I,K) - Y[Lij-1] < X[J]){
		RFLOAT score = Sbnd(X[J],Yc(Y,I,K)-Y[Lij-1],J,I-K+1-Lij,I-K,refid);
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I]=%6.3f,Sbnd(X[J],Y[I,K]-Y[Lij-1],J,I-K+1-Lij)=%0.6f,Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),score,Sm(J,I,K,Y), max(C,score+(RFLOAT)Sm(J,I,K,Y)), A->score(I,K,J));
		if(DEBUG) assert(Lijx <= 0);
	      } else if(ENDFIX && extend && X[J] >= Yc(Y,I,K) && Lijx > 0 && X[J]-X[Lijx-1] < Yc(Y,I,K)){
		RFLOAT score = Sbnd(X[J]-X[Lijx-1],Yc(Y,I,K),J+1-Lijx,I-K,I-K,refid);
		printf("Lijy=%d,Lijx=%d,X[J]=%0.6f,Y[I,K]=%6.3f,Sbnd(%0.3f,%0.3f,%d,%d)=%0.6f,Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Y[I],X[J]-X[Lijx-1],Yc(Y,I,K),J+1-Lijx,I-K, score,Sm(J,I,K,Y), max(C,score+(RFLOAT)Sm(J,I,K,Y)), A->score(I,K,J));
		if(DEBUG) assert(Lij <= 0);
	      } else {
		RFLOAT score = Send(min(X[J],Yc(Y,I,K)),J+1-max(1,Lijx) ,I-K+1 - max(1,Lij),I-K,refid,0);
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I,K]=%6.3f,Send(min(X[J],Y[I,K]),J+1-max(1,Lijx),I-K+1-max(1,Lij))=%0.6f,Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),score,Sm(J,I,K,Y), max(C,(extend || Lij > 0) ? score+(RFLOAT)Sm(J,I,K,Y) : (RFLOAT)MINSCORE), A->score(I,K,J));
	      }
	    } else {/* internal interval : display Sint(X[J]-X[H],Y[I,K]-Y[G,D],J-H,I-K-G) + Sm(J,I,K), A[I,K,J].score */
	      if(DEBUG) assert(G>=0 && H>=0 && D>=0);
	      RFLOAT x = X[J] - X[H];
	      RFLOAT y = Yc(Y,I,K) - Yc(Y,G,D);
	      RFLOAT Pen,Gauss,Bias,PenSm, sint;
	      RFLOAT OutPen = OutlierPenalty;
	      SintDetail(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	      if(maptype){
		if(outlierBC)
		  OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
		if(OUTLIER_LTYPE==0)
		  OutPen -= (x+y) * OutlierLambdaInv;
		else
		  OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
		sint = (OUTLIER_TYPE1 == 0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
		  OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm; // Sint(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y);
#else // NEW
		sint = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE1 + OutPen) + PenSm; // Sint(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y);
#endif
	      } else if(OUTLIER_DELTA(x-y)){
		if(outlierBC)
		  OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
		OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
		sint = (OUTLIER_TYPE == 0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
		  OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm; // Sint(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y);
#else // NEW
		sint = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE + OutPen) + PenSm; // Sint(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y);
#endif
	      } else
		sint = Bias + Pen + Gauss + PenSm;

	      double var = SF[0]*SF[0]+fabs(SD[0])*SD[0]*y;
	      if(QUADRATIC_VARIANCE)
		var += SR[0]*SR[0]*y*y;
	      if(RES_VARIANCE){
		FLOAT resR = Y[I] - Y[I-K];
		FLOAT resL = Y[G] - Y[G-D];
		FLOAT resvar = resL*resL + resR*resR;
		var += SE[0]*SE[0]*resvar;
	      }

	      double err = x-y;
	      if(align->orientation) {
		printf("G=%2d,H=%2d,D=%2d,X[J]=%0.3f,Y[I,K]=%0.3f,X[J]-X[H]=%0.5f,Y[I,K]-Y[G,D]=%0.5f,norm=%0.4f,Sint(X,Y,%d,%d)=%0.6f(Pen=%0.6f,Gterm=%0.6f,Gerr=%0.6f,Bias=%0.6f,Sm=%0.6f,Out=%0.6e,var=%0.8e),A[I,K,J]=%0.6f,(X[M+1]-X[J])/C=%0.3f\n",
		       G,H,D,X[J],Yc(Y,I,K),x,y,err*err/var,J-H,I-K-G,sint,Pen,Gauss + err*err*0.5/var,err*err*0.5/var,Bias,PenSm,Bias*biasWToutlierF + OutPen, var, A->score(I,K,J), (X[M+1]-X[J])*origPixelLen/PixelLen);
	      } else {
		printf("G=%2d,H=%2d,D=%2d,X[J]=%0.3f,Y[I,K]=%0.3f,X[J]-X[H]=%0.5f,Y[I,K]-Y[G,D]=%0.5f,norm=%0.4f,Sint(X,Y,%d,%d)=%0.6f(Pen=%0.6f,Gterm=%0.6f,Gerr=%0.6f,Bias=%0.6f,Sm=%0.6f,Out=%0.6e,var=%0.8e),A[I,K,J]=%0.6f,X[J]/C=%0.3f\n",
		       //	    printf("G=%2d,H=%2d,D=%2d,X[J]=%0.8f,Y[I,K]=%0.8f,X[J]-X[H]=%0.8f,Y[I,K]-Y[G,D]=%0.8f,norm=%0.8f,Sint(X,Y,%d,%d)=%0.8f(Pen=%0.8f,Bias=%0.8f,Sm=%0.8f,var),A[I,K,J]=%0.8f,X[J]/C=%0.8f\n",
		       G,H,D,X[J],Yc(Y,I,K),x,y,err*err/var,J-H,I-K-G,sint,Pen,Gauss + err*err*0.5/var,err*err*0.5/var,Bias,PenSm,Bias*biasWToutlierF + OutPen, var, A->score(I,K,J),X[J]*origPixelLen/PixelLen);
	      }
	    }
	  }
	  if(DEBUG && align->Rend > -2) assert(J >= ((extend && I >= N+1-DELTA_Y) ? 1 : max(1,M+1-DELTA_X)));
	  int Rij = (align->Rend <= -2) ? I : A->Rij(I,K,J);
	  if(DEBUG && extend && align->Rend > -2) assert(I>=N+1-DELTA_Y || J >= M+1-DELTA_X);
	  int Rijx = (align->Rend <= -2) ? J : extend ? A->Rijx(I,K,J) : M+1;

	  /* Right End: display Rij,Send(X[M+1]-X[J],min(M,Rijx)+1-J,min(N,Rij)+1-I) */
	  if(align->Rend <= -2 && (NEW==1 || align->Rend == -2))
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rijk=%d,Rijkx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,C=%0.6f(%d),total score=%0.6f, X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), C, localtype, A->score(I,K,J) + C, X[M+1]*origPixelLen/PixelLen);
	  else if(align->Rend <= -3)
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rijk=%d,Rijkx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,EndPen=%0.6f,BiasEnd=%0.6f,total score=%0.6f, X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), ChimScore, BiasEnd2(X[M+1]-X[J],M+1-J), A->score(I,K,J) + ChimScore+BiasEnd(X[M+1]-X[J],M+1-J), X[M+1]*origPixelLen/PixelLen);
	  else if(ENDFIX && X[M+1]-X[J] <= Y[N+1]-Yc(Y,I,K) && Rij <= N && Y[Rij+1]-Yc(Y,I,K) < X[M+1]-X[J]){
	    RFLOAT score = Sbnd(X[M+1]-X[J],Y[Rij+1]-Yc(Y,I,K),min(M,Rijx)+1-J,Rij+1-I,Rij,refid);
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rij=%d,Rijx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Yc(Y,I,K)=%0.3f,Sbnd(X[M+1]-X[J],Y[Rij+1]-Y[I,K],min(M,Rijx)+1-J,Rij+1-I)=%0.6f,total score=%0.6f,X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), score, A->score(I,K,J) + max(C, score), X[M+1]*origPixelLen/PixelLen);
	  } else if(ENDFIX && X[M+1]-X[J] >= Y[N+1]-Yc(Y,I,K) && Rijx <= M && X[A->Rijx(I,K,J)+1]-X[J] < Y[N+1]-Yc(Y,I,K)){
	    RFLOAT score = Sbnd(X[Rijx+1]-X[J],Y[N+1]-Yc(Y,I,K)  ,Rijx+1-J,min(N,Rij)+1-I,min(N,Rij),refid);
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rij=%d,Rijx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,Sbnd(X[Rijx+1]-X[J],Y[N+1]-Y[I,K],Rijx+1-J,min(N,Rij)+1-I)=%0.6f,total score=%0.6f,X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), score,  A->score(I,K,J) + max(C, score), X[M+1]*origPixelLen/PixelLen);
	  } else {
	    //	    int rverb = (PVERB>=2 ? 1 : 0);
	    RFLOAT score = Send(min(X[M+1]-X[J],Y[N+1]-Yc(Y,I,K)),min(M,Rijx)+1-J,min(N,Rij)+1-I,min(N,Rij),refid,/* rverb */0);
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rij=%d,Rijx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,Send(min(X[M+1]-X[J],Y[N+1]-Y[I,K]),min(M,Rijx)+1-J,min(N,Rij)+1-I)=%0.6f,total score=%0.6f,X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), score, A->score(I,K,J) + max(C, (!extend && Rij > N) ? (RFLOAT)MINSCORE : score), X[M+1]*origPixelLen/PixelLen);
	  }
	  fflush(stdout);
	  if(DEBUG) assert(Rij >= I && Rij <= N+1);
	  //      if(DEBUG>=2)
	  //	fflush(stdout);exit(1);
	} // pragma omp critical
      } // if(VERB...) 
    } /* NEW8 update align->score, align->logPV etc */
  }// if(bestscore > align->score + 1e-8)

  if(DEBUG/* HERE HERE >=2 */ && align->numpairs > 0) assert(align->noutliers >= 0 && align->maxoutlier >= 0.0 && align->maxoutlierLabels >= 0 &&
							     (align->noutliers <= 0 || align->maxoutlier > 0.0 || align->maxoutlierLabels > 0));

  if(DEBUG && MultiMatches && align->score >= ScoreThreshold2 && align->logPV > LogPvThreshold2 && align->numpairs >= AlignedSiteThreshold2 && AlignedEndOutlier2(align) && 
     min(999.0,align->maxoutlier) <= AlignedOutlierThreshold2 && min(999,align->maxoutlierLabels) <= AlignedOutlierLabels2 &&
     AlignedLength(align,align->rev ? Y : YYmap[refid]->site[0]) > AlignedLengthThreshold && align->repeat <= 0 && 
     (PVERB || !(align->Malign && align->multicnt > 0))){
	    // NOTE : using -L threshold instead of -L2 threshold, since align->repeat was not computed unless  -L threshold was satisfied by align
    #pragma omp critical
    {
      int U = align->numpairs;
      printf("WARNING:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:bestscore=%0.6f(I=%d,K=%d,J=%d,R=%d),align:I=%d..%d,K=%d..%d,J=%d..%d:or=%d,rev=%d,score=%0.6f,logPV=%0.2f,numpairs=%d,Length=%0.3f,Lend=%d,Rend=%d,outlier=%0.3f,repeat=%d:S2=%0.4f,T2=%0.4f,E2=%d,I2=%0.3f,%d,L=%0.3f:align->Malign=%p, align->multicnt=%d,nummatchgroup=%d\n",
	     refid,rmap->id,mapid,nanomap->id,orientation,rev,bestscore,bestI,bestK,bestJ,bestR,align->sites1[0],align->sites1[U-1],align->sitesK1[0],align->sitesK1[U-1],align->sites2[0],align->sites2[U-1],
	     align->orientation,align->rev,align->score,align->logPV,align->numpairs,AlignedLength(align,YYmap[refid]->site[0]),align->Lend,align->Rend,align->maxoutlier,align->repeat,
	     ScoreThreshold2,LogPvThreshold2,AlignedEndOutlierThreshold2,AlignedOutlierThreshold2,AlignedOutlierLabels2,AlignedLengthThreshold,align->Malign,align->multicnt,nummatchgroup);
      fflush(stdout);
      if(DEBUG>=2) assert(align->Malign && align->multicnt > 0);// NOTE : may fail rarely if MULTIMATCHES_FILTER and rightmost alignment interval has -ve score < -MULTIMATCHES_FILTER
    }
  }
  
  if(DEBUG && align->numpairs > 0) assert(!align->rev || rev == 1);

  if(DEBUG>=2 && error)
    assert(0);

  if(SecondBest && bestscore2 > ScoreThreshold2 && (!align->align2 || bestscore2 > align->align2->score + 1e-8)){/* check if 2nd best alignment should be saved as overall 2nd best alignment */
    int U = align->numpairs;
    FLOAT alignYik = (U <= 0) ? -1e30 : Yc(Y,align->sites1[U-1],align->sitesK1[U-1]);
    if(align->orientation != orientation || fabs(alignYik - bestYik2) >= MinSpacing){   /* backtrack through array to retrieve 2nd best alignment starting at right end A[bestI2][bestK2][bestJ2] */
      if(PVERB>=2){
        #pragma omp critical
	{
	  if(align->align2){
	    Calign *align2 = align->align2;
	    printf("Replacing previous 2nd best alignment with bestscore2= %0.4f,orientation=%d,bestI2=%d,bestK2=%d,bestJ2=%d:refid=%d,mapid=%d(id=%lld),orientation=%d:score=%0.4f,logPV=%0.2f,numpairs=%d\n",
		   bestscore2, orientation, bestI2, bestK2, bestJ2, align2->mapid1,align2->mapid2,Gmap[align2->mapid2]->id,align2->orientation,align2->score,align2->logPV,align2->numpairs);
	  } else
	    printf("Creating 2nd best alignment with bestscore2= %0.4f,orientation=%d,bestI2=%d,bestK2=%d,bestJ2=%d\n", bestscore2, orientation, bestI2, bestK2, bestJ2);
	  fflush(stdout);
	}
      }

      if(DEBUG) assert(bestI2 >= 0);
      if(DEBUG) assert(Ilist != 0);

      int I = bestI2;
      int K = bestK2;
      int J = bestJ2;

      int U = 0;

      /* right end segment */
      outscore[0] = iscore[0] = bestscore2 - A->score(I,K,J);

      while(I > 0){
	if(DEBUG>=2){
	  assert(I-K >= 1 && IMIN <= I && I <= IMAX);
	  assert(J >= JMIN[I] && J <= JMAX[I]);
	}
	Ilist[U] = I;
	Klist[U] = K;
	Jlist[U] = J;
	int G = A->G(I,K,J);
	RFLOAT score = A->score(I,K,J);
	if(PVERB>=2 && G <= 0){
	  printf("I=%d,K=%d,J=%d:G=%d,A->score(I,K,J)=%0.6f\n",I,K,J,G,score);
	  fflush(stdout);
	}
	if(G > 0){
	  int T = A->T(I,K,J);
	  int H = A->H(I,K,J);
	  if(PVERB>=2){
	    printf("I=%d,K=%d,J=%d:G=%d,T=%d,H=%d,A->score(I,K,J)=%0.6f\n",I,K,J,G,T,H,score);
	    fflush(stdout);
	  }
	  if(DEBUG>=2) assert(H > 0 && T >= 0);
	  iscore[U+1] = score - A->score(G,T,H);
	  RFLOAT x = X[J]-X[H];
	  RFLOAT y = Yc(Y,I,K) - Yc(Y,G,T);
	  if(maptype){
	    RFLOAT Bias,Pen,Gauss,PenSm;
	    SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	    outscore[U+1] = Bias + Pen + Gauss + PenSm;
	    if(DEBUG>=2){
	      RFLOAT OutPen = OutlierPenalty;
	      if(outlierBC)
		OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
	      if(OUTLIER_LTYPE==0)
		OutPen -= (x+y) * OutlierLambdaInv;
	      else
		OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
	      RFLOAT iscore2 = (OUTLIER_TYPE1 == 0) ? OutlierBias + max(Bias + Pen + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
		OutlierBias + Pen + max(Bias + Gauss, OutPen + Bias * biasWToutlierF) + PenSm;
#else // NEW
	      RFLOAT iscore2 = OutlierBias + max(Bias + Pen + Gauss, OutPen + Pen * OUTLIER_TYPE1 + Bias * biasWToutlierF) + PenSm;
#endif
	      if(!(fabs(iscore2-iscore[U+1]) < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN)){
                #pragma omp critical
		{
		  printf("mapid=%d(id=%lld):I=%d,J=%d,K=%d:G=%d,T=%d,H=%d:U=%d,x=%0.3f,y=%0.3f,Bias=%0.9f,OutBias=%0.9f,Pen=%0.9f,OutlierPenalty=%0.9f,outscore[U+1]=%0.9f:iscore2=%0.9f,iscore[U+1]=%0.9f(err=%0.9f):score=%0.9f,score(G,T,H)=%0.9f\n",
			 mapid,nanomap->id,I,J,K,G,T,H,U,x,y,Bias,OutlierBias,Pen,OutlierPenalty,outscore[U+1],iscore2,iscore[U+1],fabs(iscore2-iscore[U+1]), score, A->score(G,T,H));
		  fflush(stdout);
		  
		  /* NOTE : large -ve scores and hence rounding errors can occur with -maptype 0, since that disables -outlier for |x-y| > maxOutlier */
		  assert(fabs(iscore2-iscore[U+1]) < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN);
		  assert(0);
		}
	      }
	    }
	  } else if(OUTLIER_DELTA(x-y)){
	    RFLOAT Bias,Pen,Gauss,PenSm;
	    SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	    outscore[U+1] = Bias + Pen + Gauss + PenSm;
	    if(DEBUG>=2){
	      RFLOAT OutPen = OutlierPenalty;
	      if(outlierBC)
		OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
	      OutPen -= fabs(x-y) * OutlierLambdaInv;

#if 0 // OLD
	      RFLOAT iscore2 = (OUTLIER_TYPE == 0) ? OutlierBias + max(Bias + Pen + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
		OutlierBias + Pen + max(Bias + Gauss, OutPen + Bias * biasWToutlierF) + PenSm;
#else // NEW
	      RFLOAT iscore2 = OutlierBias + max(Bias + Pen + Gauss, OutPen + Pen*OUTLIER_TYPE + Bias * biasWToutlierF) + PenSm;
#endif
	      if(!(fabs(iscore2-iscore[U+1])  < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN)){
                #pragma omp critical
		{
		  printf("mapid=%d(id=%lld):I=%d,J=%d,K=%d:G=%d,T=%d,H=%d:U=%d,x=%0.3f,y=%0.3f,Bias=%0.9f,OutBias=%0.9f,Pen=%0.9f,OutlierPenalty=%0.9f,outscore[U+1]=%0.9f:iscore2=%0.9f,iscore[U+1]=%0.9f(err=%0.9f):score=%0.9f,score(G,T,H)=%0.9f\n",
			 mapid,nanomap->id,I,J,K,G,T,H,U,x,y,Bias,OutlierBias,Pen,OutlierPenalty,outscore[U+1],iscore2,iscore[U+1],fabs(iscore2-iscore[U+1]), score, A->score(G,T,H));
		  fflush(stdout);
		  
		  /* NOTE : large -ve scores and hence rounding errors can occur with -maptype 0, since that disables -outlier for x > y */
		  assert(fabs(iscore2-iscore[U+1]) < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN);
		  assert(0);
		}
	      }
	    }
	  } else {/* no possible outlier */
	    outscore[U+1] = iscore[U+1];
	  }

	  K = T;
	  J = H;
	} else {/* left end segment */
	  outscore[U+1] = iscore[U+1] = score;
	}
	U++;
	I = G;
      }

      if(DEBUG) assert(U > 0);
      if(DEBUG) assert(I <= (isLinear ? -1 : 0));

      delete [] align->align2; align->align2 = NULL;
      Calign *align2 = align->align2 = new Calign[1];
      align2->mapid1 = refid;
      align2->mapid2 = mapid;

      align2->score = bestscore2;
      align2->orientation = orientation;
      align2->scaleID = scaleID;
      int numpairs,Lend;
      align2->Nrange = IMAX-IMIN+1;
      align2->Mrange = jmax-jmin+1;
      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(align2->Mrange == M);
      align2->logPV = alignFPsd(A,bestI2,bestJ2,bestK2,Y,X,N,M,align2->Nrange,align2->Mrange,bestR2,orientation,rev,scaleID,refid,mapid,0,0, numpairs,Lend,-1,0,0);
      align2->Lend = I;
      align2->Rend = bestR2;
      
      I = Ilist[U-1];
      K = Klist[U-1];
      J = Jlist[U-1];

      if(DEBUG>=2) assert(align2->Lend <= -2 || J <= DELTA_X || (extend && I-K <= DELTA_Y));
      align2->Lij1 = (align2->Lend <= -2) ? I-K : A->Lij(I,K,J);
      if(DEBUG>=2) assert(align2->Lij1 <= I-K && align2->Lij1 >= 0);
      align2->Lij2 = (align2->Lend <= -2) ? J : extend ? A->Lijx(I,K,J) : 0;
      if(DEBUG>=2) assert(align2->Lij2 <= J && align2->Lij2 >= 0);
      if(DEBUG>=2) assert(align2->Rend <= -2 || bestJ2 >= M+1 - DELTA_X || (extend && bestI2 >= N+1-DELTA_Y));
      align2->Rij1 = (align2->Rend <= -2) ? bestI2 : A->Rij(bestI2,bestK2,bestJ2);
      if(DEBUG>=2) assert(align2->Rij1 >= bestI2 && align2->Rij1 <= N+1);
      align2->Rij2 = (align2->Rend <= -2) ? bestJ2 : extend ? A->Rijx(bestI2,bestK2,bestJ2) : M+1;
      if(DEBUG>=2) assert(align2->Rij2 >= bestJ2 && align2->Rij2 <= M+1);
      
#if CALIGN_END==0
      align2->LijY = A->Lij(I,K,J);
      align2->LijX = extend ? A->Lijx(I,K,J) : 0;
      align2->RijY = A->Rij(bestI2,bestK2,bestJ2);
      align2->RijX = extend ? A->Rijx(bestI2,bestK2,bestJ2) : M+1;
#endif
      align2->repeat = -1;
      /* (re)allocate 2nd best alignment */
      align2->allfree();
      if(DEBUG) assert(U > 0);
      align2->expand_arrays(U);
      align2->numpairs = U;
      
      /* copy alignment from Ilist[],Jlist[] in reverse order */
      for(int I= 0; I < U; I++){
	align2->sites1[I] = Ilist[U-1-I];
	align2->sitesK1[I] = Klist[U-1-I];
	align2->sites2[I] = Jlist[U-1-I];
	align2->iscore[I] = iscore[U-I];
	align2->outscore[I] = outscore[U-I];
      }
      align2->iscore[U] = iscore[0];
      align2->outscore[U] = outscore[0];
      
      align2->noutliers = 0;
      align2->maxoutlier = 0.0;
      align2->maxoutlierLabels = 0;
      int lastI = align2->sites1[0];
      int lastK = align2->sitesK1[0];
      int lastJ = align2->sites2[0];
      for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
	I = align2->sites1[t];
	K = align2->sitesK1[t];
	J = align2->sites2[t];
	if(align2->outscore[t] + (RFLOAT)0.01 < align2->iscore[t]){
	  align2->noutliers++;
	  double deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	  double deltaX = X[J] - X[lastJ];
	  if(DEBUG) assert(deltaX > 0.0);
	  double delta = fabs(deltaY-deltaX);
	  align2->maxoutlier = max(delta,align2->maxoutlier);
	  align2->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, align2->maxoutlierLabels);// NEW302
	}
      }
      if(DEBUG/* HERE HERE >=2 */) assert(align2->noutliers >= 0 && align2->maxoutlier >= 0.0 && align2->maxoutlierLabels >= 0 &&
					  (align2->noutliers <= 0 || align2->maxoutlier > 0.0 || align2->maxoutlierLabels > 0));

      if(DEBUG/* HERE HERE >=2 */) assert(align2->noutliers >= 0 && align2->maxoutlier >= 0.0 && align2->maxoutlierLabels >= 0 &&
					  (align2->noutliers <= 0 || align2->maxoutlier > 0.0 || align2->maxoutlierLabels > 0));

      if(VERB >= 2-PVERB && bestscore2 > ScoreThreshold2 && (VERB>=2 ||  giter==RefRepeats-1 /* && nanomap->id== 3272 ||  (mapid==1254 && align->orientation) */ /* || fabs(offset-trueoffset) > 2*Ylambda || align->orientation*/)){
#pragma omp critical 
	{ 
	  RFLOAT C = ChimScore;
	  FLOAT offset = bestYik2 - X[bestJ2];
	  FLOAT trueoffset = nanomap->endloc - X[M+1];
	  FLOAT delta = offset-trueoffset;
	  Cmap *pmap = nanomap;
	  while(pmap->origmap)
	    pmap = pmap->origmap;

	  int numpairs,Lend;

	  if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	  (void)alignFPsd(A,bestI2,bestJ2,bestK2,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,bestR2,orientation,rev,scaleID,refid,mapid,0,1, numpairs,Lend,-1,0,0);
	  printf("2nd Best(A):refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.4f(I=%d,K=%d,J=%d,R=%d),logPV=%0.4f:orientation=%d,scaleid=%d(%0.4f),trueflip=%d,trueoffset=%0.3f,delta=%0.3f,aligned sites=%d, Lend=%d,Rend=%d,Cscore=%0.4e,fpcnt=%d(%d):%s\n",
		 refid,rmap->id,mapid,nanomap->id,orientation,bestscore2,bestI2,bestK2,bestJ2,bestR2,align2->logPV,orientation, scaleID, scaleID ? ScaleFactor[scaleID] : 1.0,
		 nanomap->flipped,trueoffset,delta,align2->numpairs,align2->Lend,align2->Rend,C, M - align2->numpairs, nanomap->fpcnt,pmap->name ? pmap->name : "");
	  int I= -1,J= -1 ,K=0, G= -1,H= -1, D = 0;
	  if(DEBUG) assert(U== align2->numpairs);
	  for(int T=0; T < U; T++, G=I, H=J, D=K){
	    I = Ilist[U-1-T];
	    K = Klist[U-1-T];
	    J = Jlist[U-1-T];
	    printf("T=%2d:I=%2d,K=%2d,J=%2d:",T,I,K,J);
	    if(T<=0){ /* Left End: display Send(min(X[J],Y[I-K..I]),J+1-max(1,Lijx),I+1-max(1,Lij))+Sm(J,I,K), A[I,K,J].score */
	      if(DEBUG && align2->Lend > -2) assert(J <= DELTA_X || (extend && I-K <= DELTA_Y));
	      int Lij = (align2->Lend <= -2) ? I-K : A->Lij(I,K,J);
	      if(DEBUG && align2->Lend > -2 && extend) assert(I-K <= DELTA_Y || J <= DELTA_X);
	      int Lijx = (align2->Lend <= -2) ? J : extend ? A->Lijx(I,K,J) : 0;

	      if(align2->Lend <= -2 && (NEW==1 || align2->Lend == -2))
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I,K]=%6.3f,C=%0.6f(%d),Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),C,localtype,Sm(J,I,K,Y),C+Sm(J,I,K,Y),A->score(I,K,J));
	      else if(align2->Lend <= -3)
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I,K]=%6.3f,EndPen=%0.6f,BiasEnd=%0.6f,Sm(J,I,K)=%0.6f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),ChimScore,BiasEnd(X[J],J),Sm(J,I,K,Y),BiasEnd(X[J],J)+ChimScore+Sm(J,I,K,Y),A->score(I,K,J));
	      else if(ENDFIX && X[J] <= Yc(Y,I,K) && Lij > 0 && Yc(Y,I,K) - Y[Lij-1] < X[J]){
		RFLOAT score = Sbnd(X[J],Yc(Y,I,K)-Y[Lij-1],J,I-K+1-Lij,I-K,refid);
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I]=%6.3f,Sbnd(X[J],Y[I,K]-Y[Lij-1],J,I-K+1-Lij)=%0.6f,Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),score,Sm(J,I,K,Y), max(C,score+(RFLOAT)Sm(J,I,K,Y)), A->score(I,K,J));
		if(DEBUG) assert(Lijx <= 0);
	      } else if(ENDFIX && extend && X[J] >= Yc(Y,I,K) && Lijx > 0 && X[J]-X[Lijx-1] < Yc(Y,I,K)){
		RFLOAT score = Sbnd(X[J]-X[Lijx-1],Yc(Y,I,K),J+1-Lijx,I-K,I-K,refid);
		printf("Lijy=%d,Lijx=%d,X[J]=%0.6f,Y[I,K]=%6.3f,Sbnd(%0.3f,%0.3f,%d,%d)=%0.6f,Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Y[I],X[J]-X[Lijx-1],Yc(Y,I,K),J+1-Lijx,I-K, score,Sm(J,I,K,Y), max(C,score+(RFLOAT)Sm(J,I,K,Y)), A->score(I,K,J));
		if(DEBUG) assert(Lij <= 0);
	      } else {
		RFLOAT score = Send(min(X[J],Yc(Y,I,K)),J+1-max(1,Lijx) ,I-K+1 - max(1,Lij), I-K, refid,0);
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I,K]=%6.3f,Send(min(X[J],Y[I,K]),J+1-max(1,Lijx),I-K+1-max(1,Lij))=%0.6f,Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),score,Sm(J,I,K,Y), max(C,(extend || Lij > 0) ? score+(RFLOAT)Sm(J,I,K,Y) : (RFLOAT)MINSCORE), A->score(I,K,J));
	      }
	    } else {/* internal interval : display Sint(X[J]-X[H],Y[I,K]-Y[G,D],J-H,I-K-G) + Sm(J,I,K), A[I,K,J].score */
	      if(DEBUG) assert(G>=0 && H>=0 && D>=0);
	      RFLOAT x = X[J]-X[H];
	      RFLOAT y = Yc(Y,I,K)-Yc(Y,G,D);
	      RFLOAT Pen,Gauss,Bias,PenSm, sint;
	      SintDetail(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	      RFLOAT OutPen = OutlierPenalty;
	      if(maptype){
		if(outlierBC)
		  OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
		if(OUTLIER_LTYPE==0)
		  OutPen -= (x+y) * OutlierLambdaInv;
		else
		  OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
		sint = (OUTLIER_TYPE1 == 0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
		  OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;// Sint(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y);
#else // NEW
		sint = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE1 + OutPen) + PenSm;// Sint(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y);
#endif
	      } else if(OUTLIER_DELTA(x-y)){
		if(outlierBC)
		  OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
		OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
		sint = (OUTLIER_TYPE == 0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
		  OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;// Sint(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y);
#else // NEW
		sint = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE + OutPen) + PenSm; // Sint(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y);
#endif
	      } else 
		sint = Bias + Pen + Gauss + PenSm;
	      if(align2->orientation)
		printf("G=%2d,H=%2d,D=%2d,X[J]=%0.3f,Y[I,K]=%0.3f,X[J]-X[H]=%0.4f,Y[I,K]-Y[G,D]=%0.4f,norm=%0.4f,Sint(X,Y,%d,%d)=%0.6f(Pen=%0.6f,Gerr=%0.6f,Bias=%0.6f,Sm=%0.6f,Out=%0.6e),A[I,K,J]=%0.6f,(X[M+1]-X[J])/C=%0.3f\n",
		       G,H,D,X[J],Yc(Y,I,K),x,y,(x-y)*(x-y)/(SF[0]*SF[0]+fabs(SD[0])*SD[0]*y+SR[0]*SR[0]*y*y),J-H,I-K-G,sint,Pen,Gauss,Bias,PenSm,Bias*biasWToutlierF+OutPen,A->score(I,K,J), (X[M+1]-X[J])*origPixelLen/PixelLen);
	      else
		printf("G=%2d,H=%2d,D=%2d,X[J]=%0.3f,Y[I,K]=%0.3f,X[J]-X[H]=%0.4f,Y[I,K]-Y[G,D]=%0.4f,norm=%0.4f,Sint(X,Y,%d,%d)=%0.6f(Pen=%0.6f,Gerr=%0.6f,Bias=%0.6f,Sm=%0.6f,Out=%0.6e),A[I,K,J]=%0.6f,X[J]/C=%0.3f\n",
		       G,H,D,X[J],Yc(Y,I,K),x,y,(x-y)*(x-y)/(SF[0]*SF[0]+fabs(SD[0])*SD[0]*y+SR[0]*SR[0]*y*y),J-H,I-K-G,sint,Pen,Gauss,Bias,PenSm,Bias*biasWToutlierF+OutPen,A->score(I,K,J),X[J]*origPixelLen/PixelLen);
	      //	  printf("G=%2d,H=%2d,D=%2d,X[J]=%0.3f,Y[I,K]=%0.3f,X[J]-X[H]=%0.3f,Y[I]-Y[G]=%0.3f,norm=%0.4f,Sint(X,Y,%d,%d)=%0.6f,A[I,K,J]=%0.6f\n",
	      //		 G,H,D,X[J],Yc(Y,I,K),x,y,(x-y)*(x-y)/(SF[0]*SF[0]+fabs(SD[0])*SD[0]*y+SR[0]*SR[0]*y*y),J-H,I-K-G,sint,A->score(I,K,J));
	    }
	  }
	  if(DEBUG && align2->Rend > -2) assert(J >= ((extend && I >= N+1-DELTA_Y) ? 1 : max(1,M+1-DELTA_X)));
	  int Rij = (align2->Rend <= -2) ? I : A->Rij(I,K,J);
	  if(DEBUG && extend && align2->Rend > -2) assert(I>=N+1-DELTA_Y || J >= M+1-DELTA_X);
	  int Rijx = (align2->Rend <= -2) ? J : extend ? A->Rijx(I,K,J) : M+1;

	  /* Right End: display Rij,Send(X[M+1]-X[J],min(M,Rijx)+1-J,min(N,Rij)+1-I) */
	  if(align2->Rend <= -2 && (NEW==1 || align2->Rend == -2))
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rijk=%d,Rijkx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,C=%0.6f(%d),total score=%0.6f, X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), C, localtype, A->score(I,K,J) + C, X[M+1]*origPixelLen/PixelLen);
	  else if(align2->Rend <= -3)
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rijk=%d,Rijkx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,EndPen=%0.6f,BiasEnd=%0.6f,total score=%0.6f, X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), ChimScore, BiasEnd(X[M+1]-X[J],M+1-J), A->score(I,K,J) + ChimScore+BiasEnd(X[M+1]-X[J],M+1-J), X[M+1]*origPixelLen/PixelLen);
	  else if(ENDFIX && X[M+1]-X[J] <= Y[N+1]-Yc(Y,I,K) && Rij <= N && Y[Rij+1]-Yc(Y,I,K) < X[M+1]-X[J]){
	    RFLOAT score = Sbnd(X[M+1]-X[J],Y[Rij+1]-Yc(Y,I,K),min(M,Rijx)+1-J,min(N,Rij)+1-I,min(N,Rij),refid);
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rij=%d,Rijx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Yc(Y,I,K)=%0.3f,Sbnd(X[M+1]-X[J],Y[Rij+1]-Yc(Y,I,K),M+1-J,Rij+1-I)=%0.6f,total score=%0.6f,X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), score, A->score(I,K,J) + max(C, score), X[M+1]*origPixelLen/PixelLen);
	  } else if(ENDFIX && X[M+1]-X[J] >= Y[N+1]-Yc(Y,I,K) && Rijx <= M && X[A->Rijx(I,K,J)+1]-X[J] < Y[N+1]-Yc(Y,I,K)){
	    RFLOAT score = Sbnd(X[Rijx+1]-X[J],Y[N+1]-Yc(Y,I,K),min(M,Rijx)+1-J,min(N,Rij)+1-I,min(N,Rij),refid);
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rij=%d,Rijx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,Sbnd(X[M+1]-X[J],Y[Rij+1]-Y[I,K],M+1-J,Rij+1-I)=%0.6f,total score=%0.6f,X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), score,  A->score(I,K,J) + max(C, score), X[M+1]*origPixelLen/PixelLen);
	  } else {
	    RFLOAT score = Send(min(X[M+1]-X[J],Y[N+1]-Yc(Y,I,K)),min(M,Rijx)+1-J,min(N,Rij)+1-I,min(N,Rij),refid,0);
	    //	printf("min(X[M+1]-X[J],Y[N+1]-Yc(Y,I,K))=%0.3f,min(M,Rijx)+1-J=%d,min(N,Rij)+1-I=%d\n",min(X[M+1]-X[J],Y[N+1]-Yc(Y,I,K)),min(M,Rijx)+1-J,min(N,Rij)+1-I);
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rij=%d,Rijx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,Send(min(X[M+1]-X[J],Y[N+1]-Y[I,K]),min(M,Rijx)+1-J,min(N,Rij)+1-I)=%0.6f,total score=%0.6f,X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), score, A->score(I,K,J) + max(C, (!extend && Rij > N) ? (RFLOAT)MINSCORE : score), X[M+1]*origPixelLen/PixelLen);
	  }
	  fflush(stdout);
	  if(DEBUG) assert(Rij >= I && Rij <= N+1);
	  /*      if(DEBUG>=2)
		  exit(1);*/
	} // pragma omp critical 
      } // if(VERB...)
    } // backtrack to retrieve 2nd best alignment
  }

  if(SecondBest && bestscore > ScoreThreshold2 && (!align->align2 || bestscore > align->align2->score + 1e-8)){/* check if current best alignment should be saved as overall 2nd best alignment */
    int alignK = align->numpairs;
    FLOAT alignYik = (alignK <= 0) ? -1e30 : Yc(Y,align->sites1[alignK-1],align->sitesK1[alignK-1]);
    if(align->orientation != orientation || fabs(alignYik - bestYik) >= MinSpacing){  /* backtrack through array to retrieve best alignment as overall 2nd best alignment */
      if(PVERB>=2 && align->align2){
        #pragma omp critical
	{
	  Calign *align2 = align->align2;
	  printf("Replacing previous 2nd best alignment with bestscore= %0.4f,orientation=%d:refid=%d,mapid=%d(id=%lld),orientation=%d:score=%0.4f,logPV=%0.2f,numpairs=%d\n",
		 bestscore, orientation, align2->mapid1,align2->mapid2,Gmap[align2->mapid2]->id,align2->orientation,align2->score,align2->logPV,align2->numpairs);
	  fflush(stdout);
	}
      }
      if(DEBUG) assert(bestscore <= align->score + 1e-8);

      if(DEBUG) assert(bestI >= 0);
      if(DEBUG) assert(Ilist != 0);

      int I = bestI;
      int K = bestK;
      int J = bestJ;

      int U = 0;

      /* right end segment */
      outscore[0] = iscore[0] = bestscore - A->score(I,K,J);

      while(I > 0){
	if(DEBUG>=2){
	  assert(I-K >= 1 && IMIN <= I && I <= IMAX);
	  assert(J >= JMIN[I] && J <= JMAX[I]);
	}
	Ilist[U] = I;
	Klist[U] = K;
	Jlist[U] = J;
	int G = A->G(I,K,J);
	RFLOAT score = A->score(I,K,J);
	if(G > 0){
	  int T = A->T(I,K,J);
	  int H = A->H(I,K,J);
	  if(DEBUG>=2) assert(H > 0 && T >= 0);
	  iscore[U+1] = score - A->score(G,T,H);
	  RFLOAT x = X[J]-X[H];
	  RFLOAT y = Yc(Y,I,K) - Yc(Y,G,T);
	  if(maptype){
	    RFLOAT Bias,Pen,Gauss,PenSm;
	    SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	    outscore[U+1] = Bias + Pen + Gauss + PenSm;
	    if(DEBUG>=2){
	      RFLOAT OutPen = OutlierPenalty;
	      if(outlierBC)
		OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
	      if(OUTLIER_LTYPE==0)
		OutPen -= (x+y) * OutlierLambdaInv;
	      else
		OutPen -= fabs(x-y) * OutlierLambdaInv;
	
#if 0 // OLD
	      RFLOAT iscore2 = (OUTLIER_TYPE1 == 0 ) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
		OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
#else // NEW
	      RFLOAT iscore2 = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE1 + OutPen) + PenSm;
#endif

	      if(!(fabs(iscore2-iscore[U+1])  < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN)){
                #pragma omp critical
		{
		  printf("mapid=%d(id=%lld):I=%d,J=%d,K=%d:G=%d,T=%d,H=%d:U=%d,x=%0.3f,y=%0.3f,Bias=%0.9f,OutBias=%0.9f,Pen=%0.9f,OutlierPenalty=%0.9f,outscore[U+1]=%0.9f:iscore2=%0.9f,iscore[U+1]=%0.9f(err=%0.9f):score=%0.9f,score(G,T,H)=%0.9f\n",
			 mapid,nanomap->id,I,J,K,G,T,H,U,x,y,Bias,OutlierBias,Pen,OutlierPenalty,outscore[U+1],iscore2,iscore[U+1],fabs(iscore2-iscore[U+1]), score, A->score(G,T,H));
		  fflush(stdout);
		  
		  /* NOTE : large -ve scores and hence rounding errors can occur with -maptype 0, since that disables -outlier for |x-y| > maxOutlier */
		  assert(fabs(iscore2-iscore[U+1]) < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN);
		  assert(0);
		}
	      }
	    }
	  } else if(OUTLIER_DELTA(x-y)){
	    RFLOAT Bias,Pen,Gauss,PenSm;
	    SintDetail(x,y, J-H,I-K-G,J,I,K,T,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	    outscore[U+1] = Bias + Pen + Gauss + PenSm;
	    if(DEBUG>=2){
	      RFLOAT OutPen = OutlierPenalty;
	      if(outlierBC)
		OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
	      OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
	      RFLOAT iscore2 = (OUTLIER_TYPE==0 ) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
		OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
#else // NEW
	      RFLOAT iscore2 = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE + OutPen) + PenSm;
#endif
	      if(!(fabs(iscore2-iscore[U+1])  < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN)){
                #pragma omp critical
		{
		  printf("mapid=%d(id=%lld):I=%d,J=%d,K=%d:G=%d,T=%d,H=%d:U=%d,x=%0.3f,y=%0.3f,Bias=%0.9f,OutBias=%0.9f,Pen=%0.9f,Gauss=%0.9f,OutlierPenalty=%0.9f,outscore[U+1]=%0.9f:iscore2=%0.9f,iscore[U+1]=%0.9f(err=%0.9f):score=%0.9f,score(G,T,H)=%0.9f\n",
			 mapid,nanomap->id,I,J,K,G,T,H,U,x,y,Bias,OutlierBias,Pen,Gauss,OutlierPenalty,outscore[U+1],iscore2,iscore[U+1],fabs(iscore2-iscore[U+1]), score, A->score(G,T,H));
		  fflush(stdout);
		  
		  /* NOTE : large -ve scores and hence rounding errors can occur with -maptype 0, since that disables -outlier for |x-y| > maxOutlier */
		  assert(fabs(iscore2-iscore[U+1]) < SCORE_MARGIN * max(fabs(iscore2),fabs(score)) + ASCORE_MARGIN);
		  assert(0);
		}
	      }
	    }
	  } else {/* no possible outlier */
	    outscore[U+1] = iscore[U+1];
	  }

	  K = T;
	  J = H;
	} else {/* left end segment */
	  outscore[U+1] = iscore[U+1] = score;
	}
	U++;
	I = G;
      }

      if(DEBUG) assert(U > 0);
      if(DEBUG) assert(I <= (isLinear ? -1 : 0));

      delete [] align->align2; align->align2 = NULL;
      Calign *align2 = align->align2 = new Calign[1];
      align2->mapid1 = refid;
      align2->mapid2 = mapid;

      align2->score = bestscore;
      align2->orientation = orientation;
      align2->scaleID = scaleID;
      int numpairs,Lend;
      align2->Nrange = IMAX-IMIN+1;
      align2->Mrange = jmax-jmin+1;
      if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(align2->Mrange == M);
      align2->logPV = alignFPsd(A,bestI,bestJ,bestK,Y,X,N,M,align2->Nrange,align2->Mrange,bestR,orientation,rev,scaleID,refid,mapid,0,0, numpairs,Lend,-1,0,0);
      align2->Lend = I;
      align2->Rend = bestR;

      I = Ilist[U-1];
      K = Klist[U-1];
      J = Jlist[U-1];

      if(DEBUG>=2) assert(align2->Lend <= -2 || J <= DELTA_X || (extend && I-K <= DELTA_Y));
      align2->Lij1 = (align2->Lend <= -2) ? I-K : A->Lij(I,K,J);
      if(DEBUG>=2) assert(align2->Lij1 <= I-K && align2->Lij1 >= 0);
      align2->Lij2 = (align2->Lend <= -2) ? J : extend ? A->Lijx(I,K,J) : 0;
      if(DEBUG>=2) assert(align2->Lij2 <= J && align2->Lij2 >= 0);
      if(DEBUG>=2) assert(align2->Rend <= -2 || bestJ >= M+1 - DELTA_X || (extend && bestI >= N+1-DELTA_Y));
      align2->Rij1 = (align2->Rend <= -2) ? bestI : A->Rij(bestI,bestK,bestJ);
      if(DEBUG>=2) assert(align2->Rij1 >= bestI && align2->Rij1 <= N+1);
      align2->Rij2 = (align2->Rend <= -2) ? bestJ : extend ? A->Rijx(bestI,bestK,bestJ) : M+1;
      if(DEBUG>=2) assert(align2->Rij2 >= bestJ && align2->Rij2 <= M+1);
      
#if CALIGN_END==0
      align2->LijY = A->Lij(I,K,J);
      align2->LijX = extend ? A->Lijx(I,K,J) : 0;
      align2->RijY = A->Rij(bestI,bestK,bestJ);
      align2->RijX = extend ? A->Rijx(bestI,bestK,bestJ) : M+1;
#endif

      align2->repeat = -1;
      /* (re)allocate 2nd best alignment */
      align2->allfree();
      if(DEBUG) assert(U > 0);
      align2->expand_arrays(U);
      align2->numpairs = U;

      /* copy alignment from Ilist[],Jlist[] in reverse order */
      for(int I= 0; I < U; I++){
	align2->sites1[I] = Ilist[U-1-I];
	align2->sitesK1[I] = Klist[U-1-I];
	align2->sites2[I] = Jlist[U-1-I];
	align2->iscore[I] = iscore[U-I];
	align2->outscore[I] = outscore[U-I];
      }
      align2->iscore[U] = iscore[0];
      align2->outscore[U] = outscore[0];

      align2->noutliers = 0;
      align2->maxoutlier = 0.0;
      align2->maxoutlierLabels = 0;
      int lastI = align2->sites1[0];
      int lastK = align2->sitesK1[0];
      int lastJ = align2->sites2[0];
      for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
	I = align2->sites1[t];
	K = align2->sitesK1[t];
	J = align2->sites2[t];
	if(align2->outscore[t] + (RFLOAT)0.01 < align2->iscore[t]){
	  align2->noutliers++;
	  double deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	  double deltaX = X[J] - X[lastJ];
	  if(DEBUG) assert(deltaX > 0.0);
	  double delta = fabs(deltaY-deltaX);
	  align2->maxoutlier = max(delta,align2->maxoutlier);
	  align2->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, align2->maxoutlierLabels);// NEW302
	}
      }
      if(DEBUG/* HERE HERE >=2 */) assert(align2->noutliers >= 0 && align2->maxoutlier >= 0.0 && align2->maxoutlierLabels >= 0 &&
					  (align2->noutliers <= 0 || align2->maxoutlier > 0.0 || align2->maxoutlierLabels > 0));

      if(VERB >= 2-PVERB && bestscore > MINSCORE && (VERB>=2 ||  giter==RefRepeats-1 /*||  (mapid==1254 && align->orientation) */ /* || fabs(offset-trueoffset) > 2*Ylambda || align->orientation*/)){
        #pragma omp critical 
	{ 
	  RFLOAT C = ChimScore;
	  FLOAT offset = bestYik - X[bestJ];
	  FLOAT trueoffset = nanomap->endloc - X[M+1];
	  FLOAT delta = offset-trueoffset;
	  Cmap *pmap = nanomap;
	  while(pmap->origmap)
	    pmap = pmap->origmap;

	  int numpairs,Lend;
	  if(DEBUG && !(CutFlip || ShiftOffset1 <= 30)) assert(jmax-jmin+1 == M);
	  (void)alignFPsd(A,bestI,bestJ,bestK,Y,X,N,M,IMAX-IMIN+1,jmax-jmin+1,bestR,orientation,rev,scaleID,refid,mapid,0,1,numpairs,Lend,-1,0,0);
	  printf("2nd Best(B):refid=%d,mapid=%d(id=%lld),score=%0.4f(I=%d,K=%d,J=%d,R=%d),logPV=%0.4f:orientation=%d,scaleID=%d(%0.4f),trueflip=%d,trueoffset=%0.3f,delta=%0.3f,aligned sites=%d, Lend=%d,Rend=%d,Cscore=%0.4e,fpcnt=%d(%d):%s\n",
		 refid,mapid,nanomap->id,bestscore,bestI,bestK,bestJ,bestR,align2->logPV,orientation, scaleID, scaleID ? ScaleFactor[scaleID] : 1.0,
		 nanomap->flipped,trueoffset,delta,align2->numpairs,align2->Lend,align2->Rend,C, M - align2->numpairs, nanomap->fpcnt,pmap->name ? pmap->name : "");
	  int I= -1,J= -1 ,K=0, G= -1,H= -1, D = 0;
	  if(DEBUG) assert(U== align2->numpairs);
	  for(int T=0; T < U; T++, G=I, H=J, D=K){
	    I = Ilist[U-1-T];
	    K = Klist[U-1-T];
	    J = Jlist[U-1-T];
	    printf("T=%2d:I=%2d,K=%2d,J=%2d:",T,I,K,J);
	    if(T<=0){ /* Left End: display Send(min(X[J],Y[I-K..I]),J+1-max(1,Lijx),I+1-max(1,Lij))+Sm(J,I,K), A[I,K,J].score */
	      if(DEBUG && align2->Lend > -2) assert(J <= DELTA_X || (extend && I-K <= DELTA_Y));
	      int Lij = (align2->Lend <= -2) ? I-K : A->Lij(I,K,J);
	      if(DEBUG && align2->Lend > -2 && extend) assert(I-K <= DELTA_Y || J <= DELTA_X);
	      int Lijx = (align2->Lend <= -2) ? J : extend ? A->Lijx(I,K,J) : 0;

	      if(align2->Lend <= -2 && (NEW==1 || align2->Lend == -2))
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I,K]=%6.3f,C=%0.6f(%d),Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),C,localtype,Sm(J,I,K,Y),C+Sm(J,I,K,Y),A->score(I,K,J));
	      else if(align2->Lend <= -3)
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I,K]=%6.3f,EndPen=%0.6f,BiasEnd=%0.6f,Sm(J,I,K)=%0.6f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),ChimScore,BiasEnd(X[J],J),Sm(J,I,K,Y),BiasEnd(X[J],J)+ChimScore+Sm(J,I,K,Y),A->score(I,K,J));
	      else if(ENDFIX && X[J] <= Yc(Y,I,K) && Lij > 0 && Yc(Y,I,K) - Y[Lij-1] < X[J]){
		RFLOAT score = Sbnd(X[J],Yc(Y,I,K)-Y[Lij-1],J,I-K+1-Lij,I-K,refid);
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I]=%6.3f,Sbnd(X[J],Y[I,K]-Y[Lij-1],J,I-K+1-Lij)=%0.6f,Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),score,Sm(J,I,K,Y), max(C,score+(RFLOAT)Sm(J,I,K,Y)), A->score(I,K,J));
		if(DEBUG) assert(Lijx <= 0);
	      } else if(ENDFIX && extend && X[J] >= Yc(Y,I,K) && Lijx > 0 && X[J]-X[Lijx-1] < Yc(Y,I,K)){
		RFLOAT score = Sbnd(X[J]-X[Lijx-1],Yc(Y,I,K),J+1-Lijx,I-K,I-K,refid);
		printf("Lijy=%d,Lijx=%d,X[J]=%0.6f,Y[I,K]=%6.3f,Sbnd(%0.3f,%0.3f,%d,%d)=%0.6f,Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Y[I],X[J]-X[Lijx-1],Yc(Y,I,K),J+1-Lijx,I-K, score,Sm(J,I,K,Y), max(C,score+(RFLOAT)Sm(J,I,K,Y)), A->score(I,K,J));
		if(DEBUG) assert(Lij <= 0);
	      } else {
		RFLOAT score = Send(min(X[J],Yc(Y,I,K)),J+1-max(1,Lijx) ,I-K+1 - max(1,Lij), I-K, refid,0);
		printf("Lij=%d,Lijx=%d,X[J]=%6.3f,Y[I,K]=%6.3f,Send(min(X[J],Y[I,K]),J+1-max(1,Lijx),I-K+1-max(1,Lij))=%0.6f,Sm(J,I,K)=%0.4f,score=%0.6f,A[I,K,J]=%0.6f\n",
		       Lij,Lijx,X[J],Yc(Y,I,K),score,Sm(J,I,K,Y), max(C,(extend || Lij > 0) ? score+(RFLOAT)Sm(J,I,K,Y) : (RFLOAT)MINSCORE), A->score(I,K,J));
	      }
	    } else {/* internal interval : display Sint(X[J]-X[H],Y[I,K]-Y[G,D],J-H,I-K-G) + Sm(J,I,K), A[I,K,J].score */
	      if(DEBUG) assert(G>=0 && H>=0 && D>=0);
	      RFLOAT x = X[J]-X[H];
	      RFLOAT y = Yc(Y,I,K)-Yc(Y,G,D);
	      RFLOAT Pen,Gauss,Bias,PenSm, sint;
	      SintDetail(x,y,J-H,I-K-G,J,I,K,D,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
	      RFLOAT OutPen = OutlierPenalty;
	      if(maptype){
		if(outlierBC)
		  OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
		if(OUTLIER_LTYPE==0)
		  OutPen -= (x+y) * OutlierLambdaInv;
		else
		  OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
		sint = (OUTLIER_TYPE1 == 0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
		  OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm; // Sint(x,y,J-H,I-K-G,J,I,K,PRtabY,Y);
#else
		sint = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE1 + OutPen) + PenSm; // Sint(x,y,J-H,I-K-G,J,I,K,PRtabY,Y);
#endif
	      } else if(OUTLIER_DELTA(x-y)){
		if(outlierBC)
		  OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
		OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
		sint = (OUTLIER_TYPE == 0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
		  OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm; // Sint(x,y,J-H,I-K-G,J,I,K,PRtabY,Y);
#else // NEW
		sint = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE + OutPen) + PenSm; // Sint(x,y,J-H,I-K-G,J,I,K,PRtabY,Y);
#endif
	      } else
		sint = Bias + Pen + Gauss + PenSm;
	      if(align2->orientation)
		printf("G=%2d,H=%2d,D=%2d,X[J]=%0.3f,Y[I,K]=%0.3f,X[J]-X[H]=%0.4f,Y[I,K]-Y[G,D]=%0.4f,norm=%0.4f,Sint(X,Y,%d,%d)=%0.6f(Pen=%0.6f,Gerr=%0.6f,Bias=%0.6f,Sm=%0.6f,Out=%0.6e),A[I,K,J]=%0.6f,(X[M+1]-X[J])/C=%0.3f(A)\n",
		       G,H,D,X[J],Yc(Y,I,K),x,y,(x-y)*(x-y)/(SF[0]*SF[0]+fabs(SD[0])*SD[0]*y+SR[0]*SR[0]*y*y),J-H,I-K-G,sint,Pen,Gauss,Bias,PenSm,Bias*biasWToutlierF+OutPen,A->score(I,K,J), (X[M+1]-X[J])*origPixelLen/PixelLen);
	      else
		printf("G=%2d,H=%2d,D=%2d,X[J]=%0.3f,Y[I,K]=%0.3f,X[J]-X[H]=%0.4f,Y[I,K]-Y[G,D]=%0.4f,norm=%0.4f,Sint(X,Y,%d,%d)=%0.6f(Pen=%0.6f,Gerr=%0.6f,Bias=%0.6f,Sm=%0.6f,Out=%0.6e),A[I,K,J]=%0.6f,X[J]/C=%0.3f(A)\n",
		       G,H,D,X[J],Yc(Y,I,K),x,y,(x-y)*(x-y)/(SF[0]*SF[0]+fabs(SD[0])*SD[0]*y+SR[0]*SR[0]*y*y),J-H,I-K-G,sint,Pen,Gauss,Bias,PenSm,Bias*biasWToutlierF+OutPen,A->score(I,K,J),X[J]*origPixelLen/PixelLen);
	      //	  printf("G=%2d,H=%2d,D=%2d,X[J]=%0.3f,Y[I,K]=%0.3f,X[J]-X[H]=%0.3f,Y[I]-Y[G]=%0.3f,norm=%0.4f,Sint(X,Y,%d,%d)=%0.6f,A[I,K,J]=%0.6f\n",
	      //		 G,H,D,X[J],Yc(Y,I,K),x,y,(x-y)*(x-y)/(SF[0]*SF[0]*fabs(SD[0])*SD[0]*y+SR[0]*SR[0]*y*y),J-H,I-K-G,sint,A->score(I,K,J));
	    }
	  }
	  if(DEBUG && align2->Rend > -2) assert(J >= ((extend && I >= N+1-DELTA_Y) ? 1 : max(1,M+1-DELTA_X)));
	  int Rij = (align2->Rend <= -2) ? I : A->Rij(I,K,J);
	  if(DEBUG && extend && align2->Rend > -2) assert(I>=N+1-DELTA_Y || J >= M+1-DELTA_X);
	  int Rijx = (align2->Rend <= -2) ? J : extend ? A->Rijx(I,K,J) : M+1;
	  /* Right End: display Rij,Send(X[M+1]-X[J],min(M,Rijx)+1-J,min(N,Rij)+1-I) */
	  if(align2->Rend <= -2 && (NEW==1 || align2->Rend == -2))
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rijk=%d,Rijkx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,C=%0.6f(%d),total score=%0.6f, X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), C, localtype, A->score(I,K,J) + C, X[M+1]*origPixelLen/PixelLen);
	  else if(align2->Rend <= -3)
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rijk=%d,Rijkx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,EndPen=%0.6f,BiasEnd=%0.6f,total score=%0.6f, X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), ChimScore, BiasEnd(X[M+1]-X[J],M+1-J), A->score(I,K,J) + ChimScore+BiasEnd(X[M+1]-X[J],M+1-J), X[M+1]*origPixelLen/PixelLen);
	  else if(ENDFIX && X[M+1]-X[J] <= Y[N+1]-Yc(Y,I,K) && Rij <= N && Y[Rij+1]-Yc(Y,I,K) < X[M+1]-X[J]){
	    RFLOAT score = Sbnd(X[M+1]-X[J],Y[Rij+1]-Yc(Y,I,K),min(M,Rijx)+1-J,min(N,Rij)+1-I,min(N,Rij),refid);
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rij=%d,Rijx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Yc(Y,I,K)=%0.3f,Sbnd(X[M+1]-X[J],Y[Rij+1]-Yc(Y,I,K),M+1-J,Rij+1-I)=%0.6f,total score=%0.6f,X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), score, A->score(I,K,J) + max(C, score), X[M+1]*origPixelLen/PixelLen);
	  } else if(ENDFIX && X[M+1]-X[J] >= Y[N+1]-Yc(Y,I,K) && Rijx <= M && X[A->Rijx(I,K,J)+1]-X[J] < Y[N+1]-Yc(Y,I,K)){
	    RFLOAT score = Sbnd(X[Rijx+1]-X[J],Y[N+1]-Yc(Y,I,K),min(M,Rijx)+1-J,min(N,Rij)+1-I,min(N,Rij),refid);
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rij=%d,Rijx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,Sbnd(X[M+1]-X[J],Y[Rij+1]-Y[I,K],M+1-J,Rij+1-I)=%0.6f,total score=%0.6f,X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), score,  A->score(I,K,J) + max(C, score), X[M+1]*origPixelLen/PixelLen);
	  } else {
	    RFLOAT score = Send(min(X[M+1]-X[J],Y[N+1]-Yc(Y,I,K)),min(M,Rijx)+1-J,min(N,Rij)+1-I, min(N,Rij), refid, 0);
	    //	printf("min(X[M+1]-X[J],Y[N+1]-Yc(Y,I,K))=%0.3f,min(M,Rijx)+1-J=%d,min(N,Rij)+1-I=%d\n",min(X[M+1]-X[J],Y[N+1]-Yc(Y,I,K)),min(M,Rijx)+1-J,min(N,Rij)+1-I);
	    printf("I=%d,K=%d,J=%d,N=%d,M=%d:Rij=%d,Rijx=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,X[M+1]-X[J]=%0.3f,Y[N+1]-Y[I,K]=%0.3f,Send(min(X[M+1]-X[J],Y[N+1]-Y[I,K]),min(M,Rijx)+1-J,min(N,Rij)+1-I)=%0.6f,total score=%0.6f,X[M+1]/C=%0.3f\n",
		   I,K,J,N,M,Rij,Rijx,X[M+1],Y[N+1],X[M+1]-X[J],Y[N+1]-Yc(Y,I,K), score, A->score(I,K,J) + max(C, (!extend && Rij > N) ? (RFLOAT)MINSCORE : score), X[M+1]*origPixelLen/PixelLen);
	  }
	  fflush(stdout);
	  if(DEBUG) assert(Rij >= I && Rij <= N+1);
	  /*      if(DEBUG>=2)
		  exit(1);*/
	} // pragma omp critical 
      }
    } // if(VERB...)
  }

  if(DEBUG>=2){/* check that unused array elements are still NaN */
    if(DIAGONAL == 1){
      for(int I = 1; I <= N; I++){
	for(int J = 1; J <= M; J++){
	  if(IMIN <= I && I <= IMAX && JMIN[I] <= J && J <= JMAX[I])
	    continue;
	  for(int K = 0; K <= Kmax[I]; K++){
	    assert(IsNan(A->score(I,K,J)));
	    assert(IsNan(A->Uscore(I,K,J)));
	    assert(A->Rijx(I,K,J)== ival);
	    assert(A->Lijx(I,K,J)== ival);
	    assert(A->Rij(I,K,J)== ival);
	    assert(A->Lij(I,K,J)== ival);
	    assert(A->H(I,K,J)== ival);
	    assert(A->T(I,K,J)== ival);
	    assert(A->G(I,K,J)== ival);
	  }
	}
      }
    }
    if(DIAGONAL >= 2 && !MIN_MEM){
      for(int I = IMIN; I <= IMAX; I++){
        int jmin = (A->Istride < M+2*FENCE) ? Jmin1+(I-IMIN) : Jmin1;
        int jmax = (A->Istride < M+2*FENCE) ? Jmax1+(I-IMIN) : Jmax1;
	for(int J = jmin; J <= jmax; J++){
	  if(JMIN[I] <= J && J <= JMAX[I])
	    continue;
	  for(int K = 0; K <= Kmax[I]; K++){
	    if(!(IsNan(A->score(I,K,J)))){
	      #pragma omp critical
	      {
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d:IMIN=%d,IMAX=%d,N=%d,M=%d:Istride=%lld(FENCE=%d),Kstride=%lld,kmax=%d,Jmin1=%d,Jmax1=%d:I=%d,K=%d,J=%d,JMIN[I]=%d,JMAX[I]=%d:A->score(I,K,J)=%e (&score_base[%llu])\n",
		       refid,rmap->id,mapid,nanomap->id,orientation,IMIN,IMAX,N,M,A->Istride,FENCE,A->Kstride,A->kmax,Jmin1,Jmax1,I,K,J,JMIN[I],JMAX[I],A->score(I,K,J), (unsigned long long)(&A->score(I,K,J) - A->score_base));
		fflush(stdout);

		assert(IsNan(A->score(I,K,J)));
	      }
	    }
	    assert(IsNan(A->Uscore(I,K,J)));
	    assert(A->Rijx(I,K,J)== ival);
	    assert(A->Lijx(I,K,J)== ival);
	    assert(A->Rij(I,K,J)== ival);
	    assert(A->Lij(I,K,J)== ival);
	    assert(A->H(I,K,J)== ival);
	    assert(A->T(I,K,J)== ival);
	    assert(A->G(I,K,J)== ival);
	  }
	}
      }
    }
  }
  if(M > MAX_ALLOCA){
    delete [] biasend_values;
    delete [] Ilist;
    delete [] iscore;
  }
}

/* update primary alignment align from r */
static void updateAlignment(Calign *align, Calign *r, Cmap *rmap, Cmap *nanomap, int orientation)
{
  double *Y = rmap->site[0];

  if(AlignedThreshold(align, Y) && !AlignedThreshold(r,Y))
    return;// avoid overwriting above threshold alignment align[0] just because the r->score is better 

  int U = r->numpairs;
  if(PVERB){
    int T = align->numpairs;
    if(!T)
      printf("refid=%d(%lld),mapid=%d(%lld),or=%d:Replacing primary alignment (pairs=%d,score=%0.6f) with merged alignment:or=%d,pairs=%d,score=%0.6f,logPV=%0.2f(logPV2=%0.2f),Len=%0.1f\n",
	     align->mapid1,refmap[align->mapid1]->id,align->mapid2,Gmap[align->mapid2]->id,align->orientation,T,align->score,r->orientation,U,r->score,r->logPV,r->logPV2,AlignedLength(r,Y));
    else
      printf("refid=%d(%lld),mapid=%d(%lld),or=%d:Replacing primary alignment (I=%d..%d,K=%d..%d,J=%d..%d,pairs=%d,score=%0.6f,logPV=%0.2f,Len=%0.1f) with merged alignment:or=%d,pairs=%d,score=%0.6f,logPV=%0.2f,Len=%0.1f\n",
	     align->mapid1,refmap[align->mapid1]->id,align->mapid2,Gmap[align->mapid2]->id,align->orientation,align->sites1[0],align->sites1[T-1],align->sitesK1[0],align->sitesK1[T-1],
	     align->sites2[0],align->sites2[T-1],T,align->score,align->logPV,AlignedLength(align,Y),r->orientation,U,r->score,r->logPV,AlignedLength(r,Y));
    fflush(stdout);
  }
  align->orientation = r->orientation;
  align->rev = r->rev;
  align->scaleID = r->scaleID;
  align->numpairs = U;
  align->expand_arrays(U);
  align->repeat = align->repeat;
  for(int t = 0; t < U; t++){
    align->sites1[t] = r->sites1[t];
    align->sitesK1[t] = r->sitesK1[t];
    align->sites2[t] = r->sites2[t];
    align->iscore[t] = r->iscore[t];
    align->outscore[t] = r->outscore[t];
  }
  align->iscore[U] = r->iscore[U];
  align->outscore[U] = r->outscore[U];

  align->noutliers = r->noutliers;
  align->maxoutlier = r->maxoutlier;
  align->maxoutlierLabels = r->maxoutlierLabels;

  align->Lend = r->Lend;
  align->Rend = r->Rend;
  align->Lij1 = r->Lij1;
  align->Lij2 = r->Lij2;
  align->Rij1 = r->Rij1;
  align->Rij2 = r->Rij2;
#if CALIGN_END==0
  align->LijY = r->LijY;
  align->LijX = r->LijX;
  align->RijY = r->RijY;
  align->RijX = r->RijX;
#endif
		  
  align->score = r->score;
  if(DEBUG) assert(r->logPV2 >= r->logPV);
  align->logPV = r->logPV;
  align->logPV2 = r->logPV2;
  

  if(DEBUG>=2 && align->Malign){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
    for(int i = 0; i < align->multimax; i++)
      for(int j = i+1; j < align->multimax; j++)
	if(align->Malign[j] && align->Malign[i] == align->Malign[j]){
	  printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	  fflush(stdout);
	  assert(align->Malign[i] != align->Malign[j]);
	}
  }

}

/* compute rightmost label on Y that overlaps X when rightmost alignment is Y[I] with X[J] */
/* If Xrev == true : The orientation of X[] is backwards */
/* If Xscale != 1.0 : Need to scale X[] by Xscale */
static int RijY(FLOAT *Y, FLOAT *X, int I, int J, int N, int M, bool Xrev = false, double Xscale = 1.0)
{
  int Rij1 = I;

  if(!Xrev){
    FLOAT Ymax = (X[M+1] - X[J]) * Xscale + Y[I];

    /* NOTE : binary search would be faster, but typically the number of overlapped labels is small */
    while(Rij1 <= N){
      if(Y[++Rij1] > Ymax){
	Rij1--;
	break;
      }
    }
  } else {
    FLOAT Ymax = X[M+1-J] * Xscale + Y[I];

    /* NOTE : binary search would be faster, but typically the number of overlapped labels is small */
    while(Rij1 <= N){
      if(Y[++Rij1] > Ymax){
	Rij1--;
	break;
      }
    }
  }

  if(DEBUG) assert(I <= Rij1 && Rij1 <= N+1);

  return Rij1;
}

/* compute rightmost label on X that overlaps Y when rightmost alignment is Y[I] with X[J] */
/* If Xrev == true : The orientation of X[] is backwards */
/* If Xscale != 1.0 : Need to scale X[] by Xscale */
static int RijX(FLOAT *Y, FLOAT *X, int I, int J, int N, int M, bool Xrev = false, double Xscale = 1.0)
{
  int Rij2 = J;

  if(!Xrev){
    FLOAT Xmax = Y[N+1] - Y[I] + X[J] * Xscale;

    /* NOTE : binary search would be faster, but typically the number of overlapped labels is small */
    while(Rij2 <= M){
      if(X[++Rij2] * Xscale > Xmax){
	Rij2--;
	break;
      }
    }
  } else {
    FLOAT Xmin = X[M+1-J] * Xscale - Y[N+1] + Y[I];

    /* NOTE : binary search would be faster, but typically the number of overlapped labels is small */
    while(Rij2 <= M){
      ++Rij2;
      if(X[M+1-Rij2] * Xscale < Xmin){
	Rij2--;
	break;
      }
    }
  }

  if(DEBUG && !(J <= Rij2 && Rij2 <= M+1)){
    printf("RijX:I=%d,J=%d,N=%d,M=%d,Xrev=%d,Xscale=%0.6f:Rij2=%d\n",
	   I,J,N,M,Xrev,Xscale, Rij2);
    fflush(stdout);
    assert(J <= Rij2 && Rij2 <= M+1);
  }

  return Rij2;
}

/* compute left label on Y that overlaps X when leftmost alignment is Y[I] with X[J] */
/* If Xrev == true : The orientation of X[] is backwards */
/* If Xscale != 1.0 : Need to scale X[] by Xscale */
static int LijY(FLOAT *Y, FLOAT *X, int I, int J, int N, int M, bool Xrev = false, double Xscale = 1.0)
{
  int Lij1 = I;

  if(!Xrev){
    FLOAT Ymin = Y[I] - X[J] * Xscale;

    /* NOTE : binary search would be faster, but typically the number of overlapped labels is small */
    while(Lij1 > 0){
      if(Y[--Lij1] < Ymin){
	Lij1++;
	break;
      }
    }
  } else {
    FLOAT Ymin = Y[I] - X[M+1] + X[M+1-J] * Xscale;

    /* NOTE : binary search would be faster, but typically the number of overlapped labels is small */
    while(Lij1 > 0){
      if(Y[--Lij1] < Ymin){
	Lij1++;
	break;
      }
    }
  }

  if(DEBUG) assert(0 <= Lij1 && Lij1 <= I);

  return Lij1;
}

/* compute left label on X that overlaps Y when leftmost alignment is Y[I] with X[J] */
/* If Xrev == true : The orientation of X[] is backwards */
/* If Xscale != 1.0 : Need to scale X[] by Xscale */
static int LijX(FLOAT *Y, FLOAT *X, int I, int J, int N, int M, bool Xrev = false, double Xscale = 1.0)
{
  int Lij2 = J;

  if(!Xrev){
    FLOAT Xmin = X[J] * Xscale - Y[I];

    /* NOTE : binary search would be faster, but typically the number of overlapped labels is small */
    while(Lij2 > 0){
      if(X[--Lij2] * Xscale < Xmin){
	Lij2++;
	break;
      }
    }
  } else {
    FLOAT Xmax = X[M+1-J] * Xscale + Y[I];

    /* NOTE : binary search would be faster, but typically the number of overlapped labels is small */
    while(Lij2 > 0){
      --Lij2;
      if(X[M+1-Lij2] * Xscale > Xmax){
	Lij2++;
	break;
      }
    }
  }

  if(DEBUG) assert(0 <= Lij2 && Lij2 <= J);

  return Lij2;
}

/* Save copy of left end of a matchgroup p == align->Malign[i], (p->sites1[0..t1]) as new matchgroup, provided -A2 -S2 and -T2 threshold are satisfied (or RefSplitStitch>=2 && score >= ChimScore) and 
   insert it into sorted array align->Malign[u .. align->multicnt-1] incrementing align->multicnt.
   
   Trim the right end of the partial matchgroup if that improves the score (but not with RefsplitStitch>=2, unless original score was < ChimScore

   NOTE : there could be a region with very large -ve score in the middle of the partial matchgroup, so checking for -S2 or -T2 should be deferred until the matchgroup has been split by RefSplit. 
 */

static void SaveLeftFragment(Calign *align, int i, int u, int t1, 
			     double pscoreL, // original score of Left Fragment
			     FLOAT *Y, FLOAT *X, int N, int M, Cmap *rmap, Cmap *nanomap)
{
  /* truncate unique left portion of Malign[i] at right end if score can be improved (but not with RefSplitStitch>=2, unless original score was < ChimScore), assumes biaswtEnd == 0.0 */
  double pthreshold = 0.001;
  if(REFSPLIT_FIX && RefSplit)
    pthreshold = log(1.0/(Rsplit ? Rsplit : Psplit));

  Calign *p = align->Malign[i];
  int orientation = p->orientation;

  int T = t1;
  double pscoreLT = pscoreL, sum;
  if(!(RefSplitStitch>=2 && pscoreL > ChimScore)){
    for(;T > 0; T--){
      if((sum = p->iscore[T]) > 0.0){
	if(REFSPLIT_FIX && sum < pthreshold){/* look ahead until sum of scores either exceeds pthreshold or drops below 0.0 */
	  int t = T-1;
	  for(; t > 0; t--){
	    sum += p->iscore[t];
	    if(sum >= pthreshold || sum <= 0.0)
	      break;
	  }
	  if(sum <= 0.0){
	    T = t;
	    pscoreLT -= sum;
	    continue;
	  }
	}
	break;
      }
      pscoreLT -= sum;
    }
    if(PVERB && T < t1){
      printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d: Trimmed Malign[%d][0..%d],score=%0.6f to Malign[%d][%d..%d],score=%0.6f, p->iscore[0,1,T]= %0.6f,%0.6f,%0.6f\n",
	     p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,i,t1,pscoreL,i,0,T,pscoreLT,p->iscore[0],p->iscore[1],p->iscore[T]);
      fflush(stdout);
    }
  }

  if((RefSplitStitch>=2 && T == t1) || (T + 1 >= AlignedSiteThreshold2 && (REFSPLIT_FIX || pscoreLT >= ScoreThreshold2))){/* save left end of Malign[i] (p->sites*[0..T]) as a new matchgroup */
    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }
    if(align->multicnt >= align->multimax){
      int nmultimax = align->multicnt + 16;
      Calign **nMalign = new Calign*[nmultimax];
      for(int t = 0; t < align->multimax; t++)
	nMalign[t] = align->Malign[t];
      for(int t = align->multimax; t < nmultimax; t++){
	nMalign[t] = new Calign[1];
	if(DEBUG) assert(nMalign[t]->allocated_size == 0);
      }
      delete [] align->Malign;
      align->Malign = nMalign;
      align->multimax = nmultimax;
    }
    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }
		    
    Calign *r = align->Malign[align->multicnt];
    r->numpairs = T+1;
    r->expand_arrays(r->numpairs);
    if(DEBUG) assert(r->allocated_size >=r->numpairs);
    r->mapid1 = p->mapid1;
    r->mapid2 = p->mapid2;
    r->orientation = p->orientation;
    if(DEBUG && MultiMatchesRev) assert(p->rev == 0);
    r->rev = p->rev;
    r->scaleID = p->scaleID;
    r->repeat = 0;

    r->stitch = (p->stitch & 1) | 2;// NEW10

    r->noutliers = 0;
    r->maxoutlier = 0.0;
    r->maxoutlierLabels = 0;

    /* copy p (sites 0 .. T) */
    int lastI, lastK, lastJ;
    for(int t = 0; t <= T; t++){
      int I = r->sites1[t] = p->sites1[t];
      int K = r->sitesK1[t] = p->sitesK1[t];
      int J = r->sites2[t] = p->sites2[t];
      FLOAT iscore = r->iscore[t] = p->iscore[t];
      FLOAT outscore = r->outscore[t] = p->outscore[t];
      if(t > 0 && outscore + (FLOAT)0.01 < iscore){// NEW10
	r->noutliers++;
	FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	FLOAT deltaX = X[J] - X[lastJ];
	if(DEBUG) assert(deltaX > 0.0);
	FLOAT delta = fabs(deltaY-deltaX);
	r->maxoutlier = max(delta, r->maxoutlier);
	r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
      }
      lastI = I; lastK = K; lastJ = J;
    }
    r->iscore[r->numpairs] = r->outscore[r->numpairs] = ChimScore;// Sm() is not required at right end
    r->Lend = p->Lend;
    r->Lij1 = p->Lij1;
    r->Lij2 = p->Lij2;
    r->Rend = -2;
    r->Rij1 = p->sites1[T];
    r->Rij2 = p->sites2[T];
#if CALIGN_END==0
    r->LijY = p->LijY;
    r->LijX = p->LijX;
    r->RijY = RijY(Y,X,p->sites1[T],p->sites2[T],N,M);
    if(DEBUG/* HERE HERE >=2 */) assert(p->sites2[T] <= M);
    r->RijX = RijX(Y,X,p->sites1[T],p->sites2[T],N,M);
#endif

    r->score = 0.0;
    for(int t = 0; t <= r->numpairs; t++)
      r->score += r->iscore[t];
    r->Nrange = p->Nrange;
    r->Mrange = p->Mrange;

    r->logPV = alignFP(r, Y, X, N, M, r->orientation, r->mapid1, r->mapid2, r->score, PVERB>=3 ? 1 : 0);
    r->logPV2 = max(r->logPV, p->logPV2);
    if(DEBUG/* HERE HERE >=2 */) assert(r->logPV2 >= r->logPV);

    if(DEBUG/* HERE HERE >=2 */) assert(r->noutliers >= 0 && r->maxoutlier >= 0.0 && r->maxoutlierLabels >= 0 &&
					(r->noutliers <= 0 || r->maxoutlier > 0.0 || r->maxoutlierLabels > 0));

    if(PVERB){
#pragma omp critical
      {
	printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:%s Malign[%d][%d..%d](I=%d..%d,K=%d..%d,J=%d..%d) pairs=%d,score=%0.6f,logPV=%0.2f in Malign[%d..%d]\n",
	       r->mapid1,refmap[r->mapid1]->id,r->mapid2,Gmap[r->mapid2]->id,r->orientation,r->rev,
	       (REFSPLIT_FIX || r->logPV >= LogPvThreshold2 || (RefSplitStitch >= 2 && r->score >= ChimScore)) ? "Saving" : "Discarding",
	       i,0,T,r->sites1[0],r->sites1[r->numpairs-1],r->sitesK1[0],r->sitesK1[r->numpairs-1],r->sites2[0],r->sites2[r->numpairs-1], r->numpairs,r->score,r->logPV,i+1,align->multicnt);
	fflush(stdout);
      }
    }

    if((REFSPLIT_FIX || r->logPV >= LogPvThreshold2) || (RefSplitStitch >= 2 && r->score >= ChimScore)){
      /* place r == align->Malign[align->multicnt] in correct location in align->Malign[u .. align->multicnt] */
      int t = align->multicnt;
      while(--t >= u && align->Malign[t]->score < r->score)
	align->Malign[t+1] = align->Malign[t];
      align->Malign[t+1] = r;


      if(VERB >= 2-PVERB){
#pragma omp critical
	{
	  printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:Saved Malign[%d][%d..%d](I=%d..%d,K=%d..%d,J=%d..%d) pairs=%d,score=%0.6f,logPV=%0.2f as Malign[%d], multicnt -> %d\n",
		 r->mapid1,refmap[r->mapid1]->id,r->mapid2,Gmap[r->mapid2]->id,r->orientation,r->rev,i,0,T,r->sites1[0],r->sites1[r->numpairs-1],r->sitesK1[0],r->sitesK1[r->numpairs-1],r->sites2[0],r->sites2[r->numpairs-1],
		 r->numpairs,r->score,r->logPV,t+1, align->multicnt+1);
	  fflush(stdout);
        }
      }
      align->multicnt++;
    }
  }

  if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
    for(int i = 0; i < align->multimax; i++)
      for(int j = i+1; j < align->multimax; j++)
	if(align->Malign[i] == align->Malign[j]){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	  fflush(stdout);
	  assert(align->Malign[i] != align->Malign[j]);
	}
  }

}

/* Save copy of right end of a matchgroup p == align->Malign[i], (p->sites1[r1 .. U-1]) as new matchgroup, provided -A2 -S2 (?) and -T2 (?) threshold are satisfied (or RefSplitStitch>=2 && score >= ChimScore) and 
   insert it into sorted array align->Malign[u..align->multicnt-1] incrementing align->multicnt.
   
   Trim the left end of the partial matchgroup if that improves the score (but not with RefsplitStitch>=2, unless original score was < ChimScore

   NOTE : there could be a region with very large -ve score in the middle of the partial matchgroup, so checking for -S2 or -T2 should be deferred until the matchgroup has been split by RefSplit.

 */

static void SaveRightFragment(Calign *align, int i, int u, int r1, int U, 
			      double pscoreR, // original score of Right Fragment
			      FLOAT *Y, FLOAT *X, int N, int M, Cmap *rmap, Cmap *nanomap)	  
{
  Calign *p = align->Malign[i];

  int orientation = p->orientation;

  /* truncate unique right portion of Malign[i] at left end if score can be improved (but not with RefSplitStitch>=2, unless original score was < ChimScore (should be biasend2_values[JL], 
     but if biaswtEnd == 0 they are the same) */
  double pthreshold = 0.001;
  if(REFSPLIT_FIX && RefSplit)
    pthreshold = log(1.0/(Rsplit ? Rsplit : Psplit));

  int T = r1;
  double pscoreRT = pscoreR, sum;
  if(!(RefSplitStitch>=2 && pscoreR > ChimScore)){
    for(;T < U; T++){
      if((sum = p->iscore[T+1]) > 0.0){
	if(REFSPLIT_FIX && sum < pthreshold){/* look ahead until sum of scores either exceeds pthreshold or drops below 0.0 */
	  int t = T + 1;
	  for(; t < U; t++){
	    sum += p->iscore[t+1];
	    if(sum >= pthreshold || sum <= 0.0)
	      break;
	  }
	  if(sum <= 0.0){
	    T = t;
	    pscoreRT -= sum;
	    continue;
	  }
	}
	break;
      }
      pscoreRT -= sum;
    }
    if(PVERB /* && T > r1 */){
      printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d: Trimmed Malign[%d][%d..%d],score=%0.6f to Malign[%d][%d..%d],score=%0.6f,iscore[T+1,U-1,U]=%0.6f,%0.6f,%0.6f\n",
	     p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,i,r1,U,pscoreR,i,T,U,pscoreRT,p->iscore[T+1],p->iscore[U-1],p->iscore[U]);
      fflush(stdout);
    }
  }

  if((RefSplitStitch>=2 && T == r1) || (U - T >= AlignedSiteThreshold2 && (REFSPLIT_FIX || pscoreRT >= ScoreThreshold2))){/* save right end of Malign[i] (p->sites*[T .. U-1]) as a new matchgroup */
      if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	for(int i = 0; i < align->multimax; i++)
	  for(int j = i+1; j < align->multimax; j++)
	    if(align->Malign[i] == align->Malign[j]){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		     rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	      fflush(stdout);
	      assert(align->Malign[i] != align->Malign[j]);
	    }
      }

    if(align->multicnt >= align->multimax){
      int nmultimax = align->multicnt + 16;
      Calign **nMalign = new Calign*[nmultimax];
      for(int t = 0; t < align->multimax; t++)
	nMalign[t] = align->Malign[t];
      for(int t = align->multimax; t < nmultimax; t++){
	nMalign[t] = new Calign[1];
	if(DEBUG) assert(nMalign[t]->allocated_size == 0);
      }
      delete [] align->Malign;
      align->Malign = nMalign;
      align->multimax = nmultimax;
    }

    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }

    Calign *r = align->Malign[align->multicnt];
    r->numpairs = U - T;
    r->expand_arrays(r->numpairs);
    if(DEBUG) assert(r->allocated_size >= r->numpairs);
    r->mapid1 = p->mapid1;
    r->mapid2 = p->mapid2;
    r->orientation = p->orientation;
    if(DEBUG && MultiMatchesRev) assert(p->rev == 0);
    r->rev = p->rev;
    r->scaleID = p->scaleID;
    r->repeat = 0;

    r->stitch = 1 | (p->stitch & 2);// NEW10
    r->noutliers = 0;
    r->maxoutlier = 0.0;
    r->maxoutlierLabels = 0;

    /* copy p (sites T .. U-1) */
    int lastI = -1, lastK = -1, lastJ = -1;
    for(int t = T; t < U; t++){
      int I = r->sites1[t - T] = p->sites1[t];
      int K = r->sitesK1[t - T] = p->sitesK1[t];
      int J = r->sites2[t - T] = p->sites2[t];
      if(t == T){
	r->iscore[0] = r->outscore[0] = ChimScore + Sm(J,I,K,Y);
      } else {
	FLOAT iscore = r->iscore[t - T] = p->iscore[t];
	FLOAT outscore = r->outscore[t - T] = p->outscore[t];
	if(outscore + (FLOAT)0.01 < iscore){// NEW10
	  r->noutliers++;
	  FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	  FLOAT deltaX = X[J] - X[lastJ];
	  if(DEBUG) assert(deltaX > 0.0);
	  FLOAT delta = fabs(deltaY-deltaX);
	  r->maxoutlier = max(delta, r->maxoutlier);
	  r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
	}
      }
      lastI = I; lastK = K; lastJ = J;
    }
    r->iscore[U-T] = p->iscore[U];
    r->outscore[U-T] = p->outscore[U];
    r->Lend = -2;
    r->Lij1 = r->sites1[0] - r->sitesK1[0];
    r->Lij2 = r->sites2[0];
    r->Rend = p->Rend;
    r->Rij1 = p->Rij1;
    r->Rij2 = p->Rij2;
#if CALIGN_END==0
    r->LijY = LijY(Y,X,r->Lij1,r->Lij2,N,M);
    r->LijX = LijX(Y,X,r->Lij1,r->Lij2,N,M);
    r->RijY = p->RijY;
    r->RijX = p->RijX;
#endif

    r->score = 0.0;
    for(int t = 0; t <= r->numpairs; t++)
      r->score += r->iscore[t];
    r->Nrange = p->Nrange;
    r->Mrange = p->Mrange;

    r->logPV = alignFP(r, Y, X, N, M, r->orientation, r->mapid1, r->mapid2, r->score, PVERB>=3 ? 1 : 0);
    r->logPV2 = max(r->logPV, p->logPV2);
    if(DEBUG/* HERE HERE >=2 */) assert(r->logPV2 >= r->logPV);

    if(DEBUG/* HERE HERE >=2 */) assert(r->noutliers >= 0 && r->maxoutlier >= 0.0 && r->maxoutlierLabels >= 0 &&
					(r->noutliers <= 0 || r->maxoutlier > 0.0 || r->maxoutlierLabels > 0));
    if(PVERB){
#pragma omp critical
      {
	printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:%s Malign[%d][%d..%d](I=%d..%d,K=%d..%d,J=%d..%d) pairs=%d,score=%0.6f,logPV=%0.2f in Malign[%d..%d]\n",
	       r->mapid1,refmap[r->mapid1]->id,r->mapid2,Gmap[r->mapid2]->id,r->orientation,r->rev,
	       (REFSPLIT_FIX || r->logPV >= LogPvThreshold2 || (RefSplitStitch >= 2 && r->score >= ChimScore)) ? "Saving" : "Discarding",
	       i,T,U-1,r->sites1[0],r->sites1[r->numpairs-1],r->sitesK1[0],r->sitesK1[r->numpairs-1],r->sites2[0],r->sites2[r->numpairs-1], r->numpairs,r->score,r->logPV, u, align->multicnt);
	fflush(stdout);
      }
    }

    if((REFSPLIT_FIX || r->logPV >= LogPvThreshold2) || (RefSplitStitch >= 2 && r->score >= ChimScore)){
      /* place align->Malign[align->multicnt] in correct location in align->Malign[u .. align->multicnt] */
      int t = align->multicnt;
      while(--t >= u && align->Malign[t]->score < r->score)
	align->Malign[t+1] = align->Malign[t];
      align->Malign[t+1] = r;

      if(PVERB){
#pragma omp critical
	{
	  printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:Saved Malign[%d][%d..%d](I=%d..%d,K=%d..%d,J=%d..%d) pairs=%d,score=%0.6f,logPV=%0.2f in Malign[%d], multicnt -> %d\n",
		 r->mapid1,refmap[r->mapid1]->id,r->mapid2,Gmap[r->mapid2]->id,r->orientation,r->rev,
		 i,T,U-1,r->sites1[0],r->sites1[r->numpairs-1],r->sitesK1[0],r->sitesK1[r->numpairs-1],r->sites2[0],r->sites2[r->numpairs-1], r->numpairs,r->score,r->logPV, t+1, align->multicnt+1);
	  fflush(stdout);
	}
      }
      align->multicnt++;
    }
  }

  if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
    for(int i = 0; i < align->multimax; i++)
      for(int j = i+1; j < align->multimax; j++)
	if(align->Malign[i] == align->Malign[j]){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	  fflush(stdout);
	  assert(align->Malign[i] != align->Malign[j]);
	}
  }

}

/* do a thorough check for duplicate or overlapped matchgroups align->Malign[lastnumMatchgroup .. align->multicnt-1]. 

Only matchgroups in the same orientation (and scaleID if hashScaleDelta >= 3) are checked.

First check if matchgroups are overlapped (with identical label pairs) : If so try to combine the matchgroups into a single larger matchgroup:
If MULTIMATCHES_DUPFIX && MULTIMATCH_TRIM, save the unique portions of the original matchgroups as new matchgroups
If MultiMatchesTotScore combine the matchgroups to maximize the total score : At each of the 2 branch points:
  1. Check the score of the first non-shared aligned segment.
  2. If the higher scoring branch has a -ve score that is worse than for the lower scoring branch, pick the lower scoring branch.
  3. Overwrite the original higher scoring matchgroup with the highest scoring combo (or fragment) remaining.

Next (unless strict == 1) only keep any remaining matchgroup i, that relative to every higher scoring matchgroup j:
    1. Has at least MultiMatches unique aligned sites in reference OR query (IF MULTIMATCHES_FIX, just a shift of MultiMatches sites at both ends in the same direction is sufficient)
OR  2. Differs in offset at both alignment ends by at least MultiMatchesDelta (kb), in same direction.
OR  3. shares at most the left end aligned pair OR right end aligned pair with matchgroup j (NOTE : unlike in refalignXYsd(), we don't require the other end offset to differ by MultiMatchesDelta)

If Xorient == -1 OR NumScaleFactor > 1, a reversed and rescaled version of X may need to be computed
If Xorient == -1 AND (hashMultiMatches > 1 && NumScaleFactor > 1 && hashScaleDelta < 2) both orientation may be present, so only same orientation alignments should be compared.

If strict == 1 && MultiMatchesTotScore : matchgroups may contain CutFlip matchgroups and hence MultiMatchesDelta must be reduced to MultiMatchesTotDelta or 50% of smallest matchgroup size (on reference)

Updates lastnumMatchgroup to the new number of total matchgroups (align->multicnt).

*/
static void MultiMatchesRemoveDupes(Calign *align, int &lastNumMatchgroup, FLOAT *Y, FLOAT *X, int N, int M, Cmap *rmap, Cmap *nanomap, int Xorient, int strict = 0)
{
  FLOAT *Xrev = X;
  if(Xorient < 0 || NumScaleFactor > 1)
    Xrev = new FLOAT[M+2];

  int refid = align->mapid1;
  int mapid = align->mapid2;
  int orientation = align->orientation;

  if(DEBUG>=1+RELEASE){/* check that all logPV2 values are >= logPV */
    for(int i = lastNumMatchgroup; i < align->multicnt; i++){
      Calign *p = align->Malign[i];
      if(DEBUG && !(p->logPV2 >= p->logPV)){
	printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld):Malign[%d]:or=%d,rev=%d,pairs=%d, score= %0.7f, logPV= %0.6f, logPV2= %0.6f\n",
	       p->mapid1,rmap->id,p->mapid2,nanomap->id,i,p->orientation,p->rev,p->numpairs,p->score,p->logPV,p->logPV2);
	fflush(stdout);
	assert(p->logPV2 >= p->logPV);
      }
    }
  }
  if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
    for(int i = 0; i < align->multimax; i++)
      for(int j = i+1; j < align->multimax; j++)
	if(align->Malign[i] == align->Malign[j]){
	  printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	  fflush(stdout);
	  assert(align->Malign[i] != align->Malign[j]);
	}
  }

  if(DEBUG)
    for(int t = 0; t < align->multicnt; t++)
      assert(align->Malign[t]->allocated_size > 0);

  if(align->multicnt > lastNumMatchgroup + 1){

    /* fix rounding errors in matchgroup scores */
    for(int i = lastNumMatchgroup; i < align->multicnt; i++){
      Calign *p = align->Malign[i];
      int U = p->numpairs;

      if(PVERB>=3 && p->sites1[U-1] == 19101 && p->sitesK1[U-1] == 0 && p->sites2[U-1]==1062){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:Malign[%d]: score= %0.6f, numpairs= %d:\n",p->mapid1,rmap->id,p->mapid2,nanomap->id,p->orientation,p->rev,i,p->score,U);
	fflush(stdout);
	double score = 0.0;
	for(int t = 0; t <= U; t++){
	  score += p->iscore[t];
	  if(t <= 0)
	    printf("  t=%5d: I=%d,K=%d,J=%d: iscore[t]= %0.6f, iscoresum= %0.6f\n",
		   t,p->sites1[t],p->sitesK1[t],p->sites2[t],p->iscore[t], score);
	  else if(t < U)
	    printf("  t=%5d: I=%d..%d,K=%d..%d,J=%d..%d: outscore[t]= %0.6f, iscore[t]= %0.6f, iscoresum= %0.6f\n",
		   t,p->sites1[t-1],p->sites1[t],p->sitesK1[t-1],p->sitesK1[t],p->sites2[t-1],p->sites2[t],p->outscore[t],p->iscore[t], score);
	  else
	    printf("  t=%5d: iscore[t]= %0.6f, iscoresum= %0.6f\n", t, p->iscore[t],score);
	}
      }

      double score = 0.0;
      for(int t = 0; t <= U; t++)
	score += p->iscore[t];

      if(DEBUG && fabs(score - p->score) > ASCORE_MARGIN + SCORE_MARGIN * fabs(p->score)){
	#pragma omp critical
	{
	  printf("WARNING: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d: Malign[%d]->score= %0.7f, iscore[0..%d]= %0.7f (err= %0.7f) : correcting\n",
		 p->mapid1,rmap->id,p->mapid2,nanomap->id,p->orientation,p->rev,i,p->score,U,score,p->score - score);
	  fflush(stdout);
	  if(DEBUG >= 1+RELEASE) assert(fabs(score - p->score) < ASCORE_MARGIN + SCORE_MARGIN * fabs(p->score));
	}
      }

      p->score = score;
    }

    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }

    /* sort all matchgroups in align->Malign[lastNumMatchgroup..align->multicnt-1][0] by score in descending order of Score */
    qsort(&align->Malign[lastNumMatchgroup], align->multicnt - lastNumMatchgroup, sizeof(Calign *), (intcmp *)CalignScoreDec);

    if(PVERB){
      printf("MultiMatchesRemoveDupes:rid=%lld,mid=%lld,or=%d:multicnt=%d,lastNumMatchgroup=%d\n",rmap->id,nanomap->id,orientation,align->multicnt,lastNumMatchgroup);
      for(int i = lastNumMatchgroup; i < align->multicnt; i++){
	Calign *p = align->Malign[i];

	if(DEBUG && Xorient >= 0 && !(p->orientation == Xorient)){
	  #pragma omp critical
	  {
	    printf("\t Malign[%d]=%p : orientation= %d, Xorient= %d\n",i,p,p->orientation,Xorient);
	    fflush(stdout);
	    assert(p->orientation == Xorient);
	  }
	}

	if(Xorient < 0 || NumScaleFactor > 1){/* compute Xrev[] */
	  if(DEBUG && NumScaleFactor <= 1) assert(p->scaleID == 0);
	  FLOAT scale = ScaleFactor[p->scaleID];
	  if(DEBUG && p->scaleID == 0) assert(scale == 1.0);
	  if((Xorient < 0) ? (!p->orientation) : (p->orientation == Xorient)){
	    for(int J=0;J <= M+1;J++)
	      Xrev[J] = X[J]*scale;
	  } else {
	    for(int J=0;J <= M+1;J++)
	      Xrev[J] = (X[M+1] - X[M+1-J])*scale;
	  }
	}

	//	(void) alignFPsd(A,p->I,p->J,p->K,Y,Xrev,N,M,IMAX-IMIN+1,jmax-jmin+1,p->R,orientation,rev,scaleID,refid,mapid,0, PVERB ? 1 : 0,numpairs,Lend,p->IL);

	double logPV = p->logPV;
	int U = p->numpairs;
	int I = p->sites1[U-1];
	int K = p->sitesK1[U-1];
	int J = p->sites2[U-1];
	int IL = p->sites1[0];
	int KL = p->sitesK1[0];
	int JL = p->sites2[0];
	printf("  Malign[%d]= %p:or=%d,rev=%d,sc=%d,I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d (offset=%0.3f .. %0.3f):numpairs=%d, score= %0.6f, LogPv= %0.2f(logPV2=%0.2f)\n",
	       i,p,p->orientation,p->rev,p->scaleID,I,K,J,IL,KL,JL,Yc(Y,I,K)-Xrev[J],Yc(Y,IL,KL)-Xrev[JL],U, p->score,logPV,p->logPV2);

	if(PVERB>=3) {
	  printf("\t Alignment:\n");
	  double TlogPV = alignFP(p, Y, Xrev, N, M, p->orientation, p->mapid1, p->mapid2, p->score, PVERB ? 1 : 0);
	  if(fabs(TlogPV - logPV) > 0.01){
	    printf("\t\t WARNING:logPV= %0.4f, alignFP()= %0.4f (err= %0.4f)\n", logPV, TlogPV, logPV - TlogPV);
	    fflush(stdout);
	  }
	}
      }
      fflush(stdout);

      //      lastNumMatchgroup = align->multicnt;
      //      return;
    }

    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }

    /* Eliminate a matchgroup if it does not have enough unique aligned sites relative to every higher scoring matchgroup with same orientation (see comments above for details) */
    int resetcnt = 0;
    int j = lastNumMatchgroup + 1;
    for(int i = lastNumMatchgroup + 1; i < align->multicnt; i++){
    Lrepeati:
      if(i >= align->multicnt)/* can happen due to jump to Lrepeati: */
	break;

      Calign *p = align->Malign[i];
      if(DEBUG && i+1 < align->multicnt && !(p->score >= align->Malign[i+1]->score)){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld):i=%d,multicnt=%d:Malign[i]->score=%0.6f(logPV=%0.2f,or=%d),Malign[i+1]->score=%0.6f(logPV=%0.2f,or=%d)\n",
	       p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,i,align->multicnt,p->score,p->logPV,p->orientation,align->Malign[i+1]->score,align->Malign[i+1]->logPV,align->Malign[i+1]->orientation);
	fflush(stdout);
	assert(p->score >= align->Malign[i+1]->score);// align->Malign[i.. multicnt-1] should be sorted by score
      }
      if(DEBUG>=2){
	for(int t = i+1; t < align->multicnt; t++){
	  if(!(align->Malign[t-1]->score >= align->Malign[t]->score && align->Malign[t-1]->numpairs > 0 && align->Malign[t]->numpairs > 0)){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld):i=%d,j=%d,multicnt=%d:Malign[%d]->score=%0.6f(logPV=%0.2f,or=%d,pairs=%d),Malign[%d]->score=%0.6f(logPV=%0.2f,or=%d,pairs=%d)\n",
		   p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,i,j,align->multicnt,
		   t,align->Malign[t]->score,align->Malign[t]->logPV,align->Malign[t]->orientation,align->Malign[t]->numpairs,
		   t-1,align->Malign[t-1]->score,align->Malign[t-1]->logPV,align->Malign[t-1]->orientation,align->Malign[t-1]->numpairs);
	    fflush(stdout);
	    assert(align->Malign[t-1]->score >= align->Malign[t]->score && align->Malign[t-1]->numpairs > 0 && align->Malign[t]->numpairs > 0);
	  }
	}
	for(int t = lastNumMatchgroup; t < j; t++){
	  if(!(align->Malign[t]->numpairs > 0 && (t <= lastNumMatchgroup || align->Malign[t]->score <= align->Malign[t-1]->score))){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld):i=%d,j=%d:t=%d:Malign[t]:score=%0.6f,pairs= %d, Malign[t-1]->score= %0.6f\n",
		   p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,i,j,t,align->Malign[t]->score,align->Malign[t]->numpairs, (t <= lastNumMatchgroup) ? -1.0 : align->Malign[t-1]->score);
	    fflush(stdout);
	    assert(align->Malign[t]->numpairs > 0 && (t <= 0 || align->Malign[t]->score <= align->Malign[t-1]->score));
	  }
	}
      }

      if(DEBUG && Xorient >= 0) assert(p->orientation == Xorient);

      if(Xorient < 0 || NumScaleFactor > 1){/* compute Xrev[] */
	if(DEBUG && NumScaleFactor <= 1) assert(p->scaleID == 0);
	FLOAT scale = ScaleFactor[p->scaleID];
	if(DEBUG && p->scaleID == 0) assert(scale == 1.0);
	if((Xorient < 0) ? (!p->orientation) : (p->orientation == Xorient)){
	  for(int J=0;J <= M+1;J++)
	    Xrev[J] = X[J]*scale;
	} else {
	  for(int J=0;J <= M+1;J++)
	    Xrev[J] = (X[M+1] - X[M+1-J])*scale;
	}
      }

      if(DEBUG && p->numpairs <= 0){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld):i=%d,multicnt=%d:Malign[i]->score=%0.6f(logPV=%0.2f,or=%d,sc=%d,numpairs=%d)\n",
	       p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,i,align->multicnt,p->score,p->logPV,p->orientation,p->scaleID,p->numpairs);
	fflush(stdout);
	assert(p->numpairs >= 1);
      }

      int U = p->numpairs;
      int I = p->sites1[U-1];
      int K = p->sitesK1[U-1];
      int J = p->sites2[U-1];
      int IL = p->sites1[0];
      int KL = p->sitesK1[0];
      int JL = p->sites2[0];
      if(DEBUG) assert(refmap[p->mapid1]->origmap == NULL);
      if(DEBUG) assert(Gmap[p->mapid2]->origmap == NULL);

      int orientation = p->orientation;

      if(PVERB){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d, lastNumMatchgroup=%d, multicnt=%d\n",
	       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,j,lastNumMatchgroup,align->multicnt);
	for(int t = lastNumMatchgroup; t < j; t++){
	  Calign *p = align->Malign[t];
	  printf("\t Malign[%d]=%p: score= %0.6f, or=%d, rev=%d, sc=%d, pairs= %d, LogPv= %0.2f(logPV2= %0.2f)\n",
		 t, p, p->score,p->orientation, p->rev,p->scaleID, p->numpairs, p->logPV, p->logPV2);
	}
	
	fflush(stdout);
      }

      if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	for(int i = 0; i < align->multimax; i++)
	  for(int j = i+1; j < align->multimax; j++)
	    if(align->Malign[j] && align->Malign[i] == align->Malign[j]){
	      printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		     rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	      fflush(stdout);
	      assert(align->Malign[i] != align->Malign[j]);
	    }
      }

      if(DEBUG>=2){
	for(int t = lastNumMatchgroup + 1; t < j; t++){
	  if(!(align->Malign[t-1]->score >= align->Malign[t]->score)){
	    printf("MultiMatchesRemoveDupes: rid=%lld,mid=%lld:lastNumMatchgroup=%d,t=%d,j=%d,multicnt=%d:Malign[t-1]:or=%d,score=%0.6f; Malign[t]:or=%d,score=%0.6f\n",
		   rmap->id,nanomap->id,lastNumMatchgroup,t,j,align->multicnt,
		   align->Malign[t-1]->orientation,align->Malign[t-1]->score, align->Malign[t]->orientation,align->Malign[t]->score);
	    fflush(stdout);
	    assert(align->Malign[t-1]->score >= align->Malign[t]->score);
	  }
	}
      }

      int k = lastNumMatchgroup;
      for(; k < j; k++){
	Calign *q = align->Malign[k];

	if(q->orientation != p->orientation)
	  continue;
	if(hashScaleDelta >= 3 && q->scaleID != p->scaleID)
	  continue;

	if(DEBUG) assert(q->rev == p->rev);

	if(DEBUG>=2){
	  for(int t = i+1; t < align->multicnt; t++){
	    if(!(align->Malign[t-1]->score >= align->Malign[t]->score && align->Malign[t-1]->numpairs > 0 && align->Malign[t]->numpairs > 0)){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld):i=%d,j=%d,multicnt=%d:Malign[%d]->score=%0.6f(logPV=%0.2f,or=%d,pairs=%d),Malign[%d]->score=%0.6f(logPV=%0.2f,or=%d,pairs=%d)\n",
		     p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,i,j,align->multicnt,
		     t,align->Malign[t]->score,align->Malign[t]->logPV,align->Malign[t]->orientation,align->Malign[t]->numpairs,
		     t-1,align->Malign[t-1]->score,align->Malign[t-1]->logPV,align->Malign[t-1]->orientation,align->Malign[t-1]->numpairs);
	      fflush(stdout);
	      assert(align->Malign[t-1]->score >= align->Malign[t]->score && align->Malign[t-1]->numpairs > 0 && align->Malign[t]->numpairs > 0);
	    }
	  }
	  for(int t = lastNumMatchgroup; t < j; t++){
	    if(!(align->Malign[t]->numpairs > 0 && (t <= lastNumMatchgroup || align->Malign[t]->score <= align->Malign[t-1]->score))){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld):i=%d,j=%d,k=%d:t=%d:Malign[t]:score=%0.6f,pairs= %d, Malign[t-1]->score= %0.6f\n",
		     p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,i,j,k,t,align->Malign[t]->score,align->Malign[t]->numpairs, (t <= lastNumMatchgroup) ? -1.0 : align->Malign[t-1]->score);
	      fflush(stdout);
	      assert(align->Malign[t]->numpairs > 0 && (t <= lastNumMatchgroup || align->Malign[t]->score <= align->Malign[t-1]->score));
	    }
	  }
	}

	if(DEBUG>=2 && !MultiMatchesTotScore) assert(q->score >= p->score);

#if 1 // NOTE : play it safe and avoid checking matchgroup[k] even if its score is < p->score (so we don't accidentally delete the higher scoring matchgroup)
	if(!(q->score >= p->score)){// NEW
	  if(DEBUG) assert(lastNumMatchgroup <= k && k < j);
	  k = j;// p == Malign[i] will be kept since all higher scoring matchgroups have been checked
	  break;
	}
#endif
	int U2 = q->numpairs;
	int I2 = q->sites1[U2-1];
	int K2 = q->sitesK1[U2-1];
	int J2 = q->sites2[U2-1];
	int IL2 = q->sites1[0];
	int KL2 = q->sitesK1[0];
	int JL2 = q->sites2[0];

 	/* NOTE : unlike in refalignXYsd(), here we first check for overlapped alignments with identical shared regions, since speed is not the primary concern and we need to detect shared regions in the middle even if
	   both ends are sufficently distinct (which is NOT possible if the matchgroups are from the same refalignXYsd() call) */

	/* check for overlapped alignments : If so merge p with q and filter out p (Skip check if q is completely overlapped by p, which should be very rare since p is lower scoring) */
	if(min(I,I2) >= max(IL,IL2) && min(J,J2) >= max(JL,JL2)){
	  if(PVERB>=4){
	    printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:i=%d,j=%d,k=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f):Looking for matching alignment pairs\n",
		   p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,i,j,k,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV);
	    fflush(stdout);
	  }

	  /* locate leftmost matching  alignments in p & q */
	  int t1= 0, t2= 0;
	  for(; t1 < U && t2 < U2; ){
	    if(PVERB>=4){
	      printf("\t t1=%d/%d,t2=%d/%d:p->sites*[t1]= %d,%d,%d, q->sites*[t2]= %d,%d,%d\n",t1,U,t2,U2,p->sites1[t1],p->sitesK1[t1],p->sites2[t1],q->sites1[t2],q->sitesK1[t2],q->sites2[t2]);
	      fflush(stdout);
	    }
	    if(p->sites1[t1] < q->sites1[t2]){
	      t1++;
	      continue;
	    }
	    if(p->sites1[t1] > q->sites1[t2]){
	      t2++;
	      continue;
	    }
	    if(p->sites2[t1] < q->sites2[t2]){
	      t1++;
	      continue;
	    }
	    if(p->sites2[t1] > q->sites2[t2]){
	      t2++;
	      continue;
	    }
	    if(p->sitesK1[t1] == q->sitesK1[t2]) /* overlap match found */
	      break;
	    
	    if(t1 + 1 < U)
	      t1++;
	    else
	      t2++;
	  }
	  if(t1 < U && t2 < U2){/* overlap match found */
	    if(DEBUG>=2) assert(p->sites1[t1] == q->sites1[t2] && p->sitesK1[t1] == q->sitesK1[t2] && p->sites2[t1] == q->sites2[t2]);

	    int r1,r2;

	    if(MULTIMATCHES_DUPFIX){ // locate rightmost CONTIGUOUS match and then reinsert remainder of lower scoring right end into align->Malign[] at right position (if large enough)
	      r1 = t1;
	      r2 = t2;
	      while(r1 < U-1 && r2 < U2 - 1){
		if(p->sites1[r1+1] != q->sites1[r2+1])
		  break;
		if(p->sites2[r1+1] != q->sites2[r2+1])
		  break;
		if(p->sitesK1[r1+1] != q->sitesK1[r2+1])
		  break;
		r1++;
		r2++;
	      }
	      if(MULTIMATCHES_DUPFIX >= 2){/* locate highest scoring CONTIGUOUS match */
		double pscoreM = 0.0;
		for(int t = t1+1; t <= r1; t++)
		  pscoreM += p->iscore[t];

		int bestt1 = t1, bestt2 = t2, bestr1 = r1, bestr2 = r2;
		double bestscoreM = pscoreM;
		
		int cnt = 0;
		while(r1 < U && r2 < U2){
		  if(DEBUG>=3 && ++cnt >= 1000){
		    printf("WARNING: r1=%d,r2=%d: bestt1=%d,best2=%d,bestr1=%d,bestr2=%d,bestscoreM=%0.6f:cnt=%d : loop timeout\n",
			   r1,r2,bestt1,bestt2,bestr1,bestr2,bestscoreM,cnt);
		    fflush(stdout);
		    break;
		  }
		  /* find start of next matching region */
		  t1 = r1+1, t2 = r2+1;
		  for(; t1 < U && t2 < U2; ){
		    if(PVERB>=4){
		      printf("\t t1=%d/%d,t2=%d/%d:p->sites*[t1]= %d,%d,%d, q->sites*[t2]= %d,%d,%d\n",t1,U,t2,U2,p->sites1[t1],p->sitesK1[t1],p->sites2[t1],q->sites1[t2],q->sitesK1[t2],q->sites2[t2]);
		      fflush(stdout);
		    }
		    if(p->sites1[t1] < q->sites1[t2]){
		      t1++;
		      continue;
		    }
		    if(p->sites1[t1] > q->sites1[t2]){
		      t2++;
		      continue;
		    }
		    if(p->sites2[t1] < q->sites2[t2]){
		      t1++;
		      continue;
		    }
		    if(p->sites2[t1] > q->sites2[t2]){
		      t2++;
		      continue;
		    }
		    if(p->sitesK1[t1] == q->sitesK1[t2]) /* overlap match found */
		      break;
	    
		    if(t1 + 1 < U)
		      t1++;
		    else
		      t2++;
		  }
		  r1 = t1;
		  r2 = t2;
		  if(t1 < U && t2 < U2){/* overlap match found : locate right end */
		    while(r1 < U-1 && r2 < U2 - 1){
		      if(p->sites1[r1+1] != q->sites1[r2+1])
			break;
		      if(p->sites2[r1+1] != q->sites2[r2+1])
			break;
		      if(p->sitesK1[r1+1] != q->sitesK1[r2+1])
			break;
		      r1++;
		      r2++;
		    }
		    /* compute score */
		    pscoreM = 0.0;
		    for(int t = t1+1; t <= r1; t++)
		      pscoreM += p->iscore[t];
		    if(pscoreM > bestscoreM){
		      bestt1 = t1;
		      bestt2 = t2;
		      bestr1 = r1;
		      bestr2 = r2;
		      bestscoreM = pscoreM;
		    }
		  }
		}// while(r1 < U && r2 < U2)

		t1 = bestt1;
		t2 = bestt2;
		r1 = bestr1;
		r2 = bestr2;
	      }// MULTIMATCHES_DUPFIX >= 2

	    } else { /* locate rightmost matching alignments in p & q */
	      r1 = U - 1;
	      r2 = U2-1;
	      while(r1 > t1 || r2 > t2){
		if(p->sites1[r1] < q->sites1[r2]){
		  r2--;
		  continue;
		}
		if(p->sites1[r1] > q->sites1[r2]){
		  r1--;
		  continue;
		}
		if(p->sites2[r1] < q->sites2[r2]){
		  r2--;
		  continue;
		}
		if(p->sites2[r1] > q->sites2[r2]){
		  r1--;
		  continue;
		}
		if(p->sitesK1[r1] == q->sitesK1[r2])/* overlap match found */
		  break;

		if(r1 > t1)
		  r1--;
		if(r2 > t2)
		  r2--;
	      } 
	    }
	    if(DEBUG>=2) assert(r1 >= t1 && r2 >= t2);
	    if(DEBUG>=2) assert(p->sites1[r1] == q->sites1[r2] && p->sitesK1[r1] == q->sitesK1[r2] && p->sites2[r1] == q->sites2[r2]);

	    /* choose p up to t1 OR q up to t2 (whichever scores higher, unless MultiMatchesTotScore) */
	    double pscoreL = 0.0, qscoreL = 0.0;
	    for(int t = 0; t <= t1; t++)
	      pscoreL += p->iscore[t];
	    for(int t = 0; t <= t2; t++)
	      qscoreL += q->iscore[t];

	    /* choose p from t1 to r1 OR q from t2 to r2 (whichever scores higher) */
	    double pscoreM = 0.0, qscoreM = 0.0;
	    for(int t = t1+1; t <= r1; t++)
	      pscoreM += p->iscore[t];
	    for(int t = t2+1; t <= r2; t++)
	      qscoreM += q->iscore[t];
	    
	    /* choose p from r1 to right end OR q from r2 to right end (whichever scores higher, unless MultiMatchesTotScore) */
	    double pscoreR = 0.0, qscoreR = 0.0;
	    for(int t = r1+1; t <= U; t++)
	      pscoreR += p->iscore[t];
	    for(int t = r2+1; t <= U2; t++)
	      qscoreR += q->iscore[t];

	    if(!(qscoreM >= MultiMatchesDupesMinscore || pscoreM > p->score * MultiMatchesDupesMinscoreRel)){// NEW177: common region is not large enough to break up p or q */
	      if(PVERB>=3){
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:i=%d,j=%d,k=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f):pscoreM= %0.6f is not large enough\n",
		       p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,i,j,k,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV,pscoreM);
		fflush(stdout);
	      }
	      continue;
	    }

	    // NOTE : MultiMatchesTotScore should use similar trimming heuristic as in refalignXYsd() (but based on iscore[] only, as implemented in SaveRightFragment() & SaveLeftFragment)
	    bool PreferLp, PreferRp;
	    if(MMPEN_FIX){/* NEW code */
	      if(pscoreL <= qscoreL){/* break ties in favor of q */
		PreferLp = !MultiMatchesTotScore ? (pscoreL > qscoreL + MM_PEN) 
		  : (qscoreL <= 0.0 || p->iscore[t1] < MM_PEN + q->iscore[t2]) ? false
		  : (qscoreL > 0.0 && p->iscore[t1] > MM_PEN + q->iscore[t2]) ? true : (pscoreL > qscoreL + MM_PEN);
	      } else {/* break ties in favor of p */
		PreferLp = !MultiMatchesTotScore ? (pscoreL > qscoreL - MM_PEN) 
		  : (qscoreL <= 0.0 || q->iscore[t2] < MM_PEN + p->iscore[t1]) ? true 
		  : (qscoreL > 0.0 && q->iscore[t2] > MM_PEN + p->iscore[t1]) ? false : (pscoreL > qscoreL - MM_PEN);
	      }
	      if(pscoreR <= qscoreR){/* break ties in favor of q */
		PreferRp = !MultiMatchesTotScore ? (pscoreR > qscoreR + MM_PEN)
		  : (qscoreR <= 0.0 || p->iscore[r1+1] < MM_PEN + q->iscore[r2+1]) ? false
		  : (qscoreR > 0.0 && p->iscore[r1+1] > MM_PEN + q->iscore[r2+1]) ? true : (pscoreR > qscoreR + MM_PEN);
	      } else {/* break ties in favor of p */
		PreferRp = !MultiMatchesTotScore ? (pscoreR > qscoreR - MM_PEN)
		  : (qscoreR <= 0.0 || q->iscore[r2+1] < MM_PEN + p->iscore[r1+1]) ? true
		  : (qscoreR > 0.0 && q->iscore[r2+1] > MM_PEN + p->iscore[r1+1]) ? false : (pscoreR > qscoreR - MM_PEN);
	      }
	    } else {/* OLD code */
	      if(p->score <= q->score){/* break tries in favor of q */
		PreferLp = !MultiMatchesTotScore ? (pscoreL > qscoreL + MM_PEN) 
		  : (pscoreL > MM_PEN && q->iscore[t2] < min(-MM_PEN, p->iscore[t1])) ? true 
		  : (qscoreL > MM_PEN && p->iscore[t1] < min(-MM_PEN, q->iscore[t2])) ? false : (pscoreL > qscoreL + MM_PEN);

		PreferRp = !MultiMatchesTotScore ? (pscoreR > qscoreR + MM_PEN)
		  : (pscoreR > MM_PEN && q->iscore[r2+1] < min(-MM_PEN,p->iscore[r1+1])) ? true
		  : (qscoreR > MM_PEN && p->iscore[r1+1] < min(-MM_PEN,q->iscore[r2+1])) ? false : (pscoreR > qscoreR + MM_PEN);

	      } else {/* break ties in favor of p */
		PreferLp = !MultiMatchesTotScore ? (pscoreL > qscoreL - MM_PEN) 
		  : (pscoreL > MM_PEN && q->iscore[t2] < min(-MM_PEN, p->iscore[t1])) ? true 
		  : (qscoreL > MM_PEN && p->iscore[t1] < min(-MM_PEN, q->iscore[t2])) ? false : (pscoreL > qscoreL - MM_PEN);

		PreferRp = !MultiMatchesTotScore ? (pscoreR > qscoreR - MM_PEN)
		  : (pscoreR > MM_PEN && q->iscore[r2+1] < min(-MM_PEN,p->iscore[r1+1])) ? true
		  : (qscoreR > MM_PEN && p->iscore[r1+1] < min(-MM_PEN,q->iscore[r2+1])) ? false : (pscoreR > qscoreR - MM_PEN);
	      }
	    }

	    if(VERB >= 2-PVERB || (DEBUG && MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >= 3) && !(fabs(pscoreM - qscoreM) <= 1e-3 * max(U,U2))) ||
	       (DEBUG && !(isfinite(pscoreL) && isfinite(qscoreL) && isfinite(pscoreM) && isfinite(qscoreM) && isfinite(pscoreR) && isfinite(qscoreR) &&
			   fabs(pscoreL+pscoreM+pscoreR - p->score) <= 1e-5 + fabs(p->score)*1e-6 && fabs(qscoreL+qscoreM+qscoreR - q->score) <= 1e-5 + fabs(q->score)*1e-6))){
	      #pragma omp critical
	      {
		printf("refid=%d(%lld),mapid=%d(%lld),or=%d,%d,rev=%d,sc=%d,%d:i=%d,j=%d,k=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f)\n",
		       p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,q->orientation,p->rev,p->scaleID,q->scaleID,i,j,k,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV);
		printf("   t1=%d(IKJ=%d,%d,%d),r1=%d(IKJ=%d,%d,%d),U1=%d; t2=%d(IKJ=%d,%d,%d),r2=%d(IKJ=%d,%d,%d),U2=%d (A2=%d)\n",
		       t1,p->sites1[t1],p->sitesK1[t1],p->sites2[t1],r1,p->sites1[r1],p->sitesK1[r1],p->sites2[r1],U,
		       t2,q->sites1[t2],q->sitesK1[t2],q->sites2[t2],r2,q->sites1[r2],q->sitesK1[r2],q->sites2[r2],U2,AlignedSiteThreshold2);
		printf("     pscoreL=%0.6f,pscoreM=%0.6f,pscoreR=%0.6f,qscoreL=%0.6f,qscoreM=%0.6f,qscoreR=%0.6f (Xorient=%d,scaleID=%d)\n",pscoreL,pscoreM,pscoreR,qscoreL,qscoreM,qscoreR,Xorient,p->scaleID);
		if(1 /* MultiMatchesTotScore */){
		  int t2m = max(0,t2-1), t1m = max(0,t1-1);
		  printf("     PreferLp=%d: q->iscore[t2]= %0.6f(IKJ=%d,%d,%d), p->iscore[t1]= %0.6f(IKJ=%d,%d,%d)\n", 
			 PreferLp ? 1 : 0, q->iscore[t2], q->sites1[t2m], q->sitesK1[t2m], q->sites2[t2m],p->iscore[t1], p->sites1[t1m],p->sitesK1[t1m],p->sites2[t1m]);
		  int r2m = min(U2-1,r2+1), r1m = min(U-1,r1+1);
		  printf("     PreferRp=%d: q->iscore[r2+1]= %0.6f(IKJ=%d,%d,%d), p->iscore[r1+1]= %0.6f(IKJ=%d,%d,%d)\n", 
			 PreferRp ? 1 : 0, q->iscore[r2+1], q->sites1[r2m],q->sitesK1[r2m],q->sites2[r2m],p->iscore[r1+1], p->sites1[r1m],p->sitesK1[r1m],p->sites2[r1m]);
		}
		printf("     p->Lend=%d,p->Lij1=%d,p->Lij2=%d,p->Rend=%d,p->Rij1=%d,p->Rij2=%d, q->Lend=%d,q->Lij1=%d,q->Lij2=%d,q->Rend=%d,q->Rij1=%d,q->Rij2=%d\n",
		       p->Lend,p->Lij1,p->Lij2,p->Rend,p->Rij1,p->Rij2,q->Lend,q->Lij1,q->Lij2,q->Rend,q->Rij1,q->Rij2);
		fflush(stdout);

		if(DEBUG) assert(isfinite(pscoreL) && isfinite(qscoreL) && isfinite(pscoreM) && isfinite(qscoreM) && isfinite(pscoreR) && isfinite(qscoreR));
		if(DEBUG && !(fabs(pscoreL+pscoreM+pscoreR - p->score) <= 1e-5 + fabs(p->score)*1e-6)){
		  int U = p->numpairs;
		  double sum = 0.0;
		  for(int t = 0; t <= U; t++){
		    sum += p->iscore[t];
		    printf("\t t=%d/%d: iscore[t]= %0.7f, cum= %0.7f\n", t, U, p->iscore[t],sum);
		  }
		  fflush(stdout);
		  assert(fabs(pscoreL+pscoreM+pscoreR - p->score) <= 1e-5 + fabs(p->score)*1e-6);
		}
		if(DEBUG) assert(fabs(qscoreL+qscoreM+qscoreR - q->score) <= 1e-5 + fabs(q->score)*1e-6);
		if(DEBUG>= 1+RELEASE && MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >= 3) && !(fabs(pscoreM - qscoreM) <= 2e-3 * max(U,U2))){/* middle regions should be identical */
		  printf("pscoreM = sum(iscore[%d..%d]) = %0.6f:\n", t1+1,r1,pscoreM);
		  double sum = 0.0;
		  for(int t = t1+1; t <= r1; t++){
		    sum += p->iscore[t];
		    printf("%d/%d: I=%d..%d,K=%d..%d,J=%d..%d: iscore[%d]= %0.6f, outscore[%d]= %0.6f, iscoresum= %0.6f\n",
			   t-t1,r1-t1,p->sites1[t-1],p->sites1[t],p->sitesK1[t-1],p->sitesK1[t],p->sites2[t-1],p->sites2[t],t,p->iscore[t],t,p->outscore[t],sum);
		  }

		  printf("qscoreM = sum(iscore[%d..%d]) = %0.6f:\n", t2+1,r2,qscoreM);
		  sum = 0.0;
		  for(int t = t2+1; t <= r2; t++){
		    sum += q->iscore[t];
		    printf("%d/%d: I=%d..%d,K=%d..%d,J=%d..%d: iscore[%d]= %0.6f, outscore[%d]= %0.6f, iscoresum= %0.6f\n",
			   t-t2,r2-t2,q->sites1[t-1],q->sites1[t],q->sitesK1[t-1],q->sitesK1[t],q->sites2[t-1],q->sites2[t],t,q->iscore[t],t,q->outscore[t], sum);
		  }

		  fflush(stdout);

		  assert(fabs(pscoreM - qscoreM) <= 2e-3 * max(U,U2));
		}
	      }
            }

	    if(!PreferLp && !PreferRp && ((MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >= 3)) || pscoreM <= qscoreM)){ /* q is same or superior to p in all 3 segments (OR p is same as q) */
	      if(VERB >= 2-PVERB){
		#pragma omp critical
		{
		  if(MULTIMATCHES_DUPFIX && MULTIMATCH_TRIM)
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:i=%d/%d,j=%d,k=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f): p completely overlapped by q : keeping q unchanged\n",
			   p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,i,align->multicnt,j,k,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV);
		  else
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:i=%d/%d,j=%d,k=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f): p completely overlapped by q : deleting p\n",
			   p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,i,align->multicnt,j,k,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV);
		  printf("   pscoreL=%0.6f,pscoreM=%0.6f,pscoreR=%0.6f,qscoreL=%0.6f,qscoreM=%0.6f,qscoreR=%0.6f\n",pscoreL,pscoreM,pscoreR,qscoreL,qscoreM,qscoreR);
		  fflush(stdout);
		}
	      }	
	      
	    LmatchingMaps:	      
	      if(MULTIMATCHES_DUPFIX && MULTIMATCH_TRIM){/* save the unique portions of p, if they are large enough */
		if(MULTIMATCH_TRIMFIX && t1==r1 /* WAS (t1==0 && r1==0) || (t1==U-1 && r1==U-1))*/) {// single label pair overlap for p == align->Malign[i] : save both p & q
		  if(PVERB){
		    printf("\t Single lable pair overlap between p & q : Keeping both p & q\n");
		    fflush(stdout);
		  }
		  continue;/* NOTE : This is needed to avoid infinite loop, since otherwise :
		              1. If single label pair overlap is at left or right end of p, the "unique" right or left portion saved below is the entire align->Malign[i] !
			      2. If single label pair overlap is in middle of p, it will get split into 2 pieces that subsequently get merged together again ! */
		}

		if(r1 > 0 && U - r1 - 1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique right portion of Malign[i] is large enough to save */
		  SaveRightFragment(align, i, i+1, r1, U, pscoreR, Y,Xrev,N,M,rmap,nanomap);
		      
	        if(t1 < U - 1 && t1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique left portion of Malign[i] is large enough to save */
		  SaveLeftFragment(align, i, i+1, t1, pscoreL,Y,Xrev,N,M,rmap,nanomap);
   	      } // MULTIMATCH_TRIM

	      break;/* filter out p == align->Malign[i] */
	    }

	    if(PreferLp && PreferRp && ((MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >= 3)) || pscoreM >= qscoreM)){   /* p is superior to q in all 3 segments (should never happen, unless MultiMatchesTotScore) */
	      if(VERB >= 2-PVERB || (DEBUG/* HERE >=2 */ && !MultiMatchesTotScore && !(MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >= 3)))){
		#pragma omp critical
		{
		  if((MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >= 3)) && !MultiMatchesTotScore)
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:i=%d,j=%d,k=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f): q matches p\n",
			 p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,i,j,k,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV);
		  else
		    printf("%srefid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:i=%d,j=%d,k=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f): q completely overlapped by p ?\n",
			   MultiMatchesTotScore ? "" : "WARNING:", p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,i,j,k,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV);
		  printf("   pscoreL=%0.6f,pscoreM=%0.6f,pscoreR=%0.6f,qscoreL=%0.6f,qscoreM=%0.6f,qscoreR=%0.6f: wall time= %0.6f\n",pscoreL,pscoreM,pscoreR,qscoreL,qscoreM,qscoreR,wtime());
		  fflush(stdout);
		}
	      }	
	      if(MULTIMATCHES_DUPFIX && !MultiMatchesTotScore)/* assume pscoreL == qscoreL && pscoreR == qscoreR && pscoreM == qscoreM */
		goto LmatchingMaps;
	      if(MULTIMATCHES_DUPFIX && MultiMatchesTotScore){ /* assume MultiMatchesTotScore prefers pscoreL + pscoreR even though they are smaller than qscoreL + qscoreR */
		if(MULTIMATCH_TRIM){/* save the unique portions of q, if they are large enough */
		  if(MULTIMATCH_TRIMFIX && ((t1==0 && r1==0) || (t1==U-1 && r1==U-1))) { // single label pair overlap at left or right end of p == align->Malign[i] : save entire p & q
		    if(PVERB){
		      printf("\t Single label pair overlap between p & q : Keeping both p & q\n");
		      fflush(stdout);
		    }
		    continue;
		  }

		  /* NOTE Malign[i] is p */

		  if(r2 > 0 && U2 - r2 - 1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique right portion of Malign[k] is large enough to save */
		    SaveRightFragment(align, k, i+1, r2, U2, qscoreR, Y,Xrev,N,M,rmap,nanomap);
		      
		  if(t2 < U2 - 1 && t2 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique left portion of Malign[k] is large enough to save */
		    SaveLeftFragment(align, k, i+1, t2, qscoreL,Y,Xrev,N,M,rmap,nanomap);
		}

		if(PVERB/* HERE >=2 */){
		  printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:i=%d,j=%d,k=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f): removed q, keeping p\n",
			 p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,i,j,k,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV);
		  fflush(stdout);
		}

		/* keep p and delete q == Malign[k] from Malign[k..j-1] and repeat same value of k, since Malign[k] will have changed */
		if(DEBUG) assert(q == align->Malign[k] && q->allocated_size > 0);
		q->allfree();
		if(DEBUG) assert(q->allocated_size == 0);

		for(int t = k+1; t < j; t++)
		  align->Malign[t-1] = align->Malign[t];
		align->Malign[j-1] = q;
		j--;
		k--;
		if(DEBUG>=2) assert(k+1 >= lastNumMatchgroup);
	
		if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
		  for(int i = 0; i < align->multimax; i++)
		    for(int j = i+1; j < align->multimax; j++)
		      if(align->Malign[i] == align->Malign[j]){
			printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
			       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
			fflush(stdout);
			assert(align->Malign[i] != align->Malign[j]);
		      }
		}

		int origj = j;

		/* NOTE : in same case the q fragment Malign[i+1] may score higher than p == Malign[i] */
		if(MULTIMATCHES_ORDERFIX && i+1 < align->multicnt && align->Malign[i+1]->score > align->Malign[i]->score){/* swap Malign[i,i+1] :  When done restart outer i loop (goto Lrepeati) since i has changed */
                  if(PVERB){
                    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,Malign[i]->score= %0.6f(pairs=%d), Malign[i+1]->score= %0.6f(pairs=%d) (swapped)\n",
			   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i]->score,align->Malign[i]->numpairs,
			   align->Malign[i+1]->score,align->Malign[i+1]->numpairs);
                    fflush(stdout);
                  }

		  Calign *tmp = align->Malign[i+1];
		  align->Malign[i+1] = align->Malign[i];
		  align->Malign[i] = tmp;

		  origj++;// force jump to Lrepeati if resetcnt is too large

		  for(int t = i+1; t+1 < align->multicnt; t++){
		    if(align->Malign[t+1]->score <= align->Malign[t]->score)
		      break;
		    if(PVERB){
		      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,t=%d:Malign[t]->score= %0.6f(pairs=%d), Malign[t+1]->score= %0.6f(pairs=%d) (swapped)\n",
			     rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,t,align->Malign[t]->score,align->Malign[t]->numpairs,
			     align->Malign[t+1]->score,align->Malign[t+1]->numpairs);
		      fflush(stdout);
		    }
		    Calign *tmp = align->Malign[t+1];
		    align->Malign[t+1] = align->Malign[t];
		    align->Malign[t] = tmp;
		  }
		}

		/* In rare cases the highest scoring q fragment align->Malign[i] will have a higher score than align->Malign[j-1] :  If so repeatedly :
		   1. If i != j : Swap align->Malign[j-1] to Malign[i-1]
		   2. Resort position of Malign[i-1] in Malign[i-1 .. multicnt-1]
		   3. Reduce i to i-1
		   3. Reduce j to j-1


		   Since this may result in an infinite loop (due to rounding), limit doing this no more than 16 times.
		*/

		if(MULTIMATCHES_ORDERFIX && j > lastNumMatchgroup && align->Malign[i]->score > align->Malign[j-1]->score){// NEW175
		  if(DUPFIX_MAXCNT && ++resetcnt > DUPFIX_MAXCNT){
		    if(i+1 < align->multicnt)
		      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d:Malign[i]->score= %0.6f(pairs=%d),Malign[i+1]->score=%0.6f(pairs=%d), Malign[j-1]->score= %0.6f(pairs=%d)\n",
			     rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,  align->Malign[i]->score,align->Malign[i]->numpairs,
			     align->Malign[i+1]->score,align->Malign[i+1]->numpairs, align->Malign[j-1]->score,align->Malign[j-1]->numpairs);
		    else
		      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d:Malign[i]->score= %0.6f(pairs=%d), Malign[j-1]->score= %0.6f(pairs=%d)\n",
			     rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,
			     align->Malign[i]->score,align->Malign[i]->numpairs,align->Malign[j-1]->score,align->Malign[j-1]->numpairs);
		    printf("WARNING:Exceeded max number of times (%d) high scoring alignment was broken into fragments with high score\n",resetcnt);
		    fflush(stdout);
		  } else {
		    while(j > lastNumMatchgroup && align->Malign[i]->score > align->Malign[j-1]->score){
		      if(i > j){
			if(PVERB>=3){
			  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d:Malign[i]->score= %0.6f(pairs=%d), Malign[j-1]->score= %0.6f(pairs=%d):swapping\n",
				 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,align->Malign[i]->score,align->Malign[i]->numpairs,
				 align->Malign[j-1]->score,align->Malign[j-1]->numpairs);
			  fflush(stdout);
			}
			Calign *tmp = align->Malign[i-1];
			align->Malign[i-1] = align->Malign[j-1];
			align->Malign[j-1] = tmp;
		      }
		      int t = i;
		      for(; t < align->multicnt; t++){
			if(align->Malign[t-1]->score >= align->Malign[t]->score)
			  break;
			if(PVERB>=3){
			  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:t=%d:Malign[t-1]->score= %0.6f(pairs=%d), Malign[t]->score= %0.6f(pairs=%d):swapping\n",
				 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,t,align->Malign[t-1]->score,align->Malign[t-1]->numpairs,
				 align->Malign[t]->score,align->Malign[t]->numpairs);
			  fflush(stdout);
			}
			Calign *tmp = align->Malign[t-1];
			align->Malign[t-1] = align->Malign[t];
			align->Malign[t] = tmp;
		      }
		      if(PVERB){
			printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d,t=%d:Malign[i]->score= %0.6f, Malign[j-1]->score= %0.6f moved to Malign[t-1]\n",
			       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,t,align->Malign[i]->score,align->Malign[j-1]->score);
			fflush(stdout);
		      }

		      i--;
		      j--;
		    } // while(j > lastNumMatchgroup && align->Malign[i]->score > align->Malign[j-1]->score)
		  } // if(++resetcnt <= DUPFIX_MAXCNT)
		} // if(MULTIMATCHES_ORDERFIX && align->Malign[i]->score > align->Malign[j-1]->score)

		if(j <= lastNumMatchgroup){
		  if(PVERB>=3){
		    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:j=%d,i=%d:Moving Malign[i]->score= %0.6f(pairs=%d) to Malign[j] and incrementing j to %d, i to %d\n",
			   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,j,i,align->Malign[i]->score,align->Malign[i]->numpairs,j+1,i+1);
		    fflush(stdout);
		  }
		  if(i > j){// move Malign[i] to Malign[j]
		    Calign *tmp = align->Malign[j];
		    align->Malign[j] = align->Malign[i];
		    align->Malign[i] = tmp;
		  }
		  j++;
		  i++;
		  goto Lrepeati;
		}

		if(j < origj || k <= 0)
		  goto Lrepeati;

		continue;/* repeat k */
	      } // if(MULTIMATCHES_DUPFIX && MultiMatchesTotScore)
	    } /* PreferLp && PreferRp && pscoreM >= qscoreM */ else {/* q is NOT completely overlapped by p */

	      if(PreferLp && !PreferRp /* WAS pscoreL >= qscoreL && qscoreR >= pscoreR */ ){/* p left of q */
		/* NOTE : don't check if the entire overlap region matches, just pick whichever one is higher scoring (If MULTIMATCHES_DUPFIX the overlap region always matches exactly : prefer q) */

		int s1,s2;
		if((MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >= 3)) || qscoreM >= pscoreM){/* transition from p to q at t1,t2 */
		  s1 = t1;
		  s2 = t2;
		} else { /* transition from p to q at r1,r2 */
		  s1 = r1;
		  s2 = r2;
		}

		Calign *r = new Calign[1];
		r->numpairs = s1 + U2 - s2;
		r->expand_arrays(r->numpairs);
		if(DEBUG) assert(r->allocated_size >= r->numpairs);
		r->mapid1 = p->mapid1;
		r->mapid2 = p->mapid2;
		r->orientation = p->orientation;
		if(DEBUG && MultiMatchesRev) assert(p->rev == 0);
		r->rev = q->rev;
		r->scaleID = q->scaleID;
		r->repeat = 0;
		  
                r->stitch = (p->stitch & 1) | (q->stitch & 2);// NEW10
                r->noutliers = 0;
                r->maxoutlier = 0.0;
		r->maxoutlierLabels = 0;

		/* copy p (sites 0..s1) */
                int lastI= -1, lastK= -1, lastJ = -1;
		for(int t = 0; t <= s1; t++){
		  int I = r->sites1[t] = p->sites1[t];
		  int K = r->sitesK1[t] = p->sitesK1[t];
		  int J = r->sites2[t] = p->sites2[t];
		  FLOAT iscore = r->iscore[t] = p->iscore[t];
		  FLOAT outscore = r->outscore[t] = p->outscore[t];
		  if(t > 0 && outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    if(DEBUG) assert(deltaX > 0.0);		    
		    FLOAT delta = fabs(deltaY-deltaX);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		  }
		  if(PVERB && r->numpairs == 16512){
		    if(t > 0)
		      printf("\tt=%d:s1=%d,I=%d,K=%d,J=%d:r->iscore[t]=p->iscore[t]= %0.6f, outscore[t]= %0.6f, y= %0.4f, x= %0.4f\n",
			     t,s1,I,K,J,iscore,outscore,Yc(Y,I,K) - Yc(Y,lastI,lastK), Xrev[J] - Xrev[lastJ]);
		    else
		      printf("\tt=%d:s1=%d,I=%d,K=%d,J=%d:r->iscore[t]=p->iscore[t]= %0.6f, outscore[t]= %0.6f, Yc(I,K)= %0.4f, Xrev[J]= %0.4f\n",
			     t,s1,I,K,J,iscore,outscore,Yc(Y,I,K), Xrev[J]);
		    fflush(stdout);
		  }
		  lastI = I; lastK = K; lastJ = J;
		}

		/* copy q (sites s2+1 .. U2-1) */
		int u = s1 - s2;
		for(int t = s2+1; t < U2; t++){
		  int I = r->sites1[u + t] = q->sites1[t];
		  int K = r->sitesK1[u + t] = q->sitesK1[t];
		  int J = r->sites2[u + t] = q->sites2[t];
		  FLOAT iscore = r->iscore[u + t] = q->iscore[t];
		  FLOAT outscore = r->outscore[u + t] = q->outscore[t];
		  if(outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    if(DEBUG) assert(deltaX > 0.0);
		    FLOAT delta = fabs(deltaY-deltaX);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		  }
		  if(PVERB && r->numpairs == 16512){
		    printf("\tt+u=%d:t=%d,u=%d,U2=%d:I=%d,K=%d,J=%d:r->iscore[t+u]=q->iscore[t]= %0.6f, outscore[t]= %0.6f, y= %0.4f, x= %0.4f\n",
			   t+u,t,u,U2,I,K,J,iscore,outscore,Yc(Y,I,K) - Yc(Y,lastI,lastK), Xrev[J] - Xrev[lastJ]);
		    fflush(stdout);
		  }
		  lastI = I; lastK = K; lastJ = J;
		}
		r->iscore[u + U2] = q->iscore[U2];
		r->outscore[u + U2] = q->outscore[U2];
		if(PVERB && r->numpairs == 16512){
		  printf("\tt=%d:r->iscore[t]=q->iscore[U2=%d]= %0.6f, outscore[t]= %0.6f\n",
			 u+U2,U2,q->iscore[U2],q->outscore[U2]);
		  fflush(stdout);
		}

		r->Lend = p->Lend;
		r->Lij1 = p->Lij1;
		r->Lij2 = p->Lij2;
		r->Rend = q->Rend;
		r->Rij1 = q->Rij1;
		r->Rij2 = q->Rij2;

#if CALIGN_END==0
		r->LijY = p->LijY;
		r->LijX = p->LijX;
		r->RijY = q->RijY;
		r->RijX = q->RijX;
#endif		

		r->score = 0;
		for(int t = 0; t <= r->numpairs; t++)
		  r->score += r->iscore[t];

		if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
		if(DEBUG && !CutFlip) assert(p->Mrange <= M);
		if(DEBUG && CutFlip) assert(1 <= q->Nrange && q->Nrange <= N && 1 <= q->Mrange && q->Mrange <= M);
		if(DEBUG && !CutFlip) assert(q->Mrange <= M);
		r->Nrange = max(max(p->Nrange,q->Nrange),r->sites1[r->numpairs - 1] - r->sites1[0] + r->sitesK1[0] + 1);
		r->Mrange = max(max(p->Mrange,q->Mrange),r->sites2[r->numpairs - 1] - r->sites2[0] + 1);
		if(DEBUG && CutFlip) assert(1 <= r->Nrange && r->Nrange <= N && 1 <= r->Mrange && r->Mrange <= M);
		if(DEBUG && !CutFlip) assert(r->Mrange <= M);

		r->logPV = alignFP(r, Y, Xrev, N, M, r->orientation, r->mapid1, r->mapid2, r->score, (PVERB>=3) ? 1 : 0);
		r->logPV2 = max(r->logPV, max(p->logPV2,q->logPV2));
		if(DEBUG/* HERE HERE >=2 */) assert(r->logPV2 >= r->logPV);

		if(DEBUG/* HERE HERE >=2 */) assert(r->noutliers >= 0 && r->maxoutlier >= 0.0 && r->maxoutlierLabels >= 0 &&
						    (r->noutliers <= 0 || r->maxoutlier > 0.0 || r->maxoutlierLabels > 0));

		if(PVERB || (DEBUG && !MultiMatchesTotScore && ((DEBUG>=2 && r->logPV < max(p->logPV,q->logPV)) || r->score + 1e-5 < max(p->score,q->score)))){
		  #pragma omp critical
		  {
		    double rscoreL=0.0,rscoreM=0.0,rscoreR=0.0;
		    for(int t = 0; t <= t1; t++)
		      rscoreL += r->iscore[t];
		    
		    for(int t = t1+1; t <= s1; t++)
		      rscoreM += r->iscore[t];
		    int u = s1 - s2;
		    for(int t = s2+1; t <= r2; t++)
		      rscoreM += r->iscore[u + t];

		    for(int t = r2+1; t <= U2; t++)
		      rscoreR += r->iscore[u + t];

		    printf("WARNING: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:Merging p(I=%d..%d,K=%d..%d,J=%d..%d,pairs=%d,score=%0.6f,logPV=%0.2f) with q(I=%d..%d,K=%d..%d,J=%d..%d,pairs=%d,score=%0.6f,logPV=%0.2f):pairs=%d,score=%0.6f,logPV=%0.2f\n",
			   p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,
			   IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV,r->numpairs,r->score,r->logPV);
		    printf("     t1=%d/%d,t2=%d/%d,p->sites[t1]=%d,%d,%d; r1=%d,r2=%d,p->sites[r1]=%d,%d,%d,s1=%d,s2=%d,r->logPV=%0.2f(logPV2=%0.2f)\n",
			   t1,U,t2,U2,p->sites1[t1],p->sitesK1[t1],p->sites2[t1],r1,r2,p->sites1[r1],p->sitesK1[r1],p->sites2[r1],s1,s2,r->logPV,r->logPV2);
		    printf("     pscoreL=%0.6f,pscoreM=%0.6f,pscoreR=%0.6f,qscoreL=%0.6f,qscoreM=%0.6f,qscoreR=%0.6f:r->score=%0.6f(rscoreL=%0.6f,rscoreM=%0.6f,rscoreR=%0.6f)\n",
			   pscoreL,pscoreM,pscoreR,qscoreL,qscoreM,qscoreR,r->score,rscoreL,rscoreM,rscoreR);
		    fflush(stdout);
		    if(DEBUG && !MultiMatchesTotScore) assert(!(r->score + 1e-5 < max(p->score,q->score)));
		  }
		}
	        if(/* r->logPV <= LogPvThreshold2 || */ (!MultiMatchesTotScore ? (r->logPV < max(p->logPV,q->logPV)) : (r->logPV < min(LogPvThreshold3,LogPvThreshold2)))){/* remove r and keep p & q */
		  if(PVERB || (VERB>=2 && (!MultiMatchesTotScore ? (r->logPV < max(p->logPV,q->logPV)) : (r->logPV < min(LogPvThreshold3,LogPvThreshold2))))){
		    #pragma omp critical
		    {
		      printf("     Merged contig worse: keeping unmerged contigs:p->logPV=%0.2f,q->logPV=%0.2f,r->logPV=%0.2f(logPV2=%0.2f),LogPvThreshold2=%0.2f\n",
			     p->logPV,q->logPV,r->logPV,r->logPV2,LogPvThreshold2);
		      fflush(stdout);
		    }
		  }
		  delete [] r;
		  goto Lnooverlap;
		}

		if(r->score > align->score)
		  updateAlignment(align,r,rmap,nanomap,r->orientation);

		if(MULTIMATCHES_DUPFIX && MULTIMATCH_TRIM){/* save the unique portions of p & q, if they are large enough */
		  if(r1 > 0 && U - r1 - 1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique right portion of p == Malign[i] is large enough to save */
		    SaveRightFragment(align, i, i+1, r1, U, pscoreR, Y,Xrev,N,M,rmap,nanomap);

		  if(t2 < U2-1 && t2 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique left portion of q == Malign[k] is large enough to save */
		    SaveLeftFragment(align, k, i+1, t2, qscoreL,Y,Xrev,N,M,rmap,nanomap);
		}

		/* delete q == Malign[k] from Malign[k..j-1] (decreasing j by 1), recycle p at Malign[i] AND insert r into Malign[i .. aligncnt-1] */
		delete [] q;
		j--;
		for(int t = k; t < j; t++)
		  align->Malign[t] = align->Malign[t+1];
		align->Malign[j] = p;
		if(DEBUG) assert(p->allocated_size > 0);
		p->allfree();
		if(DEBUG) assert(p->allocated_size == 0);

		int t = i+1;
		for(; t < align->multicnt; t++){
		  if(r->score >= align->Malign[t]->score)// NEW
		    break;
		  align->Malign[t-1] = align->Malign[t];
		}
		if(DEBUG) assert(r->allocated_size > 0);
		align->Malign[t-1] = r;
		if(PVERB>=3){
		  printf("refid=%d(%lld),mapid=%d(%lld),or=%d: Moved r to Malign[%d] : j=%d,i=%d,multicnt=%d\n", refid,rmap->id,mapid,nanomap->id,orientation,t-1,j,i,align->multicnt);
		  fflush(stdout);		    
		}

		if(DEBUG>=2 && align->Malign){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
		  for(int i = 0; i < align->multimax; i++)
		    for(int j = i+1; j < align->multimax; j++)
		      if(align->Malign[j] && align->Malign[i] == align->Malign[j]){
			printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
			       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
			fflush(stdout);
			assert(align->Malign[i] != align->Malign[j]);
		      }
		}

		if(j <= lastNumMatchgroup){/* special case : restart outer loop */
		  if(PVERB){
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d: exiting inner loop with k=%d,j=%d,i=%d\n", refid,rmap->id,mapid,nanomap->id,orientation,k,j,i);
		    fflush(stdout);		    
		  }
		  if(DEBUG) assert(j <= i && j <= k);
		  break;/*  k >= j && j <= i will force copy of Malign[i] to Malign[j] and increment j by 1 and then continue with next i in outer loop */
		}

		if(DEBUG>=2){
		  Calign *p = align->Malign[i];
		  int U = p->numpairs;
		  double score = 0.0;
		  for(int t = 0; t <= U; t++)
		    score += p->iscore[t];
		  
		  if(PVERB || (DEBUG && fabs(score - p->score) > 1e-5 + 1e-6 * fabs(p->score))){
                    #pragma omp critical
		    {
		      printf("WARNING: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d: Malign[%d]->score= %0.7f, iscore[0..%d]= %0.7f (err= %0.7f)\n",
		        p->mapid1,rmap->id,p->mapid2,nanomap->id,p->orientation,p->rev,i,p->score,U,score,p->score - score);
		      double sum = 0.0;
		      for(int t = 0; t <= U; t++){
		        sum += p->iscore[t];
		        printf("\t t=%d/%d: iscore[t]= %0.7f, cum= %0.7f\n",t,U,p->iscore[t],sum);
		      }
		      fflush(stdout);
		      if(DEBUG >= 1+RELEASE) assert(fabs(score - p->score) < 1e-5 + 1e-6 * fabs(p->score));
		    }
		  }
		}

		/* In rare cases the highest scoring q fragment (or r) align->Malign[i] will have a higher score than align->Malign[j-1] :  If so repeatedly :
		   1. If i != j : Swap align->Malign[j-1] to Malign[i-1]
		   2. Resort position of Malign[i-1] in Malign[i-1 .. multicnt-1]
		   3. Reduce i to i-1
		   3. Reduce j to j-1

                   Since this may result in an infinite loop (due to rounding), limit doing this no more than 16 times.
		*/

		if(MULTIMATCHES_ORDERFIX && j > lastNumMatchgroup && align->Malign[i]->score > align->Malign[j-1]->score){// NEW175
		  if(DUPFIX_MAXCNT && ++resetcnt > DUPFIX_MAXCNT){
		    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d:Malign[i]->score= %0.6f, Malign[j-1]->score= %0.6f\n",
			   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,align->Malign[i]->score,align->Malign[j-1]->score);
		    printf("WARNING:Exceeded max number of times (%d) high scoring alignment was broken into fragments with high score\n",resetcnt);
		    fflush(stdout);
		  } else {
		    while(j > lastNumMatchgroup && align->Malign[i]->score > align->Malign[j-1]->score){
		      if(i > j){
			if(PVERB>=3){
			  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d:Malign[i]->score= %0.6f(pairs=%d), Malign[j-1]->score= %0.6f(pairs=%d):swapping\n",
				 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,align->Malign[i]->score,align->Malign[i]->numpairs,
				 align->Malign[j-1]->score,align->Malign[j-1]->numpairs);
			  fflush(stdout);
			}
			Calign *tmp = align->Malign[i-1];
			align->Malign[i-1] = align->Malign[j-1];
			align->Malign[j-1] = tmp;
		      }

		      int t = i;
		      for(; t < align->multicnt; t++){
			if(align->Malign[t-1]->score >= align->Malign[t]->score)
			  break;
			if(PVERB>=3){
			  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:t=%d:Malign[t-1]->score= %0.6f(pairs=%d), Malign[t]->score= %0.6f(pairs=%d):swapping\n",
				 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,t,align->Malign[t-1]->score,align->Malign[t-1]->numpairs,
				 align->Malign[t]->score,align->Malign[t]->numpairs);
			  fflush(stdout);
			}
			Calign *tmp = align->Malign[t-1];
			align->Malign[t-1] = align->Malign[t];
			align->Malign[t] = tmp;
		      }
		      if(PVERB){
			printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d,t=%d:Malign[i]->score= %0.6f, Malign[j-1]->score= %0.6f moved to Malign[t-1]\n",
			       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,t,align->Malign[i]->score,align->Malign[j-1]->score);
			fflush(stdout);
		      }
		      i--;
		      j--;
		    } // while(j > lastNumMatchgroup && align->Malign[i]->score > align->Malign[j-1]->score)
		  } // if(++resetcnt <= DUPFIX_MAXCNT)
		} // if(MULTIMATCHES_ORDERFIX && align->Malign[i]->score > align->Malign[j-1]->score)

		if(j <= lastNumMatchgroup){
		  if(PVERB>=3){
		    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:j=%d,i=%d:Moving Malign[i]->score= %0.6f(pairs=%d) to Malign[j] and incrementing j to %d, i to %d\n",
			   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,j,i,align->Malign[i]->score,align->Malign[i]->numpairs,j+1,i+1);
		    fflush(stdout);
		  }
		  if(i > j){// move Malign[i] to Malign[j]
		    Calign *tmp = align->Malign[j];
		    align->Malign[j] = align->Malign[i];
		    align->Malign[i] = tmp;
		  }
		  j++;
		  i++;
		}

		goto Lrepeati;// NOTE: below code is not enough, since it fails to update the other variables at the top of the i loop (eg U, I,K,J)

	      } else if(!PreferLp && PreferRp /* WAS qscoreL >= pscoreL && pscoreR >= qscoreR */){/* q left of p */
		/* NOTE : don't check if the entire overlap region matches, just pick whichever one is higher scoring (If MULTIMATCHES_DUPFIX the overlap region always matches exactly : prefer q) */
		int s1,s2;
		if(!(MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >=2)) && qscoreM < pscoreM){/* transition from q to p at t1,t2 */
		  s1 = t1;
		  s2 = t2;
		} else {/* transition from q to p at r1,r2 */
		  s1 = r1;
		  s2 = r2;
		}

		Calign *r = new Calign[1];
		r->numpairs = s2 + U - s1;
		r->expand_arrays(r->numpairs);
		if(DEBUG) assert(r->allocated_size >= r->numpairs);
		r->mapid1 = q->mapid1;
		r->mapid2 = q->mapid2;
		r->orientation = q->orientation;
		if(DEBUG && MultiMatchesRev) assert(q->rev == 0);
		r->rev = q->rev;
		r->scaleID = q->scaleID;
		r->repeat = 0;

                r->stitch = (q->stitch & 1) | (p->stitch & 2);// NEW10
                r->noutliers = 0;
                r->maxoutlier = 0.0;
		r->maxoutlierLabels = 0;

		/* copy q (sites 0 .. s2) */
		int lastI = -1, lastK = -1, lastJ = -1;
		for(int t = 0; t <= s2; t++){
		  int I = r->sites1[t] = q->sites1[t];
		  int K = r->sitesK1[t] = q->sitesK1[t];
		  int J = r->sites2[t] = q->sites2[t];
		  FLOAT iscore = r->iscore[t] = q->iscore[t];
		  FLOAT outscore = r->outscore[t] = q->outscore[t];
		  if(t > 0 && outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    if(DEBUG) assert(deltaX > 0.0);
		    FLOAT delta = fabs(deltaY-deltaX);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302		    
		  }
		  lastI = I; lastK = K; lastJ = J;
		}

		/* copy p (sites s1+1 .. U-1) */
		int u = s2 - s1;
		for(int t = s1+1; t < U; t++){
		  int I = r->sites1[u + t] = p->sites1[t];
		  int K = r->sitesK1[u + t] = p->sitesK1[t];
		  int J = r->sites2[u + t] = p->sites2[t];
		  FLOAT iscore = r->iscore[u + t] = p->iscore[t];
		  FLOAT outscore = r->outscore[u + t] = p->outscore[t];
		  if(outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    if(DEBUG) assert(deltaX > 0.0);
		    FLOAT delta = fabs(deltaY-deltaX);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302		    
		  }
		  lastI = I; lastK = K; lastJ = J;
		}
		r->iscore[u + U] = p->iscore[U];
		r->outscore[u + U] = p->outscore[U];

		r->Lend = q->Lend;
		r->Lij1 = q->Lij1;
		r->Lij2 = q->Lij2;

		r->Rend = p->Rend;
		r->Rij1 = p->Rij1;
		r->Rij2 = p->Rij2;
	      
#if CALIGN_END==0
		r->LijY = q->LijY;
		r->LijX = q->LijX;
		r->RijY = p->RijY;
		r->RijX = p->RijX;
#endif

		r->score = 0.0;
		for(int t = 0; t <= r->numpairs; t++)
		  r->score += r->iscore[t];

		if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
		if(DEBUG && !CutFlip) assert(p->Mrange <= M);
		if(DEBUG && CutFlip) assert(1 <= q->Nrange && q->Nrange <= N && 1 <= q->Mrange && q->Mrange <= M);
		if(DEBUG && !CutFlip) assert(q->Mrange <= M);
		r->Nrange = max(max(p->Nrange,q->Nrange),r->sites1[r->numpairs - 1] - r->sites1[0] + r->sitesK1[0] + 1);
		r->Mrange = max(max(p->Mrange,q->Mrange),r->sites2[r->numpairs - 1] - r->sites2[0] + 1);
		if(DEBUG && CutFlip) assert(1 <= r->Nrange && r->Nrange <= N && 1 <= r->Mrange && r->Mrange <= M);
		if(DEBUG && !CutFlip) assert(r->Mrange <= M);

		r->logPV = alignFP(r, Y, Xrev, N, M, r->orientation, r->mapid1, r->mapid2, r->score, (PVERB>=3) ? 1 : 0);
		r->logPV2 = max(r->logPV, max(p->logPV2,q->logPV2));
		if(DEBUG/* HERE HERE >=2 */) assert(r->logPV2 >= r->logPV);

		if(DEBUG/* HERE HERE >=2 */) assert(r->noutliers >= 0 && r->maxoutlier >= 0.0 && r->maxoutlierLabels >= 0 &&
						    (r->noutliers <= 0 || r->maxoutlier > 0.0 || r->maxoutlierLabels > 0));

		if(VERB >= 2-PVERB || (DEBUG && !MultiMatchesTotScore && ((DEBUG>=2 && r->logPV < max(p->logPV,q->logPV)) || r->score + 1e-5 < max(p->score,q->score)))){
		  double rscoreL=0.0,rscoreM=0.0,rscoreR=0.0;
		  for(int t = 0; t <= t2; t++)
		    rscoreL += r->iscore[t];

		  for(int t = t2+1; t <= s2; t++)
		    rscoreM += r->iscore[t];
		  int u = s2 - s1;
		  for(int t = s1+1; t <= r1; t++)
		    rscoreM += r->iscore[u + t];

		  for(int t = r1+1; t <= U; t++)
		    rscoreR += r->iscore[u + t];

		  #pragma omp critical
		  {
		    printf("WARNING:refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:Merging p(I=%d..%d,K=%d..%d,J=%d..%d,pairs=%d,score=%0.6f,logPV=%0.2f) with q(I=%d..%d,K=%d..%d,J=%d..%d,pairs=%d,score=%0.6f,logPV=%0.2f):pairs=%d,score=%0.6f,logPV=%0.2f\n",
			   p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV,r->numpairs,r->score,r->logPV);
		    printf("     t1=%d/%d,t2=%d/%d,p->sites[t1]=%d,%d,%d; r1=%d,r2=%d,p->sites[r1]=%d,%d,%d,s1=%d,s2=%d,r->logPV=%0.2f(logPV2=%0.2f)\n",
			   t1,U,t2,U2,p->sites1[t1],p->sitesK1[t1],p->sites2[t1],r1,r2,p->sites1[r1],p->sitesK1[r1],p->sites2[r1],s1,s2,r->logPV,r->logPV2);
		    printf("     pscoreL=%0.6f,pscoreM=%0.6f,pscoreR=%0.6f,qscoreL=%0.6f,qscoreM=%0.6f,qscoreR=%0.6f,r->score=%0.6f(rscoreL=%0.6f,rscoreM=%0.6f,rscoreR=%0.6f)\n",
			   pscoreL,pscoreM,pscoreR,qscoreL,qscoreM,qscoreR,r->score,rscoreL,rscoreM,rscoreR);
		    fflush(stdout);
		    if(DEBUG && !MultiMatchesTotScore) assert(!(r->score +1e-5 < max(p->score,q->score)));
		  }
		}
	        if(/* r->logPV <= LogPvThreshold2 || */ (!MultiMatchesTotScore ? (r->logPV < max(p->logPV,q->logPV)) : (r->logPV < min(LogPvThreshold3,LogPvThreshold2)))){/* remove r and keep p & q */
		  if(VERB >= 2-PVERB || (VERB>=2 && (!MultiMatchesTotScore ? (r->logPV < max(p->logPV,q->logPV)) : (r->logPV < min(LogPvThreshold3,LogPvThreshold2))))){
		    printf("     Merged contig worse: keeping unmerged contigs: p->logPV=%0.2f,q->logPV=%0.2f,r->logPV=%0.2f(logPV2=%0.2f),LogPvThreshold2=%0.2f\n",p->logPV,q->logPV,r->logPV,r->logPV2,LogPvThreshold2);
		    fflush(stdout);
		  }
		  delete [] r;
		  goto Lnooverlap;
		}
		if(r->score > align->score)/* update primary alignment from r */
		  updateAlignment(align,r,rmap,nanomap,r->orientation);

		if(MULTIMATCHES_DUPFIX && MULTIMATCH_TRIM){/* save the unique portions of p & q, if they are large enough */
		  // NOTE : the unique portion cannot be the entire alignment p, since PreferRp 

		  if(r2 > 0 && U2 - r2 - 1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique right portion of q == Malign[k] is large enough to save */
		    SaveRightFragment(align, k, i+1, r2, U2, qscoreR, Y,Xrev,N,M,rmap,nanomap);

		  if(t1 < U-1 && t1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique left portion of p == Malign[i] is large enough to save */
		    SaveLeftFragment(align, i, i+1, t1, pscoreL,Y,Xrev,N,M,rmap,nanomap);
		}

		/* delete q == Malign[k] from Malign[k..j-1] (decreasing j by 1), recycle p at Malign[i] AND insert r into Malign[i .. aligncnt-1] */
		delete [] q;
		j--;
		for(int t = k; t < j; t++)
		  align->Malign[t] = align->Malign[t+1];
		align->Malign[j] = p;
		if(DEBUG) assert(p->allocated_size > 0);
		p->allfree();
		if(DEBUG) assert(p->allocated_size == 0);

		int t = i+1;
		for(; t < align->multicnt; t++){
		  if(r->score >= align->Malign[t]->score)// NEW
		    break;
		  align->Malign[t-1] = align->Malign[t];
		}
		align->Malign[t-1] = r;
		if(PVERB>=3){
		  if(k < j)
		    printf("\t Removed Malign[k=%d] and Moved Malign[%d..%d] to Malign[%d..%d] then reduced j= %d to %d\n",k,k+1,j,k,j-1,j+1,j);
		  else
		    printf("\t Removed Malign[k=%d] and then reduced j= %d to %d\n",k,j+1,j);
		  if(t < align->multicnt)
		    printf("\t Inserted r into Malign[i=%d .. %d] at Malign[%d](r->score=%0.6f, pairs=%d), Malign[%d]:score=%0.6f,pairs=%d\n",
			   i,align->multicnt-1,t-1,r->score,r->numpairs,t,align->Malign[t]->score,align->Malign[t]->numpairs);
		  else
		    printf("\t Inserted r into Malign[i=%d .. %d] at Malign[%d](r->score=%0.6f, pairs=%d)\n", i,align->multicnt-1,t-1,r->score,r->numpairs);
		}

		if(DEBUG>=2 && align->Malign){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
		  for(int i = 0; i < align->multimax; i++)
		    for(int j = i+1; j < align->multimax; j++)
		      if(align->Malign[j] && align->Malign[i] == align->Malign[j]){
			printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
			       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
			fflush(stdout);
			assert(align->Malign[i] != align->Malign[j]);
		      }
		}

		if(j <= lastNumMatchgroup){/* special case : restart outer loop */
		  if(PVERB){
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d: exiting inner loop with k=%d,j=%d,i=%d\n", refid,rmap->id,mapid,nanomap->id,orientation,k,j,i);
		    fflush(stdout);		    
		  }
		  if(DEBUG) assert(j <= i && j <= k);
		  break;/*  k >= j && j <= i will force copy of Malign[i] to Malign[j] and increment j by 1 and then continue with next i in outer loop */
		}

		/* In rare cases the highest scoring q fragment (or r) align->Malign[i] will have a higher score than align->Malign[j-1] :  If so repeatedly :
		   1. If i != j : Swap align->Malign[j-1] to Malign[i-1]
		   2. Resort position of Malign[i-1] in Malign[i-1 .. multicnt-1]
		   3. Reduce i to i-1
		   3. Reduce j to j-1


                   Since this may result in an infinite loop (due to rounding), limit doing this no more than 16 times.
		*/
		if(MULTIMATCHES_ORDERFIX && j > lastNumMatchgroup && align->Malign[i]->score > align->Malign[j-1]->score){// NEW175
		  if(DUPFIX_MAXCNT && ++resetcnt > DUPFIX_MAXCNT){
		    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d:Malign[i]->score= %0.6f, Malign[j-1]->score= %0.6f\n",
			   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,align->Malign[i]->score,align->Malign[j-1]->score);
		    printf("WARNING:Exceeded max number of times (%d) high scoring alignment was broken into fragments with high score\n",resetcnt);
		    fflush(stdout);
		  } else {
		    while(j > lastNumMatchgroup && align->Malign[i]->score > align->Malign[j-1]->score){
		      if(i > j){
			if(PVERB>=3){
			  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d:Malign[i]->score= %0.6f(pairs=%d), Malign[j-1]->score= %0.6f(pairs=%d) to Malign[i-1]\n",
				 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,align->Malign[i]->score,align->Malign[i]->numpairs,
				 align->Malign[j-1]->score,align->Malign[j-1]->numpairs);
			  fflush(stdout);
			}
			Calign *tmp = align->Malign[i-1];
			align->Malign[i-1] = align->Malign[j-1];
			align->Malign[j-1] = tmp;
		      }
		      int t = i;
		      for(; t < align->multicnt; t++){
			if(align->Malign[t-1]->score >= align->Malign[t]->score)
			  break;
			if(PVERB>=3){
			  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:t=%d:Malign[t-1]->score= %0.6f(pairs=%d), Malign[t]->score= %0.6f(pairs=%d):swapping\n",
				 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,t,align->Malign[t-1]->score,align->Malign[t-1]->numpairs,
				 align->Malign[t]->score,align->Malign[t]->numpairs);
			  fflush(stdout);
			}
			Calign *tmp = align->Malign[t-1];
			align->Malign[t-1] = align->Malign[t];
			align->Malign[t] = tmp;
		      }
		      if(PVERB){
			printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,j=%d,t=%d:Malign[i]->score= %0.6f, Malign[j-1]->score= %0.6f moved to Malign[t-1]\n",
			       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,i,j,t,align->Malign[i]->score,align->Malign[j-1]->score);
			fflush(stdout);
		      }
		      i--;
		      j--;
		    } // while(j > lastNumMatchgroup && align->Malign[i]->score > align->Malign[j-1]->score)
		  } // if(++resetcnt <= DUPFIX_MAXCNT)
		} // if(MULTIMATCHES_ORDERFIX && align->Malign[i]->score > align->Malign[j-1]->score)

		if(j <= lastNumMatchgroup){
		  if(PVERB>=3){
		    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:j=%d,i=%d:Moving Malign[i]->score= %0.6f(pairs=%d) to Malign[j] and incrementing j to %d, i to %d\n",
			   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->scaleID,j,i,align->Malign[i]->score,align->Malign[i]->numpairs,j+1,i+1);
		    fflush(stdout);
		  }
		  if(i > j){// move Malign[i] to Malign[j]
		    Calign *tmp = align->Malign[j];
		    align->Malign[j] = align->Malign[i];
		    align->Malign[i] = tmp;
		  }
		  j++;
		  i++;
		}

		goto Lrepeati;// NOTE: below code is not enough, since it fails to update the other variables at the top of the i loop (eg U, I,K,J)

		// update p to Malign[i] and continue k loop at k == lastNumMatchgroup (since Malign[i] has changed)
		/*		p = align->Malign[i];
		k = lastNumMatchgroup - 1;
		continue;*/

	      }/* q left of p */
	      else if(PreferLp && PreferRp/* WAS pscoreL >= qscoreL && pscoreR >= qscoreR */ ){
		if(DEBUG) assert(pscoreM < qscoreM);
		if(DEBUG) assert(!(MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >= 3)));/* since then this case was handled previously */

		/* combine ends from p with middle portion of q */
		Calign *r = new Calign[1];
		r->numpairs = t1 + (U-r1) + (r2-t2);
		r->expand_arrays(r->numpairs);
		if(DEBUG) assert(r->allocated_size >= r->numpairs);
		r->mapid1 = p->mapid1;
		r->mapid2 = p->mapid2;
		r->orientation = p->orientation;
		if(DEBUG && MultiMatchesRev) assert(p->rev == 0);
		r->rev = p->rev;
		r->scaleID = p->scaleID;
		r->repeat = 0;

                r->stitch = p->stitch;// NEW10
                r->noutliers = 0;
                r->maxoutlier = 0.0;
		r->maxoutlierLabels = 0;

		/* copy p (sites 0..t1) */
		int lastI, lastK, lastJ;
		for(int t = 0; t <= t1; t++){
		  int I = r->sites1[t] = p->sites1[t];
		  int K = r->sitesK1[t] = p->sitesK1[t];
		  int J = r->sites2[t] = p->sites2[t];
		  FLOAT iscore = r->iscore[t] = p->iscore[t];
		  FLOAT outscore = r->outscore[t] = p->outscore[t];
		  if(t > 0 && outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    if(DEBUG) assert(deltaX > 0.0);
		    FLOAT delta = fabs(deltaY-deltaX);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		  }
		  lastI = I; lastK = K; lastJ = J;
		}

		/* copy q (sites t2+1 .. r2) */
		int u = t1 - t2;
		for(int t = t2+1; t <= r2; t++){
		  int I = r->sites1[u + t] = q->sites1[t];
		  int K = r->sitesK1[u + t] = q->sitesK1[t];
		  int J = r->sites2[u + t] = q->sites2[t];
		  FLOAT iscore = r->iscore[u + t] = q->iscore[t];
		  FLOAT outscore = r->outscore[u + t] = q->outscore[t];
		  if(outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    if(DEBUG) assert(deltaX > 0.0);
		    FLOAT delta = fabs(deltaY-deltaX);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		  }
		  lastI = I; lastK = K; lastJ = J;
		}

		/* copy p (sites r1+1 .. U-1) */
		u = (r2-t2) - (r1 - t1);
		for(int t = r1+1; t < U; t++){
		  int I = r->sites1[t+u] = p->sites1[t];
		  int K = r->sitesK1[t+u] = p->sitesK1[t];
		  int J = r->sites2[t+u] = p->sites2[t];
		  FLOAT iscore = r->iscore[t+u] = p->iscore[t];
		  FLOAT outscore = r->outscore[t+u] = p->outscore[t];
		  if(outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    FLOAT delta = fabs(deltaY-deltaX);
		    if(DEBUG) assert(deltaX > 0.0);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		  }
		  lastI = I; lastK = K; lastJ = J;
		}
		r->iscore[U+u] = p->iscore[U];
		r->outscore[U+u] = p->outscore[U];

		r->Lend = p->Lend;
		r->Lij1 = p->Lij1;
		r->Lij2 = p->Lij2;
		r->Rend = p->Rend;
		r->Rij1 = p->Rij1;
		r->Rij2 = p->Rij2;
	      
#if CALIGN_END==0
		r->LijY = p->LijY;
		r->LijX = p->LijX;
		r->RijY = p->RijY;
		r->RijX = p->RijX;
#endif

		r->score = 0.0;
		for(int t = 0; t <= r->numpairs; t++)
		  r->score += r->iscore[t];

		if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
		if(DEBUG && !CutFlip) assert(p->Nrange <= N && p->Mrange <= M);
		if(DEBUG && CutFlip) assert(1 <= q->Nrange && q->Nrange <= N && 1 <= q->Mrange && q->Mrange <= M);
		if(DEBUG && !CutFlip) assert(q->Nrange <= N && q->Mrange <= M);
		r->Nrange = max(max(p->Nrange,q->Nrange),r->sites1[r->numpairs - 1] - r->sites1[0] + r->sitesK1[0] + 1);
		r->Mrange = max(max(p->Mrange,q->Mrange),r->sites2[r->numpairs - 1] - r->sites2[0] + 1);
		if(DEBUG && CutFlip) assert(1 <= r->Nrange && r->Nrange <= N && 1 <= r->Mrange && r->Mrange <= M);
		if(DEBUG && !CutFlip) assert(r->Nrange <= N && r->Mrange <= M);

		r->logPV = alignFP(r, Y, Xrev, N, M, r->orientation, r->mapid1, r->mapid2, r->score, 0);
		r->logPV2 = max(r->logPV, max(p->logPV2,q->logPV2));
		if(DEBUG/* HERE HERE >=2 */) assert(r->logPV2 >= r->logPV);

		if(DEBUG/* HERE HERE >=2 */) assert(r->noutliers >= 0 && r->maxoutlier >= 0.0 && r->maxoutlierLabels >= 0 &&
						    (r->noutliers <= 0 || r->maxoutlier > 0.0 || r->maxoutlierLabels > 0));

		if(VERB >= 2-PVERB || (DEBUG && !MultiMatchesTotScore && ((DEBUG>=2 && r->logPV < max(p->logPV,q->logPV)) || r->score + 1e-5 < max(p->score,q->score) /* || r->numpairs < max(p->numpairs,q->numpairs)*/))){
		  #pragma omp critical
		  {
		    printf("WARNING:refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:Merging ends of p(I=%d..%d,K=%d..%d,J=%d..%d,pairs=%d,score=%0.6f,logPV=%0.2f) with middle of q(I=%d..%d,K=%d..%d,J=%d..%d,pairs=%d,score=%0.6f,logPV=%0.2f):pairs=%d,score=%0.6f,logPV=%0.2f\n",
			   p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV,r->numpairs,r->score,r->logPV);
		    printf("     t1=%d/%d,t2=%d/%d,p->sites[t1]=%d,%d,%d; r1=%d,r2=%d,p->sites[r1]=%d,%d,%d,r->logPV=%0.2f(logPV2=%0.2f)\n",
			   t1,U,t2,U2,p->sites1[t1],p->sitesK1[t1],p->sites2[t1],r1,r2,p->sites1[r1],p->sitesK1[r1],p->sites2[r1],r->logPV,r->logPV2);
		    printf("     pscoreL=%0.6f,pscoreM=%0.6f,pscoreR=%0.6f,qscoreL=%0.6f,qscoreM=%0.6f,qscoreR=%0.6f\n",pscoreL,pscoreM,pscoreR,qscoreL,qscoreM,qscoreR);
		    fflush(stdout);
		    if(DEBUG && !MultiMatchesTotScore) assert(!(r->score + 1e-5 < max(p->score,q->score)));
		  }
		}

	        if(/* r->logPV <= LogPvThreshold2 || */ (!MultiMatchesTotScore ? (r->logPV < max(p->logPV,q->logPV)) : (r->logPV < min(LogPvThreshold3,LogPvThreshold2)))){/* remove r and keep p & q */
		  if(VERB >= 2-PVERB || (VERB>=2 && (!MultiMatchesTotScore ? (r->logPV < max(p->logPV,q->logPV)) : (r->logPV < min(LogPvThreshold3,LogPvThreshold2))))){
		    #pragma omp critical
		    {
		      printf("     Merged contig worse: keeping unmerged contigs: p->logPV=%0.2f,q->logPV=%0.2f,r->logPV=%0.2f(logPV2=%0.2f),LogPvThreshold2=%0.2f\n",
			     p->logPV,q->logPV,r->logPV,r->logPV2,LogPvThreshold2);
		      fflush(stdout);
		    }
		  }
		  delete [] r;
		  goto Lnooverlap;
		}

		if(MULTIMATCHES_DUPFIX && MULTIMATCH_TRIM){/* NEW20 : save the unique portions of q, if they are large enough */
		  if(MULTIMATCH_TRIMFIX && ((t1==0 && r1==0) || (t1==U-1 && r1==U-1))) { // single label pair overlap at left or right end of p == align->Malign[i] : save entire p & q
		    if(PVERB){
		      printf("\t Single lable pair overlap between p & q : Keeping both p & q\n");
		      fflush(stdout);
		    }
		    continue;
		  }

		  if(r2 > 0 && U2 - r2 - 1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique right portion of Malign[k] is large enough to save */
		    SaveRightFragment(align, k, i+1, r2, U2, qscoreR, Y,Xrev,N,M,rmap,nanomap);
		      
		  if(t2 < U2 - 1 && t2 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique left portion of Malign[k] is large enough to save */
		    SaveLeftFragment(align, k, i+1, t2, qscoreL,Y,Xrev,N,M,rmap,nanomap);
		}

		if(r->score > align->score)/* update primary alignment from r */
		  updateAlignment(align,r,rmap,nanomap,r->orientation);

		/* NEW20 : replace p == Malign[i] with r and delete q == Malign[k] from Malign[k..j-1] and repeat same value of k, since Malign[k] will have changed */
		if(DEBUG>=2) assert(p == align->Malign[i]);
		delete [] p;
		p = align->Malign[i] = r;

		if(DEBUG) assert(q == align->Malign[k] && q->allocated_size > 0);
		q->allfree();
		if(DEBUG) assert(q->allocated_size == 0);

		for(int t = k+1; t < j; t++)
		  align->Malign[t-1] = align->Malign[t];
		align->Malign[j-1] = q;
		j--;
		k--;
		if(DEBUG>=2) assert(k+1 >= lastNumMatchgroup);

		/*
		delete [] q;
		q = align->Malign[k] = r;
		*/

		if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
		  for(int i = 0; i < align->multimax; i++)
		    for(int j = i+1; j < align->multimax; j++)
		      if(align->Malign[j] && align->Malign[i] == align->Malign[j]){
			printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
			       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
			fflush(stdout);
			assert(align->Malign[i] != align->Malign[j]);
		      }
		}

		continue;/* repeat k */

		//		break;/* p == align->Malign[i] will be filtered out since k < j */

	      } else {/* !PreferLp && !PreferRp */
		// WAS20		if(DEBUG) assert(pscoreL <= qscoreL && pscoreR <= qscoreR);
		if(DEBUG) assert(!(MULTIMATCHES_DUPFIX && (NumScaleFactor <= 1 || hashScaleDelta >= 3)));/* since all these cases should have been handled previously */
		if(DEBUG && !(pscoreM > qscoreM)){
		  #pragma omp critical
		  {
		    printf("refid=%d(%lld),mapid=%d(%lld),or=%d:i=%d,j=%d,k=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f):\n",
			 p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,i,j,k,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV);
		    printf("   t1=%d(IKJ=%d,%d,%d),r1=%d(IKJ=%d,%d,%d),U1=%d; t2=%d(IKJ=%d,%d,%d),r2=%d(IKJ=%d,%d,%d),U2=%d\n",
			   t1,p->sites1[t1],p->sitesK1[t1],p->sites2[t1],r1,p->sites1[r1],p->sitesK1[r1],p->sites2[r1],U,
			   t2,q->sites1[t2],q->sitesK1[t2],q->sites2[t2],r2,q->sites1[r2],q->sitesK1[r2],q->sites2[r2],U2);
		    printf("   pscoreL=%0.8f,pscoreM=%0.8f,pscoreR=%0.8f,qscoreL=%0.8f,qscoreM=%0.8f,qscoreR=%0.8f\n",
			   pscoreL,pscoreM,pscoreR,qscoreL,qscoreM,qscoreR);
		    fflush(stdout);
		    
		    assert(pscoreM > qscoreM);
		  }
		}

		/* combine ends from q with middle portion of p */
		Calign *r = new Calign[1];
		r->numpairs = t2 + (U2-r2) + (r1-t1);
		r->expand_arrays(r->numpairs);
		if(DEBUG) assert(r->allocated_size >= r->numpairs);
		r->mapid1 = p->mapid1;
		r->mapid2 = p->mapid2;
		r->orientation = p->orientation;
		if(DEBUG && MultiMatchesRev) assert(p->rev == 0);
		r->rev = p->rev;
		r->scaleID = p->scaleID;
		r->repeat = 0;

                r->stitch = q->stitch;// NEW10
                r->noutliers = 0;
                r->maxoutlier = 0.0;
		r->maxoutlierLabels = 0;

		/* copy q (sites 0..t2) */
		int lastI, lastK, lastJ;
		for(int t = 0; t <= t2; t++){
		  int I = r->sites1[t] = q->sites1[t];
		  int K = r->sitesK1[t] = q->sitesK1[t];
		  int J = r->sites2[t] = q->sites2[t];
		  FLOAT iscore = r->iscore[t] = q->iscore[t];
		  FLOAT outscore = r->outscore[t] = q->outscore[t];
		  if(t > 0 && outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    if(DEBUG) assert(deltaX > 0.0);
		    FLOAT delta = fabs(deltaY-deltaX);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		  }
		  lastI = I; lastK = K; lastJ = J;
		}

		/* copy p (sites t1+1 .. r1) */
		int u = t2 - t1;
		for(int t = t1+1; t <= r1; t++){
		  int I = r->sites1[u + t] = p->sites1[t];
		  int K = r->sitesK1[u + t] = p->sitesK1[t];
		  int J = r->sites2[u + t] = p->sites2[t];
		  FLOAT iscore = r->iscore[u + t] = p->iscore[t];
		  FLOAT outscore = r->outscore[u + t] = p->outscore[t];
		  if(outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    if(DEBUG) assert(deltaX > 0.0);
		    FLOAT delta = fabs(deltaY-deltaX);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		  }
		  lastI = I; lastK = K; lastJ = J;
		}

		/* copy q (sites r2+1 .. U2-1) */
		u = (r1-t1) - (r2 - t2);
		for(int t = r2+1; t < U2; t++){
		  int I = r->sites1[t+u] = q->sites1[t];// WAS20 p->sites1[t];
		  int K = r->sitesK1[t+u] = q->sitesK1[t];// WAS20 p->sitesK1[t];
		  int J = r->sites2[t+u] = q->sites2[t];// WAS20 p->sites2[t];
		  FLOAT iscore = r->iscore[t+u] = q->iscore[t];// WAS20 p->iscore[t];
		  FLOAT outscore = r->outscore[t+u] = q->outscore[t];// WAS20 p->outscore[t];
		  if(outscore + (FLOAT)0.01 < iscore){// NEW10
		    r->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = Xrev[J] - Xrev[lastJ];
		    if(DEBUG) assert(deltaX > 0.0);
		    FLOAT delta = fabs(deltaY-deltaX);
		    r->maxoutlier = max(delta, r->maxoutlier);
		    r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		  }
		  lastI = I; lastK = K; lastJ = J;
		}
		r->iscore[U2 + u /* WAS20 U+u */] = q->iscore[U2];// WAS20 p->iscore[U];
		r->outscore[U2 + u /* WAS20 U+u */] = q->outscore[U2];// WAS20 p->outscore[U];

		r->Lend = q->Lend;
		r->Lij1 = q->Lij1;
		r->Lij2 = q->Lij2;
		r->Rend = q->Rend;
		r->Rij1 = q->Rij1;
		r->Rij2 = q->Rij2;

#if CALIGN_END==0
		r->LijY = q->LijY;
		r->LijX = q->LijX;
		r->RijY = q->RijY;
		r->RijX = q->RijX;
#endif

		r->score = 0.0;
		for(int t = 0; t <= r->numpairs; t++)
		  r->score += r->iscore[t];

		if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
		if(DEBUG && !CutFlip) assert(p->Nrange <= N && p->Mrange <= M);
		if(DEBUG && CutFlip) assert(1 <= q->Nrange && q->Nrange <= N && 1 <= q->Mrange && q->Mrange <= M);
		if(DEBUG && !CutFlip) assert(q->Nrange <= N && q->Mrange <= M);
		r->Nrange = max(max(p->Nrange,q->Nrange),r->sites1[r->numpairs - 1] - r->sites1[0] + r->sitesK1[0] + 1);
		r->Mrange = max(max(p->Mrange,q->Mrange),r->sites2[r->numpairs - 1] - r->sites2[0] + 1);
		if(DEBUG && CutFlip) assert(1 <= r->Nrange && r->Nrange <= N && 1 <= r->Mrange && r->Mrange <= M);
		if(DEBUG && !CutFlip) assert(r->Nrange <= N && r->Mrange <= M);

		r->logPV = alignFP(r, Y, Xrev, N, M, r->orientation, r->mapid1, r->mapid2, r->score, 0);
		r->logPV2 = max(r->logPV, max(p->logPV2,q->logPV2));
		if(DEBUG/* HERE HERE >=2 */) assert(r->logPV2 >= r->logPV);
		
		if(DEBUG/* HERE HERE >=2 */) assert(r->noutliers >= 0 && r->maxoutlier >= 0.0 && r->maxoutlierLabels >= 0 &&
						    (r->noutliers <= 0 || r->maxoutlier > 0.0 || r->maxoutlierLabels > 0));

		if(PVERB >= 3 || (DEBUG && ((DEBUG>=2 && r->logPV < max(p->logPV,q->logPV)) || r->score + 1e-5 < max(p->score,q->score) /* || r->numpairs < max(p->numpairs,q->numpairs)*/))){
		  #pragma omp critical
		  {
		    printf("WARNING:refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:Merging middle of p(I=%d..%d,K=%d..%d,J=%d..%d,pairs=%d,score=%0.6f,logPV=%0.2f) with ends of q(I=%d..%d,K=%d..%d,J=%d..%d,pairs=%d,score=%0.6f,logPV=%0.2f):pairs=%d,score=%0.6f,logPV=%0.2f\n",
			   p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV,r->numpairs,r->score,r->logPV);
		    printf("     t1=%d/%d,t2=%d/%d,p->sites[t1]=%d,%d,%d; r1=%d,r2=%d,p->sites[r1]=%d,%d,%d,r->logPV=%0.2f(logPV2=%0.2f)\n",
			   t1,U,t2,U2,p->sites1[t1],p->sitesK1[t1],p->sites2[t1],r1,r2,p->sites1[r1],p->sitesK1[r1],p->sites2[r1],r->logPV,r->logPV2);
		    printf("     pscoreL=%0.6f,pscoreM=%0.6f,pscoreR=%0.6f,qscoreL=%0.6f,qscoreM=%0.6f,qscoreR=%0.6f\n",pscoreL,pscoreM,pscoreR,qscoreL,qscoreM,qscoreR);
		    
		    printf("p->iscore:U=%d:\n",U);
		    double cum = 0.0;
		    for(int t = 0; t <= U; t++){
		      cum += p->iscore[t];
		      printf("p->iscore[%d/%d]= %0.6f, cum= %0.6f\n",t,U,p->iscore[t],cum);
		    }

		    printf("q->iscore:U2=%d:\n",U2);
		    cum = 0.0;
		    for(int t = 0; t <= U2; t++){
		      cum += q->iscore[t];
		      printf("q->iscore[%d/%d]= %0.6f, cum= %0.6f\n",t,U2,q->iscore[t],cum);
		    }

		    printf("r->iscore:pairs=%d:\n",r->numpairs);
		    cum = 0.0;
		    for(int t = 0; t <= r->numpairs; t++){
		      cum += r->iscore[t];
		      printf("r->iscore[%d/%d]= %0.6f, cum= %0.6f\n",t,r->numpairs,r->iscore[t],cum);
		    }

		    fflush(stdout);
		    if(DEBUG)assert(!(r->score + 1e-5 < max(p->score,q->score)));
		  }
		}

	        if(/* r->logPV <= LogPvThreshold2 || */ (!MultiMatchesTotScore ? (r->logPV < max(p->logPV,q->logPV)) : (r->logPV < min(LogPvThreshold3,LogPvThreshold2)))){/* remove r and keep p & q */
		  if(VERB >= 2-PVERB || (VERB>=2 && (!MultiMatchesTotScore ? (r->logPV < max(p->logPV,q->logPV)) : (r->logPV < min(LogPvThreshold3,LogPvThreshold2))))){
		    #pragma omp critical
		    {
		      printf("     Merged contig worse: keeping unmerged contigs: p->logPV=%0.2f,q->logPV=%0.2f,r->logPV=%0.2f(logPV2=%0.2f),LogPvThreshold2=%0.2f\n",p->logPV,q->logPV,r->logPV,r->logPV2,LogPvThreshold2);
		      fflush(stdout);
		    }
		  }
		  delete [] r;
		  goto Lnooverlap;
		}

		if(MULTIMATCHES_DUPFIX && MULTIMATCH_TRIM){/* save the unique portions of p, if they are large enough */
		  if(MULTIMATCH_TRIMFIX && t1==r1 /* WAS (t1==0 && r1==0) || (t1==U-1 && r1==U-1))*/) {// single label pair overlap for p == align->Malign[i] : save both p & q
		    if(PVERB){
		      printf("\t Single lable pair overlap between p & q : Keeping both p & q\n");
		      fflush(stdout);
		    }
		    continue;/* NOTE : This is needed to avoid infinite loop, since otherwise :
				1. If single label pair overlap is at left or right end of p, the "unique" right or left portion saved below is the entire align->Malign[i] !
				2. If single label pair overlap is in middle of p, it will get split into 2 pieces that subsequently get merged together again ! */
		  }
		  
		  if(r1 > 0 && U - r1 - 1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique right portion of Malign[i] is large enough to save */
		    SaveRightFragment(align, i, i+1, r1, U, pscoreR, Y,Xrev,N,M,rmap,nanomap);
		      
		  if(t1 < U - 1 && t1 >= (RefSplitStitch>=2 ? 1 : AlignedSiteThreshold2))/* unique left portion of Malign[i] is large enough to save */
		    SaveLeftFragment(align, i, i+1, t1, pscoreL,Y,Xrev,N,M,rmap,nanomap);
		} // MULTIMATCH_TRIM

		if(r->score > align->score)/* update primary alignment from r */
		  updateAlignment(align,r,rmap,nanomap,r->orientation);
		
		delete [] q;
		while(k > lastNumMatchgroup /* WAS390 0 */ && r->score > align->Malign[k-1]->score){// NEW20 : r->score may need to be re-sorted in align->Malign[0..k] 
		  align->Malign[k] = align->Malign[k-1];
		  k--;
		}
		q = align->Malign[k] = r;

		if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
		  for(int i = 0; i < align->multimax; i++)
		    for(int j = i+1; j < align->multimax; j++)
		      if(align->Malign[j] && align->Malign[i] == align->Malign[j]){
			printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
			       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
			fflush(stdout);
			assert(align->Malign[i] != align->Malign[j]);
		      }
		}

		break;/* p == align->Malign[i] will be filtered out */
	      }

	      /* NOTE : this case can happen if (eg) the two alignments have ends that cross each other due to differents sets of indels, or have alternate indels */
	      if(VERB >= 2-PVERB || DEBUG/* HERE >=2 */){
		printf("WARNING:refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f): Crossed Overlap!\n",
		       p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV);
		fflush(stdout);
	      }
	    }/* q is NOT completely overlapped by p */
          } else {/* no match found in overlap region */
            if(VERB >= 2-PVERB){
               printf("refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:p(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f), q(I=%d..%d(K=%d..%d),J=%d..%d,pairs=%d,score=%0.6f,LogPV=%0.2f): t1=%d,t2=%d:Overlap without any matches!\n",
		      p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->rev,IL,I,KL,K,JL,J,p->numpairs,p->score,p->logPV,IL2,I2,KL2,K2,JL2,J2,q->numpairs,q->score,q->logPV, t1,t2);
	       fflush(stdout);
            } 
          }
	}/* alignments overlap in reference and query */

 Lnooverlap: /* includes unhandled overlapped alignments */

        if(MULTIMATCHES_FIX){
  	  if(J >= J2 + MultiMatches && JL2 + MultiMatches <= JL)
	    continue;/* at least MultiMatches distinct labels in Query */
	  if(JL + MultiMatches <= JL2 && J2 >= J + MultiMatches)
	    continue;/* at least MultiMatches distinct labels in Query */
	  if(I >= I2 + MultiMatches && IL2-KL2 + MultiMatches <= IL-KL)
	    continue;/* at least MultiMatches distinct labels in Reference */
	  if(IL-KL + MultiMatches <= IL2-KL2 && I2 >= I + MultiMatches)
	    continue;/* at least MultiMatches distinct labels in Reference */
	} else {
  	  if(J >= (max(J2,JL)) + MultiMatches && JL2 + MultiMatches <= (min(J2,JL)))
	    continue;/* at least MultiMatches distinct labels in Query */
	  if(JL + MultiMatches <= (min(J,JL2)) && J2 >= (max(J,JL2)) + MultiMatches)
	    continue;/* at least MultiMatches distinct labels in Query */
	  if(I >= (max(I2,IL-KL)) + MultiMatches && IL2-KL2 + MultiMatches <= (min(I2,IL-KL)))
	    continue;/* at least MultiMatches distinct labels in Reference */
	  if(IL-KL + MultiMatches <= (min(I,IL2-KL2)) && I2 >= (max(I,IL2-KL2)) + MultiMatches)
	    continue;/* at least MultiMatches distinct labels in Reference */
	}

	if(MultiMatchesDelta > 0.0){/* check if offset is different at both alignment ends by at least this many kb */
	  double Delta = MultiMatchesDelta;

	  /* locate leftmost nearest alignments in reference for p & q */
	  int t1 = 0, t2 = 0;
	  if(p->sites1[0] < q->sites1[0]){/* increase t1 until labels on reference are as close as possible */
	    while(t1 < U-1){
	      if(p->sites1[t1+1] < q->sites1[0]){
		t1++;
		continue;
	      }
	      if(fabs(Yc(Y,p->sites1[t1],p->sitesK1[t1]) - Yc(Y,q->sites1[0],q->sitesK1[0])) > fabs(Yc(Y,p->sites1[t1+1],p->sitesK1[t1+1]) - Yc(Y,q->sites1[0],q->sitesK1[0])))
		t1++;
	      break;
	    }
	  } else {/* increase t2 until labels on reference are as close as possible */
	    while(t2 < U2 - 1){
	      if(p->sites1[0] > q->sites1[t2+1]){
		t2++;
		continue;
	      }
	      if(fabs(Yc(Y,p->sites1[0],p->sitesK1[0]) - Yc(Y,q->sites1[t2],q->sitesK1[t2])) > fabs(Yc(Y,p->sites1[0],p->sitesK1[0]) - Yc(Y,q->sites1[t2+1],q->sitesK1[t2+1])))
		t2++;
	      break;
	    }
	  }
	  double offsetL = Yc(Y,p->sites1[t1],p->sitesK1[t1]) - Xrev[p->sites2[t1]];
	  double offsetL2 = Yc(Y,q->sites1[t2],q->sitesK1[t2]) - Xrev[q->sites2[t2]];

	  /* locate rightmost nearest alignments in reference for p & q */
	  int r1 = U-1, r2 = U2 - 1;
	  if(p->sites1[r1] < q->sites1[r2]){/* decrease r2 until labels on referece are as close as possible */
	    while(r2 > 0){
	      if(p->sites1[r1] < q->sites1[r2-1]){
		r2--;
		continue;
	      }
	      if(fabs(Yc(Y,p->sites1[r1],p->sitesK1[r1]) - Yc(Y,q->sites1[r2],q->sitesK1[r2])) > fabs(Yc(Y,p->sites1[r1],p->sitesK1[r1]) - Yc(Y,q->sites1[r2-1],q->sitesK1[r2-1])))
		r2--;
	      break;
	    }
	  } else {/* decrease r1 until labels on reference are as close as possible */
	    while(r1 > 0){
	      if(p->sites1[r1-1] > q->sites1[r2]){
		r1--;
		continue;
	      }
	      if(fabs(Yc(Y,p->sites1[r1],p->sitesK1[r1]) - Yc(Y,q->sites1[r2],q->sitesK1[r2])) > fabs(Yc(Y,p->sites1[r1-1],p->sitesK1[r1-1]) - Yc(Y,q->sites1[r2],q->sitesK1[r2])))
		r1--;
	      break;
	    }
	  }
	  double offsetR = Yc(Y,p->sites1[r1],p->sitesK1[r1]) - Xrev[p->sites2[r1]];
	  double offsetR2 = Yc(Y,q->sites1[r2],q->sitesK1[r2]) - Xrev[q->sites2[r2]];

	  /*	  double offsetL = Yc(Y,IL,KL) - Xrev[JL];
	  double offsetR = Yc(Y,I,K) - Xrev[J];
	  double offsetL2 = Yc(Y,IL2,KL2) - Xrev[JL2];
	  double offsetR2 = Yc(Y,I2,K2) - Xrev[J2];*/

	  if(strict && MultiMatchesTotScore >= 3 && (p->logPV2 > p->logPV || q->logPV2 > q->logPV)) {// reduce MultiMatchesDelta value to lesser of MultiMatchesTotDelta
	    Delta = min(Delta, MultiMatchesTotDelta);

	    /* Require offsets to differ at only one end */
	    if(fabs(offsetL - offsetL2) > Delta)
	      continue;
	    if(fabs(offsetR - offsetR2) > Delta)
	      continue;

	  } else {
	    if(REFSPLIT_FIX){  /* Require offsets to differ at only one end */
	      if(fabs(offsetL - offsetL2) > Delta)
		continue;
	      if(fabs(offsetR - offsetR2) > Delta)
		continue;
	    } else  {
	      if(min(offsetL2 - offsetL, offsetR2 - offsetR) > Delta)    // WAS	    if(min(offsetL2,offsetR2) - max(offsetL,offsetR) > Delta)
		continue;
	      if(min(offsetL - offsetL2, offsetR - offsetR2) > Delta)     // WAS	    if(min(offsetL,offsetR) - max(offsetL2,offsetR2) > Delta)
		continue;
	    }
	  }
	  
	  if(PVERB>=2){
	    int U1 = p->numpairs,U2 = q->numpairs;
	    printf("refid=%d(%lld),mapid=%d(%lld):i=%d,j=%d,k=%d: p(I=%d..%d,K=%d..%d,J=%d..%d,or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f) q(I=%d..%d,K=%d..%d,J=%d..%d,or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f):offsetL=%0.3f,%0.3f(t1=%d,t2=%d,IKJ=%d,%d,%d,IKJ2=%d,%d,%d),offsetR=%0.3f,%0.3f(r1=%d,r2=%d,IKJ=%d,%d,%d,IKJ2=%d,%d,%d), Delta= %0.3f\n",
		 p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,i,j,k,p->sites1[0],p->sites1[U1-1],p->sitesK1[0],p->sitesK1[U1-1],p->sites2[0],p->sites2[U1-1],p->orientation,p->rev,U1,p->score,p->logPV,
		   q->sites1[0],q->sites1[U2-1],q->sitesK1[0],q->sitesK1[U2-1],q->sites2[0],q->sites2[U2-1],q->orientation,q->rev,U2,q->score,q->logPV,
		   offsetL,offsetL2,t1,t2,p->sites1[t1],p->sitesK1[t1],p->sites2[t1],q->sites1[t2],q->sitesK1[t2],q->sites2[t2],
		   offsetR,offsetR2,r1,r2,p->sites1[r1],p->sitesK1[r1],p->sites2[r1],q->sites1[r2],q->sitesK1[r2],q->sites2[r2],Delta);
	    if(PVERB>=3){
	      printf("\t Alignment p:\n");
	      double PlogPV = alignFP(p, Y, Xrev, N, M, p->orientation, p->mapid1, p->mapid2, p->score, PVERB ? 1 : 0);

	      printf("\t Alignment q:\n");
	      double QlogPV = alignFP(q, Y, Xrev, N, M, q->orientation, q->mapid1, q->mapid2, q->score, PVERB ? 1 : 0);
	      printf("\t PlogPV= %0.2f, QlogPV= %0.2f\n",PlogPV,QlogPV);
	    }
	    fflush(stdout);
	  }
	}

	break;/* alignment p is NOT distinct enough */
      }

      if(DEBUG && !(lastNumMatchgroup <= j && lastNumMatchgroup <= k && k <= j && j <= i && i < align->multicnt)){
	Calign *p = align->Malign[i];
	Calign *q = align->Malign[k];
	Calign *r = align->Malign[j];
	int U1 = p->numpairs,U2 = q->numpairs, U3 = r->numpairs;
	printf("refid=%d(%lld),mapid=%d(%lld):i=%d,j=%d,k=%d: p(I=%d..%d,K=%d..%d,J=%d..%d,or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f) q(I=%d..%d,K=%d..%d,J=%d..%d,or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f):Removed p\n",
	       p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,i,j,k,p->sites1[0],p->sites1[U1-1],p->sitesK1[0],p->sitesK1[U1-1],p->sites2[0],p->sites2[U1-1],p->orientation,p->rev,U1,p->score,p->logPV,
	       q->sites1[0],q->sites1[U2-1],q->sitesK1[0],q->sitesK1[U2-1],q->sites2[0],q->sites2[U2-1],q->orientation,q->rev,U2,q->score,q->logPV);
	printf("lastNumMatchgroup=%d: r(i=%d..%d,K=%d..%d,J=%d..%d,or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f)\n",lastNumMatchgroup,
	       r->sites1[0],r->sites1[U3-1],r->sitesK1[0],r->sitesK1[U3-1],r->sites2[0],r->sites2[U3-1],r->orientation,r->rev,U3,r->score,r->logPV);
	fflush(stdout);

	assert(lastNumMatchgroup <= j && lastNumMatchgroup <= k && k <= j && j <= i && i < align->multicnt);
      }

      if(k < j){/* not distinct : filter out align->Malign[i] (possibly modified matchgroups align->Malign[i+1 .. align->multicnt-1], may include fragments of Malign[i])  */
	if(PVERB){
	  Calign *p = align->Malign[i];
	  Calign *q = align->Malign[k];
	  int U1 = p->numpairs,U2 = q->numpairs;
	  printf("refid=%d(%lld),mapid=%d(%lld):i=%d,j=%d,k=%d: p(I=%d..%d,K=%d..%d,J=%d..%d,or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f) q(I=%d..%d,K=%d..%d,J=%d..%d,or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f):Removed p\n",
		 p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,i,j,k,p->sites1[0],p->sites1[U1-1],p->sitesK1[0],p->sitesK1[U1-1],p->sites2[0],p->sites2[U1-1],p->orientation,p->rev,U1,p->score,p->logPV,
		 q->sites1[0],q->sites1[U2-1],q->sitesK1[0],q->sitesK1[U2-1],q->sites2[0],q->sites2[U2-1],q->orientation,q->rev,U2,q->score,q->logPV);
	  fflush(stdout);
	}
	if(DEBUG) assert(align->Malign[i]->allocated_size > 0);
	align->Malign[i]->allfree();
	if(DEBUG) assert(align->Malign[i]->allocated_size == 0);
	//	if(DEBUG) align->Malign[i] = NULL;

	if(PVERB){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,k=%d,j=%d, lastNumMatchgroup=%d, multicnt=%d\n",
		 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,k,j,lastNumMatchgroup,align->multicnt);
	  for(int t = lastNumMatchgroup; t < j; t++){
	    Calign *p = align->Malign[t];
	    printf("\t Malign[%d]=%p: score= %0.6f, or=%d, rev=%d, sc=%d, pairs= %d, LogPv= %0.2f(logPV2= %0.2f)\n",
		   t, p, p->score,p->orientation, p->rev,p->scaleID, p->numpairs, p->logPV, p->logPV2);
	  }

	  fflush(stdout);
	}

	if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	  for(int i = 0; i < align->multimax; i++)
	    for(int j = i+1; j < align->multimax; j++)
	      if(align->Malign[j] && align->Malign[i] == align->Malign[j]){
		printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
		fflush(stdout);
		assert(align->Malign[i] != align->Malign[j]);
	      }
	}

	if(DEBUG>=2){
	  for(int k = lastNumMatchgroup + 1; k < j; k++){
	    if(!(align->Malign[k-1]->score >= align->Malign[k]->score)){
	      printf("MultiMatchesRemoveDupes: rid=%lld,mid=%lld:lastNumMatchgroup=%d,k=%d,j=%d,multicnt=%d:Malign[k-1]:or=%d,score=%0.6f; Malign[k]:or=%d,score=%0.6f\n",
		     rmap->id,nanomap->id,lastNumMatchgroup,k,j,align->multicnt,
		     align->Malign[k-1]->orientation,align->Malign[k-1]->score, align->Malign[k]->orientation,align->Malign[k]->score);
	      fflush(stdout);
	      assert(align->Malign[k-1]->score >= align->Malign[k]->score);
	    }
	  }
	}

	continue;/* next i */
      }

      if(j < i){
	if(DEBUG) assert(align->Malign[j]->allocated_size == 0);
	Calign *tmp = align->Malign[j];
	align->Malign[j] = align->Malign[i];
	align->Malign[i] = tmp;
      }
      if(DEBUG>=2)
	for(int t = j+1; t <= i; t++)
	  assert(align->Malign[t]->allocated_size == 0);
      if(1){/* need to resort position of Malign[j] in Malign[lastNumMatchgroup .. j], since Malign[i] may have a larger score than Malign[j-1] */
	Calign *tmp = align->Malign[j];
	int t = j - 1;
	for(; t >= lastNumMatchgroup; t--){
	  if(align->Malign[t]->score >= tmp->score)
	    break;
	  align->Malign[t+1] = align->Malign[t];
	}
	align->Malign[t+1] = tmp;
      }
      j++;

      if(PVERB){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:i=%d,k=%d,j=%d, lastNumMatchgroup=%d, multicnt=%d\n",
	       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,k,j,lastNumMatchgroup,align->multicnt);
	for(int t = lastNumMatchgroup; t < j; t++){
	  Calign *p = align->Malign[t];
	  printf("\t Malign[%d]=%p: score= %0.6f, or=%d, rev=%d, sc=%d, pairs= %d, LogPv= %0.2f(logPV2= %0.2f)\n",
		 t, p, p->score,p->orientation, p->rev,p->scaleID, p->numpairs, p->logPV, p->logPV2);
	}

	fflush(stdout);
      }

      if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	for(int i = 0; i < align->multimax; i++)
	  for(int j = i+1; j < align->multimax; j++)
	    if(align->Malign[j] && align->Malign[i] == align->Malign[j]){
	      printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		     rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	      fflush(stdout);
	      assert(align->Malign[i] != align->Malign[j]);
	    }
      }

      if(DEBUG /* HERE >=2 */){
	for(int k = lastNumMatchgroup + 1; k < j; k++){
	  if(!(align->Malign[k-1]->score >= align->Malign[k]->score)){
	    printf("MultiMatchesRemoveDupes: rid=%lld,mid=%lld:lastNumMatchgroup=%d,k=%d,j=%d,multicnt=%d:Malign[k-1]:or=%d,score=%0.6f; Malign[k]:or=%d,score=%0.6f\n",
		   rmap->id,nanomap->id,lastNumMatchgroup,k,j,align->multicnt,
		   align->Malign[k-1]->orientation,align->Malign[k-1]->score, align->Malign[k]->orientation,align->Malign[k]->score);
	    fflush(stdout);
	    assert(align->Malign[k-1]->score >= align->Malign[k]->score);
	  }
	}
      }

    } // i = lastNumMatchgroup + 1 .. align->multicnt - 1

    align->multicnt = j;
  }

  if(PVERB){
    printf("After MultiMatchesRemoveDupes:refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:pairs=%d,score=%0.6f,logPV=%0.2f,multicnt=%d,lastNumMatchgroup=%d\n",
	   rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,align->orientation,align->rev,align->numpairs,align->score,align->logPV,align->multicnt,lastNumMatchgroup);
    if(PVERB>=2){
      for(int i = 0; i < lastNumMatchgroup; i++){
	Calign *p = align->Malign[i];
	if(PVERB <= 2){
	  printf("  Malign[%d]=%p:or=%d,rev=%d,sc=%d:numpairs=%d, score= %0.6f, LogPv= %0.2f(logPV2= %0.2f)\n",
		 i,p,p->orientation,p->rev,p->scaleID,p->numpairs,p->score,p->logPV, p->logPV2);
	  continue;
	}
      }
    }

    for(int i = lastNumMatchgroup; i < align->multicnt; i++){
      Calign *p = align->Malign[i];

      if(DEBUG && Xorient >= 0) assert(p->orientation == Xorient);

      if(Xorient < 0 || NumScaleFactor > 1){/* compute Xrev[] */
	if(DEBUG && NumScaleFactor <= 1) assert(p->scaleID == 0);
	FLOAT scale = ScaleFactor[p->scaleID];
	if(DEBUG && p->scaleID == 0) assert(scale == 1.0);
	if((Xorient < 0) ? (!p->orientation) : (p->orientation == Xorient)){
	  for(int J=0;J <= M+1;J++)
	    Xrev[J] = X[J]*scale;
	} else {
	  for(int J=0;J <= M+1;J++)
	    Xrev[J] = (X[M+1] - X[M+1-J])*scale;
	}
      }

      double logPV = p->logPV;
      int U = p->numpairs;
      int I = p->sites1[U-1];
      int K = p->sitesK1[U-1];
      int J = p->sites2[U-1];
      int IL = p->sites1[0];
      int KL = p->sitesK1[0];
      int JL = p->sites2[0];
      printf("  Malign[%d]=%p:or=%d,rev=%d,sc=%d:I=%d,K=%d,J=%d,IL=%d,KL=%d,JL=%d (offset=%0.3f .. %0.3f):numpairs=%d, score= %0.6f, LogPv= %0.2f(logPV2= %0.2f)\n",
	     i,p,p->orientation,p->rev,p->scaleID,I,K,J,IL,KL,JL,Yc(Y,I,K)-Xrev[J],Yc(Y,IL,KL)-Xrev[JL],U, p->score,logPV,p->logPV2);
      if(PVERB>=2){
	//	printf("M=%d,or=%d,scale=%0.6f,Xrev[1,M,M+1]= %0.4f,%0.4f,%0.4f\n",M,p->orientation,ScaleFactor[p->scaleID],Xrev[1],Xrev[M],Xrev[M+1]);
	printf("\t Xorient=%d,NumScaleFactor=%d, Alignment:\n",Xorient,NumScaleFactor);
	double TlogPV = alignFP(p, Y, Xrev, N, M, p->orientation, p->mapid1, p->mapid2, p->score, PVERB ? 1 : 0);
	if(fabs(TlogPV - logPV) > 0.01){
	  printf("\t\t WARNING:logPV= %0.4f, alignFP()= %0.4f (err= %0.4f)\n", logPV, TlogPV, logPV - TlogPV);
	  fflush(stdout);
	}
      }
    }
    fflush(stdout);
  }

  if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
    for(int i = 0; i < align->multimax; i++)
      for(int j = i+1; j < align->multimax; j++)
	if(align->Malign[i] == align->Malign[j]){
	  printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		 rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	  fflush(stdout);
	  assert(align->Malign[i] != align->Malign[j]);
	}
  }

  if(DEBUG){/* check that all logPV2 values are >= logPV */
    for(int i = lastNumMatchgroup; i < align->multicnt; i++){
      Calign *p = align->Malign[i];
      assert(p->logPV2 >= p->logPV);
    }
  }

  if(Xorient < 0 || NumScaleFactor > 1)
    delete [] Xrev;	

  lastNumMatchgroup = align->multicnt;
}

/* Recompute iscore[] and outscore[] for an alignment (typically called after inverting the alignment with copyrev(), or after merging outliers with MatchgroupRefSplit() */
static void RescoreAlign(int index, /* index into align->Malign[] that was just inverted (or -1 if we just inverted align itself) */
			 Calign *p, /* inverted alignment that needs to have iscore[] and outscore[] recomputed */
			 FLOAT *X, FLOAT *Y, int M, int N, int refid, int mapid, Cmap *rmap, Cmap *nanomap)
{
  int orientation = p->orientation;

  if(DEBUG>=1+RELEASE || PVERB>=2){
    double scoresum = 0.0;
    for(int u = 0; u <= p->numpairs; u++)
      scoresum += p->iscore[u];
    
    if(PVERB>=2 || fabs(scoresum - p->score) > ASCORE_MARGIN + SCORE_MARGIN * fabs(scoresum)){
      #pragma omp critical
      {
        if(index >= 0)
          printf("WARNING:refid=%d(id=%lld),mapid=%d(id=%lld): After flipping Malign[%d]:or=%d,rev=%d,score=%0.7f, iscore[0..%d]= %0.7f (err= %0.7f)\n",
	    refid,rmap->id,mapid,nanomap->id,index,p->orientation,p->rev,p->score,p->numpairs,scoresum, p->score - scoresum);
	else
          printf("WARNING:refid=%d(id=%lld),mapid=%d(id=%lld): After flipping align:or=%d,rev=%d,score=%0.7f, iscore[0..%d]= %0.7f (err= %0.7f)\n",
	    refid,rmap->id,mapid,nanomap->id,p->orientation,p->rev,p->score,p->numpairs,scoresum, p->score - scoresum);
	fflush(stdout);
	//	assert(fabs(scoresum - p->score) <= ASCORE_MARGIN + SCORE_MARGIN * fabs(scoresum));
      }
    }
  }

  // need to recompute iscore,outscore, since Sm() terms for aligned labels are assigned to the LEFT interval, which is not symmetric
  int U = p->numpairs;
  int IL = p->sites1[0],I;
  int KL = p->sitesK1[0],K;
  int JL = p->sites2[0],J;
  FLOAT x = X[JL], y = Yc(Y,IL,KL);
  if(p->Lend <= -2)
    p->outscore[0] = p->iscore[0] = ChimScore + Sm(JL,IL,KL,Y);
  else if(ENDFIX && x <= y && p->Lij1 > 0 && y - Y[p->Lij1 - 1] < x)/* Sbnd(x,y-Y[Lij-1],JL,IL-KL-Lij+1) */
    p->outscore[0] = p->iscore[0] = Sbnd(x,y - Y[p->Lij1 - 1], JL,IL-KL+1-p->Lij1,IL-KL,refid) + Sm(JL,IL,KL,Y);
  else if(ENDFIX && extend && x >= y && p->Lij2 > 0 && x - X[p->Lij2-1] < y)/* Sbnd(x-X[p->Lij2-1],y,JL+1-p->Lij2,IL-KL) */
    p->outscore[0] = p->iscore[0] = Sbnd(x - X[p->Lij2-1], y, JL+1-p->Lij2,IL-KL,IL-KL,refid) + Sm(JL,IL,KL,Y);
  else /* Send(min(x,y),JL-1-max(1,p->Lij2),IL-KL+1-max(1,p->Lij1)) */
    p->outscore[0] = p->iscore[0] = Send(min(x, y), JL + 1 - max(1, p->Lij2), IL - KL + 1 - max(1, p->Lij1), IL - KL, refid, 0) + Sm(JL,IL,KL, Y);

  if(PVERB>=2){
    if(index >= 0)
      printf("After Rescoring malign[%d]:", index);
    else
      printf("After Rescoring align:");
    if(p->Lend <= -2)
      printf("U=%d,orig score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, ChimScore=%0.6f,Sm=%0.6f(y=%0.4f),iscore[0]=%0.6f\n",
	     U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL,ChimScore,Sm(JL,IL,KL,Y),y,p->iscore[0]);
    else if(x <= y && p->Lij1 > 0 && y - Y[p->Lij1 - 1] < x)
      printf("U=%d,orig score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,n=%d,n=%d),Sm=%0.6f,iscore[0]=%0.6f\n",
	     U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL,
	     Sbnd(x,y - Y[p->Lij1 - 1], JL,IL-KL+1-p->Lij1,IL-KL,refid),x,y-Y[p->Lij1-1],JL,IL-KL+1-p->Lij1,Sm(JL,IL,KL,Y),p->iscore[0]);
    else if(x >= y && p->Lij2 > 0 && x - X[p->Lij2-1] < y)
      printf("U=%d,orig score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,n=%d,n=%d),Sm=%0.6f,iscore[0]=%0.6f\n",
	     U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL,
	     Sbnd(x - X[p->Lij2-1], y, JL+1-p->Lij2,IL-KL,IL-KL,refid), x - X[p->Lij2-1], y, JL+1-p->Lij2,IL-KL,Sm(JL,IL,KL,Y),p->iscore[0]);
    else
      printf("U=%d,orig score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, Send=%0.6f(x=%0.4f,m=%d,n=%d),Sm=%0.6f,iscore[0]=%0.6f\n",
	     U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL,
	     Send(min(X[JL], Yc(Y,IL,KL)), JL + 1 - max(1, p->Lij2), IL - KL + 1 - max(1, p->Lij1), IL - KL, refid, 0), 
	     min(X[JL], Yc(Y,IL,KL)),  JL + 1 - max(1, p->Lij2),  IL - KL + 1 - max(1, p->Lij1), Sm(JL,IL,KL,Y),p->iscore[0]);

    fflush(stdout);
  }

  double sum = p->iscore[0];

  for(int u = 1; u < U; u++, IL = I, KL = K, JL = J){
    I = p->sites1[u];
    K = p->sitesK1[u];
    J = p->sites2[u];

    double Bias,Pen,Gauss,PenSm,OutPen,iscore;
    SintDetail(X[J]-X[JL], Yc(Y,I,K) - Yc(Y,IL,KL), J-JL, I-K-IL, J,I,K,KL,Y,Bias,Pen,Gauss,PenSm,OutPen,iscore,0);
	  
    sum += iscore;

    if(PVERB>=3)
      printf("\t u=%d:I=%d,K=%d,J=%d,G=%d,T=%d,H=%d:x=%0.4f,y=%0.4f:Bias=%0.6f,Pen=%0.6f,Gauss=%0.6f,PenSm=%0.6f,OutPen=%0.6f:outscore[u]= %0.6f -> %0.6f, iscore[u]= %0.6f -> %0.6f, (delta= %0.6f),iscoresum= %0.6f\n",
	     u,I,K,J,IL,KL,JL,X[J]-X[JL],Yc(Y,I,K)-Yc(Y,IL,KL),Bias,Pen,Gauss,PenSm,OutPen,p->outscore[u],Bias + Pen + Gauss + PenSm,p->iscore[u],iscore,iscore - p->iscore[u],sum);

    p->iscore[u] = iscore;
    p->outscore[u] = Bias + Pen + Gauss + PenSm;

    if(DEBUG/* HERE >=2 */) assert(p->outscore[u] <= p->iscore[u] + SCORE_MARGIN * fabs(p->outscore[u]) + ASCORE_MARGIN);
  }

  x = X[M+1] - X[JL];
  y = Yc(Y,IL,KL);

  if(p->Rend <= -2)
    p->iscore[U] = p->outscore[U] = ChimScore;// assumes biaswtEnd == 0.0
  else if(ENDFIX && x <= Y[N+1]-y && p->Rij1 <= N && Y[p->Rij1+1] - y < x) /* Sbnd(x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-I, p->Rij1,refid) */
    p->iscore[U] = p->outscore[U] = Sbnd(x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-IL,p->Rij1,refid);
  else if(ENDFIX && extend && x >= Y[N+1] - y && p->Rij2 <= M && X[p->Rij2+1] - X[JL] < Y[N+1] - y)/* Sbnd(X[p->Rij2+1]-X[JL],Y[N+1]-y, p->Rij2+1-JL,min(N,p->Rij1)+1-IL, min(N, p->Rij1), refid) */
    p->iscore[U] = p->outscore[U] = Sbnd(X[p->Rij2+1]-X[JL],Y[N+1]-y,p->Rij2+1-JL,min(N,p->Rij1)+1-IL,min(N,p->Rij1),refid);    
  else
    p->iscore[U] = p->outscore[U] = Send(min(X[M+1] - X[JL], Y[N+1] - Yc(Y,IL,KL)), min(M,p->Rij2) + 1 - JL, min(N, p->Rij1) + 1 - IL, min(N, p->Rij1), refid, 0);

  sum += p->iscore[U];

  if(PVERB>=2){
    if(index >= 0)
      printf("After Rescoring Malign[%d]= %p:", index,p);
    else 
      printf("After Rescoring align= %p:", p);

    if(p->Rend <= -2)
      printf("numpairs=%d,score=%0.6f -> %0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,L=%d,J=%d, ChimScore=%0.6f,iscore[U]=%0.6f\n",
	     U, p->score, sum, p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL, ChimScore, p->iscore[U]);
    else if(ENDFIX && x <= Y[N+1]-y && p->Rij1 <= N && Y[p->Rij1+1] - y < x)
      printf("numpairs=%d,score=%0.6f -> %0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,K=%d,J=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),iscore[U]=%0.6f\n",
	     U, p->score,sum,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL,
	     Sbnd(x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-IL,p->Rij1,refid), x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-IL, p->iscore[U]);
    else if(ENDFIX && extend && x >= Y[N+1] - y && p->Rij2 <= M && X[p->Rij2+1] - X[JL] < Y[N+1] - y)
      printf("numpairs=%d,score=%0.6f -> %0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,K=%d,J=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),iscore[U]=%0.6f\n",
	     U, p->score,sum,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL,
	     Sbnd(X[p->Rij2+1]-X[JL],Y[N+1]-y,p->Rij2+1-JL,min(N,p->Rij1)+1-IL,min(N,p->Rij1),refid), X[p->Rij2+1]-X[JL],Y[N+1]-y,p->Rij2+1-JL,min(N,p->Rij1)+1-IL, p->iscore[U]);
    else
      printf("numpairs=%d,score=%0.6f -> %0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,K=%d,J=%d, Send=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),iscore[U]=%0.6f\n",
	     U, p->score, sum, p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL,
	     Send(min(X[M+1] - X[JL], Y[N+1] - Yc(Y,IL,KL)), min(M,p->Rij2) + 1 - JL, min(N, p->Rij1) + 1 - IL, min(N, p->Rij1), refid, 0), 
	     X[M+1] - X[JL], Y[N+1] - Yc(Y,IL,KL), min(M,p->Rij2) + 1 - JL, min(N, p->Rij1) + 1 - IL, p->iscore[U]);
    fflush(stdout);
  }

  if(DEBUG && REFSPLIT_FIX <= 0 /* WAS7 1 */){
    double scoresum = 0.0;
    for(int u = 0; u <= p->numpairs; u++)
      scoresum += p->iscore[u];

    if(fabs(scoresum - p->score) > 1e-3 + 1e-4 * fabs(scoresum)){
      #pragma omp critical
      {
        if(index >= 0)
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld): After flipping & rescoring Malign[%d]:or=%d,rev=%d,score=%0.7f, iscore[0..%d]= %0.7f (err= %0.7f, corrected)\n",
		 refid,rmap->id,mapid,nanomap->id,index,p->orientation,p->rev,p->score,p->numpairs,scoresum, p->score - scoresum);
	else
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld): After flipping & rescoring align:or=%d,rev=%d,score=%0.7f, iscore[0..%d]= %0.7f (err= %0.7f, corrected)\n",
		 refid,rmap->id,mapid,nanomap->id,p->orientation,p->rev,p->score,p->numpairs,scoresum, p->score - scoresum);
	fflush(stdout);
	if(DEBUG >= 1+RELEASE) assert(fabs(scoresum - p->score) <= 1e-1 + 1e-2 * fabs(scoresum));
      }
    }
  }

  p->score = sum;
}

static int maxhashcnt = 0;/* maxmimum number of hashtable matches for any map pair (so far) */

/** version of refalign() that can handle resSD[0] > 0.0 using 3-D recurrance based alignment 
Top level function for performing ref alignment between two maps.
Allocate memory for mapsizes.
Run alignments in forward and reverse directions using refalignXYsd().
Check if splitting conditions are met (chimera, split) and append resulting fragments to map list for remapping.
*/
static void refalignSD(Cmap *rmap,
		       Cmap *nanomap,
		       size_t &alignid, /**< reference to index into alignment[] array. NOTE : alignment[alignid] may be NULL.
					If phash && NoSplit==1 && HashMultiMatch up to 3 alignment results may be returned in alignment[alignid..alignid+2] */
		       int **RKmax,/* Kmax == RKmax[refid + rev*grefend] */
		       int refid,int mapid, /**< id's used to identify rmap & nanomap in result (align) */
		       CHashMatch *phash, /**< If !=0 pointer to hashtable entry */
		       CXPen *XPen, /**< per thread score table */
		       AL *A, /**< A[I=1..N][K=0..Kmax[I]][J=1..maxM] : only 1st two dimensions are allocated (NOT Allocated at all if (DIAGONAL>=2 && phash && hashdelta) */
		       RFLOAT * &Fmem, /**< preallocated memory Fmem[0 ... pcnt*maxM*DPsizF - 1] to be used by A->field[I][K][] of type RFLOAT */
		       int * &Imem, /**< preallocated memory Imem[0 ... pcnt*maxM*DPsizI - 1] to be used by A->field[I][K][] of type int */
		       long long &StrideMax,/* If (MIN_MEM && DIAGONAL>=2 && hashdelta) : the current allocated number of elements per array */
		       long long &KstrideMax, /* If (DIAGONAL>=2 && MIN_MEM && CACHE && hashdelta) : the Kstride value used with stride <= StrideMax */
		       int *JMIN, int *JMAX, /**< preallocated memory Jmin[1..maxN], Jmax[1..maxN] used with phash offset to create diagonalized arrays */
		       int *Imin, int *Imax,  /**< preallocated memory Imin[1..maxM], Imax[1..maxM] used with phash offset to create diagonalized arrays */
		       int tid, int numthreads,
		       long long limN,/* use instead of maxN : limN == (MINMEM ? N : maxN) */
		       int nosplit, /* local version of NoSplit */
		       int &maxmatchgroup, /* size of matchgroup & mheap memory allocated : can be increased, if needed */
		       Cmatchgroup * &matchgroup, /* memory for matchgroup[0..maxmatchgroup-1 (extends to 2*maxmatchgroup-1 if MATCHGROUP_HEAP)] */
		       Cmatchgroup ** &mheap /* If MATCHGROUP_HEAP : memory for mheap[0..maxmatchgroup] */
		       )
{
  Calign* &galign = alignment[alignid++];

  if(MultiMatches && MultiMatchesRev && !(DIAGONAL>=2 && phash && hashdelta)){
    printf("-MultiMatchesRev not implemented without -hashgen and -hashdelta\n");
    fflush(stdout);exit(1);
  }

  if(colors != 1){
    printf("alignment for multi-color data not yet implemented\n");
    fflush(stdout);exit(1);
  }
  if(DEBUG)assert(resSD[0] > 0.0);

  double wstart = 0.0;
  if(VERB>=2){
    wstart = wtime();
    #pragma omp critical
    {
      printf("starting refalignSD: refid=%d(id=%lld),mapid=%d(id=%lld),tid=%d/%d: wall time= %0.6f secs\n",refid,rmap->id,mapid,nanomap->id,tid,numthreads,wstart);
      fflush(stdout);
    }
  }

  // if(DEBUG && galign) assert(galign->numpairs == 0);
  if(galign){
    if(galign->block_id < 0){
      galign->allfree();
      if(ALIGN_COMPRESS)
	delete [] galign;
    }
    if(ALIGN_COMPRESS)
      galign = NULL;
  }

  Calign *align, Lalign;
  if(DEBUG) assert(Lalign.Malign == NULL);
  if(galign != 0)
    align = galign;
  else
    align = &Lalign;/* a local temporary variable : alignment will be saved to galign IFF score is good */

  if(DEBUG>=2) assert(0 <= refid && refid < numrefmaps);
  align->mapid1 = refid;
  align->mapid2 = mapid;
  align->Lend = align->Rend = -1;
  align->orientation = -1;
  align->rev = 0;
  align->score = max(MINSCORE, min(ScoreThreshold,2.0 * ChimScore));
  align->numpairs = 0;
  align->logPV = 0.0;
  if(SecondBest){
    delete [] align->align2; 
    align->align2 = NULL;
  }
  if(MultiMatches){
    if(align->Malign){
      if(DEBUG) assert(align->multimax > 0);
      for(int t = 0; t < align->multimax; t++)
	delete [] align->Malign[t];
      delete [] align->Malign;
      align->Malign = NULL;
    }
    align->multicnt = align->multimax = 0;
  }
  if(TRACE)
    align->multicnt = align->multimax = 0;
  if(RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0)
    align->repeat = 0;

  int N = rmap->numsite[0];
  FLOAT *Y = rmap->site[0];
  int M = nanomap->numsite[0];
  FLOAT *X = nanomap->site[0];

  /* Do memory allocation for dynamic programming array A */
  /* NOTE : if (DIAGONAL>=2 && phash && hashdelta) A->field[][][] will be re-allocated in refalignXYsd() using malloc()/free() */
  if(!(DIAGONAL >= 2 && phash && hashdelta)){  /* re-allocate memory for A->field[][][] */
    A->Kstride = limN * maxM;
    A->Istride = M;
    long long stride = (1LL + A->kmax) * A->Kstride;

    long long mcnt = 0;
#define FBLOCK(field) {					\
      A->field##_base = &Fmem[mcnt - A->Istride - 1LL];	\
      mcnt += stride;					\
    }
    FBLOCK(score);
    FBLOCK(Uscore);
    if(RepeatRec)
      FBLOCK(rscore);
    if(MultiMatches){
      FBLOCK(Tscore);
    }
#undef FBLOCK

    if(DEBUG) assert(mcnt <= (1LL + A->kmax) * limN * maxM * DPsizF);

    mcnt = 0;
#define BLOCK(field) {					\
      A->field##_base = &Imem[mcnt - A->Istride - 1LL];	\
      mcnt += stride;					\
    }
    BLOCK(G);
    BLOCK(T);
    BLOCK(H);
    BLOCK(Lij);
    BLOCK(Rij);
    BLOCK(Lijx);
    BLOCK(Rijx);
    if(RepeatRec || MultiMatchesFilter >= 2)
      BLOCK(shift);
    if(RepeatRec){
      BLOCK(rG);
      BLOCK(rT);
      BLOCK(rH);
    }
    if(MultiMatches){
      BLOCK(IL);
      BLOCK(KL);
      BLOCK(JL);
      BLOCK(R);
    }
#undef BLOCK

    if(VERB>=2){
      printf("kmax=%d,N=%d,M=%d:stride=%lld,Istride=%lld,Kstride=%lld,mcnt=%lld, maxM=%lld, N*(1+kmax)*maxM*7=%lld\n",
	     A->kmax,N,M,stride,A->Istride,A->Kstride,mcnt,maxM, N*(1LL+A->kmax)*maxM*DPsizI);
      fflush(stdout);
    }
    if(DEBUG) assert(mcnt <= (1LL + A->kmax) * limN * maxM * DPsizI);
  }

  FLOAT *Xrev = NULL, *Yrev = NULL;
  if(M > MAX_ALLOCA)
    Xrev = new FLOAT[M+2]; // HERE HERE : move this memory to end of Fmem+Imem memory block
  else
    Xrev = (FLOAT *)alloca((M+2)*sizeof(FLOAT));
  if(MultiMatchesRev){
    if(N > MAX_ALLOCA)
      Yrev = new FLOAT[N+2]; // HERE HERE : move this memory to end of Fmem+Imem memory block
    else
      Yrev = (FLOAT *)alloca((N+2)*sizeof(FLOAT));
  }
  
  if(DEBUG) assert(nanomap->mapid == mapid);
  Cmap *origmap = nanomap;
  while(origmap->origmap)
    origmap = origmap->origmap;
  int origmapid = origmap->mapid;

  if(TRACE && phash && hashdelta && rmap->id==REF_TRACE && nanomap->id == MAP_TRACE){
    int cnt = 0;
    CHashMatch *hash = phash;
    while(hash->id1 == refid && hash->id2 == origmapid){
      cnt++;
      hash++;
    }
    if(cnt > maxhashcnt || TRACE){
      hash = phash;

      #pragma omp critical
      {
	if(cnt > maxhashcnt)
          maxhashcnt = cnt;

	if(cnt >= maxhashcnt || TRACE){
          printf("refalignSD:refid=%d(id=%lld),mapid=%d(id=%lld),origmapid=%d,T=%0.2f,hashdelta=%0.1f: %d hashtable entries (max=%d):\n",
	    refid,rmap->id,mapid,Gmap[mapid]->id,origmapid,LogPvThreshold,hashdelta,cnt,maxhashcnt);
	  while(hash->id1 == refid && hash->id2 == origmapid){
	    if(ShiftOffset1 <= 30)
	      printf("phash=%p:mapid1=%d,mapid2=%d,hashscore=%d,offset=%d,or=%d,sc=%d,Loc2= %0.1f .. %0.1f kb\n",
		     hash,hash->id1,hash->id2,hash->hashscore,hash->offset,hash->orientation, hash->scaleID,hash->MinLoc2, hash->MaxLoc2);
	    else
	      printf("phash=%p:mapid1=%d,mapid2=%d,hashscore=%d,offset=%d,or=%d,sc=%d\n",
		     hash,hash->id1,hash->id2,hash->hashscore,hash->offset,hash->orientation,hash->scaleID);
	    hash++;
          }
	  printf("[phash=%p:mapid1=%d,mapid2=%d,hashscore=%d,offset=%d,or=%d,sc=%d]\n",
		 hash,hash->id1,hash->id2,hash->hashscore,hash->offset,hash->orientation,hash->scaleID);
	  fflush(stdout);
        }
      }
    }
  }

  int lastNumMatchgroup = 0;

  if(DEBUG && !(NumScaleFactor == 1 + 2 * ScaleDelta)){
    #pragma omp critical
    {
      printf("ScaleDelta=%d, NumScaleFactor=%d\n",ScaleDelta,NumScaleFactor);
      fflush(stdout);
      assert(NumScaleFactor == 1 + 2 * ScaleDelta);
    }
  }

  CHashMatch *origphash = phash;

  for(int scaleID = 0; scaleID < NumScaleFactor; scaleID++){
    int startNumMatchgroup = lastNumMatchgroup;

    FLOAT scale = ScaleFactor[scaleID];
    if(DEBUG && scaleID == 0) assert(scale == 1.0);
    if(origphash && hashScaleDelta >= 2 && MapScale && origMapScale && nanomap->cumscale != 1.0)
      scale = 1.0;// NEW44 : MapScale has already rescaled this molecule

    /* first check X in normal orientation and update best alignment */
    if(scaleID > 0)
      for(int J= 0; J <= M+1; J++)
	Xrev[J] = X[J]*scale;

    phash = origphash;
    for(int cnt = 0; HashMultiMatchMax <= 0 || cnt < HashMultiMatchMax ; cnt++){ /* if(phash && hashdelta) loop over multiple offsets */

      if(cnt && (cnt%1000)==0){
	printf("WARNING:refid=%d(id=%lld),mapid=%d(id=%lld),or=0:over %d hashtable offsets:phash=%p:id1=%d,id2=%d,hashscore=%d,offset=%d,or=%d,sc=%d\n",
	       refid,rmap->id,mapid,nanomap->id,cnt,phash,phash->id1,phash->id2,phash->hashscore,phash->offset,phash->orientation,phash->scaleID);
	fflush(stdout);
      }

      if(TRACE && phash && nanomap->id == MAP_TRACE && rmap->id == REF_TRACE){
	#pragma omp critical
	{
	  printf("tid=%d,cnt1=%d,refid=%d(id=%lld),mapid=%d,%d(id=%lld),or=0,sc=%d:phash=%p:id1=%d,id2=%d,hashscore=%d,offset=%d,or=%d,sc=%d:wtime= %0.6f\n",
		 tid,cnt,refid,rmap->id,mapid,origmapid,nanomap->id,scaleID,phash,phash->id1,phash->id2,phash->hashscore,phash->offset,phash->orientation,phash->scaleID,wtime());
	  if(align->Malign)
	    printf("\t lastNumMatchgroup=%d, startNumMatchgroup=%d,align->multicnt=%d,align->multimax=%d\n",lastNumMatchgroup,startNumMatchgroup,align->multicnt,align->multimax);
	  fflush(stdout);
	}
      }

      if(phash){
	if(phash->id1 != refid || phash->id2 != origmapid || phash->orientation)
	  break;

	if(HashMultiMatchMaxDelta > 0 && phash->hashscore < origphash->hashscore - HashMultiMatchMaxDelta){// NEW13
	  phash++;
	  continue;
	}

	if(hashScaleDelta>=2 && giter==0 && phash->scaleID != scaleID){// NEW13   
	  phash++;
	  continue;
	}
      }

      refalignXYsd(Y, N, scaleID > 0 ? Xrev : X, M, 0, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, phash, tid, 
		   numthreads, maxmatchgroup, matchgroup, mheap, hashdelta, hashdeltaAdjust,ScoreThreshold2,LogPvThreshold2,AlignedSiteThreshold2);

      if(VERB>=3 && nanomap->id == MAP_TRACE){
	#pragma omp critical
	{
	  printf("refalignSD:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,M=%d,score=%0.3f/%0.3f,logPV=%0.3f/%0.3f,numpairs=%d/%d,Length=%0.3f/%0.3f,repeat=%d:tid=%d,wtime=%0.6f\n",
		 refid,rmap->id, mapid,nanomap->id, align->orientation,nanomap->numsite[0],align->score,ScoreThreshold,align->logPV,LogPvThreshold,align->numpairs,AlignedSiteThreshold, 
		 align->numpairs ? AlignedLength(align,Y) : 0.0, AlignedLengthThreshold, align->repeat,tid,wtime());
	  fflush(stdout);
	}
      }

      if(DEBUG>=2 && RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0 && !(align->repeat >= 0)){
	#pragma omp critical
	{
	  assert(align->repeat >= 0);
	}
      }

      if(!(phash && hashdelta))
	break;

      phash++;

      if(DEBUG) assert(hashdelta);
      /*      if(!hashdelta)
	while(phash->id1 == refid && phash->id2 == origmapid && !phash->orientation)
	phash++;*/

      if(DEBUG && !(phash->id1 != refid || phash->id2 != origmapid || phash->orientation)) assert(HashMultiMatch);
    }
    
    if(MultiMatches && MultiMatchesRev){/* Also check X and Y both in reversed orientation (using same hashtable entries) */
      int origmulticnt = align->multicnt;
      
      for(int J=0;J <= M+1;J++)
	Xrev[J] = (X[M+1] - X[M+1-J])*scale;

      for(int I=0;I <= N+1;I++)
	Yrev[I] = Y[N+1] - Y[N+1-I];

      if(VERB>=2 && rmap->id == REF_TRACE && nanomap->id == MAP_TRACE && N >= 15218){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=0,rev=1,N=%d,M=%d: Y[15218]= %0.4f, Y[15217]= %0.4f\n",refid,rmap->id,mapid,nanomap->id,N,M,Yrev[15218],Yrev[15217]);
	fflush(stdout);
      }

      phash = origphash;
      for(int cnt = 0; HashMultiMatchMax <= 0 || cnt < HashMultiMatchMax ; cnt++){ /* if(phash && hashdelta) loop over multiple offsets */

	if(cnt && (cnt%1000)==0){
	  printf("WARNING:refid=%d(id=%lld),mapid=%d(id=%lld),or=0,rev=1:over %d hashtable offsets:phash=%p:id1=%d,id2=%d,hashscore=%d,offset=%d,or=%d,sc=%d\n",
		 refid,rmap->id,mapid,nanomap->id,cnt,phash,phash->id1,phash->id2,phash->hashscore,phash->offset,phash->orientation,phash->scaleID);
	  fflush(stdout);
	}

	if(TRACE && phash && nanomap->id == MAP_TRACE && rmap->id == REF_TRACE){
#pragma omp critical
	  {
	    printf("tid=%d,cnt1=%d,scaleID=%d,refid=%d(id=%lld),mapid=%d,%d(id=%lld),or=0,rev=1:phash=%p:id1=%d,id2=%d,hashscore=%d,offset=%d,or=%d,sc=%d:wtime=%0.6f\n",
		   tid,cnt,scaleID,refid,rmap->id,mapid,origmapid,nanomap->id,phash,phash->id1,phash->id2,phash->hashscore,phash->offset,phash->orientation,phash->scaleID,wtime());
	    fflush(stdout);
	  }
	}

	if(phash){
	  if(phash->id1 != refid || phash->id2 != origmapid || phash->orientation)
	    break;

	  if(HashMultiMatchMaxDelta > 0 && phash->hashscore < origphash->hashscore - HashMultiMatchMaxDelta){// NEW13
	    phash++;
	    continue;
	  }

	  if(hashScaleDelta>=2 && giter==0 && phash && phash->scaleID != scaleID){// NEW13     
	    phash++;
	    continue;
	  }
	}

	refalignXYsd(Yrev, N, Xrev, M, 0, scaleID, RKmax[refid+grefend], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, phash, tid, numthreads, maxmatchgroup, matchgroup, 
		     mheap, hashdelta, hashdeltaAdjust,ScoreThreshold2,LogPvThreshold2,AlignedSiteThreshold2,1,N,1,M,1);

	if(VERB>=3 && nanomap->id == MAP_TRACE){
#pragma omp critical
	  {
	    printf("refalignSD:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,M=%d,score=%0.3f/%0.3f,logPV=%0.3f/%0.3f,numpairs=%d/%d,Length=%0.3f/%0.3f,repeat=%d:tid=%d,wtime=%0.6f\n",
		   refid,rmap->id, mapid,nanomap->id, align->orientation,align->rev,nanomap->numsite[0],align->score,ScoreThreshold,align->logPV,LogPvThreshold,align->numpairs,AlignedSiteThreshold, 
		   align->numpairs ? AlignedLength(align,Y) : 0.0, AlignedLengthThreshold, align->repeat,tid,wtime());
	    fflush(stdout);
	  }
	}

	if(DEBUG>=2 && RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0 && !(align->repeat >= 0)){
#pragma omp critical
	  {
	    assert(align->repeat >= 0);
	  }
	}

	if(!(phash && hashdelta))
	  break;
	phash++;

	if(DEBUG) assert(hashdelta);
	/*	if(!hashdelta)
	  while(phash->id1 == refid && phash->id2 == origmapid && !phash->orientation)
	  phash++;*/
	if(DEBUG && !(phash->id1 != refid || phash->id2 != origmapid || phash->orientation)) assert(HashMultiMatch);
      }

      /* reverse orientation align->Malign[origmulticnt .. align->multicnt - 1] */
      if(DEBUG) assert(YYmap == refmap);
      if(DEBUG) assert(XXmap == Gmap);

      for(int J=0;J <= M+1;J++)
	Xrev[J] = X[J]*scale;

      for(int t = origmulticnt; t < align->multicnt; t++){
	Calign *p = align->Malign[t];
	if(DEBUG) assert(p->rev);

	int orientation = p->orientation;
	if(PVERB>=2 || DEBUG>=2){
	  double scoresum = 0.0;
	  for(int u = 0; u <= p->numpairs; u++)
	    scoresum += p->iscore[u];

	  if(PVERB>=2 || fabs(scoresum - p->score) > 1e-3){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),M=%d,N=%d: Before flipping Malign[%d]:or=%d,rev=%d,sc=%d:score=%0.7f, iscore[0..%d]= %0.7f (err= %0.7f)\n",
	    	   refid,rmap->id,mapid, nanomap->id, M, N, t, p->orientation,p->rev,p->scaleID,p->score,p->numpairs,scoresum, p->score - scoresum);
	    fflush(stdout);
	  }
	  
	  if(PVERB>=2){
	    for(int J=0;J <= M+1;J++)
	      Xrev[J] = (X[M+1] - X[M+1-J])*scale;

	    int index = t;
	    if(1){
	      FLOAT *Y = Yrev;
	      FLOAT *X = Xrev;

    
	      int U = p->numpairs;
	      int IL = p->sites1[0],I;
	      int KL = p->sitesK1[0],K;
	      int JL = p->sites2[0],J;
	      FLOAT x = X[JL], y = Yc(Y,IL,KL);
	      double iscore0;
	      if(p->Lend <= -2)
		iscore0 = ChimScore + Sm(JL,IL,KL,Y);
	      else if(ENDFIX && x <= y && p->Lij1 > 0 && y - Y[p->Lij1 - 1] < x)/* Sbnd(x,y-Y[Lij-1],JL,IL-KL-Lij+1) */
		iscore0 = Sbnd(x,y - Y[p->Lij1 - 1], JL,IL-KL+1-p->Lij1,IL-KL,refid) + Sm(JL,IL,KL,Y);
	      else if(ENDFIX && extend && x >= y && p->Lij2 > 0 && x - X[p->Lij2-1] < y)/* Sbnd(x-X[p->Lij2-1],y,JL+1-p->Lij2,IL-KL) */
		iscore0 = Sbnd(x - X[p->Lij2-1], y, JL+1-p->Lij2,IL-KL,IL-KL,refid) + Sm(JL,IL,KL,Y);
	      else /* Send(min(x,y),JL-1-max(1,p->Lij2),IL-KL+1-max(1,p->Lij1)) */
		iscore0 = Send(min(x, y), JL + 1 - max(1, p->Lij2), IL - KL + 1 - max(1, p->Lij1), IL - KL, refid, 0) + Sm(JL,IL,KL, Y);

	      printf("Before Flipping malign[%d]:", index);

	      if(p->Lend <= -2)
		printf("U=%d,score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, ChimScore=%0.6f,Sm=%0.6f(y=%0.4f),iscore[0]=%0.6f(err= %0.6f)\n",
		       U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL,ChimScore,Sm(JL,IL,KL,Y),y,p->iscore[0], iscore0 -p->iscore[0]);
	      else if(x <= y && p->Lij1 > 0 && y - Y[p->Lij1 - 1] < x)
		printf("U=%d,score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,n=%d,n=%d),Sm=%0.6f,iscore[0]=%0.6f(err= %0.6f)\n",
		       U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL, Sbnd(x,y - Y[p->Lij1 - 1], JL,IL-KL+1-p->Lij1,IL-KL,refid),x,y-Y[p->Lij1-1],JL,IL-KL+1-p->Lij1,Sm(JL,IL,KL,Y),p->iscore[0], iscore0 - p->iscore[0]);
	      else if(x >= y && p->Lij2 > 0 && x - X[p->Lij2-1] < y)
		printf("U=%d,score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Liej2=%d, IL=%d,KL=%d,JL=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,n=%d,n=%d),Sm=%0.6f,iscore[0]=%0.6f(err= %0.6f)\n",
		       U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL, Sbnd(x - X[p->Lij2-1], y, JL+1-p->Lij2,IL-KL,IL-KL,refid), x - X[p->Lij2-1], y, JL+1-p->Lij2,IL-KL,Sm(JL,IL,KL,Y),p->iscore[0], iscore0 - p->iscore[0]);
	      else
		printf("U=%d,score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, Send=%0.6f(x=%0.4f,m=%d,n=%d),Sm=%0.6f,iscore[0]=%0.6f -> %0.6f(delta= %0.6f\n",
		       U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL, Send(min(X[JL], Yc(Y,IL,KL)), JL + 1 - max(1, p->Lij2), IL - KL + 1 - max(1, p->Lij1), IL - KL, refid,0), 
		       min(X[JL], Yc(Y,IL,KL)),  JL + 1 - max(1, p->Lij2),  IL - KL + 1 - max(1, p->Lij1), Sm(JL,IL,KL,Y),p->iscore[0],iscore0, iscore0 - p->iscore[0]);

	      for(int u = 1; u < U; u++, IL = I, KL = K, JL = J){
		I = p->sites1[u];
		K = p->sitesK1[u];
		J = p->sites2[u];

		double Bias,Pen,Gauss,PenSm,OutPen,iscore;
		SintDetail(X[J]-X[JL], Yc(Y,I,K) - Yc(Y,IL,KL), J-JL, I-K-IL, J,I,K,KL,Y,Bias,Pen,Gauss,PenSm,OutPen,iscore,0);
	  
		printf("\t u=%d:I=%d,K=%d,J=%d,G=%d,T=%d,H=%d:x=%0.4f,y=%0.4f:iscore[u]= %0.6f (err= %0.6f)\n",u,I,K,J,IL,KL,JL,X[J]-X[JL],Yc(Y,I,K) - Yc(Y,IL,KL),p->iscore[u],iscore - p->iscore[u]);

	      }

	      x = X[M+1] - X[JL];
	      y = Yc(Y,IL,KL);

	      double iscoreU;
	      if(p->Rend <= -2)
		iscoreU = ChimScore;// assumes biaswtEnd == 0.0
	      else if(ENDFIX && x <= Y[N+1]-y && p->Rij1 <= N && Y[p->Rij1+1] - y < x) /* Sbnd(x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-I, p->Rij1,refid) */
		iscoreU = Sbnd(x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-IL,p->Rij1,refid);
	      else if(ENDFIX && extend && x >= Y[N+1] - y && p->Rij2 <= M && X[p->Rij2+1] - X[JL] < Y[N+1] - y)/* Sbnd(X[p->Rij2+1]-X[JL],Y[N+1]-y, p->Rij2+1-JL,min(N,p->Rij1)+1-IL, min(N, p->Rij1), refid) */
		iscoreU = Sbnd(X[p->Rij2+1]-X[JL],Y[N+1]-y,p->Rij2+1-JL,min(N,p->Rij1)+1-IL,min(N,p->Rij1),refid);    
	      else
		iscoreU = Send(min(X[M+1] - X[JL], Y[N+1] - Yc(Y,IL,KL)), min(M,p->Rij2) + 1 - JL, min(N, p->Rij1) + 1 - IL, min(N, p->Rij1), refid,0);

	      printf("Before Flipping Malign[%d]:", index);

	      if(p->Rend <= -2)
		printf("numpairs=%d,score=%0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,L=%d,J=%d, ChimScore=%0.6f,iscore[U]= %0.6f(err= %0.6f)\n",
		       U, p->score,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL, ChimScore, p->iscore[U], iscoreU - p->iscore[U]);
	      else if(ENDFIX && x <= Y[N+1]-y && p->Rij1 <= N && Y[p->Rij1+1] - y < x)
		printf("numpairs=%d,score=%0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,K=%d,J=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),iscore[U]= %0.6f(err= %0.6f)\n",
		       U, p->score,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL,
		       Sbnd(x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-IL,p->Rij1,refid), x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-IL, p->iscore[U], iscoreU - p->iscore[U]);
	      else if(ENDFIX && extend && x >= Y[N+1] - y && p->Rij2 <= M && X[p->Rij2+1] - X[JL] < Y[N+1] - y)
		printf("numpairs=%d,score=%0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,K=%d,J=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),iscore[U]= %0.6f(err= %0.6f)\n",
		       U, p->score,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL,
		       Sbnd(X[p->Rij2+1]-X[JL],Y[N+1]-y,p->Rij2+1-JL,min(N,p->Rij1)+1-IL,min(N,p->Rij1),refid), X[p->Rij2+1]-X[JL],Y[N+1]-y,p->Rij2+1-JL,min(N,p->Rij1)+1-IL, p->iscore[U], iscoreU - p->iscore[U]);
	      else
		printf("numpairs=%d,score=%0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,K=%d,J=%d, Send=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),iscore[U]=%0.6f(err= %0.6f)\n",
		       U, p->score,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL,
		       Send(min(X[M+1] - X[JL], Y[N+1] - Yc(Y,IL,KL)), min(M,p->Rij2) + 1 - JL, min(N, p->Rij1) + 1 - IL, min(N, p->Rij1), refid,0), 
		       X[M+1] - X[JL], Y[N+1] - Yc(Y,IL,KL), min(M,p->Rij2) + 1 - JL, min(N, p->Rij1) + 1 - IL, p->iscore[U], iscoreU - p->iscore[U]);

	    }
	    for(int J=0;J <= M+1;J++)
	      Xrev[J] = X[J]*scale;
	  } // (PVERB>=2 || fabs(scoresum - p->score) > 1e-5)
	} // if(PVERB >= 2)

	Calign *nalign = new Calign[1];

	copyrev(nalign, align->Malign[t], 1);
	
	// need to recompute iscore,outscore, since Sm() terms for aligned labels are assigned to the LEFT interval, which is not symmetric
	RescoreAlign(t,nalign, Xrev, Y, M, N, refid, mapid, rmap, nanomap);

	if(DEBUG/* HERE >=2 */) assert(orientation == nalign->orientation);

	if(PVERB>=3){
	  Calign *p = nalign;
	  int U = p->numpairs;

	  if(p->sites1[U-1] == 19101 && p->sites2[U-1] == 1062){

	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:Malign[%d]: score= %0.6f, numpairs= %d:After RescoreAlign:\n",
		   p->mapid1,rmap->id,p->mapid2,nanomap->id,p->orientation,p->rev,t,p->score,U);
	    fflush(stdout);

	    double sum = 0;
	    for(int T = 0; T <= U; T++){
	      sum += p->iscore[T];
	      if(T <= 0)
		printf("  T=%5d: I=%d,K=%d,J=%d: iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T],p->sitesK1[T],p->sites2[T],p->iscore[T], sum);
	      else if(T < U)
		printf("  T=%5d: I=%d..%d,K=%d..%d,J=%d..%d: outscore[T]= %0.6f, iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T-1],p->sites1[T],p->sitesK1[T-1],p->sitesK1[T],p->sites2[T-1],p->sites2[T],p->outscore[T],p->iscore[T], sum);
	      else
		printf("  T=%5d: iscore[T]= %0.6f, iscoresum= %0.6f\n", T, p->iscore[T], sum);
	    }
	  }
	}

	delete [] align->Malign[t];
	align->Malign[t] = nalign;
	if(DEBUG) assert(!align->Malign[t]->rev);	

	if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	  for(int i = 0; i < align->multimax; i++)
	    for(int j = i+1; j < align->multimax; j++)
	      if(align->Malign[i] == align->Malign[j]){
		printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
		fflush(stdout);
		assert(align->Malign[i] != align->Malign[j]);
	      }
	}

	if(PVERB>=3){
	  Calign *p = align->Malign[t];
	  int U = p->numpairs;

	  if(p->sites1[U-1] == 19101 && p->sites2[U-1] == 1062){

	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:Malign[%d]= %p: score= %0.6f, numpairs= %d:After delete [] Malign[t]\n",
		   p->mapid1,rmap->id,p->mapid2,nanomap->id,p->orientation,p->rev,t,p,p->score,U);
	    fflush(stdout);

	    double sum = 0;
	    for(int T = 0; T <= U; T++){
	      sum += p->iscore[T];
	      if(T <= 0)
		printf("  T=%5d: I=%d,K=%d,J=%d: iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T],p->sitesK1[T],p->sites2[T],p->iscore[T], sum);
	      else if(T < U)
		printf("  T=%5d: I=%d..%d,K=%d..%d,J=%d..%d: outscore[T]= %0.6f, iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T-1],p->sites1[T],p->sitesK1[T-1],p->sitesK1[T],p->sites2[T-1],p->sites2[T],p->outscore[T],p->iscore[T], sum);
	      else
		printf("  T=%5d: iscore[T]= %0.6f, iscoresum= %0.6f\n", T, p->iscore[T], sum);
	    }
	  }
	}

      }// for t = origmulticnt .. align->multicnt - 1

      if(align->numpairs > 0 && align->rev){
	int orientation = align->orientation;
	if(PVERB || (DEBUG && !(align->numpairs > 0 && align->orientation == 0 && align->rev == 1))){
	  double scoresum = 0.0;
	  for(int u = 0; u <= align->numpairs; u++)
	    scoresum += align->iscore[u];
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:score=%0.6f,logPV=%0.2f,iscore[0..%d]= %0.6f,Lend=%d,Rend=%d,multicnt=%d, align=%p,Malign=%p: Flipping rev\n",
		 refid,rmap->id,mapid,nanomap->id,align->orientation,align->rev,align->score,align->logPV,align->numpairs,scoresum,align->Lend,align->Rend,align->multicnt,align,align->Malign);
	  fflush(stdout);
	  if(DEBUG/* HERE >=2 */) assert(align->numpairs > 0 && align->orientation == 0 && align->rev == 1);
	}
        Calign *nalign = new Calign[1];
	copyrev(nalign, align, 1);
        if(DEBUG/* HERE >=2 */)assert(!nalign->rev);

	// need to recompute iscore,outscore, since Sm() terms for aligned labels are assigned to the LEFT interval, which is not symmetric
	RescoreAlign(-1,nalign, Xrev, Y, M, N, refid, mapid, rmap, nanomap);

	Calign **Malign = align->Malign;// Malign is NOT saved by copyrev()
	int multicnt = align->multicnt;
	int multimax = align->multimax;
	align->Malign = NULL;
	align->allfree();
	Calign tmp = align[0]; align[0] = nalign[0]; nalign[0] = tmp;
	delete [] nalign;
	align->Malign = Malign;
	align->multicnt = multicnt;
	align->multimax = multimax;
	if(DEBUG) assert(!align->rev);
	if(PVERB/* HERE >=3 */){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:align->bestscore=%0.6f,align->logPV=%0.2f,align->multicnt=%d, align=%p,Malign=%p : After flipping rev\n",
		 refid,rmap->id,mapid,nanomap->id,align->orientation,align->rev,align->score,align->logPV,align->multicnt,align,align->Malign);
	  fflush(stdout);
	}
      }
    } // if MultiMatchesRev

    if(phash && HashMultiMatchMax > 0)
      while(phash->id1 == refid && phash->id2 == origmapid && !phash->orientation)
	phash++;
    if(DEBUG && phash) assert(phash->id1 != refid || phash->id2 != origmapid || phash->orientation);

    if(MultiMatches){/* initialize logPV2 for new matchgroups */
      align->logPV2 = align->logPV;
      if(MultiMatches /* NEW && AlignedThreshold(align,Y,ScoreThreshold,LogPvThreshold) */){
	for(int t = lastNumMatchgroup; t < align->multicnt; t++){
	  Calign *p = align->Malign[t];
	  p->logPV2 = p->logPV;
	}
	int orientation = align->orientation;
	if(PVERB){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,pairs=%d,score=%0.6f,logPV=%0.2f(logPV2=%0.2f):lastNumMatchgroup=%d,multicnt=%d:Initializing logPV2 == logPV for Malign[%d..%d]\n",
		 refid,rmap->id,mapid,nanomap->id,align->orientation,align->numpairs,align->score,align->logPV,align->logPV2,lastNumMatchgroup,align->multicnt, lastNumMatchgroup,align->multicnt-1);
	  if(PVERB>=2){
	    for(int t = startNumMatchgroup; t < align->multicnt; t++){
	      Calign *p = align->Malign[t];
	      printf("\t Malign[%d]=%p: or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f,logPV2=%0.2f\n",t,p,p->orientation,p->rev,p->numpairs,p->score,p->logPV,p->logPV2);
	    }
	  }
	  fflush(stdout);
	}
      }
    }

    if(MultiMatches){/* remove duplicates from different hashtable matches in align->Malign[lastNumMatchgroup .. align->multicnt-1][] (same orientation of query) */
      int origmulticnt = align->multicnt;
      int origlastNumMatchgroup = lastNumMatchgroup;

      MultiMatchesRemoveDupes(align,lastNumMatchgroup,Y,X,N,M,rmap,nanomap, 0, 0);

      if(TRACE && rmap->id == REF_TRACE && nanomap->id==MAP_TRACE){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=0,rev=%d:align->bestscore=%0.6f,align->logPV=%0.2f,align->multicnt=%d -> %d(last=%d -> %d), align=%p\n",
	       refid,rmap->id,mapid,nanomap->id,align->rev,align->score,align->logPV,origmulticnt,align->multicnt,origlastNumMatchgroup,lastNumMatchgroup,align);
	fflush(stdout);
      }
    }
    if(DEBUG && MultiMatches && align->multicnt > 0){
      for(int t = 0; t < align->multicnt; t++){
	Calign *q = align->Malign[t];
	if(DEBUG) assert(0 <= q->mapid1 && q->mapid1 < numrefmaps);
	if(DEBUG) assert(0 <= q->mapid2 && q->mapid2 < nummaps);
      }
    }

    CHashMatch *origphashR = phash;

    /* next check X in reversed orientation and update best alignment */
    for(int J=0;J <= M+1;J++)
      Xrev[J] = (X[M+1]-X[M+1-J])*scale;

    for(int cnt = 0; HashMultiMatchMax <= 0 || cnt < HashMultiMatchMax ; cnt++){ /* if(phash && hashdelta) loop over multiple offsets */
      if(cnt && (cnt%1000)==0){
	printf("WARNING:refid=%d,mapid=%d(id=%lld),or=1,sc=%d:over %d hashtable offsets:phash=%p:id1=%d,id2=%d,hashscore=%d,offset=%d,or=%d,sc=%d\n",
	       refid,mapid,nanomap->id,scaleID,cnt,phash,phash->id1,phash->id2,phash->hashscore,phash->offset,phash->orientation,phash->scaleID);
	fflush(stdout);
      }

      if(TRACE && phash && nanomap->id == MAP_TRACE && rmap->id == REF_TRACE){
	#pragma omp critical
	{
	  printf("tid=%d,cnt2=%d,refid=%d(id=%lld),mapid=%d,%d(id=%lld),or=1,sc=%d:phash=%p:id1=%d,id2=%d,hashscore=%d,offset=%d,or=%d,sc=%d:wtime=%0.6f\n",
		 tid,cnt,refid,rmap->id,mapid,origmapid,nanomap->id,scaleID,phash,phash->id1,phash->id2,phash->hashscore,phash->offset,phash->orientation,phash->scaleID,wtime());
	  fflush(stdout);
	}
      }

      if(phash){
	if(phash->id1 != refid || phash->id2 != origmapid)
	  break;
	if(!phash->orientation){
	  if(DEBUG && HashMultiMatchMax <= 0) assert(phash->orientation);
	  phash++;// NEW13
	  continue;/* skip excess matches with orientation == 0 */
	}
	if(HashMultiMatchMaxDelta > 0 && phash->hashscore < origphashR->hashscore - HashMultiMatchMaxDelta){
	  phash++;// NEW13
	  continue;
	}

	if(hashScaleDelta>=2 && giter==0 && phash && phash->scaleID != scaleID){// NEW13    
	  phash++;
	  continue;
	}
      }

      refalignXYsd(Y, N, Xrev, M, 1, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, phash, tid, numthreads, maxmatchgroup, matchgroup, 
		   mheap, hashdelta, hashdeltaAdjust,ScoreThreshold2,LogPvThreshold2,AlignedSiteThreshold2);

      if(VERB>=3 && nanomap->id == MAP_TRACE){
	#pragma omp critical
	{
	  printf("refalignSD:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,M=%d,score=%0.3f/%0.3f,logPV=%0.3f/%0.3f,numpairs=%d/%d,Length=%0.3f/%0.3f,repeat=%d:tid=%d,wtime=%0.6f\n",
		 refid,rmap->id, mapid,nanomap->id, align->orientation,nanomap->numsite[0],align->score,ScoreThreshold,align->logPV,LogPvThreshold,align->numpairs,AlignedSiteThreshold, 
		 align->numpairs ? AlignedLength(align,Y) : 0.0, AlignedLengthThreshold, align->repeat,tid,wtime());
	  fflush(stdout);
	}
      }

      if(DEBUG>=2 && RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0 && !(align->repeat >= 0)){
	#pragma omp critical
	{
	  assert(align->repeat >= 0);
	}
      }

      if(!(phash && hashdelta))
	break;
      phash++;

      if(DEBUG) assert(hashdelta);
      /*      if(!hashdelta)
	while(phash->id1 == refid && phash->id2 == origmapid)
	phash++;*/
      if(DEBUG && !(phash->id1 != refid || phash->id2 != origmapid)) assert(HashMultiMatch);
    } // hashMultiMatch loop

    if(MultiMatches && MultiMatchesRev){
      int origmulticnt = align->multicnt;

      for(int J=0;J <= M+1;J++)
	Xrev[J] = X[J]*scale;

      for(int I=0;I <= N+1;I++)
	Yrev[I] = Y[N+1] - Y[N+1-I];

      if(VERB>=2 && rmap->id == REF_TRACE && nanomap->id == MAP_TRACE && N >= 15218){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=1,rev=1,N=%d,M=%d: Y[15218]= %0.4f, Y[15217]= %0.4f\n",refid,rmap->id,mapid,nanomap->id,N,M,Yrev[15218],Yrev[15217]);
	fflush(stdout);
      }

      phash = origphashR;
      for(int cnt = 0; HashMultiMatchMax <= 0 || cnt < HashMultiMatchMax ; cnt++){ /* if(phash && hashdelta) loop over multiple offsets */
	if(cnt && (cnt%1000)==0){
	  printf("WARNING:refid=%d,mapid=%d(id=%lld),or=1,rev=1:over %d hashtable offsets:phash=%p:id1=%d,id2=%d,hashscore=%d,offset=%d,or=%d,sc=%d\n",
		 refid,mapid,nanomap->id,cnt,phash,phash->id1,phash->id2,phash->hashscore,phash->offset,phash->orientation,phash->scaleID);
	  fflush(stdout);
	}

	if(TRACE && phash && nanomap->id == MAP_TRACE && rmap->id == REF_TRACE){
#pragma omp critical
	  {
	    printf("tid=%d,cnt2=%d,scaleID=%d,refid=%d(id=%lld),mapid=%d,%d(id=%lld),or=1,rev=1,sc=%d:phash=%p:id1=%d,id2=%d,hashscore=%d,offset=%d,or=%d,sc=%d:wtime=%0.6f\n",
		   tid,cnt,scaleID,refid,rmap->id,mapid,origmapid,nanomap->id,scaleID,phash,phash->id1,phash->id2,phash->hashscore,phash->offset,phash->orientation,phash->scaleID,wtime());
	    fflush(stdout);
	  }
	}

	if(phash){
	  if(phash->id1 != refid || phash->id2 != origmapid)
	    break;
	  if(!phash->orientation){
	    if(DEBUG && HashMultiMatchMax <= 0) assert(phash->orientation);
	    phash++;// NEW13
	    continue;/* skip excess matches with orientation == 0 */
	  }
	  if(HashMultiMatchMaxDelta > 0 && phash->hashscore < origphashR->hashscore - HashMultiMatchMaxDelta){
	    phash++;// NEW13
	    continue;
	  }
	  if(hashScaleDelta>=2 && giter==0 && phash && phash->scaleID != scaleID){// NEW13    
	    phash++;
	    continue;
	  }
	}

	refalignXYsd(Yrev, N, Xrev, M, 1, scaleID, RKmax[refid+grefend], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, phash, tid, numthreads, 
		     maxmatchgroup, matchgroup, mheap, hashdelta, hashdeltaAdjust,ScoreThreshold2,LogPvThreshold2,AlignedSiteThreshold2,1,N,1,M,1);

	if(VERB>=3 && nanomap->id == MAP_TRACE){
#pragma omp critical
	  {
	    printf("refalignSD:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,M=%d,score=%0.3f/%0.3f,logPV=%0.3f/%0.3f,numpairs=%d/%d,Length=%0.3f/%0.3f,repeat=%d:tid=%d,wtime=%0.6f\n",
		   refid,rmap->id, mapid,nanomap->id, align->orientation,align->rev,nanomap->numsite[0],align->score,ScoreThreshold,align->logPV,LogPvThreshold,align->numpairs,AlignedSiteThreshold, 
		   align->numpairs ? AlignedLength(align,Y) : 0.0, AlignedLengthThreshold, align->repeat,tid,wtime());
	    fflush(stdout);
	  }
	}

	if(DEBUG>=2 && RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0 && !(align->repeat >= 0)){
#pragma omp critical
	  {
	    assert(align->repeat >= 0);
	  }
	}

	if(!(phash && hashdelta))
	  break;
	phash++;

	if(DEBUG) assert(hashdelta);
	/*	if(!hashdelta)
	  while(phash->id1 == refid && phash->id2 == origmapid)
	  phash++;*/
	if(DEBUG && !(phash->id1 != refid || phash->id2 != origmapid)) assert(HashMultiMatch);
      } // MultiMatch loop

      for(int J=0;J <= M+1;J++)
        Xrev[J] = (X[M+1]-X[M+1-J])*scale;

      /* reverse orientation align->Malign[origmulticnt .. align->multicnt - 1] */
      if(DEBUG) assert(YYmap == refmap);
      if(DEBUG) assert(XXmap == Gmap);
      for(int t = origmulticnt; t < align->multicnt; t++){
	Calign *p = align->Malign[t];
	if(DEBUG) assert(p->rev);

	int orientation = p->orientation;
	if(PVERB>=2 || DEBUG>=2){
	  double scoresum = 0.0;
	  for(int u = 0; u <= p->numpairs; u++)
	    scoresum += p->iscore[u];
    
	  if(PVERB>=2 || fabs(scoresum - p->score) > 1e-3){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),M=%d,N=%d: Before flipping Malign[%d]:or=%d,rev=%d,sc=%d:score=%0.7f, iscore[0..%d]= %0.7f (err= %0.7f)\n",
		   refid,rmap->id,mapid,nanomap->id,M,N,t,p->orientation,p->rev,p->scaleID,p->score,p->numpairs,scoresum, p->score - scoresum);
	    fflush(stdout);
	  }

	  if(PVERB>=2){
	    for(int J=0;J <= M+1;J++)
	      Xrev[J] = X[J]*scale;

	    int index = t;
	    if(1){
	      FLOAT *Y = Yrev;
	      FLOAT *X = Xrev;

	      int U = p->numpairs;
	      int IL = p->sites1[0],I;
	      int KL = p->sitesK1[0],K;
	      int JL = p->sites2[0],J;
	      FLOAT x = X[JL], y = Yc(Y,IL,KL);
	      double iscore0;
	      if(p->Lend <= -2)
		iscore0 = ChimScore + Sm(JL,IL,KL,Y);
	      else if(ENDFIX && x <= y && p->Lij1 > 0 && y - Y[p->Lij1 - 1] < x)/* Sbnd(x,y-Y[Lij-1],JL,IL-KL-Lij+1) */
		iscore0 = Sbnd(x,y - Y[p->Lij1 - 1], JL,IL-KL+1-p->Lij1,IL-KL,refid) + Sm(JL,IL,KL,Y);
	      else if(ENDFIX && extend && x >= y && p->Lij2 > 0 && x - X[p->Lij2-1] < y)/* Sbnd(x-X[p->Lij2-1],y,JL+1-p->Lij2,IL-KL) */
		iscore0 = Sbnd(x - X[p->Lij2-1], y, JL+1-p->Lij2,IL-KL,IL-KL,refid) + Sm(JL,IL,KL,Y);
	      else /* Send(min(x,y),JL-1-max(1,p->Lij2),IL-KL+1-max(1,p->Lij1)) */
		iscore0 = Send(min(x, y), JL + 1 - max(1, p->Lij2), IL - KL + 1 - max(1, p->Lij1), IL - KL, refid,0) + Sm(JL,IL,KL, Y);

	      printf("Before Flipping malign[%d]:", index);

	      if(p->Lend <= -2)
		printf("U=%d,score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, ChimScore=%0.6f,Sm=%0.6f(y=%0.4f),iscore[0]=%0.6f(err= %0.6f)\n",
		       U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL,ChimScore,Sm(JL,IL,KL,Y),y,p->iscore[0], iscore0 -p->iscore[0]);
	      else if(x <= y && p->Lij1 > 0 && y - Y[p->Lij1 - 1] < x)
		printf("U=%d,score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,n=%d,n=%d),Sm=%0.6f,iscore[0]=%0.6f(err= %0.6f)\n",
		       U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL, Sbnd(x,y - Y[p->Lij1 - 1], JL,IL-KL+1-p->Lij1,IL-KL,refid),x,y-Y[p->Lij1-1],JL,IL-KL+1-p->Lij1,Sm(JL,IL,KL,Y),p->iscore[0], iscore0 - p->iscore[0]);
	      else if(x >= y && p->Lij2 > 0 && x - X[p->Lij2-1] < y)
		printf("U=%d,score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Liej2=%d, IL=%d,KL=%d,JL=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,n=%d,n=%d),Sm=%0.6f,iscore[0]=%0.6f(err= %0.6f)\n",
		       U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL, Sbnd(x - X[p->Lij2-1], y, JL+1-p->Lij2,IL-KL,IL-KL,refid), x - X[p->Lij2-1], y, JL+1-p->Lij2,IL-KL,Sm(JL,IL,KL,Y),p->iscore[0], iscore0 - p->iscore[0]);
	      else
		printf("U=%d,score=%0.6f,LogPV=%0.2f : Lend=%d, Lij1=%d,Lij2=%d, IL=%d,KL=%d,JL=%d, Send=%0.6f(x=%0.4f,m=%d,n=%d),Sm=%0.6f,iscore[0]=%0.6f -> %0.6f(delta= %0.6f\n",
		       U,p->score,p->logPV, p->Lend, p->Lij1, p->Lij2, IL,KL,JL, Send(min(X[JL], Yc(Y,IL,KL)), JL + 1 - max(1, p->Lij2), IL - KL + 1 - max(1, p->Lij1), IL - KL, refid,0), 
		       min(X[JL], Yc(Y,IL,KL)),  JL + 1 - max(1, p->Lij2),  IL - KL + 1 - max(1, p->Lij1), Sm(JL,IL,KL,Y),p->iscore[0],iscore0, iscore0 - p->iscore[0]);

	      for(int u = 1; u < U; u++, IL = I, KL = K, JL = J){
		I = p->sites1[u];
		K = p->sitesK1[u];
		J = p->sites2[u];

		double Bias,Pen,Gauss,PenSm,OutPen,iscore;
		SintDetail(X[J]-X[JL], Yc(Y,I,K) - Yc(Y,IL,KL), J-JL, I-K-IL, J,I,K,KL,Y,Bias,Pen,Gauss,PenSm,OutPen,iscore,0);
	  
		printf("\t u=%d:I=%d,K=%d,J=%d,G=%d,T=%d,H=%d:x=%0.4f,y=%0.4f:iscore[u]= %0.6f (err= %0.6f)\n",u,I,K,J,IL,KL,JL,X[J]-X[JL],Yc(Y,I,K)-Yc(Y,IL,KL),p->iscore[u],iscore - p->iscore[u]);

	      }

	      x = X[M+1] - X[JL];
	      y = Yc(Y,IL,KL);

	      double iscoreU;
	      if(p->Rend <= -2)
		iscoreU = ChimScore;// assumes biaswtEnd == 0.0
	      else if(ENDFIX && x <= Y[N+1]-y && p->Rij1 <= N && Y[p->Rij1+1] - y < x) /* Sbnd(x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-I, p->Rij1,refid) */
		iscoreU = Sbnd(x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-IL,p->Rij1,refid);
	      else if(ENDFIX && extend && x >= Y[N+1] - y && p->Rij2 <= M && X[p->Rij2+1] - X[JL] < Y[N+1] - y)/* Sbnd(X[p->Rij2+1]-X[JL],Y[N+1]-y, p->Rij2+1-JL,min(N,p->Rij1)+1-IL, min(N, p->Rij1), refid) */
		iscoreU = Sbnd(X[p->Rij2+1]-X[JL],Y[N+1]-y,p->Rij2+1-JL,min(N,p->Rij1)+1-IL,min(N,p->Rij1),refid);    
	      else
		iscoreU = Send(min(X[M+1] - X[JL], Y[N+1] - Yc(Y,IL,KL)), min(M,p->Rij2) + 1 - JL, min(N, p->Rij1) + 1 - IL, min(N, p->Rij1), refid,0);

	      printf("Before Flipping Malign[%d]:", index);

	      if(p->Rend <= -2)
		printf("numpairs=%d,score=%0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,L=%d,J=%d, ChimScore=%0.6f,iscore[U]= %0.6f(err= %0.6f)\n",
		       U, p->score,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL, ChimScore, p->iscore[U], iscoreU - p->iscore[U]);
	      else if(ENDFIX && x <= Y[N+1]-y && p->Rij1 <= N && Y[p->Rij1+1] - y < x)
		printf("numpairs=%d,score=%0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,K=%d,J=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),iscore[U]= %0.6f(err= %0.6f)\n",
		       U, p->score,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL,
		       Sbnd(x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-IL,p->Rij1,refid), x,Y[p->Rij1+1]-y,M+1-JL,p->Rij1+1-IL, p->iscore[U], iscoreU - p->iscore[U]);
	      else if(ENDFIX && extend && x >= Y[N+1] - y && p->Rij2 <= M && X[p->Rij2+1] - X[JL] < Y[N+1] - y)
		printf("numpairs=%d,score=%0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,K=%d,J=%d, Sbnd=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),iscore[U]= %0.6f(err= %0.6f)\n",
		       U, p->score,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL,
		       Sbnd(X[p->Rij2+1]-X[JL],Y[N+1]-y,p->Rij2+1-JL,min(N,p->Rij1)+1-IL,min(N,p->Rij1),refid), X[p->Rij2+1]-X[JL],Y[N+1]-y,p->Rij2+1-JL,min(N,p->Rij1)+1-IL, p->iscore[U], iscoreU - p->iscore[U]);
	      else
		printf("numpairs=%d,score=%0.6f,LogPV=%0.2f : Rend=%d, Rij1=%d,Rij2=%d, I=%d,K=%d,J=%d, Send=%0.6f(x=%0.4f,y=%0.4f,m=%d,n=%d),iscore[U]=%0.6f(err= %0.6f)\n",
		       U, p->score,p->logPV, p->Rend, p->Rij1, p->Rij2, IL,KL,JL,
		       Send(min(X[M+1] - X[JL], Y[N+1] - Yc(Y,IL,KL)), min(M,p->Rij2) + 1 - JL, min(N, p->Rij1) + 1 - IL, min(N, p->Rij1), refid,0), 
		       X[M+1] - X[JL], Y[N+1] - Yc(Y,IL,KL), min(M,p->Rij2) + 1 - JL, min(N, p->Rij1) + 1 - IL, p->iscore[U], iscoreU - p->iscore[U]);

	    }

	    for(int J=0;J <= M+1;J++)
	      Xrev[J] = (X[M+1]-X[M+1-J])*scale;
	  } // (PVERB>=2 || fabs(scoresum - p->score) > 1e-5)
	} // if(PVERB >= 2)

	Calign *nalign = new Calign[1];

	copyrev(nalign, align->Malign[t], 1);

	// need to recompute iscore,outscore, since Sm() terms for aligned labels are assigned to the LEFT interval, which is not symmetric
	RescoreAlign(t,nalign, Xrev, Y, M, N, refid, mapid, rmap, nanomap);

	if(DEBUG/* HERE >=2 */) assert(orientation == nalign->orientation);

	if(PVERB>=3){
	  Calign *p = nalign;
	  int U = p->numpairs;

	  if(p->sites1[U-1] == 19101 && p->sites2[U-1] == 1062){

	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:Malign[%d]: score= %0.6f, numpairs= %d:After RescoreAlign:\n",
		   p->mapid1,rmap->id,p->mapid2,nanomap->id,p->orientation,p->rev,t,p->score,U);
	    fflush(stdout);

	    double sum = 0;
	    for(int T = 0; T <= U; T++){
	      sum += p->iscore[T];
	      if(T <= 0)
		printf("  T=%5d: I=%d,K=%d,J=%d: iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T],p->sitesK1[T],p->sites2[T],p->iscore[T], sum);
	      else if(T < U)
		printf("  T=%5d: I=%d..%d,K=%d..%d,J=%d..%d: outscore[T]= %0.6f, iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T-1],p->sites1[T],p->sitesK1[T-1],p->sitesK1[T],p->sites2[T-1],p->sites2[T],p->outscore[T],p->iscore[T], sum);
	      else
		printf("  T=%5d: iscore[T]= %0.6f, iscoresum= %0.6f\n", T, p->iscore[T], sum);
	    }
	  }
	}

	delete [] align->Malign[t];
	align->Malign[t] = nalign;
	if(DEBUG) assert(!align->Malign[t]->rev);	

	if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	  for(int i = 0; i < align->multimax; i++)
	    for(int j = i+1; j < align->multimax; j++)
	      if(align->Malign[i] == align->Malign[j]){
		printf("MultiMatchesRemoveDupes: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		       rmap->mapid,rmap->id,nanomap->mapid,nanomap->id,orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
		fflush(stdout);
		assert(align->Malign[i] != align->Malign[j]);
	      }
	}

	if(PVERB>=3){
	  Calign *p = align->Malign[t];
	  int U = p->numpairs;

	  if(p->sites1[U-1] == 19101 && p->sites2[U-1] == 1062){

	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:Malign[%d]= %p: score= %0.6f, numpairs= %d:After delete [] Malign[t]\n",
		   p->mapid1,rmap->id,p->mapid2,nanomap->id,p->orientation,p->rev,t,p, p->score,U);
	    fflush(stdout);

	    double sum = 0;
	    for(int T = 0; T <= U; T++){
	      sum += p->iscore[T];
	      if(T <= 0)
		printf("  T=%5d: I=%d,K=%d,J=%d: iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T],p->sitesK1[T],p->sites2[T],p->iscore[T], sum);
	      else if(T < U)
		printf("  T=%5d: I=%d..%d,K=%d..%d,J=%d..%d: outscore[T]= %0.6f, iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T-1],p->sites1[T],p->sitesK1[T-1],p->sitesK1[T],p->sites2[T-1],p->sites2[T],p->outscore[T],p->iscore[T], sum);
	      else
		printf("  T=%5d: iscore[T]= %0.6f, iscoresum= %0.6f\n", T, p->iscore[T], sum);
	    }
	  }
	}
      }

      if(align->numpairs > 0 && align->rev){
	int orientation = align->orientation;
	if(PVERB || (DEBUG && !(align->numpairs > 0 && align->orientation == 1 && align->rev == 1))){
	  double scoresum = 0.0;
	  for(int u = 0; u <= align->numpairs; u++)
	    scoresum += align->iscore[u];

	  printf("refid=%d(id=%lld),mapid=%d(id=%lld):align:or=%d,rev=%d,score=%0.6f,logPV=%0.2f,iscore[0..%d]= %0.6f,Lend=%d,Rend=%d,multicnt=%d, align=%p,Malign=%p: Flipping rev\n",
		 refid,rmap->id,mapid,nanomap->id,align->orientation,align->rev,align->score,align->logPV,align->numpairs,scoresum,align->Lend,align->Rend,align->multicnt,align,align->Malign);
	  fflush(stdout);
	  if(DEBUG/* HERE >=2 */) assert(align->numpairs > 0 && align->orientation == 1 && align->rev == 1);
	}
        Calign *nalign = new Calign[1];

	copyrev(nalign, align, 1);

	// need to recompute iscore,outscore, since Sm() terms for aligned labels are assigned to the LEFT interval, which is not symmetric
	RescoreAlign(-1,nalign, Xrev, Y, M, N, refid, mapid, rmap, nanomap);

        if(DEBUG/* HERE >=2 */)assert(!nalign->rev);
	Calign **Malign = align->Malign;// Malign is NOT saved by copyrev()
	int multicnt = align->multicnt;
	int multimax = align->multimax;
	align->Malign = NULL;
	align->allfree();
	Calign tmp = align[0];	align[0] = nalign[0];	nalign[0] = tmp;
	delete [] nalign;
	align->Malign = Malign;
	align->multicnt = multicnt;
	align->multimax = multimax;
	if(DEBUG) assert(!align->rev);
	if(PVERB/* HERE >=3 */){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:align->bestscore=%0.6f,align->logPV=%0.2f,align->multicnt=%d, align=%p,Malign=%p : After flipping rev\n",
	    refid,rmap->id,mapid,nanomap->id,align->orientation,align->rev,align->score,align->logPV,align->multicnt,align,align->Malign);
	  fflush(stdout);
	}
      }
    }

    if(DEBUG && phash){
      if(HashMultiMatchMax > 0)
	while(phash->id1 == refid && phash->id2 == origmapid)
	  phash++;
      if(DEBUG) assert(phash->id1 != refid || phash->id2 != origmapid);
    }

    phash = origphash;// reset phash for next scaleID

    if(MultiMatches){/* initialize logPV2 for new matchgroups */
      align->logPV2 = align->logPV;
      if(MultiMatches /* NEW && AlignedThreshold(align,Y,ScoreThreshold,LogPvThreshold) */){
	for(int t = lastNumMatchgroup; t < align->multicnt; t++){
	  Calign *p = align->Malign[t];
	  p->logPV2 = p->logPV;
	}
	int orientation = align->orientation;
	if(PVERB){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,pairs=%d,score=%0.6f,logPV=%0.2f(logPV2=%0.2f):lastNumMatchgroup=%d,multicnt=%d:Initializing logPV2 == logPV for Malign[%d..%d]\n",
		 refid,rmap->id,mapid,nanomap->id,align->orientation,align->numpairs,align->score,align->logPV,align->logPV2,lastNumMatchgroup,align->multicnt, lastNumMatchgroup,align->multicnt-1);
	  if(PVERB>=3){
	    for(int t = startNumMatchgroup; t < align->multicnt; t++){
	      Calign *p = align->Malign[t];
	      printf("\t Malign[%d]: or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f,logPV2=%0.2f\n",t,p->orientation,p->rev,p->numpairs,p->score,p->logPV,p->logPV2);
	    }
	  }
	  fflush(stdout);
	}
      }
    }

    if(MultiMatches){ /* remove duplicates from different hashtable matches in align->Malign[lastNumMatchgroup .. align->multicnt-1][] (opposite orientation of query) */
      int origmulticnt = align->multicnt;
      int origlastNumMatchgroup = lastNumMatchgroup;

      if(DEBUG && scale != 1.0) assert(NumScaleFactor > 1);

      for(int J=0;J <= M+1;J++)
	Xrev[J] = (X[M+1]-X[M+1-J]);

      MultiMatchesRemoveDupes(align,lastNumMatchgroup,Y,Xrev,N,M,rmap,nanomap, 1, 0);

      if(TRACE && rmap->id == REF_TRACE && nanomap->id==MAP_TRACE){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d:align->bestscore=%0.6f,align->logPV=%0.2f,align->multicnt=%d -> %d(lastNumMatchgroup=%d -> %d), align=%p\n",
	    refid,rmap->id,mapid,nanomap->id,align->orientation,align->rev,align->score,align->logPV,origmulticnt,align->multicnt,origlastNumMatchgroup,lastNumMatchgroup,align);
	fflush(stdout);
      }
    }

    if(DEBUG && MultiMatches && align->multicnt > 0){
      for(int t = 0; t < align->multicnt; t++){
	Calign *q = align->Malign[t];
	if(DEBUG) assert(q->mapid1 == refid && refid < numrefmaps);
	if(DEBUG) assert(q->mapid2 == mapid && mapid < nummaps);
      }
    }

    if(VERB>=2 && TRACE && rmap->id == REF_TRACE && nanomap->id==MAP_TRACE){
      printf("refid=%d(id=%lld),mapid=%d(id=%lld):MultiMatches=%d,HashMultiMatch=%d,CutFlip=%d\n",
	     refid,rmap->id,mapid,nanomap->id, MultiMatches,HashMultiMatch, CutFlip);
      fflush(stdout);
    }

    if(MultiMatches && HashMultiMatch && CutFlip > 0){/* locate large internal outliers and align the corresponding regions in flipped orientation. If CutFlipEndExpand > 0, also check endoutlier */
      // HERE HERE : If REFSPLIT_FIX>=2 && RefSplit also need to check gaps with CutFlip .. CutFlipSkip label intervals between any two matchgroups with same orientation
      if(nanomap->origmap){
	printf("-CutFlip not implemented without -nosplit 2\n");
	fflush(stdout);
        if(DEBUG) assert(nosplit < 2);
	assert(!nanomap->origmap);
      }

      double myhashdeltaAdjust = 0.0;

      int myAlignedSiteThreshold2 = min(2 /* WAS CutFlip */, AlignedSiteThreshold2);

      if(TRACE && rmap->id == REF_TRACE && nanomap->id==MAP_TRACE){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld):Checking CutFlip for matchgroups %d .. %d\n",refid,rmap->id,mapid,nanomap->id,startNumMatchgroup, align->multicnt - 1);
	for(int t = align->multicnt; --t >= startNumMatchgroup;){
	  Calign *p = align->Malign[t];
	  printf("Malign[%d]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.6f,logPV=%0.2f,numpairs=%d\n",t,refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,p->numpairs);
	}

	fflush(stdout);
      }

      //      double maxscore = smap_min_conf * log(10.0);
      double pthreshold = CutFlipMerge ? log(1.0/CutFlipMerge) : RefSplit ? log(1.0/(Rsplit ? Rsplit : Psplit)) : -smap_min_conf * log(10.0); /* see MERGE_OUTLIERS_CUTFLIP below */

      int startmulticnt = align->multicnt;

      for(int t = startmulticnt; --t >= startNumMatchgroup;){
	Calign *p = align->Malign[t];
	if(DEBUG && MultiMatches && MultiMatchesRev) assert(p->rev==0);
	if(TRACE && rmap->id == REF_TRACE && nanomap->id==MAP_TRACE){
	  printf("Checking Malign[%d] for CutFlip:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.6f,logPV=%0.2f,numpairs=%d\n",t,refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,p->numpairs);
	  fflush(stdout);
	}
	if(!AlignedThreshold(p, Y, ScoreThreshold, LogPvThreshold))
	  continue;

	int orientation = p->orientation;// required for PVERB */
	int U = p->numpairs;
	
	int lastI = p->sites1[0];
	int lastK = p->sitesK1[0];
	int lastJ = p->sites2[0];
	int I,K,J, kLWM;
	  
	for(int k = 1; k < U; k = kLWM + 1, lastI = I, lastK = K, lastJ = J){
	  
	  if(DEBUG) {
	    assert(lastI == p->sites1[k-1]);
	    assert(lastK == p->sitesK1[k-1]);
	    assert(lastJ == p->sites2[k-1]);
	  }

	  I = p->sites1[k];
	  K = p->sitesK1[k];
	  J = p->sites2[k];

	  kLWM = k;
	  double score = p->outscore[k];

	  if(MERGE_OUTLIERS_CUTFLIP){
	    if(score > 0.0)
	      continue;
	    double LWM = score;

	    if(PVERB>=4){
	      printf("\t k=%d:outscore[k]= %0.6f: I=%d..%d,K=%d..%d,J=%d..%d\n",k,p->outscore[k],lastI,I,lastK,K,lastJ,J);
	      fflush(stdout);
	    }

	    for(int T = k+1; T < U; T++){
	      if(PVERB>=4){
		printf("\t k=%d,T=%d:outscore[T]= %0.6f, score[k..T-1]= %0.6f,LWM= %0.6f,kLWM= %d:I=%d..%d,K=%d..%d,J=%d..%d\n",
		       k,T,p->outscore[T],score,LWM,kLWM,lastI,p->sites1[T],lastK,p->sitesK1[T],lastJ,p->sites2[T]);
		fflush(stdout);
	      }
	      score += p->outscore[T];
	      if(score < LWM){
		LWM = score;
		kLWM = T;
	      }
	      if(score - LWM > pthreshold)/* Negative score region may not have a +ve scoring subregion with score >= pthreshold */
		break;
	      if(score > 0.0)
		break;
	    }

	    score = LWM;
	    if(kLWM > k){
	      I = p->sites1[kLWM];
	      K = p->sitesK1[kLWM];
	      J = p->sites2[kLWM];
	    }

	    if(PVERB>=3){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),t=%d:or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,k=%d..%d: I=%d..%d,J=%d..%d,K=%d..%d,outscore[%d..%d]=%0.6f,smap_min_conf=%0.2f,pthreshold=%0.2f\n",
		     refid,rmap->id,mapid,nanomap->id,t,p->orientation,p->score,p->logPV,U,N,M,k,kLWM,lastI,I,lastJ,J,lastK,K,k-1,kLWM,score,smap_min_conf,pthreshold);
	      printf("\t p->sites1[%d..%d]= %d..%d,p->sites2[%d..%d]= %d...%d\n",k-1,kLWM,p->sites1[k-1],p->sites1[kLWM],k-1,kLWM,p->sites2[k-1],p->sites2[kLWM]);
	      fflush(stdout);
	    }
	  }

	  if(score >= -max(0.0,smap_min_conf))
	    continue;/* not an outlier */

	  int IMIN = max(1, lastI-lastK - CutFlipExpand);
	  int IMAX = min(N, I + CutFlipExpand);
	  int jmin = max(1, (M+1-J) - CutFlipExpand);
	  int jmax = min(M, (M+1-lastJ) + CutFlipExpand);

	  CHashMatch hash;
	  hash.hashscore = 1;
	  hash.orientation = p->orientation ? 0 : 1;

	  int origmulticnt = align->multicnt;

	  if(J - lastJ < CutFlip)
	    continue;/* not enough labels to align */

	  if(CutFlipSkip > CutFlip && J - lastJ >= CutFlipSkip)
	    continue;/* Too many labels : this inversion matchgroup should already have been found by the hashtable */

	  if(p->orientation){
	    for(int j=0;j <= M+1;j++)
	      Xrev[j] = (X[M+1]-X[M+1-j])*scale;
	  } else {
	    for(int j=0; j <= M+1;j++)
	      Xrev[j] = X[j]*scale;
	  }
	  double delY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	  double delX = Xrev[J] - Xrev[lastJ];
	  bool Inversion = (CutFlipMaxErr >= 2.0 || fabs(delX-delY)*2.0/(delX+delY) <= CutFlipMaxErr);// check for Inversion
	  bool InvDup = CutFlipDupExpand && (I-lastI <= 1 || J-lastJ-(I-lastI-1) >= CutFlip || (delX - delY)/(delX+delY) > CutFlipMinErr);// check for Inverted Duplication

	  if(PVERB>=3){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:I=%d..%d,J=%d..%d:delY= %0.4f, delX= %0.4f : Inversion=%d,InvDup=%d\n",
		   refid,rmap->id,mapid,nanomap->id,p->orientation,lastI,I,lastJ,J,delY,delX,Inversion?1:0,InvDup?1:0);
	    //	    printf("\t CutFlipDupExpand=%d, CutFlipMinErr= %0.6f\n",CutFlipDupExpand, CutFlipMinErr);
	    fflush(stdout);
	  }

	  if(!Inversion && !InvDup)
	    continue;

	  /* If original alignment was normal, perform a reversed alignment */
	  if(p->orientation){
	    for(int j=0; j <= M+1;j++)
	      Xrev[j] = X[j]*scale;
	  } else {
	    for(int j=0;j <= M+1;j++)
	      Xrev[j] = (X[M+1]-X[M+1-j])*scale;
	  }

	  if(Inversion){/* check for Inversion */
	    double myLogPvThreshold3 = LogPvThreshold3;
	    if(CutFlipBC >= 2)
	      myLogPvThreshold3 += log(max(1.0, jmax-jmin+1.0 - CutFlip) * max(1.0, IMAX-IMIN+1.0 -CutFlip)) / log(10.0);

	    if(PVERB>=2){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),t=%d:or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,k=%d..%d,dX=%0.3f,dY=%0.3f: checking CutFlip for I=%d..%d,J=%d..%d,K=%d..%d,outscore=%0.6f(LogPvThreshold3=%0.2f,ScoreThreshold3=%0.2f):i=%d..%d,j=%d..%d\n",
		     refid,rmap->id,mapid,nanomap->id,t,p->orientation,p->score,p->logPV,U,N,M,k,kLWM,delX,delY,lastI,I,lastJ,J,lastK,K,score,myLogPvThreshold3,ScoreThreshold3,IMIN,IMAX,jmin,jmax);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(LogPvThreshold3 >= 0.0);

	    hash.offset = 0.5 * (Yc(Y,lastI,lastK) - Xrev[M+1-J] + Yc(Y,I,K) - Xrev[M+1-lastJ]);/* NOTE : lastJ and J are reversed, since we want alignment to be flipped */
	    if(ShiftOffset1 <= 30){
	      hash.MinLoc2 = Xrev[jmin];
	      hash.MaxLoc2 = Xrev[jmax];
	    }
	    refalignXYsd(Y, N, Xrev, M, 1-orientation, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, 
			 numthreads, maxmatchgroup, matchgroup, mheap, hashdelta, myhashdeltaAdjust,ScoreThreshold3,myLogPvThreshold3,myAlignedSiteThreshold2, IMIN,IMAX,jmin,jmax);

	    if(align->multicnt > origmulticnt){
	      for(int u = align->multicnt; --u >= origmulticnt;){
		Calign *q = align->Malign[u];
		q->logPV2 = max(q->logPV + 0.01, LogPvThreshold2); // WAS p->logPV + (LogPvThreshold - myLogPvThreshold3);
		if(PVERB>=2){
		  printf("\t CutFlip matchgroup %d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,score=%0.6f,logPV=%0.2f(logPV2=%0.2f),U=%d\n",
			 u,refid,rmap->id,mapid,nanomap->id,q->orientation,q->score,q->logPV,q->logPV2,q->numpairs);
		  fflush(stdout);
		}
		if(DEBUG) assert(q->logPV >= myLogPvThreshold3);
	      }
	      origmulticnt = align->multicnt;
	    }
	  }

	  if(InvDup){/* check for Inverted Duplication : align with reference region on either side of outlier */
	    /* first try left side */
	    IMIN = max(1, lastI-lastK - (J-lastJ) - CutFlipDupExpand);
	    IMAX = min(N, lastI + CutFlipExpand);
	    double myLogPvThreshold3 = LogPvThreshold3;
	    if(CutFlipBC)
	      myLogPvThreshold3 += log(2.0 * (CutFlipBC >= 2 ? (max(1.0, jmax-jmin+1.0 - CutFlip) * max(1.0, IMAX-IMIN+1.0 -CutFlip)) : 1.0)) / log(10.0);
	    if(PVERB>=2){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),t=%d:or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,k=%d..%d,dX=%0.3f,dY=%0.3f: checking CutFlipInvDup for I=%d..%d,J=%d..%d,K=%d..%d,outscore=%0.6f(LogPvThreshold3=%0.2f,ScoreThreshold3=%0.2f):i=%d..%d,j=%d..%d\n",
		     refid,rmap->id,mapid,nanomap->id,t,p->orientation,p->score,p->logPV,U,N,M,k,kLWM,delX,delY,lastI,I,lastJ,J,lastK,K,score,myLogPvThreshold3,ScoreThreshold3,IMIN,IMAX,jmin,jmax);
	      fflush(stdout);
	    }
	    // WAS440	    hash.offset = 0.5 * (Yc(Y,lastI,lastK) - Xrev[M+1-J] + Yc(Y,I,K) - Xrev[M+1-lastJ]);/* NOTE : lastJ and J are reversed, since we want alignment to be flipped */
	    hash.offset = 0.5 * (Y[max(1,lastI-lastK - (J-lastJ))] - Xrev[M+1-J] + Y[lastI] - Xrev[M+1-lastJ]);/* NOTE : lastJ and J are reversed, since we want alignment to be flipped */
	    if(ShiftOffset1 <= 30){
	      hash.MinLoc2 = Xrev[jmin];
	      hash.MaxLoc2 = Xrev[jmax];
	    }
	    refalignXYsd(Y, N, Xrev, M, 1-orientation, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid,
			 numthreads, maxmatchgroup, matchgroup, mheap, hashdelta, myhashdeltaAdjust,ScoreThreshold3,myLogPvThreshold3,myAlignedSiteThreshold2, IMIN,IMAX,jmin,jmax);

	    /* next try right side */
	    IMIN = max(1, I-K - CutFlipExpand);
	    IMAX = min(N, I + (J-lastJ) + CutFlipDupExpand);
	    myLogPvThreshold3 = LogPvThreshold3;
	    if(CutFlipBC)
	      myLogPvThreshold3 += log(2.0 * (CutFlipBC >= 2 ? (max(1.0, jmax-jmin+1.0 - CutFlip) * max(1.0, IMAX-IMIN+1.0 -CutFlip)) : 1.0)) / log(10.0);
	    if(PVERB>=2){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),t=%d:or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,k=%d..%d,dX=%0.3f,dY=%0.3f: checking CutFlipInvDup for I=%d..%d,J=%d..%d,K=%d..%d,outscore=%0.6f(LogPvThreshold3=%0.2f,ScoreThreshold3=%0.2f):i=%d..%d,j=%d..%d\n",
		     refid,rmap->id,mapid,nanomap->id,t,p->orientation,p->score,p->logPV,U,N,M,k,kLWM,delX,delY,lastI,I,lastJ,J,lastK,K,score,myLogPvThreshold3,ScoreThreshold3,IMIN,IMAX,jmin,jmax);
	      fflush(stdout);
	    }

	    // WAS440	    hash.offset = 0.5 * (Yc(Y,lastI,lastK) - Xrev[M+1-J] + Yc(Y,I,K) - Xrev[M+1-lastJ]);/* NOTE : lastJ and J are reversed, since we want alignment to be flipped */
	    hash.offset = 0.5 *(Y[I-K] - Xrev[M+1-J] + Y[min(N,I+(J-lastJ))] - Xrev[M+1-lastJ]);/* NOTE : lastJ and J are reversed, since we want alignment to be flipped */
	    if(ShiftOffset1 <= 30){
	      hash.MinLoc2 = Xrev[jmin];
	      hash.MaxLoc2 = Xrev[jmax];
	    }

	    refalignXYsd(Y, N, Xrev, M, 1-orientation, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid,
			 numthreads, maxmatchgroup, matchgroup, mheap, hashdelta, myhashdeltaAdjust,ScoreThreshold3,myLogPvThreshold3,myAlignedSiteThreshold2, IMIN,IMAX,jmin,jmax);

	    if(align->multicnt > origmulticnt){
	      for(int u = align->multicnt; --u >= origmulticnt;){
		Calign *q = align->Malign[u];
		q->logPV2 = max(q->logPV + 0.01, LogPvThreshold2); // WAS p->logPV + (LogPvThreshold - myLogPvThreshold3);
		if(PVERB>=2){
		  printf("\t CutFlipInvDup matchgroup %d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,score=%0.6f,logPV=%0.2f(logPV2=%0.2f),U=%d\n",
			 u,refid,rmap->id,mapid,nanomap->id,q->orientation,q->score,q->logPV,q->logPV2,q->numpairs);
		  fflush(stdout);
		}
		if(DEBUG) assert(q->logPV >= myLogPvThreshold3);
	      }
	      origmulticnt = align->multicnt;
	    }

	  }
	}
	
	if(CutFlipEndExpand > 0){// Also check EndOutliers 
	  double myhashdelta = max(hashdelta, (double)max(CutFlipExpand, CutFlipEndExpand));

	  I = p->sites1[0];
	  K = p->sitesK1[0];
	  J = p->sites2[0];
	  if(p->Lend <= -2 && min(I-K,J) >= CutFlip && (CutFlipSkip <= CutFlip || min(I-K,J) < CutFlipSkip)){/* end outlier on left end */
	    /* First try inverted matchgroup with left end of reference */

	     /* check if there is already a matchgroup on this left end outlier either with the query OR the reference extending at least CutFlipEndFilter labels from I,J */
	    int IL=I,JL=J;
	    int T = startmulticnt;
	    for(; --T >= 0; ){
	      Calign *q = align->Malign[T];
	      int UT = q->numpairs;
	      IL = q->sites1[0] - q->sitesK1[0];
	      JL = (q->orientation == p->orientation) ? q->sites2[0] : M + 1 - q->sites2[UT - 1];
	      
	      if(I - IL >= CutFlipEndFilter || J - JL >= CutFlipEndFilter)
		break;/* found matchgroup extending sufficiently far into left endoutlier region (of query OR reference) */
	    }

	    if(T >= 0 && PVERB >=2){
	      Calign *q = align->Malign[T];
	      int UT = q->numpairs;
	      int IR = q->sites1[UT - 1];
	      int JR = (q->orientation == p->orientation) ? q->sites2[UT - 1] : M + 1 - q->sites2[0];
	      if(DEBUG) assert(JL <= JR);
	      
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld):or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,Lend=%d:I=%d,K=%d,J=%d: left Endoutliers already has a matchgroup[T=%d]:or=%d,IL=%d..%d,J=%d..%d\n",
		     refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,p->numpairs,N,M,p->Lend,I,K,J,T,q->orientation,IL,IR,JL,JR);
	      fflush(stdout);
	    }

	    if(T < 0){/* no other matchgroup found in left endoutlier region of query OR reference */

	      int IMIN = max(1, I - K - J - CutFlipEndExpand);
	      int IMAX = min(N, I + CutFlipExpand);
	      int jmin = max(1, (M+1-J) - CutFlipExpand);
	      int jmax = M;

	      CHashMatch hash;
	      hash.hashscore = 1;
	      hash.orientation = (p->orientation ? 0 : 1);
	    
	      int origmulticnt = align->multicnt;

	      double myLogPvThreshold4 = LogPvThreshold4 ;
	      if(0 && CutFlipBC)// NOTE : CutFlipBC is now applied in output_smap.cpp
		myLogPvThreshold4 += log(max(1.0, jmax-jmin+1.0 - CutFlip) * max(1.0, IMAX-IMIN+1.0 - CutFlip)) / log(10.0);

	      if(PVERB>=2){
		printf("refid=%d(id=%lld),mapid=%d(id=%lld):or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,Lend=%d: checking CutFlip for left Endoutliers I=%d,K=%d,J=%d (LogPvThreshold4=%0.2f,ScoreThreshold4=%0.2f):I=%d..%d,J=%d..%d\n",
		       refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,U,N,M,p->Lend,I,K,J,myLogPvThreshold4,ScoreThreshold4,IMIN,IMAX,jmin,jmax);
		fflush(stdout);
	      }
	      if(DEBUG) assert(myLogPvThreshold4 >= 0.0);

	      if(!p->orientation){/* If original alignment was normal, perform a reversed alignment */

		for(int j=0;j <= M+1;j++)
		  Xrev[j] = (X[M+1]-X[M+1-j])*scale;

		hash.offset = Yc(Y,I,K) - Xrev[M];
		if(ShiftOffset1 <= 30){
		  hash.MinLoc2 = Xrev[jmin];
		  hash.MaxLoc2 = Xrev[jmax];
		}

		refalignXYsd(Y, N, Xrev, M, 1, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
			     maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN,IMAX,jmin,jmax);
	      } else {
		if(scaleID > 0){
		  for(int j=0; j <= M+1;j++)
		    Xrev[j] = X[j]*scale;

		  hash.offset = Yc(Y,I,K) - Xrev[M];
		  if(ShiftOffset1 <= 30){
		    hash.MinLoc2 = Xrev[jmin];
		    hash.MaxLoc2 = Xrev[jmax];
		  }

		  refalignXYsd(Y, N, Xrev, M, 0, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
			       maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN, IMAX, jmin, jmax);
		} else {
		  hash.offset = Yc(Y,I,K) - X[M];
		  if(ShiftOffset1 <= 30){
		    hash.MinLoc2 = X[jmin];
		    hash.MaxLoc2 = X[jmax];
		  }

		  refalignXYsd(Y, N, X, M, 0, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
			       maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN, IMAX, jmin, jmax);
		}
	      }

	      if(align->multicnt > origmulticnt){
		for(int u = align->multicnt; --u >= origmulticnt;){
		  Calign *q = align->Malign[u];
		  q->logPV2 = max(q->logPV + 0.01, LogPvThreshold2); // WAS p->logPV + (LogPvThreshold - myLogPvThreshold3);
		  if(PVERB>=2){
		    printf("\t End CutFlip matchgroup %d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,score=%0.6f,logPV=%0.2f(logPV2=%0.2f),U=%d\n",
			   u,refid,rmap->id,mapid,nanomap->id,q->orientation,q->score,q->logPV,q->logPV2,q->numpairs);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(q->logPV >= myLogPvThreshold4);
		}
		origmulticnt = align->multicnt;
	      }
	    }
	    
	    if(T < 0 || !(J - JL >= CutFlipEndFilter)){/* also look for inverted  matchgroup with right end of reference, that crosses the main matchgroup */
	      I = p->sites1[U-1];
	      K = p->sitesK1[U-1];
	      int IR = I;
	      int T = startmulticnt;
	      for(; --T >= 0;){
		Calign *q = align->Malign[T];
		int UT = q->numpairs;
		IR = q->sites1[UT - 1];
		
		if(IR - I >= CutFlipEndFilter)/* No need to check for region in query, since it is already known there is no current matchgroup in that region, otherwise J-JL >= CutFlipEndFilter, see above */
		  break;/* found matchgroup extending sufficiently far in right reference region */
	      }
	      
	      if(T >= 0 && PVERB >= 2){
		Calign *q = align->Malign[T];
		int UT = q->numpairs;
		int IL = q->sites1[0] - q->sitesK1[0];
		int JL = (q->orientation == p->orientation) ? q->sites2[0] : M + 1 - q->sites2[UT - 1];
		int JR = (q->orientation == p->orientation) ? q->sites2[UT - 1] : M + 1 - q->sites2[0];
		if(DEBUG) assert(JL <= JR);

		printf("refid=%d(id=%lld),mapid=%d(id=%lld):or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,Lend=%d:I=%d,K=%d,J=%d: right ref Endoutlier already has a matchgroup[T=%d]:or=%d,IL=%d..%d,J=%d..%d\n",
		     refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,p->numpairs,N,M,p->Lend,I,K,J,T,q->orientation,IL,IR,JL,JR);
		fflush(stdout);
	      }

	      if(T < 0){/* no other matchgroup found in left qry endoutlier or right ref endoutlier region */
		int IMIN = max(1, I - CutFlipExpand);
		int IMAX = min(N, I + J + CutFlipEndExpand);
		int jmin = max(1, (M+1-J) - CutFlipExpand);
		int jmax = M;
		
		CHashMatch hash;
		hash.hashscore = 1;
		hash.orientation = (p->orientation ? 0 : 1);

		int origmulticnt = align->multicnt;

		double myLogPvThreshold4 = LogPvThreshold4 ;
		if(0 && CutFlipBC)// NOTE : CutFlipBC is now applied in output_smap.cpp
		  myLogPvThreshold4 += log(max(1.0, jmax-jmin+1.0 - CutFlip) * max(1.0, IMAX-IMIN+1.0 - CutFlip)) / log(10.0);

		if(PVERB>=2){
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld):or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,Lend=%d: checking CutFlip for left qry & right ref Endoutlier I=%d,K=%d,J=%d (LogPvThreshold4=%0.2f,ScoreThreshold4=%0.2f):I=%d..%d,J=%d..%d\n",
			 refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,U,N,M,p->Lend,I,K,J,myLogPvThreshold4,ScoreThreshold4,IMIN,IMAX,jmin,jmax);
		  fflush(stdout);
		}
		if(DEBUG) assert(myLogPvThreshold4 >= 0.0);

		if(!p->orientation){/* If original alignment was normal, perform a reversed alignment */

		  for(int j=0;j <= M+1;j++)
		    Xrev[j] = (X[M+1]-X[M+1-j])*scale;

		  // WAS440		  hash.offset = Yc(Y,I,K) - Xrev[M];
		  hash.offset = Yc(Y,I,K) - Xrev[M+1-J];
		  if(ShiftOffset1 <= 30){
		    hash.MinLoc2 = Xrev[jmin];
		    hash.MaxLoc2 = Xrev[jmax];
		  }

		  refalignXYsd(Y, N, Xrev, M, 1, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
			       maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN,IMAX,jmin,jmax);
		} else {
		  if(scaleID > 0){
		    for(int j=0; j <= M+1;j++)
		      Xrev[j] = X[j]*scale;

		    // WAS440		  hash.offset = Yc(Y,I,K) - Xrev[M];
		    hash.offset = Yc(Y,I,K) - Xrev[M+1-J];
		    if(ShiftOffset1 <= 30){
		      hash.MinLoc2 = Xrev[jmin];
		      hash.MaxLoc2 = Xrev[jmax];
		    }

		    refalignXYsd(Y, N, Xrev, M, 0, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
				 maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN, IMAX, jmin, jmax);
		  } else {
		    // WAS440		  hash.offset = Yc(Y,I,K) - X[M];
		    hash.offset = Yc(Y,I,K) - X[M+1-J];
		    if(ShiftOffset1 <= 30){
		      hash.MinLoc2 = X[jmin];
		      hash.MaxLoc2 = X[jmax];
		    }

		    refalignXYsd(Y, N, X, M, 0, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
				 maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN, IMAX, jmin, jmax);
		  }
		}

		if(align->multicnt > origmulticnt){
		  for(int u = align->multicnt; --u >= origmulticnt;){
		    Calign *q = align->Malign[u];
		    q->logPV2 = max(q->logPV + 0.01, LogPvThreshold2); // WAS p->logPV + (LogPvThreshold - myLogPvThreshold3);
		    if(PVERB>=2){
		      printf("\t End CutFlip matchgroup %d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,score=%0.6f,logPV=%0.2f(logPV2=%0.2f),U=%d\n",
			     u,refid,rmap->id,mapid,nanomap->id,q->orientation,q->score,q->logPV,q->logPV2,q->numpairs);
		      fflush(stdout);
		    }
		    if(DEBUG) assert(q->logPV >= myLogPvThreshold4);
		  }
		  origmulticnt = align->multicnt;
		}
	      }
	    }
	  }

	  I = p->sites1[U-1];
	  K = p->sitesK1[U-1];
	  J = p->sites2[U-1];
	  if(p->Rend <= -2 && min(N+1-I,M+1-J) >= CutFlip && (CutFlipSkip <= CutFlip || min(N+1-I,M+1-J) < CutFlipSkip)){/* end outlier on right end */
	    /* First try inverted matchgroup with right end of reference */

	    /* check if there is already a matchgroup on this right end outlier either with the query OR the reference extending at least CutFlipEndFilter labels from I,J */
	    int IR= I, JR = J;
	    int T = startmulticnt;
	    for(; --T >= 0; ){
	      Calign *q = align->Malign[T];
	      int UT = q->numpairs;

	      IR = q->sites1[UT - 1];
	      JR = (q->orientation == p->orientation) ? q->sites2[UT - 1] : M + 1 - q->sites2[0];

	      if(IR - I >= CutFlipEndFilter || JR - J >= CutFlipEndFilter)
		break;/* found matchgroup extending sufficiently far into right endoutlier region (of query OR reference) */
	    }
	    
	    if(T >= 0 && PVERB >= 2){
	      Calign *q = align->Malign[T];
	      int UT = q->numpairs;
	      int IL = q->sites1[0] - q->sitesK1[0];
	      int JL = (q->orientation == p->orientation) ? q->sites2[0] : M + 1 - q->sites2[UT - 1];
	      if(DEBUG) assert(JL <= JR);
	      
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld):or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,Rend=%d:I=%d,K=%d,J=%d: right Endoutlier already has a matchgroup[T=%d]:I=%d..%d,JR=%d..%d\n",
		     refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,p->numpairs,N,M,p->Rend,I,K,J,T,IL,IR,JL,JR);
	      fflush(stdout);
	    }

	    if(T < 0){/* no other matchgroup found in right endoutlier region of query OR reference */
	      int IMIN = max(1, I-K - CutFlipExpand);
	      int IMAX = min(N, I + (M+1-J) + CutFlipEndExpand);
	      int jmin = 1;
	      int jmax = min(M, (M+1-J) + CutFlipExpand);

	      CHashMatch hash;
	      hash.hashscore = 1;
	      hash.orientation = (p->orientation ? 0 : 1);
	    
	      int origmulticnt = align->multicnt;

	      double myLogPvThreshold4 = LogPvThreshold4 ;
	      if(0 && CutFlipBC)// NOTE : CutFlipBC is now applied in output_smap.cpp
		myLogPvThreshold4 += log(max(1.0,jmax-jmin+1.0 - CutFlip) * max(1.0,IMAX-IMIN+1.0 - CutFlip)) / log(10.0);

	      if(PVERB>=2){
		printf("refid=%d(id=%lld),mapid=%d(id=%lld):or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,Rend=%d: checking CutFlip for right Endoutlier I=%d,K=%d,J=%d (LogPvThreshold4=%0.2f,ScoreThreshold4=%0.2f):I=%d..%d,J=%d..%d\n",
		       refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,U,N,M,p->Rend,I,K,J,myLogPvThreshold4,ScoreThreshold4,IMIN,IMAX,jmin,jmax);
		fflush(stdout);
	      }
	      if(DEBUG) assert(myLogPvThreshold4 >= 0.0);

	      if(!p->orientation){/* If original alignment was normal, perform a reversed alignment */

		for(int j=0;j <= M+1;j++)
		  Xrev[j] = (X[M+1]-X[M+1-j])*scale;

		hash.offset = Yc(Y,I,K) - Xrev[1];
		if(ShiftOffset1 <= 30){
		  hash.MinLoc2 = Xrev[jmin];
		  hash.MaxLoc2 = Xrev[jmax];
		}

		refalignXYsd(Y, N, Xrev, M, 1, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
			     maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN,IMAX,jmin,jmax);
	      } else {
		if(scaleID){
		  for(int j=0; j <= M+1;j++)
		    Xrev[j] = X[j]*scale;

		  hash.offset = Yc(Y,I,K) - Xrev[1];
		  if(ShiftOffset1 <= 30){
		    hash.MinLoc2 = Xrev[jmin];
		    hash.MaxLoc2 = Xrev[jmax];
		  }

		  refalignXYsd(Y, N, Xrev, M, 0, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
			       maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN, IMAX, jmin, jmax);
		} else {
		  hash.offset = Yc(Y,I,K) - X[1];
		  if(ShiftOffset1 <= 30){
		    hash.MinLoc2 = X[jmin];
		    hash.MaxLoc2 = X[jmax];
		  }

		  refalignXYsd(Y, N, X, M, 0, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads,
			       maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN, IMAX, jmin, jmax);
		}
	      }

	      if(align->multicnt > origmulticnt){
		for(int u = align->multicnt; --u >= origmulticnt;){
		  Calign *q = align->Malign[u];
		  q->logPV2 = max(q->logPV + 0.01, LogPvThreshold2); // WAS p->logPV + (LogPvThreshold - myLogPvThreshold3);
		  if(PVERB>=2){
		    printf("\t End CutFlip matchgroup %d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,score=%0.6f,logPV=%0.2f(logPV2=%0.2f),U=%d\n",
			   u,refid,rmap->id,mapid,nanomap->id,q->orientation,q->score,q->logPV,q->logPV2,q->numpairs);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(q->logPV >= myLogPvThreshold4);
		}
		origmulticnt = align->multicnt;
	      }
	    }
	    
	    if(T < 0 || !(JR - J >= CutFlipEndFilter)){/* also look for inverted match group with left end of reference, that crosses the main matchgroup */
	      I = p->sites1[0];
	      K = p->sitesK1[0];
	      int IL = I;
	      int T = startmulticnt;
	      for(; --T >= 0;){
		Calign *q = align->Malign[T];
		//	int UT = q->numpairs;
		IL = q->sites1[0] - q->sitesK1[0];
		if(I - IL >= CutFlipEndFilter)/* No need to check for region in query, since it is already known there is no current matchgroup in that region, otherwise JR - J >= CutFlipEndFilter, see above */
		  break;
	      }

	      if(T >= 0 && PVERB >= 2){
		Calign *q = align->Malign[T];
		int UT = q->numpairs;
		int IR = q->sites1[UT-1];
		int JL = (q->orientation == p->orientation) ? q->sites2[0] : M + 1 - q->sites2[UT - 1];
		int JR = (q->orientation == p->orientation) ? q->sites2[UT - 1] : M + 1 - q->sites2[0];
		if(DEBUG) assert(JL <= JR);
		
		printf("refid=%d(id=%lld),mapid=%d(id=%lld):or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,Lend=%d:I=%d,K=%d,J=%d: left ref Endoutlier already has a matchgroup[T=%d]:or=%d,IL=%d..%d,J=%d..%d\n",
		       refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,p->numpairs,N,M,p->Lend,I,K,J,T,q->orientation,IL,IR,JL,JR);
		fflush(stdout);
	      }

	      if(T < 0){/* no other matchgroup found in right qry endoutlier or left ref endoutlier region */
		int IMIN = max(1, I-K-(M+1-J)-CutFlipEndExpand);
		int IMAX = min(N, I + CutFlipExpand);
		int jmin = 1;
		int jmax = min(M, (M+1-J) + CutFlipExpand);

		CHashMatch hash;
		hash.hashscore = 1;
		hash.orientation = (p->orientation ? 0 : 1);
	    
		int origmulticnt = align->multicnt;

		double myLogPvThreshold4 = LogPvThreshold4 ;
		if(0 && CutFlipBC)// NOTE : CutFlipBC is now applied in output_smap.cpp
		  myLogPvThreshold4 += log(max(1.0,jmax-jmin+1.0 - CutFlip) * max(1.0,IMAX-IMIN+1.0 - CutFlip)) / log(10.0);

		if(PVERB>=2){
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld):or=%d,score=%0.6f,logPV=%0.2f,U=%d,N=%d,M=%d,Rend=%d: checking CutFlip for right qry and left ref Endoutlier I=%d,K=%d,J=%d (LogPvThreshold4=%0.2f,ScoreThreshold4=%0.2f):I=%d..%d,J=%d..%d\n",
			 refid,rmap->id,mapid,nanomap->id,p->orientation,p->score,p->logPV,U,N,M,p->Rend,I,K,J,myLogPvThreshold4,ScoreThreshold4,IMIN,IMAX,jmin,jmax);
		  fflush(stdout);
		}
		if(DEBUG) assert(myLogPvThreshold4 >= 0.0);

		if(!p->orientation){/* If original alignment was normal, perform a reversed alignment */

		  for(int j=0;j <= M+1;j++)
		    Xrev[j] = (X[M+1]-X[M+1-j])*scale;

		  // WAS440		  hash.offset = Yc(Y,I,K) - Xrev[1];
		  hash.offset = Y[I] - Xrev[M+1-J];
		  if(ShiftOffset1 <= 30){
		    hash.MinLoc2 = Xrev[jmin];
		    hash.MaxLoc2 = Xrev[jmax];
		  }

		  refalignXYsd(Y, N, Xrev, M, 1, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
			       maxmatchgroup, matchgroup, mheap, myhashdelta,myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN,IMAX,jmin,jmax);
		} else {
		  if(scaleID){
		    for(int j=0; j <= M+1;j++)
		      Xrev[j] = X[j]*scale;

		    // WAS440		    hash.offset = Yc(Y,I,K) - Xrev[1];
		    hash.offset = Y[I] - Xrev[M+1-J];
		    if(ShiftOffset1 <= 30){
		      hash.MinLoc2 = Xrev[jmin];
		      hash.MaxLoc2 = Xrev[jmax];
		    }

		    refalignXYsd(Y, N, Xrev, M, 0, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
				 maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN, IMAX, jmin, jmax);
		  } else {
		    // WAS440               hash.offset = Yc(Y,I,K) - X[1];
		    hash.offset = Y[I] - X[M+1-J];
		    if(ShiftOffset1 <= 30){
		      hash.MinLoc2 = X[jmin];
		      hash.MaxLoc2 = X[jmax];
		    }

		    refalignXYsd(Y, N, X, M, 0, scaleID, RKmax[refid], A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, align, rmap, nanomap, refid, mapid, XPen, &hash, tid, numthreads, 
				 maxmatchgroup, matchgroup, mheap, myhashdelta, myhashdeltaAdjust,ScoreThreshold4,myLogPvThreshold4,myAlignedSiteThreshold2, IMIN, IMAX, jmin, jmax);
		  }
		}

		if(align->multicnt > origmulticnt){
		  for(int u = align->multicnt; --u >= origmulticnt;){
		    Calign *q = align->Malign[u];
		    q->logPV2 = max(q->logPV + 0.01, LogPvThreshold2); // WAS p->logPV + (LogPvThreshold - myLogPvThreshold3);
		    if(PVERB>=2){
		      printf("\t End CutFlip matchgroup %d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,score=%0.6f,logPV=%0.2f(logPV2=%0.2f),U=%d\n",
			     u,refid,rmap->id,mapid,nanomap->id,q->orientation,q->score,q->logPV,q->logPV2, q->numpairs);
		      fflush(stdout);
		    }
		    if(DEBUG) assert(q->logPV >= myLogPvThreshold4);
		  }
		  origmulticnt = align->multicnt;
		}
	      }
	    }
	  }
	}
      }

      if(align->multicnt > startmulticnt){
	int origmulticnt = align->multicnt;

	lastNumMatchgroup = startNumMatchgroup;/* repeat duplicate check over all matchgroups for current scaleID */

	MultiMatchesRemoveDupes(align,lastNumMatchgroup,Y,X,N,M,rmap,nanomap, -1, RefSplit ? 1 : 0);

	if(TRACE && rmap->id == REF_TRACE && nanomap->id==MAP_TRACE){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld):align->bestscore=%0.6f,align->logPV=%0.2f,align->multicnt=%d -> %d,align=%p\n",
		 refid,rmap->id,mapid,nanomap->id,align->score,align->logPV,origmulticnt,align->multicnt,align);
	  fflush(stdout);
	}
      }

      align->logPV2 = max(align->logPV, align->logPV2);// NEW12 : in rare cases endoutlier CutFlip alignment may become the best alignment 

    } // if(MultiMatches && HashMultiMatch && CutFlip > 0)


    // NOTE : after this (till end of scaleID loop) startNumMatchgroup may no longer be valid and lastNumMatchgroup should match align->multicnt

    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   refid,rmap->id,mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }

    if(MultiMatches && scaleID > 0 && hashScaleDelta >= 3){/* keep only matchgroups with scaleID matching the best matchgroup */
      int orientation = align->orientation;
      if(align->scaleID == scaleID){/* delete matchgroups from previous scaleID values : align->Malign[0..startNumMatchgroup-1] */
	int cnt = 0;
	for(int i = 0; i < align->multicnt; i++){
	  if(align->Malign[i]->scaleID != scaleID)
	    continue;
	  Calign *tmp = align->Malign[cnt];
	  align->Malign[cnt++] = align->Malign[i];
	  align->Malign[i] = tmp;
	}
	if(cnt < align->multicnt){
	  int delta = align->multicnt - cnt;
	  if(PVERB && delta > 0){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld): Deleted %d/%d matchgroups with scaleID < %d (align->scaleID=%d):multicnt= %d -> %d \n",
		   refid,rmap->id,mapid,nanomap->id,delta,align->multicnt,scaleID, align->scaleID, align->multicnt, cnt);
	    fflush(stdout);
	  }
	  for(int i = startNumMatchgroup; i < align->multicnt; i++){
	    Calign *tmp = align->Malign[i - delta];
	    align->Malign[i - delta] = align->Malign[i];
	    align->Malign[i] = tmp;
	  }
	  lastNumMatchgroup = align->multicnt = cnt;
	}
      } else {/* delete matchgroups for current scaleID values : align->Malign[startNumMatchgroup .. align->multicnt-1] */
	int cnt = 0;
	for(int i = 0; i < align->multicnt; i++){
	  if(align->Malign[i]->scaleID == scaleID)
	    continue;
	  Calign *tmp = align->Malign[cnt];
	  align->Malign[cnt++] = align->Malign[i];
	  align->Malign[i] = tmp;
	}
	if(PVERB && cnt < align->multicnt){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld): Deleted %d matchgroups with scaleID = %d (align->scaleID=%d):multicnt= %d -> %d\n",
		 refid,rmap->id,mapid,nanomap->id, align->multicnt - cnt, scaleID, align->scaleID, align->multicnt,cnt);
	  fflush(stdout);
	}
	lastNumMatchgroup = align->multicnt = cnt;
      }
    }

    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   refid,rmap->id,mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }

    if(scaleID > 0 && (scaleID % 2) == 0 && align->scaleID <= scaleID - 2 && AlignedThreshold(align, Y, ScoreThreshold, LogPvThreshold) )
      break;
  } // for scaleID = 0 .. NumScaleFactor - 1

  if(MultiMatches && HashMultiMatch && NumScaleFactor > 1 && hashScaleDelta < 2){/* need to rerun MultiMatchesRemoveDupes over all matchgroups */
    lastNumMatchgroup = 0;
    MultiMatchesRemoveDupes(align,lastNumMatchgroup,Y,X,N,M,rmap,nanomap, -1, RefSplit ? 1 : 0);
  }

  if(MultiMatches && align->multicnt > 0 && AlignedThreshold(align,Y,ScoreThreshold,LogPvThreshold)){
    int origmulticnt = align->multicnt;

    if(RefSplit){/* split up alignments based on Psplit and RefSplitMinLabels */
      if(DEBUG >= 1+RELEASE){
	for(int t = 0; t < align->multicnt; t++){
	  Calign *q = align->Malign[t];
	  if(DEBUG && RefSplit && !((REFSPLIT_FIX || q->score > min(ScoreThreshold3,ScoreThreshold2)) && q->logPV2 > min(LogPvThreshold3,LogPvThreshold2) && q->numpairs >= (CutFlip ? 2 : AlignedSiteThreshold2))){
	    #pragma omp critical
	    {
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld):Malign[%d]:or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f,logPV2=%0.2f (S3= %0.6f, T3= %0.2f, A3= %d)\n",
		     refid,rmap->id,mapid,nanomap->id,t,q->orientation,q->rev,q->numpairs,q->score,q->logPV,q->logPV2, min(ScoreThreshold3,ScoreThreshold2), min(LogPvThreshold3,LogPvThreshold2), (CutFlip ? 2 : AlignedSiteThreshold2));
	      fflush(stdout);
	      assert((REFSPLIT_FIX || q->score > min(ScoreThreshold3,ScoreThreshold2)) && q->logPV2 > min(LogPvThreshold3,LogPvThreshold2) && q->numpairs >= (CutFlip ? 2 : AlignedSiteThreshold2));
	    }
	  }
	}
      }

      double *cumiscore = new double[M+1];// HERE HERE : move to end of Fmem+Imem memory block

      if(DEBUG) assert(Psplit > 0.0);
      double threshold = log(1.0/Psplit);/* A Negative scoring region with score <= -threshold causes a split : If -outlierBC, this threshold is increased by |OutlierPenaltyBC[m]+OutlierPenaltyBC[n]| */
      double pthreshold = log(1.0/(Rsplit ? Rsplit : Psplit)); /* Negative score regions are merged if they are seperated by an aligned subregion with score < pthreshold */
      int origmulticnt = align->multicnt;
      int localtype = (NEW && PoutlierEnd > 0.0) ? -3 : -2;
      int orientation = align->orientation;

      for(int t = align->multicnt; --t >= 0;){
	Calign *p = align->Malign[t];/* split up alignment using same method as with PairSplit in pairalign.cpp */
	//	p->logPV2 = p->logPV; // Now initialized before CutFlip
	if(DEBUG && !(p->logPV2 >= p->logPV)){
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,pairs=%d,score=%0.6f,logPV=%0.2f:checking align->Malign[%d/%d] for RefSplits:or=%d,numpairs=%d,score=%0.6f,logPV=%0.2f,logPV2=%0.2f,T=%0.2f,T2=%0.2f\n",
		 refid,rmap->id,mapid,nanomap->id,align->orientation,align->numpairs,align->score,align->logPV,t,align->multicnt,p->orientation,p->numpairs,p->score,p->logPV,p->logPV2,LogPvThreshold,LogPvThreshold2);
	  fflush(stdout);
	  assert(p->logPV2 >= p->logPV);// CutFlip matchgroups have their logPV2 confidence raised by the difference between the CutFlip and regular Thresholds, to avoid filtering them out (required for endoutlier CutFlip)
	}

	p->chimpair = 0;/* flag split and/or modified matchgroups with chimpair = 1  */
	if(!REFSPLIT_FIX && p->logPV <= LogPvThreshold)/* Skip Match groups with Pvalue between LogPvThreshold and LogPvThreshold2 : with RefSplit these are only used for inversions */
	  continue;

	/* recompute local X[] as Xrev[], which may depend on ScaleID and p->orientation */
	FLOAT scale = ScaleFactor[p->scaleID];
	if(!p->orientation){
	  for(int J=0;J <= M+1;J++)
	    Xrev[J] = X[J]*scale;
	} else {
	  for(int j=0;j <= M+1;j++)
	    Xrev[j] = (X[M+1]-X[M+1-j])*scale;
	}

	int U = p->numpairs;
	FLOAT *pscore = p->outscore;
	double score = 0.0;/* cumulative outscore = sum(pscore[0..T-1]) */
	double iscoresum = 0.0;/* cumulative iscore = sum(p->iscore[0..T-1]) */
	//	double cumiscore[U+1];/* cumiscore[i = 0..T] = sum(p->iscore[0..i]) */

	int iLWM = -1;/* end of most recent potential alignment index break (-1 = left end, U = right end) :
		         iLWM is the value in range lastiHWM .. T-1 with lowest value for pscore[lastiHWM+1..iLWM] AND no subinterval with score >= pthreshold
			 The internal region lastiHWM+1..iLWM becomes fixed once HWM > LWM + pthreshold OR (T==U && iWHM > iLWM)
			   The region lastiHWM+1..iLWM is merged into a single outlier IFF pscore[lastiHWM+1..iLWM] < -threshold - |OutlierPenaltyBC[m]+OutlierPenaltyBC[n]| 
			   The region lastiHWM+1..iLWM becomes an actual break IFF pscore[lastiHWM+1..iLWM] < -threshold - |OutlierPenaltyBC[m]+OutlierPenaltyBC[n]| AND max(m,n) >= RefSplitMinLabels.
			 NOTE : Split alignments are not saved unless they include at least A2 aligned labels */
	double LWM = 0.0;/* sum(pscore[0..iLWM]) */
	int iHWM = -1;/* highest value for sum(pscore[iLWM+1..iHWM]) for iLWM <= iHWM < T <= U AND no subinterval from iLWM+1 to T-1 with score < -threshold - |OutlierPenaltyBC[m]+OutlierPenaltyBC[n]| */
	double HWM = 0.0;/* sum(pscore[0..iHWM]) */
	int lastbreak = -1;/* end of most recent actual alignment index break interval (-1 = left end, U = right end) */
	int lastiHWM = -1;/* start of next potential break (corresponds to a previous iHWM value : lastbreak <= lastiHWM <= iLWM <= iHWM */
	double lastHWM = 0.0;/* sum(pscore[0..lastiHWM] : a previous HWM value that has not yet been exceed by HWM */
	orientation = p->orientation;

	if(PVERB){
	  #pragma omp critical
	  {
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:checking align->Malign[%d/%d] for RefSplits:numpairs=%d,score=%0.6f,logPV=%0.2f,threshold=%0.6f,pthreshold=%0.6f:\n",
		   refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,t,align->multicnt,p->numpairs,p->score,p->logPV,threshold,pthreshold);
	    fflush(stdout);
	  }
	}

	for(int T = 0; T <= U; T++){
	  /* PRE: -1 <= lastbreak <= lastiHWM <= iLWM <= iHWM <= T-1 :
	     lastHWM = sum(pscore[0..lastiHWM]
	     LWM = sum(pscore[0..iLWM])
	     HWM = sum(pscore[0..iHWM])
	     score = sum(pscore[0..T-1])
	     iscoresum = sum(p->iscore[0..T-1])
	     cumiscore[i = 0..T-1] = sum(p->iscore[0..i])
	     HWM <= LWM+pthreshold
	     HWM <= lastHWM
	     If iLWM > lastiHWM : pscore[lastiHWM+1] < 0.0 && pscore[iLWM] < 0.0
	  */
          if(DEBUG>=2){
	    assert(-1 <= lastbreak);
	    assert(lastbreak <= lastiHWM);
	    assert(lastiHWM <= iLWM);
	    assert(iLWM <= iHWM);
	    assert(iHWM <= T - 1);
	    assert(HWM <= LWM + pthreshold);/* otherwise lastiHWM .. iLWM would have been fixed (and resulted in an actual break subject to BC && RefSplitMinLabels) */
	    assert(HWM <= lastHWM);/* otherwise matchgroup lastbreak .. lastiHWM would have been extended to iHWM */
	    if(iLWM > lastiHWM){
	      assert(pscore[lastiHWM+1] <= (RELEASE ? 0.000001 : 0.0));
	      assert(pscore[iLWM] < 0.0);
	    }
	  }
	  
	  double inc = pscore[T];
	  cumiscore[T] = iscoresum += p->iscore[T];

	  if(PVERB){
#pragma omp critical
	    {
	      if(T < U)
		printf("T=%d/%d:lastbreak=%d,lastiHWM=%d,iLWM=%d,iHWM=%d,lastHWM=%0.6f,LWM=%0.6f,HWM=%0.6f,outscore[0..T-1]=%0.6f:outscore[T]=%0.6f (iscore[T]=%0.6f,cum=%0.6f),I=%d,K=%d,J=%d\n",
		       T,U,lastbreak,lastiHWM,iLWM,iHWM,lastHWM,LWM,HWM,score,pscore[T],p->iscore[T],iscoresum,p->sites1[T],p->sitesK1[T],p->sites2[T]);
	      else
		printf("T=%d/%d:lastbreak=%d,lastiHWM=%d,iLWM=%d,iHWM=%d,lastHWM=%0.6f,LWM=%0.6f,HWM=%0.6f,outscore[0..T-1]=%0.6f:outscore[T]=%0.6f (iscore[T]=%0.6f,cum=%0.6f)\n",
		       T,U,lastbreak,lastiHWM,iLWM,iHWM,lastHWM,LWM,HWM,score,pscore[T],p->iscore[T],iscoresum);
	      fflush(stdout);
	    }
	  }

	  if(score + inc > LWM + pthreshold || (T==U && iHWM > iLWM)){
	    if(DEBUG && T < U) assert(score+inc > HWM);/* this guarantees that potential alignment break interval lastiHWM+1..iLWM will be reset below to lastiHWM = iLWM = iHWM = T */

	    if(lastiHWM < 0 && iLWM > 0){/* NEW3 : check if left end should be trimmed */
	      int I = p->sites1[iLWM];
	      int K = p->sitesK1[iLWM];
	      if(cumiscore[iLWM] /* WAS LWM */ < ChimScore + PRtab[refid][K][I].Sm){
		if(PVERB){
#pragma omp critical
		  {
		    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:U=%d: trimming off left end of alignment up to iLWM=%d (I=%d,K=%d,J=%d)\n",
			   refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U,iLWM,I,K,p->sites2[iLWM]);
		    fflush(stdout);
		  }
		}
		lastbreak = iLWM;
		lastiHWM = iLWM = iHWM;
		lastHWM = LWM = HWM;
	      }
	    } else if(lastiHWM >= 0 && iLWM > lastiHWM){ /* The potential break interval is now fixed at lastiHWM+1 .. iLWM : check if it is an actual break. Then resume search for next break */

	      /* check if lastHWM - LWM > threshold + |OutlierPenaltyBC[m] + OutlierPenaltyBC[n]| AND max(m,n) >= RefSplitMinLabels : If so, schedule break in alignment from lastiHWM+1 .. iLWM */
	      int IL = p->sites1[lastiHWM], IR = p->sites1[iLWM];
	      int /* KL = p->sitesK1[lastiHWM], */ KR = p->sitesK1[iLWM];
	      int JL = p->sites2[lastiHWM], JR = p->sites2[iLWM];
	      int n = IR-KR-IL;
	      int m = JR-JL;
	      if(DEBUG) assert(n < max(maxN,maxM));
	      if(DEBUG) assert(m < max(maxN,maxM));
	      if(DEBUG) assert(pscore[lastiHWM+1] < 0.0);
	      if(DEBUG) assert(pscore[iLWM] < 0.0);

	      if(lastHWM - LWM > threshold - OutlierPenaltyBC[n] - OutlierPenaltyBC[m]){/* potential alignment index break satisfies -ve score threshold */
		if(max(m,n) >= RefSplitMinLabels){/* actual alignment index break */
		  if(lastiHWM + 1 - (max(0,lastbreak)) >= (min(2,AlignedSiteThreshold2))){
		    /* copy alignment from lastbreak to lastiHWM into a separate alignment */

		    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
		      for(int i = 0; i < align->multimax; i++)
			for(int j = i+1; j < align->multimax; j++)
			  if(align->Malign[i] == align->Malign[j]){
			    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
				   refid,rmap->id,mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
			    fflush(stdout);
			    assert(align->Malign[i] != align->Malign[j]);
			  }
		    }

		    if(align->multicnt >= align->multimax){
		      int nmultimax = align->multicnt + 16;
		      Calign **nMalign = new Calign*[nmultimax];
		      for(int t = 0; t < align->multimax; t++)
			nMalign[t] = align->Malign[t];
		      for(int t = align->multimax; t < nmultimax; t++)
			nMalign[t] = new Calign[1];
		      delete [] align->Malign;
		      align->Malign = nMalign;
		      align->multimax = nmultimax;
		    }

		    if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
		      for(int i = 0; i < align->multimax; i++)
			for(int j = i+1; j < align->multimax; j++)
			  if(align->Malign[i] == align->Malign[j]){
			    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
				   refid,rmap->id,mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
			    fflush(stdout);
			    assert(align->Malign[i] != align->Malign[j]);
			  }
		    }

		    Calign *r = align->Malign[align->multicnt++];

		    int S = max(0,lastbreak);
		    r->numpairs = lastiHWM - S + 1;
		    if(DEBUG) assert(r->numpairs >= 2);
		    r->expand_arrays(r->numpairs);
		    if(DEBUG) assert(r->allocated_size >= r->numpairs);
		    r->mapid1 = p->mapid1;
		    r->mapid2 = p->mapid2;
		    r->orientation = p->orientation;
		    if(DEBUG && MultiMatchesRev) assert(p->rev == 0);
		    r->rev = p->rev;
		    r->scaleID = p->scaleID;// NEW19
		    r->stitch = 0;
		    r->repeat = p->repeat;// NEW405
		    r->noutliers = 0;
		    r->maxoutlier = 0.0;
		    r->maxoutlierLabels = 0;
	      
		    /* left end */
		    if(lastbreak <= 0){/* keep original end */
		      r->iscore[0] = r->outscore[0] = p->iscore[0];
		      r->Lij1 = p->Lij1;
		      r->Lij2 = p->Lij2;
#if CALIGN_END==0
		      r->LijY = p->LijY;
		      r->LijX = p->LijX;
#endif
		      r->Lend = p->Lend;
		      if(RefSplitStitch>=2)
			r->stitch |= p->stitch & 1;
		    } else {/* generate new left endoutlier */
		      int I = p->sites1[lastbreak];
		      int K = p->sitesK1[lastbreak];
		      int J = p->sites2[lastbreak];
		      r->iscore[0] = r->outscore[0] = ChimScore + PRtab[refid][K][I].Sm;
		      r->Lij1 = I-K;
		      r->Lij2 = J;
#if CALIGN_END==0
		      r->LijY = LijY(Y,Xrev,I-K,J,N,M);
		      r->LijX = LijX(Y,Xrev,I-K,J,N,M);
#endif
		      r->Lend = localtype;
		    }

		    int t = max(0,lastbreak);
		    int lastI = r->sites1[0] = p->sites1[t];
		    int lastK = r->sitesK1[0] = p->sitesK1[t];
		    int lastJ = r->sites2[0] = p->sites2[t];
		    for(int u = 1; ++t <= lastiHWM; u++){
		      r->iscore[u] = p->iscore[t];
		      r->outscore[u] = p->outscore[t];
		      int I = r->sites1[u] = p->sites1[t];
		      int K = r->sitesK1[u] = p->sitesK1[t];
		      int J = r->sites2[u] = p->sites2[t];
		      if(r->outscore[u] + (FLOAT)0.01 < r->iscore[u]){
			r->noutliers++;
			double deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
			double deltaX = Xrev[J] - Xrev[lastJ];
			if(DEBUG) assert(deltaX > 0.0);
			double delta = fabs(deltaY-deltaX);
			r->maxoutlier = max(delta, r->maxoutlier);
			r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		      }
		      lastI = I;
		      lastK = K;
		      lastJ = J;
		    }

		    /* right end */
		    if(lastiHWM >= p->numpairs - 1){
		      r->iscore[r->numpairs] = r->outscore[r->numpairs] = p->iscore[U];
		      r->Rij1 = p->Rij1;
		      r->Rij2 = p->Rij2;
		      r->Rend = p->Rend;
#if CALIGN_END==0
		      r->RijY = p->RijY;
		      r->RijX = p->RijX;
#endif
		    } else {
		      int I = p->sites1[lastiHWM];
		      //		    int K = p->sitesK1[lastiHWM];
		      int J = p->sites2[lastiHWM];
		      r->iscore[r->numpairs] = r->outscore[r->numpairs] = ChimScore;
		      r->Rij1 = I;
		      r->Rij2 = J;
		      r->Rend = localtype;
#if CALIGN_END==0
		      r->RijY = RijY(Y,Xrev,I,J,N,M);
		      if(DEBUG/* HERE HERE >=2 */) assert(J <= M);
		      r->RijX = RijX(Y,Xrev,I,J,N,M);
#endif
		    }
		
		    r->score = 0;
		    for(int t = 0; t <= r->numpairs; t++)
		      r->score += r->iscore[t];

		    if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
		    if(DEBUG && !CutFlip) assert(p->Nrange <= N && p->Mrange <= M);
		    r->Nrange = p->Nrange;
		    r->Mrange = p->Mrange;

		    r->logPV = alignFP(r, Y, Xrev /* WAS r->orientation ? Xrev : X */, N, M, r->orientation, r->mapid1,r->mapid2, r->score, /* PVERB ? 1 : */ 0);
		    r->chimpair = 1;// flag as split matchgroup so it isn't filtered out by LogPvThreshold
		    r->logPV2 = max(r->logPV,p->logPV2);

		    if(DEBUG/* HERE HERE >=2 */) assert(r->noutliers >= 0 && r->maxoutlier >= 0.0 && r->maxoutlierLabels >= 0 &&
							(r->noutliers <= 0 || r->maxoutlier > 0.0 || r->maxoutlierLabels > 0));

		    if(PVERB){
#pragma omp critical
		      {
			printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:U=%d: splitting alignment from lastbreak=%d to lastiHWM=%d into Malign[%d]:numpairs=%d,score=%0.6f(Rscore=%0.6f),logPV=%0.2f\n",
			       refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U,lastbreak,lastiHWM,align->multicnt-1,r->numpairs,r->score,r->iscore[r->numpairs],r->logPV);
			fflush(stdout);
		      }
		    }
		  } else {
		    if(PVERB){
#pragma omp critical
		      {
			printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d,U=%d: split alignment from lastbreak=%d to lastiHWM=%d is too short due to -A2 %d (discarding)\n",
			       refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U,lastbreak,lastiHWM,AlignedSiteThreshold2);
			fflush(stdout);
		      }
		    }
		  }
		
		  lastbreak = iLWM;
		  lastiHWM = iLWM = iHWM;
		  lastHWM = LWM = HWM;
		} /* actual alignment index break */
		else if(MERGE_OUTLIERS && iLWM > lastiHWM + 1){/* merge potential alignment index break lastiHWM+1 to iLWM into a single outlier */
		  int deltaU = iLWM - lastiHWM - 1;

		  double iscore = 0.0, outscore = 0.0;
		  for(int t = lastiHWM+1; t <= iLWM; t++){
		    outscore += pscore[t];
		    iscore += p->iscore[t];
		  }

		  int I = p->sites1[iLWM];
		  int K = p->sitesK1[iLWM];
		  int J = p->sites2[iLWM];
		  int G = p->sites1[lastiHWM];
		  int D = p->sitesK1[lastiHWM];
		  int H = p->sites2[lastiHWM];

		  RFLOAT x = Xrev[J] - Xrev[H]; // WAS p->orientation ? Xrev[J] - Xrev[H] : X[J] - X[H];
		  RFLOAT y = Yc(Y,I,K) - Yc(Y,G,D);
		  //		  FLOAT delta = fabs(x - y);

		  RFLOAT Bias,Pen,Gauss,PenSm;
		  SintDetail(x,y, J-H,I-K-G,J,I,K,D,PRtab[refid],Y,Bias,Pen,Gauss,PenSm,0);
		  RFLOAT iscore2,outscore2 = Bias + Pen + Gauss + PenSm;
		  RFLOAT OutPen = OutlierPenalty;
		  if (outlierBC)
		    OutPen += OutlierPenaltyBC[J-H] + OutlierPenaltyBC[I-K-G];
		  if(maptype){// NEW8
		    if(OUTLIER_LTYPE==0)
		      OutPen -= (x+y) * OutlierLambdaInv;
		    else
		      OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
		    iscore2 = (OUTLIER_TYPE1 == 0) ? OutlierBias + max(Bias + Pen + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
		      OutlierBias + Pen + max(Bias + Gauss, OutPen + Bias * biasWToutlierF) + PenSm;
#else // NEW
		    iscore2 = OutlierBias + max(Bias + Pen + Gauss, OutPen + Pen*OUTLIER_TYPE1 + Bias * biasWToutlierF) + PenSm;
#endif
		  } else if(OUTLIER_DELTA(x-y)){// NEW8
		    OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
		    iscore2 = (OUTLIER_TYPE==0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
			OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
#else // NEW
		    iscore2 = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen*OUTLIER_TYPE + OutPen) + PenSm;
#endif
		  } else // NEW8
		    iscore2 = outscore2;

		  if(DEBUG && !(fabs(outscore + (lastHWM-LWM)) < 1e-6 + fabs(lastHWM) * 1e-12)){
#pragma omp critical
		    {
		      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d,U=%d: Merging interval lastiHWM=%d to iLWM=%d into single outlier interval(I=%d,K=%d,J=%d,G=%d,D=%d,H=%d,x=%0.3f,y=%0.3f):\n\t lastHWM=%0.6f,LWM=%0.6f,outscore[%d..%d]=%0.6f->%0.6f,iscore=%0.6f->%0.6f\n",
			     refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U, lastiHWM, iLWM, I,K,J,G,D,H,x,y,lastHWM, LWM, lastiHWM+1,iLWM,outscore,outscore2,iscore,iscore2);
		      for(int t = lastiHWM+1; t <= iLWM; t++)
			printf("outscore[%d]=%0.6f,iscore=%0.6f\n",t,pscore[t],p->iscore[t]);
		      fflush(stdout);
		      assert(fabs(outscore + (lastHWM-LWM)) < 1e-6 + fabs(lastHWM) * 1e-12);
		    }
		  }

		  pscore[lastiHWM+1] = outscore2;
		  p->iscore[lastiHWM+1] = iscore2;

		  for(int t = lastiHWM+1; t < U - deltaU; t++){
		    pscore[t + 1] = pscore[t + 1 + deltaU];
		    p->iscore[t + 1] = p->iscore[t + 1 + deltaU];

		    p->sites1[t] = p->sites1[t + deltaU];
		    p->sitesK1[t] = p->sitesK1[t + deltaU];
		    p->sites2[t] = p->sites2[t + deltaU];
		  }
		  p->numpairs = U -= deltaU;
		  if(DEBUG) assert(p->numpairs >= 2);

		  double origscore = p->score;
		  double origlogPV = p->logPV;

		  p->score += iscore2 - iscore;

		  // NEW303 : update maxoutlier etc 
		  p->noutliers = 0;
		  p->maxoutlier = 0.0;
		  p->maxoutlierLabels = 0;
		  int nI,lastI = p->sites1[0];
		  int nK,lastK = p->sitesK1[0];
		  int nJ,lastJ = p->sites2[0];
		  for(int t = 1; t < U; lastI = nI, lastK = nK, lastJ = nJ, t++){
		    nI = p->sites1[t];
		    nK = p->sitesK1[t];
		    nJ = p->sites2[t];
		    if(p->outscore[t] + (FLOAT)0.01 < p->iscore[t]){
		      p->noutliers++;
		      FLOAT deltaY = Yc(Y,nI,nK) - Yc(Y,lastI,lastK);
		      FLOAT deltaX = Xrev[nJ] - Xrev[lastJ];
		      if(DEBUG) assert(deltaX > 0.0);
		      FLOAT delta = fabs(deltaY - deltaX);
		      p->maxoutlier = max(delta,p->maxoutlier);
		      p->maxoutlierLabels = max(nI-nK-lastI + nJ-lastJ - 2, p->maxoutlierLabels);
		    }
		  }
		  if(DEBUG/* HERE HERE >=2 */) assert(p->noutliers >= 0 && p->maxoutlier >= 0.0 && p->maxoutlierLabels >= 0 &&
						      (p->noutliers <= 0 || p->maxoutlier > 0.0 || p->maxoutlierLabels > 0));

		  // p->Nrange and p->Mrange stays unchanged
		  if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
		  if(DEBUG && !CutFlip) assert(p->Nrange <= N && p->Mrange <= M);

		  p->logPV = alignFP(p, Y, Xrev /* WAS p->orientation ? Xrev : X */, N, M, p->orientation, p->mapid1, p->mapid2, p->score, 0);
		  p->chimpair = 1;// flag as split matchgroup so it isn't filtered out by LogPvThreshold
		  p->logPV2 = max(p->logPV,p->logPV2);

		  if(PVERB){
#pragma omp critical
		    {
		      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d,U=%d: Merging interval lastiHWM=%d to iLWM=%d (ref=%0.3f..%0.3f) into single outlier interval(I=%d,K=%d,J=%d,G=%d,D=%d,H=%d,x=%0.3f,y=%0.3f):\n\t lastHWM=%0.6f,LWM=%0.6f,outscore[%d]=%0.6f->%0.6f,iscore=%0.6f->%0.6f:score=%0.6f->%0.6f,logPV=%0.2f->%0.2f,PVERB=%d,deltaU=%d,T=%d->%d,iLWM->%d,iHWM->%d\n",
			     refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U,lastiHWM,iLWM, Y[G-D], Y[I], I,K,J,G,D,H,x,y,lastHWM, LWM, lastiHWM+1,outscore,outscore2,iscore,iscore2, origscore, p->score, origlogPV, p->logPV, PVERB ? 1 : 0, deltaU,T,T-deltaU,iLWM-deltaU,iHWM-deltaU);
		      /*		    printf("\t iscore2=%0.6f:OutlierBias=%0.6f,Pen=%0.6f,Bias=%0.6f,Gauss=%0.6f,OutPen=%0.6f(OutlierPenalty=%0.6f,BC=%0.6f,Lambda=%0.6f),biasWToutlierF=%0.6f,PenSm=%0.6f\n",
					    iscore2,OutlierBias,Pen,Bias,Gauss,OutPen,OutlierPenalty,OutlierPenaltyBC[J-H]+OutlierPenaltyBC[I-K-G],
					    -(OUTLIER_LTYPE==0 ? x+y : fabs(x-y)) * OutlierLambdaInv,biasWToutlierF, PenSm);*/
		      fflush(stdout);
		    }
		  }
		  T -= deltaU;
		  iLWM -= deltaU;
		  iHWM -= deltaU;
		} /* merged potential alignment index break lastiWHM+1 .. iLWM into a single outlier */
	      } /* potential alignment index break satisfies -ve score threshold */
	    } /* else if(lastiHWM >= 0 && iLWM > lastiHWM) */
	  } /* if(score + inc > LWM + pthreshold) */

	  score += inc;
	  if(score < LWM){/* extend the previous (potential) alignment break interval (lastHWM+1 to iLWM) to T */
	    iLWM = iHWM = T;
	    LWM = HWM = score;
	  } else if(score >= HWM){
	    iHWM = T;
	    HWM = score;
	    if(HWM/* WAS LWM */ >= lastHWM             /* keep extending lastbreak ... lastiHWM matchgroup to T */
	       || HWM - LWM > pthreshold){/* stop extending potential alignment break interval (lastiHWM to iLWM) and initialize new potential alignment break interval at T */
	      lastiHWM = iLWM = iHWM;
	      lastHWM = LWM = HWM;
	    }
	  }
	    
	  /* POST : -1 <= lastbreak <= lastiHWM <= iLWM <= iHWM <= T :
	     lastHWM = sum(pscore[0..lastiHWM])
	     LWM = sum(pscore[0..iLWM])
	     HWM = sum(pscore[0..iHWM])
	     score = sum(pscore[0..T])
	     iscoresum = sum(iscore[0..T])
	     cumiscore[i = 0..T] = sum(iscore[0..i])
	     HWM <= LWM+pthreshold
	     HWM <= lastHWM
	     If iLWM > lastiHWM : pscore[lastiHWM+1] <= 0.0 && pscore[iLWM] < 0.0
	  */
          if(DEBUG>=2){
	    assert(-1 <= lastbreak);
	    assert(lastbreak <= lastiHWM);
	    assert(lastiHWM <= iLWM);
	    assert(iLWM <= iHWM);
	    assert(iHWM <= T);
	    assert(HWM <= LWM + pthreshold);
	    assert(HWM <= lastHWM);
	    if(iLWM > lastiHWM){
	      if(!(pscore[lastiHWM+1] <= 0.0)){
                #pragma omp critical
		{
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:checking align->Malign[%d] for RefSplits:numpairs=%d,score=%0.6f,logPV=%0.2f,threshold=%0.6f,pthreshold=%0.6f:\n",
			 refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,t,p->numpairs,p->score,p->logPV,threshold,pthreshold);
		  printf("After T=%d/%d:lastbreak=%d,lastiHWM=%d,iLWM=%d,iHWM=%d,pscore[lastiHWM+1]= %0.6f\n",T,U,lastbreak,lastiHWM,iLWM,iHWM,pscore[lastiHWM+1]);
		  fflush(stdout);
		  assert(pscore[lastiHWM+1] <= (RELEASE ? 0.00001 : 0.0));
	        }
	      }
	    }  // iLWM > lastiHWM
	  } // DEBUG>=2
	} // for(T = 0; T < U; T++)

	int orignumpairs = p->numpairs;
	double origscore = p->score;
	double origlogPV = p->logPV;

	//	int trimmed = 0;

	if(lastbreak > 0){/* trim current alignment down to lastbreak .. U */
	  int I = p->sites1[lastbreak];
	  int K = p->sitesK1[lastbreak];
	  int J = p->sites2[lastbreak];
	  p->iscore[0] = p->outscore[0] = ChimScore + PRtab[refid][K][I].Sm;
	  p->Lij1 = I-K;
	  p->Lij2 = J;
	  p->Lend = localtype;
#if CALIGN_END==0
	  p->LijY = LijY(Y,Xrev,I-K,J,N,M);
	  p->LijX = LijX(Y,Xrev,I-K,J,N,M);
#endif
	  if(RefSplitStitch >= 2)
	    p->stitch &= ~1;// NEW10
	    
	  if(DEBUG) assert(lastiHWM >= 0);
	  int RU = U;
	  if(cumiscore[U] - cumiscore[lastiHWM] /* WAS score - lastHWM */ < ChimScore && lastiHWM < U-1/*NEW37*/){/* NEW3 : trim right end of alignment beyond lastiHWM */
	    RU = lastiHWM + 1;
	    
	    // check if region right of iLWM satisfies AlignedSiteThreshold
	    int rightend = 0;
	    if(U - iLWM >= min(2,AlignedSiteThreshold2)){// NEW37 : copy alignment from iLWM to right end into a seperate alignment
	      int I = p->sites1[iLWM];
	      int K = p->sitesK1[iLWM];
	      int J = p->sites2[iLWM];

	      rightend = 1;

	      if(align->multicnt >= align->multimax){
		int nmultimax = align->multicnt + 16;
		Calign **nMalign = new Calign*[nmultimax];
		for(int t = 0; t < align->multimax; t++)
		  nMalign[t] = align->Malign[t];
		for(int t = align->multimax; t < nmultimax; t++)
		  nMalign[t] = new Calign[1];
		delete [] align->Malign;
		align->Malign = nMalign;
		align->multimax = nmultimax;
	      }

	      Calign *r = align->Malign[align->multicnt++];
	      r->numpairs = U - iLWM;
	      if(DEBUG) assert(r->numpairs >= 2);
	      r->expand_arrays(r->numpairs);
	      if(DEBUG) assert(r->allocated_size >= r->numpairs);
	      r->mapid1 = p->mapid1;
	      r->mapid2 = p->mapid2;
	      r->orientation = p->orientation;
	      if(DEBUG && MultiMatchesRev) assert(p->rev == 0);
	      r->rev = p->rev;
	      r->scaleID = p->scaleID;// NEW19
	      r->stitch = 0;
	      r->repeat = p->repeat;// NEW405
	      r->noutliers = 0;
	      r->maxoutlier = 0.0;
	      r->maxoutlierLabels = 0;

	      if(DEBUG) assert(iLWM > 0);
	      /* generate new left endoutlier */
	      r->iscore[0] = r->outscore[0] = ChimScore + PRtab[refid][K][I].Sm;
	      r->Lij1 = I-K;
	      r->Lij2 = J;
	      r->Lend = localtype;
#if CALIGN_END==0
	      r->LijY = LijY(Y,Xrev,I-K,J,N,M);
	      r->LijX = LijX(Y,Xrev,I-K,J,N,M);
#endif

	      int t = iLWM;
	      int lastI = r->sites1[0] = p->sites1[t];
	      int lastK = r->sitesK1[0] = p->sitesK1[t];
	      int lastJ = r->sites2[0] = p->sites2[t];
	      for(int u = 1; ++t < U; u++){
		r->iscore[u] = p->iscore[t];
		r->outscore[u] = p->outscore[t];
		int I = r->sites1[u] = p->sites1[t];
		int K = r->sitesK1[u] = p->sitesK1[t];
		int J = r->sites2[u] = p->sites2[t];
		if(r->outscore[u] + (FLOAT)0.01 < r->iscore[u]){
		  r->noutliers++;
		  double deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		  double deltaX = Xrev[J] - Xrev[lastJ];
		  if(DEBUG) assert(deltaX > 0.0);
		  double delta = fabs(deltaY-deltaX);
		  r->maxoutlier = max(delta, r->maxoutlier);
		  r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
		}
		lastI = I;
		lastK = K;
		lastJ = J;
	      }

	      /* right end */
	      r->iscore[r->numpairs] = r->outscore[r->numpairs] = p->iscore[U];
	      r->Rij1 = p->Rij1;
	      r->Rij2 = p->Rij2;
#if CALIGN_END==0
	      r->RijY = p->RijY;
	      r->RijX = p->RijX;
#endif
	      r->Rend = p->Rend;

	      r->score = 0;
	      for(int t = 0; t <= r->numpairs; t++)
		r->score += r->iscore[t];

	      if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
	      if(DEBUG && !CutFlip) assert(p->Nrange <= N && p->Mrange <= M);
	      r->Nrange = p->Nrange;
	      r->Mrange = p->Mrange;

	      r->logPV = alignFP(r, Y, Xrev /* WAS r->orientation ? Xrev : X */, N, M, r->orientation, r->mapid1,r->mapid2, r->score, /* PVERB ? 1 : */ 0);
	      r->chimpair = 1;// flag as split matchgroup so it isn't filtered out by LogPvThreshold
	      r->logPV2 = max(r->logPV,p->logPV2);

	      if(DEBUG/* HERE HERE >=2 */) assert(r->noutliers >= 0 && r->maxoutlier >= 0.0 && r->maxoutlierLabels >= 0 &&
						  (r->noutliers <= 0 || r->maxoutlier > 0.0 || r->maxoutlierLabels > 0));

	      if(PVERB){
#pragma omp critical
		{
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:U=%d: splitting alignment from iLWM=%d to right end into Malign[%d]:numpairs=%d,score=%0.6f(Rscore=%0.6f),logPV=%0.2f,%0.2f\n",
			 refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U,iLWM,align->multicnt-1,r->numpairs,r->score,r->iscore[r->numpairs],r->logPV,r->logPV2);
		  fflush(stdout);
		}
	      }
	    } // if(U-iLWM >= min(2,AlignedSiteThreshold2))
	    // HERE HERE : match trimmed = 1 or 2 in -MultiMatch RefSplit

	  } // 	  if(cumiscore[U] - cumiscore[lastiHWM] < ChimScore && lastiHWM < U-1)

	  p->noutliers = 0;
	  p->maxoutlier = 0.0;
	  p->maxoutlierLabels = 0;
	  int lastI = p->sites1[0] = p->sites1[lastbreak];
	  int lastK = p->sitesK1[0] = p->sitesK1[lastbreak];
	  int lastJ = p->sites2[0] = p->sites2[lastbreak];
	  for(int k = lastbreak+1; k < RU; k++){
	    int I = p->sites1[k-lastbreak] = p->sites1[k];
	    int K = p->sitesK1[k-lastbreak] = p->sitesK1[k];
	    int J = p->sites2[k-lastbreak] = p->sites2[k];
	    double iscore = p->iscore[k-lastbreak] = p->iscore[k];
	    double outscore = p->outscore[k-lastbreak] = p->outscore[k];
	    if(outscore + (FLOAT)0.01 < iscore){// NEW10 : update maxoutlier,noutlier
	      p->noutliers++;
	      double deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	      double deltaX = Xrev[J] - Xrev[lastJ];
	      if(DEBUG) assert(deltaX > 0.0);
	      double delta = fabs(deltaY-deltaX);
	      p->maxoutlier = max(delta, p->maxoutlier);
	      p->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, p->maxoutlierLabels);// NEW302
	    }
	    lastI = I;
	    lastK = K;
	    lastJ = J;
	  }
	  if(RU < U){
	    p->iscore[RU-lastbreak] = p->outscore[RU-lastbreak] = ChimScore;
	    p->Rend = localtype;// NEW9
	    if(RefSplitStitch >= 2)
	      p->stitch &= ~2;// NEW10
	  } else {
	    p->iscore[U-lastbreak] = p->iscore[U];
	    p->outscore[U-lastbreak] = p->outscore[U];
	  }

	  p->numpairs = RU - lastbreak;

	  p->score = 0.0;
	  for(int k = 0; k <= p->numpairs; k++)
	    p->score += p->iscore[k];

	  // p->Nrange and p->Mrange stays unchanged
	  if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
	  if(DEBUG && !CutFlip) assert(p->Nrange <= N && p->Mrange <= M);

	  p->logPV = alignFP(p, Y, Xrev /* WAS p->orientation ? Xrev : X */, N, M, p->orientation, p->mapid1, p->mapid2, p->score, PVERB>=3 ? 1 : 0);
	  p->logPV2 = max(p->logPV,p->logPV2);
	  p->chimpair = 1;

	  if(DEBUG/* HERE HERE >=2 */) assert(p->noutliers >= 0 && p->maxoutlier >= 0.0 && p->maxoutlierLabels >= 0 &&
					      (p->noutliers <= 0 || p->maxoutlier > 0.0 || p->maxoutlierLabels > 0));

	  if(PVERB || (DEBUG>=2 && p->numpairs <= 1)){
	    if(RU == U)
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d,U=%d: truncating alignment Malign[%d] from lastbreak=%d to right end:numpairs=%d->%d,score=%0.6f->%0.6f(Rscore=%0.6f),logPV=%0.2f->%0.2f\n",
		     refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U,t,lastbreak,orignumpairs,p->numpairs,origscore,p->score,p->iscore[p->numpairs],origlogPV,p->logPV);
	    else
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d,U=%d: truncating alignment Malign[%d] from lastbreak=%d to lastiHWM=%d:numpairs=%d->%d,score=%0.6f->%0.6f(Rscore=%0.6f),logPV=%0.2f->%0.2f\n",
		     refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U,t,lastbreak,lastiHWM,orignumpairs,p->numpairs,origscore,p->score,p->iscore[p->numpairs],origlogPV,p->logPV);
	    fflush(stdout);
	  }
	  //	  if(DEBUG) assert(p->numpairs >= 2);

	} else if(lastiHWM > 0/* NEW47*/ && cumiscore[U] - cumiscore[lastiHWM]< ChimScore && lastiHWM < U){/* NEW3 : trim right end of alignment beyond lastiHWM */

	  // check if region right of iLWM satisfies AlignedSiteThreshold2
	  if(U - iLWM >= min(2,AlignedSiteThreshold)){// NEW37 : copy alignment from iLWM to right end into a seperate alignment
	    int I = p->sites1[iLWM];
	    int K = p->sitesK1[iLWM];
	    int J = p->sites2[iLWM];

	    if(align->multicnt >= align->multimax){
	      int nmultimax = align->multicnt + 16;
	      Calign **nMalign = new Calign*[nmultimax];
	      for(int t = 0; t < align->multimax; t++)
		nMalign[t] = align->Malign[t];
	      for(int t = align->multimax; t < nmultimax; t++)
		nMalign[t] = new Calign[1];
	      delete [] align->Malign;
	      align->Malign = nMalign;
	      align->multimax = nmultimax;
	    }

	    Calign *r = align->Malign[align->multicnt++];
	    r->numpairs = U - iLWM;
	    if(DEBUG) assert(r->numpairs >= 2);
	    r->expand_arrays(r->numpairs);
	    if(DEBUG) assert(r->allocated_size >= r->numpairs);
	    r->mapid1 = p->mapid1;
	    r->mapid2 = p->mapid2;
	    r->orientation = p->orientation;
	    if(DEBUG && MultiMatchesRev) assert(p->rev == 0);
	    r->rev = p->rev;
	    r->scaleID = p->scaleID;// NEW19
	    r->stitch = 0;
	    r->repeat = p->repeat;// NEW405
	    r->noutliers = 0;
	    r->maxoutlier = 0.0;
	    r->maxoutlierLabels = 0;

	    if(DEBUG && !(iLWM > 0)){
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:checking align->Malign[%d] for RefSplits:numpairs=%d,score=%0.6f,logPV=%0.2f,threshold=%0.6f,pthreshold=%0.6f:\n",
		     refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,t,p->numpairs,p->score,p->logPV,threshold,pthreshold);
	      printf("lastbreak= %d, lastiHWM= %d, iLWM= %d, iHWM=%d,U=%d,cumiscore[U]=%0.6f,\n", lastbreak, lastiHWM, iLWM, iHWM,U,cumiscore[U]);
	      fflush(stdout);
	      assert(iLWM > 0);
	    }

	    /* generate new left endoutlier */
	    r->iscore[0] = r->outscore[0] = ChimScore + PRtab[refid][K][I].Sm;
	    r->Lij1 = I-K;
	    r->Lij2 = J;
	    r->Lend = localtype;
#if CALIGN_END==0
	    r->LijY = LijY(Y,Xrev,I-K,J,N,M);
	    r->LijX = LijX(Y,Xrev,I-K,J,N,M);
#endif

	    int t = iLWM;
	    int lastI = r->sites1[0] = p->sites1[t];
	    int lastK = r->sitesK1[0] = p->sitesK1[t];
	    int lastJ = r->sites2[0] = p->sites2[t];
	    for(int u = 1; ++t < U; u++){
	      r->iscore[u] = p->iscore[t];
	      r->outscore[u] = p->outscore[t];
	      int I = r->sites1[u] = p->sites1[t];
	      int K = r->sitesK1[u] = p->sitesK1[t];
	      int J = r->sites2[u] = p->sites2[t];
	      if(r->outscore[u] + (FLOAT)0.01 < r->iscore[u]){
		r->noutliers++;
		double deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		double deltaX = Xrev[J] - Xrev[lastJ];
		if(DEBUG) assert(deltaX > 0.0);
		double delta = fabs(deltaY-deltaX);
		r->maxoutlier = max(delta, r->maxoutlier);
		r->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, r->maxoutlierLabels);// NEW302
	      }
	      lastI = I;
	      lastK = K;
	      lastJ = J;
	    }

	    /* right end */
	    r->iscore[r->numpairs] = r->outscore[r->numpairs] = p->iscore[U];
	    r->Rij1 = p->Rij1;
	    r->Rij2 = p->Rij2;
	    r->Rend = p->Rend;
#if CALIGN_END==0
	    r->RijY = p->RijY;
	    r->RijX = p->RijX;
#endif
	    r->score = 0;
	    for(int t = 0; t <= r->numpairs; t++)
	      r->score += r->iscore[t];

	    if(DEBUG && CutFlip) assert(1 <= p->Nrange && p->Nrange <= N && 1 <= p->Mrange && p->Mrange <= M);
	    if(DEBUG && !CutFlip) assert(p->Nrange <= N && p->Mrange <= M);
	    r->Nrange = p->Nrange;
	    r->Mrange = p->Mrange;

	    r->logPV = alignFP(r, Y, Xrev /* WAS r->orientation ? Xrev : X */, N, M, r->orientation, r->mapid1,r->mapid2, r->score, /* PVERB ? 1 : */ 0);
	    r->chimpair = 1;// flag as split matchgroup so it isn't filtered out by LogPvThreshold
	    r->logPV2 = max(r->logPV,p->logPV2);

	    if(DEBUG/* HERE HERE >=2 */) assert(r->noutliers >= 0 && r->maxoutlier >= 0.0 && r->maxoutlierLabels >= 0 &&
						(r->noutliers <= 0 || r->maxoutlier > 0.0 || r->maxoutlierLabels > 0));

	    if(PVERB){
#pragma omp critical
	      {
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:U=%d: splitting alignment from iLWM=%d to right end into Malign[%d]:numpairs=%d,score=%0.6f(Rscore=%0.6f),logPV=%0.2f,%0.2f\n",
		       refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U,iLWM,align->multicnt-1,r->numpairs,r->score,r->iscore[r->numpairs],r->logPV,r->logPV2);
		fflush(stdout);
	      }
	    }
	  }// if(U-iLWM >= min(2,AlignedSiteThreshold2))

	  int RU = p->numpairs = lastiHWM + 1;
	  p->iscore[RU] = p->outscore[RU] = ChimScore;
	  p->Rend = localtype;// NEW9
	  if(RefSplitStitch >= 2)
	    p->stitch &= ~2;// NEW10

	  /* NEW10 : recompute maxoutlier, noutlier */
	  p->noutliers = 0;
	  p->maxoutlier = 0.0;
	  p->maxoutlierLabels = 0;
	  int lastI = p->sites1[0];
	  int lastK = p->sitesK1[0];
	  int lastJ = p->sites2[0];
	  for(int k = 1; k < RU; k++){
	    int I = p->sites1[k];
	    int K = p->sitesK1[k];
	    int J = p->sites2[k];
	    double iscore = p->iscore[k];
	    double outscore = p->outscore[k];
	    if(outscore + (FLOAT)0.01 < iscore){
	      p->noutliers++;
	      double deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
	      double deltaX = Xrev[J] - Xrev[lastJ];
	      if(DEBUG) assert(deltaX > 0.0);
	      double delta = fabs(deltaY-deltaX);
	      p->maxoutlier = max(delta, p->maxoutlier);
	      p->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, p->maxoutlierLabels);// NEW302
	    }
	    lastI = I;
	    lastK = K;
	    lastJ = J;
	  }

	  p->score = 0.0;
	  for(int k = 0; k <= p->numpairs; k++)
	    p->score += p->iscore[k];

	  p->logPV = alignFP(p, Y, Xrev /* WAS p->orientation ? Xrev : X */, N, M, p->orientation, p->mapid1, p->mapid2, p->score, /* PVERB ? 1 : */ 0);
	  p->logPV2 = max(p->logPV,p->logPV2);
	  p->chimpair = 1;

	  if(DEBUG/* HERE HERE >=2 */) assert(p->noutliers >= 0 && p->maxoutlier >= 0.0 && p->maxoutlierLabels >= 0 &&
					      (p->noutliers <= 0 || p->maxoutlier > 0.0 || p->maxoutlierLabels > 0));

	  if(PVERB || (DEBUG>=2 && p->numpairs <= 1)){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d,U=%d: truncating alignment Malign[%d] right of lastiHWM=%d:numpairs=%d->%d,score=%0.6f->%0.6f(Rscore=%0.6f),logPV=%0.2f->%0.2f\n",
		   refid,rmap->id,mapid,nanomap->id,p->orientation,p->scaleID,U,t,lastiHWM,orignumpairs,p->numpairs,origscore,p->score,p->iscore[p->numpairs],origlogPV,p->logPV);
	    fflush(stdout);
	  }
	  //	  if(DEBUG>=1+RELEASE) assert(p->numpairs >= 2);
        }
	if(DEBUG) assert(p->logPV2 >= p->logPV);

	if(!(p->score > min(ScoreThreshold3,ScoreThreshold2) && p->numpairs > (CutFlip ? 2 : AlignedSiteThreshold2))){
	  if(PVERB){
	    printf("\t filtered out Malign[%d] since it is now below threshold: pairs=%d,score=%0.6f (T3= %0.2f, A2=%d, CutFlip=%d),multicnt=%d->%d\n",
		   t,p->numpairs,p->score,ScoreThreshold3,AlignedSiteThreshold2,CutFlip,align->multicnt,align->multicnt-1);
	    fflush(stdout);
	  }
	  p->allfree();
	  for(int k = t+1; k < align->multicnt; k++)
	    align->Malign[k-1] = align->Malign[k];
	  align->Malign[--align->multicnt] = p;
	}
      }

      if(PVERB && (align->multicnt != origmulticnt)){
	#pragma omp critical
	{
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld):RefSplit increased alignments from %d to %d\n",
		 refid,rmap->id,mapid,nanomap->id,origmulticnt,align->multicnt);
	  fflush(stdout);
	}
      }
      
      delete [] cumiscore;
    }

    if(RefSplitStitch){/* try to stitch together matchgroups that are end-to-end : just call MultiMatchesRemoveDupes()*/
      int origmulticnt = align->multicnt;
      lastNumMatchgroup = 0;
      MultiMatchesRemoveDupes(align,lastNumMatchgroup,Y,X,N,M,rmap,nanomap, -1, RefSplit ? 1 : 0);

      if(TRACE && rmap->id == REF_TRACE && nanomap->id==MAP_TRACE){
	printf("refid=%d(id=%lld),mapid=%d(id=%lld):align->bestscore=%0.6f,align->logPV=%0.2f: After Stitching matchgroups: align->multicnt=%d -> %d\n",
	       refid,rmap->id,mapid,nanomap->id,align->score,align->logPV,origmulticnt,align->multicnt);
	fflush(stdout);
      }
      
      /* update logPV2 and filter out matchgroups with logPV2 below min(LogPvThreshold2,LogPvThreshold3) */
      for(int t = 0; t < align->multicnt; t++){
	Calign *p = align->Malign[t];
	p->logPV2  = max(p->logPV, p->logPV2);
      }

      if(RefSplitStitch>=2){/* try to further truncate matchgroups from side marked with stitch == 1 to see if score improves */
	  // HERE HERE
      }
    }

    if(RefSplit){      /* filter out matchgroups with logPV2 below min(LogPvThreshold2,LogPvThreshold3) */
      //      int origmulticnt = align->multicnt;

      int j = 0;
      for(int t = 0; t < align->multicnt; t++){
	Calign *p = align->Malign[t];
	// Code to filter out matchgroups with logPV2 below min(LogPvThreshold2,LogPvThreshold3) : needed since RefSplit splitting or outlier merging can drop score or numpairs below threshold
	if(p->logPV2 <= min(LogPvThreshold2,LogPvThreshold3) || (!REFSPLIT_FIX && p->score <= min(ScoreThreshold3,ScoreThreshold2)) || p->numpairs < (CutFlip ? 2 : AlignedSiteThreshold2)){
	  int orientation = p->orientation;
	  if(PVERB || (DEBUG && !REFSPLIT_FIX && p->logPV2 <= min(LogPvThreshold2,LogPvThreshold3))){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld):Malign[%d]:or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f,logPV2=%0.2f (S3= %0.6f, T3= %0.2f, A3= %d): deleting Malign[%d]\n",
		   refid,rmap->id,mapid,nanomap->id,t,p->orientation,p->rev,p->numpairs,p->score,p->logPV,p->logPV2, min(ScoreThreshold3,ScoreThreshold2), min(LogPvThreshold3,LogPvThreshold2), (CutFlip ? 2 : AlignedSiteThreshold2),t);
	    fflush(stdout);
	    if(DEBUG && !REFSPLIT_FIX) assert(p->logPV2 > min(LogPvThreshold2,LogPvThreshold3));
	  }
	  p->allfree();
	  continue;// filter out align->Malign[t];
	}
	if(j < t){// swap Malign[j] and Malign[t] 
	  align->Malign[t] = align->Malign[j];
	  align->Malign[j] = p;
	}
	j++;
      }
      align->multicnt = j;
    }

    if(DEBUG>=2 && align->Malign){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   refid,rmap->id,mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }

    /* sort align->Malign[0..align->multicnt-1] by score in descending order */
    qsort(align->Malign,align->multicnt,sizeof(Calign *),(intcmp *)CalignScoreDec);

    if(DEBUG>=2 && align->Malign){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
      for(int i = 0; i < align->multimax; i++)
	for(int j = i+1; j < align->multimax; j++)
	  if(align->Malign[i] == align->Malign[j]){
	    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		   refid,rmap->id,mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
	    fflush(stdout);
	    assert(align->Malign[i] != align->Malign[j]);
	  }
    }

    /* locate highest scoring alignment that passes all thresholds (except repeat check) */
    double bscore = -1000.0;
    for(int t = 0; t < align->multicnt; t++){
      Calign *p = align->Malign[t];
      if(DEBUG && RefSplit && !((REFSPLIT_FIX || p->score > min(ScoreThreshold3,ScoreThreshold2)) && p->logPV2 > min(LogPvThreshold3,LogPvThreshold2) && p->numpairs >= (CutFlip ? 2 : AlignedSiteThreshold2))){
	#pragma omp critical
	{
	  printf("refid=%d(id=%lld),mapid=%d(id=%lld):Malign[%d]:or=%d,rev=%d,pairs=%d,score=%0.6f,logPV=%0.2f,logPV2=%0.2f (S3= %0.6f, T3= %0.2f, A3= %d)\n",
		 refid,rmap->id,mapid,nanomap->id,t,p->orientation,p->rev,p->numpairs,p->score,p->logPV,p->logPV2, min(ScoreThreshold3,ScoreThreshold2), min(LogPvThreshold3,LogPvThreshold2), (CutFlip ? 2 : AlignedSiteThreshold2));
	  fflush(stdout);
	  assert((REFSPLIT_FIX || p->score > min(ScoreThreshold3,ScoreThreshold2)) && p->logPV2 > min(LogPvThreshold3,LogPvThreshold2) && p->numpairs >= (CutFlip ? 2 : AlignedSiteThreshold2));// If this fails, filter out MGs above
	}
      }
      if(AlignedThreshold(p, Y, ScoreThreshold, LogPvThreshold) && p->repeat <= 0 && p->score > bscore){
	if(t > 0){/* swap align->Malign[t] with align->Malign[0] */
	  Calign *tmp = align->Malign[0];
	  align->Malign[0] = align->Malign[t];
	  align->Malign[t] = tmp;
	}
	bscore = p->score;
      }
    }
    
    /* check if we need to update primary alignment */
    int U = align->numpairs;
    int U1 = align->Malign[0]->numpairs;
    Calign *r = align->Malign[0];
    if(!(align->score == r->score && align->orientation == r->orientation && U == U1 && align->sites1[U-1] == r->sites1[U1-1] && align->sites2[U-1] == r->sites2[U1-1] && align->sitesK1[U-1] == r->sitesK1[U1-1])){
      // make sure r[0] is above all thresholds (we have already verified that align is above all thresholds), except repeat check

      if(AlignedThreshold(align->Malign[0], Y, ScoreThreshold, LogPvThreshold)){
	updateAlignment(align,r,rmap,nanomap,r->orientation);/* update primary alignment from r */
	align->logPV2 = r->logPV2;
      } else {/* need to add align back to Malign[] : align->repeat is the reason the corresponding Malign[] got kicked out */
	int orientation = align->orientation;
	if(PVERB){
	  printf("Adding back primary alignment to Malign[]: multicnt=%d->%d\n",align->multicnt, align->multicnt+1);
	  fflush(stdout);
	}

	if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	  for(int i = 0; i < align->multimax; i++)
	    for(int j = i+1; j < align->multimax; j++)
	      if(align->Malign[i] == align->Malign[j]){
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		       refid,rmap->id,mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
		fflush(stdout);
		assert(align->Malign[i] != align->Malign[j]);
	      }
	}

	if(align->multimax <= align->multicnt){
	  int nmultimax = align->multicnt + 1;
	  Calign **nMalign = new Calign*[nmultimax];
	  for(int t = 0; t < align->multimax; t++)
	    nMalign[t] = align->Malign[t];
	  for(int t = align->multimax; t < nmultimax; t++)
	    nMalign[t] = new Calign[1];
	  delete [] align->Malign;
	  align->Malign = nMalign;
	  align->multimax = nmultimax;
	}

	if(DEBUG>=2){// check that no two align->Malign[t1] and align->Malign[t2] have the same pointer value 
	  for(int i = 0; i < align->multimax; i++)
	    for(int j = i+1; j < align->multimax; j++)
	      if(align->Malign[i] == align->Malign[j]){
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:Malign[%d]=%p,Malign[%d]=%p, multicnt=%d,multimax=%d (duplicate pointers)\n",
		       refid,rmap->id,mapid,nanomap->id,align->orientation,align->scaleID,i,align->Malign[i],j,align->Malign[j],align->multicnt,align->multimax);
		fflush(stdout);
		assert(align->Malign[i] != align->Malign[j]);
	      }
	}

	align->Malign[align->multicnt++] = align->Malign[0];
	Calign *nalign = align->Malign[0] = new Calign[1];
	copy(nalign,align,1, 1);// copy : automatically resets Malign
	if(DEBUG) assert(nalign->Malign == NULL);
      }
    }

    if(!AlignedThreshold(align, Y , ScoreThreshold, LogPvThreshold)){
      #pragma omp critical
      {
	if(RefSplit){
	  if(VERB>=2){
	    printf("WARNING: refid=%d(id=%lld),mapid=%d(id=%lld):After RefSplit original %d matchgroups changed into %d matchgroups and none of them score above thresholds:Best score=%0.6f,LogPV=%0.2f\n",
		   refid,rmap->id,mapid,nanomap->id,origmulticnt,align->multicnt,align->score,align->logPV);
	    fflush(stdout);
	  }
	  r->score = align->score = max(align->score,ScoreThreshold + 1e-6);
	  r->logPV = align->logPV = max(align->logPV,LogPvThreshold + 1e-2);
	  r->logPV2 = align->logPV2 = max(r->logPV, r->logPV2);
	  
	  if(!AlignedThreshold(align, Y , ScoreThreshold, LogPvThreshold)){// give up if some other threshold failed
	    if(VERB>=2)
	      printf("   Discarding all %d alignments\n",align->multicnt);
	    align->multicnt = 0;
	  } else if(VERB>=2)
	    printf("   Raising best score & logPV above threshold\n");
	  if(VERB>=2)
	    fflush(stdout);
	} else {
	  printf("WARNING: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:multicnt=%d,score=%0.6f,LogPV=%0.2f,Len=%0.3f,MaxOutlier=%0.3f,Lend=%d,Rend=%d: Best alignment no longer above thresholds!\n",
		 refid,rmap->id,mapid,nanomap->id,align->orientation,align->multicnt,align->score,align->logPV, AlignedLength(align,Y), min(999.0,align->maxoutlier),align->Lend,align->Rend);
	  printf("\t A= %d, S= %0.6f, T= %0.2f, L= %0.3f, I= %0.3f, E= %d\n", 
		 AlignedSiteThreshold,ScoreThreshold,LogPvThreshold,AlignedLengthThreshold, AlignedOutlierThreshold, AlignedEndOutlierThreshold);
	  for(int t = 0;t < align->multicnt; t++)
	    printf("  Malign[%d]:or=%d,score=%0.6f,logPV=%0.2f,numpairs=%d\n",t,align->Malign[t]->orientation,align->Malign[t]->score,align->Malign[t]->logPV,align->Malign[t]->numpairs);
	  fflush(stdout);
	  assert(AlignedThreshold(align, Y , ScoreThreshold, LogPvThreshold));
	}
      }
    }

    int orientation = align->orientation;

    if(DEBUG && RefSplit && !(align->logPV2 >= align->logPV)){
      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,pairs=%d,score=%0.6f,logPV=%0.2f,Len=%0.1f,repeat=%d:remaining %d -MultiMatch alignments:\n",
	     refid,rmap->id,mapid,nanomap->id,align->orientation,align->numpairs,align->score,align->logPV,AlignedLength(align,Y),align->repeat,align->multicnt);
      for(int t = 0; t < align->multicnt; t++){
	Calign *p = align->Malign[t];
	int U = p->numpairs;
	int I = p->sites1[U-1];
	int K = p->sitesK1[U-1];
	int J = p->sites2[U-1];
	int IL = p->sites1[0];
	int KL = p->sitesK1[0];
	int JL = p->sites2[0];
	printf("%d: I=%d..%d,K=%d..%d,J=%d..%d:orientation=%d,numpairs=%d,score=%0.6f,logPV=%0.2f,Len=%0.1f,repeat=%d,Rend=%d,Lend=%d\n",
	       t,IL,I,KL,K,JL,J,p->orientation,U,p->score,p->logPV, Y[I]-Y[IL], p->repeat,p->Rend,p->Lend);
      }
      printf("align->logPV2= %0.6f, align->logPV= %0.6f\n",align->logPV2,align->logPV);
      fflush(stdout);
      assert(align->logPV2 >= align->logPV);
    }

    if(PVERB && align->multicnt > 0){
      #pragma omp critical
      {
	printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,pairs=%d,score=%0.6f,logPV=%0.2f,Len=%0.1f,repeat=%d:remaining %d -MultiMatch alignments:\n",
	       refid,rmap->id,mapid,nanomap->id,align->orientation,align->numpairs,align->score,align->logPV,AlignedLength(align,Y),align->repeat,align->multicnt);
	for(int t = 0; t < align->multicnt; t++){
	  Calign *p = align->Malign[t];
	  int U = p->numpairs;
	  int I = p->sites1[U-1];
	  int K = p->sitesK1[U-1];
	  int J = p->sites2[U-1];
	  int IL = p->sites1[0];
	  int KL = p->sitesK1[0];
	  int JL = p->sites2[0];
	  printf("%d: I=%d..%d,K=%d..%d,J=%d..%d:orientation=%d,numpairs=%d,score=%0.6f,logPV=%0.2f,Len=%0.1f,repeat=%d,Rend=%d,Lend=%d\n",
		 t,IL,I,KL,K,JL,J,p->orientation,U,p->score,p->logPV, Y[I]-Y[IL], p->repeat,p->Rend,p->Lend);
	  if(PVERB>=3){
	    double sum = 0.0;
	    for(int T = 0; T <= U; T++){
	      sum += p->iscore[T];
	      if(T <= 0)
		printf("  T=%5d: I=%d,K=%d,J=%d: iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T],p->sitesK1[T],p->sites2[T],p->iscore[T], sum);
	      else if(T < U)
		printf("  T=%5d: I=%d..%d,K=%d..%d,J=%d..%d: outscore[T]= %0.6f, iscore[T]= %0.6f, iscoresum= %0.6f\n",
		       T,p->sites1[T-1],p->sites1[T],p->sitesK1[T-1],p->sitesK1[T],p->sites2[T-1],p->sites2[T],p->outscore[T],p->iscore[T], sum);
	      else
		printf("  T=%5d: iscore[T]= %0.6f, iscoresum= %0.6f\n", T, p->iscore[T], sum);
	    }
	  }
	}
	fflush(stdout); 
      }
    }

    if(DEBUG && !(align->score == align->Malign[0]->score && align->orientation == align->Malign[0]->orientation)){
      #pragma omp critical
      {
	printf("refid=%d(id=%lld),mapid=%d(id=%lld):align:or=%d,score=%0.6f,logPV=%0.2f,logPV2=%0.2f,numpairs=%d:multicnt=%d:\n",
	       refid,rmap->id,mapid,nanomap->id,align->orientation,align->score,align->logPV,RefSplit ? align->logPV2 : align->logPV, align->numpairs,align->multicnt);
	for(int t = 0;t < align->multicnt; t++)
	  printf("  Malign[%d]:or=%d,score=%0.6f,logPV=%0.2f,numpairs=%d\n",t,align->Malign[t]->orientation,align->Malign[t]->score,align->Malign[t]->logPV,align->Malign[t]->numpairs);
	fflush(stdout);
	assert(align->score == align->Malign[0]->score);
      }
    }
    if(DEBUG && RefSplit){
      assert(align->logPV2 >= align->logPV);
      for(int t = 0; t < align->multicnt; t++){
	Calign *p = align->Malign[t];
	assert(p->logPV2 >= p->logPV);
      }
    }
  }

  if(DEBUG && RepeatRec && RepeatMaxShift > 0 && RepeatLogPvalueRatio > 0.0 && !(align->repeat >= 0)){
    #pragma omp critical
    {
      assert(align->repeat >= 0);
    }
  }

  align->chimpair = 0;
  
  if(VERB>=2 || (TRACE && rmap->id==REF_TRACE && nanomap->id==MAP_TRACE)){
    #pragma omp critical
    {
      /*      printf("refalignSD:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,M=%d,score=%0.3f/%0.3f,logPV=%0.3f/%0.3f,numpairs=%d/%d,Length=%0.3f/%0.3f,repeat=%d\n",
	     refid,rmap->id, mapid,nanomap->id, align->orientation,nanomap->numsite[0],align->score,ScoreThreshold,align->logPV,LogPvThreshold,align->numpairs,AlignedSiteThreshold, 
	     align->numpairs ? AlignedLength(align,Y) : 0.0, AlignedLengthThreshold, align->repeat);*/
      printf("tid=%d,refid=%d(mapid1=%d,id=%lld),mapid=%d(mapid2=%d,id=%lld),or=%d,M=%d,score=%0.3f/%0.3f,logPV=%0.3f/%0.3f,numpairs=%d/%d,Length=%0.3f/%0.3f,repeat=%d,IsRepeatRegion=%d,multicnt=%d,align=%p,alignid=%lu,galign=%p(%lu)\n",
	     tid,refid,align->mapid1,rmap->id, mapid, align->mapid2,nanomap->id, align->orientation,nanomap->numsite[0],align->score,ScoreThreshold,align->logPV,LogPvThreshold,align->numpairs,AlignedSiteThreshold, 
	     align->numpairs ? AlignedLength(align,Y) : 0.0, AlignedLengthThreshold, align->repeat, align->IsRepeatRegion(), MultiMatches ? align->multicnt : 0, align, alignid, galign, &galign - alignment) ;
      fflush(stdout);
    }
  }

  if(AlignedThreshold(align, Y, ScoreThreshold, LogPvThreshold) && !align->IsRepeatRegion()){/* good alignment */

    if(DEBUG && MultiMatches && !(align->Malign && align->multicnt > 0)){
      #pragma omp critical
      {
	printf("WARNING:alignment[%lu]:refid=%d(mapid1=%d,id=%lld),mapid=%d(mapid2=%d,id=%lld),or=%d,sc=%d:score=%0.4f(S=%0.2f),logPV=%0.3f(T=%0.2f),pairs=%d,repeat=%d,IsRepeatRegion=%d:Malign=%p,multicnt=%d\n",
	       alignid-1,refid,align->mapid1,rmap->id,mapid,align->mapid2,Gmap[align->mapid2]->id,align->orientation,align->scaleID,align->score,ScoreThreshold,align->logPV,LogPvThreshold,
	       align->numpairs,align->repeat,align->IsRepeatRegion(),align->Malign,align->multicnt);
	fflush(stdout);
	if(DEBUG>=2) assert(align->Malign && align->multicnt > 0);
      }
    }

    if(VERB>=2 || (DEBUG && RefSplit && !(align->logPV2 >= align->logPV))){
      #pragma omp critical
      {
	printf("alignment[%lu]:refid=%d(mapid1=%d,id=%lld),mapid=%d(mapid2=%d,id=%lld),or=%d,rev=%d,sc=%d:score=%0.4f,logPV=%0.3f,logPV2=%0.3f,pairs=%d,nosplit=%d,repeat=%d,IsRepeatRegion=%d\n",
	       alignid-1,refid,align->mapid1,rmap->id,mapid,align->mapid2,Gmap[align->mapid2]->id,align->orientation,align->rev,align->scaleID,align->score,align->logPV, RefSplit ? align->logPV2 : align->logPV,
	       align->numpairs,nosplit,align->repeat,align->IsRepeatRegion());
	if(SecondBest && align->align2){
	  Calign *align2 = align->align2;
	  printf("    2nd Best:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.3f,pairs=%d\n",
		 align2->mapid1,align2->mapid2,Gmap[align2->mapid2]->id,align2->orientation,align2->score,align2->logPV,align2->numpairs);
	}
	fflush(stdout);
	if(DEBUG && RefSplit)  assert(align->logPV2 >= align->logPV);
      }
    }

    if(!galign){/* save local align to galign */
      galign = new Calign[1];
      if(DEBUG) assert(galign->Malign == NULL);

      /* swap *galign and *align : *align is on the stack and will automatically be deallocated by stack */
      Calign tmp = *galign;// NOTE : tmp ends up with copy of default initialized galign[0] and can be safely deallocated by stack
      *galign = *align;
      *align = tmp;
      if(DEBUG){
	assert(galign->numpairs > 0);
	assert(galign->sites1[0] >= 1 && galign->sites1[galign->numpairs-1] <= N);
	assert(galign->sites2[0] >= 1 && galign->sites2[galign->numpairs-1] <= M);
      }
      align = galign;
      if(DEBUG && RefSplit) assert(align->logPV2 >= align->logPV);
      if(DEBUG) assert(Lalign.Malign == NULL);
    }
    if(DEBUG) assert(Lalign.Malign == NULL);

    /* check if mapid is a chimeric fragment : if so check how close the original fragment aligned (tandem alignment) */
    if(nanomap->origmap){
      /* locate original alignment in alignment[0..numaligns-2] */
      Cmap *origmap = nanomap->origmap;
      Calign *origalign = 0;
      int i;
      for(i = numaligns-1;--i >= 0;)
	if((origalign = alignment[i]) && Gmap[origalign->mapid2] ==  origmap && origalign->mapid1 == align->mapid1)
	  break;
      if(i < 0){
	printf("refid=%d,mapid=%d:Could not find alignment for original (complete) map\n",refid,mapid);
	fflush(stdout);exit(1);
      }
      if(nosplit && DEBUG) assert(!Gmap[origalign->mapid2]->origmap);
      /*      if(VERB && nanomap->id==96){
	printf("refid=%d,mapid=%d:id=%d,M=%d,origmapid=%d(origM=%d),orientation=%d,origorientation=%d\n",
	       refid,mapid,nanomap->id, nanomap->numsite[0], origalign->mapid2, Gmap[origalign->mapid2]->numsite[0],
	       align->orientation,origalign->orientation);
	fflush(stdout);
	}*/
      int tandem = 0;
      if(align->orientation == origalign->orientation){/* if orientations don't match, the fragments cannot be tandem alignments */
	if(!align->orientation){
	  int left = nanomap->left[0];
	  int right = nanomap->right[0];
	  int origM = Gmap[origalign->mapid2]->numsite[0];

	  int LI = align->sites1[0];
	  int LK = align->sitesK1[0];
	  int LJ = align->sites2[0] + max(0, left - 1);
	  int RI = align->sites1[align->numpairs-1];
	  int RK = align->sitesK1[align->numpairs-1];
	  int RJ = align->sites2[align->numpairs-1] + max(0, left -1);
	  
	  int origLI = origalign->sites1[0];
	  int origLK = origalign->sitesK1[0];
	  int origLJ = origalign->sites2[0];
	  int origRI = origalign->sites1[origalign->numpairs-1];
	  int origRK = origalign->sitesK1[origalign->numpairs-1];
	  int origRJ = origalign->sites2[origalign->numpairs-1];
	  
	  FLOAT *origX = origmap->site[0];

	  double Ygap = Yc(Y,LI,LK) - Yc(Y,origRI,origRK);
	  if(Ygap >= 0.0){
	    double Xgap = origX[LJ] - origX[origRJ];
	    if(Xgap > 0.0 && Xgap < Ygap + 2.0*Ylambda && Ygap <= Xgap + 2.0*Ylambda){
	      if(VERB>=2){
		printf("refid=%d,mapid=%d:origid=%d(M=%d),OR=%d,left=%d,right=%d:Ygap=%0.3f(%d,%d..%d,%d),Xgap=%0.3f(%d..%d)\n",
		       refid,mapid,origalign->mapid2,origM,
		       align->orientation,left,right,Ygap,origRI,origRK,LI,LK,Xgap,origRJ,LJ);
		fflush(stdout);
	      }
	      tandem++;

              #pragma omp atomic
	      chimpaircnt++;

	      if(DEBUG) assert(!align->chimpair);
	      align->chimpair = 1;
	      if(Xgap > 0.0)
		if(DEBUG) assert(LJ > origRJ);
	    }
	  } else {
	    Ygap = Yc(Y,origLI,origLK) - Yc(Y,RI,RK);
	    if(Ygap >= 0.0){
	      double Xgap = origX[origLJ] - origX[RJ];
	      if(Xgap > 0.0 && Xgap < Ygap + 2.0*Ylambda && Ygap - Xgap <= 2.0*Ylambda){
		if(VERB>=2){
		  printf("refid=%d,mapid=%d:origid=%d(M=%d),OR=%d,left=%d,right=%d:Yngap=%0.3f(%d,%d..%d,%d),Xngap=%0.3f(%d..%d)\n",
			 refid,mapid,origalign->mapid2,origM,
			 align->orientation,left,right,Ygap,RI,RK,origLI,origLK,Xgap,RJ,origLJ);
		  fflush(stdout);
		}
		tandem++;

                #pragma omp atomic
		chimpaircnt++;

		if(DEBUG) assert(!align->chimpair);
		align->chimpair = 1;
		if(Xgap > 0.0)
		  if(DEBUG) assert(origLJ > RJ);
	      }
	    }
	  }
	} else {/* align->orientation == 1 */
	  int left = nanomap->left[0];
	  int right = nanomap->right[0];
	  int origN = rmap->numsite[0];
	  int origM = Gmap[origalign->mapid2]->numsite[0];

	  int LI = align->sites1[0];
	  int LK = align->sitesK1[0];
	  int LJ = (M + 1 - align->sites2[0]) + max(0,left-1);
	  int RI = align->sites1[align->numpairs-1];
	  int RK = align->sitesK1[align->numpairs-1];
	  int RJ = (M + 1 - align->sites2[align->numpairs-1]) + max(0,left -1);

	  int origLI = origalign->sites1[0];
	  int origLK = origalign->sitesK1[0];
	  int origRI = origalign->sites1[origalign->numpairs-1];
	  int origRK = origalign->sitesK1[origalign->numpairs-1];
	  int origLJ = origM + 1 - origalign->sites2[0];
	  int origRJ = origM + 1 - origalign->sites2[origalign->numpairs-1];

	  if(DEBUG) assert(origRI-origRK >= 1 && origRI <= origN);
	  if(DEBUG) assert(origRJ >= 1 && origRJ <= origM);

	  FLOAT *origX = origmap->site[0];

	  double Ygap = Yc(Y,LI,LK) - Yc(Y,origRI,origRK);
	  if(Ygap >= 0.0){
	    double Xgap = origX[origRJ] - origX[LJ];
	    if(Xgap > 0.0 && Xgap < Ygap + 2.0*Ylambda && Ygap <= Xgap + 2.0*Ylambda){
	      if(VERB>=2){
		printf("refid=%d,mapid=%d:origid=%d(M=%d),OR=%d,left=%d,right=%d:Ygap=%0.3f(%d,%d..%d,%d),Xgap=%0.3f(%d..%d)\n",
		       refid,mapid,origalign->mapid2,origM,
		       align->orientation,left,right,Ygap,origRI,origRK,LI,LK,Xgap,LJ,origRJ);
		fflush(stdout);
	      }
	      tandem++;

              #pragma omp atomic
  	      chimpaircnt++;

	      if(DEBUG) assert(!align->chimpair);
	      align->chimpair = 1;
	      if(Xgap > 0.0)
		if(DEBUG) assert(origRJ > LJ);
	    }
	  } else {
	    Ygap = Yc(Y,origLI,origLK) - Yc(Y,RI,RK);
	    if(Ygap >= 0.0){
	      double Xgap = origX[RJ] - origX[origLJ];
	      if(Xgap > 0.0 && Xgap < Ygap + 2.0*Ylambda && Ygap <= Xgap + 2.0*Ylambda){
		if(VERB>=2){
		  printf("refid=%d,mapid=%d:origid=%d(M=%d),OR=%d,left=%d,right=%d:Yngap=%0.3f(%d,%d..%d,%d),Xngap=%0.3f(%d..%d)\n",
			 refid,mapid,origalign->mapid2,origM,
			 align->orientation,left,right,Ygap,RI,RK,origLI,origLK,Xgap,origLJ,RJ);
		  fflush(stdout);
		}
		tandem++;

                #pragma omp atomic
		chimpaircnt++;

		if(DEBUG) assert(!align->chimpair);
		align->chimpair = 1;
		if(Xgap > 0.0)
		  if(DEBUG) assert(RJ > origLJ);
	      }
	    }
	  }
	}
      } 
      if(TRACE && !tandem){/* not a tandem alignment : a true chimerism */
	printf("chimeric alignment: refid=%d,mapid=%d(id=%lld):M=%d(origM=%d),orientation=%d,origorientation=%d\n",
	       refid,origalign->mapid2,Gmap[origalign->mapid2]->id,nanomap->numsite[0],Gmap[origalign->mapid2]->numsite[0],align->orientation,origalign->orientation);
	fflush(stdout);
      }
    }

    /* check if chimeric split is required */
    if((align->Rend <= -2 || align->Lend <= -2) && (!nosplit || !nanomap->origmap) && nosplit <= 1){
      int J = -1;
      if(align->Lend <= -2 && (J = align->sites2[0]) - 1 >= AlignedSiteThreshold){ /* save copy of left remainder of Query Map and append it to the end of maps[] */
	/* left end is cut off 0.001 kb left of site J */

	Cmap *origmap = nanomap;
	Cmap *newmap;

	int J1 = -1, M1 = -1;
	FLOAT **XX = nanomap->site;
	if(usecolor){
	  M1 = nanomap->numsite[1];
	  if(!align->orientation){  /* locate largest J1 such that XX[1][J1 - 1] < XX[0][J] */
	    for(J1 = 1; J1 <= M1; J1++)
	      if(XX[1][J1] >= XX[0][J])
		break;
	  } else {/* locate largest J1 such that XX[1][M1+1] - XX[1][M1+1 - (J1-1)] < XX[0][M+1] - XX[0][M+1-J] */
	    for(J1 = 1; J1 <= M1; J1++)
	      if(XX[1][M1+1] - XX[1][M1+1 - J1] >= XX[0][M+1] - XX[0][M+1 - J])
		break;
	  }
	}

        #pragma omp critical 	
	{
	  maxmapalloc(totalmaps+1,maxmaps,Gmap,0,1);
	  XXmap = Gmap;
	  newmap = Gmap[totalmaps];
	  if(!newmap)
	    Gmap[totalmaps] = newmap = new Cmap;
	  newmap->mapid = totalmaps++;
	}

	newmap->allfree();
	newmap->origmap = origmap;
	newmap->id = origmap->id;
	newmap->numsite[0] = J - 1;
	newmap->site[0] = new FLOAT[newmap->numsite[0] + 2];
	newmap->site[0][0] = 0.0;

	newmap->ScanNumber = origmap->ScanNumber;
	newmap->ScanDirection = origmap->ScanDirection;
	newmap->UniqueScanId = origmap->UniqueScanId;

	if(usecolor){
	  newmap->numsite[1] = J1 - 1;
	  newmap->site[1] = new FLOAT[newmap->numsite[1] + 2];
	  newmap->site[1][0] = 0.0;
	}

	if(!align->orientation){
	  newmap->left[0] = 0;
	  newmap->right[0] = J - 1;
	  for(int i = 1; i < J; i++)
	    newmap->site[0][i] = XX[0][i];
	  newmap->site[0][J] = XX[0][J] - 0.001;
	  if(usecolor){
	    newmap->left[1] = 0;
	    newmap->right[1] = J1 - 1;
	    for(int i = 1; i < J1; i++)
	      newmap->site[1][i] = XX[1][i];
	    newmap->site[1][J1] = newmap->site[0][J];
	  }
	} else {
	  FLOAT len = XX[0][M+1] - XX[0][M+1 - J] - 0.001;
	  newmap->right[0] = M+1;
	  newmap->left[0] = M+1 - (J-1);
	  for(int i = 1; i <= J; i++)
	    newmap->site[0][i] = XX[0][newmap->left[0] + i-1] - (XX[0][M+1] - len);
	  if(usecolor){
	    newmap->left[1] = M1+1;
	    newmap->right[1] = M1+1 - (J1-1);
	    for(int i = 1; i <= J1; i++)
	      newmap->site[1][i] = XX[1][newmap->left[1] + i-1] - (XX[1][M1+1] - len);
	  }
	}

	newmap->len = nanomap->len * (XX[0][J]/XX[0][M+1]);
	newmap->fpcnt = -1;

	if(VERB>=2){
	  #pragma omp critical
	  {
	    if(origmap->name)
	      printf("refid=%d,mapid=%d(id=%lld):Lend=%d,Rend=%d,score=%0.4f,or=%d:left fragment at maps[%d],sites=%d(left=%d,right=%d,len=%0.3f kb),name=%s\n",
		     refid,mapid,Gmap[mapid]->id,align->Lend,align->Rend,align->score,align->orientation, 
		     totalmaps-1,newmap->numsite[0],newmap->left[0],newmap->right[0],newmap->len, origmap->name);
	    else
	      printf("refid=%d,mapid=%d(id=%lld):Lend=%d,Rend=%d,score=%0.4f,or=%d:left fragment at maps[%d],sites=%d(left=%d,right=%d,len=%0.3f kb)\n",
		     refid,mapid,Gmap[mapid]->id,align->Lend,align->Rend,align->score,align->orientation, 
		     totalmaps-1,newmap->numsite[0],newmap->left[0],newmap->right[0],newmap->len);
	    fflush(stdout);
	  }
	}
	if(DEBUG>=3){
	  if(nanomap->id == 8400138831007101982LL){
	    for(int t = 0; t <= J; t++)
	      printf("X[%d]= %0.8f\n",t,newmap->site[0][t]);
	    fflush(stdout);
	  }
	  assert(X[0] == 0.0);
	  for(int j = 1; j <= J; j++)
	    assert(newmap->site[0][j] > newmap->site[0][j-1]);
	}

	if(phash && hashdelta && HashMultiMatch){ /* use same hashtable entries to try alignment of newmap */
	  size_t origalignid = alignid;

	  refalignSD(rmap, newmap, alignid, RKmax, refid, newmap->mapid, phash, XPen, A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, tid, numthreads, limN, 2, maxmatchgroup, matchgroup, mheap);

	  if(VERB>=2){
	    Calign *align = alignment[origalignid];
	    if(align && AlignedThreshold(align, Y, ScoreThreshold, LogPvThreshold)){
              #pragma omp critical
	      {
		printf("split alignment[%lu]:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.3f,pairs=%d\n",
		       origalignid,align->mapid1,align->mapid2,Gmap[align->mapid2]->id,align->orientation,align->score,align->logPV,align->numpairs);
		fflush(stdout);
	      }
	    }
	  }
	}
      }

      if(align->Rend <= -2 && M-(J = align->sites2[align->numpairs-1]) >= AlignedSiteThreshold){/* save copy of right remainder of Qeury Map and append it to the end of maps[] */
	/* right end is cut off 0.001 kb right of site J */
	Cmap *origmap = nanomap;
	Cmap *newmap;
	
	int J1 = -1, M1 = -1;
	FLOAT **XX = nanomap->site;
	if(usecolor){
	  M1 = nanomap->numsite[1];
	  if(!align->orientation){/* locate smallest J1 such that XX[1][J1 + 1] > XX[0][J] */
	    for(J1 = M1; J1 >= 1; J1--)
	      if(XX[1][J1] <= XX[0][J])
		break;
	  } else {/* locate smallest J1 such that XX[1][M1+1] - XX[1][M1+1 - (J1+1)] > XX[0][M+1] - XX[0][M+1-J] */
	    for(J1 = M1; J1 >= 1; J1--)
	      if(XX[1][M1+1] - XX[1][M1+1 - J1] <= XX[0][M+1] - XX[0][M+1-J])
		break;
	  }
	}

        #pragma omp critical 
	{ 
	  maxmapalloc(totalmaps+1,maxmaps,Gmap,0,1);
	  XXmap = Gmap;
	  newmap = Gmap[totalmaps];
	  if(!newmap)
	    Gmap[totalmaps] = newmap = new Cmap;
	  newmap->mapid = totalmaps++;
	}
	if(DEBUG) assert(nanomap == Gmap[mapid]);

	newmap->allfree();
	newmap->origmap = origmap;
	newmap->id = origmap->id;
	newmap->numsite[0] = M - J;
	newmap->site[0] = new FLOAT[newmap->numsite[0] + 2];
	newmap->site[0][0] = 0.0;
	newmap->ScanNumber = origmap->ScanNumber;
	newmap->ScanDirection = origmap->ScanDirection;
	newmap->UniqueScanId = origmap->UniqueScanId;
	if(usecolor){
	  newmap->numsite[1] = M1 - J1;
	  newmap->site[1] = new FLOAT[newmap->numsite[1] + 2];
	  newmap->site[1][0] = 0.0;
	}

	if(!align->orientation){
	  newmap->left[0] = J + 1;
	  newmap->right[0] = M + 1;
	  for(int i = 1; i <= M+1-J; i++)
	    newmap->site[0][i] = X[J + i] - X[J] - 0.001;
	  if(usecolor){
	    double len = newmap->site[0][M+1-J];
	    newmap->left[1] = J1 + 1;
	    newmap->right[1] = M1 + 1;
	    for(int i = 1; i <= M1 + 1 - J1; i++)
	      newmap->site[1][i] = len - (XX[1][M1+1] - XX[1][J1 + i]);
	  }
	} else {
	  newmap->left[0] = 0;
	  newmap->right[0] = M-J;
	  for(int i = 1; i <= M-J; i++)
	    newmap->site[0][i] = X[i];
	  double len = newmap->site[0][M+1-J] = X[M+1-J] - 0.001;
	  if(usecolor){
	    newmap->left[1] = 0;
	    newmap->right[1] = M1 - J1;
	    for(int i = 1; i <= M1 - J1; i++)
	      newmap->site[0][i] = XX[1][i];
	    newmap->site[0][M1+1-J] = len;
	  }
	}

	newmap->len = origmap->len * (newmap->site[0][M-J+1]/X[M+1]);
	newmap->fpcnt = -1;

	if(VERB>=2){
	  #pragma omp critical
	  {
	    if(origmap->name)
	      printf("refid=%d,mapid=%d:Lend=%d,Rend=%d,score=%0.4f,or=%d:right fragment at maps[%d],sites=%d(left=%d,right=%d,len=%0.3f kb),name=%s\n",
		     refid,mapid,align->Lend,align->Rend,align->score,align->orientation,
		     totalmaps-1,newmap->numsite[0],newmap->left[0],newmap->right[0], newmap->len,origmap->name);
	    else
	      printf("refid=%d,mapid=%d:Lend=%d,Rend=%d,score=%0.4f,or=%d:right fragment at maps[%d],sites=%d(left=%d,right=%d,len=%0.3f kb)\n",
		     refid,mapid,align->Lend,align->Rend,align->score,align->orientation,
		     totalmaps-1,newmap->numsite[0],newmap->left[0],newmap->right[0], newmap->len);
	    fflush(stdout);
	  }
	}
	if(DEBUG>=3){
	  if(nanomap->id == 8400138831007101982LL){
	    for(int t = 0; t <= M-J+1; t++)
	      printf("X[%d]= %0.8f\n",t,newmap->site[0][t]);
	    fflush(stdout);
	  }
	  for(int j = 1; j <= M-J+1; j++)
	    assert(newmap->site[0][j] > newmap->site[0][j-1]);
	}

	if(phash && hashdelta && HashMultiMatch){ /* use same hashtable entries to try to alignment newmap */
	  size_t origalignid = alignid;

	  refalignSD(rmap, newmap, alignid, RKmax, refid, newmap->mapid, phash, XPen, A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, tid, numthreads, limN, 2, maxmatchgroup, matchgroup, mheap);

	  if(VERB>=2){
	    Calign *align = alignment[origalignid];
	    if(align && AlignedThreshold(align, Y, ScoreThreshold, LogPvThreshold)){
              #pragma omp critical
	      {
		printf("split alignment[%lu]:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.3f,pairs=%d\n",
		       origalignid,align->mapid1,align->mapid2,Gmap[align->mapid2]->id,align->orientation,align->score,align->logPV,align->numpairs);
		fflush(stdout);
	      }
	    }
	  }
	}
      }
    }
  } else /* NOT good alignment */ if(DEBUG && MultiMatches && !(CutFlip && (LogPvThreshold3 < LogPvThreshold && ScoreThreshold3 < ScoreThreshold))
				     && LogPvThreshold2 >= LogPvThreshold && ScoreThreshold2 >= ScoreThreshold && (align->Malign && align->multicnt > 0) &&
				     !(align->score > ScoreThreshold && align->logPV > LogPvThreshold)){
    #pragma omp critical
    {
      printf("WARNING:refalignSD:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,M=%d,score=%0.3f/%0.3f,logPV=%0.3f/%0.3f,numpairs=%d/%d,Length=%0.3f/%0.3f,repeat=%d,IsRepeatRegion=%d\n",
	     refid,rmap->id, mapid,nanomap->id, align->orientation,nanomap->numsite[0],align->score,ScoreThreshold,align->logPV,LogPvThreshold,align->numpairs,AlignedSiteThreshold, 
	     align->numpairs ? AlignedLength(align,Y) : 0.0, AlignedLengthThreshold, align->repeat, align->IsRepeatRegion());
      printf("   multicnt=%d,multimax=%d\n",align->multicnt,align->multimax);
      for(int t = 0; t < align->multicnt; t++){
	Calign *p = align->Malign[t];
	int U = p->numpairs;
	int I = p->sites1[U-1];
	int K = p->sitesK1[U-1];
	int J = p->sites2[U-1];
	int IL = p->sites1[0];
	int KL = p->sitesK1[0];
	int JL = p->sites2[0];
	printf("%d: or=%d,I=%d..%d,K=%d..%d,J=%d..%d:numpairs=%d,score=%0.6f,logPV=%0.2f\n",t,p->orientation,IL,I,KL,K,JL,J,U,p->score,p->logPV);
      }
      fflush(stdout);
      if(DEBUG>=2) assert(!(align->Malign && align->multicnt > 0)); // This assertion can occasionally fail (bad alignment survived in align->Malign) : cause unknown
    }
  }
  if(M > MAX_ALLOCA)
    delete [] Xrev;
  if(N > MAX_ALLOCA)
    delete [] Yrev;
  
  double wt = 0.0;

  if(RA_MIN_TIME && FmemHWM[tid] > 0 && (wt = wtime()) - FmemTime[tid] >= RA_MIN_TIME && VmRSS + VmSwap > MaxMemSiz * RA_MAX_MEM){
    long long sVmSize,sVmRSS,sVmSwap,sVmHWM;// local copies, so global shared values are not modified
    if(VERB>=3)
      getmem(sVmSize,sVmRSS,sVmSwap,&sVmHWM);

    long long HWMsiz = MADVISE_HWM ? FmemHWM[tid] : FmemSiz[tid];
    FmemMadv[tid] += HWMsiz;
    if(madvise(&Fmem[-PADDING/sizeof(RFLOAT)],HWMsiz,MADV_DONTNEED)){
      int eno = errno;
      char *err = strerror(eno);
      printf("tid=%d:madvise(%p,%lld,MADV_DONTNEED) failed (FmemSiz[tid]=%lld,FmemHWM[tid]=%lld):errno=%d:%s\n",tid,Fmem,HWMsiz,FmemSiz[tid],FmemHWM[tid],eno,err);
      fflush(stdout);exit(1);
    }
    if(VERB>=3){
      long long rVmSize,rVmRSS,rVmSwap,rVmHWM;// local copies, so global shared values are not modified
      getmem(rVmSize,rVmRSS,rVmSwap,&rVmHWM);
      
      printf("tid=%d:called madvise() on %0.4f/%0.4f Gb: VmRSS= %0.4f -> %0.4f(HWM=%0.2f), VmSwap= %0.4f Gb: wt= %0.6f\n", 
	tid, FmemHWM[tid] * 1e-9, FmemSiz[tid] * 1e-9,sVmRSS*1e-9,rVmRSS*1e-9,rVmHWM*1e-9,rVmSwap*1e-9,wtime());
      fflush(stdout);
    }

    FmemHWM[tid] = 0;
    FmemTime[tid] = wt;    
  }

  if(VERB>=2 || MIN_MEM_DEBUG){
    wt = wtime();

    long long sVmSize,sVmRSS,sVmSwap,sVmHWM;// local copies, so global shared values are not modified

    #pragma omp critical(vmemTotsiz)
    {
      getmem(sVmSize,sVmRSS,sVmSwap, &sVmHWM);
      //      realVmRSS = sVmRSS;

      if(DEBUG>=2 && !(sVmRSS <= sVmHWM)){
	printf("tid=%d: VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: wt= %0.6f, wtime= %0.6f\n",tid,sVmRSS*1e-9,sVmHWM*1e-9,sVmSwap*1e-9,sVmSize*1e-9,wt,wtime());
	fflush(stdout);
	assert(sVmRSS <= sVmHWM);
      }
      lastGetmem = wt;
    }
    
    #pragma omp critical
    {
      if(wstart > 0.0)
	printf("Completed refalignSD: refid=%d(id=%lld),mapid=%d(id=%lld):tid=%d,or=%d:M=%d,N=%d,multicnt=%d (VmRSS=%0.3f -> %0.3f,VmSwap=%0.3f Gb): wall time = %0.6f (cum wall= %0.6f)\n",
		refid,rmap->id,mapid,nanomap->id,tid,align->orientation,M,N,align->multicnt, sVmRSS*1e-9,VmRSS*1e-9,sVmSwap*1e-9,wt - wstart, wt);
      else
	printf("Completed refalignSD: refid=%d(id=%lld),mapid=%d(id=%lld):tid=%d,or=%d:M=%d,N=%d,multicnt=%d (VmRSS=%0.3f -> %0.3f,VmSwap=%0.3f Gb): cum wall= %0.6f\n",
		refid,rmap->id,mapid,nanomap->id,tid,align->orientation,M,N,align->multicnt, sVmRSS*1e-9,VmRSS*1e-9, sVmSwap*1e-9, wt);
      fflush(stdout);
    }
  }
}

static int FPcnt3 = 0;// If FPDEBUG : cumulative (m-1) (False Positive count)
static double Xlen3cum = 0.0;// If FPDEBUG : cumulative Xlen3
static double logLR1cum = 0.0;
static double logLR2cum = 0.0;
static double logLR3cum = 0.0;// If FPDEBUG : cumulative logLR3
static double noFP3cum = 0.0;// If FPDEBUG : cumulative logLR3 without Frate or FpPenalty terms

/* structure to store alignment statistics in logLR */
class AlignStat
{
public:
  double len;
  int fp;
  int fn;
  int sitecnt;

  AlignStat()
  {
    len = 0.0;
    fp = fn = sitecnt = 0;
  }
};

static double logLR(int mapid, int refid, FLOAT *X, FLOAT *Y, 
		    int M,int N,
		    Calign *align,
		    int I, int J, int K,/**< K==0 unless resSD > 0 */
		    int RJ,/**< right end of alignment */
		    int Lij, int Rij, int Lijx, int Rijx,
		    int update,/**< 0 if called to verify original logLR, 1 if an error parameter update is being computed : 
				  If update==1 : freeze the original outlier calls, but also check LR with updated outlier calls to make sure it is equal or better than with original outlier calls
				*/
		    int verb,
		    double *LLsd,/**< If != 0 : set to logLR component that is a function of SF, SD, SR, SE. Also forces full recomputation of LR even if !RESDEBUG */
		    double *Xlen, /**< If != 0 : set to sum of X interval lengths that contributed to Frate terms */
		    double minSNR = 0.0,/* If > 0 : ignore query labels with SNR < minSNR[0] */
		    AlignStat *pstat = NULL)  /* If != NULL : update alignment statistics needed to compute updated FP and FN */
{
  if(REFDEBUG &&/* HERE HERE */ (outlierLambda <= 1000.0 || outlierMax <= 1000.0)){
    printf("logLR() not yet implemented with -outlierMax or -outlierLambda\n");
    fflush(stdout);exit(1);
    /* NOTE : need to update outlier scoring */
  }

  double *SNR = NULL;

  int T = 0;
  int U = align->numpairs;

  if(DEBUG>=2) assert(I == align->sites1[T]);
  if(DEBUG>=2) assert(K == align->sitesK1[T]);
  if(DEBUG>=2) assert(J == align->sites2[T]);
  if(DEBUG>=2) assert(RJ == align->sites2[U - 1]);

  if(minSNR > 0.0){/* check if label J is thresholded by minSNR[0] : if so advance T */
    SNR = XXmap[mapid]->SNR[0];
    if(align->orientation == 0){
      while(SNR[J] < minSNR){
	if(++T >= U)
	  break;
	I = align->sites1[T];
	K = align->sitesK1[T];
	J = align->sites2[T];
      }
      if(MINSNR_FIX){
	while(SNR[RJ] < minSNR){
	  if(T >= --U)
	    break;
	  RJ = align->sites2[U-1];
	}
      }
    } else {
      while(SNR[M+1-J] < minSNR){
	if(++T >= U)
	  break;
	I = align->sites1[T];
	K = align->sitesK1[T];
	J = align->sites2[T];
      }
      if(MINSNR_FIX){
	while(SNR[M+1-RJ] < minSNR){
	  if(T >= --U)
	    break;
	  RJ = align->sites2[U-1];
	}
      }
    }

    if(verb){
      #pragma omp critical
      {
        printf("logLR():minSNR=%0.3f:id=%lld:numpairs=%d,T=%d\n",minSNR,Gmap[mapid]->id,U,T);
        if(T < U)
	  printf("\t I=%d,K=%d,J=%d:SNR[J]=%0.3f\n",align->sites1[T],align->sitesK1[T],align->sites2[T],align->orientation ? SNR[M+1-align->sites2[T]] : SNR[align->sites2[T]]);
        fflush(stdout);
      }
    }

    if(T >= U)
      return min(ScoreThreshold, 2.0*ChimScore);
  }

  //  LFLOAT F = FP[0]*0.01;

  LFLOAT scale = ScaleDeltaBPP ? 1.0 : (align->scaleID > 1) ? ScaleFactor[align->scaleID] : 1.0;
  LFLOAT XlenB = 0.0;
  int Jmin = ((NEW >= 2) ? (align->Lend != -2) : (align->Lend > -2)) ? 0 : J;
  int Jmax = ((NEW >= 2) ? (align->Rend != -2) : (align->Rend > -2)) ? M+1 : RJ;
  for(int j= Jmin;j < Jmax;j++)
    XlenB += max((FLOAT)0.0,X[j+1]-X[j] - resKB2);
  XlenB *= scale;
  LFLOAT TotalBias = (Jmax-Jmin-2)*FBias + EBias*((Jmin==0?1:0)+(Jmax==M+1?1:0));
  TotalBias += XlenB*(Frate + LBias);
  TotalBias *= biasWT;

  LFLOAT logLR1 = align->score - TotalBias;
  if(0 && !REFDEBUG && !LLsd)
    return logLR1;

  if(DEBUG) assert(NEW >= 2);
  if(DEBUG) assert(resKB2 == 0.0);

  // accumulate alignment statistics (needed if pstat != NULL)
  double len=0.0;/* sum of aligned lengths (excluding internal outlier regions) */
  int Ysites = 0, sitecnt=0, fp=0, fn=0;/* count of total, false-negative and false-positive sites in aligned region of reference */

  int origFPcnt = FPcnt3;

  LFLOAT Bscale = 1.0-BETA;

  /* The following variables are used for full LR evaluation */
  LFLOAT logLR2 = 0.0;/* 2nd way to compute -log(LR) */
  LFLOAT score2 = 0.0;/* 2nd way to compute S(X) = -log(LR(X)) -E(-log(LR(X))|X) */
  LFLOAT TotBias2 = 0.0;/* 2nd way to compute TotalBias = -E(-log(LR(X))|X)*/
  
  /* The following variables are used with update==1 to compute LR with outlier calls frozen as specified in align[] */
  LFLOAT logLR3 = 0.0;
  LFLOAT score3 = 0.0;
  LFLOAT score3sd = 0.0;/* score3sd is the part of score3 that is a function of SD or SF */
  LFLOAT Xlen3 = 0.0;/* Xlen3 is the sum of X interval lengths that contribute to Frate based terms in score3 */

  /* left end fragment */
  LFLOAT x = scale * ((align->orientation==0) ? X[J] : X[M+1] - X[M+1-J]);
  LFLOAT xLijx_1 = (Lijx <= 0) ? 0.0 : scale * ((align->orientation==0) ? X[Lijx-1] : X[M+1] - X[M+1-(Lijx-1)]);

  int n = I - K - Lij + 1;
  int m = J;
  if(minSNR > 0.0){
    if(align->orientation==0){
      for(int j = 1; j < J; j++)
	if(SNR[j] < minSNR)
	  m--;
    } else {
      for(int j = 1; j < J; j++)
	if(SNR[M+1-j] < minSNR)
	  m--;
    }
  }
  if(DEBUG && !(n >= 1)){
    printf("logLR:mapid=%d(id=%lld),refid=%d(id=%lld),or=%d,logPV=%0.2f,pairs=%d: I=%d, K=%d, Lij=%d:n=%d\n",
	   mapid,XXmap[mapid]->id,refid,YYmap[refid]->id,align->orientation,align->logPV,align->numpairs,I,K,Lij,n);
    fflush(stdout);
    assert(n >= 1);
  }
  if(DEBUG) assert(m >= 1);

  LFLOAT term;
  LFLOAT xB = max(LZERO,x-resKB2);
  if(VERB && verb){
    printf("logLR:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d,res=%0.6f,resSD=%0.6f,Xtheta=%0.8f,FP=%0.8f,FN=%0.6f,scale=%0.8f,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f,Frate=%0.9f,FpPenalty=%0.8f\n",
	   refid,refmap[refid]->id,mapid,Gmap[mapid]->id,align->orientation,align->scaleID,res[0],resSD[0],Xtheta,FP[0],FN[0],scale,SF[0],SD[0],SR[0],SE[0],Frate,FpPenalty);
    fflush(stdout);
  }

  LFLOAT sm = Sm(J,I,K,Y);
  double sdterm = 0.0;
  LFLOAT Bias = biasWT * (xB*(Frate+LBias) + (m-1)*FBias + EBias);

  int KL = K;
  if(MINSNR_FIX && pstat && align->Lend > -2){
    len += x;
    for(int t = max(1,Lijx); t < J; t++)
      fp++;
    // HERE     fp += max(0, J - max(1,Lijx));
    Ysites += I - K - max(1,Lij);
  }

  if(align->Lend <= -2){/* end outlier */
    Bias = BiasEnd2(x,J);
    term = ChimScore;
  } else if(ENDFIX && x <= Yc(Y,I,K) && Lij > 0 && Yc(Y,I,K)-Y[Lij-1] < x){ /* Sbnd(x,Y[I,K]-Y[Lij-1],n,m) ( NOTE: RES_VARIANCE is ignored) */
    LFLOAT y = Yc(Y,I,K)-Y[Lij-1];
    LFLOAT var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
    if(QUADRATIC_VARIANCE)
      var += SR[0]*SR[0]*y*y;
    LFLOAT err = x-y;
    term = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */ - err*err*0.5/var;
    if(SDDEBUG){
      score3sd += sdterm = -0.5*err*err/var;
      Xlen3 += xB;
      if(FPDEBUG)
	FPcnt3 += m-1;
    }
  } else if(ENDFIX && extend && x >= Yc(Y,I,K) && Lijx > 0 && x - xLijx_1 < Yc(Y,I,K)){/* Sbnd(x-xLijx_1, Yc(Y,I,K), J+1-Lijx, I-K) */
    LFLOAT y = Yc(Y,I,K);
    LFLOAT var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
    if(QUADRATIC_VARIANCE)
      var += SR[0]*SR[0]*y*y;
    x = x - xLijx_1;
    xB = max(LZERO,x-resKB2);
    LFLOAT err = x - y;
    m = J+1-Lijx;
    if(minSNR > 0.0){
      if(align->orientation==0){
	for(int j = Lijx; j < J; j++)
	  if(SNR[j] < minSNR)
	    m--;
      } else {
	for(int j = Lijx; j < J; j++)
	  if(SNR[M+1-j] < minSNR)
	    m--;
      }
    }
    n = I-K;
    if(DEBUG>=2) assert(m >= 1);
    if(DEBUG>=2) assert(n >= 1);
    Bias = biasWT * (xB*(Frate+LBias) + (m-1)*FBias + EBias);
    term = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */ - err*err*0.5/var;
    if(SDDEBUG){
      score3sd += sdterm = -0.5*err*err/var;
      Xlen3 += xB;
      if(FPDEBUG)
	FPcnt3 += m-1;
    }
  } else { /* Send(min(x,Yc(Y,I,K)),J-1-max(1,Lijx),I-K+1 - max(1,Lij)) */
    if(extend){
      x = min(x,Yc(Y,I,K));
      xB = max(LZERO,x-resKB2);
      m = J+1-max(1,Lijx);
      if(minSNR > 0.0){
	if(align->orientation==0){
	  for(int j = max(1,Lijx); j < J; j++)
	    if(SNR[j] < minSNR)
	      m--;
	} else {
	  for(int j = max(1,Lijx); j < J; j++)
	    if(SNR[M+1-j] < minSNR)
	      m--;
	}
      }
      n = I-K+1 - max(1,Lij);
      if(DEBUG>=2) assert(m >= 1);
      if(DEBUG>=2) assert(n >= 1);
      Bias = biasWT * (xB*(Frate+LBias) + (m-1)*FBias + EBias);
    }
    term = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */;
    Xlen3 += xB;
    if(FPDEBUG)
      FPcnt3 += m-1;
  }
  logLR2 += term + sm;
  score2 += term + sm + Bias;
  logLR3 += term + sm;
  score3 += term + sm + Bias;
  
  if((DEBUG && !isfinite(term)) || (VERB && verb)){
    #pragma omp critical
    {
      if(SCORE_APPROX>=2)
	printf("Lend=%d:I=%d,K=%d,J=%d,Lij=%d,n=%d,m=%d,xB=%0.4f,Pen term=%0.6f(PenErr=%0.8f),Bias=%0.6f,Sm=%0.6f:\n\tlogLR2=%0.6f,score2=%0.6f\n",
	       align->Lend,I,K,J,Lij,n,m,xB,term,sdterm,Bias,sm,logLR2,score2);
      else
	printf("Lend=%d:I=%d,K=%d,J=%d,Lij=%d,Lijx=%d,y=%0.4f,Y[Lij]=%0.4f,X[Lijx]=%0.4f,n=%d,m=%d,xB=%0.6f,term=%0.6f,sdterm=%0.8f,Bias=%0.6f,Sm=%0.6f(yr=%0.4f):\n\tlogLR2=%0.6f,score2=%0.6f,logLR3=%0.6f,score3=%0.6f,LLsd=%0.8f,Xlen=%0.8f,FPcnt=%d,noFP=%0.8f(cum=%0.8f),scale=%0.6f\n",
	       align->Lend,I,K,J,Lij,Lijx,Yc(Y,I,K),Y[Lij], (align->orientation==0) ? X[Lijx] : X[M+1]-X[M+1-Lijx], n,m,xB,term,sdterm,Bias,sm,Y[I]-Y[I-K],logLR2,score2,logLR3,score3, score3sd,Xlen3,FPcnt3 - origFPcnt,
	       logLR2 + Xlen3*Frate + (FPcnt3-origFPcnt)*FpPenalty, 		 logLR2 + Xlen3*Frate + (FPcnt3-origFPcnt)*FpPenalty + noFP3cum, scale);

      for(int U = 0; U <= K /* ||(I-U >= 1 && Yc(Y,I,K)-Y[I-U] <= x )*/; U++)
	printf("Y[I-%d]=%0.4f,Yc(Y,I,K)-Y[I-%d]=%0.4f,x=%0.4f\n",U,Y[I-U],U,Yc(Y,I,K)-Y[I-U],x);
      printf("\n");
      fflush(stdout);
      if(DEBUG) assert(isfinite(term));
    }
  }

  TotBias2 += Bias;

  int H = I;
  int D = K;
  int G = J;

  for(; ++T < U; H = I, D = K, G = J){
    J = align->sites2[T];
    if(minSNR > 0.0){/* check if label J is thresholded by minSNR[0] : if so advance T */
      if(align->orientation == 0){
	while(SNR[J] < minSNR){
	  if(++T >= U)
	    break;
	  I = align->sites1[T];
	  K = align->sitesK1[T];
	  J = align->sites2[T];
	}
      } else {
	while(SNR[M+1-J] < minSNR){
	  if(++T >= U)
	    break;
	  I = align->sites1[T];
	  K = align->sitesK1[T];
	  J = align->sites2[T];
	}
      }
      if(T >= U)
	break;
    }
    I = align->sites1[T];
    K = align->sitesK1[T];
    LFLOAT y = Yc(Y,I,K) - Yc(Y,H,D);
    x = scale * ((align->orientation==0) ? X[J] - X[G] : X[M+1-G] - X[M+1-J]);
    
    n = I - K - H;
    m = J - G;

    if(minSNR > 0.0){
      if(align->orientation==0){
	for(int j = G+1; j < J; j++)
	  if(SNR[j] < minSNR)
	    m--;
      } else {
	for(int j = G+1; j < J; j++)
	  if(SNR[M+1-j] < minSNR)
	    m--;
      }
    }    
    if(DEBUG>=2) assert(n > 0);
    if(DEBUG>=2) assert(m > 0);

    LFLOAT var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
    if(QUADRATIC_VARIANCE)
      var += SR[0]*SR[0]*y*y;
    FLOAT resvar = 0.0;
    if(RES_VARIANCE){
      FLOAT resR = Y[I] - Y[I-K];
      FLOAT resL = Y[I-K-n] - Y[I-K-n-D];
      resvar = resL*resL + resR*resR;
      var += SE[0]*SE[0] * resvar;
    }
    LFLOAT err = x-y;
    LFLOAT Gtermsd = 0.5*log(2.0*M_PI*var);
    LFLOAT Gterm = log(Xtheta) - Gtermsd;
    logLR1 += Bscale * Gterm;// Adjustment for BETA != 1.0

    xB = max(LZERO,x-resKB2);
    sdterm = Gterm - err*err*0.5/var;
    LFLOAT Pen =  log(Pr(Y[I-K]-Y[H])) - (n-1)*FnPenalty - (m-1)*FpPenalty; // WAS - xB*Frate;
    if(DEBUG>=2 && !isfinite(Pen)){
      #pragma omp critical
      {
	printf("T=%d,I=%d,K=%d,J=%d,H=%d,D=%d,G=%d:n=%d,m=%d,Y[I-K]=%0.4f,Y[H]=%0.4f,log(Pr(Y[I-K]-Y[H]))=%0.8f,FnPenalty=%0.8f,FpPenalty=%0.8f,xB=%0.8f,Frate=%0.8f:Pen=%0.8f\n",
	       T,I,K,J,H,D,G,n,m,Y[I-K],Y[H],log(Pr(Y[I-K]-Y[H])),FnPenalty,FpPenalty,xB,Frate,Pen);
	fflush(stdout);
	assert(isfinite(Pen));
      }
    }
    term = sdterm + Pen - xB * Frate;
    LFLOAT sm =  Sm(J,I,K,Y);
    if(SDDEBUG){
      score3sd += sdterm;
      Xlen3 += xB;
      if(FPDEBUG) 
	FPcnt3 += m-1;
    }
    Bias = biasWT * (xB*(Frate+LBias) + m * FBias);
    LFLOAT rterm = term + sm;
    LFLOAT rterm3 = rterm;
    LFLOAT OutPen = 0.0;

    RFLOAT xf = x;
    RFLOAT yf = y;

    LFLOAT outscore = rterm;

    if(maptype){
      if(FRATE_FIX1)
	sdterm -= xB * Frate;
      else
	Pen -= xB * Frate;
      OutPen = OutlierPenalty;
      if(outlierBC)
	OutPen += OutlierPenaltyBC[m] + OutlierPenaltyBC[n];
      if(OUTLIER_LTYPE==0)
	OutPen -= (x+y) * OutlierLambdaInv;
      else
	OutPen -= fabs(x-y) * OutlierLambdaInv;

#if 0 // OLD
      if(OUTLIER_TYPE1 == 0)
	rterm = OutlierBias + max(Bias + term, Bias * biasWToutlier + OutPen) + sm;
      else
	rterm = OutlierBias + Pen + max(Bias + sdterm, Bias * biasWToutlier + OutPen) + sm;
#else // NEW
      rterm = OutlierBias + max(Bias + term, Bias * biasWToutlier + Pen*OUTLIER_TYPE1 + OutPen) + sm;
#endif
      rterm -= Bias ;
    } else if(OUTLIER(maptype,xf,yf)){/* adjust rterm for outlier (NOTE use of float for xf,yf to better match values used during original alignment, to avoid -outlierMax inconsistencies) */
      if(FRATE_FIX0)
	sdterm -= xB * Frate;
      else
	Pen -= xB * Frate;
      OutPen = OutlierPenalty;
      if(outlierBC)
	OutPen += OutlierPenaltyBC[m] + OutlierPenaltyBC[n];
      OutPen -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
      if(OUTLIER_TYPE==0)
	rterm = OutlierBias + max(Bias + term, Bias * biasWToutlier + OutPen) + sm;
      else
	rterm = OutlierBias + Pen + max(Bias + sdterm, Bias * biasWToutlier + OutPen) + sm;
#else // NEW
	rterm = OutlierBias + max(Bias + term, Bias * biasWToutlier + Pen*OUTLIER_TYPE + OutPen) + sm;
#endif
      rterm -= Bias ;
    } // else rterm = term + sm

    if(MINSNR_FIX && pstat){
      if(outscore + OUTLIER_MARGIN < rterm){// outlier
#if 0 // OLD
	if(maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE){/* include both fp,fn since they are not excluded from outlier score */
	  len += x;
	  sitecnt += n + (RESSD ? K : ((SCORE_APPROX && K) ? ((SCORE_APPROX>=2 || MIS_VITERBI) ? K : 1) : 0));
	  fn += n-1 + ((RESSD==0 && SCORE_APPROX>=2 && K >= 2) ? K-1 : 0);
	  fp += m-1;
	} else if(FIX_OUTLIER_MIS){/* include only Sm() term at right end, since it is not part of outlier */
	  sitecnt += 1 + (RESSD ? K : ((SCORE_APPROX && K) ? ((SCORE_APPROX>=2 || MIS_VITERBI) ? K : 1) : 0));
	  fn += ((RESSD==0 && SCORE_APPROX>=2 && K >= 2) ? K-1 : 0);
	}
#else
	double outlier_type = (maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE);
	len += x * outlier_type;
	sitecnt += (n-1)*outlier_type + 1 + (RESSD ? K : ((SCORE_APPROX && K) ? ((SCORE_APPROX>=2 || MIS_VITERBI) ? K : 1) : 0));
	fn += (n-1)*outlier_type + ((RESSD==0 && SCORE_APPROX>=2 && K >= 2) ? K-1 : 0);
	fp += (m-1)*outlier_type;
#endif
      } else {
	len += x;
	sitecnt += n + (RESSD ? K : ((SCORE_APPROX && K) ? ((SCORE_APPROX>=2 || MIS_VITERBI) ? K : 1) : 0));
	fn += n-1 + ((RESSD==0 && SCORE_APPROX>=2 && K >= 2) ? K-1 : 0);
	fp += m-1;
      }
    }

    logLR2 += rterm;
    score2 += rterm + Bias;

    /* adjust rterm3 & score3sd for previously classified outlier */
    LFLOAT OutPen3 = 0.0;
    if(align->outscore[T] + OUTLIER_MARGIN < align->iscore[T]){/* previously classified as outlier : evaluate as such */
      OutPen3 = OutlierPenalty;      
      if(outlierBC)
	OutPen3 += OutlierPenaltyBC[m] + OutlierPenaltyBC[n];
      if(maptype){
	if(OUTLIER_LTYPE==0)
	  OutPen3 -= (x+y) * OutlierLambdaInv;
	else
	  OutPen3 -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
	if(OUTLIER_TYPE1 == 0)
	  rterm3 = OutlierBias + Bias * biasWToutlier + OutPen3 + sm;
	else
	  rterm3 = OutlierBias + Pen + Bias * biasWToutlier + OutPen3 + sm;
#else // NEW
	rterm3 = OutlierBias + Pen*OUTLIER_TYPE1 + Bias * biasWToutlier + OutPen3 + sm;
#endif
      } else {
	OutPen3 -= fabs(x-y) * OutlierLambdaInv;
#if 0 // OLD
	if(OUTLIER_TYPE==0)
	  rterm3 = OutlierBias + Bias * biasWToutlier +  OutPen3 + sm;
	else
	  rterm3 = OutlierBias + Pen + Bias * biasWToutlier + OutPen3 + sm;
#else // NEW
	  rterm3 = OutlierBias + Pen*OUTLIER_TYPE + Bias * biasWToutlier + OutPen3 + sm;
#endif
      }
      rterm3 -= Bias;

      if(DEBUG>=2 && ((OUTLIER_TYPE==0 && !update && biasWT == 0.0 && !(term <= OutPen3 + 1e-8)) || !(rterm3 <= rterm + 1e-8))){
	#pragma omp critical
	{
	  printf("logLR:T=%d:rterm3=%0.8f,rterm=%0.8f,term=%0.8f,OutPen3=%0.8f,sm=%0.8f,outscore[T]=%0.8f,iscore[T]=%0.8f:x=%0.4f,y=%0.4f\n",
		 T,rterm3,rterm,term,OutPen3,sm,align->outscore[T],align->iscore[T],x,y);
	  printf("    refid=%d(id=%lld),mapid=%d(id=%lld),orientation=%d,res=%0.6f,resSD=%0.6f,Xtheta=%0.8f,FP=%0.8f,FN=%0.6f,scale=%0.8f,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f,Frate=%0.9f,FpPenalty=%0.8f,maptype=%d\n",
		 refid,refmap[refid]->id,mapid,Gmap[mapid]->id,align->orientation,res[0],resSD[0],Xtheta,FP[0],FN[0],scale,SF[0],SD[0],SR[0],SE[0],Frate,FpPenalty,maptype);
	  fflush(stdout);
	  if(OUTLIER_TYPE==0 && !update && biasWT == 0.0)
	    assert(term <= OutPen3 + 1e-8);
	  assert(rterm3 <= rterm + 1e-8);
	}
      }
      if(SDDEBUG){/* don't count sd,Xlen term for previously classified outlier, so value is comparable with value computed from errors[] */
	score3sd -= sdterm;
	sdterm = 0.0;
	Xlen3 -= xB;
	if(FPDEBUG)
	  FPcnt3 -= m-1;
      }
    }

    if(VERB>=3 && MINSNR_FIX && pstat && mapid==11){
      printf("T=%d/%d:I=%d,K=%d,J=%d(H=%d,D=%d,G=%d):sitecnt=%d,fp=%d,fn=%d\n",T,U,I,K,J,H,D,G,sitecnt,fp,fn);
      fflush(stdout);
    }

    logLR3 += rterm3;
    score3 += rterm3 + Bias;

    if((DEBUG && !isfinite(term)) || verb){
      #pragma omp critical
      {
	if(SCORE_APPROX>=2){
	  if(update)
	    printf("T=%d:I=%d,K=%d,J=%d,H=%d,D=%d,G=%d:n=%d,m=%d,xB=%0.4f,Pen=%0.6f(Gterm=%0.6f,ErrPen=%0.6f,x=%0.4f,y=%0.4f,X*Frate=%0.6f,FnPen=%0.6f,FpPen=%0.6f,PenPr=%0.6f),Bias=%0.6f,Sm=%0.6f:\n\tlogLR2=%0.6f(delta=%0.6f),score2=%0.6f(delta=%0.6f),logLR3=%0.6f(delta=%0.6f)\n",
		   T, I, K, J, H, D, G, n, m, xB, term, Gterm, -err*err*0.5/var, x, y, -xB*Frate, -(n-1)*FnPenalty, -(m-1)*FpPenalty, log(Pr(Y[I-K]-Y[H])), Bias, sm, logLR2, rterm, score2, rterm + Bias, logLR3, rterm3);
	  else
	    printf("T=%d:I=%d,K=%d,J=%d,H=%d,D=%d,G=%d:n=%d,m=%d,xB=%0.6f,Pen=%0.6f(Gterm=%0.6f(var=%0.8e,Xtheta=%0.6f),PenSD=%0.6f,ErrPen=%0.6f,x=%0.4f,y=%0.4f,X*Frate=%0.6f,FnPen=%0.6f,FpPen=%0.6f,PenPr=%0.6f),Bias=%0.6f,Sm=%0.6f(Yr=%0.4f):\n\tlogLR2=%0.6f(delta=%0.6f),score2=%0.6f(delta=%0.6f)\n",
		   T, I, K, J, H, D, G, n, m, xB, term, Gterm,var,Xtheta, sdterm, -err*err*0.5/var, x, y, -xB*Frate, -(n-1)*FnPenalty, -(m-1)*FpPenalty, log(Pr(Y[I-K]-Y[H])), Bias, sm, Y[I]-Y[I-K],logLR2, rterm, score2, rterm + Bias);

	} else {
	  if(minSNRestimate)
	    printf("T=%d:I=%d,K=%d,J=%d,H=%d,D=%d,G=%d:n=%d,m=%d,Y(I,K)=%0.4f,X[J]=%0.6f,SNR=%0.1f,xB=%0.3f,Pen=%0.6f,Gterm=%0.6f,Gerr=%0.6f(var=%0.8e,x=%0.6f,y=%0.6f,resvar=%0.8e,Pr=%0.6f),Bias=%0.6f,Sm=%0.6f(Yr=%0.4f)\n\tlogLR2=%0.8f(delta=%0.8f),score2=%0.6f(delta=%0.6f),logLR3=%0.8f(delta=%0.6f,cum=%0.8f,oscore=%0.6f,iscore=%0.6f)\n\tLLsd=%0.8f(delta=%0.8f),Xlen=%0.8f,FPcnt=%d,noFP=%0.8f(cum=%0.8f):OutPen=%0.6e,OutlierPenalty=%0.6e,OutlierBias=%0.6f,biasWToutlier=%0.6f,OutPen3=%0.6f\n",
		   T, I, K, J, H, D, G, n, m, Yc(Y,I,K),(align->orientation==0) ? X[J] : X[M+1] - X[M+1-J], Gmap[mapid]->SNR[0][align->orientation==0 ? J : M+1-J],
		   xB, Pen, Gterm, -err*err*0.5/var, var, x, y, resvar, log(Pr(Y[I-K]-Y[H])), Bias, sm, Y[I]-Y[I-K],logLR2, rterm, score2, rterm + Bias, logLR3, rterm3, logLR3 + logLR3cum,
		   align->outscore[T],align->iscore[T],score3sd, sdterm, Xlen3, FPcnt3 - origFPcnt, 
		   logLR3 + Xlen3*Frate + (FPcnt3-origFPcnt)*FpPenalty, logLR3 + Xlen3*Frate + (FPcnt3-origFPcnt)*FpPenalty + noFP3cum, OutPen, OutlierPenalty,OutlierBias, biasWToutlier,OutPen3);
	  else
	    printf("T=%d:I=%d,K=%d,J=%d,H=%d,D=%d,G=%d:n=%d,m=%d,Y(I,K)=%0.4f,X[J]=%0.4f,xB=%0.3f,Pen=%0.6f,Gterm=%0.6f,Gerr=%0.6f(var=%0.8e,x=%0.6f,y=%0.6f,resvar=%0.8e,Pr=%0.6f),Bias=%0.6f,Sm=%0.6f(Yr=%0.4f)\n\tlogLR2=%0.8f(delta=%0.8f),score2=%0.6f(delta=%0.6f),logLR3=%0.8f(delta=%0.6f,cum=%0.8f,oscore=%0.6f,iscore=%0.6f)\n\tLLsd=%0.8f(delta=%0.8f),Xlen=%0.8f,FPcnt=%d,noFP=%0.8f(cum=%0.8f):OutPen=%0.6e,OutlierPenalty=%0.6e\n\tOutlierBias=%0.6f,biasWToutlier=%0.6f,OutPen3=%0.6f,Pen=%0.6f\n",
		   T, I, K, J, H, D, G, n, m, Yc(Y,I,K),(align->orientation==0) ? X[J] : X[M+1] - X[M+1-J], xB, Pen, Gterm, -err*err*0.5/var, var, x, y, resvar, log(Pr(Y[I-K]-Y[H])), Bias, sm, Y[I]-Y[I-K],
		   logLR2, rterm, score2, rterm + Bias, logLR3, rterm3, logLR3 + logLR3cum, align->outscore[T],align->iscore[T],
		   score3sd, sdterm, Xlen3, FPcnt3 - origFPcnt, logLR3 + Xlen3*Frate + (FPcnt3-origFPcnt)*FpPenalty, logLR3 + Xlen3*Frate + (FPcnt3-origFPcnt)*FpPenalty + noFP3cum, OutPen, OutlierPenalty,
		   OutlierBias, biasWToutlier, OutPen3, Pen);

	  /*	  printf("\t var=%0.10f:y=%0.8f,SF[0]=%0.8f,SD[0]=%0.8f,SR[0]=%0.8f,SE[0]=%0.8f,resvar=%0.8f:var(y)=%0.10f\n",
		  var,y,SF[0],SD[0],SR[0],SE[0],resvar,SF[0]*SF[0] + fabs(SD[0])*SD[0]*y + SR[0]*SR[0]*y*y + SE[0]*SE[0]*resvar);*/
	  //	} else
	  //	  printf("T=%d:I=%d,K=%d,J=%d,H=%d,D=%d,G=%d:n=%d,m=%d,xB=%0.3f,Pen=%0.6f(Gterm=%0.6f,PenErr=%0.8f,var=%0.7f,x=%0.6f,y=%0.6f,Pr=%0.6f),Bias=%0.6f,Sm=%0.6f:\n\tlogLR2=%0.6f(delta=%0.6f),score2=%0.6f(delta=%0.6f)\n",
	  //		 T, I, K, J, H, D, G, n, m, xB, term, Gterm, -err*err*0.5/var, var, x, y, log(Pr(Y[I-K]-Y[H])), Bias, sm, logLR2, rterm, score2, rterm + Bias);
	}
	//      printf("    FP[0]=%0.6f,F=%0.8f,LBias=%0.8f,Frate=%0.8f,1/Xtheta=%0.8f,FBias=%0.8f\n",FP[0],F,LBias,Frate,1.0/Xtheta,FBias);
	fflush(stdout);
	assert(isfinite(term));
      }
    }
    TotBias2 += Bias;
  }

  /* right end fragment */
  if(minSNR > 0.0){
    I = H;
    K = D;
    J = G;
  } 
  if(DEBUG) assert(H==I && D==K && G==J);
  if(DEBUG) assert(RJ == align->sites2[U - 1]);

  x = scale * ((align->orientation==0) ? X[M+1]-X[G] : X[M + 1 - G]);
  LFLOAT xRijx_1 = (Rijx > M) ? 0.0 : scale * ((align->orientation==0) ? X[M+1] - X[Rijx+1] : X[M+1-(Rijx+1)]);
  n = Rij - H + 1;
  m = M + 1 - G;
  if(DEBUG) assert(n >= 1);
  if(DEBUG && !(m >= 1)){
    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,logPV=%0.2f,score=%0.6f,pairs=%d:right end:I=%d,K=%d,J=%d,M=%d,N=%d,m=%d\n",
	   refid,refmap[refid]->id,mapid,Gmap[mapid]->id,align->orientation,align->logPV,align->score,align->numpairs,I,K,J,M,N,m);
    for(int t = 0; t < align->numpairs; t++)
      printf("%d: I=%d,K=%d,J=%d\n",t,align->sites1[t],align->sitesK1[t],align->sites2[t]);
    fflush(stdout);
    assert(m >= 1);
  }

  xB = max(LZERO,x-resKB2);
  sdterm = 0.0;
  Bias = biasWT * (xB*(Frate+LBias) + (m-1)*FBias + EBias);

  if(MINSNR_FIX && pstat && align->Rend > -2){
    int RI = align->sites1[U - 1];

    len += x;
    for(int t = RJ + 1; t <= min(M,Rijx); t++)
      fp++;
    // HERE     fp += max(0, min(M,Rijx) - RJ);
    Ysites += min(N,Rij) - RI;
  }

  if(align->Rend <= -2){/* end outlier */
    Bias = BiasEnd2(x,M+1-J);
    term = ChimScore;
  } else if(ENDFIX && x <= Y[N+1] - Yc(Y,H,D) && Rij <= N && Y[Rij+1]-Yc(Y,H,D) < x){  /* Sbnd(x,Y[Rij+1]-Yc(Y,H,D),M+1-G,Rij+1-I) : RES_VARIANCE is ignored */
    LFLOAT y = Y[Rij+1]-Yc(Y,H,D);
    LFLOAT var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
    if(QUADRATIC_VARIANCE)
      var += SR[0]*SR[0]*y*y;
    LFLOAT err = x-y;
    if(VERB && verb){
      printf("  Sbnd():H=%d,D=%d,G=%d,Rij=%d,n=%d,m=%d,Y[Rij+1]=%0.6f,Yc(Y,H,D)=%0.6f,y=%0.6f,x=%0.6f,var=%0.6f\n",
	     H,D,G,Rij,n,m,Y[Rij+1],Yc(Y,H,D),y,x,var);
      fflush(stdout);
    }
    term = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */ - err*err*0.5/var;
    if(SDDEBUG){
      score3sd += sdterm = -0.5 * err*err/var;
      Xlen3 += xB;
      if(FPDEBUG)
	FPcnt3 += m-1;
    }
  } else if(ENDFIX && extend && x >= Y[N+1] - Yc(Y,I,K) && Rijx <= M && x - xRijx_1 < Y[N+1]-Yc(Y,I,K)){/* Sbnd(x-xRijx_1, Y[N+1]-Yc(Y,I,K), Rijx+1-J,min(N,Rij)+1-I) */
    LFLOAT y = Y[N+1] - Yc(Y,I,K);
    LFLOAT var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
    if(QUADRATIC_VARIANCE)
      var += SR[0]*SR[0]*y*y;
    x = x - xRijx_1;
    xB = max(LZERO,x-resKB2);
    LFLOAT err = x - y;
    m = Rijx + 1 - J;
    if(minSNR > 0.0){
      if(align->orientation==0){
	for(int j = J+1; j <= Rijx; j++)
	  if(SNR[j] < minSNR)
	    m--;
      } else {
	for(int j = J+1; j <= Rijx; j++)
	  if(SNR[M+1-j] < minSNR)
	    m--;
      }
    }    
    n = min(N,Rij) + 1 - I;
    if(DEBUG>=2) assert(m >= 1);
    if(DEBUG>=2) assert(n >= 1);
    if(VERB && verb){
      printf("  Sbnd():H=%d,D=%d,G=%d,Rijx=%d,n=%d,m=%d,X[Rijx+1]=%0.6f,Y[N+1]=%0.6f,Yc(Y,H,D)=%0.6f,y=%0.6f,x=%0.6f,var=%0.6f\n",
	     H,D,G,Rijx,n,m,xRijx_1,Y[N+1],Yc(Y,H,D),y,x,var);
      fflush(stdout);
    }
    Bias = biasWT * (xB*(Frate+LBias) + (m-1)*FBias + EBias);
    term = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */ - err*err*0.5/var;
    if(SDDEBUG){
      score3sd += sdterm = -0.5 * err*err/var;
      Xlen3 += xB;
      if(FPDEBUG)
	FPcnt3 += m-1;
    }
  } else {
    if(extend){
      x = min(x, Y[N+1]-Yc(Y,I,K));
      xB = max(LZERO,x-resKB2);
      m = min(M,Rijx)+1-J;
      if(minSNR > 0.0){
	if(align->orientation==0){
	  int jmax = min(M,Rijx);
	  for(int j = J+1; j <= jmax; j++)
	    if(SNR[j] < minSNR)
	      m--;
	} else {
	  int jmax = min(M,Rijx);
	  for(int j = J+1; j <= jmax; j++)
	    if(SNR[M+1-j] < minSNR)
	      m--;
	}
      }    
      n = min(N,Rij)+1-I;
      if(DEBUG>=2) assert(m >= 1);
      if(DEBUG>=2) assert(n >= 1);
      Bias = biasWT * (xB*(Frate+LBias) + (m-1)*FBias + EBias);
    }
    term = -Frate*xB - (n-1)*FnPenalty - (m-1)*FpPenalty /* + 0.5*log(1.0-FN[0]) */;
    if(SDDEBUG){
      Xlen3 += xB;
      if(FPDEBUG)
	FPcnt3 += m-1;
    }
  }

  if(MINSNR_FIX && pstat){
    sitecnt += Ysites + 1 + (RESSD ? KL : (SCORE_APPROX && KL) ? ((SCORE_APPROX>=2 || MIS_VITERBI) ? KL : 1) : 0);
    fn += Ysites + ((RESSD==0 && SCORE_APPROX>=2 && KL >= 2) ? KL-1 : 0);

    pstat->len = len;
    pstat->fp = fp;
    pstat->fn = fn;
    pstat->sitecnt = sitecnt;

    if(VERB>=3){
      printf("logLR:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d: Ysites=%d,KL=%d : fp=%d,fn=%d,sitecnt=%d,len=%0.4f (cum:fp=%d,fn=%d,sitecnt=%d,len=%0.4f)\n",
	     refid,refmap[refid]->id,mapid,Gmap[mapid]->id,align->orientation, Ysites, KL, fp,fn,sitecnt,len,pstat->fp,pstat->fn,pstat->sitecnt,pstat->len);
      fflush(stdout);
    }
  }

  logLR2 += term;
  score2 += term + Bias;
  logLR3 += term;
  score3 += term + Bias;
  if((DEBUG && !isfinite(term)) || (VERB && verb)){
    if(SCORE_APPROX>=2)
      printf("Rend:H=%d,D=%d,G=%d,Rij=%d:n=%d,m=%d,xB=%0.3f,Pen=%0.6f(PenErr=%0.8f),Bias=%0.6f:\n\tlogLR1=%0.6f,logLR2=%0.6f,score2=%0.6f\n",
	     H,D,G,Rij,n,m,xB,term,sdterm,Bias,logLR1,logLR2,score2);
    else
      printf("Rend:H=%d,D=%d,G=%d,Rij=%d:n=%d,m=%d,xB=%0.6f,Pen=%0.6f,Bias=%0.6f:\n\tlogLR1=%0.6f,logLR2=%0.6f,score2=%0.6f,LLsd=%0.8f(delta=%0.8f),logLR3=%0.8f(delta=%0.8f,cum=%0.8f),Xlen=%0.8f,FPcnt=%d,noFP=%0.8f(cum=%0.8f)\n",
	     H,D,G,Rij,n,m,xB,term,Bias,logLR1,logLR2,score2,score3sd,sdterm,logLR3,term,logLR3 + logLR3cum, Xlen3,FPcnt3-origFPcnt,
	     logLR3 + Xlen3*Frate + (FPcnt3-origFPcnt)*FpPenalty, 		 logLR3 + Xlen3*Frate + (FPcnt3-origFPcnt)*FpPenalty + noFP3cum);
    printf("    Y[Rij]-Y[H,D]=%0.3f,Y[Rij-1]-Y[H,D]=%0.3f,Y[Rij+1]-Y[H,D]=%0.3f,x=%0.8f\n",
	   Y[Rij]-Yc(Y,H,D),Y[Rij-1]-Yc(Y,H,D),Y[Rij+1]-Yc(Y,H,D),x);
    fflush(stdout);
    if(DEBUG) assert(isfinite(term));
  }
  TotBias2 += Bias;

  if((REFDEBUG || DEBUG>=2 || (TRACE>=2 && Gmap[mapid]->id==MAP_TRACE && refmap[refid]->id==REF_TRACE && align->orientation==OR_TRACE)) && !((maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE) && outlierExtend) && !align->scaleID && !update && 
     fabs(align->score - score2) >= (SCORE_MARGIN * fabs(score2) + ASCORE_MARGIN) * sqrt((double)U)){
    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,logPV=%0.2f,score=%0.6f:logLR1=%0.6f,logLR2=%0.6f,score2=%0.6f,logLR3=%0.6f,score3=%0.6f,numpairs=%d,score2=%0.6f,TotBias=%0.6f,TotBias2=%0.6f\nresKB2=%0.4f,Xlen=%0.3f,XlenB=%0.3f\n",
	   refid,refmap[refid]->id,mapid,Gmap[mapid]->id,align->orientation,align->logPV,align->score,logLR1,logLR2,score2,logLR3,score3,align->numpairs,score2,TotalBias,TotBias2,resKB2,scale*X[M+1],XlenB);
    if(Poutlier>0.0)
      printf("Poutlier=%0.6f,OutlierPenalty=%0.4e,OutlierBias=%0.4f\n",
	     Poutlier,OutlierPenalty,OutlierBias);
    if(VERB && !verb)
      (void)logLR(mapid,refid,X,Y,M,N,align,align->sites1[0],align->sites2[0], align->sitesK1[0], RJ,Lij,Rij,Lijx,Rijx,update,1,0,0);
    fflush(stdout);
    assert(fabs(align->score-score2) < (SCORE_MARGIN * fabs(score2) + ASCORE_MARGIN) * sqrt((double)U));
    fflush(stdout);exit(1);
  }
  if(REFDEBUG && update && !(logLR2 > logLR3 - (SCORE_MARGIN * fabs(logLR2) + ASCORE_MARGIN) * sqrt((double)U))){
    printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:logLR1=%0.6f,logLR2=%0.6f,logLR3=%0.6f,score=%0.6f,numpairs=%d,score2=%0.6f,TotBias=%0.6f,TotBias2=%0.6f\nresKB2=%0.4f,Xlen=%0.3f,XlenB=%0.3f\n",
	   refid,refmap[refid]->id,mapid,Gmap[mapid]->id,align->orientation,logLR1,logLR2,logLR3,align->score,align->numpairs,score2,TotalBias,TotBias2,resKB2,scale*X[M+1],XlenB);
    if(VERB && !verb)
      (void)logLR(mapid,refid,X,Y,M,N,align,align->sites1[0],align->sites2[0], align->sitesK1[0], RJ,Lij,Rij,Lijx,Rijx,update,1,0,0);
    fflush(stdout);
    assert(logLR2 > logLR3 - (SCORE_MARGIN * fabs(logLR2) + ASCORE_MARGIN) * sqrt((double)U));
    fflush(stdout);exit(1);
  }

  if(SDDEBUG && LLsd)
    *LLsd = score3sd;
  if(SDDEBUG && Xlen)
    *Xlen = Xlen3;
  if(FPDEBUG && verb){
    Xlen3cum += Xlen3;
    logLR1cum += logLR1;
    logLR2cum += logLR2;
    logLR3cum += logLR3;
    noFP3cum += logLR3 + Xlen3*Frate + (FPcnt3-origFPcnt)*FpPenalty;
  }

  // NOTE : If minSNR > 0.0 need to return logLR2 which recomputes location of outliers, since they can change as labels are removed

  return (minSNR > 0.0) ? logLR2 : logLR3; // (REFDEBUG || update) ? logLR3 : logLR2;
}

/* compute log Likelihood for alternate value of FN */
static double FNtotLL(double newFN, int numthreads, size_t numaligns, Calign **alignment, double *Narray, int verb = 0)
{
  FN[0] = newFN;
  score_update();  /* update score_init() terms used by logLR() */

  size_t cnt = 0;

  #pragma omp parallel num_threads(numthreads) if (numthreads > 1 && verb==0)
  {
    int tid = 0;
#ifdef _OPENMP
    tid = omp_get_thread_num ();
#endif

    long long naligns = numaligns;

#if !USE_MIC
    #pragma omp for schedule(dynamic,1)
#endif
    for(long long i = 0; i < naligns; i++){
      if(USE_MIC && !((i % numthreads) == tid)){ // NOTE : simulates #pragma omp for schedule(static,1)
	continue;
      }

      Narray[i] = 0.0;
      Calign *align = alignment[i];
      if(!align || align->numpairs <= 1)
	continue;
      if(MapRate > 0.0 && !(BestRefPV ? (align->logPV > LogPvThreshold) : (align->score > ScoreThreshold)))
	continue;
      int mid = align->mapid2;
      if(BestRef){
	Cmap *origmap = Gmap[mid];
	while(origmap->origmap)
	  origmap = origmap->origmap;
	if(origmap->align->mapid1 != align->mapid1)// NOTE : BestRefExtCheck() not used for parameter estimation
	  continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
      }
      FLOAT *X = Gmap[mid]->site[0];
      int M = Gmap[mid]->numsite[0];
      FLOAT *Y = refmap[align->mapid1]->site[0];
      int N = refmap[align->mapid1]->numsite[0];
      double LRsd = 0.0;
      double LR = logLR(mid,align->mapid1,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,0,&LRsd,0);
      Narray[i] = LR;
      if(verb){
        printf("cnt=%lu,i=%lld:mid=%d(id=%lld),rid=%d(id=%lld): LR=%0.6f\n", cnt,(long long)i,mid,Gmap[mid]->id,align->mapid1,refmap[align->mapid1]->id, LR);
	fflush(stdout);
	cnt++;
      }
    }
  }

  double LRsum = 0.0;
  for(size_t i = 0; i < numaligns; i++)
    LRsum += Narray[i];

  return LRsum;
}

/* compute log Likelihood for alternate value of minSNR[0] */
/* If SNR_BESTREF_FIX && maxmapid > 0 : recompute all alignments of each map (mapid = 0 .. maxmapid-1) and pick the best one */
static double SNRtotLL(double minSNR, int numthreads, size_t numaligns, Calign **alignment, double *Narray, int verb, size_t maxmapid, AlignStat *Sarray)
{
  if(verb){
    printf("\nSNRtotLL:minSNR= %0.4f\n",minSNR);
    fflush(stdout);
  }

  score_update(1);  /* update score_init() terms used by logLR() */

  if(SNR_BESTREF_FIX){
    if(DEBUG) assert(maxmapid > 0);
    memset(Narray, 0, maxmapid * sizeof(double));
    memset(Sarray, 0, maxmapid * sizeof(AlignStat));
  }

  size_t cnt = 0, Scnt = 0;
  double LRsum = 0.0;

  AlignStat Astat;

  #pragma omp parallel num_threads(numthreads) if (numthreads > 1 && verb==0)
  {
    AlignStat myAstat, tmpAstat;

    int tid = 0;
#ifdef _OPENMP
    tid = omp_get_thread_num ();
#endif

    long long naligns = numaligns;

#if !USE_MIC
    #pragma omp for schedule(dynamic,1)
#endif
    for(long long i = 0; i < naligns; i++){

      if(USE_MIC && !((i % numthreads) == tid)){ // NOTE : simulates #pragma omp for schedule(static,1)
	continue;
      }

      if(!SNR_BESTREF_FIX)
	Narray[i] = 0.0;
      Calign *align = alignment[i];
      if(!align || align->numpairs <= 1)
	continue;
      if(MapRate > 0.0 && !(BestRefPV ? (align->logPV > LogPvThreshold) : (align->score > ScoreThreshold)))
	continue;
      size_t mid = align->mapid2;
      if(DEBUG && SNR_BESTREF_FIX) assert(mid < maxmapid);
      if(!SNR_BESTREF_FIX && BestRef){
	Cmap *origmap = Gmap[mid];
	while(origmap->origmap)
	  origmap = origmap->origmap;
	if(origmap->align->mapid1 != align->mapid1)// NOTE : BestRefExtCheck() not used for parameter estimation
	  continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
      }
      FLOAT *X = Gmap[mid]->site[0];
      int M = Gmap[mid]->numsite[0];
      FLOAT *Y = refmap[align->mapid1]->site[0];
      int N = refmap[align->mapid1]->numsite[0];
      double LRsd = 0.0;

      double LR = logLR(mid,align->mapid1,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], 
			align->Lij1,align->Rij1,align->Lij2,align->Rij2,1, /* (verb && Gmap[mid]->id== MAP_TRACE && refmap[align->mapid1]->id ==REF_TRACE) ? 1 : 0*/ 0, &LRsd,0,minSNR, &tmpAstat);

      double origLR = 0.0;
      if(!SNR_BESTREF_FIX){
	if(LR > 0.0){
	  Narray[i] = LR;
	  myAstat.len += tmpAstat.len;
	  myAstat.fp += tmpAstat.fp;
	  myAstat.fn += tmpAstat.fn;
	  myAstat.sitecnt += tmpAstat.sitecnt;
	}
      } else {
        origLR = Narray[mid];
	if(LR > origLR){
	  #pragma omp critical
	  {
	    origLR = Narray[mid];
	    Narray[mid] = max(origLR, LR);
	    Sarray[mid] = tmpAstat;
	  }
	}
      }

      if(verb){
	double delta = SNR_BESTREF_FIX ? max(0.0, LR - origLR) : Narray[i];
	LRsum += delta;
        Scnt += (origLR <= 0.0 && delta > 0.0) ? 1 : 0;
        printf("cnt=%lu:mid=%lu(id=%lld),rid=%d(id=%lld),or=%d: LR= %0.6f (delta= %0.6f, cum= %0.6f),Scnt=%lu\n", 
	       cnt,mid,Gmap[mid]->id,align->mapid1,refmap[align->mapid1]->id, align->orientation, LR, delta, LRsum,Scnt);
	fflush(stdout);
	cnt++;
      }
    }

    if(MINSNR_FIX && !SNR_BESTREF_FIX){
      #pragma omp critical
      {
	Astat.len += myAstat.len;
	Astat.fp += myAstat.fp;
	Astat.fn += myAstat.fn;
	Astat.sitecnt += myAstat.sitecnt;
      }
    }
  }

  if(verb==0){
    if(SNR_BESTREF_FIX){
      for(size_t mid = 0; mid < maxmapid; mid++){
	LRsum += Narray[mid];
        Scnt += (Narray[mid] > 0.0) ? 1 : 0;
      }
    } else {
      for(size_t i = 0; i < numaligns; i++){
	LRsum += Narray[i];
        Scnt += (Narray[i] > 0.0) ? 1 : 0;
      }
    }
  }

  if(MINSNR_FIX){
    double origFP = FP[0];
    double origFN = FN[0];
    double origLRsum = LRsum;
    
    /* update FN[0],FP[0] */
    if(SNR_BESTREF_FIX){
      for(size_t mid = 0; mid < maxmapid; mid++){
	AlignStat *pstat = &Sarray[mid];
	Astat.len += pstat->len;
	Astat.fp += pstat->fp;
	Astat.fn += pstat->fn;
	Astat.sitecnt += pstat->sitecnt;
      }
    }

    if(Astat.len > 0.0){
      FP[0] = Astat.fp * 100.0 / Astat.len;
      FP[0] = max(MINFP,min(MAXFP,FP[0]));
    }
    if(Astat.sitecnt * FN[0] > 0.0){
      FN[0] = ((double)Astat.fn)/((double)Astat.sitecnt);
      FN[0] = max(MINFN,min(MAXFN,FN[0]));
    }

    if(verb){
      printf("\nFPcnt=%d,len=%0.4f, FNcnt=%d, sitecnt=%d\n",Astat.fp,Astat.len,Astat.fn,Astat.sitecnt);
      fflush(stdout);
    }

    score_update(1);  /* update score_init() terms that depend on FN (or FP) */

    if(SNR_BESTREF_FIX){
      if(DEBUG) assert(maxmapid > 0);
      memset(Narray, 0, maxmapid * sizeof(double));
    }

    size_t origScnt = Scnt;

    Scnt = 0;
    cnt = 0;
    LRsum = 0.0;

    /* recompute LR */
    #pragma omp parallel num_threads(numthreads) if (numthreads > 1 && verb==0)
    {
      int tid = 0;
#ifdef _OPENMP
      tid = omp_get_thread_num ();
#endif

    long long naligns = numaligns;

#if !USE_MIC
      #pragma omp for schedule(dynamic,1)
#endif
      for(long long i = 0; i < naligns; i++){
        if(USE_MIC && !((i % numthreads) == tid)){ // NOTE : simulates #pragma omp for schedule(static,1)
	  continue;
	}

        if(!SNR_BESTREF_FIX)
          Narray[i] = 0.0;
	Calign *align = alignment[i];
	if(!align || align->numpairs <= 1)
	  continue;
	if(MapRate > 0.0 && !(BestRefPV ? (align->logPV > LogPvThreshold) : (align->score > ScoreThreshold)))
	  continue;
	size_t mid = align->mapid2;
        if(DEBUG && SNR_BESTREF_FIX) assert(mid < maxmapid);
        if(!SNR_BESTREF_FIX && BestRef){
          Cmap *origmap = Gmap[mid];
          while(origmap->origmap)
	    origmap = origmap->origmap;
	  if(origmap->align->mapid1 != align->mapid1)// NOTE : BestRefExtCheck() not used for parameter estimation
	    continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
        }
	FLOAT *X = Gmap[mid]->site[0];
	int M = Gmap[mid]->numsite[0];
	FLOAT *Y = refmap[align->mapid1]->site[0];
	int N = refmap[align->mapid1]->numsite[0];
	double LRsd = 0.0;

	double LR = logLR(mid,align->mapid1,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], 
			  align->Lij1,align->Rij1,align->Lij2,align->Rij2,1, /* (verb && Gmap[mid]->id== MAP_TRACE && refmap[align->mapid1]->id == REF_TRACE) ? 1 : 0 */ 0, &LRsd,0,minSNR, NULL);

        double origLR = 0.0;
        if(!SNR_BESTREF_FIX)
  	  Narray[i] = max(0.0,LR);
        else {
	  origLR = Narray[mid];
	  if(LR > origLR){
	    #pragma omp critical
	    {
	      origLR = Narray[mid];
	      Narray[mid] = max(origLR, LR);
	    }
	  }
        }

	if(verb){
   	  double delta = SNR_BESTREF_FIX ? max(0.0, LR - origLR) : Narray[i];
	  LRsum += delta;
          Scnt += (origLR <= 0.0 && delta > 0.0) ? 1 : 0;

	  printf("cnt=%lu:mid=%lu(id=%lld),rid=%d(id=%lld),or=%d: LR= %0.6f (delta= %0.6f, cum= %0.6f), Scnt=%lu\n", 
		 cnt,mid,Gmap[mid]->id,align->mapid1,refmap[align->mapid1]->id, align->orientation, LR, delta, LRsum, Scnt);
	  fflush(stdout);
	  cnt++;
        }
      }
    }

    if(verb==0){
      if(SNR_BESTREF_FIX){
	for(size_t mid = 0; mid < maxmapid; mid++){
	  LRsum += Narray[mid];
	  Scnt += (Narray[mid] > 0.0) ? 1 : 0;
	}
      } else {
	for(size_t i = 0; i < numaligns; i++){
	  LRsum += Narray[i];
	  Scnt += (Narray[i] > 0.0) ? 1 : 0;
	}
      }
    }

    if(verb || VERB>=2){
      printf("SNRtotLL(minSNR= %0.3f): FN= %0.6f -> %0.6f, FP= %0.4f -> %0.4f, LRsum= %0.6f -> %0.6f (Scnt=%lu -> %lu)\n",
	     minSNR, origFN, FN[0], origFP, FP[0], origLRsum, LRsum, origScnt, Scnt);
      fflush(stdout);
    }

    /* restore orignal FP,FN */
    FP[0] = origFP;
    FN[0] = origFN;

    score_update(0);  /* restore score_init() terms that depend on FN (or FP) */
  }

  return LRsum;
}

static double scoresum;
static double logPVsum;
static int NumpairsSum;
static double logLRsum, logLRsdsum, totXlen;

static double ATscoresum;
static double ATlogPVsum;
static int ATNumpairsSum;
static double ATlogLRsum;

static double *logLRarray = NULL, *logSDarray = NULL, *Xlen = NULL;

int *orignummaps = 0;
int warning2 = 0;

static int thread_printed = 0;

extern double mtime(),wtime();/* see refine.cpp */

#define MAX_PV 50
static double RawMappingRatePV[MAX_PV+1];
static double MappingRatePV[MAX_PV+1];

#if SIMPLE_BIAS <= 1
/* compute

   biassum = AVG((rawx - y)/var(y))
   Ivarsum = AVG(1/var(y))

   AVG(z) means average of z over errors[BinStart .. BinEnd-1] */

static void biascompute(double &biassum, double &Ivarsum, Cinterval *errors, int Bin, int BinStart, int BinEnd, double *Tarray1, double *Tarray2, int numthreads,
		 double A, double B, double R, double E)
{
  for(int tid = 0; tid < numthreads; tid++)
    Tarray1[tid] = Tarray2[tid] = 0.0;

  // non-deterministic with gcc 4.6 unless -fno-unsafe-math-optimizations is used
  #pragma omp parallel num_threads(numthreads)
  {
    int tid = 0;
#ifdef _OPENMP
    tid = omp_get_thread_num ();
#endif

    double mybiassum = 0.0, myIvarsum = 0.0;
    
#if !USE_MIC
    #pragma omp for schedule(static,64)
#endif
    for(int i = BinStart; i < BinEnd; i++){
      if(USE_MIC && !(((i / 64) % numthreads) == tid)){ // NOTE : simulates #prama omp for schedule(static,64)
	continue;
      }

      Cinterval *perr = &errors[i];
      double y = perr->y;
      if(ENDFIX>=3 && perr->end && y >= perr->x){
	if(VERB>=2)
	  printf("Bin=%d,i=%d:end=%d,x=%0.4f,rawx=%0.4f,y=%0.4f:skipping due to ENDFIX>=3\n",
		 Bin,i,perr->end,perr->x,perr->rawx,perr->y);
	continue;
      }
      double var = A + B * y;
      if(QUADRATIC_VARIANCE)
	var += R*y*y;
      if(RES_VARIANCE)
	var += E * perr->resvar;
      double Ivar = 1.0/var;
      double rawx = perr->rawx;
      if(perr->end){// NEW9
	double *rawsite = Gmap[perr->mapid]->rawsite[0];
	rawx = rawsite[perr->R] - rawsite[perr->L];
      }
      double err = rawx - y;
      mybiassum += err * Ivar;
      myIvarsum += Ivar;
      if(VERB>=2)
	printf("Bin=%d,i=%d:end=%d,x=%0.4f,rawx=%0.4f,y=%0.4f,err=%0.4f,var=%0.8f,Ivar=%0.8f:biassum=%0.8f,Ivarsum=%0.8f\n",
	       Bin,i,perr->end,perr->x,rawx,perr->y,err,var,Ivar,biassum,Ivarsum);
    }

    Tarray1[tid] = mybiassum;
    Tarray2[tid] = myIvarsum;
  }
  qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
  qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);

  if(VERB>=2){
    double tbiassum = 0.0, tIvarsum = 0.0;
    printf("biascompute:Bin=%d,BinStart=%d,BinEnd=%d,numthreads=%d\n",Bin,BinStart,BinEnd,numthreads);
    for(int tid = 0; tid < numthreads; tid++){
      tbiassum += Tarray1[tid];
      tIvarsum += Tarray2[tid];
      printf("Bin=%d:tid=%d:biassum=%0.18f(delta=%0.18f),Ivarsum=%0.18f(delta=%0.18f)\n",
	     Bin,tid,tbiassum, Tarray1[tid], tIvarsum, Tarray2[tid]);
    }
    fflush(stdout);
  }

  /* NOTE : above summation with printf is deterministic , the below identical summation is NOT ! */
  biassum = Ivarsum = 0.0;
  for(int tid = 0; tid < numthreads; tid++){
    biassum += Tarray1[tid];
    Ivarsum += Tarray2[tid];
  }
  if(DEBUG>=2) assert(isfinite(biassum));
  if(DEBUG>=2) assert(isfinite(Ivarsum));
}

#endif // SIMPLE_BIAS <= 1

/* Return 1 IFF -BestRefExt AND -BestRefOutlier check is satisfied and alignment of mapid with refid should be suppressed */

static int BestRefExtCheck(Calign *align, Calign_brief *nalign, int mapid, int refid)
{
  if(BestRefExt <= 0.0){
    if(BestRefOutlier <= 999.0 && align->maxoutlier < BestRefOutlier)
      return 0;
    return 1;
  }
  
  if(DEBUG>=2) assert(align->score > ScoreThreshold);
  if(DEBUG>=2) assert(align->logPV > LogPvThreshold);
  if(DEBUG>=2) assert(align->numpairs >= AlignedSiteThreshold);
  if(DEBUG>=2) assert(align->maxoutlier <= AlignedOutlierThreshold);
  if(DEBUG>=2) assert(AlignedEndOutlier(align));
  if(DEBUG>=2) assert(AlignedLength(align,refmap[refid]->site[0]) >= AlignedLengthThreshold);
  if(DEBUG>=2) assert(0 <= mapid && mapid < nummaps);
  if(DEBUG>=2) assert(0 <= refid && refid < numrefmaps);
  Cmap *Qmap = Gmap[mapid];
  if(DEBUG>=2 && !(nalign->mapid1 >= 0 && nalign->mapid1 < numrefmaps)){
    printf("BestRefExtCheck:mapid=%d,refid=%d:Qmap->mapid=%d,Qmap->id=%lld,nalign->mapid1=%d,numrefmaps=%d\n",mapid,refid,Qmap->mapid,Qmap->id,nalign->mapid1,numrefmaps);
    printf("   align->mapid1=%d,align->mapid2=%d:score=%0.6f,logPV=%0.2f,numpairs=%d\n",align->mapid1,align->mapid2,align->score,align->logPV,align->numpairs);
    fflush(stdout);
    assert(nalign->mapid1 >= 0 && nalign->mapid1 < numrefmaps);
  }
  if(DEBUG>=2) assert(nalign->mapid1 != refid);
  if(nalign->logPV < align->logPV + BestRefExtMargin)
    return 0;

  Cmap *Rmap = refmap[refid];
  
  Cmap *Rmap2 = refmap[nalign->mapid1];
  if(DEBUG) assert(0 < nalign->sites1_0 && nalign->sites1_0 <= nalign->sites1_M && nalign->sites1_M <= Rmap2->numsite[0]);

  double startref2 = Rmap2->site[0][nalign->sites1_0];
  double endref2 = Rmap2->site[0][nalign->sites1_M];

  if(svcheck){/* modified version for -svcheck : check if Rmap->startloc .. is overlapped by corresponding region of nalign by at least BestRefExt kb */
    double startref = Rmap->startloc;
    double endref = Rmap->startloc + Rmap->site[0][Rmap->numsite[0]+1];

    if(DEBUG>=2) assert(Rmap2->startloc >= CHR_OFFSET * 0.001);
    double startalign = Rmap2->startloc + startref2;
    double endalign = Rmap2->startloc + endref2;

    if(min(endref,endalign) - max(startref,startalign) < BestRefExt)
      return 1;
    return 0;
  }

  /* check if nalign corresponds to center region of Rmap2 (not within BestRefExt kb of ends) */
  double len2 = Rmap2->site[0][Rmap2->numsite[0]+1];
  if(startref2 < BestRefExt || endref2 > len2 - BestRefExt)
    return 0;
  return 1;
}

union Tsitecov { int site; float cov; };

static int CcoverageInc(Tsitecov *p1, Tsitecov *p2)
{
  // NOTE : p1[1].cov is the coverage increment value : +wt at start of interval, -wt at end of interval

  int val1 = p1[0].site;
  int val2 = p2[0].site;
  
  return (val1 > val2) ? 1 : (val1 < val2) ? -1 : 
      (p1[1].cov > p2[1].cov)? 1 : (p1[1].cov < p2[1].cov)? -1 : 0;
}

/* keep track of coverage over site intervals, based on a set of site intervals that each add coverage of mapWT */
class Ccoverage {
  int IntCnt;/* number of sites, typically only decrease over time */
  int IntAlloc;/* number of allocated sites */
  int *sites;/* list of all start and end sites, sites[0..IntCnt - 1] in ascending order (may contain duplicate values) */
  float *cov;/* cov[i = 0..IntCnt - 1] is the coverage value for interval sites[i] .. sites[i+1] (only meaningful if sites[i+1] > sites[i]) */

  /* find value "site" in sorted array sites[start .. end-1] and return largest (Rightmost) "index" s.t. sites[index] == site.
     Exit with error message if value "site" is NOT found in sites[low..high] */
  int findidR(int site, int start, int end){
    int low = start, high = end - 1;
    while(high > low){
      int mid = (low + high + 1) / 2;
      if(DEBUG>=2) assert(low < mid && mid <= high);
      int midSite = sites[mid];
      if(midSite < site)
	low = mid + 1;
      else if(midSite > site)
	high = mid - 1;
      else
	low = mid;
    }
    
    if(DEBUG>=2) assert(low >= high);
    if(DEBUG>=2 && !(low == high && sites[low] == site) && (high >= end-1 || site < sites[high+1])){
      printf("findid: Unable to find site=%d in array sites[%d .. %d] = %d .. %d\n",site, start,end-1,sites[start],sites[end-1]);
      if(high < end-1)
	printf("\t sites[%d] = %d\n", high+1, sites[high+1]);
      fflush(stdout);
      assert(low <= high && sites[low] == site && (high >= end-1 || site < sites[high+1]));
    }
    
    return low;
  };


public:
  Ccoverage() { sites = NULL; cov = NULL;};

  Ccoverage(int cnt, int *start, int *end, float *wt){/* Initialize coverage based on "cnt" site intervals start[i]..end[i] each adding coverage of wt[i], i= 0..cnt-1 */
    IntAlloc = IntCnt = cnt * 2;
    sites = new int[IntCnt];
    cov = new float[IntCnt];

    if(cnt <= 0)
      return;

    Tsitecov *sitecov = new Tsitecov[IntCnt * 2];/* interleaved version of sites[],cov[] */
    for(int i = 0; i < cnt; i++){
      sitecov[4*i].site = start[i];
      sitecov[4*i + 1].cov = wt[i];
      sitecov[4*i + 2].site = end[i];
      sitecov[4*i + 3].cov = -wt[i];
    }

    qsort(sitecov, IntCnt, sizeof(int)*2, (intcmp *)CcoverageInc);
    if(DEBUG>=2)
      for(int i = 1; i < IntCnt; i++)
	assert(sitecov[2*i-2].site <= sitecov[2*i].site);

    float covsum = 0.0f;
    for(int i = 0; i < IntCnt; i++){
      sites[i] = sitecov[2*i].site;
      cov[i] = covsum += sitecov[2*i+1].cov;
    }
    if(DEBUG && !(fabs(covsum) <= 1e-3)){
      printf("WARNING : covsum = %0.7f\n",covsum);
      fflush(stdout);
      //      assert(fabs(covsum) <= 1e-3);
    }

    delete [] sitecov;

    // remove sites[i] where sites[i] == sites[i+1], then simplify qsort (above) and mincov, covdec, maxcov (below)
    int j = 0;
    for(int i = 0; i < IntCnt - 1; i++){
      if(sites[i] >= sites[i+1])
	continue;
      sites[j] = sites[i];
      cov[j] = cov[i];
      j++;
    }
    sites[j] = sites[IntCnt-1];
    cov[j] = cov[IntCnt-1];
    IntCnt = j + 1;
  };

  ~Ccoverage(){
    delete [] sites;
    delete [] cov;
  };

  /* find sites[istart] == start and sites[iend] == end : If sites[] array has duplicate values, the largest value istart or iend is computed.
     If either start or end is not found exit with an error message */
  void findInt(int start, int end, int &istart, int &iend){
    if(DEBUG) assert(end >= start);

    istart = findidR(start, 0, IntCnt);
    iend = findidR(end, istart, IntCnt);

    if(DEBUG/* HERE >=2 */) assert(sites[istart] == start && (istart >= IntCnt-1 || sites[istart+1] > start));
    if(DEBUG/* HERE >=2 */ && !(sites[iend] == end && (iend >= IntCnt-1 || sites[iend+1] > end))){
      printf("findInt:start=%d,end=%d,istart=%d,iend=%d,IntCnt=%d,sites[iend]=%d,sites[iend+1]=%d\n",
	     start,end,istart,iend,IntCnt,sites[iend], (iend >= IntCnt-1) ? sites[IntCnt-1]+1 : sites[iend+1]);
      fflush(stdout);
      assert(sites[iend] == end && (iend >= IntCnt || sites[iend+1] > end));
    }
  };

  float maxcov(){/* compute maximum coverage over entire range sites[0] .. sites[IntCnt-1] */
    float CovMax = 0.0f;

    for(int i = 0; i < IntCnt; i++)
      CovMax = max(CovMax, cov[i]);

    return CovMax;
  };

  float mincov(int istart, int iend){/* compute minimum coverage over interval sites[istart] .. sites[iend] - 1 */
    float CovMin = IntCnt;

    for(int i = istart; i < iend; i++)
      CovMin = min(CovMin, cov[i]);

    return CovMin;
  };

  void covdec(int istart, int iend, float dec){/* add "dec" value to coverage over interval sites[istart] .. sites[iend] - 1 */
    for(int i = istart; i < iend; i++)
      cov[i] -= dec;
  };

  void printcoverage() {
    printf("Coverage profile (IntCnt= %d)\n",IntCnt);
    for(int j = 0; j < IntCnt; j++)
      printf("j=%d/%d: site=%d, cov= %0.3f\n",j,IntCnt,sites[j],cov[j]);
    fflush(stdout);
  };
};

/* convert a ref map rmap, Y[0..N+1] and its alignments Lalignment[align_start .. align_end-1] into a contig data structure suitable for refinement
   Also return nmap[I=0..N+1], which maps the original sites Y[I] to contig->site[0][i = 0..n+1], where n == contig->numsite[0].
   The original sites are also marked with contig->sitecnt[0][i] == 2 (value is 1 for unaligned molecule sites and 0 for molecule ends)
   The molecule ids are stored as contig->contig[m=0..nummaps-1].mapid (where contig->nummaps == fmapcnt <= maligncnt <= mapcnt-origmapcnt), M == contig->contig[m].numsite[0]
   Molecule alignments are stored as contig->sitemap[0][m=0..nummaps-1][0..M+1] mapping to 0..n+1.
   Molecule orientations are stored as contig->flip[0..nummaps-1].
   Molecule maps are stored (in their proper orientation) as contig->X[0][m=0..nummaps-1][0..M+1]

   returns the number of sites n in the contig.

   This function filters Lalignment[] to remove extending maps (based on -TE, -AE, -LE or -minoverlap -RepeatMask) and non-extending maps (based on -T2,-A2, -L2 or -refine -extonly) and additionally filters out lowest confidence remaining
   maps based on -MaxCov : 
          1. The remaining alignment ids are returned in alignids[0..maligncnt-1] and used to build contig[]
	  2. The confidence of removed map alignements in Lalignment[] is lowered to 0, so they will not appear in the non-refined .xmap
 */
static int build_contig(Ccontig &contig, int * &nmap, int refid, Cmap *rmap, int N, FLOAT *Y, size_t align_start, size_t align_end, Calign **Lalignment,
			const int mapcnt, const int origmapcnt, 
			int &maligncnt, size_t * &alignids /* return values, in addition to contig and nmap[] */
			)
{
  double w1;
  if(EXTSPLIT_TRACE && rmap->id == EXTSPLIT_NREFID){
    w1 = wtime();
    printf("Starting build_contig: N=%d,maps=%d,alignments=%lu : cum wall time= %0.6f secs\n", N, mapcnt - origmapcnt, align_end - align_start, w1);
    if(VERB>=3){
      for(int I = 1; I <= N + 1; I++)
	printf(" site[%d] = %0.8f (delta= %0.8f)\n",I,rmap->site[0][I],rmap->site[0][I] - rmap->site[0][I-1]);
    }
    fflush(stdout);
  }

  /* treat all K (condensation) values as 0 (so X[J] aligned with Y[I] only) : the complete alignment will be recomputed by refine anyway */
  // HERE HERE : keep track of initial K value with pXsitesL and use them to initialize sitemapL 

  /* count number of sites (total_alloc) and unaligned sites in X[] */
  long long total_alloc = 0, unaligned_alloc = 0;

  int maxaligncnt = (BestRef && !MultiMatches) ? mapcnt - origmapcnt : align_end - align_start;
  alignids = new size_t[maxaligncnt];

  int m = 0;
  for(size_t alignid = align_start; alignid < align_end; alignid++){
    Calign *align = Lalignment[alignid];
    if(DEBUG>=2) assert(align && align->mapid1 == refid);
    int mapid = align->mapid2;
    if(DEBUG>=2) assert(!Gmap[mapid]->origmap);

    alignids[m] = alignid;
    total_alloc += Gmap[mapid]->numsite[0] + 2;
    unaligned_alloc += Gmap[mapid]->numsite[0] + 2 - align->numpairs;
    m++;
  }

  if(DEBUG && BestRef && !MultiMatches && m != mapcnt-origmapcnt){
    printf("refid=%d:m=%d,mapcnt=%d,origmapcnt=%d\n",refid,m,mapcnt,origmapcnt);
    fflush(stdout);
    assert(m == mapcnt-origmapcnt);
  }
  if(DEBUG) assert(m <= maxaligncnt);
  maligncnt = m;

  if(EXTSPLIT_TRACE && rmap->id == EXTSPLIT_NREFID){
    double w2 = wtime();
    printf("After counting number of alignments and sites:m=%d,site_cnt=%lld,aligned_cnt=%lld : cum wall time= %0.6f secs\n", m, total_alloc, unaligned_alloc, w2);
    fflush(stdout);
  }

  Csite ***pXsites = new Csite**[maligncnt];
  Csite **pXsites_pool = new Csite*[total_alloc];
  long long palloc = 0;/* points to next free entry in pXsites_pool[] */

  Csite **pYsites = new Csite*[N+2 + unaligned_alloc];/* pYsites[0..N+1] are the original sites/ends, pYsites[N+2 ... n+1] the uanlgined projections from maps */
  Csite *Ysites = new Csite[N+2 + unaligned_alloc];/* set of Csites to use to build all consensus sites including ends and unaligned projections from maps */
  long long alloc = N+2;/* points to next free entry in Ysites[] */

  for(int I=0; I <= N+1; I++){
    Csite *psite = pYsites[I] = &Ysites[I];
    if(DEBUG && I <= N && !(Y[I+1] > Y[I] - (FLOAT)1e-6)){
      printf("I=%d,N=%d:Y[I]=%0.8f,Y[I+1]=%0.8f\n",I,N,Y[I],Y[I+1]);
      fflush(stdout);
      assert(Y[I+1] > Y[I] - (FLOAT)1e-6);
    }
    psite->loc = Y[I];
    psite->I = I;
    if(VERB>=2){
      printf("I=%d,N=%d:Y[I]=%0.3f,site->loc=%0.3f,site->I=%d\n",I,N,Y[I],psite->loc,psite->I);
      fflush(stdout);
    }
  }

  if(EXTSPLIT_TRACE && rmap->id == EXTSPLIT_NREFID){
    printf("refid=%d:pXsites=%p, pXsites_pool=%p, Ysites=%p, maligncnt=%d (align=%lu..%lu), total_alloc=%lld, unaligned_alloc=%lld\n",
	   refid,pXsites,pXsites_pool,Ysites,maligncnt,align_start,align_end,total_alloc,unaligned_alloc);
    fflush(stdout);
  }

  int fmapcnt = 0;

  int filt1= 0, filt2= 0;// number of extending & non-extending molecules filtered (or suppressed with logPV set to LogPvThreshold - 1.0, if Refine <= 2)

  int numthreads = 1;
#ifdef _OPENMP
  numthreads = MaxThreads; // WAS omp_get_max_threads();
  numthreads = min(numthreads,MaxThreads);
  if(numthreads > nummaps)
    numthreads = max(1,nummaps);
#endif

  double FilterLogPV = 0.0;// WAS143 min(LogPvThreshold2,LogPvThresholdTE) - 1.0;

  // NOTE : Can be parallelized : need to localize some shared variables
  if(1) {
  
    for(m = 0; m < maligncnt; m++){
      size_t alignid = alignids[m];
      if(DEBUG>=2) assert(align_start <= alignid && alignid < align_end);
      Calign *align = Lalignment[alignid];
      if(DEBUG>=2) assert(align);

      int mapid = align->mapid2;
      if(DEBUG>=2) assert(align->mapid2 == mapid);
      if(DEBUG>=2) assert(align->mapid1 == refid);

      Cmap *nanomap = Gmap[mapid];
      int M = nanomap->numsite[0];

      if(DEBUG>=2 && !isfinite(align->logPV)){
	printf("mapid=%d:M=%d,N=%d:align->score=%0.6f,align->logPV=%0.6e,align->numpairs=%d\n",mapid,M,N,align->score,align->logPV,align->numpairs);
	fflush(stdout);
	assert(isfinite(align->logPV));
      }

      double scale = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;	    
      FLOAT *X = nanomap->site[0];
      int I = align->sites1[0];
      int K = align->sitesK1[0];
      //	    if(DEBUG) assert(K==0);
      int J = align->sites2[0];
      int U = align->numpairs;
      int RI = align->sites1[U-1];
      int RK = align->sitesK1[U-1];
      int RJ = align->sites2[U-1];
      int extendleft = 0, extendright = 0;

      /* first decide if this molecule should be discarded */
      if(extend){/* check if map extends beyond left/right end of reference */
	double leftend = (align->Lend > -2) ? Yc(Y,I,K) - scale*(align->orientation ? X[M+1]-X[M+1-J] : X[J]) : Yc(Y,I,K);
	double rightend = (align->Rend > -2) ?  Yc(Y,RI,RK) + scale*(align->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]) : Yc(Y,RI,RK);
	double AlignLen = AlignedLength(align,Y);
	extendleft = (leftend < 0.0 /* WAS EndLen */) ? 1 : 0;
	extendright = (rightend > Y[N+1]/* WAS -EndLen */) ? 1 : 0;
	if(extendleft || extendright){
	  if(align->logPV <= LogPvThresholdTE || align->numpairs < AlignedSiteThresholdE || AlignLen < AlignedLengthThresholdE){
	    if(EXTSPLIT_TRACE && rmap->id == EXTSPLIT_NREFID){
	      double Alen = align->orientation ? X[M+1 - J] - X[M+1 - RJ] : X[RJ] - X[J];
	      //	      double Xleft = min(Yc(Y,I,K) , scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]));
	      //	      double Xright = min(Y[N+1] - Yc(Y,RI,RK), scale * (align->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]));

	      printf("mapid=%d:id=%lld,M=%d,N=%d,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d,or=%d,Lend=%d,Rend=%d:leftend=%0.3f(%d),rightend=%0.3f(%d),Alen=%0.3f,%0.3f,XLen=%0.3f,Ylen=%0.3f (%d new sites),extendonly=%d,%0.3f, Refine=%d:\n",
		     mapid,Gmap[mapid]->id,M,N,I,K,J,RI,RK,RJ,align->orientation,align->Lend,align->Rend,leftend,extendleft,rightend, extendright,AlignLen,Alen, X[M+1], Y[N+1], M-RJ,extendonly,EndLen,Refine);

	      printf("\tdiscarded extending map (Lend=%d,%0.3f,Rend=%d,%0.3f) due to logPV=%0.4f(TE=%0.4f),Sites=%d(AE=%d),AlignLen=%0.3f(LE=%0.2f),Score=%0.2f\n",
		     align->Lend,-leftend,align->Rend,rightend-Y[N+1],align->logPV,LogPvThresholdTE,align->numpairs,AlignedSiteThresholdE,AlignLen,AlignedLengthThresholdE,align->score);
	      fflush(stdout);
	    }
	    if(FilterXmap)
	      align->logPV = FilterLogPV;
	    filt1++;
	    continue;
	  }
	  if(MinOverlapRatio > 0.0  && max(-leftend,rightend-Y[N+1]) > scale*X[M+1]*(1.0-MinOverlapRatio)){
	    if(EXTSPLIT_TRACE && rmap->id == EXTSPLIT_NREFID){
	      double Alen = align->orientation ? X[M+1 - J] - X[M+1 - RJ] : X[RJ] - X[J];
	      //	      double Xleft = min(Yc(Y,I,K) , scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]));
	      //	      double Xright = min(Y[N+1] - Yc(Y,RI,RK), scale * (align->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]));

	      printf("mapid=%d:id=%lld,M=%d,N=%d,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d,or=%d,Lend=%d,Rend=%d:leftend=%0.3f(%d),rightend=%0.3f(%d),Alen=%0.3f,%0.3f,XLen=%0.3f,Ylen=%0.3f (%d new sites),extendonly=%d,%0.3f, Refine=%d:\n",
		     mapid,Gmap[mapid]->id,M,N,I,K,J,RI,RK,RJ,align->orientation,align->Lend,align->Rend,leftend,extendleft,rightend, extendright,AlignLen,Alen, X[M+1], Y[N+1], M-RJ,extendonly,EndLen,Refine);
	      printf("\tdiscarded extending map (Lend=%d,%0.3f,Rend=%d,%0.3f) due to -minoverlap %0.4f (I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d:X[J,RJ,M+1]=%0.3f,%0.3f,%0.3f, Y[IK,RIK,N+1]=%0.3f,%0.3f,%0.3f)\n",
		     align->Lend, -leftend, align->Rend, rightend-Y[N+1],MinOverlapRatio,I,K,J,RI,RK,RJ,
		     scale*(align->orientation ? X[M+1]-X[M+1-J] : X[J]), scale*(align->orientation ? X[M+1]-X[M+1-RJ] : X[RJ]), scale*X[M+1],Yc(Y,I,K),Yc(Y,RI,RK), Y[N+1]);
	      fflush(stdout);
	    }
	    if(FilterXmap)
	      align->logPV = FilterLogPV;
	    filt1++;
	    continue;
	  }
	  int shift;
	  if(RepeatMaxShift > 0 && (shift = align->IsRepeatRegion())){
	    if(EXTSPLIT_TRACE && rmap->id == EXTSPLIT_NREFID){
	      double Alen = align->orientation ? X[M+1 - J] - X[M+1 - RJ] : X[RJ] - X[J];
	      //	      double Xleft = min(Yc(Y,I,K) , scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]));
	      //	      double Xright = min(Y[N+1] - Yc(Y,RI,RK), scale * (align->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]));

	      printf("mapid=%d:id=%lld,M=%d,N=%d,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d,or=%d,Lend=%d,Rend=%d:leftend=%0.3f(%d),rightend=%0.3f(%d),Alen=%0.3f,%0.3f,XLen=%0.3f,Ylen=%0.3f (%d new sites),extendonly=%d,%0.3f, Refine=%d:\n",
		     mapid,Gmap[mapid]->id,M,N,I,K,J,RI,RK,RJ,align->orientation,align->Lend,align->Rend,leftend,extendleft,rightend, extendright,AlignLen,Alen, X[M+1], Y[N+1], M-RJ,extendonly,EndLen,Refine);
	      printf("\tdiscarded extending map (L=%0.3f,R=%0.3f) due to Repeat at shift=%d (X[M+1]=%0.3f)\n",
		     -leftend,rightend-Y[N+1], shift,scale * X[M+1]);
	      fflush(stdout);
	    }
	    if(FilterXmap)
	      align->logPV = FilterLogPV;
	    filt1++;
	    continue;
	  }
	} else {
	  if(align->logPV <= LogPvThreshold2 || align->numpairs < AlignedSiteThreshold2 || AlignLen < AlignedLengthThreshold2 || 
	     (Refine == 2 && extendonly && leftend >= EndLen && rightend <= Y[N+1] - EndLen /* NEW57 */)){
	    if(EXTSPLIT_TRACE && rmap->id == EXTSPLIT_NREFID){
	      double Alen = align->orientation ? X[M+1 - J] - X[M+1 - RJ] : X[RJ] - X[J];
	      //	      double Xleft = min(Yc(Y,I,K) , scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]));
	      //	      double Xright = min(Y[N+1] - Yc(Y,RI,RK), scale * (align->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]));

	      printf("mapid=%d:id=%lld,M=%d,N=%d,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d,or=%d,Lend=%d,Rend=%d:leftend=%0.3f(%d),rightend=%0.3f(%d),Alen=%0.3f,%0.3f,XLen=%0.3f,Ylen=%0.3f (%d new sites),extendonly=%d,%0.3f, Refine=%d:\n",
		     mapid,Gmap[mapid]->id,M,N,I,K,J,RI,RK,RJ,align->orientation,align->Lend,align->Rend,leftend,extendleft,rightend, extendright,AlignLen,Alen, X[M+1], Y[N+1], M-RJ,extendonly,EndLen,Refine);
	      printf("\tdiscarded non-extending map alignment due to logPV=%0.4f(T2=%0.4f) OR Sites=%d(A2=%d) OR AlignLen=%0.3f(L2=%0.2f) OR -refine %d -extonly %0.3f\n",
		     align->logPV,LogPvThreshold2, align->numpairs, AlignedSiteThreshold2, AlignLen, AlignedLengthThreshold2,Refine, EndLen);
	      fflush(stdout);
	    }
	    if(FilterXmap)
	      align->logPV = FilterLogPV;
	    if(DEBUG) assert(isfinite(align->logPV));
	    filt2++;
	    continue;
	  }
	}
	if(VERB>=3 && (extendright || extendleft)){
	  double Alen = align->orientation ? X[M+1 - J] - X[M+1 - RJ] : X[RJ] - X[J];
	  double Xleft = min(Yc(Y,I,K) , scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]));
	  double Xright = min(Y[N+1] - Yc(Y,RI,RK), scale * (align->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]));

	  printf("mapid=%d:id=%lld,M=%d,N=%d,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d,or=%d,Lend=%d,Rend=%d:leftend=%0.3f(%d),rightend=%0.3f(%d),Alen=%0.3f,%0.3f,XLen=%0.3f,Ylen=%0.3f (%d new sites),extendonly=%d,%0.3f, Refine=%d:\n\t Score=%0.2f,logPV=%0.2f,numpairs=%d,mapWT=%0.6f,Xleft=%0.3f,Xright=%0.3f:fmapcnt=%d\n",
		 mapid,Gmap[mapid]->id,M,N,I,K,J,RI,RK,RJ,align->orientation,align->Lend,align->Rend,leftend,extendleft,rightend, extendright,AlignLen,Alen, X[M+1], Y[N+1], M-RJ,extendonly,EndLen,Refine,
		 align->score,align->logPV,align->numpairs,align->mapWT,Xleft,Xright, fmapcnt);
	  fflush(stdout);
	}
      }

      if(DEBUG/* HERE >=2 */) assert(fmapcnt <= m);
      alignids[fmapcnt] = alignids[m];/* compress alignids[0..maligncnt-1] array to alignids[0..fmapcnt-1] */

      /* make pXsites[m][0..M+1] point into Csite linked list starting at firstsite (or 0 for unaligned ends due to endoutliers)  */
      if(DEBUG) assert(fmapcnt < maligncnt);
      pXsites[fmapcnt] = &pXsites_pool[palloc];
      if(VERB>=2 && rmap->id == 21913){
	printf("fmapcnt=%d,M=%d:pXsites[fmapcnt]=%p,palloc=%lld\n",fmapcnt,M,pXsites[fmapcnt],palloc);
	fflush(stdout);
      }
      palloc += M + 2;
      if(DEBUG) assert(0 < palloc && palloc <= total_alloc);
      for(int j = 0; j <= M+1; j++)
	pXsites[fmapcnt][j] = 0;/* default all sites to endoutlier regions */

      if(align->Lend > -2 || UseEndoutliers){ /* add unaligned sites left of site X[J] to consensus sites linked list starting at firstsite */
	for(int j = 0; j < J; j++){
	  double loc = Y[I] - scale*(align->orientation ? X[M+1-j]-X[M+1-J] : X[J] - X[j]);

	  if(DEBUG>=2) assert(alloc < N + 2 + unaligned_alloc);
	  Csite *nsite = pYsites[alloc] = &Ysites[alloc]; alloc++;
	  nsite->loc = loc;
	  nsite->I = (j ? -1 : -2);/* encodes ends as -2, unaligned site as -1 */
#if DEBUG>=2 
	  nsite->m = m;
	  nsite->J = j;
#endif

	  pXsites[fmapcnt][j] = nsite;
	  if(VERB>=2){
	    if(loc < 0.0)
	      printf("Left end site j=%d of mapid=%d(id=%lld) extends left of Y : loc=%0.3f,Y[%d]=%0.3f,X[j]=%0.6f,X[%d]=%0.6f(scale=%0.6f)\n",
		     j, mapid,Gmap[mapid]->id,loc,I,Y[I], scale*(align->orientation ? X[M+1]-X[M+1-j] : X[j]), J, scale*(align->orientation ? X[M+1] - X[M+1-J] : X[J]),scale);
	    else
	      printf("Left end site j=%d of mapid=%d(id=%lld) maps to Y loc=%0.3f,Y[%d]=%0.3f,X[j]=%0.6f,X[%d]=%0.6f(scale=%0.6f)\n",
		     j,mapid,Gmap[mapid]->id,loc,I,Y[I], scale*(align->orientation ? X[M+1]-X[M+1-j] : X[j]), J, scale*(align->orientation ? X[M+1] - X[M+1-J] : X[J]),scale);
		    
	    fflush(stdout);
	  }
	}
      }

      /* process first aligned sites I,J,K */
      if(DEBUG/* HERE >=2 */ && !(ISLINEAR && isLinear)) assert(I-K > 0);

      pXsites[fmapcnt][J] = pYsites[I];
      if(VERB>=2 && rmap->id == 21913){
	printf("m=%d/%d,fmapcnt=%d,mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d:Y[I]=%0.3f,Y[I-K]=%0.3f,X[J]=%0.3f:(aligned site:I=%d,loc=%0.3f),scale=%0.6f\n",
	       m,maligncnt,fmapcnt,mapid,Gmap[mapid]->id,align->orientation,I,K,J,Y[I],Y[I-K],scale * (align->orientation ? X[M+1]-X[J] : X[J]), pYsites[I]->I,pYsites[I]->loc, scale);
	fflush(stdout);
      }

      /* process subsequent aligned sites and unaligned sites between them */
      int H = I;
      int D = K;
      int G = J;
      for(int T= 1; T < align->numpairs; T++, H = I, D = K, G = J){
	I = align->sites1[T];
	if(DEBUG/* HERE >=2 */ && !(ISLINEAR && isLinear) && !(I <= N)){
	  printf("m=%d/%d,fmapcnt=%d,refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:T=%d(U=%d),I=%d,N=%d\n",m,maligncnt,fmapcnt,refid,rmap->id,mapid,Gmap[mapid]->id,align->orientation,
		 T,align->numpairs,I,N);
	  fflush(stdout);
	  assert(I <= N);
	}
	K = align->sitesK1[T];
	//	      if(DEBUG) assert(K==0 && D==0);
	J = align->sites2[T];
	double y = Y[I] - Y[H];
	double x = scale * ((align->orientation==0) ? X[J] - X[G] : X[M+1-G] - X[M+1-J]);
	pXsites[fmapcnt][J] = pYsites[I];

	/* process unaligned sites in X between X[G] and X[J] */
	for(int j = G; ++j < J;){
	  double loc = Y[H] + scale * (align->orientation ? X[M+1-G] - X[M+1-j] : X[j]-X[G]) * y/x;
	  if(DEBUG && !(loc > Y[H] && loc < Y[I])){
	    printf("m=%d/%d:mapid=%d,or=%d:I=%d,K=%d,J=%d:H=%d,D=%d,G=%d:y=%0.4f(Y[I]=%0.3f,Y[H]=%0.3f),x=%0.3f(X[J]=%0.3f,X[G]=%0.3f):j=%d,X[j]=%0.3f,loc=%0.4f,scale=%0.7f\n",
		   m,maligncnt,mapid,align->orientation,I,K,J,H,D,G,y,Y[I],Y[H],x,
		   scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]),
		   scale * (align->orientation ? X[M+1]-X[M+1-G] : X[G]),j,
		   scale * (align->orientation ? X[M+1]-X[M+1-j] : X[j]),loc,scale);
	    fflush(stdout);
	    assert(loc > Y[H] && loc < Y[I]);
	  }
	  if(DEBUG>=2) assert(alloc < N + 2 + unaligned_alloc);
	  Csite *nsite = pYsites[alloc] = &Ysites[alloc]; alloc++;

	  nsite->loc = loc;
	  nsite->I = -1;
#if DEBUG>=2 
	  nsite->m = m;
	  nsite->J = j;
#endif
	  pXsites[fmapcnt][j] = nsite;
	}
	if(VERB>=2){
	  printf("m=%d/%d,fmapcnt=%d:mapid=%d(id=%lld),or=%d:I=%d,K=%d,J=%d,M=%d:Y[I]=%0.3f,Y[I-K]=%0.3f,X[J]=%0.3f:(aligned site:I=%d,loc=%0.3f),scale=%0.6f,align->Rend=%d\n",
		 m,maligncnt,fmapcnt,mapid,Gmap[mapid]->id,align->orientation,I,K,J,M,Y[I],Y[I-K],scale * (align->orientation ? X[M+1]-X[J] : X[J]), pYsites[I]->I,pYsites[I]->loc, scale,align->Rend);
	  fflush(stdout);
	}
      }
      if(DEBUG) assert(H == RI && D == RK && G == RJ);
      if(align->Rend > -2 || UseEndoutliers){/* add unaligned sites right of site X[RJ] */
	for(int j = RJ; ++j <= M+1; ){
	  double loc = Y[RI] + scale * (align->orientation ? X[M+1-RJ] - X[M+1-j] : X[j] - X[RJ]);
	  if(VERB>=2){
	    printf("mapid=%d(id=%lld):M=%d,N=%d:RI=%d,RK=%d,RJ=%d:Y[RI]=%0.3f,X[RJ]=%0.3f:j=%d,X[j]=%0.3f,loc=%0.4f,Y[N+1]=%0.3f\n",
		   mapid,Gmap[mapid]->id,M,N,RI,RK,RJ,Y[RI],
		   scale * (align->orientation ? X[M+1]-X[M+1-RJ] : X[RJ]),j,
		   scale * (align->orientation ? X[M+1]-X[M+1-j] : X[j]),loc,Y[N+1]);
	    fflush(stdout);
	  }
	  if(DEBUG>=2) assert(alloc < N + 2 + unaligned_alloc);
	  Csite *nsite = pYsites[alloc] = &Ysites[alloc]; alloc++;
	  nsite->loc = loc;
	  nsite->I = (j == M+1) ? -2 : -1;// -2 means molecule end
#if DEBUG>=2 
	  nsite->m = m;
	  nsite->J = j;
#endif
	  pXsites[fmapcnt][j] = nsite;
	  if(VERB>=2 && j==M+1){
	    if(loc > Y[N+1])
	      printf("Right end of mapid=%d(id=%lld) extends right of Y : loc=%0.3f,N=%d,Y[N+1]=%0.3f,Y[%d]=%0.3f,X[%d]=%0.3f\n",
		     mapid,Gmap[mapid]->id,loc,N,Y[N+1],RI,Y[RI],RJ, scale * (align->orientation ? X[M+1] - X[M+1-RJ] : X[RJ]));
	    else
	      printf("Right end of mapid=%d(id=%lld) maps to Y loc=%0.3f,N=%d,Y[N+1]=%0.3f,Y[%d]=%0.3f,X[%d]=%0.3f\n",
		     mapid,Gmap[mapid]->id,loc,N,Y[N+1],RI,Y[RI],RJ, scale * (align->orientation ? X[M+1] - X[M+1-RJ] : X[RJ]));
	    fflush(stdout);
	  }
	}
      }

      //	    #pragma omp atomic
      fmapcnt++;
	    
    } // for(m = 0; m < maligncnt; m++)
    if(DEBUG) assert(palloc <= total_alloc);/* Some maps were filtered out due to -extendonly, so not all memory was needed */
    if(DEBUG) assert(alloc <= N + 2 + unaligned_alloc);/* Some maps were filtered out due to -extendonly, so not all memory was needed */
    if(DEBUG) assert(fmapcnt <= maligncnt);
  } // if(1)

  if(VERB/* >=2 */){
    if(FilterXmap)
      printf("  maps remaining fmapcnt=%d (maligncnt=%d), %d extending maps filtered, %d non-extending maps filtered (also from unrefined .xmap)\n",fmapcnt, maligncnt, filt1, filt2);
    else
      printf("  maps remaining fmapcnt=%d (maligncnt=%d), %d extending maps filtered, %d non-extending maps filtered (but not from unrefined .xmap)\n",fmapcnt, maligncnt, filt1, filt2);
    if(VERB>=3){
      //      qsort(alignids,fmapcnt,sizeof(size_t),(intcmp *)alignidLogPVDec);
      for(m = 0; m < fmapcnt; m++){
	size_t alignid = alignids[m];
	if(DEBUG>=2) assert(align_start <= alignid && alignid < align_end);
	Calign *align = Lalignment[alignid];
	if(DEBUG>=2) assert(align);
	      
	int mapid = align->mapid2;
	printf("   id=%lld:numpairs=%d,score=%0.6f,logPV=%0.2f,Lend=%d,Rend=%d\n",Gmap[mapid]->id,align->numpairs,align->score,align->logPV,align->Lend,align->Rend);
      }
      fflush(stdout);
    }
    fflush(stdout);
  }
  if(DEBUG) assert(fmapcnt <= maligncnt);

  if(VERB>=2){
    double w2 = wtime();
    printf("After adding all alignments to contig:fmapcnt=%d: cum wall time= %0.6f secs\n", fmapcnt, w2);
    fflush(stdout);
  }

  // sort pYsites[0..alloc-1]
  Csite **pYsitesOrig = pYsites;
  pYsites = new Csite*[N+2];
  memcpy(pYsites,pYsitesOrig,sizeof(Csite *) * (N+2));

  qsort(pYsitesOrig, alloc, sizeof(Csite *), (intcmp *)CsiteLocInc);

  Csite *firstsite = pYsitesOrig[0];
  for(int i = 0; i < alloc; i++)
    pYsitesOrig[i]->site = i;

  int n = alloc - 2;/* account for ends of consensus sites = 0 and n+1 */
  if(DEBUG) assert(0 <= n);/* check of 31 bit overflow */

  if(VERB>=2){
    double w2 = wtime();
    printf("After sorting consensus map sites:fmapcnt=%d,n=%d: cum wall time= %0.6f secs\n", fmapcnt, n, w2);
    fflush(stdout);
  }

  /* create mapping nmap[I=0..N+1] from Y[I] to i = 0..n+1, by using pYsites[I]->site == i == nmap[I]. This is needed to merge 2 Alleles of the same Haplotype input map */
  for(int I = 0; I <= N+1; I++){
    nmap[I] = pYsites[I]->site;
    if(DEBUG) assert(0 <= nmap[I] && nmap[I] <= n+1);
    if(DEBUG && I > 0) assert(nmap[I-1] < nmap[I]);
  }

  if(VERB>=3){/* display consensus map and mappings */
    printf("n=%d,N=%d: pYsites[N+1]= %0.4f, Y[N+1]= %0.4f\n",n,N, pYsites[N+1]->loc, Y[N+1]);
    for(int I = 1; I <= N; I++){
      int i = nmap[I];
      printf("I=%d/%d:Y[I]= %0.6f, nmap[I]=i=%d\n",I, N, Y[I], i);
    }
    printf("\n");

    for(int m = 0; m < fmapcnt; m++){
      size_t alignid = alignids[m];
      Calign *align = Lalignment[alignid];
      int mapid = align->mapid2;
      Cmap *nanomap = Gmap[mapid];
      int M = nanomap->numsite[0];
      FLOAT *X = nanomap->site[0];
      
      Csite **ppX = pXsites[m];

      printf("m=%d: mapid=%d,id=%lld, M=%d, n=%d, or=%d, len= %0.4f\n",m, mapid, nanomap->id, M, n, align->orientation, X[M+1]);
      for(int J = 0; J <= M + 1; J++){
	Csite *p = ppX[J];
	//	printf("\t J=%d, X[J]= %0.4f: site=%d, loc= %0.4f, I=%d\n", J, X[J], p->site, p->loc - firstsite->loc, p->I);
	if(p->I >= 0)
	  printf("\t J=%d, X[J]= %0.4f: loc= %0.4f, I=%d, site= %d\n", J, X[J], p->loc - firstsite->loc, p->I, p->site);
	else
	  printf("\t J=%d, X[J]= %0.4f: loc= %0.4f, I=%d\n", J, X[J], p->loc - firstsite->loc, p->I);
      }
    }
    fflush(stdout);
  }

  contig.mapid = -1;/* marks this contig as a consensus map */
  contig.id = rmap->id;
  contig.numsite[0] = n;
  contig.site[0] = new double[n+2];
  //	contig.color = new char[n+2];
  contig.sitecnt[0] = new float[n+2];

  contig.nummaps = fmapcnt;
  contig.contig = new Ccontig[fmapcnt];
  contig.flip = new int[fmapcnt];
  contig.scale = new double[fmapcnt];
  contig.sitemap[0] = new int*[fmapcnt];
  contig.X[0] = 0;
  contig.align = new Calign*[fmapcnt];
  contig.maxoutlier = new double[fmapcnt];

  contig.left = Y[0] - firstsite->loc;/* original consensus left end */
  contig.right = Y[N+1] - firstsite->loc;/* original consensus right end */
  contig.Y1 = contig.left + Y[1] - Y[0];/* original leftmost label */
  contig.YN = contig.right - (Y[N+1] - Y[N]);/* original rightmost label */
  if(VERB>=2){
    printf("refid=%d: firstsite->loc = %0.3f\n",refid,firstsite->loc);
    fflush(stdout);
  }

  for(int site = 0; site <= n+1; site++){
    Csite *psite = pYsitesOrig[site];
    if(DEBUG) assert(site >=0 && site <= n+1);
    contig.site[0][site] = psite->loc - firstsite->loc;
    if(DEBUG) assert(contig.site[0][site] >= 0.0);
    if(DEBUG && !(site <= 0 || contig.site[0][site] >= contig.site[0][site-1] - 1e-6)){
      printf("psite->site=%d,psite->loc=%0.6f,firstsite->loc=%0.6f\n",
	     psite->site,psite->loc,firstsite->loc);
      if(site>0)
	printf("    contig.site[%d]=%0.6f,contig.site[%d]=%0.6f\n",
	       site,contig.site[0][site],site-1,contig.site[0][site-1]);
      fflush(stdout);
      assert(site <= 0 || contig.site[0][site] >= contig.site[0][site-1] - 1e-6);
    }
    if(site > 0)  contig.site[0][site] = max(contig.site[0][site], contig.site[0][site-1]);

    //	  contig.color[site] = 0;
    contig.sitecnt[0][site] = (psite->I == 0 || psite->I == N+1 || psite->I <= -2) ? 0.0f : (psite->I < 0) ? 1.0f : 2.0f;
    if(VERB>=3){
      printf("site=%d,n=%d:contig.sitecnt[site]=%0.1f:psite->I=%d,psite->loc= %0.4f\n",site,n,contig.sitecnt[0][site],psite->I,psite->loc);
      fflush(stdout);
    }
  }
  
  if(VERB>=2){
    double w2 = wtime();
    printf("After initializing contig data structure:n=%d: cum wall time= %0.6f secs\n", n, w2);
    fflush(stdout);
  }

  delete [] pYsitesOrig; pYsitesOrig = NULL;

  if(DEBUG>=2) assert(fmapcnt <= maligncnt);

  for(m = 0; m < fmapcnt; m++){
    size_t alignid = alignids[m];
    if(DEBUG>=2) assert(align_start <= alignid && alignid < align_end);
    Calign *align = Lalignment[alignid];
    if(DEBUG>=2) assert(align);
	  
    int mapid = align->mapid2;
    if(DEBUG>=2) assert(align->mapid2 == mapid);
    if(DEBUG>=2) assert(align->mapid1 == refid);
	  
    /* good alignment */
    Cmap *nanomap = Gmap[mapid];
    int M = nanomap->numsite[0];
    Ccontig *pcontig = &contig.contig[m];
    pcontig->numsite[0] = M;
    pcontig->mapid = mapid;
    pcontig->id = nanomap->id;
    pcontig->trimL[0] = 0;
    pcontig->trimR[0] = M+1;
    if(DEBUG>=2) assert(m < contig.nummaps);
    contig.flip[m] = align->orientation;
    contig.scale[m] = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;
    if(VERB>=2){
      printf("m=%d:mapid=%d,id=%lld,M=%d,n=%d, or=%d,contig.flip[m]=%d,score=%0.6f,logPV=%0.4f,numpairs=%d\n",
	     m,mapid,Gmap[mapid]->id, M,n,align->orientation,contig.flip[m],align->score,align->logPV,align->numpairs);
      fflush(stdout);
    }
    contig.sitemap[0][m] = new int[M+3];
    *contig.sitemap[0][m]++ = -1;
    contig.sitemap[0][m][0] = contig.sitemap[0][m][M+1] = -1;
    int lastsite = -1;
    for(int J = 0; J <= M+1; J++){
      Csite *psite = pXsites[m][J];
      if(VERB>=2 && psite){
	printf("  J=%d: I= %d, loc= %0.6f\n",J,psite->I,psite->loc - firstsite->loc);
	fflush(stdout);
      }
      if(DEBUG>=2 && J > 1 && J <= M && psite){
	assert(psite->site !=  contig.sitemap[0][m][J-1]);
	assert(psite->site <= n);
	if(psite->site >= 0) {
	  assert(psite->site > contig.sitemap[0][m][J-1]);
	  assert(psite->site > lastsite);
	  lastsite = psite->site;
	}
      }
      contig.sitemap[0][m][J] = psite ? psite->site : -1;
    }
  }// m = 0..fmapcnt-1

  /* free up memory */
  delete [] pXsites_pool; pXsites_pool = NULL;
  delete [] pXsites; pXsites = NULL;
  delete [] pYsites; pYsites = NULL;
  delete [] Ysites; Ysites = NULL;

  if(VERB>=2){
    double w2 = wtime();
    printf("After allocating & initializing contig.sitemap[0][0..fmapcnt-1]: cum wall time= %0.6f secs\n", w2);
    fflush(stdout);
  }

  if(DEBUG>=2){
    printf("Before Calling contig.Xmap():\n");

    if(DEBUG>=2) assert(fmapcnt <= maligncnt);

    for(m = 0; m < fmapcnt; m++){
      size_t alignid = alignids[m];
      Calign *align = Lalignment[alignid];
      if(DEBUG) assert(align);
	  
      int mapid = align->mapid2;
      if(DEBUG) assert(align->mapid2 == mapid);
      if(DEBUG) assert(align->mapid1 == refid);
	  
      /* good alignment */
      Cmap *nanomap = Gmap[mapid];
      int M = nanomap->numsite[0];
      Ccontig *pcontig = &contig.contig[m];
      int trimL = pcontig->trimL[0];
      int trimR = pcontig->trimR[0];
      if(DEBUG && pcontig->mapid != mapid){
	printf("m=%d:mapid=%d:contig.contig[m].mapid=%d,align->orientation=%d,contig.flip[m]=%d,score=%0.6f,logPV=%0.4f,numpairs=%d\n",
	       m,mapid,contig.contig[m].mapid,align->orientation,contig.flip[m],align->score,align->logPV,align->numpairs);
	fflush(stdout);
	assert(pcontig->mapid == mapid);
      }
      if(DEBUG) assert(trimL >= 0 && trimR >= trimL && trimR <= M+1);
      if(DEBUG) assert(M == pcontig->numsite[0]);
      if(DEBUG) assert(align->orientation == contig.flip[m]);
      if(DEBUG) assert(trimR - trimL == M+1);
    }
  }

  if(DEBUG)assert(contig.X[0] == 0);
  contig.Xmap();
  if(DEBUG)assert(contig.nummaps == fmapcnt);

  if(VERB>=2){
    double w2 = wtime();
    printf("After calling contig.Xmap(): cum wall time= %0.6f secs\n", w2);
    fflush(stdout);
  }

  if(DEBUG>=2){
    if(VERB>=2){
      printf("After Calling contig.Xmap():\n");
      fflush(stdout);
    }

    if(DEBUG>=2) assert(fmapcnt <= maligncnt);

    for(m = 0; m < fmapcnt; m++){
      size_t alignid = alignids[m];
      if(DEBUG) assert(align_start <= alignid && alignid < align_end);
      if(VERB>=3){
	printf("m=%d:alignids[m]= %lu\n",m,alignids[m]);
	fflush(stdout);
      }
      Calign *align = Lalignment[alignid];
      if(DEBUG) assert(align);
	  
      int mapid = align->mapid2;
      if(DEBUG) assert(align->mapid1 == refid);
	  
      double scale = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;	    	      
      Cmap *nanomap = Gmap[mapid];
      FLOAT *X = nanomap->site[0];
      int M = nanomap->numsite[0];
      Ccontig *pcontig = &contig.contig[m];
      int trimL = pcontig->trimL[0];
      int trimR = pcontig->trimR[0];
      if(DEBUG) assert(trimL >= 0 && trimR >= trimL && trimR <= M+1);
      if(DEBUG) assert(m < contig.nummaps);
      double trimLeft = X[trimL];
      double trimRight = X[trimR];
      if(DEBUG && (!(pcontig->mapid == mapid) || VERB>=2)){
	printf("m=%d:mapid=%d:contig.contig[m].mapid=%d,align->orientation=%d,contig.flip[m]=%d,score=%0.6f,logPV=%0.4f,numpairs=%d\n",
	       m,mapid,contig.contig[m].mapid,align->orientation,contig.flip[m],align->score,align->logPV,align->numpairs);
	fflush(stdout);
	assert(pcontig->mapid == mapid);
      }
      assert(M == pcontig->numsite[0]);
      if(DEBUG && !(align->orientation == contig.flip[m])){
	printf("m=%d:mapid=%d:align->orientation=%d,contig.flip[m]=%d,score=%0.6f,logPV=%0.4f,numpairs=%d\n",
	       m,mapid,align->orientation,contig.flip[m],align->score,align->logPV,align->numpairs);
	fflush(stdout);
	assert(align->orientation == contig.flip[m]);
      }
      for(int J = 0; J <= M+1; J++){
	if(DEBUG && !(contig.X[0][m][J] >= 0.0)){
	  printf("m=%d:mapid=%d,J=%d:contig.X[m][J]=%0.6e\n",m,mapid,J,contig.X[0][m][J]);
	  fflush(stdout);
	  assert(contig.X[0][m][J] >= 0.0);
	}
	if(DEBUG && !(fabs(contig.X[0][m][J] - scale * (align->orientation ? trimRight - X[trimR-J] : X[J] - trimLeft)) <= 0.0001)){
	  printf("m=%d:mapid=%d,J=%d:contig.X[m][J]=%0.6e,orientation=%d(flip[m]=%d),M=%d(contig[m].numsite=%d),trimL=%d,trimR=%d,Left=%0.6f,Right=%0.6f,X[trimL+J]=%0.6f,X[trimR-J]=%0.6f(delta=%0.6f),scale=%0.7f\n",
		 m,mapid,J,contig.X[0][m][J],align->orientation,contig.flip[m],M,pcontig->numsite[0],trimL,trimR,trimLeft,trimRight,X[trimL+J],X[trimR-J],
		 contig.X[0][m][J] - scale*(align->orientation ? trimRight - X[trimR-J] : X[trimL+J] - trimLeft),scale);
	  fflush(stdout);
	  assert(fabs(contig.X[0][m][J] - scale * (align->orientation ? trimRight - X[trimR-J] : X[trimL+J]-trimLeft)) <= 0.0001);
	}
      }
    }
  }

  if(VERB>=2){
    printf("MaxCov = %d\n",MaxCov);
    fflush(stdout);
  }
  if(!(MaxCov > 0))
    for(int id = 0; id < contig.nummaps;id++)
      contig.contig[id].contigid = id;

  if(MaxCov > 0){/* If needed, delete maps/alignments with lowest logPV, so coverage at all points is reduced to below MaxCov */
    CmapPv *mapPv = new CmapPv[contig.nummaps];
    double *Hcuts = contig.site[0];

    int *start = new int[fmapcnt];
    int *end = new int[fmapcnt];
    float *wt = new float[fmapcnt];

    if(DEBUG>=2) assert(fmapcnt <= maligncnt);

    for(int m = 0; m < fmapcnt; m++){
      size_t alignid = alignids[m];
      if(DEBUG>=2) assert(align_start <= alignid && alignid < align_end);
      Calign *align = Lalignment[alignid];
      if(DEBUG>=2) assert(align);

      int mapid = align->mapid2;
      if(DEBUG>=2) assert(align->mapid2 == mapid);
      if(DEBUG>=2) assert(m < contig.nummaps);
      if(DEBUG>=2 && !BestRefWT && !(align->mapWT == 1.0)){
	printf("m=%d/%d:alignid=%lu(%lu..%lu):refid=%d(%lld),mapid=%d(%lld),or=%d,rev=%d:mapWT= %0.6f\n",
	       m,fmapcnt,alignid,align_start,align_end-1,align->mapid1,YYmap[align->mapid1]->id,align->mapid2,XXmap[align->mapid2]->id,align->orientation,align->rev,align->mapWT);
	fflush(stdout);
	assert(align->mapWT == 1.0);
      }
      wt[m] = (BestRefWT && MaxCovWt) ? align->mapWT : 1.0f;

      mapPv[m].contigid = m;
      mapPv[m].LogPv = align->logPV;
      mapPv[m].discard = 0;
      Ccontig *pcontig = &contig.contig[m];
      int M = pcontig->numsite[0];
      int *mapM = contig.sitemap[0][m];

      int firstsite = mapM[0];
      for(int J= 1; firstsite < 0 && J <= M; J++)
	firstsite = mapM[J];
      if(MAXCOV_FIX != 0.0){
	for(; firstsite <= n; firstsite++)
	  if(Hcuts[firstsite + 1] > Hcuts[firstsite] + MAXCOV_FIX)
	    break;

	if(DEBUG/* HERE >=2 */) assert(Hcuts[firstsite + 1] > Hcuts[firstsite] + MAXCOV_FIX);
      }
      start[m] = firstsite;

      int lastsite = mapM[M+1];
      for(int J= M; lastsite < 0 && J >= 1; J--)
	lastsite = mapM[J];
      if(MAXCOV_FIX != 0.0){
	for(; lastsite >= 1; lastsite--)
	  if(Hcuts[lastsite] > Hcuts[lastsite - 1] + MAXCOV_FIX)
	    break;

	if(DEBUG/* HERE >=2 */) assert(Hcuts[lastsite] > Hcuts[lastsite - 1] + MAXCOV_FIX);
      }
      end[m] = lastsite;

      if(DEBUG/* HERE >=2 */ && !(0 <= firstsite && firstsite <= lastsite && lastsite <= n+1)){
	printf("m=%d,contig.nummaps=%d:n=%d,M=%d,firstsite=%d,lastsite=%d\n",
	       m,contig.nummaps,n,M,firstsite,lastsite);
	fflush(stdout);
	assert(0 <= firstsite);
	assert(firstsite <= lastsite);
	assert(lastsite <= n+1);
      }
    }

    /* sort mapPv[0..m-1] in ascending order of logPV (break ties in order of original mapid = Gmap[gcontig->contig[p->contigid].mapid]->mapid) */
    gcontig = &contig;
    qsort(mapPv,fmapcnt,sizeof(CmapPv),(intcmp*)mapPVinc);
    if(VERB>=2){
      int sitesum = 0;
      double lensum = 0.0;
      for(int del = 0; del < fmapcnt; del++){
	int m = mapPv[del].contigid;
	Ccontig *pcontig = &contig.contig[m];
	Cmap *pmap = Gmap[pcontig->mapid];
	int M = pcontig->numsite[0];
	int *mapM = contig.sitemap[0][m];
	int iL = mapM[0];
	int iR = mapM[M+1];

	sitesum += M;
	lensum += Gmap[pcontig->mapid]->site[0][M+1];

	printf("del=%d/%d:m=%d,mapid=%d(orig=%d,id=%lld),or=%d:numsites=%d,len=%0.6f(%0.6f..%0.6f),PV=%0.6f (cum:sites=%d,len=%0.3f)\n",
	       del,fmapcnt,m,pcontig->mapid,pmap->mapid,pmap->id,contig.flip[m],pcontig->numsite[0],pmap->site[0][M+1], Hcuts[iL], Hcuts[iR], mapPv[del].LogPv, sitesum, lensum);
	if(DEBUG) assert(pcontig->numsite[0] == Gmap[pcontig->mapid]->numsite[0]);
      }
      fflush(stdout);
    }

    /* compute highest coverage */
    Ccoverage coverage(fmapcnt, start, end, wt);
    float maxcov = coverage.maxcov();

    if(VERB>=2){
      printf("Highest coverage maxcov = %0.2f : cum wall time= %0.6f secs\n", maxcov, wtime());
      if(VERB>=3)
	coverage.printcoverage();
      fflush(stdout);
    }

    if(DEBUG) assert(PRESERVE_MAXCOV);

    int delcnt = 0;
    int nextdel = fmapcnt - 1 - floor(max(2.0,EndTrimCov)+0.999999);
    int sitesum = 0;
    double lensum = 0.0;

    float MaxCovf = MaxCov;

    if(maxcov > MaxCovf){
      int maxdel = 0;

      for(int del = 0; del <= nextdel; del++){
	int m = mapPv[del].contigid;
	Ccontig *pcontig = &contig.contig[m];
	Cmap *pmap = Gmap[pcontig->mapid];
	int M = pcontig->numsite[0];
	int firstsite = start[m];
	int lastsite = end[m];

	/* check if deleting this map would reduce coverage anywhere below MaxCovf */
	int ifirstsite, ilastsite;
	coverage.findInt(firstsite, lastsite, ifirstsite, ilastsite);
	float mincov = coverage.mincov(ifirstsite, ilastsite);

	if(mincov - wt[m] < MaxCovf)
	  continue;

	/* remove this map from coverage profile */
	delcnt++;
	maxdel = del;
	if(DEBUG) assert(mapPv[del].discard == 0);

	coverage.covdec(ifirstsite, ilastsite, wt[m]);

	mapPv[del].discard = 1;/* discard maxPv[del].contigid */
	    
	if(VERB>=2){
	  sitesum += M;
	  lensum += Gmap[pcontig->mapid]->site[0][M+1];
	  printf("del=%d/%d:mapid=%d(orig=%d,id=%lld):numsites=%d,len=%0.6f(%0.6f..%0.6f),PV=%0.6f: \n\t deleted (cum:maps=%d,sites=%d,len=%0.3f)\n",
		 del,fmapcnt,pcontig->mapid,pmap->mapid,pmap->id,M,pmap->site[0][M+1], Hcuts[firstsite], Hcuts[lastsite], mapPv[del].LogPv, delcnt,sitesum,lensum);
	  fflush(stdout);
	}
      } /* for del = 0 .. nextdel */

      /* update maxcov */
      maxcov = coverage.maxcov();

      if(DEBUG) assert(maxdel <= nextdel);
      nextdel = min(nextdel,maxdel)+1;
    } /* if (maxcov > MaxCov) */

    if(VERB){
      if(delcnt > 0){
	if(FilterXmap)
	  printf("Discarding %d out of %d alignments with logPV < %0.4f to reduce coverage to %d (total alignments=%d,maxcov=%0.2f), also removed from unrefined .xmap: cum wall time= %0.6f secs\n",
		 delcnt,nextdel,mapPv[nextdel].LogPv,MaxCov, contig.nummaps,maxcov, wtime());
	else
	  printf("Discarding %d out of %d alignments with logPV < %0.4f to reduce coverage to %d (total alignments=%d,maxcov=%0.2f), but NOT removed from unrefined .xmap: cum wall time= %0.6f secs\n",
		 delcnt,nextdel,mapPv[nextdel].LogPv,MaxCov, contig.nummaps,maxcov, wtime());
      } else
	printf("total maps=%d: maxcov= %0.2f: cum wall time= %0.6f\n",contig.nummaps, maxcov, wtime());
      if(VERB>=3)
	coverage.printcoverage();
      fflush(stdout);
    }

    /* remove maps maxPv[0..nextdel-1] with discard == 1 from contig */
    /* first mark contig[id].contigid = -1 for all contigs to be deleted */
    if(DEBUG)assert(contig.nummaps == fmapcnt);
    for(int id = 0; id < contig.nummaps;id++)
      contig.contig[id].contigid = id;
    for(int k = 0; k < nextdel; k++){
      int id = mapPv[k].contigid;
      if(DEBUG>=2) assert(id >= 0 && id < contig.nummaps);
      if(mapPv[k].discard){
	contig.contig[id].contigid = -1;

	/* If FilterXmap : delete alignment from output (unrefined .xmap) by reducing its Pvalue */
	if(DEBUG>=2) assert(0 <= id && id < maligncnt);
	size_t alignid = alignids[id];
	if(DEBUG>=2) assert(align_start <= alignid && alignid < align_end);
	Calign *align = Lalignment[alignid];
	if(DEBUG>=2) assert(align);
	if(VERB>=2){
	  int mapid = contig.contig[id].mapid;
	  printf("mapid=%d,id=%lld:discarding map due to excess coverage:logPV=%0.4f -> %0.4f\n",
		 mapid,Gmap[mapid]->id,align->logPV,FilterLogPV);
	  fflush(stdout);
	}
	if(FilterXmap)
	  align->logPV = FilterLogPV;
      }
    }

    int sitesum1 = 0, sitesum2 = 0;
    double lensum1 = 0.0, lensum2 = 0.0;
    if(DEBUG) assert(fmapcnt == contig.nummaps);

    int dcnt = 0;
    for(int id = 0; id < contig.nummaps; id++){
      Ccontig *pcontig = &contig.contig[id];
      sitesum1 += pcontig->numsite[0];
      lensum1 += Gmap[pcontig->mapid]->site[0][pcontig->numsite[0]+1];

      if(contig.contig[id].contigid >= 0){
	if(VERB>=2){
	  printf("id=%d/%d:contigid=%d,mapid=%d(orig=%d,id=%lld):numsites=%d,len=%0.6f (cum:sites=%d,len=%0.3f), dcnt=%d\n",
		 id,contig.nummaps,id,pcontig->mapid,Gmap[pcontig->mapid]->mapid,Gmap[pcontig->mapid]->id,pcontig->numsite[0],Gmap[pcontig->mapid]->site[0][pcontig->numsite[0]+1], sitesum1, lensum1,dcnt);
	  fflush(stdout);
	}
	if(DEBUG>=2) assert(contig.contig[id].contigid < maligncnt);

	if(dcnt > 0){/* swap contig[id] with contig[id-dcnt] */
	  Ccontig tmp = contig.contig[id-dcnt];
	  contig.contig[id-dcnt] = contig.contig[id];
	  contig.contig[id] = tmp;

	  contig.flip[id-dcnt] = contig.flip[id];
		
	  if(DEBUG && !(contig.sitemap[0][id-dcnt]==0)){
	    printf("id=%d/%d,dcnt=%d:swapping contig[id] with contig[id-dcnt]:contig.sitemap[0][id-dcnt]=%p\n",
		   id,contig.nummaps,dcnt,contig.sitemap[0][id-dcnt]);
	    fflush(stdout);
	    assert(contig.sitemap[0][id-dcnt]==0);
	  }
	  contig.sitemap[0][id-dcnt] = contig.sitemap[0][id];
	  contig.sitemap[0][id] = 0;
		
	  if(DEBUG) assert(contig.X[0][id-dcnt]==0);
	  contig.X[0][id-dcnt] = contig.X[0][id];
	  contig.X[0][id] = 0;
	}

	continue;
      }

      dcnt++;

      sitesum2 += pcontig->numsite[0];
      lensum2 += Gmap[pcontig->mapid]->site[0][pcontig->numsite[0]+1];
      if(VERB>=2){
	printf("id=%d/%d:contigid=%d,mapid=%d(orig=%d,id=%lld):numsites=%d,len=%0.6f (cum:sites=%d,len=%0.3f)(deleted:maps=%d,sites=%d,len=%0.3f)\n",
	       id,contig.nummaps,id,pcontig->mapid,Gmap[pcontig->mapid]->mapid,Gmap[pcontig->mapid]->id,pcontig->numsite[0],Gmap[pcontig->mapid]->site[0][pcontig->numsite[0]+1],
	       sitesum1, lensum1, dcnt, sitesum2,lensum2);
	fflush(stdout);
      }

      /* free memory of contig.contig[id] */
      if(DEBUG) assert(contig.contig[id].mapid >= 0);
      contig.contig[id].allfree();
      if(contig.sitemap[0][id]){
	delete [] &contig.sitemap[0][id][-1];
	contig.sitemap[0][id] = 0;
      }
      if(DEBUG) assert(contig.X[0]);
      delete [] contig.X[0][id];
      contig.X[0][id] = 0;
    }

    if(VERB>=2){
      printf("total:maps=%d,sites=%d,len=%0.3f (deleted:maps=%d,sites=%d,len=%0.3f)\n",
	     contig.nummaps, sitesum1, lensum1, dcnt, sitesum2,lensum2);
      fflush(stdout);
    }
    if(DEBUG) assert(delcnt == dcnt);

    contig.nummaps -= dcnt;

    if(DEBUG>=2){
      for(int m = 0; m < contig.nummaps; m++){
	int id = contig.contig[m].contigid;
	if(DEBUG) assert(0 <= id && id < maligncnt);
	size_t alignid = alignids[id];
	if(DEBUG) assert(align_start <= alignid && alignid < align_end);
	Calign *align = Lalignment[alignid];
	if(DEBUG) assert(align);
      }
    }

    delete [] mapPv;
    delete [] start;
    delete [] end;
    delete [] wt;

    if(VERB>=2){
      double w2 = wtime();
      printf("After filtering maps due to -MaxCov: cum wall time= %0.6f secs\n", w2);
      fflush(stdout);
    }

    // Need to update contig.sitecnt[0][0..n+1] based on contig.sitemap[0][m=0..MD-1][j=0..MX[m]+1] since original contig.sitecnt[] does not reflect deleted maps due to -MaxCov
    // See code in refine() and move it here. This will also fix the corresponding problem with refineHap()

    Ccontig *pcontig = &contig;
    float *&sitecnt = pcontig->sitecnt[0];// NOTE : sitecnt is now an alias for pcontig->sitecnt[0]
    float *origsitecnt = NULL;

    int *MX = NULL;
    int MD = pcontig->nummaps;

    if(SITECNT_FIX){
      MX = new int[MD];
      for(int k = 0; k < MD; k++)
	MX[k] = pcontig->contig[k].numsite[0];

      origsitecnt = new float[n+2];
      memcpy(origsitecnt,sitecnt,(n+2)*sizeof(float));
      memset(sitecnt, 0, (n+2)*sizeof(float)); 

      for(int m = 0; m < MD; m++){
	int *mapM = pcontig->sitemap[0][m];/* mapM[j=0..MX[m]+1] is location of site X[m][j] on Hcuts[0..n+1] (or -1 if not aligned) */
	int lasti = -1, lastJ = -1;
	int M = MX[m];
	for(int J = 1; J <= M; J++){
	  int i = mapM[J];
	  if(DEBUG>=2) assert(0 <= i && i <= n+1);

	  sitecnt[i] += 1.0f;
	  
	  if(DEBUG>=2 && !(i > lasti && sitecnt[i] <= m + 1.0f + 1e-6f)){
	    double *X = pcontig->X[0][m];/* query maps X[j=0..MX[k]+1] */
	    int mapid = pcontig->contig[m].mapid;
	    int id = contig.contig[m].contigid;
	    size_t alignid = alignids[id];
	    if(DEBUG) assert(align_start <= alignid && alignid < align_end);
	    Calign *align = Lalignment[alignid];
	    if(DEBUG) assert(align);

	    printf("m=%d: mapid=%d,id=%lld,or=%d: M=%d, len= %0.4f, score=%0.6f, logPV=%0.2f: site[lasti=%d,i=%d] = %0.4f,%0.4f, X[lastJ=%d,J=%d]= %0.4f,%0.4f, sitecnt[i]= %0.6f\n",
		   m,mapid,Gmap[mapid]->id, align->orientation, MX[m], X[MX[m]+1], align->score, align->logPV, lasti,i,pcontig->site[0][lasti],pcontig->site[0][i],
		   lastJ,J,X[lastJ],X[J], sitecnt[i]);
	    fflush(stdout); 
	    assert(i > lasti && sitecnt[i] <= m + 1.0f + 1e-6f);
	  }
	  lasti = i;
	  lastJ = J;
	}

#if COMPRESS_CONTIG
	/* minimum value 0.01f for ends */
	int i = mapM[0];
	if(i >= 0){
	  if(DEBUG) assert(i <= n+1);
	  sitecnt[i] = max(sitecnt[i], 0.01f);
	}
	i = mapM[MX[m]+1];
	if(i >= 0){
	  if(DEBUG) assert(i <= n+1);
	  sitecnt[i] = max(sitecnt[i], 0.01f);
	}
#endif
      }

      for(int i = 1; i <= n; i++){
	if(DEBUG) assert(origsitecnt[i] <= 2.001f);
	
	if(origsitecnt[i] >= 1.999f)
	  sitecnt[i] = max(origsitecnt[i],sitecnt[i]);
	
	if(DEBUG && !(sitecnt[i] >= 0.0f && sitecnt[i] <= max(2,MD) + 1e-6f)){
	  printf("i=%d,n=%d:sitecnt[i]= %0.2f, MD= %d\n",i,n,sitecnt[i],MD);
	  fflush(stdout);
	  assert(sitecnt[i] >= 0.0f && sitecnt[i] <= max(2,MD) + 1e-6f);
	}
      }

      int orign = n;

#if COMPRESS_CONTIG
      /* make sure to keep ends of Y[0,N+1] */
      for(int I = 0; I <= N+1; I += N+1){
	int i = nmap[I];
	sitecnt[i] = max(0.01f, sitecnt[i]);
      }

      if(VERB>=3){
	for(int I = 0; I <= N+1; I++){
	  int i = nmap[I];
	  printf("I=%d/%d: Y[I]= %0.4f, nmap[I]=i=%d, orign=%d : origsitecnt[i]= %0.3f -> %0.3f\n", I,N,Y[I], i, orign, origsitecnt[i], sitecnt[i]);
	}
	fflush(stdout);
      }

      /* reduce n to include only ends and labels with sitecnt[i] > 0 */
      int *Hremap = new int[n+2];/* maps from original site i to new compacted site Hremap[i] */
      
      Hremap[0] = n = 0;
      for(int i = 1; i <= orign; i++){
	Hremap[i] = -1;
	if(sitecnt[i] > 0.0){
	  Hremap[i] = ++n;
	  if(VERB>=3){
	    printf("i=%d/%d:orig sitecnt[i]= %0.2f, Hremap[i]= %d\n",i,orign,sitecnt[i], Hremap[i]);
	    fflush(stdout);
	  }
	} else if(VERB>=3){
	  printf("i=%d/%d:orig sitecnt[i]= %0.2f, Hremap[i]= %d\n",i,orign,sitecnt[i], Hremap[i]);
	  fflush(stdout);
	}
      }
      Hremap[orign+1] = n+1;
      contig.numsite[0] = n;

      /* remap sitecnt[] */
      delete [] origsitecnt;
      origsitecnt = sitecnt;
      sitecnt = new float[n+2];
      int cnt = 0;/* count now many entries in sitecnt[] have been set : should add up to n+2 */
      for(int i = 0; i <= orign + 1; i++){
	int j = Hremap[i];
	if(j >= 0){
	  if(DEBUG>=2 && !(j == cnt)){
	    printf("i=%d (n=%d -> %d), Hremap[i]=j=%d (cnt=%d), sitecnt[j] -> origsitecnt[i]= %0.3e\n",
		   i, orign, n, Hremap[i], cnt, origsitecnt[i]);
	    assert(j == cnt);
	  }
	  cnt++;
	  sitecnt[j] = origsitecnt[i];
	  if(sitecnt[j] <= 0.02f)
	    sitecnt[j] = 0.0f;
	} else if(DEBUG>=2 && !(origsitecnt[i] <= 0.0f)){
	  printf("i=%d (n=%d -> %d), Hremap[i]=%d, origsitecnt[i]= %0.3e\n",
		 i, orign, n, Hremap[i], origsitecnt[i]);
	  fflush(stdout);
	  assert(origsitecnt[i] <= 0.0f);
	}
      }
      if(DEBUG) assert(cnt == n+2);
      
      if(DEBUG){
	for(int i = 1; i <= n; i++){
	  if(DEBUG && !(sitecnt[i] >= 0.0f && sitecnt[i] <= max(2,MD) + 1e-6f)){
	    printf("i=%d,n=%d: sitecnt[i]= %0.2f, MD= %d\n",i,n,sitecnt[i],MD);
	    fflush(stdout);
	    assert(sitecnt[i] >= 0.0f && sitecnt[i] <= max(2,MD) + 1e-6f);
	  }
	}
      }

      /* remap contig.site[0][m] */
      double *origsite = contig.site[0];
      contig.site[0] = new double[n+2];

      cnt = 0;
      for(int i = 0; i <= orign + 1;i++){
	int j = Hremap[i];
	if(j >= 0){
	  if(DEBUG>=2 && !(j == cnt)){
	    printf("i=%d (n=%d -> %d), Hremap[i]=j=%d (cnt=%d), site[j] -> origsite[i]= %0.4f\n",
		   i, orign, n, Hremap[i], cnt, origsite[i]);
	    assert(j == cnt);
	  }
	  cnt++;
	  contig.site[0][j] = origsite[i];
	}
      }
      if(DEBUG) assert(cnt == n+2);
      delete [] origsite;

      /* remap nmap[0..N+1] */
      for(int I = 0; I <= N+1; I++){
	int i = nmap[I];
	if(DEBUG>=2) assert(0 <= i && i <= orign+1);
	int j = Hremap[i];
	if(DEBUG/* HERE >=2 */ && !(0 <= j && j <= n+1)){
	  printf("I=%d,N=%d:nmap[I]=i=%d,orign=%d, Hremap[i]=j=%d,n=%d\n",
		 I,N,i,orign,j,n);
	  printf("\t origsitecnt[i]= %0.3f\n", origsitecnt[i]);
	  fflush(stdout);
	  assert(0 <= j && j <= n+1);
	}
	nmap[I] = j;
      }

      /* remap pcontig->sitemap[0][m] arrays */
      for(int m = 0; m < MD; m++){
	int *mapM = pcontig->sitemap[0][m];
	for(int J = MX[m]+1; J >= 0; J--){
	  int i = mapM[J];
	  if(DEBUG/* HERE >=2 */) assert(0 <= i && i <= orign+1);
	  int j = Hremap[i];
	  if(DEBUG/* HERE >= 2*/) assert(0 <= j && j <= n+1);
	  mapM[J] = j;
	}
      }

      delete [] origsitecnt; origsitecnt = NULL;
      delete [] Hremap;
#endif // COMPRESS_CONTIG

      if(VERB>=3){/* display consensus map and mappings */
	printf("n=%d,N=%d: site[0]= %0.4f, site[n+1]= %0.4f, Y[N+1]= %0.4f\n", n, N, contig.site[0][0], contig.site[0][n+1], Y[N+1]);
	for(int i = 0; i <= n+1; i++)
	  if(sitecnt[i] > 0.0f)
	    printf("i=%d:site[i]= %0.4f, sitecnt[i]= %0.3e\n", i, contig.site[0][i], sitecnt[i]);
	printf("\n");

	for(int m = 0; m < MD; m++){
	  int *mapM = pcontig->sitemap[0][m];
	  double *X = pcontig->X[0][m];/* query maps X[j=0..MX[k]+1] */
	  int mapid = pcontig->contig[m].mapid;
	  int id = contig.contig[m].contigid;
	  size_t alignid = alignids[id];
	  if(DEBUG) assert(align_start <= alignid && alignid < align_end);
	  Calign *align = Lalignment[alignid];
	  if(DEBUG) assert(align);

	  printf("m=%d: mapid=%d,id=%lld,or=%d: M=%d, len= %0.4f, score=%0.6f, logPV=%0.2f\n",m,mapid,Gmap[mapid]->id, align->orientation, MX[m],X[MX[m]+1], align->score, align->logPV);
	  for(int J = 0; J <= MX[m] + 1; J++){
	    int i = mapM[J];
	    if(DEBUG) assert(0 <= i && i <= n+1);	    
	    printf("\t J=%d, X[J]= %0.4f: site[i]= %0.4f, sitecnt[i]= %0.3e\n", J, X[J], contig.site[0][i], sitecnt[i]);
	  }
	}
	fflush(stdout);
      }

      delete [] MX;
      MX = NULL;

      if(VERB>=2){
	double w2 = wtime();
	printf("After updating contig.sitecnt[0][] to removed filtering maps and reducing n=%d -> %d: cum wall time= %0.6f secs\n", orign, n, w2);
	fflush(stdout);
      }
    }

    // NOTE : Due to -MaxCov mapwt may no longer be normalized : consider doing a local renormalization 
  }

  delete [] Ysites; Ysites = NULL;
  delete [] pYsitesOrig; pYsitesOrig = NULL;

  /* Allocate coverage arrays used as output by refine() for use in output_draft() */
  contig.fragcnt[0] = new float[n+2];
  contig.sitecntFN[0] = new float[n+2];
  if(mCNT > 0){
    contig.sitecntN1[0][0] = new float[(n+2)*mCNT];
    for(int t = 1; t < mCNT; t++)
      contig.sitecntN1[0][t] = contig.sitecntN1[0][0] + (n+2)*t;
  }
  contig.fragcntT[0] = new float[n+2];
  if(CovNorm)
    contig.fragcntTnorm[0] = new float[n+2];
  if(TrimNorm >= 0){
    contig.sitecntFNnorm[0] = new float[n+2];
    contig.sitecntN2[0] = new float[n+2];
    contig.sitecntN3[0] = new float[n+2];
    contig.sitecntN4[0] = new float[n+2];
    contig.sitecntN5[0] = new float[n+2];
    contig.sitecntN6[0] = new float[n+2];

    contig.fragSd[0] = new float[n+2];
    contig.expSd[0] = new float[n+2];
    contig.fragBias[0] = new float[n+2];
    contig.fragCov[0] = new float[n+2];
    contig.fragChiSq[0] = new float[n+2];
  }

  if(VERB>=2){
    printf("After reducing coverage:nummaps=%d\n",contig.nummaps);
    int sitesum = 0;
    double lensum = 0.0;
    for(int id = 0; id < contig.nummaps; id++){
      Ccontig *pcontig = &contig.contig[id];
      sitesum += pcontig->numsite[0];
      lensum += Gmap[pcontig->mapid]->site[0][pcontig->numsite[0]+1];
      printf("contigid=%d/%d:mapid=%d(orig=%d,id=%lld):numsites=%d,len=%0.6f (cum:sites=%d,len=%0.3f)\n",
	     id,m,pcontig->mapid,Gmap[pcontig->mapid]->mapid,Gmap[pcontig->mapid]->id,pcontig->numsite[0],Gmap[pcontig->mapid]->site[0][pcontig->numsite[0]+1], sitesum, lensum);
    }
    fflush(stdout);
  }

  for(int m = 0; m < contig.nummaps; m++){
    int id = contig.contig[m].contigid;
    if(DEBUG>=2) assert(0 <= id && id < maligncnt);
    size_t alignid = alignids[id];
    if(DEBUG>=2) assert(align_start <= alignid && alignid < align_end);
    Calign *align = Lalignment[alignid];
    if(DEBUG>=2) assert(align);
    contig.align[m] = align;
    contig.maxoutlier[m] = align->maxoutlier;
  }

  if(VERB>=2){
    double w2 = wtime();
    printf("Completed build_contig: N=%d,maps=%d, alignments=%lu -> %d, n=%d : wall time = %0.6f (cum= %0.6f)\n",
	   N, mapcnt - origmapcnt, align_end - align_start, contig.nummaps, n, w2-w1,w2);
    fflush(stdout);
  }

  if(DEBUG) assert(contig.numsite[0] == n);

  return n;
}

static double updateBiasLL(double val, Cinterval *errors, int numerrors, double A, double B, double R, double E, double logXtheta, double *Tarray3)
{
  /* estimate LL with full bias removal */
  BiasCorrect(Gmap, 0, nummaps, 0);

#ifdef _OPENMP
  int numthreads = MaxThreads; // WAS omp_get_max_threads();
  if(numthreads > numerrors/64)
    numthreads = max(1,numerrors/64);
#endif

  if(RESBIAS_TRACE>=2 && val==0.0)
    qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorIdInc);

  /* now recompute x values in errors[] based on new site[] values and new LL value */
  double errsum3 = 0.0;
  for(int tid = 0; tid < numthreads; tid++)
    Tarray3[tid] = 0.0;

  #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
  {
    int tid = 0;
#ifdef _OPENMP
    tid = omp_get_thread_num ();
#endif

    int lastid  = -1;
    double LogSum = 0.0,Errsum1 = 0.0, Errsum2 = 0.0, LogCum = 0.0, Errcum1 = 0.0, Errcum2 = 0.0;/* for debugging */

#if REFDEBUG >= 1 || RESBIAS_DEBUG	       
    double myerrsum0 = 0.0;
    double myerrsum1 = 0.0;
#endif
    double myerrsum3 = 0.0;

#if !USE_MIC
    #pragma omp for schedule(static,64)
#endif
    for(int i = 0; i < numerrors; i++){
      if(USE_MIC && !(((i / 64) % numthreads) == tid)){ // NOTE : simulates #pragma omp for schedule(static,64)
        continue;
      }

      Cinterval *perr = &errors[i];
      FLOAT *X = Gmap[perr->mapid]->site[0], *rawX;
      FLOAT newx = X[perr->R] - X[perr->L], oldx;
      double x = perr->x = newx;
      if(DEBUG>=2) assert(perr->x > 0.0);
      double y = perr->y;
      if(ENDFIX>=3 && perr->end && y >= x)
	continue;
      double var = A + B*y;
      if(QUADRATIC_VARIANCE)
	var += R*y*y;
      if(RES_VARIANCE)
	var += E * perr->resvar;
      if(DEBUG>=2) assert(var > 0.0);
      double Ivar = 1.0/var;
      double err = y - x;
      if(RESBIAS_TRACE>=2 && val==0.0){/* display per molecule statistics ( NOTE: must call qsort() before this parallel loop and reduced threads to 1) */
        int mapid = perr->mapid;
	if(mapid != lastid){
          LogCum += LogSum;
	  Errcum1 += Errsum1;
	  Errcum2 += Errsum2;
	  if(lastid >= 0){/* display values for mol lastid */
            printf("  mapid=%d(id=%lld):Lsum=%0.6f,errsum=%0.6f->%0.6f,LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
              lastid,Gmap[lastid]->id, -0.5*LogSum, -0.5*Errsum1, -0.5*Errsum2, -0.5*(LogSum+Errsum1), -0.5*(LogSum+Errsum2),-0.5*(Errsum2-Errsum1),
              -0.5*(LogCum + Errcum1), -0.5*(LogCum + Errcum2));
	    fflush(stdout);
          }
	  lastid = mapid;
	  LogSum = Errsum1 = Errsum2 = 0.0;
        }
	if(!(ENDFIX>=2 && perr->end)){
          LogSum += log(var) - logXtheta;
	  if(DEBUG){
            rawX = Gmap[perr->mapid]->rawsite[0];
	    oldx  = rawX[perr->R] - rawX[perr->L];
	    assert(fabs(oldx - perr->rawx) < 1e-6);
	  }
	}
	Errsum2 += err*err*Ivar;

#if REFDEBUG >= 1 || RESBIAS_DEBUG	       
	double err1 = y - perr->origx;
	Errsum1 += (RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2):err1*err1)*Ivar;// WAS148 err1*err1*Ivar;
	if(VERB>=2){
	  int M = Gmap[perr->mapid]->numsite[0];
	  /*	  if(!(ENDFIX>=2 && perr->end))
	    printf("    mapid=%d,L=%d,R=%d,end=%d:Lsum=%0.6f,errterm=%0.6f->%0.6f,LLsd=%0.6f->%0.6f(delta=%0.6f,cum=%0.6f -> %0.6f),x=%0.6f,y=%0.6f\n",
		   mapid,perr->L,perr->R,perr->end,-0.5*(log(var) - logXtheta), -0.5*err1*err1*Ivar, -0.5*err*err*Ivar,
		   -0.5*(log(var)-logXtheta + err1*err1*Ivar), -0.5*(log(var)-logXtheta + err*err*Ivar), -0.5*(err*err*Ivar - err1*err1*Ivar),
		   -0.5*(LogSum+Errsum1),-0.5*(LogSum+Errsum2), x, y);
	  else 
	    printf("    mapid=%d,L=%d,R=%d,end=%d:LLsd=%0.6f->%0.6f(delta=%0.6f,cum=%0.6f -> %0.6f),x=%0.6f,y=%0.6f, X[L]=%0.6f,X[R]=%0.6f,X[%d]=%0.6f\n",
		   mapid,perr->L,perr->R,perr->end, -0.5*err1*err1*Ivar, -0.5*err*err*Ivar, -0.5*(err*err*Ivar - err1*err1*Ivar),
		   -0.5*(LogSum+Errsum1),-0.5*(LogSum+Errsum2), x, y, X[perr->L], X[perr->R], M+1, X[M+1]);*/
	  if(!(ENDFIX>=2 && perr->end))
	    printf("    mapid=%d,L=%d,R=%d,end=%d:Lsum=%0.6f,errterm=%0.6f->%0.6f,LLsd=%0.6f->%0.6f(delta=%0.6f,cum=%0.6f -> %0.6f),x=%0.6f -> %0.6f,y=%0.6f\n",
                          mapid,perr->L,perr->R,perr->end,-0.5*(log(var) - logXtheta), 
                         (RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2) : err1*err1)*Ivar, (RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2):err*err)*Ivar,
	                  -0.5*(log(var)-logXtheta + (RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2):err1*err1)*Ivar),
	                  -0.5*(log(var)-logXtheta + (RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2) : err*err)*Ivar), 
	                  -0.5*(RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2)-min(err1*err1,perr->maxerr2) : err*err - err1*err1)*Ivar,
			 -0.5*(LogSum+Errsum1),-0.5*(LogSum+Errsum2), perr->origx, x, y);
	  else
	    printf("    mapid=%d,L=%d,R=%d,end=%d:errterm=%0.6f->%0.6f,LLsd=%0.6f->%0.6f(delta=%0.6f,cum=%0.6f -> %0.6f),x=%0.6f -> %0.6f,y=%0.6f, X[L]=%0.6f,X[R]=%0.6f,X[%d]=%0.6f\n",
                         mapid,perr->L,perr->R,perr->end,
	                 (RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2) : err1*err1)*Ivar, (RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2):err*err)*Ivar,
                         -0.5*(RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2) : err1*err1)*Ivar, -0.5*(RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2) : err*err)*Ivar,
	                 -0.5*(RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2)-min(err1*err1,perr->maxerr2) : err*err - err1*err1)*Ivar,
	                 -0.5*(LogSum+Errsum1),-0.5*(LogSum+Errsum2), perr->origx, x, y, X[perr->L], X[perr->R], M+1, X[M+1]);
	  fflush(stdout);
	}
#endif
      }
		
      double delta3;
      myerrsum3 += delta3 = RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2)*Ivar : err*err*Ivar;

      if((DEBUG>=2 && !(isfinite(err))) || (RESBIAS_TRACE>=2 && val==0.0)){
        #pragma omp critical
	{
	  int M = Gmap[perr->mapid]->numsite[0];
	  rawX = Gmap[perr->mapid]->rawsite[0];
#if REFDEBUG >= 1 || RESBIAS_DEBUG	       
	  double rawx = perr->rawx;
	  if(perr->end)// NEW9
            rawx = rawX[perr->R] - rawX[perr->L];
	  double err0 = y - rawx;
	  double err1 = y - perr->origx, delta1;	      
	  myerrsum0 += RESBIAS_MAXERR2 ? min(err0*err0,perr->maxerr2)*Ivar : err0*err0*Ivar;
	  myerrsum1 += delta1 = RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2)*Ivar : err1*err1*Ivar;
	  printf("i=%d/%d:mapid=%d,L=%d,R=%d,M=%d,end=%d:var=%0.6f,err0=%0.6f,err1=%0.6f,err3=%0.6f,maxerr=%0.6f(cum=%0.6f,%0.6f,%0.6f,del=%0.6f):rawx=%0.6f,x1=%0.6f,x3=%0.6f,y=%0.6f\n",
	      i,numerrors,perr->mapid,perr->L,perr->R,M,perr->end,var,err0,err1,err,sqrt(perr->maxerr2),myerrsum0,myerrsum1,myerrsum3, delta3-delta1, rawx, perr->origx, x,y);
#else
	  printf("i=%d/%d:mapid=%d,L=%d,R=%d,M=%d,end=%d:X[R]=%0.3f,X[L]=%0.3f,rawX[R]=%0.6f,rawX[L]=%0.6f:var=%0.6f,err3=%0.6f,maxerr=%0.6f(cum=%0.6f):rawx=%0.6f, x=%0.6f, y=%0.6f\n",
	      i,numerrors,perr->mapid,perr->L,perr->R,M,perr->end,X[perr->R],X[perr->L],rawX[perr->R],rawX[perr->L],var,err,sqrt(perr->maxerr2),myerrsum3, rawx, x,y);
#endif
	  if(!isfinite(err) || VERB>=2){
	    printf("mapid=%d,id=%lld\n",perr->mapid,Gmap[perr->mapid]->id);
	    for(int J = 1; J <= M+1; J++)
	      printf("J=%d:rawX[J]=%0.3f,X[J]=%0.3f\n",J,rawX[J],X[J]);
          }
	  fflush(stdout);

	  assert(isfinite(err));
        }
      }
      if(DEBUG>=2) assert(isfinite(myerrsum3));
    }
    if(VERB>=2 && WITH_RESBIAS && giter== 1 && lastid >= 0){/* display values for lastid */
      LogCum += LogSum;
      Errcum1 += Errsum1;
      Errcum2 += Errsum2;
      printf("  mapid=%d(id=%lld):Lsum=%0.6f,errsum=%0.6f->%0.6f,LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
	  lastid,Gmap[lastid]->id, -0.5*LogSum, -0.5*Errsum1, -0.5*Errsum2, -0.5*(LogSum+Errsum1), -0.5*(LogSum+Errsum2),-0.5*(Errsum2-Errsum1),
	  -0.5*(LogCum + Errcum1), -0.5*(LogCum + Errcum2));
      fflush(stdout);
    }

    Tarray3[tid] = myerrsum3;
  }

  for(int tid = 0; tid < numthreads; tid++)
    errsum3 += Tarray3[tid];

  if(RESBIAS_TRACE>=2 && val==0)
    qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorRawxInc);

  return errsum3;
}


/* sort by decreasing order of map size */
static int CmapSizeDec(register Cmap **p1, register Cmap **p2)
{
  register int M1 = p1[0]->numsite[0];
  register int M2 = p2[0]->numsite[0];
  register FLOAT *X1 = p1[0]->site[0];
  register FLOAT *X2 = p2[0]->site[0];
  register FLOAT size1 = X1[M1+1];
  register FLOAT size2 = X2[M2+1];
  return (size1 < size2) ? 1 : (size1 > size2) ? -1 : 0;
}

/* sort in increasing order of paired field */
static int CmapPairedInc(register Cmap **p1, register Cmap **p2)
{
  return p1[0]->paired - p2[0]->paired;
}

/* locate outlier size bin (always 0 if K < 2) : 
   bin = K : endoutlier bin : size range OutlierKB[bin] and above
   bin = 0 .. K - 1 : size range OutlierKB[bin .. bin+1]
   
   NOTE : OutlierKB[0] == extsplitOutlier and OutlierKB[K+1] == 9999.0
*/
static int findBin(double delta, int K, double *OutlierKB)
{
  if(DEBUG) assert(OutlierKB[0] <= delta && delta < OutlierKB[K+1]);

  if(K <= 0)
    return 0;

  int LB = 0;
  int UB = K+1;
  if(DEBUG>=2) assert(OutlierKB[LB] <= delta && delta < OutlierKB[UB]);

  while(UB > LB + 1){
    if(DEBUG>=2) assert(OutlierKB[LB] <= delta && delta < OutlierKB[UB]);

    int mid = (UB + LB) / 2;
    if(DEBUG>=2) assert(1 <= mid && mid <= K);

    if(delta >= OutlierKB[mid])
      LB = mid;
    else
      UB = mid;

    if(DEBUG>=2) assert(OutlierKB[LB] <= delta && delta < OutlierKB[UB]);
  }

  if(DEBUG) assert(UB == LB + 1);
  if(DEBUG>=2) assert(OutlierKB[LB] <= delta && delta < OutlierKB[LB+1]);

  return LB;
}

/* trim alignment down to p->sites2[tL .. tR] and update p->score, p->logPV and p->noutliers,maxoutlier,maxoutlierLabels */
static void AlignTrim(Calign *p, int tL, int tR, int N, int M, FLOAT *Y, FLOAT *X, FLOAT *Xrev)
{
  double scale = p->scaleID ? ScaleFactor[p->scaleID] : 1.0;	    

  int U = p->numpairs;
  Cmap *rmap = YYmap[p->mapid1];
  Cmap *nanomap = XXmap[p->mapid2];

  if(DEBUG) assert(tL <= 0 || tR >= U-1);/* only one side is trimmed */

  /* trim alignment down to p->sites2[tL .. tR] */
  if(tR < U-1){// trim right end 
    p->numpairs = U = tR+1;
    int I = p->sites1[U-1];
    int J = p->sites2[U-1];
    p->iscore[U] = p->outscore[U] = ChimScore;
    p->Rij1 = I;
    p->Rij2 = J;
    p->Rend = localtype;// new right endoutlier
#if CALIGN_END==0
    p->RijY = RijY(Y,X,I,J,N,M,p->orientation,scale);
    if(DEBUG/* HERE HERE >=2 */) assert(J <= M);
    p->RijX = RijX(Y,X,I,J,N,M,p->orientation,scale);
#endif
  } else if(tL > 0){// trim left end
    p->numpairs = U -= tL;
    for(int t = 0; t < U; t++){
      p->sites1[t] = p->sites1[t + tL];
      p->sitesK1[t] = p->sitesK1[t + tL];
      p->sites2[t] = p->sites2[t + tL];

      p->iscore[t+1] = p->iscore[t+1+tL];
      p->outscore[t+1] = p->outscore[t+1+tL];
    }
    p->Lend = localtype;// new left endoutlier
    int I = p->sites1[0];
    int K = p->sitesK1[0];
    int J = p->sites2[0];
    p->iscore[0] = p->outscore[0] = ChimScore + Sm(0,I,K,Y);
    p->Lij1 = I-K;
    p->Lij2 = J;
#if CALIGN_END==0
    p->LijY = LijY(Y,X,I-K,J,N,M,p->orientation);
    p->LijX = LijX(Y,X,I-K,J,N,M,p->orientation);
#endif
  }
  
  /* update p->score */
  p->score = 0;
  for(int t = 0; t <= U; t++)
    p->score += p->iscore[t];

  /* update p->logPV */
  if(DEBUG && !p->orientation) assert(Xrev == X);
  p->logPV = alignFP(p,Y,Xrev,N,M,p->orientation,p->mapid1,p->mapid2,p->score,0);

  /* update p->noutliers,maxoutlier,maxoutlierLabels */
  int orientation = p->orientation;// for debugging
  p->noutliers = 0;
  p->maxoutlier = 0.0;
  p->maxoutlierLabels = 0;
  int I,lastI = p->sites1[0];
  int K,lastK = p->sitesK1[0];
  int J,lastJ = p->sites2[0];
  for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
    I = p->sites1[t];
    K = p->sitesK1[t];
    J = p->sites2[t];
    if(p->outscore[t] + (FLOAT)0.01 < p->iscore[t]){
      p->noutliers++;
      FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
      FLOAT deltaX = (Xrev[J] - Xrev[lastJ]) * scale;
      if(DEBUG) assert(deltaX > 0.0);
      FLOAT delta = fabs(deltaY - deltaX);
      p->maxoutlier = max(delta, p->maxoutlier);
      p->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, p->maxoutlierLabels);
    }
    if(PVERB/* HERE HERE >=3 */){
      FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
      FLOAT deltaX = (Xrev[J] - Xrev[lastJ]) * scale;
      if(DEBUG) assert(deltaX > 0.0);
      FLOAT delta = fabs(deltaY - deltaX);
      printf(" t=%d/%d:iscore[t]= %0.6f, outscore[t]= %0.6f,I=%d..%d,K=%d..%d,J=%d..%d,delY=%0.3f,delX=%0.3f,delta=%0.3f:maxoutlier=%d,%0.3f,%d\n",
	     t,U,p->iscore[t],p->outscore[t],lastI,I,lastK,K,lastJ,J,deltaY,deltaX,delta,p->noutliers,p->maxoutlier,p->maxoutlierLabels);
      fflush(stdout);
    }
  }

  if(PVERB>=2){
    printf("AlignTrim:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,rev=%d,sc=%d:U=%d,score=%0.6f,logPV=%0.2f:maxoutlier=%d,%0.3f,%d\n",
	   p->mapid1,rmap->id,p->mapid2,nanomap->id,p->orientation,p->rev,p->scaleID,U,p->score,p->logPV,p->noutliers,p->maxoutlier,p->maxoutlierLabels);
    fflush(stdout);
  }

  if(DEBUG/* HERE HERE >=2 */) assert(p->noutliers >= 0 && p->maxoutlier >= 0.0 && p->maxoutlierLabels >= 0 &&
                                         (p->noutliers <= 0 || p->maxoutlier > 0.0 || p->maxoutlierLabels > 0));
}

int RAorigMultiMatches;
int RAorigRefSplit;
double RAorighashdeltaAdjust;
int RAorigHashBest;
double RAorigbiasWT;
int RAorigHashScore;
int RAorigNumResQ;
int RAorigHashMultiMatch;
int RAorigDeltaX;
int RAorigDeltaY;
int RAorigOutlierExtend;
int RAorigOutlierBC;

/** Top level align routine for reference mapping. Currently large function

Overview of routine.
 - Initialize density based penalty values.
 - Condition input: sort IDs, injest hash results, QC input maps,
 - Allocate memory corresponding to largest possible array.
 - Perform multithreaded alignments with refalignSD().
 - Accumulate statistics of all alignments.
 - Filter alignments based on PV and coverage criteria.
 - Refine contigs using refine().
 - Calculate error parameters.
*/

void refalign_allpairs(int& nummaps,
		       int& numrefmaps,
		       double *pSNRtotLL, /* If != 0 : return initial value of SNRtotLL() */
		       double *newPixelLen/* If != 0 and pSNRtotLL != 0 : return value of updated estimate of PixelLen (no actual parameters are updated) */
		       )
{

  if(VERB>=2){
    printf("refalign_allpairs:nummaps=%d,numrefmaps=%d,totalmaps=%d:Before score_init: cpu time=%0.6f, wall time=%0.6f\n",nummaps,numrefmaps,totalmaps,mtime(),wtime());
    fflush(stdout);
    dumpmemmap();
  }

  if(0){
    getmem(VmSize,VmRSS,VmSwap, &VmHWM);

    printf("At start of refalign_allpairs(): VmSize= %0.3f, VmRSS= %0.3f, VmSwap= %0.3f, VmHWM= %0.3f Gb\n",
	   VmSize * 1e-9, VmRSS * 1e-9, VmSwap * 1e-9, VmHWM * 1e-9);
    fflush(stdout);
  }

  if(extendSplit){
    if(extsplitMinWT < splitFiltMinWT){
      printf("WARNING: -extsplitMinWT %0.4e value must be at least as large as -splitFilt %0.4e (mWT) value : increasing -extsplitMinWT to %0.4e\n",
	     extsplitMinWT,splitFiltMinWT,splitFiltMinWT);
      fflush(stdout);
      extsplitMinWT = splitFiltMinWT;
    }
    if(splitFiltFN < extendSplitFN){
      printf("WARNING: -splitFilt N value (%d) must be at least equal to -extsplit N value (%d): changing -splitFilt N to %d\n",
	     splitFiltFN,extendSplitFN,extendSplitFN);
      fflush(stdout);
      splitFiltFN = extendSplitFN;
    }
    if(splitFiltFNlen < extendSplitFNlen){
      printf("WARNING: -splitFilt NL value (%0.3f) must be at least equal to -extsplit NL value (%0.3f): changing -splitFilt NL to %0.3f\n",
	     splitFiltFNlen,extendSplitFNlen,extendSplitFNlen);
      fflush(stdout);
      splitFiltFNlen = extendSplitFNlen;
    }
  }

  if(ExtsplitSpacingFix >= 2 && ExtsplitVerifyPeak){
    printf("Cannot use -extsplitSpacingFix 2 with -extsplitVerifyPeak 1 : Changing to -extsplitVerifyPeak 0\n");
    fflush(stdout);

    ExtsplitVerifyPeak = 0;
  }

  if(DEBUG && RefSplit && !MultiMatches){
    printf("Cannot use -RefSplit %0.2e %d %0.2e with -MultiMatches %d ..\n",Psplit,RefSplitMinLabels,Rsplit,MultiMatches);
    fflush(stdout);
    assert(!(RefSplit && !MultiMatches));
  }

  if(!MULTIMATCHES_MINMEM){
    printf("MULTIMATCHES_MINMEM=0 no longer supported : please recompile with MULTIMATCHES_MINMEM=1\n");
    fflush(stdout);exit(1);
  }
  if(MaxMem > 0){
    MaxMemSiz = (double)MaxMem * 1000.0 * 1000.0 * 1000.0;
    if(RA_MIN_TIME)
      MaxMemSiz2 = MaxMemSiz * 0.9;
  }
  vmemTotsiz = memTotsiz = 0;
  tm.tv_sec = floor(VMRSS_SLEEP);
  tm.tv_nsec = (VMRSS_SLEEP - tm.tv_sec) * 1e9;

  if(MultiMatches && MULTIMATCH_TRIM && biasWTend > 0.0){
    printf("WARNING: -MultiMatches is not implemented exactly for biaswtEnd > 0.0\n");
    fflush(stdout);
  }

  if(VERB>=2){
    printf("outlierExtend=%d\n",outlierExtend);
    fflush(stdout);
  }

  if(MultiMatches && SecondBest){
    printf("-SecondBest not supported with -MultiMatches\n");
    fflush(stdout);exit(1);
  }

  if(DEBUG && MultiMatches) assert(LogPvThreshold2 <= LogPvThreshold && ScoreThreshold2 <= ScoreThreshold);
  if(!FIX_OUTLIER_MIS){
    printf("FIX_OUTLIER_MIS==0 no longer supported\n");
    fflush(stdout);exit(1);
  }

  if(colors > 1){
    if(colors > 2){
      printf("refalign_allpairs: colors(=%d) > 2 not supported\n",colors);
      fflush(stdout);exit(1);
    }
    if(DEBUG) assert(!usecolor);
    return refalign_allpairs2(nummaps,numrefmaps,pSNRtotLL);
  }
  
  if(minSNRestimate && !MapSNR){
    printf("-minSNRestimate : Required SNR values in BNX input are missing\n");
    fflush(stdout);exit(1);
  }

  if (MultiMatches) {
    LogPvThreshold2 = min(LogPvThreshold,LogPvThreshold2);
    ScoreThreshold2 = min(ScoreThreshold,ScoreThreshold2);
  }

  DPsizF = (MultiMatches ? 3 : 2);/* number of RFLOAT rields in DP array */
  DPsizI = (MultiMatches ? 11 : 7);/* number of int fields in DP array */
  if(RepeatRec || MultiMatchesFilter >= 2)
    DPsizI += 1;/* A->shift shared by RepeatRec and MultiMatchesFilter */
  if(RepeatRec){
    DPsizF += 1;
    DPsizI += 3;
  }

  rs_heap = new lightweight_heap(0,0);

  if(!SIMPLE_BIAS){
    printf("SIMPLE_BIAS=0 no longer supported\n");
    fflush(stdout);exit(1);
  }
  if(VERB>=2){
    printf("outlierExtend=%d,outlierBC=%d\n",outlierExtend,outlierBC);
    fflush(stdout);
  }

  if(ScanCorrection > 0 && UniqueScans > 1 && nummaps < totalmaps && !(hash_filename || NoSplit == 2)){
    printf("-ScanCorrection with -subset is not support without EITHER -hash OR -nosplit 2\n");
    fflush(stdout);exit(1);
  }
  if(!(ScanCorrection > 0 && UniqueScans > 1))
    startmaps = totalmaps = nummaps;

  if(Refine && NoSplit != 2){
    printf("-refine %d not supported without -nosplit 2\n",Refine);
    fflush(stdout);exit(1);
  }
  if(Refine)
    startmaps = totalmaps = nummaps;

  if(usecolor && NoSplit != 2){/* HERE : remove to test with 2-color data and -usecolor 1 or -usecolor 2 */
    printf("-ref with 2 color -i input and -usecolor %d requires -nosplit 2\n", usecolor);
    fflush(stdout);exit(1);
  }

  if(!FLAT_MEMORY){
    printf("FLAT_MEMORY==0 no longer supported\n");
    fflush(stdout);exit(1);
  }

  if(!ALIGN_COMPRESS){
    printf("ALIGN_COMPRESS==0 no longer supported\n");
    fflush(stdout);exit(1);
  }

  if(!SCORE_ALLREF){
    printf("SCORE_ALLREF=0 no longer supported\n");
    fflush(stdout);exit(1);
  }

  if(!GOODMAPS){
    printf("GOODMAPS=0 no longer supported\n");
    fflush(stdout);exit(1);
  }

  if(PoutlierS != Poutlier && MapStitched){
    printf("WARNING:Seperate -outlier pvalue for stitched intervals not yet implmented: using same pvalue\n");
    fflush(stdout);
  }

  if(DEBUG) assert(startmaps == totalmaps);


  origScoreThreshold = ScoreThreshold;/* global to support REFDEBUG */
  origLogPvThreshold = LogPvThreshold;/* -T before adjustment by -TE (or -TS) */
  int origAlignedSiteThreshold = AlignedSiteThreshold;/* -A before adjustment by -AE (or -AS) */
  double origAlignedLengthThreshold = AlignedLengthThreshold;/* -L before adjustment by -LE (or -LS) */

  double origLogPvThreshold2 = LogPvThreshold2;/* -T2 before adjustment by -TE (or -TS) */
  int origAlignedSiteThreshold2 = AlignedSiteThreshold2;/* -A2 before adjustment by -AE (or -AS) */
  double origAlignedLengthThreshold2 = AlignedLengthThreshold2;/* -L2 before adjustment by -LE (or -LS) */

  double origLogPvThresholdTE = LogPvThresholdTE;/* -TE before adjustment by -TS */
  int origAlignedSiteThresholdE = AlignedSiteThresholdE;/* -AE before adjustment by -AS */
  double origAlignedLengthThresholdE = AlignedLengthThresholdE;/* -LE before adjustment by -LS */

  double origEndLen = EndLen;
  double origEndLen2 = EndLen2;
  double origMaxExtend = MaxExtend;

  if(REFDEBUG){
    if(!(origScoreThreshold <= -9999.0) || !(origLogPvThreshold <= 0.0) || !(AlignedSiteThreshold <= 2) || !(AlignedEndOutlierThreshold >= 2) || AlignedOutlierThreshold < 999.0 || AlignedLengthThreshold > 0.0 || extend || PoutlierEnd > 0 || (Ch > 0.0 && ChFdr > 0.0) || NoSplit != 2){
      printf("REFDEBUG requires -S -1e4 -T 1.0 -A 2 -E 2 -I 1000 -L 0 -extend 0 -endoutlier 0.0 -nosplit 2\n");
      printf("current values : -S %0.1f -T 1e%0.2f -A %d -E %d -I %0.1f -L %0.1f -extend %d -endoutlier %0.6f -nosplit %d\n",
	     origScoreThreshold, -origLogPvThreshold, AlignedSiteThreshold, AlignedEndOutlierThreshold, AlignedOutlierThreshold, AlignedLengthThreshold, extend, PoutlierEnd, NoSplit);
      fflush(stdout);
      fflush(stdout);exit(1);
    }
    if(REFDEBUG && MININTERVAL > 1e-5){
      printf("REFDEBUG requires -minEnd <= 0.00001 (current value %0.6f)\n",MININTERVAL);
      fflush(stdout);exit(1);
    }
    if(numrefmaps > 1 && !(BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0)){
      printf("REFDEBUG with multiple (%d) reference contigs requires -BestRef without ( -BestRefPV or -BestRefExt or -BestRefOutlier)\n", numrefmaps);
      printf("current values: BestRef=%d,BestRefPV=%d,BestRefExt=%0.3f,BestRefOutlier=%0.6e\n",BestRef,BestRefPV,BestRefExt,BestRefOutlier);
      fflush(stdout);exit(1);
    }
    if(hashdeltaAdjust > 0.0){
      printf("REFDEBUG not supported with -hashdelta %0.1f %0.1f (use one arg with -hashdelta)\n",hashdelta,hashdeltaAdjust);
      fflush(stdout);exit(1);
    }
    if(biasWT > 0.0){
      printf("REFDEBUG not supported with -biasWT %0.2f\n",biasWT);
      fflush(stdout);exit(1);
    }
  }

  if(!NoStat && biasWT > 0.0 && !(giter2 == RefRepeats2-1 && RefRepeats==1)){
    printf("WARNING: Error parameter estimation (AutoNoise) with -biasWT %0.2f is not reliable\n",biasWT);
    fflush(stdout);
  }

  if(VERB>=2){
    printf("refalign:nummaps=%d,totalmaps=%d,DIAGONAL=%d:start time=%0.6f(Elapsed=%0.6f),REFDEBUG=%d\n",nummaps,totalmaps,DIAGONAL,mtime(),wtime(),REFDEBUG);
    fflush(stdout);
  }

  long long origCMapID = CMapID;

  if(!ISLINEAR && isLinear){
    printf("isLinear=%d not supported (set ISLINEAR in constants.h)\n",isLinear);
    fflush(stdout);exit(1);
  }

  if(NEW != 2){
    printf("NEW != 2 no longer supported\n");
    fflush(stdout);exit(1);
  }

  if(NEW && Ch > PoutlierEnd){
    if(VERB){
      printf("Using -PoutlierEnd %0.6e due to -Ch\n", Ch);
      fflush(stdout);
    }
    PoutlierEnd = Ch;
  }

  if(DEBUG>=2 && (usecolor || colors >= 2)){
    for(int i= 0; i < nummaps; i++){
      Cmap *pmap = Gmap[i];
      FLOAT len1 = pmap->site[0][pmap->numsite[0]+1];
      FLOAT len2 = pmap->site[1][pmap->numsite[1]+1];
      if(!(fabs(len1 - len2) < 1e-3)){
	printf("refalign: Gmap[%d]: id=%lld, M1=%d,len1=%0.4f, M2=%d,len2=%0.4f\n",i, pmap->id, pmap->numsite[0], len1, pmap->numsite[1], len2);
	fflush(stdout);
	assert(fabs(len1 - len2) < 1e-3);
      }
    }
  }
  if(DEBUG>=2){
    for(int mapid = 0; mapid < nummaps; mapid++){
      if(!(Gmap[mapid]->mapid == mapid)){
	printf("mapid=%d:Gmap[mapid]=%p,Gmap[mapid]->mapid=%d,Gmap[mapid]->id=%lld\n",
	       mapid,Gmap[mapid],Gmap[mapid]->mapid,Gmap[mapid]->id);
	for(int m = 0; m < 10; m++)
	  printf("m=%d:Gmap[m]=%p,Gmap[m]->mapid=%d,Gmap[m]->id=%lld\n",
		 m,Gmap[m],Gmap[m]->mapid,Gmap[m]->id);
	fflush(stdout);
	assert(Gmap[mapid]->mapid == mapid);
      }
    }
  }

  if(DEBUG && REFSCORETYPE != 4){
    printf("REFSCORETYPE=%d not supported(must be 4)\n",REFSCORETYPE);
    fflush(stdout);exit(1);
  }

  if(numrefmaps <= 0){
    printf("refalign_allpairs: Insufficient data: nummaps=%d, numrefmaps=%d\n",nummaps,numrefmaps);
    fflush(stdout);exit(1);
  }

  if(NoStat && RefRepeats > 1){
    printf("Cannot use -nostat or -refine with -M %d\n", RefRepeats);
    fflush(stdout);exit(1);
  }

  double totlen = 0.0;
  for(int m = 0; m < nummaps; m++){
    Cmap *pmap = Gmap[m];
    int M = pmap->numsite[0];
    totlen += pmap->site[0][M+1];
  }
  double totreflen = 0.0;
  for(int m = 0; m < numrefmaps; m++){
    Cmap *pmap = refmap[m];
    int N = pmap->numsite[0];
    totreflen += pmap->site[0][N+1];
  }
  double CoverageMult = totlen/max(0.001,totreflen);
  if(totalmaps > nummaps){/* adjust for use of -subset */
    if(VERB){
      printf("Adjusting Coverage estimate for use of -subset : totalmaps=%d,nummaps=%d\n",totalmaps,nummaps);
      fflush(stdout);
    }
    CoverageMult *= totalmaps;
    CoverageMult /= nummaps;
  }

  int numthreads = 1;/* NOTE : inside the giter & refid loops local numthreads variables are used
			to customize numthreads to the current number iterations */
#ifdef _OPENMP
  numthreads = MaxThreads; // WAS omp_get_max_threads();
  //  numthreads = min(numthreads,MaxThreads);
#endif

  double *Tarray1 = new double[numthreads];
  double *Tarray2 = new double[numthreads];
  double *Tarray3 = new double[numthreads];
  double *Tarray4 = new double[numthreads];
  double *Tarray5 = new double[numthreads];
  double *Tarray6 = new double[numthreads];

  double *Narray = NULL;/* Narray[0..numaligns-1] is reallocated in each giter iteration */
  AlignStat *Sarray = NULL;/* Sarray[0..maxmapid - 1] is reallocated in each giter iteration */

  extern Cmap **YYmap,**XXmap;
  extern int numY,numX;
  numY = numrefmaps;
  YYmap = refmap;
  numX = nummaps;
  XXmap = Gmap;

  /* -ScanScaling variables */
  int ScanAligned = ((UniqueScans*3*sizeof(double) + THREAD_PADDING - 1) & (~(THREAD_PADDING-1)))/sizeof(double);
  if(DEBUG) assert(ScanAligned >= UniqueScans * 3);

  double *ThetaDelta=NULL,*Sxsum=NULL,*Sxysum=NULL,*Sxxsum=NULL,**Txy=NULL,**Txx=NULL,**Tx=NULL;
  double *Sscalesum=NULL,*Sscalesumsq=NULL,*Sscalewtsum=NULL;
  if(ScanCorrection){
    ThetaDelta = new double[UniqueScans*7];
    Sxsum = &ThetaDelta[UniqueScans];
    Sxysum = &ThetaDelta[UniqueScans*2];
    Sxxsum = &ThetaDelta[UniqueScans*3];
    Sscalesum = &ThetaDelta[UniqueScans*4];
    Sscalesumsq = &ThetaDelta[UniqueScans*5];
    Sscalewtsum = &ThetaDelta[UniqueScans*6];
    Txy = new double*[numthreads*3];
    Txx = &Txy[numthreads];
    Tx = &Txy[numthreads*2];

    for(int t = 0; t < numthreads; t++){
      double *mem = new double[ScanAligned];
      Txy[t] = mem;
      Txx[t] = &mem[UniqueScans];
      Tx[t] = &mem[UniqueScans*2];
    }
  }

  if(ScanCorrection && UniqueScans > 1 && NoSplit != 2){
    printf("-ScanCorrection only supported with -nosplit 2\n");
    fflush(stdout);exit(1);
  }

  int Imaxresbias = 0, *SizeToBin[MAXCOLOR] = {NULL,NULL};
  if(VERB>=2){
    printf("NoStat=%d,maxresbias=%0.3f,mres=%0.3f,parametersfile=%p\n",NoStat,maxresbias,mres,parametersfile);
    fflush(stdout);
  }
  if(!NoStat && maxresbias > mres * 0.5){/* initialize bias parameters */
    if(ScaleDelta && !ScaleDeltaBPP){
      printf("WARNING: -resbias with -ScaleDelta requires -ScaleDeltaBPP\n");
      if(REFDEBUG){
	fflush(stdout);
	exit(1);
      }
    }

    if(0 && !giter2 && (!parametersfile || !ResBinsFile)){
      /* default initialization of ResBins[] and resbiasX[] resbias[] is not done in RefAligner */
    }
    if(rawsitemaps < totalmaps){
      /* allocate (previously unallocated) rawsite[0] and copy site[0] values to it */
      /* NOTE : applied to all maps including -subset maps (if -ScanScaling) */
      rawsitealloc(Gmap,rawsitemaps,totalmaps);
      rawsitemaps = totalmaps;
    }

    if(BIAS_TRACE){
      for(int m = 0; m < totalmaps; m++){
	Cmap *pmap = Gmap[m];
	if(pmap->id != BIAS_TRACE_ID)
	  continue;
	for(int c = 0; c < (usecolor ? 2 : colors); c++){
	  printf("After rawsitealloc:pmap->id=%lld,c=%d,numsite[c]=%d:\n",pmap->id,c,pmap->numsite[c]);
	  for(int I = 0; I <= pmap->numsite[c] + 1; I++)
	    printf("  rawsite[c][%d]= %0.6f, site[c][%d]= %0.6f\n", I, pmap->rawsite[c][I], I, pmap->site[c][I]);
	}
	fflush(stdout);
      }
    }

    if(VERB>=2 && nummaps > 0){
      int *MM = Gmap[0]->numsite;
      printf("After Initializing bias parameters:Gmap[0]->numsite=MM={%d,%d},Gmap[0]->site[0][MM[0]+1]=%0.3f,Gmap[0]->site[1][MM[1]+1]=%0.3f,Gmap[0]->rawsite[0][MM[0]+1]=%0.3f,Gmap[0]->rawsite[1][MM[1]+1]=%0.3f\n",
	     MM[0],MM[1],Gmap[0]->site[0][MM[0]+1],Gmap[0]->site[1][MM[1]+1],Gmap[0]->rawsite[0][MM[0]+1],Gmap[0]->rawsite[1][MM[1]+1]);
      fflush(stdout);
    }

    if(DEBUG>=2 && (usecolor || colors >= 2) && (maxresbias > mres * 0.5 || ResBins[0] > 0)){
      for(int i= 0; i < totalmaps; i++){
	Cmap *pmap = Gmap[i];
	if((VERB>=2 && pmap->id == 1LL) || (DEBUG && !(fabs(pmap->rawsite[0][pmap->numsite[0]+1] - pmap->rawsite[1][pmap->numsite[1]+1]) < 1e-3))){
	  printf("Original rawsites for map id=%lld\n",pmap->id);
	  int origcolors = colors;
	  if(usecolor)
	    colors = 2;
	  for(int c = 0; c < colors; c++){
	    printf("numsite[%d]=%d\n",c,pmap->numsite[c]);
	    FLOAT *X = pmap->rawsite[c];
	    int M = pmap->numsite[c];
	    for(int j= 1; j <= M+1; j++)
	      printf("rawsite[%d][%d]= %0.8f\n",c,j,X[j]);
	  }
	  colors = origcolors;
	  fflush(stdout);
	}
	assert(fabs(pmap->rawsite[0][pmap->numsite[0]+1] - pmap->rawsite[1][pmap->numsite[1]+1]) < 1e-3);
      }
    }
  }

  if(DEBUG) assert(sizeof(RFLOAT) <= sizeof(FLOAT));

  if(VERB>=2){
    printf("PixelLen=%0.4f,origPixelLen=%0.4f\n",PixelLen,origPixelLen);
    fflush(stdout);
  }

  if(VERB>=2 && extend && !(ScoreThreshold >= 0.0 || LogPvThreshold >= 7.0 )){
    printf("WARNING:-ve score threshold=%e without -T 1e-7 (or better) not recommended with -extend (Since any nanomap can achieve a 0 score by extending the entire map beyond the reference)\n",ScoreThreshold);
    fflush(stdout);
  }

  if(VERB>=2){
    printf("MinFP=%0.6f,FP[0]=%0.6f,MinFN=%0.6f,FN[0]=%0.6f\n",MINFP,FP[0],MINFN,FN[0]);
    fflush(stdout);
  }

  /* adjust initial values based on bounds */
  if(FP[0] < MINFP){
    printf("FP=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",FP[0],MINFP,MAXFP,MINFP);
    FP[0] = MINFP;
  } else if(FP[0] > MAXFP){
    printf("FP=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",FP[0],MINFP,MAXFP,MAXFP);
    FP[0] = MAXFP;
  }
  if(FN[0] < MINFN){
    printf("FN=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",FN[0],MINFN,MAXFN,MINFN);
    FN[0] = MINFN;
  } else if(FN[0] > MAXFN){
    printf("FN=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",FN[0],MINFN,MAXFN,MAXFN);
    FN[0] = MAXFN;
  }
  if(SF[0] < max(0.0,MINSF)){
    printf("SF=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",SF[0],MINSF,MAXSF,MINSF);
    SF[0] = max(0.0,MINSF);
  } else if(SF[0] > MAXSF){
    printf("SF=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",SF[0],MINSF,MAXSF,MAXSF);
    SF[0] = MAXSF;
  }
  if(SD[0] < MINSD){
    printf("SD=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",SD[0],MINSD,MAXSD,MINSD);
    SD[0] = MINSD;
  } else if(SD[0] > MAXSD){
    printf("SD=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",SD[0],MINSD,MAXSD,MAXSD);
    SD[0] = MAXSD;
  }
  if(SR[0] < max(0.0,MINSR)){
    printf("SR=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",SR[0],MINSR,MAXSR,MINSR);
    SR[0] = max(0.0,MINSR);
  } else if(SR[0] > MAXSR){
    printf("SR=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",SR[0],MINSR,MAXSR,MAXSR);
    SR[0] = MAXSR;
  }
  if(SR[0] < 0.0){
    printf("ERROR:SD=%0.6f is not valid (must specify +ve sr)\n",SD[0]);
    fflush(stdout);exit(1);
  }
  if(SF[0] < 0.0){
    printf("ERROR:SF=%0.6f is not valid (must specify +ve sr)\n",SF[0]);
    fflush(stdout);exit(1);
  }
  if(SD[0] < -sqrt(2.0*SF[0]*SR[0]) * MINSD_MULT){
    printf("WARNING:SD=%0.6f is not valid for SF=%0.6f,SR=%0.6f: changing to %0.6f\n",SD[0],SF[0],SR[0],-sqrt(2.0*SF[0]*SR[0])*MINSD_MULT);
    fflush(stdout);
    assert(SR[0] >= 0.0);
    SD[0] = -sqrt(2.0*SF[0]*SR[0]) * MINSD_MULT;
  }
  if(SE[0] < MINSE){
    printf("SE=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",SE[0],MINSE,MAXSE,MINSE);
    SE[0] = MINSE;
  } else if(SE[0] > MAXSE){
    printf("SE=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",SE[0],MINSE,MAXSE,MAXSE);
    SE[0] = MAXSE;
  }
  if(res[0] < MinRes){
    printf("res=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",res[0],MinRes,MaxRes,MinRes);
    res[0] = MinRes;
  } else if(res[0] > MaxRes){
    printf("res=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",res[0],MinRes,MaxRes,MaxRes);
    res[0] = MaxRes;
  }
  if(resSD[0] < MinResSD){
    printf("resSD=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",resSD[0],MinResSD,MaxResSD,MinResSD);
    resSD[0] = MinResSD;
  } else if(resSD[0] > MaxResSD){
    printf("resSD=%0.6f is not in range [%0.6f .. %0.6f] : changing to %0.6f\n",resSD[0],MinResSD,MaxResSD,MaxResSD);
    resSD[0] = MaxResSD;
  }

  fflush(stdout);

  PRbias = 0.0;

  /* initialize pmap->nalign,align */
  for(int i= 0; i < nummaps; i++){
    Cmap *pmap = Gmap[i];
    pmap->align->reset();
    pmap->nalign->reset();
  }

  /* first check the average query and reference interval size to see if FP and FN are in the right ballpark */
  double rawtheta = 0.0;
  int rawXsites = 0;
  for(int i= 0; i < nummaps; i++){
    Cmap *pmap = Gmap[i];
    FLOAT *X = pmap->site[0];
    int N = pmap->numsite[0];
    rawtheta += X[N+1];
    rawXsites += N;
  }
  if(rawXsites > 0)
    rawtheta /= rawXsites;
  resKB = res[0] * PixelLen;
  double rawlambda = 0.0;
  int rawYsites = 0;
  for(int refid = 0;refid < numrefmaps;refid++){
    Cmap *rmap = refmap[refid];
    FLOAT *Y = rmap->site[0];
    int N = rmap->numsite[0];

    if(DEBUG/* HERE HERE >=2 */){
      assert(Y[0] == 0.0);
      for(int I = 1; I <= N+1; I++){
	if(!(Y[I] >= Y[I-1])){
	  printf("I=%d,N=%d,Y[I-1,I]=%0.4f,%0.4f,Y[N]=%0.4f,Y[N+1]=%0.4f\n",
		 I,N,Y[I-1],Y[I],Y[N],Y[N+1]);
	  fflush(stdout);
	  assert(Y[I] >= Y[I-1]);
	}
      }
    }

    for(int i = 1; i < N; i++){
      double y = Y[i+1] - Y[i];
      if(y > resKB){
	rawlambda += y;
	rawYsites++;
      }
    }
    /*    rawlambda += Y[N+1];
	  rawYsites += N;*/
  }
  if(rawYsites > 0)
    rawlambda /= rawYsites;
  if(rawXsites > 0 && rawYsites > 0){/* check if FP and FN need to be adjusted upwards */
    if(rawtheta < rawlambda*0.5){
      printf("WARNING:raw theta=%0.3f,lambda=%0.3f : theta is too small for a reasonable false positive rate\n",
	     rawtheta,rawlambda);
      fflush(stdout);
      //      exit(1);
    }
  }

  int maxthreads = 1;
  #ifdef _OPENMP
  maxthreads = MaxThreads; // WAS omp_get_max_threads();
  //  maxthreads = min(maxthreads,MaxThreads);
  #endif

  MaxPair = maxthreads * 1024 * (USE_MIC ? 8 : 16) + nummaps;
  if(VERB && (VERB/* HERE HERE >=2 */ || HASH_DEBUG)){
    printf("MaxPair=%d,maxthreads=%d,nummaps=%d\n",MaxPair,maxthreads,nummaps);
    fflush(stdout);
  }
  if(DEBUG) assert(MaxPair > 0);/* make sure it hasn't wrapped around 32 bit signed number */

  if(hash_filename){
#if HASH_STREAM < 2
    printf("HASH_STREAM=%d no longer supported (see hash.h)\n",HASH_STREAM);
    fflush(stdout);exit(1);
#endif

    if(idrenumbered && !HashGen){
      printf("hash table requires unique +ve id numbers for input Maps\n");
      fflush(stdout);exit(1);
    }
    if(NoSplit < 0){
      printf("hash table does not support -nosplit 0\n");
      fflush(stdout);exit(1);
    }

    if(TRACE && MAP_TRACE){
      for(int m = 0; m < nummaps; m++)
	if(Gmap[m]->id == MAP_TRACE)
	  printf("Gmap[%d]->id = %lld\n",m,Gmap[m]->id);
      fflush(stdout);
    }

    if(!HashGen){ /* sort maps by id in ascending order and renumber Ids */
      qsort(refmap,numrefmaps,sizeof(Cmap *),(intcmp*)CmapIdInc);
      qsort(Gmap,nummaps,sizeof(Cmap *),(intcmp*)CmapIdInc);
    
      for(int m = 0; m < nummaps; m++)
	Gmap[m]->mapid = m;
      for(int m = 0; m < numrefmaps; m++)
	refmap[m]->mapid = m;
    }

    if(DEBUG) assert(hashpairs1 == 0 && numhashpairs1 == 0);

    size_t L = strlen(hash_filename);
    if(L >= strlen(".hashbin") && !strcmp(&hash_filename[L-strlen(".hashbin")],".hashbin")){/* binary file input */
      BinaryFormat = 1;
      
      /* set up streaming hashtable IO */
      /* set up input buffers */
      size_t num = maxMatchesPerRefid + 1;// see hash.h
      if(DEBUG) assert(maxMapsPerRefid <= MASK(31));
      if((size_t)MaxPair < maxMapsPerRefid)
	MaxPair = maxMapsPerRefid;
      if((size_t)MaxPair > num)
	num = MaxPair;
      if(VERB/* HERE HERE >=2 */){
	printf("maxMatchesPerRefid=%lu, maxMapsPerRefid=%lu: num=%lu,MaxPair=%d\n",maxMatchesPerRefid,maxMapsPerRefid,num,MaxPair);
	fflush(stdout);
      }
      
      YidListMem = new int[MaxPair*4];
#if MSAN
      intptr_t test1 = __msan_test_shadow(YidListMem, MaxPair*4*sizeof(int));
      memset(YidListMem, 0, MaxPair*4*sizeof(int));// to shut up warnings about unitialized memory tied to this "new" allocation
      if(VERB>=2){
	intptr_t test2 = __msan_test_shadow(YidListMem, MaxPair*4*sizeof(int));
	printf("After Allocating YidListMem= %p : test1= %lld; After initializing YidListMem, test2= %lld (MaxPair=%d)\n",YidListMem, (long long) test1, (long long) test2, MaxPair);
	fflush(stdout);
      }
#endif

      YidList1 = &YidListMem[0];
      XidList1 = &YidListMem[MaxPair];
      phashListMem = new CHashMatch*[MaxPair*2];
      phashList1 = &phashListMem[0];
      NumPair1 = 0;

      YidList2 = &YidListMem[MaxPair*2];
      XidList2 = &YidListMem[MaxPair*3];
      phashList2 = &phashListMem[MaxPair];
      NumPair2 = 0;

      numhashpairs1 = maxhashpairs1 = 0;
      maxhashalloc(num+1,numhashpairs1,maxhashpairs1,hashpairs1);// Allocate one extra space so phash[1] for last phash == &hashpairs1[maxhashpairs1-1] is valid
      nexthash1 = hashpairs1;

      numhashpairs2 = maxhashpairs2 = 0;
      maxhashalloc(num+1,numhashpairs2,maxhashpairs2,hashpairs2);
      nexthash2 = hashpairs2;

      if(VERB>=2){
	long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
	getmem(VmSize,VmRSS, VmSwap, &VmHWM);

	printf("Allocated Hash Buffers:MaxPair=%d (%llu bytes for 2 buffers):VmSize= %0.4f,VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb\n",
	       MaxPair,(unsigned long long)(MaxPair*2*(sizeof(CHashMatch) + sizeof(int)*2+sizeof(CHashMatch*))), VmSize*1e-9,VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9);
	fflush(stdout);
      }

      // The Following hash_open() will be called before every -M iteration
      // MatchMax = hash_open(HashFP, hash_filename);

    } else {/* text format no longer supported */
      printf("refalign_allpairs:Text format Hashtable in %s not supported\n",hash_filename);
      fflush(stdout);exit(1);
    }
  } else {// no hashtable : allocate YidList1[],XidList1[]
    if(HashMultiMatch){
      printf("WARNING: -hashMultiMatch cannot be used without -hashgen : ignoring -hashMultiMatch\n");
      fflush(stdout);
      HashMultiMatch = 0;
    }
    if(hashdelta){
      printf("WARNING: -hashdelta cannot be used without -hashgen : ignoring -hashMultiMatch\n");
      fflush(stdout);
      hashdelta = hashdeltaAdjust = hashdeltaLim = 0.0;
    }

    YidListMem = new int[MaxPair * 2];
    YidList1 = &YidListMem[0];
    XidList1 = &YidListMem[MaxPair];
    NumPair1 = 0;
  }

  logLRsum = LARGE_NEGATIVE;
  logLRsdsum = LARGE_NEGATIVE;
  totXlen = LARGE_NEGATIVE;
  logLRarray = logSDarray = Xlen = NULL;

  if(RefRepeats < 1)
    RefRepeats = 1;

  if(DEBUG) assert(resSD[0] > 0.0);

  double resSDorig = resSD[0];

  Cparameters *parameters = new Cparameters[RefRepeats+1];
  memset(parameters, 0, (RefRepeats+1) * sizeof(Cparameters));// otherwise MSAN complains when structure is written to .errbin file

  int maxnumrefmaps = numrefmaps;
  numalign_start = new size_t[numrefmaps+1];
  numalign_end = new size_t[numrefmaps+1];
  orignummaps = new int[numrefmaps];

  double PixelLenSD = 0.0;

  if(Refine && (RefRepeats > 1 || RefRepeats2 > 1)){
    if(RefRepeats2 > 1)
      printf("-M %d %d not compatible with -refine %d\n",RefRepeats, RefRepeats2, Refine);
    else
      printf("-M %d not compatible with -refine %d\n",RefRepeats, Refine);
    fflush(stdout);exit(1);
  }

  maxN = 0;
  int kmax = 0;/* largest Kmax[I] value over all reference maps */
  int sumN = 0;
  for(int refid = 0; refid < numrefmaps; refid++){
    Cmap *rmap = refmap[refid];

    if(DEBUG) assert(rmap != 0);
    int N = rmap->numsite[0];
    sumN += N+1;
    if(N > maxN)
      maxN = N;
  }

  int revmult = (MultiMatches && MultiMatchesRev) ? 2 : 1;
  int **RKmax = new int*[numrefmaps*revmult];
  int *RKmem = new int[sumN*revmult];
#if MSAN
      intptr_t Rtest1 = __msan_test_shadow(RKmem, sumN*revmult*sizeof(int));
      memset(RKmem, 0, sumN*revmult*sizeof(int));// to shut up warnings about unitialized memory tied to this "new" allocation
      if(VERB>=2){
	intptr_t Rtest2 = __msan_test_shadow(RKmem, sumN*revmult*sizeof(int));
	printf("After Allocating RKmem= %p : Rtest1= %ld; After initializing RKmem, Rtest2= %ld (sumN=%d,revmult=%d)\n",RKmem,Rtest1,Rtest2,sumN,revmult);
	fflush(stdout);
      }
#endif

  double *coverage = NULL, *endoutlierL = NULL, *endoutlierR = NULL;
  int *endoutlierLi = NULL, *endoutlierRi = NULL;
  char *outlierLB = NULL, *outlierRB = NULL;
  size_t *endoutlierStartL = NULL, *endoutlierEndL = NULL;
  size_t *endoutlierStartR = NULL, *endoutlierEndR = NULL;

  double **endoutlierLm = new double* [MAX_KB_BINS*(1+EXTSPLIT_DELBIN) + EXTSPLIT_BALANCED*2];
  double **endoutlierRm = new double* [MAX_KB_BINS*(1+EXTSPLIT_DELBIN) + EXTSPLIT_BALANCED*2];
  int **endoutlierLim = new int* [MAX_KB_BINS*(1+EXTSPLIT_DELBIN) + EXTSPLIT_BALANCED*2];
  int **endoutlierRim = new int* [MAX_KB_BINS*(1+EXTSPLIT_DELBIN) + EXTSPLIT_BALANCED*2];
  char **outlierLBm = new char* [MAX_KB_BINS*(1+EXTSPLIT_DELBIN) + EXTSPLIT_BALANCED*2];
  char **outlierRBm = new char* [MAX_KB_BINS*(1+EXTSPLIT_DELBIN) + EXTSPLIT_BALANCED*2];

  int *SplitBinCnt = new int[MAX_KB_BINS*(1+EXTSPLIT_DELBIN) + EXTSPLIT_BALANCED];

  int KBend = max(0, KBcnt - 1);

  if(EXTSPLIT_DELBIN){/* index will run from -KBend ...,   0.. KBend-1, KBend (If EXTSPLIT_BALANCED index will extend to KBend+2, where index KBend+2 is used to keep track of endoutliers only) */
    endoutlierLm += MAX_KB_BINS;
    endoutlierRm += MAX_KB_BINS;
    endoutlierLim += MAX_KB_BINS;
    endoutlierRim += MAX_KB_BINS;
    outlierLBm += MAX_KB_BINS;
    outlierRBm += MAX_KB_BINS;

    SplitBinCnt += MAX_KB_BINS;
  }

  if(extendSplit){
    coverage = new double[(1 + 2*(1+EXTSPLIT_BALANCED*2+KBend*(1+EXTSPLIT_DELBIN)))*(maxN+2)];
    endoutlierL = &coverage[maxN+2];
    endoutlierR = &coverage[2*(maxN+2)];
    endoutlierLi = new int[2*(maxN+2)*(1+EXTSPLIT_BALANCED*2+KBend*(1+EXTSPLIT_DELBIN))];
    endoutlierRi = &endoutlierLi[maxN+2];
    if(DEBUG && KBcnt > 0) assert(KBcnt <= MAX_KB_BINS && KBcnt >= 2 && extsplitOutlier > 0.0);

    if(EXTSPLIT_RANGE){
      endoutlierStartL = new size_t[4*(maxN+2)];
      endoutlierStartR = &endoutlierStartL[(maxN+2)];
      endoutlierEndL = &endoutlierStartL[2*(maxN+2)];
      endoutlierEndR = &endoutlierStartL[3*(maxN+2)];
    }

    if(extsplitOutlier > 0.0){
      outlierLB = new char[2*(maxN+1)*(1+EXTSPLIT_BALANCED*2+KBend*(1+EXTSPLIT_DELBIN))];
      outlierRB = &outlierLB[maxN+1];
      
      int offset = 1+EXTSPLIT_BALANCED*2+KBend;

      for(int k = 0; k < KBcnt-1; k++){
	endoutlierLm[k] = &endoutlierL[2*(maxN+2)*(1+k)];
	endoutlierRm[k] = &endoutlierR[2*(maxN+2)*(1+k)];
	endoutlierLim[k] = &endoutlierLi[2*(maxN+2)*(1+k)];
	endoutlierRim[k] = &endoutlierRi[2*(maxN+2)*(1+k)];
	outlierLBm[k] = &outlierLB[2*(maxN+1)*(1+k)];
	outlierRBm[k] = &outlierRB[2*(maxN+1)*(1+k)];
	if(EXTSPLIT_DELBIN){
	  endoutlierLm[-1-k] = &endoutlierL[2*(maxN+2)*(k + offset)];
	  endoutlierRm[-1-k] = &endoutlierR[2*(maxN+2)*(k + offset)];
	  endoutlierLim[-1-k] = &endoutlierLi[2*(maxN+2)*(k + offset)];
	  endoutlierRim[-1-k] = &endoutlierRi[2*(maxN+2)*(k + offset)];
	  outlierLBm[-1-k] = &outlierLB[2*(maxN+1)*(k + offset)];
	  outlierRBm[-1-k] = &outlierRB[2*(maxN+1)*(k + offset)];
	}
      }

      outlierLBm[KBend] = outlierLB;
      outlierRBm[KBend] = outlierRB;

      if(EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000){
	for(int k = KBend+1; k <= KBend+2; k++){
	  endoutlierLm[k] = &endoutlierL[2*(maxN+2)*k];
	  endoutlierRm[k] = &endoutlierR[2*(maxN+2)*k];
	  endoutlierLim[k] = &endoutlierLi[2*(maxN+2)*k];
	  endoutlierRim[k] = &endoutlierRi[2*(maxN+2)*k];
	  outlierLBm[k] = &outlierLB[2*(maxN+1)*k];
	  outlierRBm[k] = &outlierRB[2*(maxN+1)*k];
	}
      }
    }
    endoutlierLm[KBend] = endoutlierL;
    endoutlierRm[KBend] = endoutlierR;
    endoutlierLim[KBend] = endoutlierLi;
    endoutlierRim[KBend] = endoutlierRi;
  }
  double *extsplitExtOnly = NULL;

  /* NOTE: since res & resSD can change, the following computation of maxdist,AlignResMax and Kmax[] should be repeated before each score_init() */
  double maxdist,AlignResMax;

  if(1 /* WAS10 !(ResEstimate && !REFDEBUG_STRICT) */){
    maxdist = (res[0] + SDrange * resSD[0])*PixelLen;
    AlignResMax = maxdist * AlignResMult;

    FLOAT *Yrev = 0;
    if(MultiMatches && MultiMatchesRev)
      Yrev = new FLOAT[maxN+2];

    int cntN = 0;
    long long ksum = 0, Nsum = 0;
    for(int refid = 0; refid < numrefmaps; refid++){
      Cmap *rmap = refmap[refid];
      FLOAT *Y = rmap->site[0];
      int N = rmap->numsite[0];

      if(DEBUG>=2){/* check that site Y[0..N+1] are monotonic */
	for(int I = 0; I <= N; I++)
	  if(DEBUG && !(Y[I+1] >= Y[I])){
	    printf("refid=%d(id=%lld):I=%d,N=%d:Y[I]=%0.8f,Y[I+1]=%0.8f\n",refid,rmap->id,I,N,Y[I],Y[I+1]);
	    fflush(stdout);
	    assert(Y[I+1] >= Y[I]);
	  }
      }

      int *Kmax = RKmax[refid] = &RKmem[cntN];   cntN += N+1;

      int KMAX_APPROX = (SCORE_APPROX >= (AlignRes ? 2 : 1) || AlignResMult <= 1.0) ? 1 : 0;// NEW

      for(int I = 1; I <= N; I++){
	int K = 0;
	if(KMAX_APPROX /* NEW */){/* determine Kmax[I] based on total distance Y[I] - Y[I-K] < maxdist */
	  while(I-K > 1){
	    if(Y[I] - Y[I-K-1] >= maxdist)
	      break;
	    K++;
	  }
	} else {
	  while(I-K > 1){
	    if((!KMAX_FIX && Y[I-K] - Y[I-K-1] >= maxdist) || Y[I]-Y[I-K-1] >= AlignResMax)
	      break;
	    K++;
	  }
	}
	if(K > KMAX){
	  if(VERB >= 2){
	    printf("Kmax[%d]=%d(reducing to %d):res=%0.3f,resSD=%0.3f:",I,Kmax[I],KMAX, res[0],resSD[0]);
	    for(int U = 0; U <= K; U++)
	      printf("Y[%d]=%0.3f,",I-U,Y[I-U]);
	    printf("\n");
	  }
	  K = KMAX;
	}
	Kmax[I] = K;
	if((DEBUG>=2 && resSD[0] <= 0.001 && Kmax[I]>=2) ||(TRACE>=2 && REF_TRACE == rmap->id && Kmax[I])){
	  printf("refid=%d(id=%lld):Kmax[%d]=%d:res=%0.3f,resSD=%0.3f:",refid,rmap->id,I,Kmax[I],res[0],resSD[0]);
	  for(int U = 0; U <= K; U++)
	    printf("Y[%d]=%0.3f,",I-U,Y[I-U]);
	  printf("\n");
	}
      }

      for(int I = 1; I <= N; I++){
	ksum += Kmax[I];
	if(Kmax[I] > kmax)
	  kmax = Kmax[I];
      }
      Nsum += N;

      if(MultiMatches && MultiMatchesRev){
	for(int I = 0; I <= N+1; I++)
	  Yrev[I] = Y[N+1] - Y[N+1 - I];
	Y = Yrev;

	int *Kmax = RKmax[refid + numrefmaps] = &RKmem[cntN];   cntN += N+1;
	
	for(int I = 1; I <= N; I++){
	  int K = 0;
	  if(KMAX_APPROX /* NEW */){/* determine Kmax[I] based on total distance Y[I] - Y[I-K] < maxdist */
	    while(I-K > 1){
	      if(Y[I] - Y[I-K-1] >= maxdist)
		break;
	      K++;
	    }
	  } else {
	    while(I-K > 1){
	      if((!KMAX_FIX && Y[I-K] - Y[I-K-1] >= maxdist) || Y[I]-Y[I-K-1] >= AlignResMax)
		break;
	      K++;
	    }
	  }
	  if(K > KMAX){
	    if(VERB >= 2){
	      printf("Kmax[%d]=%d(reducing to %d):res=%0.3f,resSD=%0.3f:",I,Kmax[I],KMAX, res[0],resSD[0]);
	      for(int U = 0; U <= K; U++)
		printf("Y[%d]=%0.3f,",I-U,Y[I-U]);
	      printf("\n");
	    }
	    K = KMAX;
	  }
	  Kmax[I] = K;
	  if((DEBUG>=2 && resSD[0] <= 0.001 && Kmax[I]>=2) ||(TRACE>=2 && REF_TRACE == rmap->id && Kmax[I])){
	    printf("refid=%d(id=%lld):Kmax[%d]=%d:res=%0.3f,resSD=%0.3f:",refid,rmap->id,I,Kmax[I],res[0],resSD[0]);
	    for(int U = 0; U <= K; U++)
	      printf("Y[%d]=%0.3f,",I-U,Y[I-U]);
	    printf("\n");
	  }
	}
      }
    }
    if(DEBUG) assert(cntN <= sumN * revmult);
    if(VERB){
      printf("kmax=%d,average Kmax[I]=%0.3f\n",
	     kmax, ((double) ksum)/Nsum);
      fflush(stdout);
    }
    if(MultiMatches && MultiMatchesRev)
      delete [] Yrev;
    
    if(VERB>=2){
      printf("Initialized RKmax[0..%d] : sumN=%d, revmult=%d, cntN=%d : RKmax= %p, RKmem= %p, RKmax[0]= %p\n",numrefmaps-1,sumN, revmult, cntN, RKmax, RKmem, RKmax[0]);
      fflush(stdout);
    }
  }

  parameters[0].FPfrac[0] = 0.0;

  if(extendSplit){/* use -TS -AS -LS values */
    if(LogPvThresholdTS < LogPvThresholdTE){
      if(VERB){
	printf("Updating : LogPvThresholdTE = %0.2f -> %0.2f (due to -TS)\n", LogPvThresholdTE,LogPvThresholdTS);
	fflush(stdout);
      }
      LogPvThresholdTE = LogPvThresholdTS;
    }
    if(AlignedSiteThresholdS < AlignedSiteThresholdE){
      if(VERB){
	printf("Updating : -AE from %d to %d (due to -AS)\n",AlignedSiteThresholdE,AlignedSiteThresholdS);
	fflush(stdout);
      }
      AlignedSiteThresholdE = AlignedSiteThresholdS;
    }
    if(AlignedLengthThresholdS < AlignedLengthThresholdE){
      if(VERB){
	printf("Updating : -LE from %0.2f to %0.2f (due to -LS)\n",AlignedLengthThresholdE,AlignedLengthThresholdS);
	fflush(stdout);
      }
      AlignedLengthThresholdE = AlignedLengthThresholdS;
    }
  }

  if(LogPvThresholdTE < LogPvThreshold){
    if(VERB){
      printf("Updating : LogPvThreshold = %0.2f -> %0.2f, LogPvThreshold2 = %0.2f -> %0.2f (due to -TE)\n",
	     LogPvThreshold,LogPvThresholdTE,LogPvThreshold2,min(LogPvThreshold,LogPvThresholdTE));
      fflush(stdout);
    }
    LogPvThreshold = LogPvThresholdTE;
    if(MultiMatches)
      LogPvThreshold2 = min(LogPvThreshold2, LogPvThreshold);
  }
  if(AlignedSiteThresholdE < AlignedSiteThreshold){
    if(VERB){
      printf("Updating : -A from %d to %d, -A2 from %d to %d (due to -AE)\n",
	     AlignedSiteThreshold,AlignedSiteThresholdE,AlignedSiteThreshold2,min(AlignedSiteThreshold2, AlignedSiteThresholdE/* NEW153 */));
      fflush(stdout);
    }
    AlignedSiteThreshold = AlignedSiteThresholdE;
    if(MultiMatches)
      AlignedSiteThreshold2 = min(AlignedSiteThreshold2, AlignedSiteThresholdE/* NEW153 */);
  }
  if(AlignedLengthThresholdE < AlignedLengthThreshold){
    if(VERB){
      printf("Updating : -L from %0.2f to %0.2f, -L2 from %0.2f to %0.2f (due to -LE)\n",
	     AlignedLengthThreshold,AlignedLengthThresholdE,AlignedLengthThreshold2,min(AlignedLengthThreshold2, AlignedLengthThresholdE/* NEW153 */));
      fflush(stdout);
    }
    AlignedLengthThreshold = AlignedLengthThresholdE;
    if(MultiMatches)
      AlignedLengthThreshold2 = min(AlignedLengthThreshold2, AlignedLengthThresholdE/* NEW153 */);
  }

  //  double origLogPvThreshold2 = LogPvThreshold;// save original threshold with -TE
  //  double origScoreThreshold2 = ScoreThreshold;// currently the same as origScoreThreshold

  int NumScaleFactor2 = 1 + 2*MapScaleDelta;
  int *scaleIDcnt = new int[max(NumScaleFactor2,NumScaleFactor)];

  int origDELTA_X = DELTA_X;
  int origDELTA_Y = DELTA_Y;
  int origoutlierExtend = outlierExtend;

  origMapScale = 0;/* If query maps were rescaled */

  if(giter2 == RefRepeats2/* WAS29 RefRepeats*/ - 1 && RefRepeats > 1){
    if(VERB){
      if(MultiMatches)
	printf("Changing -MultiMatches from %d to 0\n",MultiMatches);
      if(HashBest >= 0 && HashMultiMatchMaxDelta > 0 && HashBest != HashMultiMatchMaxDelta)
	printf("Changing -hashbest from %d to %d\n",HashBest,HashMultiMatchMaxDelta);
      if(biasWT > 0 && maptype==1/* NEW29 */)
	printf("Changing -biasWT %0.3f to 0\n", biasWT);
    }
    MultiMatches = 0;
    if(HashBest >= 0 && HashMultiMatchMaxDelta > 0)
      HashBest = HashMultiMatchMaxDelta;
    if(maptype==1)/* NEW29 */
      biasWT = 0.0;
  }

  // NEW143 : moved start* value initialization of giter loop
  double startLogPvThreshold = LogPvThreshold;// save original -T threshold with -TE & -TS adjustments
  int startAlignedSiteThreshold = AlignedSiteThreshold;// save original -A threshold with -AE & -AS adjustments
  double startAlignedLengthThreshold = AlignedLengthThreshold;// save original -L threshold with -LE & -LS adjustments
  double startScoreThreshold = ScoreThreshold;// currently the same as origScoreThreshold
  
  double startLogPvThreshold2 = LogPvThreshold2;// save original -T2 threshold with -TE & -TS adjustments
  int startAlignedSiteThreshold2 = AlignedSiteThreshold2;// save original -A2 threshold with -AE & -AS adjustments
  double startAlignedLengthThreshold2 = AlignedLengthThreshold2;// save original -L2 threshold with -LE & -LS adjustments

  double startLogPvThresholdTE = LogPvThresholdTE;// save original -TE threshold with -TS adjustments
  int startAlignedSiteThresholdE = AlignedSiteThresholdE;// save original -AE threshold with -AS adjustments
  double startAlignedLengthThresholdE = AlignedLengthThresholdE;// save original -LE threshold with -LS adjustments

  pid_t *child_pid = NULL;
  int numchild = 0;

  for(giter = 0; giter < RefRepeats; giter++){
    LogPvThreshold = startLogPvThreshold;
    AlignedSiteThreshold = startAlignedSiteThreshold;
    AlignedLengthThreshold = startAlignedLengthThreshold;
    ScoreThreshold = startScoreThreshold;
    
    LogPvThreshold2 = startLogPvThreshold2;
    AlignedSiteThreshold2 = startAlignedSiteThreshold2;
    AlignedLengthThreshold2 = startAlignedLengthThreshold2;

    LogPvThresholdTE = startLogPvThresholdTE;
    AlignedSiteThresholdE = startAlignedSiteThresholdE;
    AlignedLengthThresholdE = startAlignedLengthThresholdE;

    if(DEBUG && RefSplit && !MultiMatches){
      printf("giter=%d:Cannot use -RefSplit %0.2e %d %0.2e with -MultiMatches %d ..\n",giter,Psplit,RefSplitMinLabels,Rsplit,MultiMatches);
      fflush(stdout);
      assert(!(RefSplit && !MultiMatches));
    }

    int origBestRef = BestRef;
    int origBestRefWT = BestRefWT;
    int origMultiMatches = MultiMatches;
    int origRefSplit = RefSplit;
    double MSorigLogPvThreshold = LogPvThreshold;
    double MSorigScoreThreshold = ScoreThreshold;
    double MSorigAlignedLengthThreshold = AlignedLengthThreshold;
    int MSorigAlignedSiteThreshold = AlignedSiteThreshold;
    int origScaleDelta = ScaleDelta;
    double origScaleDeltaSize = ScaleDeltaSize;
    int origScaleDeltaBPP = ScaleDeltaBPP;
    double orighashdeltaAdjust = hashdeltaAdjust;

    if(MapScale && giter==0 && !origMapScale && !pSNRtotLL){/* for initial alignment lower threshold, since alignment before Scaling will be worse than after Scaling */
      if(VERB){
	printf("MapScale : Reducing -T(%0.2f -> %0.2f) -S %0.2f to %0.2f  -L %0.2f to %0.2f  -A %d to %d and disabling -MultiMatches and forcing -BestRef 1 -BestRefWT 0 -RefSplit 0 during preliminary iteration\n",
	       LogPvThreshold, LogPvThreshold - 3.0, ScoreThreshold, -9.0, AlignedLengthThreshold, AlignedLengthThreshold*0.5, AlignedSiteThreshold, max(2, AlignedSiteThreshold/2));
	fflush(stdout);
      }

      BestRef = 1;
      BestRefWT = 0;
      MultiMatches = 0;
      RefSplit = 0;
      LogPvThreshold -= 3.0;
      ScoreThreshold = -9.0;
      AlignedLengthThreshold *= 0.5;
      AlignedSiteThreshold = max(2, AlignedSiteThreshold/2);
    
      if(hashdeltaAdjust > 0.0 && hashdeltaLim > hashdelta){
	if(VERB){
	  printf("MapScale : changing -hashdelta %0.1f %0.1f %0.1f to -hashdelta %0.1f during preliminary iteration\n",hashdelta,hashdeltaAdjust, hashdeltaLim,hashdelta);
	  fflush(stdout);
	}
	hashdeltaAdjust = 0.0;
      }

      if(MapScaleDelta > 0 && (!ScaleDelta || (giter2 == RefRepeats2 -1 && giter == RefRepeats-1) || ScaleDeltaSize * ScaleDelta < MapScaleDeltaSize * MapScaleDelta)){
	if(VERB){
	  if(!ScaleDelta)
	    printf("MapScale : Adding -ScaleDelta %0.3f %d during preliminary iteration\n", MapScaleDeltaSize,MapScaleDelta);
	  else
	    printf("MapScale : Changing -ScaleDelta %0.3f %d to -ScaleDelta %0.3f %d during preliminary iteration\n",ScaleDeltaSize,ScaleDelta,MapScaleDeltaSize,MapScaleDelta);
	  fflush(stdout);
	}
	ScaleDelta = MapScaleDelta;
	ScaleDeltaSize = MapScaleDeltaSize;
	ScaleDeltaBPP = 1;
	NumScaleFactor = 1 + 2 * ScaleDelta;
	if(ScaleDelta > 0){
	  for(int i = 1; i <= ScaleDelta; i++){
	    double scale = 1.0 + i * ScaleDeltaSize;
	    ScaleFactor[2*i-1] = scale;
	    ScaleFactor[2*i] = 1.0/scale;
	  }
	}
      }
    }

    if(giter2 == RefRepeats2 - 1 && giter == RefRepeats - 1 && !(MapScale && giter==0 && !origMapScale)){
      if(VERB){
	if(MultiMatches != RAorigMultiMatches)
	  printf("giter=%d,%d/%d,%d: Changing -MultiMatches from %d to %d\n",giter, giter2, RefRepeats, RefRepeats2, MultiMatches, RAorigMultiMatches);
	if(RefSplit != RAorigRefSplit)
	  printf("giter=%d,%d/%d,%d: Changing -RefSplit from %d to %d\n",giter, giter2, RefRepeats, RefRepeats2, RefSplit, RAorigRefSplit);
	if(hashdeltaAdjust != RAorighashdeltaAdjust)
	  printf("giter=%d,%d/%d,%d: Changing -hashdelta %0.1f to -hashdelta %0.1f %0.1f %0.1f\n",giter,giter2, RefRepeats,RefRepeats2, hashdelta,hashdelta,RAorighashdeltaAdjust,hashdeltaLim);
	if(HashBest != RAorigHashBest)
	  printf("giter=%d,%d/%d,%d: Changing -hashbest from %d to %d\n",giter, giter2, RefRepeats, RefRepeats2,HashBest,RAorigHashBest);
        if(biasWT != RAorigbiasWT)
	  printf("giter=%d,%d/%d,%d: Changing -biaswt from %0.3f to %0.3f\n",giter, giter2, RefRepeats, RefRepeats2, biasWT, RAorigbiasWT);
	if(HashScore != RAorigHashScore)
	  printf("giter=%d,%d/%d,%d: Changing -hashgen 2nd arg (hashscore) from %d to %d\n",giter,giter2,RefRepeats,RefRepeats2,HashScore,RAorigHashScore);
	if(NumResQ != RAorigNumResQ)
	  printf("giter=%d,%d/%d,%d: Changing -hashgen last arg (NumResQ) from %d to %d\n",giter,giter2,RefRepeats,RefRepeats2,NumResQ, RAorigNumResQ);
	if(HashMultiMatch != RAorigHashMultiMatch)
	  printf("giter=%d,%d/%d,%d: Changing -hashMultiMatch from %d to %d\n",giter,giter2,RefRepeats,RefRepeats2,HashMultiMatch, RAorigHashMultiMatch);
	if(DELTA_X != RAorigDeltaX)
	  printf("giter=%d,%d/%d,%d: Changing -deltaX from %d to %d\n",giter,giter2,RefRepeats,RefRepeats2,DELTA_X, RAorigDeltaX);
	if(DELTA_Y != RAorigDeltaY)
	  printf("giter=%d,%d/%d,%d: Changing -deltaY from %d to %d\n",giter,giter2,RefRepeats,RefRepeats2,DELTA_Y, RAorigDeltaY);
	if(outlierExtend != RAorigOutlierExtend)
	  printf("giter=%d,%d/%d,%d: Changing -OutlierExtend from %d to %d\n",giter,giter2,RefRepeats,RefRepeats2,outlierExtend, RAorigOutlierExtend);
	if(outlierBC != RAorigOutlierBC)
	  printf("giter=%d,%d/%d,%d: Changing -OutlierBC from %d to %d\n",giter,giter2,RefRepeats,RefRepeats2,outlierBC, RAorigOutlierBC);
      }
      MultiMatches = RAorigMultiMatches;
      RefSplit = RAorigRefSplit;
      hashdeltaAdjust = RAorighashdeltaAdjust;
      HashBest = RAorigHashBest;
      biasWT = RAorigbiasWT;
      HashScore = RAorigHashScore;
      NumResQ = RAorigNumResQ;
      HashMultiMatch = RAorigHashMultiMatch;
      DELTA_X = RAorigDeltaX;
      DELTA_Y = RAorigDeltaY;
      outlierExtend = RAorigOutlierExtend;
      outlierBC = RAorigOutlierBC;

      if(relaxBnds){
	if(VERB){
	  printf("Removing bounds on FN,FP,SF,SD,SR except for MinSD = %0.4f\n",MinSD);
	  fflush(stdout);
	}
	MinFP = 0.01;
	MaxFP = max(4.0, MaxFP);
	MinFN = 0.001;
	MaxFN = max(0.40, MaxFN);
	MinSF = 0.001;
	MaxSF = max(1.000, MaxSF);
	MaxSD = max(0.50, MaxSD);
	MinSR = 0.00;
	MaxSR = max(0.50, MaxSR);
	MinSE = 0.01;
	MaxSE = 0.50;
	MinRes = 0.01;
	MaxRes = 9.99;
	MinResSD = 0.01;
	MaxResSD = 9.99;
      }
    }

    if(DEBUG && MultiMatches) assert(LogPvThreshold2 <= LogPvThreshold);
    if(DEBUG && MultiMatches) assert(AlignedSiteThreshold2 <= AlignedSiteThreshold);
    if(DEBUG && MultiMatches) assert(AlignedLengthThreshold2 <= AlignedLengthThreshold);

    /* NOTE : if NoSplit < 2, each iterations will create a seperate set of map splits that accumulate at the end of Gmap[startmaps ... totalmaps-1] */

    DELTA_X = origDELTA_X;
    DELTA_Y = origDELTA_Y;
    outlierExtend = origoutlierExtend;
    if(giter2 < RefRepeats2 - 1 || giter < RefRepeats - 1){
      if(DELTA_X2 > 0)
	DELTA_X = DELTA_X2;
      if(DELTA_Y2 > 0)
	DELTA_Y = DELTA_Y2;
      if(DELTA_X < origDELTA_X || DELTA_Y < origDELTA_Y)
	outlierExtend = 0;
      if(VERB>=2){
	printf("giter=%d,%d: deltaX = %d -> %d, deltaY = %d -> %d, outlierExtend = %d -> %d\n",
	       giter,giter2, origDELTA_X,DELTA_X,origDELTA_Y,DELTA_Y,origoutlierExtend,outlierExtend);
	fflush(stdout);
      }
    }

    if(DEBUG>=2) assert(colors==1);

    if(DEBUG>=2){
      for(int mapid = 0; mapid < nummaps; mapid++){
        if(!(Gmap[mapid]->mapid == mapid)){
 	  printf("mapid=%d:Gmap[mapid]=%p,Gmap[mapid]->mapid=%d,Gmap[mapid]->id=%lld\n",
		mapid,Gmap[mapid],Gmap[mapid]->mapid,Gmap[mapid]->id);
	  for(int m = 0; m < 10; m++)
	    printf("m=%d:Gmap[m]=%p,Gmap[m]->mapid=%d,Gmap[m]->id=%lld\n",
		  m,Gmap[m],Gmap[m]->mapid,Gmap[m]->id);
	  fflush(stdout);
	  assert(Gmap[mapid]->mapid == mapid);
        }
      }
    }

    if(VERB && LogPvThreshold != startLogPvThreshold){
      printf("Restoring LogPvThreshold = %0.2f -> %0.2f\n", LogPvThreshold, startLogPvThreshold);
      fflush(stdout);
    }
    ScoreThreshold = startScoreThreshold;
    LogPvThreshold = startLogPvThreshold;/* restore original LogPvThreshold, in case it was changed by -MapRate */

    // HERE : parameters should not be saved if(minSNRestimate && pSNRtotLL) : minSNR scan or bpp scan
    /* save current parameter values */
    if(VERB>=2){
      printf("Saving Error parameters for giter=%d:\n",giter);
      fflush(stdout);
    }

#pragma novector
    for(int c = 0; c < (usecolor ? MAXCOLOR : colors);c++){
      parameters[giter].res[c] = res[c];
      parameters[giter].resSD[c] = resSD[c];

      parameters[giter].FP[c] = FP[c];
      parameters[giter].FN[c] = FN[c];
      parameters[giter].SF[c] = SF[c];
      parameters[giter].SD[c] = SD[c];
      if(QUADRATIC_VARIANCE)
	parameters[giter].SR[c] = SR[c];
      if(RES_VARIANCE)
	parameters[giter].SE[c] = SE[c];
      parameters[giter].minSNR[c] = minSNR[c];

      if(DEBUG) assert(ResBins[c] <= RESBINS);
      parameters[giter].ResBins[c] = ResBins[c];
      if(DEBUG>=2 && (c==0 || usecolor)) assert(maxresbias >= resbiasX[c][ResBins[c]] - 1e-6);
      for(int Bin = 0; Bin <= ResBins[c]; Bin++){
	parameters[giter].resbias[c][Bin] = resbias[c][Bin];
	parameters[giter].resbiasX[c][Bin] = min(maxresbias,resbiasX[c][Bin]);
	if(VERB>=2){
	  printf("Bin=%d:size=%6.3f kb, bias= %7.4f\n",Bin, parameters[giter].resbiasX[c][Bin], parameters[giter].resbias[c][Bin]);
	  fflush(stdout);
	}
      }
    }
    parameters[giter].SF[2] = MA_SF;
    parameters[giter].SD[2] = MA_SD;
    parameters[giter].MA_mean = MA_mean;
    parameters[giter].PixelLen = PixelLen;
    parameters[giter].PixelLenSD = PixelLenSD;
    parameters[giter].mres = mres; // NOTE : mres does not change during autonoize
    parameters[giter].mresSD = mresSD; // NOTE : mresSD does not change during autonoise

    parameters[giter].maxresbias = maxresbias;

    printf("%d:", giter+1);
    fflush(stdout);

    numaligns = 0;
    for(int mapid = 0; mapid < nummaps; mapid++)
      Gmap[mapid]->origmap = 0;/* mark map as not a chimeric fragment */

    numerrors = numresdata = 0;

    /* initialize statistics counter */
    scoresum = 0.0;
    logPVsum = 0.0;
    NumpairsSum = 0.0;
    double LRsum = 0.0;

    ATscoresum = 0.0;
    ATlogPVsum = 0.0;
    ATNumpairsSum = 0.0;
    ATlogLRsum = 0.0;
    if(REFDEBUG && SDDEBUG)
      logLRsdsum = 0.0;

    double maplen = 0.0;/* total length of all maps used */
    for(int mapid = 0; mapid < nummaps; mapid++){
      Cmap *nanomap = Gmap[mapid];
      int M = nanomap->numsite[0];
      FLOAT *X = nanomap->site[0];
      maplen += X[M+1];
    }

    double totlen = 0.0;/* total length of maps for all alignments (including endoutliers and internal outliers) : for alignments that pass main 3 thresholds */

    int mapcnt = 0;/* Total number of maps that successfully aligned (over all reference maps : same map can align with multiple reference maps) */
    double resK2 = 2.0 * res[0] * PixelLen;
    double lenY = 0.0;/* sum of aligned ref lengths including internal outlier regions */
    double len=0.0;/* sum of aligned qry lengths (excluding internal outlier regions, unless -outlierType 1) */
    double lenB = 0.0;/* sum of aligned qry lengths - resK2 (excluding internal outlier regions, unless -outlierType 1) */
    double lenOut = 0.0;/* sum of aligned qry internal outlier regions (will be 0 with -outlierType 1) */
    double lenEnd = 0.0;/* sum of aligned qry external outlier regions */
    double ATtotlen = 0.0;/*total length of maps over all alignments (including endoutliers and internal outliers) : for alignments that pass all thresholds */

    int sitecnt=0, fp=0; double fn=0;/* count of total site intervals, false-negative and false-positive sites in aligned region of reference (including internal outliers IF -outlierType 1) */
    int sitecntY = 0;/* count of total reference sites EXCLUDING misresolved sites (including in internal outliers IF -outlierType 1) */
    int sitecntX = 0;/* count of total query sites in aligned regions (including internal outliers IF -outlierType 1) */
    int sitecntOut=0;/* total ref sites in internal outlier regions (will be 0 with -outlierType 1) (excluding misresolved sites if FIX_OUTLIER_MIS, which will instead be in sitecnt) */
    int sitecntOutY=0;/* count of ref sites in internal outlier regions EXCLUDING misresolved sites (will be 0 with -outlierType 1) */
    int sitecntOutX=0;/* count of qry sites in internal outlier regions (will be 0 with -outlierType 1) */
    int sitecntEnd=0;/* total query sites for endoutlier regions */
    int totsitecnt=0;/* total query sites for all maps that aligned (including any internal and endoutlier regions */
    int fpI = 0, fnI = 0;/* false-positives and false-negative sites that are NOT within FP_DIST of true-positive site */

    int segcnt = 0;/* count of internal aligned intervals (excluding outliers see outliercnt) */
    double PrPen = 0.0;/* sum of penalties for log(Pr(y)) and Sm()-log(p) */

    int outliertot = 0;/* number of internal intervals that are candidates for outliers (for BNX excludes some aligned intervals, see -maxOutlier) */
    int outliercnt = 0;/* number of internal intervals that were outliers */
    double outliersum = 0.0;/* weighted sum of outlier probability corresponding to outliercnt */

    int outlierEndcnt = 0;/* number of ends that were outliers (Lend or Rend <= -3) */
    int HDoutliercnt = 0;/* number of outlier ends with label density above MaxSiteDensity */
    int HDsites = 0;/* number of sites in outlier ends with label density above MaxSiteDensity */
    double HDlen = 0.0;/* total length of outlier ends with label density above MaxSiteDensity (as multiple of 100kb) */

    int fraccnt = 0;/* number of molecules filtered out due to -F */
    int LDcnt = 0;/* number of molecules filtered out due to -D (but NOT -F) */

    int chimcnt = 0;/* count of chimeric sites at least AlignedSiteThreshold from either end (for best alignments) */
    int chimconf = 0;/* count of confirmed chimeric fragments (with good alignment to seperate location) */
    int chimconfFP = 0;/* count of confirmed chimeric fragments that are FP (if ground truth is known) */
    chimpaircnt = 0;/* count how many chimeric pairs (see chimconf) are next to each other in same orientation (within 20 * Ylambda) */

    size_t errcnt = 0, totcnt=0, tcnt =0;

    int stitchcnt = 0, stitchOut = 0;/* count of internal intervals with stitch and intervals with both a stitch and outlier (if stitch information is present) */
    int stitchEnd = 0, stitchEndOut = 0;/* count of end intervals with stitch and intervals with both a stitch and outlier (if stitch information is present) */
    int sitecntS = 0, fpS = 0; double fnS = 0,lenS = 0.0;/* FP and FN estimates for stitched intervals */

    for(int i = 0; i < max(1,NumScaleFactor); i++)
      scaleIDcnt[i] = 0;

    if(ResEstimate && !REFDEBUG_STRICT /* NEW10 */&& giter > 0){/* recompute maxdist,AlignResMax & Kmax[] since res,resSD may have changed */
      maxdist = (res[0] + SDrange * resSD[0]) * PixelLen;
      AlignResMax = maxdist * AlignResMult;

      FLOAT *Yrev = 0;
      if(MultiMatches && MultiMatchesRev)
	Yrev = new FLOAT[maxN+2];

      int cntN = 0;
      long long ksum = 0, Nsum = 0;
      kmax = 0;
      for(int refid = 0; refid < numrefmaps; refid++){
	Cmap *rmap = refmap[refid];
	FLOAT *Y = rmap->site[0];
	int N = rmap->numsite[0];

	if(DEBUG>=2){/* check that site Y[0..N+1] are monotonic */
	  for(int I = 0; I <= N; I++)
	    if(DEBUG && !(Y[I+1] >= Y[I])){
	      printf("refid=%d:I=%d,N=%d:Y[I]=%0.8f,Y[I+1]=%0.8f\n",refid,I,N,Y[I],Y[I+1]);
	      fflush(stdout);
	      assert(Y[I+1] >= Y[I]);
	    }
	}

	int *Kmax = RKmax[refid];// WAS10 = &RKmem[cntN];
	cntN += N+1;

	int KMAX_APPROX = (SCORE_APPROX >= (AlignRes ? 2 : 1) || AlignResMult <= 1.0) ? 1 : 0;// NEW

	for(int I = 1; I <= N; I++){
	  int K = 0;
	  if(KMAX_APPROX /* NEW WAS SCORE_APPROX >= 2 || !AlignRes */){/* determine Kmax[I] based on total distance Y[I] - Y[I-K] < maxdist */
	    while(I-K > 1){
	      if(Y[I] - Y[I-K-1] >= maxdist)
		break;
	      K++;
	    }
	  } else {
	    while(I-K > 1){
	      if((!KMAX_FIX && Y[I-K] - Y[I-K-1] >= maxdist) || Y[I]-Y[I-K-1] >= AlignResMax)
		break;
	      K++;
	    }
	  }
	  if(K > KMAX){
	    if(VERB >= 2){
	      printf("Kmax[%d]=%d(reducing to %d):res=%0.3f,resSD=%0.3f:",I,Kmax[I],KMAX,res[0],resSD[0]);
	      for(int U = 0; U <= K; U++)
		printf("Y[%d]=%0.3f,",I-U,Y[I-U]);
	      printf("\n");
	    }
	    K = KMAX;
	  }
	  Kmax[I] = K;
	  if(VERB>=3 && refid==0 && I==2){
	    printf("RKmax[0][I=%d]= %d,Kmax[I]= %d\n", I, RKmax[0][I], Kmax[I]);
	    fflush(stdout);
	  }
	  if(DEBUG>=2 && resSD[0] <= 0.001 && Kmax[I]>=2){
	    printf("Kmax[%d]=%d:res=%0.3f,resSD=%0.3f:",I,Kmax[I],res[0],resSD[0]);
	    for(int U = 0; U <= K; U++)
	      printf("Y[%d]=%0.3f,",I-U,Y[I-U]);
	    printf("\n");
	  }
	}

	for(int I = 1; I <= N; I++){
	  ksum += Kmax[I];
	  if(Kmax[I] > kmax)
	    kmax = Kmax[I];
	}
	Nsum += N;

	if(MultiMatches && MultiMatchesRev){
	  for(int I = 0; I <= N+1; I++)
	    Yrev[I] = Y[N+1] - Y[N+1 - I];
	  Y = Yrev;

	  int *Kmax = RKmax[refid + numrefmaps];// WAS10  = &RKmem[cntN];
	  cntN += N+1;
	
	  for(int I = 1; I <= N; I++){
	    int K = 0;
	    if(KMAX_APPROX /* NEW */){/* determine Kmax[I] based on total distance Y[I] - Y[I-K] < maxdist */
	      while(I-K > 1){
		if(Y[I] - Y[I-K-1] >= maxdist)
		  break;
		K++;
	      }
	    } else {
	      while(I-K > 1){
		if((!KMAX_FIX && Y[I-K] - Y[I-K-1] >= maxdist) || Y[I]-Y[I-K-1] >= AlignResMax)
		  break;
		K++;
	      }
	    }
	    if(K > KMAX){
	      if(VERB >= 2){
		printf("Kmax[%d]=%d(reducing to %d):res=%0.3f,resSD=%0.3f:",I,Kmax[I],KMAX, res[0],resSD[0]);
		for(int U = 0; U <= K; U++)
		  printf("Y[%d]=%0.3f,",I-U,Y[I-U]);
		printf("\n");
	      }
	      K = KMAX;
	    }
	    Kmax[I] = K;
	    if((DEBUG>=2 && resSD[0] <= 0.001 && Kmax[I]>=2) || (TRACE>=2 && REF_TRACE == rmap->id && Kmax[I])){
	      printf("refid=%d(id=%lld):Kmax[%d]=%d:res=%0.3f,resSD=%0.3f:",refid,rmap->id,I,Kmax[I],res[0],resSD[0]);
	      for(int U = 0; U <= K; U++)
		printf("Y[%d]=%0.3f,",I-U,Y[I-U]);
	      printf("\n");
	    }
	  }
	}
      }
      if(DEBUG) assert(cntN <= sumN * revmult);
      if(VERB){
	printf("kmax=%d,average Kmax[I]=%0.3f\n",
	       kmax, ((double) ksum)/Nsum);
	fflush(stdout);
      }
      if(MultiMatches && MultiMatchesRev)
	delete [] Yrev;
      if(VERB>=2){
	printf("Initialized RKmax[0..%d] : sumN=%d, revmult=%d, cntN=%d : RKmax= %p, RKmem= %p, RKmax[0]= %p\n",numrefmaps-1,sumN, revmult, cntN, RKmax, RKmem, RKmax[0]);
	fflush(stdout);
      }
    }

#if MSAN
    if(VERB>=2){
#pragma omp critical
      {
	//	      __msan_unpoison(&RKmax, sizeof(int *));

	intptr_t test3 = __msan_test_shadow(YidListMem, MaxPair*4*sizeof(int));
	printf("After computing RKmax[]: YidListMem= %p, MaxPair=%d : msan_test_shadow= %lld\n", YidListMem, MaxPair, (long long) test3);
	fflush(stdout);
	assert(test3 < 0);
	
	intptr_t test4 = __msan_test_shadow(&RKmax, sizeof(int *));
	printf("\t msan_test_shadow(&RKmax, sizeof(int*))= %lld\n", (long long)test4);
	fflush(stdout);
	assert(test4 < 0);
	
	intptr_t test5 = __msan_test_shadow(RKmem, sumN*revmult*sizeof(int));
	printf("\t msan_test_shadow(RKmem, sumN*revmult*sizeof(int))= %lld, RKmem=%p, sumN=%d,revmult=%d\n", (long long)test5, RKmem, sumN, revmult);
	fflush(stdout);
	assert(test5 < 0);
      }
    }
#endif

    if(VERB>=2){
      printf("giter=%d:nummaps=%d,startmaps=%d,totalmaps=%d:Before score_init: cpu time=%0.6f, wall time=%0.6f\n",giter,nummaps,startmaps,totalmaps,mtime(),wtime());
      fflush(stdout);
      dumpmemmap();
    }

    if(DEBUG) assert(colors==1);

    int scorerefmaps = numrefmaps;
    if(!(SCORE_INIT_DELAY && nexthash1 && XmapCount[0] && !Refine && !(!NoStat || (MapScale && giter==0 && !origMapScale && !pSNRtotLL)))){
      (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);
      ChimScore = OutlierEndBias + OutlierEndPenalty;
    }

#if MSAN
    if(VERB>=2){
#pragma omp critical
      {
	//	      __msan_unpoison(&RKmax, sizeof(int *));

	intptr_t test3 = __msan_test_shadow(YidListMem, MaxPair*4*sizeof(int));
	printf("After calling score_init(): YidListMem= %p, MaxPair=%d : msan_test_shadow= %lld\n", YidListMem, MaxPair, (long long) test3);
	fflush(stdout);
	assert(test3 < 0);
	
	intptr_t test4 = __msan_test_shadow(&RKmax, sizeof(int *));
	printf("\t msan_test_shadow(&RKmax, sizeof(int*))= %lld\n", (long long)test4);
	fflush(stdout);
	assert(test4 < 0);
	
	intptr_t test5 = __msan_test_shadow(RKmem, sumN*revmult*sizeof(int));
	printf("\t msan_test_shadow(RKmem, sumN*revmult*sizeof(int))= %lld, RKmem=%p, sumN=%d,revmult=%d\n", (long long)test5, RKmem, sumN, revmult);
	fflush(stdout);
	assert(test5 < 0);
      }
    }
#endif

    if(VERB>=2){
      printf("refalign:nummaps=%d,startmaps=%d,totalmaps=%d,ChimScore=%0.6f:After score_init (mem=%0.1f Mbytes): cpu time=%0.6f, wall time=%0.6f\n",
	     nummaps,startmaps, totalmaps, ChimScore, score_init_mem/(1024.0*1024.0), mtime(),wtime());
      fflush(stdout);
      dumpmemmap();
    }

    if(nexthash1){/* go back to start of HashTable data */
      if(VERB>=2){
	printf("Calling hash_open:cpu time=%0.6f, wall time=%0.6f\n",mtime(),wtime());
	fflush(stdout);
      }
      if(HashFP){
	(void)hash_close(HashFP,0);
	numhashpairs1 = numhashpairs2 = 0;
	NumPair1 = NumPair2 = 0;
	nexthash1 = hashpairs1;
	refid1 = refidend1 = -1;
	if(HASH_STREAM>=2){
	  nexthash2 = hashpairs2;
	  refid2 = refidend2 = -1;
	}
	HashFP = NULL;
      }
      MatchMax = hash_open(HashFP, hash_filename);
      if(DEBUG) assert(HashFP != NULL);
      if(VERB>=2){
	printf("   Finished hash_open:MatchMax=%llu:cpu time=%0.6f, wall time=%0.6f\n",(unsigned long long)MatchMax,mtime(),wtime());
	printf("nexthash1=%p,FirstAlignments=%d,NoSplit=%d\n",nexthash1,FirstAlignments,NoSplit);
	fflush(stdout);
      }
      totalhashpairs = 0;
    }

    if(DEBUG>=2){
      for(int mapid = 0; mapid < nummaps; mapid++){
        if(!(Gmap[mapid]->mapid == mapid)){
 	  printf("mapid=%d:Gmap[mapid]=%p,Gmap[mapid]->mapid=%d,Gmap[mapid]->id=%lld\n",
		mapid,Gmap[mapid],Gmap[mapid]->mapid,Gmap[mapid]->id);
	  for(int m = 0; m < 10; m++)
	    printf("m=%d:Gmap[m]=%p,Gmap[m]->mapid=%d,Gmap[m]->id=%lld\n",
		  m,Gmap[m],Gmap[m]->mapid,Gmap[m]->id);
	  fflush(stdout);
	  assert(Gmap[mapid]->mapid == mapid);
        }
      }
    }

    if(DEBUG>=2) assert(0 <= giter && giter <= RefRepeats-1);

    #pragma omp parallel for num_threads(numthreads) schedule(static,256)
    for(int mapid = 0;mapid < nummaps;mapid++){
      Cmap *nanomap = Gmap[mapid];
      nanomap->incscale = 1.0;
      nanomap->incwt = nanomap->y2sum = nanomap->xysum = 0.0;
    }

    if(nexthash1){/* with hashtable */

      int refidend = -1;
   
      for(int refid = 0; refid < numrefmaps; refid = refidend + 1){

	refidend = refidend1;
	if(refid != refid1){ /* Compute YidList1[],XidList1[],phashList1[] (may just copy/swap from 2nd buffer set) */
	  refidend = loadhash2(refid, nummaps, nexthash1, hashpairs1, numhashpairs1, maxhashpairs1, YidList1, XidList1, phashList1, NumPair1);
	  if(DEBUG) assert(refid==refid1);
	}
	if(VERB>=2){
	  printf("refid=%d(refid1=%d),refidend=%d(refidend1=%d), numrefmaps=%d, NumPair1=%d,MaxPair=%d\n",
		 refid,refid1,refidend,refidend1,numrefmaps, NumPair1,MaxPair);
	  fflush(stdout);
	}
	if(refidend < refid){
	  for(int rid = refid; rid <= numrefmaps; rid++)
	    numalign_start[rid] = numalign_end[rid] = numaligns;	    
	  break;
	}
	if(NumPair1 <= 0) {
	  for(int rid = refid; rid <= refidend; rid++)
	    numalign_start[rid] = numalign_end[rid] = numaligns;	    
	  continue;
	}

	if(DEBUG) assert(YidList1[0] >= refid && YidList1[NumPair1-1] <= refidend);

        if(SCORE_INIT_DELAY && XmapCount[0] && !Refine && !(!NoStat || (MapScale && giter==0 && !origMapScale && !pSNRtotLL))){
	  (void) score_init(refmap,refid1,refidend+1,nummaps,RKmax);
	  ChimScore = OutlierEndBias + OutlierEndPenalty;
	}
	if(VERB>=2){
	  printf("refalign:nummaps=%d,startmaps=%d,totalmaps=%d,ChimScore=%0.6f:After score_init (mem=%0.1f Mbytes): cpu time=%0.6f, wall time=%0.6f\n",
		 nummaps,startmaps, totalmaps, ChimScore, score_init_mem/(1024.0*1024.0), mtime(),wtime());
	  fflush(stdout);
	  dumpmemmap();
	}

	/* determine pcnt = sum of K+1 values for largest reference map in range refid .. refidend */
	/* NOTE: this pcnt is only used to estimate real memory used. It is replaced by (1 + Kmax) * maxN to allocate virtual memory */

	pcnt = 1;
	int Ncnt = 1;
	int NN = 0;
	int alignblock = (NoSplit <= 1 && HashMultiMatch) ? 3 : 1;
	size_t orignumaligns = numaligns;

#if MSAN
        if(VERB>=2){
#pragma omp critical
          {
	    intptr_t test1 = __msan_test_shadow(&numaligns, sizeof(size_t));
	    intptr_t test2 = __msan_test_shadow(&orignumaligns, sizeof(size_t));

	    if(test1 >= 0 || test2 >= 0){
              printf("numaligns=%lu (test1=%ld), orignumaligns=%lu (test2=%ld)\n",numaligns,test1,orignumaligns,test2);
	      fflush(stdout);
	      assert(test1 < 0);
	      assert(test2 < 0);
            }
          }
        }
#endif

	numaligns += NumPair1 * alignblock;
	maxalignallocNULL(numaligns,alignment,numaligns,maxaligns,&alignment_blockid);

	double Ylambda = 0.0;
	int Ycnt = 0;

	for(int rid = refid; rid <= refidend; rid++){
	  Cmap *rmap = refmap[rid];
	  int N = rmap->numsite[0];
	  int *Kmax = RKmax[rid];
	  FLOAT *Y = rmap->site[0];

	  Ycnt += N;
	  Ylambda += Y[N+1];

	  if(N > NN)
	    NN = N;

	  long long pcnt_rid = 0;
	  for(int I=1; I <= N; I++)
	    pcnt_rid += Kmax[I] + 1;
	  if(MIN_MEM && DIAGONAL>=2 && hashdelta){
	    if(pcnt_rid * Ncnt > pcnt * N){
	      pcnt = pcnt_rid;// WAS max(pcnt, pcnt_rid);
	      Ncnt = N;
	    }
	  } else {
	    if(pcnt_rid > pcnt){
	      pcnt = pcnt_rid;
	      Ncnt = N;
	    }
	  }
	}
	Ylambda = Ylambda / max(1,Ycnt);
	if(DEBUG) assert(pcnt >= 0 && pcnt <= MAXINT);

	if(VERB>=2){
	  printf("refid=%d..%d,nummaps=%d:numaligns=%llu->%llu,NumPair1=%d,refid1=%d..%d,refid2=%d..%d,Ylambda=%0.3f,Xlambda=%0.3f\n",refid,refidend,nummaps,
		 (unsigned long long)orignumaligns,(unsigned long long)numaligns,NumPair1,refid1,refidend1,refid2,refidend2,Ylambda,Xlambda);
	  fflush(stdout);
	}

	size_t DPsiz = DPsizF * sizeof(RFLOAT) + DPsizI * sizeof(int);
	size_t virtperthread_size = (maxN+maxM) * (2LL*sizeof(int *)) + (1ul + kmax) * maxN * (maxM + 2*FENCE) * DPsiz + /* alignment fudge */ (6+1)*CACHE_LINE_GUARD*sizeof(float);
	size_t perthread_size = pcnt * maxM  * DPsiz;
	if(MIN_MEM && DIAGONAL>=2 && hashdelta){
	  // base real memory used on estimated JMIN[]..JMAX[] ranges : approximately min(maxM, 2*max(DELTA_X,hashdelta)+1) * (maxM + 2*max(DELTA_Y,hashdelta)) * (pcnt/Ncnt)	  
	  long long ihashdelta = hashdeltaAdjust ? floor(hashdeltaLim + 0.999) : floor(hashdelta + 0.9999);
	  long long delX = DELTA_X, delY = DELTA_Y;
	  long long deltaJ = min(maxM, 2*(max(max(delX,delY), ihashdelta)) + 1);
	  long long deltaI = maxM + 2*(max(delY, ihashdelta));
	  perthread_size = DPsiz * deltaJ * deltaI * pcnt / Ncnt;
	  virtperthread_size = DPsiz * deltaJ * deltaI * (1ul + kmax);// NEW 

	  if(Ylambda > 0.0 && Xlambda > Ylambda){	  /* correction when reference label density is higher than query label density */
	    double c = Xlambda / Ylambda;
	    double deltaJ2 = deltaJ + (c-1.0) * deltaI;
	    perthread_size = DPsiz * (c * deltaI) * min(1024.0 /* 1 page = 1024 ints or floats */ , deltaJ2) * pcnt/Ncnt;
	    virtperthread_size = DPsiz * (c * deltaI) * deltaJ2 * (1ul + kmax);
	  }
	}

	/* determine number of threads (numthreads) to use */
	int numthreads = 1;
        #ifdef _OPENMP
	numthreads = MaxThreads; // WAS omp_get_max_threads();
	//	numthreads = min(numthreads,MaxThreads);

	if(!RA_MIN_TIME && MaxMem > 0 && pcnt > 0 && maxM > 0){/* NOTE : maxM, the largest map size, is computed in score_init() */
	  double virtperthread = virtperthread_size + sizeof(AL); // (1.0+kmax) * maxN * ( maxM * DPsiz) + sizeof(AL);// virtual memory used per thread
	  double memperthread = perthread_size + sizeof(AL); // (double)pcnt * (double)(maxM  * DPsiz) + sizeof(AL);// Estimate of real memory used per thread

	  extern int numbufs;
	  double HashMem = MaxPair*2*(sizeof(CHashMatch) + sizeof(int)*2+sizeof(CHashMatch*)) + numbufs * HASHBUF_SIZ * 2 * sizeof(CHashMatch);
	  double GB = 1024.0*1024.0*1024;
	  double scoreWS = min(1.0, 4.0/numrefmaps);// NEW : max fraction of score memory likely to be in active use, rest can be swapped out
	  double maxmem = (double)MaxMem * GB - score_init_mem * scoreWS - HashMem;
	  double maxvirtmem = (MaxVirtMem > 0.0) ? MaxVirtMem * GB : 1e+40;
	  long long VmSize = 0, VmRSS = 0, VmSwap = 0;

	  delete rs_heap;    /* free lightweight heap : this should release virtual memory space with glibc */
	  rs_heap = new lightweight_heap(0,0);
	  if(TotalThreads){
            getmem(VmSize,VmRSS, VmSwap, &VmHWM);
	    realVmRSS = VmRSS;
	    if(DEBUG>=2 && !(VmRSS <= VmHWM)){
              printf("VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: wt= %0.6f\n",VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9,VmSize*1e-9,wtime());
	      fflush(stdout);
	      assert(VmRSS <= VmHWM);
            }
	    //	    long long score_swap = score_init_mem * (1.0 - scoreWS);
	    maxvirtmem -= min(VmSize, max(VmRSS, /* WAS score_swap */score_init_mem) + VmSwap);
	    //   maxmem -= VmRSS; // NOTE : this memory can be allowed to swap out
	  }
	  int limitthreads = max(1,(int)floor(min(maxmem/memperthread , maxvirtmem/virtperthread) + 0.5));
	  if(limitthreads < numthreads){
	    if(VERB){
	      if(TotalThreads)
		printf("refid=%d..%d: number of threads reduced from %d to %d due to MaxVirtMem=%0.6e(%0.6e)Gb,MaxMem=%0.4f(%0.4f)Gb, Score=%0.4f Gb, HashBuf=%0.4f Gb, per thread virtual memory = %0.4f Gb, real memory ~ %0.4f Gb, VmRSS=%0.4f,VmSwap=%0.4f,VMSize=%0.4f Gb:N<=%d,pcnt=%lld(N=%d,c=%0.3f),maxN=%lld,kmax=%d,maxM=%lld\n",
		       refid,refidend, numthreads,limitthreads, MaxVirtMem, maxvirtmem/GB, MaxMem, maxmem/GB,score_init_mem/GB, HashMem/GB, virtperthread/GB,
		       memperthread/GB, VmRSS/GB, VmSwap/GB,VmSize/GB, NN,pcnt,Ncnt,(Ylambda <= 0.0) ? 1.0 : max(1.0, Xlambda/Ylambda),maxN,kmax,maxM);
	      else
		printf("refid=%d..%d: number of threads reduced from %d to %d due to MaxVirtMem=%0.6e(%0.6e)Gb,MaxMem=%0.4f(%0.4f)Gb, Score=%0.4f Gb, HashBuf=%0.4f Gb, per thread virtual memory = %0.4f Gb, real memory ~ %0.4f Gb:N<=%d,pcnt=%lld(N=%d,c=%0.3f),maxN=%lld,kmax=%d,maxM=%lld\n",
		       refid,refidend, numthreads,limitthreads, MaxVirtMem, maxvirtmem/GB, MaxMem, maxmem/GB,score_init_mem/GB, HashMem/GB, virtperthread/GB, memperthread/GB, NN,pcnt,Ncnt,
		       (Ylambda <= 0.0) ? 1.0 : max(1.0, Xlambda/Ylambda),maxN,kmax,maxM);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(limitthreads >= 1);
	    numthreads = limitthreads;
	  } else if(VERB/* HERE >=2 */){
	    if(TotalThreads)
		printf("refid=%d..%d: number of threads=%d: MaxVirtMem=%0.4f(%0.6e)Gb,MaxMem=%0.4f(%0.4f)Gb, Score=%0.4f Gb, HashBuf=%0.4f Gb, per thread virtual memory = %0.4f Gb, real memory ~ %0.4f Gb, VmRSS=%0.4f,VmSwap=%0.4f,VMSize=%0.4f Gb:N<=%d,pcnt=%lld(N=%d,c=%0.3f),maxN=%lld,kmax=%d,maxM=%lld\n",
		       refid,refidend, numthreads, MaxVirtMem, maxvirtmem/GB, MaxMem, maxmem/GB,score_init_mem/GB, HashMem/GB, virtperthread/GB,
		       memperthread/GB, VmRSS/GB, VmSwap/GB,VmSize/GB, NN,pcnt,Ncnt,(Ylambda <= 0.0) ? 1.0 : max(1.0, Xlambda/Ylambda), maxN,kmax,maxM);
	      else
		printf("refid=%d..%d: number of threads=%d: MaxVirtMem=%0.4f(%0.6e)Gb,MaxMem=%0.4f(%0.4f)Gb, Score=%0.4f Gb, HashBuf=%0.4f Gb, per thread virtual memory = %0.4f Gb, real memory ~ %0.4f Gb:N<=%d,pcnt=%lld(N=%d,c=%0.3f),maxN=%lld,kmax=%d,maxM=%lld\n",
		       refid,refidend, numthreads, MaxVirtMem, maxvirtmem/GB, MaxMem, maxmem/GB,score_init_mem/GB, HashMem/GB, virtperthread/GB, memperthread/GB, NN,pcnt,Ncnt,
		       (Ylambda <= 0.0) ? 1.0 : max(1.0, Xlambda/Ylambda),maxN,kmax,maxM);
	    fflush(stdout);
	  }
	}
	if(numthreads > NumPair1)
	  numthreads = max(1,NumPair1);

        #endif

	if(MIN_MEM_DEBUG || RA_MIN_TIME){
	  if(FmemSiz) delete [] FmemSiz;
	  FmemSiz = new long long[numthreads];
	  for(int i = 0; i < numthreads; i++)
	    FmemSiz[i] = 0;
	}
	if(RA_MIN_TIME){
	  if(FmemMadv) delete [] FmemMadv;
	  FmemMadv = new double[numthreads];
	  for(int i = 0; i < numthreads; i++)
	    FmemMadv[i] = 0.0;

	  if(FmemSleep) delete [] FmemSleep;
	  FmemSleep = new double[numthreads];
	  for(int i = 0; i < numthreads; i++)
	    FmemSleep[i] = 0.0;

	  if(FmemBT) delete [] FmemBT;
	  FmemBT = new double[numthreads];
	  for(int i = 0; i < numthreads; i++)
	    FmemBT[i] = 0.0;

          if(FmemHWM) delete [] FmemHWM;
          FmemHWM = new long long[numthreads];
	  if(FmemTime) delete [] FmemTime;
	  FmemTime = new double[numthreads];

	  for(int i = 0; i < numthreads; i++){
            FmemHWM[i] = 0;
	    FmemTime[i] = wtime();
          }
        }
	if(MIN_MEM_DEBUG){
          if(FmemRsiz) delete [] FmemRsiz;
	  FmemRsiz = new long long[numthreads];
	  for(int i = 0; i < numthreads; i++)
	    FmemRsiz[i] = 0;
        }

	int block = (HashMultiMatch && maptype) ? 1 : min(16,max(1,NumPair1/((USE_MIC ? 16 : 64) * numthreads)));
	//	numthreads = 1;
	if(VERB && (VERB>=2 || numthreads != thread_printed)){
	  printf("refid=%d..%d:Using %d threads(NumPair1=%d,block=%d)\n",refid,refidend,numthreads,NumPair1,block);
	  fflush(stdout);
	  thread_printed = numthreads;
	}

	if(DEBUG) assert(numthreads >= 1);

	if(VERB>=2){
	  printf("refid=%d..%d/%d:kmax=%d,maxN=%lld,maxM=%lld\n",refid,refidend,numrefmaps,kmax,maxN,maxM);
	  fflush(stdout);
	}
	pcnt = (1LL+kmax) * maxN;
	if(MIN_MEM && DIAGONAL>=2 && hashdelta)/* (re)allocate most memory in refalignXYsd() using malloc()/free() */
	  rs_heap->reset_lightweight_heap((maxN+maxM) * (2LL*sizeof(int*)) +/*alignment fudge*/ (4+1)*CACHE_LINE_GUARD*sizeof(float), numthreads);
	else
	  rs_heap->reset_lightweight_heap(virtperthread_size, numthreads);
	  //	  rs_heap->reset_lightweight_heap((maxN+maxM) * (2LL*sizeof(int*)) + pcnt * (maxM + 2*FENCE) * DPsiz +/*alignment fudge*/ (6+1)*CACHE_LINE_GUARD*sizeof(float), numthreads);
            
	if(VERB>=2){
	  printf("refid=%d..%d/%d: start of parallel section:NumPair1=%d: CPU time=%0.6f wall time=%0.6f\n",refid,refidend,numrefmaps,NumPair1,mtime(),wtime());
	  fflush(stdout);
	}

#if MSAN
	if(VERB>=2){
#pragma omp critical
	  {
	    //	      __msan_unpoison(&RKmax, sizeof(int *));

	    intptr_t test3 = __msan_test_shadow(YidListMem, MaxPair*4*sizeof(int));
	    printf("Before start of multithreaded block: YidListMem= %p, MaxPair=%d : msan_test_shadow= %lld\n", YidListMem, MaxPair, (long long) test3);
	    fflush(stdout);
	    assert(test3 < 0);
	
	    intptr_t test4 = __msan_test_shadow(&RKmax, sizeof(int *));
	    printf("\t msan_test_shadow(&RKmax, sizeof(int*))= %lld\n", (long long)test4);
	    fflush(stdout);
	    assert(test4 < 0);
	
	    intptr_t test5 = __msan_test_shadow(RKmem, sumN*revmult*sizeof(int));
	    printf("\t msan_test_shadow(RKmem, sumN*revmult*sizeof(int))= %lld, RKmem=%p, sumN=%d,revmult=%d\n", (long long)test5, RKmem, sumN, revmult);
	    fflush(stdout);
	    assert(test5 < 0);
	  }
	}
#endif

	int lastPairId = 0;

	NumThreads = max(1,numthreads);
	PausedThreads = 0;

	/* Multi-threaded work section : alignments of YidList1[0..NumPair1-1] with XidList1[0..NumPair1-1] (with hashtable) */
	/* NOTE : MemorySanitizer is not able to handle the following OpenMP loop, unless compiled with -O0 */
	#pragma omp parallel num_threads(numthreads) if(numthreads > 1) 
	{
	  int tid = 0;
          #ifdef _OPENMP
	  tid = omp_get_thread_num ();
          #endif

	  /* each thread needs its own local memory */
	  int maxmatchgroup = 0;
	  Cmatchgroup *matchgroup = NULL;
	  Cmatchgroup **mheap = NULL;
	  if(MultiMatches){
	    maxmatchgroup = 1024;
	    if(MATCHGROUP_HEAP){
	      matchgroup = new Cmatchgroup[2*maxmatchgroup];
	      mheap = new Cmatchgroup*[maxmatchgroup+1];
            } else
	      matchgroup = new Cmatchgroup[maxmatchgroup];
          }

	  CXPen XPenMem;
	  CXPen *XPen = &XPenMem;
	  XPen_alloc(XPen);

	  /* allocate DP array A.<field>(I=1..maxN, K=0..kmax, J=1..maxM) */
	  AL A;
	  A.kmax = A.KMAX = kmax;
	  if(sizeof(A.Kstride) < sizeof(long long) && (long long)maxN * (long long)maxM * (long long) kmax > MASK(31)){
	    printf("maxN=%lld,maxM=%lld,kmax=%d: maxN * maxM * kmax exceeds signed integer range : change Kstride to long long in refalign.cpp\n",maxN,maxM,A.kmax);
	    fflush(stdout);exit(1);
	  }
	  if(sizeof(A.Istride) < sizeof(long long) && (long long)maxM > MASK(31)){
	    printf("maxM=%lld: maxM exceeds signed integer range : change Istride to long long in refalign.cpp\n",maxM);
	    fflush(stdout);exit(1);
	  }

	  int *JMIN = rs_heap->alloc_int(maxN,tid) - 1;
	  int *JMAX = rs_heap->alloc_int(maxN,tid) - 1;
	  int *Imin = rs_heap->alloc_int(maxM,tid) - 1;
	  int *Imax = rs_heap->alloc_int(maxM,tid) - 1;

	  long long StrideMax = 0;/* initial allocation (elements per array) in current thread */
	  long long KstrideMax = 0;/* Used with StrideMax if CACHE != 0 */
	  RFLOAT *Fmem = 0;
	  int *Imem = 0;
	  if(!(MIN_MEM && DIAGONAL>=2 && hashdelta)){
	    if(DEBUG) assert(kmax == A.KMAX);
	    StrideMax = (1LL + kmax) * maxN * maxM;
	    KstrideMax = maxN * maxM;
	    Fmem = rs_heap->alloc_RFLOAT(StrideMax * DPsizF, tid);
	    Imem = rs_heap->alloc_int(StrideMax * DPsizI, tid);
	  }

	  if(VERB>=2){
            #pragma omp critical
	    {
	      printf("thread=%d/%d:memory allocated:block size=%d maps, pcnt=%lld,N<=%d,kmax=%d,maxM=%lld,maxN=%lld, NumPair1=%d, StrideMax=%lld\n",
	         tid,numthreads,block,pcnt,NN,kmax,maxM,maxN,NumPair1,StrideMax);
	      fflush(stdout);
	    }
	  }

#if MSAN
         if(VERB>=2){
#pragma omp critical
           {
	//	      __msan_unpoison(&RKmax, sizeof(int *));

	     intptr_t test3 = __msan_test_shadow(YidListMem, MaxPair*4*sizeof(int));
	     printf("tid=%d:After allocating Fmem/Imem: YidListMem= %p, MaxPair=%d : msan_test_shadow= %lld\n", tid, YidListMem, MaxPair, (long long) test3);
	     fflush(stdout);
	     assert(test3 < 0);
	
   	     intptr_t test4 = __msan_test_shadow(&RKmax, sizeof(int *));
	     printf("\t msan_test_shadow(&RKmax, sizeof(int*))= %lld\n", (long long)test4);
	     fflush(stdout);
	     assert(test4 < 0);
	
	     intptr_t test5 = __msan_test_shadow(RKmem, sumN*revmult*sizeof(int));
	     printf("\t msan_test_shadow(RKmem, sumN*revmult*sizeof(int))= %lld, RKmem=%p, sumN=%d,revmult=%d\n", (long long)test5, RKmem, sumN, revmult);
	     fflush(stdout);
	     assert(test5 < 0);
           }
         }
#endif

	  int Tmapcnt = 0;

#if !USE_MIC
	  #pragma omp for nowait schedule(dynamic,block) // need "nowait" to support RA_MIN_TIME to avoid memory starvation of last threads
#endif
	  for(int PairId = 0; PairId < NumPair1; PairId++){
	    if(USE_MIC && !(((PairId / 16) % numthreads) == tid)){ 
	      continue; // NOTE : simulate #pragma omp for schedule(static,16)
	    }

	    CHashMatch *phash = phashList1[PairId];
	    int rid = YidList1[PairId];
	    int mapid = XidList1[PairId];
	    if(DEBUG>=2) assert(rid >= refid && rid <= refidend);
	    if(DEBUG>=2) assert(0 <= mapid && mapid < nummaps);

	    if(!tid && refidend+1 < numrefmaps && refid2 < refidend+1){
	      /* Read ahead into 2nd buffer in the master thread. In Non-parallel section swap the 2 buffers instead of reading data */
	      int end2 = loadhash2(refidend+1, nummaps, nexthash2, hashpairs2, numhashpairs2, maxhashpairs2, YidList2, XidList2, phashList2, NumPair2);
	      if(DEBUG) assert(refid2 >= refidend+1);
	      if(DEBUG) assert(refidend2 == end2);
	    }

#if MSAN
	    intptr_t test1, test2, test3, test4, test5, test6;
	    if(VERB>=2){
#pragma omp critical
	      {
		test1 = __msan_test_shadow(&numaligns, sizeof(size_t));
		test2 = __msan_test_shadow(&orignumaligns, sizeof(size_t));
		test3 = __msan_test_shadow(&alignblock, sizeof(int));
		test4 = __msan_test_shadow(&PairId, sizeof(int));
		test5 = __msan_test_shadow(&rid, sizeof(int));
		test6 = __msan_test_shadow(&mapid, sizeof(int));
	
		if(test1 >= 0 || test2 >= 0 || test3 >= 0 || test4 >= 0 || test5 >= 0 || test6 >= 0){
		  printf("tid=%d: test1=%ld, test2=%ld, test3=%ld, test4=%ld, test5=%ld, test6=%ld\n",tid,test1,test2,test3,test4,test5,test6);
		  fflush(stdout);

		  printf("\t PairId=%d:rid=%d,mapid=%d: numaligns=%lu, orignumaligns=%lu, alignblock=%d\n",
			 PairId,rid,mapid,numaligns, orignumaligns, alignblock);
		  fflush(stdout);
		}
		  
		assert(test1 < 0);
		assert(test2 < 0);
		assert(test3 < 0);
		assert(test4 < 0);
		assert(test5 < 0);
		assert(test6 < 0);
	      }
	    }
#endif

	    size_t alignid = orignumaligns + PairId * alignblock;
	    size_t origalignid = alignid;
	    if(DEBUG>=2 && !(alignid + alignblock <= numaligns)){
	      #pragma omp critical
	      {
		printf("PairId=%d/%d:rid=%d/%d,mapid=%d/%d:alignid=%llu,alignblock=%d,numaligns=%llu,numalign_start[rid]=%llu\n",
		       PairId,NumPair1,rid,numrefmaps,mapid,nummaps,(unsigned long long)alignid,alignblock,(unsigned long long)numaligns,(unsigned long long)numalign_start[rid]);
		fflush(stdout);
		assert(alignid < numaligns);
	      }
	    }
	    
	    for(int t = 0; t < alignblock; t++){// free/reset alignment memory
	      Calign *p = alignment[alignid+t];
	      if(!p)
		continue;
	      if(p->block_id < 0){
		p->allfree();
		if(ALIGN_COMPRESS)
		  delete [] p;
	      }
	      if(ALIGN_COMPRESS)
		alignment[alignid+t] = NULL;
	    }

	    if(FirstAlignments && mapcnt+Tmapcnt >= FirstAlignments)
	      continue;	  // NOTE : multithreaded loop is not determininistic since mapcnt is not synchronized

	    Cmap *rmap = refmap[rid];
	    int N = rmap->numsite[0];

	    Cmap *nanomap = Gmap[mapid];
	    if(DEBUG>=2) assert(nanomap != 0);
	    if(DEBUG>=2) assert(nanomap->mapid == mapid);

	    //	    if(TRACE && !(rmap->id == REF_TRACE && nanomap->id == MAP_TRACE))  continue;// HERE 

	    int M = nanomap->numsite[0];
	    FLOAT *X = nanomap->site[0];

	    if((VERB>=2 && PairId > lastPairId + 1000) || (DEBUG>=2 && USE_MIC && !(((PairId/16) % numthreads) == tid)) || (MIN_MEM_DEBUG && VERB>=3)){
	      #pragma omp critical
	      {
		printf("tid=%d:PairId=%d/%d:rid=%d(%lld),mapid=%d(%lld),N=%d,M=%d:Calling refalignSD:alignment[alignid=%lu]=%p: cum wall= %0.6f\n",
		       tid,PairId,NumPair1,rid,rmap->id,mapid,nanomap->id,N,M,alignid,alignment[alignid], wtime());
		fflush(stdout);
		if(PairId > lastPairId + 1000)
		  lastPairId = PairId;
	      }
	    }

#if MSAN
	    if(VERB>=2){
#pragma omp critical
	      {
	      //	      __msan_unpoison(&RKmax, sizeof(int *));

	        intptr_t test3 = __msan_test_shadow(YidListMem, MaxPair*4*sizeof(int));
		if(test3 >= 0){
	          printf("tid=%d:Before Calling refalignSD: YidListMem= %p, MaxPair=%d : msan_test_shadow= %lld\n", tid,YidListMem, MaxPair, (long long) test3);
		  fflush(stdout);
	        }
		assert(test3 < 0);
	      
		intptr_t test4 = __msan_test_shadow(&RKmax, sizeof(int *));
		if(test4 >= 0){
		  printf("\t msan_test_shadow(&RKmax, sizeof(int*))= %lld\n", (long long)test4);
		  fflush(stdout);
	        }
		assert(test4 < 0);

		intptr_t test5 = __msan_test_shadow(RKmem, sumN*revmult*sizeof(int));
		if(test5 >= 0){
	          printf("\t msan_test_shadow(RKmem, sumN*revmult*sizeof(int))= %lld, RKmem=%p, sumN=%d,revmult=%d,N=%d\n", (long long)test5, RKmem, sumN, revmult, N);
		  fflush(stdout);
	        }
		assert(test5 < 0);
	      }
	    }
#endif

	    refalignSD(rmap, 
		       nanomap, 
		       alignid, 
		       RKmax, 
		       rid, 
		       mapid, 
		       phash, 
		       XPen, 
		       &A, 
		       Fmem, 
		       Imem, 
		       StrideMax, 
		       KstrideMax, 
		       JMIN, 
		       JMAX, 
		       Imin, 
		       Imax, 
		       tid, 
		       numthreads, 
		       maxN, 
		       NoSplit, 
		       maxmatchgroup, 
		       matchgroup, 
		       mheap);

	    if(DEBUG>=2 && !(alignid <= origalignid + alignblock)){
	      #pragma omp critical
	      {
		printf("tid=%d:PairId=%d/%d:rid=%d(id=%lld),mapid=%d(id=%lld),N=%d,M=%d:origalignid=%lu,alignid=%lu,alignblock=%d,alignment[%lu]=%p\n",
		       tid,PairId,NumPair1,rid,rmap->id,mapid,nanomap->id,N,M,origalignid,alignid,alignblock,origalignid,alignment[origalignid]);
		fflush(stdout);
		assert(alignid <= origalignid + alignblock);
	      }
	    }

	    for(int t = 0; t < alignblock; t++){
	      Calign * &align = alignment[origalignid + t];

	      if(align){
		if(DEBUG) assert(align->mapid1 == rid);
		if(DEBUG && t==0 && !(align->mapid2 == mapid)){
		  #pragma omp critical
		  {
		    printf("tid=%d:PairId=%d/%d:rid=%d(id=%lld),mapid=%d(id=%lld),N=%d,M=%d:origalignid=%lu,alignid=%lu,alignblock=%d:t=%d,align->mapid2=%d,or=%d,alignment[%lu]=%p\n",
			   tid,PairId,NumPair1,rid,rmap->id,mapid,nanomap->id,N,M,origalignid,alignid,alignblock,t,align->mapid2,align->orientation,origalignid,alignment[origalignid]);
		    fflush(stdout);
		    assert(align->mapid2 == mapid);
		  }
		}
		if(DEBUG) assert(Gmap[align->mapid2]->id == Gmap[mapid]->id);
		
		if(AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold)){/* good alignment */
		  if(t == 0){
		    Cmap *origmap = nanomap;
		    while(origmap->origmap)
		      origmap = origmap->origmap;
		    if(TSAN || origmap->nalign->mapid1 < 0 || (BESTREF_PV ? (align->logPV > origmap->nalign->logPV + BestRefMargin * (rid > origmap->nalign->mapid1 ? 1.0 : -1.0)) :
							       (align->score > origmap->nalign->score + BestRefMargin * (rid > origmap->nalign->mapid1 ? 1.0 : -1.0)))){
                      #pragma omp critical(nalignlock)
		      {
			if(origmap->nalign->mapid1 < 0 || (BESTREF_PV ? (align->logPV > origmap->nalign->logPV + BestRefMargin * (rid > origmap->nalign->mapid1 ? 1.0 : -1.0)) :
							   (align->score > origmap->nalign->score + BestRefMargin * (rid > origmap->nalign->mapid1 ? 1.0 : -1.0)))){
			  if(VERB>=2 && nanomap->id == MAP_TRACE && origmap->nalign->mapid1 >= 0){
			    printf("refid=%d,mapid=%d:align->score=%0.6f,logPV=%0.2f,numpairs=%d,or=%d, best refid=%d -> %d\n",
				   refid,mapid,align->score,align->logPV,align->numpairs,align->orientation, (origmap->nalign->mapid1 < 0 ? -1 : origmap->nalign->mapid1), align->mapid1);
			    if(origmap->nalign->mapid1 >= 0)
			      printf("   previous nalign->score=%0.6f,logPV=%0.2f,numpairs=%d,or=%d\n", origmap->nalign->score,origmap->nalign->logPV,origmap->nalign->numpairs,origmap->nalign->orientation);
			    fflush(stdout);
			  }
			  origmap->nalign->update(*align, N);/* save best alignment for next iteration */
			}
		      }
		    }
		    if(DEBUG>=2) assert(origmap->nalign->mapid1 >= 0);
		  }

		  Tmapcnt++;

		  if(FirstAlignments && Tmapcnt >= 16){
                    #pragma omp critical
		    {
		      mapcnt += Tmapcnt;
		      Tmapcnt = 0;
		    }
		  }
		}
              }

	      if(VERB>=2 && nanomap->id == MAP_TRACE /* && giter == RefRepeats-1 */){
                #pragma omp critical
		{
		  if(!align || align->numpairs <= 0){
	            if(VERB>=2 && t==0)
		      printf("refid=%d(id=%lld),mapid=%d(id=%lld),M=%d:No alignment found(tid=%d,PairId=%d),t=%d\n",
			rid,refmap[rid]->id,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0],tid,PairId,t);
		  } else if (!(AlignedThreshold(align,rmap->site[0], ScoreThreshold, LogPvThreshold))){/* no good alignment */
	            if(VERB>=2 && t==0)
		      printf("refid=%d(id=%lld),mapid=%d(id=%lld),M=%d:No good alignment:score=%0.4f,logPV=%0.3f,or=%d,scale=%d(%0.4f),pairs=%d,maxoutlier=%0.4f,Lend=%d,Rend=%d,len=%0.3f(tid=%d,PairId=%d),t=%d\n",
			rid,refmap[rid]->id,mapid,Gmap[mapid]->id, Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, align->scaleID, align->scaleID ? ScaleFactor[align->scaleID] : 1.0,
			align->numpairs,align->maxoutlier,align->Lend,align->Rend, X[M+1]*origPixelLen/PixelLen,tid,PairId,t);
		  } else {
		    Cmap *origmap = nanomap;
		    while(origmap->origmap)
		      origmap = origmap->origmap;
		    printf("refid=%d(id=%lld),mapid=%d(id=%lld),M=%d:score=%0.4f,logPV=%0.3f,orientation=%d,scale=%d(%0.4f,hash=%d,inc=%0.4f,cum=%0.4f),pairs=%d,Lend=%d,Rend=%d(tid=%d,PairId=%d),mapcnt=%d,t=%d,repeat=%d,nalign->mapid1=%d\n",
			   rid,refmap[rid]->id,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, 
			   align->scaleID, align->scaleID ? ScaleFactor[align->scaleID] : 1.0, phash ? phash->scaleID : -1, nanomap->incscale,nanomap->cumscale,
			align->numpairs,align->Lend,align->Rend, tid, PairId, mapcnt,t,align->repeat, origmap->nalign->mapid1);
		    if(SecondBest && align->align2){
		      Calign *align2 = align->align2;
		      printf("    2nd Best:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.3f,pairs=%d\n",
			     align2->mapid1,align2->mapid2,Gmap[align2->mapid2]->id,align2->orientation,align2->score,align2->logPV,align2->numpairs);
		    }
		  }
		  fflush(stdout);
		}
	      } // pragma omp critical
            } // for t = 0 .. alignblock -1

	  } /* parallel for PairId = 0 .. NumPair1 - 1 */

          #pragma omp critical
	  {
	    mapcnt += Tmapcnt;
	    Tmapcnt=0;
	  }

	  /* free per-thread memory */
	  if(MIN_MEM && DIAGONAL>=2 && hashdelta && Fmem){
	    if(RA_MIN_TIME){// using mmap/madvise/munmap
	      /* Make sure last thread is not stuck in WaitForMemory() loop, even if it requires more than -maxmem memory : 
		 Incrementing PausedThreads for completed threads allows WaitForMemory() to recognize when all threads are either paused (in WaitForMemory()) or finished */
              #pragma omp critical(vmemTotsiz)
	      {
                PausedThreads++;
              }

	      if(munmap(&Fmem[-PADDING/sizeof(RFLOAT)], FmemSiz[tid])){
		int eno = errno;
		char *err = strerror(eno);

                #pragma omp critical
		{
	          printf("munmap(%p,%lld) failed: errno=%d:%s\n",Fmem, FmemSiz[tid], eno, err);
		  dumpmemmap();
		  fflush(stdout);exit(1);
	        }
	      }
	    } else // using posix_memalign/free
	      free(&Fmem[-PADDING/sizeof(RFLOAT)]);
          } 
		  
	  XPen_free(XPen);
	  if(MultiMatches) {
	    delete [] matchgroup; 
	    if(MATCHGROUP_HEAP) delete [] mheap;
          }
	} /* end of parallel section */

        PausedThreads = 0;

	double TotalMadv = 0.0, TotalSleep = 0.0, TotalBT = 0.0;
	if(RA_MIN_TIME)
	  for(int i = 0; i < numthreads;i++){
	    TotalMadv += FmemMadv[i];
	    TotalSleep += FmemSleep[i];
	    TotalBT += FmemBT[i];
	  }

	if(MIN_MEM_DEBUG || RA_MIN_TIME){
	  delete [] FmemSiz; 
	  FmemSiz = NULL;	
	}
	if(RA_MIN_TIME){
	  delete [] FmemMadv;
	  FmemMadv = NULL;
	  delete [] FmemSleep;
	  FmemSleep = NULL;
	  delete [] FmemBT;
	  FmemBT = NULL;
	  delete [] FmemHWM; 
	  FmemHWM = NULL;
	  delete [] FmemTime; 
	  FmemTime = NULL;
	}
	if(MIN_MEM_DEBUG){
  	  delete [] FmemRsiz; 
	  FmemRsiz = NULL;
	}

	if(VERB){
	  printf("[refid=%d..%d/%d:total alignments=%d (alignids=%llu..%llu,nummaps=%d), Madvise= %0.1f Gb/thread, Sleep= %0.6f, BT= %0.6f secs/thread: cum CPU time=%0.6f wall time=%0.6f secs\n",
		refid,refidend,numrefmaps,mapcnt,(unsigned long long)orignumaligns,(unsigned long long)numaligns-1,nummaps,
		 TotalMadv*1e-9/max(1,numthreads),TotalSleep/max(1,numthreads),TotalBT/max(1,numthreads),mtime(),wtime());
	  fflush(stdout);
	}

	if(DEBUG) NumPair1 = 0;

	if(MINMEM>=2){// does not help since score_init() memory prevents release of virtual memory
          delete rs_heap; 
	  rs_heap = new lightweight_heap(0,0);
	  if(VERB>=2){
	    printf("Reset lightweight heap\n");
	    fflush(stdout);
	  }
	}

	if(ALIGN_COMPRESS){/* compress alignment[numalign_start[refid]..numalign_end[refidend]-1] to remove NULL pointers */
	  size_t j = numalign_start[refid] = orignumaligns;
	  int rid = refid;
	  size_t k = j;
	  for(; k < numaligns; k++){
	    if(!alignment[k]){
	      k++;
	      break;
	    }
	    for(; rid < alignment[j]->mapid1; rid++)
	      numalign_start[rid+1] = numalign_end[rid] = j;
	    if(VERB>=3 && giter == RefRepeats - 1){
	      Calign *p = alignment[j];
	      printf("alignment[%lu]=%p:refid=%d,mapid=%d,or=%d:numpairs=%d,score=%0.6f,logPV=%0.2f\n",
		     j,p,p->mapid1,p->mapid2,p->orientation,p->numpairs,p->score,p->logPV);
	      fflush(stdout);
	    }
	    j++;
	  }
	  for(; k < numaligns; k++){
	    if(!alignment[k])
	      continue;
	    if(DEBUG>=2) assert(j < k);
	    if(DEBUG>=2) assert(alignment[j]==0);
	    alignment[j] = alignment[k];
	    alignment[k] = 0;
	    for(; alignment[j]->mapid1 > rid; rid++)
	      numalign_start[rid+1] = numalign_end[rid] = j;
	    if(VERB>=3 && giter == RefRepeats - 1){
	      Calign *p = alignment[j];
	      printf("alignment[%lu]=%p:refid=%d,mapid=%d,or=%d:numpairs=%d,score=%0.6f,logPV=%0.2f\n",
		     j,p,p->mapid1,p->mapid2,p->orientation,p->numpairs,p->score,p->logPV);
	      fflush(stdout);
	    }
	    j++;
	  }
	  if(VERB>=2 && j < numaligns){
	    printf("refid=%d..%d:reduced numaligns from %llu to %llu(rid=%d): CPU time=%0.6f wall time=%0.6f\n",
		   refid,refidend,(unsigned long long)numaligns,(unsigned long long)j,rid,mtime(),wtime());
	    fflush(stdout);
	  }
	  numalign_end[rid] = numaligns = j;
	  while(++rid < numrefmaps)
	    numalign_start[rid] = numalign_end[rid] = numaligns;
	  if(VERB>=2){
	    printf("After removing null alignments from refid=%d..%d (orignumaligns=%llu)\n",refid,refidend,(unsigned long long)orignumaligns);
	    for(int r = refid; r <= refidend; r++)
	      printf("   refid=%d:alignid=%lld..%lld\n",r, (long long)numalign_start[r],(long long)numalign_end[r]-1);
	    fflush(stdout);
	  }
	}

	if(MINMEM_GC){/* move all alignments in alignment[orignumaligns .. numaligns-1] into next Calign_block */
          size_t cnt = 0, pairs = 0, Msiz = 0; // (alignment_blockid < 0) ? maxaligns : 0;
	  for(size_t k = orignumaligns; k < numaligns; k++){
	    Calign *p = alignment[k];
	    cnt++;
	    pairs += p->numpairs;
	    if(MultiMatches && p->multicnt > 0){
	      Msiz += p->multicnt;
	      for(int t = 0; t < p->multicnt; t++)
		pairs += p->Malign[t]->numpairs;
	    }
	  }

	  if(VERB>=2){
	    long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
	    getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
	    printf("Allocating Calign_block for alignment[%lu..%lu] : cnt=%lu,pairs=%lu,Msiz=%lu: VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb\n",
		   orignumaligns,numaligns-1,cnt,pairs, Msiz, VmSize*1e-9, VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9);
	    fflush(stdout);
	  }

	  int block_id;
	  Calign_block *block = align_blockalloc(cnt+Msiz,pairs,Msiz,1,1,block_id);
	  if(DEBUG) assert(Msiz == block->Malignsiz);

#if 0
	  if(alignment_blockid < 0){ // Reallocate alignment[0..maxalign-1], so it is on the Calign_block
	    Calign **newalignment = &block->Malignblock[0];
	    memcpy(newalignment, alignment, maxaligns * sizeof(Calign *));
	    delete [] alignment;
	    alignment = newalignment;
	    alignment_blockid = block_id;
	  }
#endif

	  size_t offset = 0, offsetp = 0, Moffset = 0;// maxaligns;

	  for(size_t i = orignumaligns; i < numaligns; i++){
	    Calign *p = alignment[i];

	    /* first allocate & copy main alignment */
	    Calign *q = &block->block[offset];
	    if(DEBUG>=2) assert(offset+1 <= block->numaligns);
	    *q = *p;// copy all scalars

	    size_t nump = p->numpairs;
	    q->block_id = block_id;
	    q->allocated_size = nump;
	    size_t Ioffset = 3*offsetp;
	    size_t Foffset = 2*(offsetp + offset);

	    offset++;
	    offsetp += nump;
	    if(DEBUG>=2) assert(offset <= cnt + Msiz);
	    if(DEBUG>=2 && !(offset == (i-orignumaligns+1) + Moffset)){
	      printf("i=%lu(%lu..%lu):nump=%lu,Ioffset=%lu(intsiz=%lu),Foffset=%lu(scoresiz=%lu),Moffset=%lu(Malignsiz=%lu):offsetp=%lu,offset=%lu(cnt=%lu,pairs=%lu,Msiz=%lu)\n",
		     i,orignumaligns,numaligns,nump,Ioffset,block->intsiz,Foffset,block->scoresiz,Moffset,block->Malignsiz,offsetp,offset,cnt,pairs,Msiz);
	      fflush(stdout);
	      assert(offset == (i-orignumaligns+1) + Moffset);
	    }
	    if(DEBUG>=2) assert(offsetp <= pairs);

	    q->sites1 = &block->intblock[Ioffset];
	    q->sites2 = &block->intblock[Ioffset+nump];
	    q->sitesK1 = &block->intblock[Ioffset+nump*2];
	    if(DEBUG>=2) assert(Ioffset + 3*nump <= block->intsiz);
	    q->iscore = &block->scoreblock[Foffset];
	    q->outscore = &block->scoreblock[Foffset+nump+1];
	    if(DEBUG>=2) assert(Foffset+2*(nump+1) <= block->scoresiz);

	    memcpy(q->sites1,p->sites1, nump * sizeof(int));
	    memcpy(q->sites2,p->sites2, nump * sizeof(int));
	    memcpy(q->sitesK1,p->sitesK1,nump * sizeof(int));
	    if(DEBUG>=2) assert((char *)(&q->sitesK1[nump]) <= ((char*)block->block) + block->memsiz);
	    memcpy(q->iscore,p->iscore, (nump+1) * sizeof(FLOAT));
	    memcpy(q->outscore,p->outscore, (nump+1) * sizeof(FLOAT));
	    if(DEBUG>=2) assert((char *)(&q->outscore[nump+1]) <= ((char*)block->block) + block->memsiz);	      
	    q->Malign = NULL;

	    if(DEBUG>=2) assert(q->multicnt == p->multicnt);

	    if(MultiMatches && p->Malign != NULL){/* allocate and copy p->Malign[0..p->multicnt-1][0] */
	      if(DEBUG/* HERE HERE >=2 */) assert(q->multicnt > 0);
	      q->Malign = &block->Malignblock[Moffset];
	      if(DEBUG>=2 && !((char *)(&q->Malign[q->multicnt]) <= ((char*)block->block) + block->memsiz)){
		printf("i=%lu(%lu..%lu):multicnt=%d,Moffset=%lu, &q->Malign[q->multicnt] = &block[%lu], memsiz=%lu\n",
		       i,orignumaligns,numaligns,q->multicnt,Moffset,(char *)(&q->Malign[q->multicnt]) - ((char*)block->block), block->memsiz);
		fflush(stdout);
		assert((char *)(&q->Malign[q->multicnt]) <= ((char*)block->block) + block->memsiz);	      
	      }
	      Moffset += q->multicnt;
	      if(DEBUG>=2) assert(Moffset <= block->Malignsiz);

	      for(int t = 0; t < q->multicnt; t++){
	        Calign *r = q->Malign[t] = &block->block[offset /*  + t */];


		*r = p->Malign[t][0];// copy scalars
		if(DEBUG>=2) assert(r->Malign == NULL);
		r->multicnt = 0;
		  
		size_t nump = r->numpairs;
		if(DEBUG>=2) assert(nump > 0);
		r->block_id = block_id;
		r->allocated_size = nump;
		size_t Ioffset = 3*offsetp;
		size_t Foffset = 2*(offsetp + offset);

		offset++;
		offsetp += nump;

		if(DEBUG>=2 && !(offset <= cnt + Msiz && offset == (i-orignumaligns+1) + Moffset - q->multicnt + t+1)){
		  printf("i=%lu(%lu..%lu):t=%d/%d:nump=%lu,Ioffset=%lu(intsiz=%lu),Foffset=%lu(scoresiz=%lu),Moffset=%lu(Malignsiz=%lu):offsetp=%lu,offset=%lu(cnt=%lu,pairs=%lu,Msiz=%lu)\n",
			 i,orignumaligns,numaligns,t,q->multicnt,nump,Ioffset,block->intsiz,Foffset,block->scoresiz,Moffset,block->Malignsiz,offsetp,offset,cnt,pairs,Msiz);
		  fflush(stdout);
		  assert(offset <= cnt + Msiz);
		  assert(offset == (i-orignumaligns+1) + Moffset - q->multicnt + t+1);
		}
		if(DEBUG>=2) assert(offsetp <= pairs);

		r->sites1 = &block->intblock[Ioffset];
		r->sites2 = &block->intblock[Ioffset+nump];
		r->sitesK1 = &block->intblock[Ioffset+nump*2];
		if(DEBUG>=2 && !(Ioffset + 3*nump <= block->intsiz)){
		  printf("i=%lu(%lu..%lu):t=%d/%d:nump=%lu,Ioffset=%lu(intsiz=%lu),Foffset=%lu(scoresiz=%lu),Moffset=%lu(Malignsiz=%lu):offsetp=%lu,offset=%lu(cnt=%lu,pairs=%lu,Msiz=%lu)\n",
			 i,orignumaligns,numaligns,t,q->multicnt,nump,Ioffset,block->intsiz,Foffset,block->scoresiz,Moffset,block->Malignsiz,offsetp,offset,cnt,pairs,Msiz);
		  fflush(stdout);
		  assert(Ioffset + 3*nump <= block->intsiz);
		}
		r->iscore = &block->scoreblock[Foffset];
		r->outscore = &block->scoreblock[Foffset + nump+1];
		if(DEBUG>=2) assert(Foffset + 2*(nump+1) <= block->scoresiz);

		memcpy(r->sites1,p->Malign[t]->sites1, nump * sizeof(int));
		memcpy(r->sites2,p->Malign[t]->sites2, nump * sizeof(int));
		memcpy(r->sitesK1,p->Malign[t]->sitesK1, nump * sizeof(int));
		if(DEBUG>=2) assert((char *)(&r->sitesK1[nump]) <= ((char*)block->block) + block->memsiz);
		memcpy(r->iscore,p->Malign[t]->iscore, (nump+1) * sizeof(FLOAT));
		memcpy(r->outscore,p->Malign[t]->outscore, (nump+1) * sizeof(FLOAT));
		if(DEBUG>=2 && !((char *)(&r->outscore[nump+1]) <= ((char*)block->block) + block->memsiz)){	      
		  printf("i=%lu(%lu..%lu):t=%d/%d:nump=%lu,Ioffset=%lu(intsiz=%lu),Foffset=%lu(scoresiz=%lu),Moffset=%lu(Malignsiz=%lu):r->outscore[nump+1]= &block[%lu], memsiz=%lu\n",
			 i,orignumaligns,numaligns,t,q->multicnt,nump,Ioffset,block->intsiz,Foffset,block->scoresiz,Moffset,block->Malignsiz,(char*)&r->outscore[nump+1] - (char*)block->block,block->memsiz);
		  fflush(stdout);
		  assert((char *)(&r->outscore[nump+1]) <= ((char*)block->block) + block->memsiz);	      
		}
	      }// for t = 0 .. q->multicnt - 1

	      if(DEBUG>=2) assert(offset <= block->numaligns);
	    } // if(MultiMatches && p->Malign != NULL)   

	    if(p->block_id < 0)
	      delete [] alignment[i];

	    alignment[i] = q;
	  } // for i = orignumaligns .. numaligns - 1

	  if(VERB>=2){
	    long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
	    getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
	    printf("Before malloc_trim(0) for alignment[%lu..%lu] : cnt=%lu,pairs=%lu,Msiz=%lu: VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb\n",
		orignumaligns,numaligns-1,cnt,pairs, Msiz, VmSize*1e-9, VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9);
	    fflush(stdout);
	  }
	  malloc_trim(0);
	  if(VERB){
	    long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
	    getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
	    printf("After allocating Calign_block for alignment[%lu..%lu] : cnt=%lu,pairs=%lu,Msiz=%lu: VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb\n",
		orignumaligns,numaligns-1,cnt,pairs, Msiz, VmSize*1e-9, VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9);
	    if(VERB>=2) malloc_stats();
	    fflush(stdout);
	  }
	  if(DEBUG) assert(offset <= cnt + Msiz);
	  if(DEBUG) assert(offsetp <= pairs);
	  if(DEBUG) assert(Moffset <= Msiz);
        }// if(MINMEM_GC)

      }/* refid = 0 .. numrefmaps-1 */

    } else { /* No hashtable */
      if(DEBUG) assert(!HashMultiMatch);
      if(DEBUG) assert(!nexthash1);
      if(DEBUG) assert(!HashFP);
      if(DEBUG && !CmapStart && !(nummaps == startmaps)){
        printf("nummaps=%d,startmaps=%d,totalmaps=%d\n", nummaps,startmaps,totalmaps);
	fflush(stdout);
        assert(nummaps == startmaps);
      }
      if(DEBUG) assert(nummaps <= startmaps);
      if(DEBUG) assert(startmaps <= totalmaps);
      if(DEBUG && NoSplit==2 && !(startmaps == totalmaps)){
        printf("nummaps=%d,startmaps=%d,totalmaps=%d\n", nummaps,startmaps,totalmaps);
	fflush(stdout);
	assert(startmaps == totalmaps);
      }

      if(NoSplit < 2){/* original code without YidList[],XidList[] */
       for(int refid = 0;refid < numrefmaps;refid++){
	Cmap *rmap = refmap[refid];
	int N = rmap->numsite[0];
	int *Kmax = RKmax[refid];

	orignummaps[refid] = totalmaps;/* skip maps from nummaps..orignummaps[refid]-1 for current refid (Not needed if NoSplit >= 2)*/
	numalign_start[refid] = numalign_end[refid] = numaligns;

	if(VERB && numrefmaps > 1){
	  printf("refid=%d/%d(id=%lld),sites=%d:\n",refid,numrefmaps,refmap[refid]->id,N);
	  fflush(stdout);
	}
	if(VERB>=2){
	  printf("iter=%d,refid=%d:nummaps=%d,totalmaps=%d,numaligns=%llu=numalign_start[refid]=numalign_end[refid]\n",giter,refid,nummaps,totalmaps,(unsigned long long)numaligns);
	  fflush(stdout);
	}

	numaligns += nummaps;
	maxalignallocNULL(numaligns,alignment,numaligns,maxaligns,&alignment_blockid);
	numalign_end[refid] = numaligns;
      
	/* determine pcnt = sum of K+1 values for reference map */
	/* NOTE: With FLAT_MEMORY pcnt is only used to estimate real memory and adjusted the number of threads */
	long long limN = MINMEM ? N : maxN;
	pcnt = 0;
	for(int I=1; I <= N; I++)
	  pcnt += Kmax[I]+1;
	if(DEBUG) assert(pcnt >= 0 && pcnt <= MAXINT);

	size_t DPsiz = DPsizF * sizeof(RFLOAT) + DPsizI * sizeof(int);
	long long virtperthread_size = (limN+maxM) * (2LL*sizeof(int *)) + (1LL + kmax) * limN * maxM * DPsiz + /* alignment fudge */ (6+1)*CACHE_LINE_GUARD*sizeof(float);
	long long perthread_size = pcnt * maxM  * DPsiz;

	/* determine number of threads (numthreads) to use */
	int numthreads = 1;
        #ifdef _OPENMP
	numthreads = MaxThreads; // WAS omp_get_max_threads();
	//	numthreads = min(numthreads,MaxThreads);
	if(MaxMem > 0 && pcnt > 0 && maxM > 0){/* NOTE : maxM, the largest map size, is computed in score_init() */
	  double virtperthread = virtperthread_size + sizeof(AL);// virtual memory used per thread
	  double memperthread = perthread_size + sizeof(AL);// Estimate of real memory used per thread
	  double maxmem = (double)MaxMem * 1024.0 * 1024.0 * 1024.0 - score_init_mem;
	  //	  int limitthreads = max(1,(int)floor(maxmem/virtperthread + 0.5));
	  //	  int limitthreads = max(1,(int)floor(maxmem/memperthread + 0.5));
	  int limitthreads = max(1,(int)floor(maxmem/min(virtperthread*0.33,memperthread) + 0.5));
	  if(limitthreads < numthreads){
	    if(VERB){
	      printf("refid=%d(id=%lld): number of threads reduced from %d to %d due to MaxMem=%0.1f Gbytes, Score=%0.3f Gbytes, per thread virtual memory = %0.3f Gbytes, real memory ~ %0.3f Gbytes:N=%d,limN=%lld,kmax=%d,pcnt=%lld,maxM=%lld\n",
		     refid,refmap[refid]->id, numthreads,limitthreads, MaxMem, score_init_mem/(1024.0*1024.0*1024.0), 
		     virtperthread/(1024.0*1024.0*1024.0), memperthread/(1024.0*1024.0*1024.0), N, limN,kmax,pcnt,maxM);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(limitthreads >= 1);
	    numthreads = limitthreads;
	  } else if(VERB>=2){
	    printf("refid=%d(id=%lld): numthreads=%d, MaxMem=%0.1f Gbytes, Score=%0.3f Gbytes, per thread virtual memory = %0.3f Gbytes, real memory ~ %0.3f Gbytes:N=%d,pcnt=%lld,maxM=%lld\n",
	      refid,refmap[refid]->id, numthreads, MaxMem, score_init_mem/(1024.0*1024.0*1024.0), 
	      virtperthread/(1024.0*1024.0*1024.0), memperthread/(1024.0*1024.0*1024.0), N, pcnt,maxM);
	    fflush(stdout);
	  }
	}
	if(numthreads > nummaps)
	  numthreads = max(1,nummaps);
        #endif

	int block = min(16,max(1,nummaps/(64*numthreads)));
	//	numthreads = 1;
	if(VERB && (VERB>=2 || numthreads != thread_printed)){
	  printf("refid=%d:Using %d threads(nummaps=%d,block=%d)\n",refid,numthreads,nummaps,block);
	  fflush(stdout);
	  thread_printed = numthreads;
	}

	pcnt = (1LL + kmax) * limN;
	if(VERB>=2){
	  printf("refid=%d:kmax=%d,limN=%lld,maxM=%lld\n",refid,kmax,limN,maxM);
	  fflush(stdout);
	}
	rs_heap->reset_lightweight_heap(virtperthread_size, numthreads);
            
	NumThreads = max(1,numthreads);
	PausedThreads = 0;

	/* Multi-threaded work section : alignments of refid with mapid = 0..nummaps-1 (no hashtable && NoSplit < 2) */

	#pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	{
	  int tid = 0;
          #ifdef _OPENMP
	  tid = omp_get_thread_num ();
          #endif

	  /* each thread needs its own local memory */

	  int maxmatchgroup = 0;
	  Cmatchgroup *matchgroup = NULL;
	  Cmatchgroup **mheap = NULL;

	  CXPen XPenMem;
	  CXPen *XPen = &XPenMem;
	  XPen_alloc(XPen);

	  long long StrideMax = 0;/* will not be used without hashtable : see following assertion */
	  long long KstrideMax = 0;

	  /* allocate DP array A.<field>(I=1..N, K=0..kmax, J=1..M) */
	  AL A;
	  A.kmax = A.KMAX = kmax;
	  if(sizeof(A.Kstride) < sizeof(long long) && (long long)limN * (long long)maxM * (long long) kmax > MASK(31)){
	    printf("limN=%lld,maxM=%lld,kmax=%d: limN * maxM * kmax exceeds signed integer range : change Kstride to long long in refalign.cpp\n",limN,maxM,kmax);
	    fflush(stdout);exit(1);
	  }
	  if(sizeof(A.Istride) < sizeof(long long) && (long long)maxM > MASK(31)){
	    printf("maxM=%lld: maxM exceeds signed integer range : change Istride to long long in refalign.cpp\n",maxM);
	    fflush(stdout);exit(1);
	  }
	  RFLOAT *Fmem = rs_heap->alloc_RFLOAT(pcnt * maxM * DPsizF, tid);
	  int *Imem = rs_heap->alloc_int(pcnt * maxM * DPsizI, tid);

	  int *JMIN = rs_heap->alloc_int(limN,tid) - 1;
	  int *JMAX = rs_heap->alloc_int(limN,tid) - 1;
	  int *Imin = rs_heap->alloc_int(maxM,tid) - 1;
	  int *Imax = rs_heap->alloc_int(maxM,tid) - 1;

	  if(VERB>=2){
            #pragma omp critical
	    {
	      printf("thread=%d/%d:memory allocated:block size=%d maps, pcnt=%lld,N=%d,kmax=%d,maxM=%lld,limN=%lld,Fmem=%p,Imem=%p,Imax=%p,end=%p\n",
	         tid,numthreads,block,pcnt,N,kmax,maxM,limN,Fmem,Imem,Imax,Imax+maxM*sizeof(int));
	      fflush(stdout);
	    }
	  }
	
	  int Tmapcnt = 0;

	  /* NOTE: If NoSplit <= 1 : loop must be broken into two parts since loop bounds cannot change inside parallel loop */
	  if(DEBUG) assert(nummaps <= orignummaps[refid]);

#if !USE_MIC
          #pragma omp for schedule(dynamic, block)
#endif
	  for(int mapid = 0;mapid < nummaps;mapid++){
	    if(USE_MIC && !(((mapid / 16) % numthreads) == tid)){ // NOTE : simulates #pragma omp for schedule(static,16)
	      continue;
	    }

	    if(FirstAlignments && mapcnt + Tmapcnt >= FirstAlignments)
	      continue;	  // NOTE : multithreaded loop is not determininistic since mapcnt is not synchronized

	    size_t alignid = numalign_start[refid] + mapid;
	    if(DEBUG) assert(alignid < numaligns);
	    if(DEBUG) assert(mapid < orignummaps[refid]);
	    Calign * &align = alignment[alignid];// NOTE : pointer value may change in refalignSD !

	    if(VERB && nummaps > 1000*numthreads && !(mapid%(1000*numthreads))){
              #pragma omp critical
	      {
		mapcnt += Tmapcnt;
		Tmapcnt = 0;
      		if(HASH_DEBUG)
		  printf("[refid=%d/%d,mapid=%d/%d,alignments=%d+]: CPU time=%0.6f, wall time=%0.6f secs\n",refid,numrefmaps,mapid,nummaps,mapcnt, mtime(),wtime());
		else
		  printf("[refid=%d/%d,mapid=%d/%d]\n",refid,numrefmaps,mapid,nummaps);
		fflush(stdout);
	      } // omp critical
	    }

	    Cmap *nanomap = Gmap[mapid];
	    if(DEBUG>=2) assert(nanomap != 0);
	    if(DEBUG>=2 && !(nanomap->mapid == mapid)){
	      #pragma omp critical
	      {
		printf("mapid=%d:Gmap[mapid]->mapid=%d\n",mapid,Gmap[mapid]->mapid);
		fflush(stdout);
		assert(nanomap->mapid == mapid);
	      }
	    }
	    int M = nanomap->numsite[0];
	    FLOAT *X = nanomap->site[0];
	    //	    nanomap->incscale = 1.0;
	    //	    nanomap->incwt = 0.0;

	    refalignSD(rmap, nanomap, alignid, RKmax, refid, mapid, 0, XPen, &A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, tid, numthreads, limN, NoSplit, maxmatchgroup, matchgroup, mheap);

	    if(DEBUG && align) assert(align->mapid1 == refid);
	    if(DEBUG && align) assert(align->mapid2 == mapid);

	    if(align && AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold)){/* good alignment */
	      Cmap *origmap = nanomap;
	      while(origmap->origmap)
		origmap = origmap->origmap;

	      if(origmap->nalign->mapid1 < 0 || (BESTREF_PV ? (align->logPV > origmap->nalign->logPV + BestRefMargin * (refid > origmap->nalign->mapid1 ? 1.0 : -1.0)) :
						 (align->score > origmap->nalign->score + BestRefMargin * (refid > origmap->nalign->mapid1 ? 1.0 : -1.0)))){
                #pragma omp critical(nalignlock)
		{
		  if(origmap->nalign->mapid1 < 0 || (BESTREF_PV ? (align->logPV > origmap->nalign->logPV + BestRefMargin * (refid > origmap->nalign->mapid1 ? 1.0 : -1.0)) :
						 (align->score > origmap->nalign->score + BestRefMargin * (refid > origmap->nalign->mapid1 ? 1.0 : -1.0)))){
		    if(VERB>=2 && nanomap->id == MAP_TRACE){
		      printf("refid=%d,mapid=%d:align->score=%0.6f,logPV=%0.2f,numpairs=%d,or=%d, best refid=%d -> %d\n",
			     refid,mapid,align->score,align->logPV,align->numpairs,align->orientation, (origmap->nalign->mapid1 < 0 ? -1 : origmap->nalign->mapid1), align->mapid1);
		      if(origmap->nalign->mapid1 >= 0)
			printf("   previous nalign->score=%0.6f,logPV=%0.2f,numpairs=%d,or=%d\n", origmap->nalign->score,origmap->nalign->logPV,origmap->nalign->numpairs,origmap->nalign->orientation);
		      fflush(stdout);
		    }
		    origmap->nalign->update(*align, N);/* save best alignment for next iteration */
	          }
	        }
	      }
	      if(DEBUG>=2) assert(origmap->nalign->mapid1 >= 0);

	      Tmapcnt++;
	    }

	    if(VERB>=2 && nanomap->id == MAP_TRACE /* && giter == RefRepeats-1 */){
              #pragma omp critical
	      {
		mapcnt += Tmapcnt;
		Tmapcnt = 0;

		if(!align || align->numpairs <= 0){
		  //		  if(VERB>=2)
		    printf("refid=%d,mapid=%d(id=%lld),M=%d:no alignment found(thread=%d)\n",
			   refid,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0],tid);
		} else if (!(AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))){/* no good alignment */
		  //		  if(VERB>=2)
		    printf("refid=%d,mapid=%d(id=%lld),M=%d:no good alignment:score=%0.4f,logPV=%0.3f,orientation=%d,scale=%d(%0.4f),pairs=%d,Lend=%d,Rend=%d,len=%0.3f(thread=%d)\n",
			   refid,mapid,Gmap[mapid]->id, Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, align->scaleID, align->scaleID ? ScaleFactor[align->scaleID] : 1.0,
			   align->numpairs,align->Lend,align->Rend, X[M+1]*origPixelLen/PixelLen,tid);
		} else {
		  Cmap *origmap = nanomap;
		  while(origmap->origmap)
		    origmap = origmap->origmap;

		  printf("refid=%d,mapid=%d,M=%d:score=%0.4f,logPV=%0.3f,orientation=%d,scale=%d(%0.4f),pairs=%d,Lend=%d,Rend=%d(thread=%d),mapcnt=%d,nalign->mapid1=%d\n",
			 refid,mapid,Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, align->scaleID, align->scaleID ? ScaleFactor[align->scaleID] : 1.0, align->numpairs,align->Lend,align->Rend, tid,
			 mapcnt+Tmapcnt, origmap->nalign->mapid1);
		}
		fflush(stdout);
	      } // pragma omp critical
	    }
	  } /* parallel for mapid = 0 .. nummaps -1 */

	  int start = orignummaps[refid];
	  int lim = totalmaps;
	  if(DEBUG && NoSplit >= 2) assert(start == lim);

	  if(VERB>=2){
	    #pragma omp critical
	    {
	      mapcnt += Tmapcnt;
	      Tmapcnt = 0;
	    }

	    if(numthreads > 1){
              #pragma omp barrier
	    }

	    #pragma omp master
	    {
	      printf("[refid=%d:total alignments=%d/%llu (alignids=%llu..%llu,nummaps=%d,totalmaps=%d)],start=%d,lim=%d: cum CPU time=%0.6f wall time=%0.6f secs\n",
		     refid,Tmapcnt + mapcnt,(unsigned long long)numaligns,(unsigned long long)numalign_start[refid],(unsigned long long)numalign_end[refid]-1,nummaps,totalmaps,start,lim,mtime(),wtime());
	      fflush(stdout);
	    }
	  }

	  while(start < lim){/* loop if more map splits are produced */
	    if(FirstAlignments && mapcnt + Tmapcnt > FirstAlignments)
	      break;

	    if(VERB>=2){
              #pragma omp master
	      {
		printf("refid=%d/%d(id=%lld),sites=%d:processing map splits (%d..%d):alignids so far=%llu..%llu\n",
		       refid,numrefmaps,refmap[refid]->id,N,start,lim-1, (unsigned long long)numalign_start[refid],(unsigned long long)numalign_end[refid]-1);
		fflush(stdout);
	      }
	    }

	    /* allocate enough memory for alignment[] array before entering multithreaded loop */
	    size_t alignidstart = numalign_start[refid] + start - (orignummaps[refid] - nummaps);
	    #pragma omp master
	    {
	      size_t alignid = numalign_start[refid] + lim - (orignummaps[refid] - nummaps);
	      if(VERB>=2){
		printf("maxalignallocNULL(%llu):refid=%d,numalign_start[refid]=%llu,lim=%d,orignummaps[refid]=%d,nummaps=%d,start=%d,numaligns=%llu\n",
		       (unsigned long long)alignid,refid,(unsigned long long)numalign_start[refid],lim,orignummaps[refid],nummaps,start,(unsigned long long)numaligns);
		fflush(stdout);
	      }
	      maxalignallocNULL(alignid,alignment,numaligns,maxaligns,&alignment_blockid);
	      numalign_end[refid] = numaligns = max(numaligns,alignid);
	    }

	    if(numthreads > 1){
              #pragma omp barrier
	    }

	    int block = min(3,max(1,(lim-start)/(64*numthreads)));
	  
#if !USE_MIC
            #pragma omp for schedule(dynamic,block)
#endif
	    for(int mapid = start;mapid < lim;mapid++){
	      if(USE_MIC && !(((mapid / 16) % numthreads) == tid)) { // NOTE : simulates #pragma omp for schedule(static,16)
	        continue;
	      }

	      size_t alignid = numalign_start[refid] + mapid - (orignummaps[refid] - nummaps);
	      if(DEBUG>=2) assert(0 <= alignid && alignid < numaligns);

	      Calign * &align = alignment[alignid];// NOTE : pointer value may change in refalignSD !
	      Cmap *nanomap = Gmap[mapid];
	      if(DEBUG>=2) assert(nanomap != 0);
	      if(DEBUG>=2) assert(nanomap->mapid == mapid);
	      int M = nanomap->numsite[0];
	      FLOAT *X = nanomap->site[0];

	      if(VERB && nummaps > 1000 && !(mapid%1000)){
                #pragma omp critical
		{
		  mapcnt += Tmapcnt;
		  Tmapcnt = 0;
		  printf("[refid=%d/%d,mapid=%d/%d,alignments=%d]\n",refid,numrefmaps,mapid,nummaps,mapcnt);
		  fflush(stdout);
		} // omp critical
	      }

	      nanomap->incscale = 1.0;// WAS 0.0
	      nanomap->incwt = nanomap->xysum = nanomap->y2sum = 0.0;
#if 0
	      nanomap->xsum = nanomap->Ylen = nanomap->Xlen = 0.0;
#endif

	      refalignSD(rmap, nanomap, alignid, RKmax, refid, mapid, 0, XPen, &A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, tid, numthreads, limN, NoSplit, maxmatchgroup, matchgroup, mheap);

	      if(DEBUG && align) assert(align->mapid1 == refid);
	      if(DEBUG && align) assert(align->mapid2 == mapid);

	      if(align && AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))/* good alignment */
		Tmapcnt++;
	      if(VERB>=2 && giter == RefRepeats-1){
                #pragma omp critical
		{
		  mapcnt += Tmapcnt;
		  Tmapcnt = 0;

		  if(!align || align->numpairs <= 0)
		    printf("refid=%d,mapid=%d(id=%lld),M=%d:no alignment found(thread=%d)\n",
			   refid,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0],tid);
		  else if (!(AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold)))/* no good alignment */
		    printf("refid=%d,mapid=%d(id=%lld),M=%d:no good alignment:score=%0.4f,logPV=%0.3f,orientation=%d,scale=%d(%0.4f),pairs=%d,Lend=%d,Rend=%d,len=%0.3f(thread=%d)\n",
			   refid,mapid,Gmap[mapid]->id, Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, align->scaleID, align->scaleID ? ScaleFactor[align->scaleID] : 1.0,
			   align->numpairs,align->Lend,align->Rend, X[M+1]*origPixelLen/PixelLen,tid);
		  else
		    printf("refid=%d,mapid=%d,M=%d:score=%0.4f,logPV=%0.3f,orientation=%d,scale=%d(%0.4f),pairs=%d,Lend=%d,Rend=%d(thread=%d),mapcnt=%d\n",
			   refid,mapid,Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, align->scaleID, align->scaleID ? ScaleFactor[align->scaleID] : 1.0, align->numpairs,align->Lend,align->Rend, tid,mapcnt);
		  fflush(stdout);
		} // pragma omp critical
	      } // VERB>=2 
	    } /* 2nd parallel for mapid = orignummaps[refid] .. nummaps -1 */

	    if(VERB>=2){
	      if(numthreads > 1){
                #pragma omp barrier
	      }
	      #pragma omp master
	      {
		printf("Split Alignments from %d map splits:\n",lim-start);
		for(size_t i = alignidstart; i < numaligns; i++){
		  Calign *align = alignment[i];
		  if(!align || align->numpairs <= 0)
		    continue;
		  if(AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
		    printf("%lu:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.3f,pairs=%d,Lend=%d,Rend=%d\n",
			   i,align->mapid1,align->mapid2,Gmap[align->mapid2]->id,align->orientation,align->score,align->logPV,align->numpairs,align->Lend,align->Rend);
		}
		fflush(stdout);
	      }
	    }

	    start = lim;
	    lim = totalmaps;
	    if(DEBUG && NoSplit > 0) assert(start >= lim);
	  } /* while (start < lim)  */

          #pragma omp critical
	  {
	    mapcnt += Tmapcnt;
	    Tmapcnt=0;
	  }

	  if(totalmaps > lim && !warning2){
            #pragma omp critical 
	    {
	      warning2 = 1;
	      printf("WARNING: parallel loop bound exceeded : may have missed some alignments:totalmaps=%d,lim=%d\n",totalmaps,lim);
	      fflush(stdout);
	    }
	  }

	  /* free per-thread memory */
	  XPen_free(XPen);
	  if(MultiMatches){
	    delete [] matchgroup;
	    if(MATCHGROUP_HEAP) delete [] mheap;
	  }
	} /* end of parallel section */

	if(VERB){
	  printf("[refid=%d:total alignments=%d/%llu (alignids=%llu..%llu,nummaps=%d,totalmaps=%d)]: cum CPU time=%0.6f wall time=%0.6f secs\n",
		 refid,mapcnt,(unsigned long long)numaligns,(unsigned long long)numalign_start[refid],(unsigned long long)numalign_end[refid]-1,nummaps,totalmaps,mtime(),wtime());
	  fflush(stdout);
	}

	if(MINMEM>=2){// does not help since score_init() memory prevents release of virtual memory
          delete rs_heap; 
	  rs_heap = new lightweight_heap(0,0);
	  if(VERB>=2){
	    printf("Reset lightweight heap\n");
	    fflush(stdout);
	  }
	}

	if(ALIGN_COMPRESS){/* compress alignment[numalign_start[refid]..numalign_end[refid]-1] to remove NULL pointers */
	  size_t j = numalign_start[refid];
	  size_t k = j;
	  for(; k < numaligns; k++){
	    if(!alignment[k]){
	      k++;
	      break;
	    }
	    j++;
	  }
	  for(; k < numaligns; k++){
	    if(!alignment[k])
	      continue;
	    if(DEBUG>=2) assert(j < k);
	    if(DEBUG>=2) assert(alignment[j]==0);
	    alignment[j] = alignment[k];
	    alignment[k] = 0;
	    j++;
	  }
	  if(VERB>=2 && j < numaligns){
	    printf("reduced numalign_end[%d] from %llu to %llu (numalign_start[%d]=%llu)\n",refid,(unsigned long long)numalign_end[refid],(unsigned long long)j,refid,(unsigned long long)numalign_start[refid]);

	    for(size_t t = 0; t < j; t++){
	      Calign *align = alignment[t];
	      if(!align || align->numpairs <= 0)
		continue;
	      if(AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
		printf("%lu:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.3f,pairs=%d\n",
		       t,align->mapid1,align->mapid2,Gmap[align->mapid2]->id,align->orientation,align->score,align->logPV,align->numpairs);
	    }
	    fflush(stdout);
	  }
	  numalign_end[refid] = numaligns = j;
	}

       } /* refid 0..numrefmaps-1 */

      } else {/* new code with YidList[],XidList][] */

	int refidend = -1;

	for(int refid = 0;refid < numrefmaps; refid = refidend + 1){
	  refidend = refid;

	  Cmap *rmap = refmap[refidend];
	  int N = rmap->numsite[0];
	  FLOAT *Y = rmap->site[0];
	  orignummaps[refidend] = totalmaps;

	  if(N < max(1,AlignedSiteThreshold) || Y[N] <= Y[1] + max(res[0]*PixelLen, AlignedLengthThreshold)){
	    numalign_start[refid] = numalign_end[refid] = numaligns;
	    continue;
	  }

	  /* accumulate YidList1[0..NumPair1-1],XidList1[0..NumPair1-1] */
	  for(int mapid = 0; mapid < nummaps; mapid++){
	    YidList1[NumPair1] = refidend;
	    XidList1[NumPair1++] = mapid;
	  }

	  if(NoSplit >= 2){
	    while((NumPair1 <= 0 || NumPair1 + nummaps <= MaxPair) && refidend+1 < numrefmaps){
	      refidend++;

	      Cmap *rmap = refmap[refidend];
	      int N = rmap->numsite[0];
	      FLOAT *Y = rmap->site[0];
	      orignummaps[refidend] = totalmaps;

	      if(N < max(1,AlignedSiteThreshold) || Y[N] <= Y[1] + max(res[0]*PixelLen, AlignedLengthThreshold)){
		numalign_start[refid] = numalign_end[refid] = numaligns;
		continue;
	      }

	      for(int mapid = 0; mapid < nummaps; mapid++){
		YidList1[NumPair1] = refidend;
		XidList1[NumPair1++] = mapid;
	      }
	    }
	  }

	  if(DEBUG) assert(YidList1[0] >= refid && YidList1[NumPair1-1] <= refidend);

#if 0
	  /* HERE : randomize order of XidList1[],YidList1[]  ? */
	  for(int i = 1; i <= NumPair1; i++){/* swap randum element from i .. NumPair-1 with element i-1 */
	    int j = i + (rand() % (NumPair - i));
	    /* swap Yidlist1[i-1, j] */
	    int tmp = Yidlist1[j];
	    Yidlist1[j] = Yidlist1[i-1];
	    Yidlist1[i-1] = tmp;

	    /* swap Xidlist1[i-1, j] */
	    tmp = Xidlist1[j];
	    Xidlist1[j] = Xidlist1[i-1];
	    Xidlist1[i-1] = tmp;
	  }
#endif

	  if(VERB && numrefmaps > 1){
	    printf("refid=%d..%d/%d,NumPair1=%d:\n",refid,refidend,numrefmaps,NumPair1);
	    fflush(stdout);
	  }

	  if(VERB>=2){
	    printf("iter=%d,refid=%d:nummaps=%d,totalmaps=%d,numaligns=%llu=numalign_start[refid]=numalign_end[refid]\n",giter,refid,nummaps,totalmaps,(unsigned long long)numaligns);
	    fflush(stdout);
	  }

	  /* determine pcnt = sum of K+1 values for largest reference map in range refid .. refidend */
	  /* NOTE: this pcnt is only used to estimate real memory used. It is replaced by (1 + Kmax) * maxN to allocate virtual memory */

	  pcnt = 1;
	  int Ncnt = 1;
	  int NN = 0;
	  int alignblock = 1;// NOTE : NoSplit == 2
	  size_t orignumaligns = numaligns;
	  numaligns += NumPair1 * alignblock;
          maxalignallocNULL(numaligns,alignment,numaligns,maxaligns,&alignment_blockid);

	  double Ylambda = 0.0;
	  int Ycnt = 0;

	  for(int rid = refid; rid <= refidend; rid++){
	    Cmap *rmap = refmap[rid];
	    int N = rmap->numsite[0];
	    int *Kmax = RKmax[rid];
	    FLOAT *Y = rmap->site[0];

	    Ycnt += N;
	    Ylambda += Y[N+1];

	    if(N > NN)
	      NN = N;

	    long long pcnt_rid = 0;
	    for(int I=1; I <= N; I++)
	      pcnt_rid += Kmax[I] + 1;
	    if(0 && MIN_MEM && DIAGONAL>=2 && hashdelta){
	      if(pcnt_rid * Ncnt > pcnt * N){
		pcnt = pcnt_rid;// WAS max(pcnt, pcnt_rid);
		Ncnt = N;
	      }
	    } else {
	      if(pcnt_rid > pcnt){
		pcnt = pcnt_rid;
		Ncnt = N;
	      }
	    }
	  }
	  Ylambda = Ylambda / max(1,Ycnt);
	  if(DEBUG) assert(pcnt >= 0 && pcnt <= MAXINT);

	  if(VERB>=2){
	    printf("refid=%d..%d,nummaps=%d:numaligns=%llu->%llu,NumPair1=%d,refid1=%d..%d,refid2=%d..%d,Ylambda=%0.3f,Xlambda=%0.3f\n",refid,refidend,nummaps,
		   (unsigned long long)orignumaligns,(unsigned long long)numaligns,NumPair1,refid1,refidend1,refid2,refidend2,Ylambda,Xlambda);
	    fflush(stdout);
	  }

	  size_t DPsiz = DPsizF * sizeof(RFLOAT) + DPsizI * sizeof(int);
	  size_t virtperthread_size = (maxN+maxM) * (2LL*sizeof(int *)) + (1ul + kmax) * maxN * (maxM + 2*FENCE) * DPsiz + /* alignment fudge */ (6+1)*CACHE_LINE_GUARD*sizeof(float);
	  size_t perthread_size = pcnt * maxM  * DPsiz;

	  if(0 && MIN_MEM && DIAGONAL>=2 && hashdelta){
	    // base real memory used on estimated JMIN[]..JMAX[] ranges : approximately min(maxM, 2*max(DELTA_X,hashdelta)+1) * (maxM + 2*max(DELTA_Y,hashdelta)) * (pcnt/Ncnt)	  
	    long long ihashdelta = floor(hashdelta + 0.9999);
	    long long delX = DELTA_X, delY = DELTA_Y;
	    long long deltaJ = min(maxM, 2*(max(delX, ihashdelta)) + 1);
	    long long deltaI = maxM + 2*(max(delY, ihashdelta));
	    perthread_size = DPsiz * deltaJ * deltaI * pcnt / Ncnt;
	    virtperthread_size = DPsiz * deltaJ * deltaI * (1ul + kmax);// NEW 

	    if(Ylambda > 0.0 && Xlambda > Ylambda){	  /* correction when reference label density is higher than query label density */
	      double c = Xlambda / Ylambda;
	      perthread_size = DPsiz * (c * deltaI * (deltaJ + (c-1.0)*deltaI)) * pcnt/Ncnt;
	      virtperthread_size = DPsiz * (c * deltaI * (deltaJ + (c-1.0)*deltaI)) * (1ul + kmax);
	    }
	  }

	  /* determine number of threads (numthreads) to use */
	  int numthreads = 1;
#ifdef _OPENMP
	  numthreads = MaxThreads; // WAS omp_get_max_threads();
	  //	  numthreads = min(numthreads,MaxThreads);
	  if(MaxMem > 0 && pcnt > 0 && maxM > 0){/* NOTE : maxM, the largest map size, is computed in score_init() */
	    double virtperthread = virtperthread_size + sizeof(AL); // (1.0+kmax) * maxN * ( maxM * DPsiz) + sizeof(AL);// virtual memory used per thread
	    double memperthread = perthread_size + sizeof(AL); // (double)pcnt * (double)(maxM  * DPsiz) + sizeof(AL);// Estimate of real memory used per thread

	    //	    extern int numbufs;
	    double HashMem = 0.0;// MaxPair*2*(sizeof(CHashMatch) + sizeof(int)*2+sizeof(CHashMatch*)) + numbufs * HASHBUF_SIZ * 2 * sizeof(CHashMatch);
	    double GB = 1024.0*1024.0*1024;
	    double scoreWS = min(1.0, 4.0/numrefmaps);// NEW : max fraction of score memory likely to be in active use
	    double maxmem = (double)MaxMem * GB - score_init_mem * scoreWS - HashMem;
	    double maxvirtmem = (MaxVirtMem > 0.0) ? MaxVirtMem * GB : 1e+40;
	    long long VmSize = 0, VmRSS = 0, VmSwap = 0;

	    delete rs_heap;    /* free lightweight heap : this should release virtual memory space with glibc */
	    rs_heap = new lightweight_heap(0,0);
	    if(TotalThreads){
	      getmem(VmSize,VmRSS, VmSwap, &VmHWM);
	      realVmRSS = VmRSS;
	      if(DEBUG>=2 && !(VmRSS <= VmHWM)){
		printf("VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: wt= %0.6f\n",VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9,VmSize*1e-9,wtime());
		fflush(stdout);
		assert(VmRSS <= VmHWM);
	      }
	      long long score_swap = score_init_mem * (1.0 - scoreWS);
	      maxvirtmem -= min(VmSize, max(VmRSS, score_swap) + VmSwap);
	      //   maxmem -= VmRSS; // NOTE : this memory can be allowed to swap out
	    }

	    int limitthreads = max(1,(int)floor(min(maxmem/memperthread , maxvirtmem/virtperthread) + 0.5));
	    if(limitthreads < numthreads){
	      if(VERB){
		if(TotalThreads)
		  printf("refid=%d..%d: number of threads reduced from %d to %d due to MaxVirtMem=%0.6e(%0.6e)Gb,MaxMem=%0.4f(%0.4f)Gb, Score=%0.4f Gb, HashBuf=%0.4f Gb, per thread virtual memory = %0.4f Gb, real memory ~ %0.4f Gb, VmRSS=%0.4f,VmSwap=%0.4f,VMSize=%0.4f Gb:N<=%d,pcnt=%lld(maxN=%lld,kmax=%d),maxM=%lld\n",
			 refid,refidend, numthreads,limitthreads, MaxVirtMem, maxvirtmem/GB, MaxMem, maxmem/GB,score_init_mem/GB, HashMem/GB, virtperthread/GB,
			 memperthread/GB, VmRSS/GB, VmSwap/GB,VmSize/GB, NN,pcnt,maxN,kmax,maxM);
		else
		  printf("refid=%d..%d: number of threads reduced from %d to %d due to MaxVirtMem=%0.6e(%0.6e)Gb,MaxMem=%0.4f(%0.4f)Gb, Score=%0.4f Gb, HashBuf=%0.4f Gb, per thread virtual memory = %0.4f Gb, real memory ~ %0.4f Gb:N<=%d,pcnt=%lld(maxN=%lld,kmax=%d),maxM=%lld\n",
			 refid,refidend, numthreads,limitthreads, MaxVirtMem, maxvirtmem/GB, MaxMem, maxmem/GB,score_init_mem/GB, HashMem/GB, virtperthread/GB, memperthread/GB, NN,pcnt,maxN,kmax,maxM);
		fflush(stdout);
	      }
	      if(DEBUG) assert(limitthreads >= 1);
	      numthreads = limitthreads;
	    } else if(VERB>=2){
	      if(TotalThreads)
		printf("refid=%d..%d: number of threads=%d: MaxVirtMem=%0.4f(%0.6e)Gb,MaxMem=%0.4f(%0.4f)Gb, Score=%0.4f Gb, HashBuf=%0.4f Gb, per thread virtual memory = %0.4f Gb, real memory ~ %0.4f Gb, VmRSS=%0.4f,VmSwap=%0.4f,VMSize=%0.4f Gb:N<=%d,pcnt=%lld(maxN=%lld,kmax=%d),maxM=%lld\n",
		       refid,refidend, numthreads, MaxVirtMem, maxvirtmem/GB, MaxMem, maxmem/GB,score_init_mem/GB, HashMem/GB, virtperthread/GB,
		       memperthread/GB, VmRSS/GB, VmSwap/GB,VmSize/GB, NN,pcnt,maxN,kmax,maxM);
	      else
		printf("refid=%d..%d: number of threads=%d: MaxVirtMem=%0.4f(%0.6e)Gb,MaxMem=%0.4f(%0.4f)Gb, Score=%0.4f Gb, HashBuf=%0.4f Gb, per thread virtual memory = %0.4f Gb, real memory ~ %0.4f Gb:N<=%d,pcnt=%lld(maxN=%lld,kmax=%d),maxM=%lld\n",
		       refid,refidend, numthreads, MaxVirtMem, maxvirtmem/GB, MaxMem, maxmem/GB,score_init_mem/GB, HashMem/GB, virtperthread/GB, memperthread/GB, NN,pcnt,maxN,kmax,maxM);
	      fflush(stdout);
	    }
	  }

	  if(numthreads > NumPair1)
	    numthreads = max(1,NumPair1);

#endif

	  if(MIN_MEM_DEBUG || RA_MIN_TIME){
	    if(FmemSiz) delete [] FmemSiz;
	    FmemSiz = new long long[numthreads];
	    for(int i = 0; i < numthreads; i++)
	      FmemSiz[i] = 0;
	  }
	  if(RA_MIN_TIME){
	    if(FmemMadv) delete [] FmemMadv;
	    FmemMadv = new double[numthreads];
	    for(int i = 0; i < numthreads; i++)
	      FmemMadv[i] = 0.0;

	    if(FmemSleep) delete [] FmemSleep;
	    FmemSleep = new double[numthreads];
	    for(int i = 0; i < numthreads; i++)
	      FmemSleep[i] = 0.0;

	    if(FmemBT) delete [] FmemBT;
	    FmemBT = new double[numthreads];
	    for(int i = 0; i < numthreads; i++)
	      FmemBT[i] = 0.0;

	    if(FmemHWM) delete [] FmemHWM;
	    FmemHWM = new long long[numthreads];
	    if(FmemTime) delete [] FmemTime;
	    FmemTime = new double[numthreads];

	    for(int i = 0; i < numthreads; i++){
	      FmemHWM[i] = 0;
	      FmemTime[i] = wtime();
	    }
	  }
	  if(MIN_MEM_DEBUG){
	    if(FmemRsiz) delete [] FmemRsiz;
	    FmemRsiz = new long long[numthreads];
	    for(int i = 0; i < numthreads; i++)
	      FmemRsiz[i] = 0;
	  }

	  int block = min(16,max(1,NumPair1/((USE_MIC ? 16 : 64) * numthreads)));
	  //	  numthreads = 1;
	  if(VERB && (VERB>=2 || numthreads != thread_printed)){
	    printf("refid=%d..%d:Using %d threads(NumPair1=%d,block=%d)\n",refid,refidend,numthreads,NumPair1,block);
	    fflush(stdout);
	    thread_printed = numthreads;
	  }

	  if(DEBUG) assert(numthreads >= 1);

	  if(VERB>=2){
	    printf("refid=%d..%d/%d:kmax=%d,maxN=%lld,maxM=%lld\n",refid,refidend,numrefmaps,kmax,maxN,maxM);
	    fflush(stdout);
	  }
	  pcnt = (1LL+kmax) * maxN;

	  rs_heap->reset_lightweight_heap(virtperthread_size, numthreads);
            
	  if(VERB>=2){
	    printf("refid=%d..%d/%d: start of parallel section. CPU time=%0.6f wall time=%0.6f\n",refid,refidend,numrefmaps,mtime(),wtime());
	    fflush(stdout);
	  }

	  int lastPairId = 0;

	  NumThreads = max(1,numthreads);
	  PausedThreads = 0;

	  /* Multi-threaded work section : alignments of YidList1[0..NumPair1-1] with XidList1[0..NumPair1-1] (no hashtable && NoSplit==2) */
	  #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	  {
	    int tid = 0;
#ifdef _OPENMP
	    tid = omp_get_thread_num ();
#endif

	    /* each thread needs its own local memory */
	    int maxmatchgroup = 0;
	    Cmatchgroup *matchgroup = NULL;
	    Cmatchgroup **mheap = NULL;

	    CXPen XPenMem;
	    CXPen *XPen = &XPenMem;
	    XPen_alloc(XPen);

	    /* Allocate DP array A.<field>(I=1..N, K=0..kmax, J=1..M) */
	    AL A;
	    A.kmax = A.KMAX = kmax;
	    if(sizeof(A.Kstride) < sizeof(long long) && (long long)maxN * (long long)maxM * (long long) kmax > MASK(31)){
	      printf("maxN=%lld,maxM=%lld,kmax=%d: maxN * maxM * kmax exceeds signed integer range : change Kstride to long long in refalign.cpp\n",maxN,maxM,A.kmax);
	      fflush(stdout);exit(1);
	    }
	    if(sizeof(A.Istride) < sizeof(long long) && (long long)maxM > MASK(31)){
	      printf("maxM=%lld: maxM exceeds signed integer range : change Istride to long long in refalign.cpp\n",maxM);
	      fflush(stdout);exit(1);
	    }

	    int *JMIN = rs_heap->alloc_int(maxN,tid) - 1;
	    int *JMAX = rs_heap->alloc_int(maxN,tid) - 1;
	    int *Imin = rs_heap->alloc_int(maxM,tid) - 1;
	    int *Imax = rs_heap->alloc_int(maxM,tid) - 1;

	    if(DEBUG) assert(kmax == A.KMAX);
	    long long StrideMax = (1LL + kmax) * maxN * maxM;
	    long long KstrideMax = maxN * maxM;
	    RFLOAT *Fmem = rs_heap->alloc_RFLOAT(StrideMax * DPsizF, tid);
	    int *Imem = rs_heap->alloc_int(StrideMax * DPsizI, tid);

	    if(VERB>=2){
              #pragma omp critical
	      {
	        printf("thread=%d/%d:memory allocated:block size=%d maps, pcnt=%lld,N<=%d,kmax=%d,maxM=%lld,maxN=%lld, NumPair1=%d, StrideMax=%lld\n",
		  tid,numthreads,block,pcnt,NN,kmax,maxM,maxN,NumPair1,StrideMax);
	        fflush(stdout);
	      }
	    }
	      
	    int Tmapcnt = 0;

#if !USE_MIC
            #pragma omp for schedule(dynamic,block)
#endif
	    for(int PairId = 0; PairId < NumPair1; PairId++){
	      if(USE_MIC && !(((PairId / 16) % numthreads) == tid)){ // NOTE : simulate #pragma omp for schedule(static,16)
		continue;
	      }

	      int rid = YidList1[PairId];
	      int mapid = XidList1[PairId];
	      if(DEBUG>=2) assert(rid >= refid && rid <= refidend);

	      size_t alignid = orignumaligns + PairId * alignblock;
	      size_t origalignid = alignid;
	      if(DEBUG>=2 && !(alignid + alignblock <= numaligns)){
                #pragma omp critical
		{
		  printf("PairId=%d/%d:rid=%d/%d,mapid=%d/%d:alignid=%llu,alignblock=%d,numaligns=%llu,numalign_start[rid]=%llu\n",
		     PairId,NumPair1,rid,numrefmaps,mapid,nummaps,(unsigned long long)alignid,alignblock,(unsigned long long)numaligns,(unsigned long long)numalign_start[rid]);
		  fflush(stdout);
		  assert(alignid < numaligns);
		}
	      }

	      for(int t = 0; t < alignblock; t++){
	        Calign *p = alignment[alignid+t];
	        if(!p)
		  continue;
		if(p->block_id < 0){
	          p->allfree();
		  if(ALIGN_COMPRESS)
		    delete [] p;
	        }
		if(ALIGN_COMPRESS)
		  alignment[alignid+t] = NULL;
	      }

	      if(FirstAlignments && mapcnt+Tmapcnt >= FirstAlignments)
		continue;	  // NOTE : multithreaded loop is not determininistic since mapcnt is not synchronized

	      Cmap *rmap = refmap[rid];
	      int N = rmap->numsite[0];

	      Cmap *nanomap = Gmap[mapid];
	      if(DEBUG>=2) assert(nanomap != 0);
	      if(DEBUG>=2) assert(nanomap->mapid == mapid);
	      int M = nanomap->numsite[0];
	      FLOAT *X = nanomap->site[0];

	      if((VERB>=2 && PairId > lastPairId + 100) || (DEBUG>=2 && USE_MIC && !(((PairId/16) % numthreads) == tid)) || TSAN){
                #pragma omp critical
		{
		  if((VERB>=2 && PairId > lastPairId+ 100) || (DEBUG && USE_MIC && !(((PairId/16) % numthreads) == tid))){
		    printf("tid=%d:PairId=%d/%d:rid=%d,mapid=%d,N=%d,M=%d:Calling refalignSD:alignment[alignid=%lu]=%p: wall time= %0.6f secs\n",
			   tid,PairId,NumPair1,rid,mapid,N,M,alignid,alignment[alignid],wtime());
		    fflush(stdout);
		    lastPairId = PairId;
		  }
		}
	      }

	      //	      int *Kmax = RKmax[rid];
	      //	      if(DEBUG>=2) assert(Kmax != 0);

	      refalignSD(rmap, nanomap, alignid, RKmax, rid, mapid, 0, XPen, &A, Fmem, Imem, StrideMax, KstrideMax, JMIN, JMAX, Imin, Imax, tid, numthreads, maxN, NoSplit, maxmatchgroup, matchgroup, mheap);

	      if(DEBUG>=2 && !(alignid <= origalignid + alignblock)){
                #pragma omp critical
		{
		  printf("tid=%d:PairId=%d/%d:rid=%d(id=%lld),mapid=%d(id=%lld),N=%d,M=%d:origalignid=%lu,alignid=%lu,alignblock=%d,alignment[%lu]=%p\n",
			 tid,PairId,NumPair1,rid,rmap->id,mapid,nanomap->id,N,M,origalignid,alignid,alignblock,origalignid,alignment[origalignid]);
		  fflush(stdout);
		  assert(alignid <= origalignid + alignblock);
		}
	      }

	      for(int t = 0; t < alignblock; t++){
		Calign * &align = alignment[origalignid + t];

		if(align){
		  if(DEBUG) assert(align->mapid1 == rid);
		  if(DEBUG && t==0 && !(align->mapid2 == mapid)){
                    #pragma omp critical
		    {
		      printf("tid=%d:PairId=%d/%d:rid=%d(id=%lld),mapid=%d(id=%lld),N=%d,M=%d:origalignid=%lu,alignid=%lu,alignblock=%d:t=%d,align->mapid2=%d,or=%d,alignment[%lu]=%p\n",
			     tid,PairId,NumPair1,rid,rmap->id,mapid,nanomap->id,N,M,origalignid,alignid,alignblock,t,align->mapid2,align->orientation,origalignid,alignment[origalignid]);
		      fflush(stdout);
		      assert(align->mapid2 == mapid);
		    }
	          }
		  if(DEBUG) assert(Gmap[align->mapid2]->id == Gmap[mapid]->id);
		
		  if(AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold)){/* good alignment */
		    if(t == 0){
		      Cmap *origmap = nanomap;
		      while(origmap->origmap)
			origmap = origmap->origmap;
		      if(origmap->nalign->mapid1 < 0 || (BESTREF_PV ? (align->logPV > origmap->nalign->logPV + BestRefMargin * (rid > origmap->nalign->mapid1 ? 1.0 : -1.0)) :
							 (align->score > origmap->nalign->score + BestRefMargin * (rid > origmap->nalign->mapid1 ? 1.0 : -1.0)))){
                        #pragma omp critical(nalignlock)
			{
			  if(origmap->nalign->mapid1 < 0 || (BESTREF_PV ? (align->logPV > origmap->nalign->logPV + BestRefMargin * (rid > origmap->nalign->mapid1 ? 1.0 : -1.0)) :
			    (align->score > origmap->nalign->score + BestRefMargin * (rid > origmap->nalign->mapid1 ? 1.0 : -1.0)))){
			    if(VERB>=2 && nanomap->id == MAP_TRACE && origmap->nalign->mapid1 >= 0){
			      printf("refid=%d,mapid=%d:align->score=%0.6f,logPV=%0.2f,numpairs=%d,or=%d, best refid=%d -> %d\n",
			        refid,mapid,align->score,align->logPV,align->numpairs,align->orientation, (origmap->nalign->mapid1 < 0 ? -1 : origmap->nalign->mapid1), align->mapid1);
			      if(origmap->nalign->mapid1 >= 0)
				printf("   previous nalign->score=%0.6f,logPV=%0.2f,numpairs=%d,or=%d\n", origmap->nalign->score,origmap->nalign->logPV,origmap->nalign->numpairs,origmap->nalign->orientation);
			      fflush(stdout);
			    }
			    origmap->nalign->update(*align, N);/* save best alignment for next iteration */
			  }
			}
		      }
		      if(DEBUG>=2) assert(origmap->nalign->mapid1 >= 0);
		    }
		    
		    Tmapcnt++;

		    if(FirstAlignments && Tmapcnt >= 16){
                      #pragma omp critical
		      {
		        mapcnt += Tmapcnt;
		        Tmapcnt = 0;
		      }
		    }
		  }
		}

		if(VERB>=2 && nanomap->id == MAP_TRACE /* && giter == RefRepeats-1 */){
                  #pragma omp critical
		  {
		    mapcnt += Tmapcnt;
		    Tmapcnt = 0;

		    if(!align || align->numpairs <= 0){
		      if(VERB>=2 && t==0)
			printf("refid=%d,mapid=%d(id=%lld),M=%d:no alignment found(thread=%d),t=%d\n",
		            rid,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0],tid,t);
		    } else if (!(AlignedThreshold(align,rmap->site[0], ScoreThreshold, LogPvThreshold))){/* no good alignment */
		      if(VERB>=2 && t==0)
			printf("refid=%d,mapid=%d(id=%lld),M=%d:no good alignment:score=%0.4f,logPV=%0.3f,orientation=%d,scale=%d(%0.4f),pairs=%d,maxoutlier=%0.4f,Lend=%d,Rend=%d,len=%0.3f(thread=%d),t=%d\n",
		               rid,mapid,Gmap[mapid]->id, Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, align->scaleID, align->scaleID ? ScaleFactor[align->scaleID] : 1.0,
			         align->numpairs,align->maxoutlier,align->Lend,align->Rend, X[M+1]*origPixelLen/PixelLen,tid,t);
		    } else {
		      Cmap *origmap = nanomap;
		      while(origmap->origmap)
			origmap = origmap->origmap;
		      printf("refid=%d(id=%lld),mapid=%d(id=%lld),M=%d:score=%0.4f,logPV=%0.3f,orientation=%d,scale=%d(%0.4f),pairs=%d,Lend=%d,Rend=%d(thread=%d),mapcnt=%d,t=%d,repeat=%d,nalign->mapid1=%d\n",
			rid,refmap[rid]->id,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, align->scaleID, align->scaleID ? ScaleFactor[align->scaleID] : 1.0, align->numpairs,align->Lend,align->Rend, tid,mapcnt,t,align->repeat, origmap->nalign->mapid1);
		      if(SecondBest && align->align2){
		        Calign *align2 = align->align2;
		        printf("    2nd Best:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.3f,pairs=%d\n",
		    	    align2->mapid1,align2->mapid2,Gmap[align2->mapid2]->id,align2->orientation,align2->score,align2->logPV,align2->numpairs);
		      }
		    }
		    fflush(stdout);
		  }
		} // pragma omp critical
	      } // for t = 0 .. alignblock -1

	    } /* parallel for PairId = 0 .. NumPair1 - 1 */

            #pragma omp critical
	    {
	       mapcnt += Tmapcnt;
	       Tmapcnt = 0;
	    }

	    /* free per-thread memory */
	    XPen_free(XPen);
	    if(MultiMatches){
	      delete [] matchgroup;
	      if(MATCHGROUP_HEAP) delete [] mheap;
	    }
          } /* end of parallel section */

	  double TotalMadv = 0.0, TotalSleep = 0.0, TotalBT = 0.0;
	  if(RA_MIN_TIME)
	    for(int i = 0; i < numthreads;i++){
	      TotalMadv += FmemMadv[i];
	      TotalSleep += FmemSleep[i];
	      TotalBT += FmemBT[i];
	    }

	  if(MIN_MEM_DEBUG || RA_MIN_TIME){
	    delete [] FmemSiz; 
	    FmemSiz = NULL;	
	  }
	  if(RA_MIN_TIME){
	    delete [] FmemMadv;
	    FmemMadv = NULL;
	    delete [] FmemSleep;
	    FmemSleep = NULL;
	    delete [] FmemBT;
	    FmemBT = NULL;
	    delete [] FmemHWM; 
	    FmemHWM = NULL;
	    delete [] FmemTime; 
	    FmemTime = NULL;
	  }
	  if(MIN_MEM_DEBUG){
  	    delete [] FmemRsiz; 
	    FmemRsiz = NULL;
	  }

	  if(VERB){
	    printf("[refid=%d..%d/%d:total alignments=%d (alignids=%llu..%llu,nummaps=%d), Madvise= %0.1f Gb/thread, Sleep= %0.3f, BT= %0.3f secs/thread: cum CPU time=%0.6f wall time=%0.6f secs\n",
		refid,refidend,numrefmaps,mapcnt,(unsigned long long)orignumaligns,(unsigned long long)(numaligns-1),nummaps,
	        TotalMadv*1e-9/max(1,numthreads),TotalSleep/max(1,numthreads),TotalBT/max(1,numthreads),mtime(),wtime());
	    fflush(stdout);
	  }

	  if(DEBUG) NumPair1 = 0;

	  if(MINMEM>=2){// does not help since score_init() memory prevents release of virtual memory
	    delete rs_heap; 
	    rs_heap = new lightweight_heap(0,0);
	    if(VERB>=2){
	      printf("Reset lightweight heap\n");
	      fflush(stdout);
	    }
	  }

	  if(ALIGN_COMPRESS){/* compress alignment[numalign_start[refid]..numalign_end[refidend]-1] to remove NULL pointers */
	    size_t j = numalign_start[refid] = orignumaligns;
	    int rid = refid;
	    size_t k = j;
	    for(; k < numaligns; k++){
	      if(!alignment[k]){
		k++;
		break;
	      }
	      for(; rid < alignment[j]->mapid1; rid++)
		numalign_start[rid+1] = numalign_end[rid] = j;
	      if(VERB>=3 && giter == RefRepeats - 1){
		Calign *p = alignment[j];
		printf("alignment[%lu]=%p:refid=%d,mapid=%d,or=%d:numpairs=%d,score=%0.6f,logPV=%0.2f\n",
		       j,p,p->mapid1,p->mapid2,p->orientation,p->numpairs,p->score,p->logPV);
		fflush(stdout);
	      }
	      j++;
	    }
	    for(; k < numaligns; k++){
	      if(!alignment[k])
		continue;
	      if(DEBUG>=2) assert(j < k);
	      if(DEBUG>=2) assert(alignment[j]==0);
	      alignment[j] = alignment[k];
	      alignment[k] = 0;
	      for(; alignment[j]->mapid1 > rid; rid++)
		numalign_start[rid+1] = numalign_end[rid] = j;
	      if(VERB>=3 && giter == RefRepeats - 1){
		Calign *p = alignment[j];
		printf("alignment[%lu]=%p:refid=%d,mapid=%d,or=%d:numpairs=%d,score=%0.6f,logPV=%0.2f\n",
		       j,p,p->mapid1,p->mapid2,p->orientation,p->numpairs,p->score,p->logPV);
		fflush(stdout);
	      }
	      j++;
	    }
	    if(VERB>=2 && j < numaligns){
	      printf("refid=%d..%d:reduced numaligns from %llu to %llu(rid=%d): CPU time=%0.6f wall time=%0.6f\n",
		     refid,refidend,(unsigned long long)numaligns,(unsigned long long)j,rid,mtime(),wtime());
	      fflush(stdout);
	    }
	    numalign_end[rid] = numaligns = j;
	    while(++rid < numrefmaps)
	      numalign_start[rid] = numalign_end[rid] = numaligns;
	    if(VERB>=2){
	      printf("After removing null alignments from refid=%d..%d (orignumaligns=%llu)\n",refid,refidend,(unsigned long long)orignumaligns);
	      for(int r = refid; r <= refidend; r++)
		printf("   refid=%d:alignid=%lld..%lld\n",r, (long long)numalign_start[r],(long long)numalign_end[r]-1);
	      fflush(stdout);
	    }
	  }
	} /* refid 0..numrefmaps-1 */
      } // NoSplit >= 2 : Using XidList[],YidList[]
    } /* General case (no hashtable) */

    if(MINMEM){
      delete rs_heap; 
      rs_heap = new lightweight_heap(0,0);
      if(VERB>=2){
	printf("Reset lightweight heap\n");
	fflush(stdout);
      }

      if(giter == RefRepeats-1 && giter2 == RefRepeats-1 && !(MapScale && giter==0 && !origMapScale && !pSNRtotLL)){/* free up all hashtble related memory */
	if(HashFP){
	  hash_close(HashFP, pSNRtotLL ? 0 : 1);

	  numhashpairs1 = numhashpairs2 = 0;
	  NumPair1 = NumPair2 = 0;
	  nexthash1 = hashpairs1;
	  refid1 = refidend1 = -1;
	  nexthash2 = hashpairs2;
	  refid2 = refidend2 = -1;
	  HashFP = NULL;
	}

	delete [] hashmatch1; hashmatch1 = 0;
	refid1 = refid2 = -1;

	delete [] hashmatch2; hashmatch2 = 0;
	delete [] hashpairs1; hashpairs1 = 0;
	delete [] hashpairs2; hashpairs2 = 0;
	numhashpairs1 = numhashpairs2 = maxhashpairs1 = maxhashpairs2 = 0;

	delete [] YidListMem; YidListMem = NULL;
	delete [] phashListMem; phashListMem = NULL;
	YidList1 = YidList2 = XidList1 = XidList2 = 0;
	phashList1 = phashList2 = 0;
	NumPair1 = NumPair2 = MaxPair = 0;
	refidend1 = refidend2 = -1;
      }
    }

    if(DEBUG>=2) assert(0 <= giter && giter <= RefRepeats-1);

    //    if(VERB>=2)/* sort alignment by mapid2 (for debugging) */
    //      qsort(alignment, numaligns, sizeof(Calign*), (intcmp*)CalignMapidInc);

    if(VERB/* HERE HERE >=2 */){
      long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
      getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
      printf("Final numaligns=%lu:VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb : CPU time= %0.6f, wall time= %0.6f\n",
	    numaligns,VmSize * 1e-9, VmRSS * 1e-9, VmHWM * 1e-9, VmSwap * 1e-9, mtime(), wtime());
      fflush(stdout);
    }

    if(MapRate > 0.0 || giter == RefRepeats-1 || BestRef){/* adjust LogPvThreshold to reduce effective mapping rate (if needed) to no more than MapRate */
      Calign **sortalign = new Calign*[numaligns];
      for(size_t i = 0; i < numaligns; i++)
	sortalign[i] = alignment[i];
      if(BestRef){/* replace logPV by -100.0 for alignments that will be filtered out by BestRef */
	if(giter==RefRepeats-1){/* Compute Raw Mapping rate */
	  qsort(sortalign, numaligns, sizeof(Calign*), (intcmp*)CalignLogPVDec);
	  size_t realaligns = numaligns;

	  // new code to provide Log10PV values that are integers 
	  double LogPv = floor(max(0.0,startLogPvThreshold) + 0.5);
	  double maxLogPv = MAX_PV + 0.01;
	  for(int k = 0; k < LogPv - 0.01 && k <= MAX_PV; k++)
	    RawMappingRatePV[k] = ((double)realaligns)/nummaps;
	  int t = realaligns-1;
	  for(; LogPv <= maxLogPv; LogPv += 1.0){
	    while(t >= 0 && sortalign[t]->logPV < LogPv)
	      t--;
	    if(t < 0)
	      break;
	    int k = (int)floor(LogPv+0.5);
	    RawMappingRatePV[k] = ((double)t)/nummaps;
	  }
	}

	for(size_t i = 0; i < numaligns; i++){
	  Calign *align = alignment[i];
	  if(DEBUG) assert(align != 0);
	  int refid = align->mapid1;
	  int mapid = align->mapid2;
	  if(DEBUG) assert(mapid >= 0);
	  Cmap *nanomap = Gmap[mapid];
	  Cmap *origmap = nanomap;
	  while(origmap->origmap)
	    origmap = origmap->origmap;
	  if(DEBUG>=2 && BestRef) assert(origmap->nalign->mapid1 >= 0);
	  if(VERB>=3 && refmap[align->mapid1]->id == 3446){
	      printf("alignment[%lu]=%p:refid=%d(%lld),mapid=%d(%lld),or=%d:numpairs=%d,origmap->nalign->mapid1=%d(score=%0.6f,logPV=%0.2f,or=%d),score=%0.6f,logPV=%0.2f,maxoutlier=%0.3f\n",
		     i,align,align->mapid1,refmap[align->mapid1]->id,align->mapid2,Gmap[align->mapid2]->id,align->orientation,align->numpairs,origmap->nalign->mapid1,origmap->nalign->score,
		     origmap->nalign->logPV,origmap->nalign->orientation,align->score,align->logPV,align->maxoutlier);
	      fflush(stdout);
	  }
	  if(origmap->nalign->mapid1 != refid && BestRefExtCheck(align,origmap->nalign,origmap->mapid,refid)){	  
	    if(VERB>=2 && refmap[align->mapid1]->id == 3446){
	      printf("alignment[%lu]=%p:refid=%d(%lld),mapid=%d(%lld),or=%d:numpairs=%d,nanomap->mapid=%d,origmap->mapid=%d,origmap->nalign->mapid1=%d,score=%0.6f->MINSCORE,logPV=%0.2f->-100.00,maxoutlier=%0.3f\n",
		     i,align,align->mapid1,refmap[align->mapid1]->id,align->mapid2,Gmap[align->mapid2]->id,align->orientation,align->numpairs,nanomap->mapid,origmap->mapid,origmap->nalign->mapid1,align->score,align->logPV,align->maxoutlier);
	      fflush(stdout);
	    }
	    align->logPV = -100.0;
	    align->score = MINSCORE;
	  }
	}
      }
      if(MapRate > 0.0){
	if(BestRefPV){/* adjust logPV threshold */
	  qsort(sortalign, numaligns, sizeof(Calign*), (intcmp*)CalignLogPVDec);
	  size_t goalcnt = floor(nummaps * MapRate + 0.5);

	  if(VERB/* HERE >=2 */){
	    printf("MapRate=%0.4f,numaligns=%llu,nummaps=%d,goalcnt=%llu\n",MapRate,(unsigned long long)numaligns,nummaps,(unsigned long long)goalcnt);
	    fflush(stdout);
	  }

	  if(goalcnt < numaligns && sortalign[goalcnt]->logPV > 0.0){
	    LogPvThreshold = sortalign[goalcnt]->logPV;
	    LogPvThreshold = min(LogPvThreshold,MaxLogPvThreshold);
	  }
	  if(VERB){
	    printf("Changing LogPV threshold from %0.2f to %0.2f\n", startLogPvThreshold, LogPvThreshold);
	    fflush(stdout);
	  }
	} else {/* adjust score threshold */
	  qsort(sortalign, numaligns, sizeof(Calign*), (intcmp*)CalignScoreDec);
	  size_t goalcnt = floor(nummaps * MapRate + 0.5);
	  if(VERB/* HERE >=2 */){
	    printf("MapRate=%0.4f,numaligns=%llu,nummaps=%d,goalcnt=%llu\n",MapRate,(unsigned long long)numaligns,nummaps,(unsigned long long)goalcnt);
	    fflush(stdout);
	  }
	  if(goalcnt < numaligns && sortalign[goalcnt]->score >= (min(0.0,origScoreThreshold))){
	    ScoreThreshold = sortalign[goalcnt]->score;
	    ScoreThreshold = min(ScoreThreshold,MaxScoreThreshold);
	  }
	  if(VERB){
	    printf("Changing score threshold from %0.2f to %0.2f\n", origScoreThreshold, ScoreThreshold);
	    fflush(stdout);
	  }
	}
      }
      if(giter==RefRepeats-1){/* display effect of Pvalue cutoff on mapping rate */
	if(!(MapRate > 0.0 && BestRefPV))
	  qsort(sortalign, numaligns, sizeof(Calign*), (intcmp*)CalignLogPVDec);
	size_t realaligns = numaligns;
	if(BestRef){
	  for(realaligns=0;realaligns < numaligns; realaligns++)
	    if(sortalign[realaligns]->logPV <= 0.0)
	      break;
	  if(DEBUG && NoSplit==2 && BestRefExt <= 0.0 && BestRefOutlier > 999.0 && !(realaligns <= (size_t)nummaps)){
	    printf("After BestRef filtering of alignments: realaligns=%llu,nummaps=%d\n",
		   (unsigned long long)realaligns,nummaps);
	    fflush(stdout);
	    assert(realaligns <= (size_t)nummaps);
	  }
	}

	// new code to provide Log10PV values that are integers 
	double LogPv = floor(max(0.0,startLogPvThreshold) + 0.5);
	double maxLogPv = MAX_PV + 0.01;
	for(int k = 0; k < LogPv - 0.01 && k <= MAX_PV; k++)
	  MappingRatePV[k] = ((double)realaligns)/nummaps;
	if(VERB && (RefRepeats > 1 || RefRepeats2 > 1)){
	  printf("Log10PV threshold vs Mapping Rate (numaligns=%llu,nummaps=%d,LogPV range=%0.1f .. %0.1f,MapRate=%0.4f):\n",(unsigned long long)realaligns,nummaps,LogPv,maxLogPv,MapRate);
	  fflush(stdout);
	}
	int t = realaligns-1;
	for(; LogPv <= maxLogPv; LogPv += 1.0){
	  while(t >= 0 && sortalign[t]->logPV < LogPv)
	    t--;
	  if(t < 0)
	    break;
	  int k = (int)floor(LogPv+0.5);
	  MappingRatePV[k] = ((double)t)/nummaps;
	  if(VERB /* HERE HERE && (RefRepeats > 1 || RefRepeats2 > 1) */){
	    if(BestRef)
	      printf("Log10PV=%0.2f MappingRate=%0.5f (coverage = %0.2f), MappingRate without BestRef=%0.5f\n", LogPv, MappingRatePV[k], MappingRatePV[k] * CoverageMult,RawMappingRatePV[k]);
	    else
	      printf("Log10PV=%0.2f MappingRate=%0.5f (coverage = %0.2f)\n", LogPv, MappingRatePV[k], MappingRatePV[k] * CoverageMult);
	  }
	}

	fflush(stdout);
      }
      delete [] sortalign;
    }

    if(DEBUG>=2) assert(0 <= giter && giter <= RefRepeats-1);

    if(VERB && BestRef){
      if(!svcheck || BestRefExt <= 0.0){
	if(BestRefOutlier < 999.0)
	  printf("Removed duplicate alignments of same map to different references, provided lower scoring one has at least 1 outlier above %0.3f kb:\n", BestRefOutlier);
	else
	  printf("Removed duplicate alignments of same map to different references:\n");
      } else if(svcheck)
	printf("Removed duplicate alignments of same map if best alignment is to different reference region (BestRefExt = %0.3f kb)\n",BestRefExt);
      else
	printf("Removed duplicate alignments of same map if best alignment is to center region of different reference (BestRefExt = %0.3fkb)\n",BestRefExt);
      fflush(stdout);
    }

    if(Refine && !(MapScale && giter==0 && !origMapScale && !pSNRtotLL)){// free up as much memory as possible before calling refine()
      if(VERB>=2){
	printf("Calling dumpmemmap() before freeling alignment memory:\n");
	fflush(stdout);
	dumpmemmap();      
      }

      if(DEBUG) assert(RefRepeats == 1);
      delete rs_heap; rs_heap = NULL;
      if(VERB>=2){
	printf("Freed lightweight heap\n");
	fflush(stdout);
      }
      if(DEBUG) assert(!pSNRtotLL);

      // free up all hashtable related memory before starting refinement
      if(HashFP){
	hash_close(HashFP, 1);

	numhashpairs1 = numhashpairs2 = 0;
	NumPair1 = NumPair2 = 0;
	nexthash1 = hashpairs1;
	refid1 = refidend1 = -1;
	nexthash2 = hashpairs2;
	refid2 = refidend2 = -1;
	HashFP = NULL;
      }

      delete [] hashmatch1; hashmatch1 = 0;
      refid1 = refid2 = -1;

      delete [] hashmatch2; hashmatch2 = 0;
      delete [] hashpairs1; hashpairs1 = 0;
      delete [] hashpairs2; hashpairs2 = 0;
      numhashpairs1 = numhashpairs2 = maxhashpairs1 = maxhashpairs2 = 0;

      delete [] YidListMem; YidListMem = NULL;
      delete [] phashListMem; phashListMem = NULL;
      YidList1 = YidList2 = XidList1 = XidList2 = 0;
      phashList1 = phashList2 = 0;
      NumPair1 = NumPair2 = MaxPair = 0;
      refidend1 = refidend2 = -1;

      if(DEBUG) assert(NoStat);

      if(SCORE_MINMEM && NoStat){
	if(VERB>=2){
	  printf("Calling score_free\n");
	  fflush(stdout);
	}
	score_free(0,scorerefmaps);// will be recomputed after Refine
      }

      if(VERB>=2){
	printf("Calling dumpmemmap() before collecting information for refine():NoStat=%d\n",NoStat);
	fflush(stdout);
	dumpmemmap();      
      }
    }

    if(EARLY_ALIGN_FILTER){ // filter out below threshold or NULL alignments from alignment[] to speed up subsequent loops below
      size_t cnt = 0, origcnt = 0;
      for(int refid = 0; refid < numrefmaps; refid++){
	size_t nalignid = numalign_start[refid];
	origcnt += numalign_end[refid] - nalignid;
	for(size_t alignid = nalignid; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!align)
	    continue;
	  if(DEBUG>=2) assert(align->mapid1 == refid);
	  Cmap *rmap = refmap[refid];
	  if(!AlignedThreshold(align, rmap->site[0], startScoreThreshold, startLogPvThreshold))
	    continue;
	  if(nalignid < alignid){
	    alignment[alignid] = alignment[nalignid];
	    alignment[nalignid] = align;
	  }
	  alignid++;
	}
	cnt += nalignid - numalign_start[refid];

        for(size_t alignid = nalignid; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(align && align->block_id < 0)
	    delete [] align;
	  alignment[alignid] = 0;
	}
	numalign_end[refid] = nalignid;

	if(DEBUG>=2){
	  for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	    Calign *align = alignment[alignid];
	    assert(align);
	    assert(align->mapid1 == refid);
	    Cmap *rmap = refmap[refid];
	    assert(AlignedThreshold(align, rmap->site[0], startScoreThreshold, startLogPvThreshold));
	  }
	}
      }
      if(VERB/* HERE >=2 */ && cnt < origcnt){
	printf("Filtered out %lu out of %lu alignments that were below threshold\n",origcnt - cnt, origcnt);
	fflush(stdout);
      }
    }

    if(Refine && !(MapScale && giter==0 && !origMapScale && !pSNRtotLL) &&
       MultiMatches && LogPvThreshold2 < LogPvThreshold /* WAS152 LogPvThreshold < origLogPvThreshold */){/* If best matchgroup is below LogPvThreshold, remove alternate matchgroups */
      if(DEBUG && EARLY_ALIGN_FILTER) assert(LogPvThreshold == startLogPvThreshold && ScoreThreshold == startScoreThreshold);
      size_t cnt = 0;
      for(int refid = 0; refid < numrefmaps; refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!EARLY_ALIGN_FILTER){
	    if(!align)
	      continue;
	    Cmap *rmap = refmap[refid];
	    if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
	      continue;
	  }
	  if(DEBUG>=2) assert(align->mapid1 == refid);

	  if(DEBUG>=2) assert(align->multicnt > 0);

	  /* NOTE : align->Malign[0] is the matchgroup with highest score, but not necessarily with the highest LogPv */
	  double bestLogPv = -1000.0;
	  for(int t = 0; t < align->multicnt; t++)
	    bestLogPv = max(bestLogPv, align->Malign[t]->logPV);
	  if(bestLogPv < LogPvThreshold /* WAS152 origLovPvThreshold */)
	    continue;

	  cnt += align->multicnt - 1;
	  align->multicnt = 1;
	}
      }
      if(VERB/* HERE >=2 */ && cnt > 0){
	printf("Filtered out %lu alternate matchgroups where all matchgroups had logPV < %0.2f\n",cnt,LogPvThreshold/* WAS152 origLogPvThreshold */);
	fflush(stdout);
      }
    }

    if((MultiMatches > 0 || !BestRef) && MultiMatchesUniqueQuery > 0){/* filter out MGs based on query overlap accross all reference contigs */

      /* count total number of matchgroups */
      size_t MGcnt = 0;
      for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!EARLY_ALIGN_FILTER && !align)
	    continue;
	  Cmap *rmap = refmap[refid];
	  if(!EARLY_ALIGN_FILTER && !AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
	    continue;

	  if(MultiMatches > 0){
            if(DEBUG) assert(align->multicnt >= 1);
  	    MGcnt += align->multicnt;
          } else
	    MGcnt++;
	}
      }      
      
      Calign **Talignment = new Calign*[MGcnt];

      size_t cnt = 0;
      for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!EARLY_ALIGN_FILTER && !align)
	    continue;
	  Cmap *rmap = refmap[refid];
	  if(!EARLY_ALIGN_FILTER && !AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
	    continue;

	  if(MultiMatches > 0){
            for(int t = 0; t < align->multicnt; t++)
	      Talignment[cnt++] = align->Malign[t];
          } else
	    Talignment[cnt++] = align;
	}
      }      
      if(DEBUG) assert(cnt == MGcnt);

      // sort Talignment[0..cnt-1] in ascending order of Qry map id and descending order of LogPV 
      qsort(Talignment,cnt,sizeof(Calign *),(intcmp*)CalignQryIncLogpvDec);

      size_t delcnt = 0, zerocnt = 0, trimcnt = 0, totlabcnt = 0, trimlabcnt = 0;

      for(size_t i = 0; i < cnt; i++){
	Calign *p = Talignment[i];
	if(!EARLY_ALIGN_FILTER && !p)
	  continue;
	
	if(p->numpairs <= 0)
	  zerocnt++;
      }

      FLOAT *XrevMem = new FLOAT[maxM+2];
      XrevMem[0] = 0.0;

      for(size_t i = 0; i < cnt; i++){
	Calign *p = Talignment[i];
	if(!EARLY_ALIGN_FILTER && !p)
	  continue;
	int U = p->numpairs;
	if(U <= 0 || p->logPV <= 0.0)
	  continue;

	int rid = p->mapid1;
	Cmap *Ymap = YYmap[rid];
	int N = Ymap->numsite[0];
	FLOAT *Y = Ymap->site[0];

	int mid = p->mapid2;
	Cmap *Xmap = XXmap[mid];
	int M = Xmap->numsite[0];
	FLOAT *X = Xmap->site[0];

	FLOAT *Xrev = XrevMem;
	for(int J = 1; J <= M+1; J++)
	  Xrev[J] = X[M+1] - X[M+1-J];

	int LJ = p->sites2[0];
	int RJ = p->sites2[U-1];
	if(DEBUG) assert(LJ <= RJ);
	int qrystart = p->orientation ? M + 1 - RJ : LJ;
	int qryend   = p->orientation ? M + 1 - LJ : RJ;

	for(size_t k = i+1; k < cnt; k++){
	  Calign *q = Talignment[k];
	  if(!EARLY_ALIGN_FILTER && !q)
	    continue;
	  if(mid != q->mapid2)
	    break;

	  int U2 = q->numpairs;
	  if(U2 <= 0 || q->logPV <= 0.0)
	    continue;

	  int rid2 = q->mapid1;
	  Cmap *Ymap2 = YYmap[rid2];
	  int N2 = Ymap2->numsite[0];
	  FLOAT *Y2 = Ymap2->site[0];

	  int LJ2 = q->sites2[0];
	  int RJ2 = q->sites2[U2 - 1];
	  if(DEBUG) assert(LJ2 <= RJ2);
	  int qrystart2 = q->orientation ? M + 1 - RJ2 : LJ2;
	  int qryend2   = q->orientation ? M + 1 - LJ2 : RJ2;
	  
	  if(min(qryend,qryend2) - max(qrystart,qrystart2) > min(qryend-qrystart,qryend2-qrystart2) - MultiMatchesUniqueQuery){/* filter out q or p (but check internal overlap with outlier) */
	    if(q->logPV > p->logPV && min(qryend,qryend2)-max(qrystart,qrystart2) > qryend2-qrystart2 - MultiMatchesUniqueQuery){// can happen due to MultiMatchesUniqueQueryTrim
	      if(DEBUG) assert(MultiMatchesUniqueQueryTrim);

	      if(MultiMatchesUniqueQueryInv > 0 && min(qryend,qryend2) - max(qrystart,qrystart2) >= MultiMatchesUniqueQueryInv){/* check if I consecutive aligned labels in p overlap the query of the same interval in q */
		// HERE HERE HERE
		printf("MultiMatchesUniqueQueryInv = %d : not yet implemented\n",MultiMatchesUniqueQueryInv);
		fflush(stdout);exit(1);
	      }

	      delcnt++;
	      p->logPV = 0.0;
	      break;
	    }

	    if(MultiMatchesUniqueQueryInv > 0 && min(qryend,qryend2) - max(qrystart,qrystart2) >= MultiMatchesUniqueQueryInv){/* check if I consecutive aligned labels in q overlap the query of the same interval in p */
	      // HERE HERE HERE
	      printf("MultiMatchesUniqueQueryInv = %d : not yet implemented\n",MultiMatchesUniqueQueryInv);
	      fflush(stdout);exit(1);
	    }

	    delcnt++;
	    q->logPV = 0.0;
	    continue;
	  }

	  if(MultiMatchesUniqueQueryTrim && min(qryend,qryend2) - max(qrystart,qrystart2) >= 2){/* trim overlapped region in query (except for possibly 1 label) */
	    int qstart = max(qrystart,qrystart2);
	    int qend = min(qryend,qryend2);
	    /* compute score of overlapped region qstart .. qend for p and q */
	    int L1 = p->orientation ? M+1 - qend : qstart;
	    int R1 = p->orientation ? M+1 - qstart : qend;
	    double score1 = 0.0;
	    int t;
	    for(t = 0; t < U; t++)
	      if(p->sites2[t] >= L1)
		break;
	    int tL1 = t, tR1 = t;
	    for(t++; t < U; t++){
	      if(p->sites2[t] > R1)
		break;
	      score1 += p->iscore[t];
	      tR1 = t;
	    }

	    int L2 = q->orientation ? M+1 - qend : qstart;
	    int R2 = q->orientation ? M+1 - qstart : qend;
	    double score2 = 0;
	    for(t = 0; t < U2; t++)
	      if(q->sites2[t] >= L2)
		break;
	    int tL2 = t, tR2 = t;
	    for(t++; t < U2; t++){
	      if(q->sites2[t] > R2)
		break;
	      score2 += q->iscore[t];
	      tR2 = t;
	    }
	    
	    if(DEBUG) assert(tL1 <= 0 || tR1 >= U-1);
	    if(DEBUG && !(tL2 <= 0 || tR2 >= U2-1)){
	      printf("q1=%d..%d,q2=%d..%d,or1=%d,or2=%d:L1=%d,R1=%d,L2=%d,R2=%d,M=%d,score1=%0.6f,score2=%0.6f\n",
		     qrystart,qryend,qrystart2,qryend2,p->orientation,q->orientation,L1,R1,L2,R2,M,score1,score2);
	      for(int t = 0; t < U; t++)
		printf("p->sites2[%d] = %d, iscore= %0.6f\n",t,p->sites2[t],p->iscore[t]);
	      printf("p->iscore[%d]= %0.6f\n",U,p->iscore[U]);
	      for(int t = 0; t < U2; t++)
		printf("q->sites2[%d] = %d, iscore= %0.6f\n", t, q->sites2[t], q->iscore[t]);
	      printf("q->iscore[%d]= %0.6f\n",U2,q->iscore[U2]);

	      printf("tL1=%d,tR1=%d,U=%d\n",tL1,tR1,U);
	      printf("tL2=%d,tR2=%d,U2=%d\n",tL2,tR2,U2);
	      fflush(stdout);
	      assert(tL2 <= 0 || tR2 >= U2-1);
	    }

	    trimcnt++;
	    if(score1 >= score2){// trim q */
	      if(MultiMatchesUniqueQueryInv > 0 && U2 - (tR2-tL2+1) >= MultiMatchesUniqueQueryInv){/* check if I consecutive aligned labels in q overlap the query of the same interval in p */
		// HERE HERE HERE
		printf("MultiMatchesUniqueQueryInv = %d : not yet implemented\n",MultiMatchesUniqueQueryInv);
		fflush(stdout);exit(1);
	      }

	      totlabcnt += U2;
	      if(tL2 <= 0){// trim q down to q->sites2[tR2 .. U2-1]
		if(tR2 > 0){
		  AlignTrim(q,tR2,U2-1,N2,M,Y2,X,q->orientation ? Xrev : X);
		  trimlabcnt += tR2-1;
		}
	      } else {// trim q down to q->sites2[0 .. tL2]
		if(DEBUG) assert(tL2 <= U2-1);
		if(U2-1 > tL2){
		  AlignTrim(q,0,tL2,N2,M,Y2,X,q->orientation ? Xrev : X);
		  trimlabcnt += U2-1-tL2;
		}
              }
	    } else {/* trim p */
	      if(MultiMatchesUniqueQueryInv > 0 && U - (tR1-tL1+1) >= MultiMatchesUniqueQueryInv){/* check if I consecutive aligned labels in p overlap the query of the same interval in q */
		// HERE HERE HERE
		printf("MultiMatchesUniqueQueryInv = %d : not yet implemented\n",MultiMatchesUniqueQueryInv);
		fflush(stdout);exit(1);
	      }

	      totlabcnt += U;
	      if(tL1 <= 0){// trim p down to p->sites2[tR1 .. U-1]
		if(tR1 > 0){
		  AlignTrim(p,tR1,U-1,N,M,Y,X,p->orientation ? Xrev : X);
		  trimlabcnt += tR1-1;
		}
	      } else {// trim p down to p->sites2[0 .. tL1]
		if(DEBUG) assert(tL1 <= U-1);
		if(U-1 > tL1){
		  AlignTrim(p,0,tL1,N,M,Y,X,p->orientation ? Xrev : X);
		  trimlabcnt += U-1 - tL1;
		}
	      }
	    }
	  }
	}
      }

      delete [] XrevMem;
      delete [] Talignment;

      int overwrite = 0;

      if(MultiMatches > 0){
       for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!EARLY_ALIGN_FILTER && !align)
	    continue;
	  Cmap *rmap = refmap[refid];
	  if(!EARLY_ALIGN_FILTER && !AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
	    continue;

	  int i = 0, ibest = -1;
	  double bestscore = -9999.0;

	  for(int t = 0; t < align->multicnt; t++){
	    Calign *p = align->Malign[t];
	    if(p->logPV <= 0.0)
	      continue;
	    if(p->score > bestscore){
	      ibest = i;
	      bestscore = p->score;
	    }
	    if(i != t){/* swap align->Malign[t] and align->Malign[i] */
	      align->Malign[t] = align->Malign[i];
	      align->Malign[i] = p;
	    }
	    i++;
	  }

	  if(DEBUG) assert(i <= align->multicnt);
	  align->multicnt = i;

	  if(i <= 0){/* all MGs were Suppressed by MGs with another refid */
	    if(DEBUG) assert(ibest < 0);
	    align->logPV = 0.0;
	    overwrite++;
	  }

	  if(ibest > 0){
	    Calign *p = align->Malign[ibest];
	    align->Malign[ibest] = align->Malign[0];
	    align->Malign[0] = p;

	    /* need to update align[0] from p == align->Malign[0] */
	    overwrite++;

	    align->score = p->score;
	    align->logPV = p->logPV;
	    align->logPV2 = p->logPV2;
	    align->orientation = p->orientation;
	    align->scaleID = p->scaleID;

	    align->Lij1 = p->Lij1;
	    align->Rij1 = p->Rij1;
	    align->Lij2 = p->Lij2;
	    align->Rij2 = p->Rij2;
#if CALIGN_END==0
	    align->LijY = p->LijY;
	    align->LijX = p->LijX;
	    align->RijY = p->RijY;
	    align->RijX = p->RijX;
#endif
	    align->Lend = p->Lend;
	    align->Rend = p->Rend;

	    int U = p->numpairs;
	    align->expand_arrays(U);

	    align->numpairs = U;
	    for(int i = 0; i < U;i++){
	      align->sites1[i] = p->sites1[i];
	      align->sitesK1[i] = p->sitesK1[i];
	      align->sites2[i] = p->sites2[i];
	    }
	    for(int i = 0; i <= U; i++){
	      align->iscore[i] = p->iscore[i];
	      align->outscore[i] = p->outscore[i];
	    }

	    align->Nrange = p->Nrange;
	    align->Mrange = p->Mrange;

	    align->noutliers = p->noutliers;
	    align->maxoutlier = p->maxoutlier;
	    align->repeat = p->repeat;
	  }
	}
       }
      }// if (MultiMatches > 0)

      if(VERB){
	if(MultiMatches > 0)
	  printf("Suppressed %lu of %lu MGs (+ %lu/%lu overlapped labels from %lu MGs) due to -MultiMatchesUniqueQuery %d %d %d (%d primary MGs were updated)\n",
		 delcnt,MGcnt,trimlabcnt,totlabcnt,trimcnt,MultiMatchesUniqueQuery,MultiMatchesUniqueQueryInv,MultiMatchesUniqueQueryTrim,overwrite);
	else
	  printf("Suppressed %lu of %lu primary MGs due to -MultiMatchesUniqueQuery %d %d\n",delcnt,MGcnt,MultiMatchesUniqueQuery,MultiMatchesUniqueQueryInv);
	fflush(stdout);
      }
    }

    if(BestRefWT && giter==RefRepeats-1){   /* compute weights for alignments so that each molecule's wts add up to 1 and are based on relative likelihood (exp(score)), OR (if BestRefPV) Pvalue */
      /* NOTE: If -AddFragsWT is used the total wts of a molecule may add up to more than 1, hence this should never be used with -mapped (stage0) and is only intended to be used with -refine 2 (stage1).
	 AddFragsWt will treat all matchgroups of the same molecule with the same reference in the same orientation as a single alignment with all such matchgroups sharing their total weight */

      if(DEBUG) assert(!(MapScale && giter==0 && !origMapScale));

      double Log10 = log(10.0);      

      if(DEBUG) assert(BestRef==0);
      if(DEBUG && EARLY_ALIGN_FILTER) assert(LogPvThreshold == startLogPvThreshold && ScoreThreshold == startScoreThreshold);

      if(VERB>=2){
	printf("Computing map wts for each molecule alignment\n");
	fflush(stdout);
      }

      /* initialize each map's Likehood value to 0.0 */
      for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!EARLY_ALIGN_FILTER && !align)
	    continue;
	  Gmap[align->mapid2] -> Likelihood = 0.0;
	}
      }

      /* compute relative likelihood for each alignment, relative to the best alignment for same map.
	 Store the relative likelihood value in align->mapWT and add it to the map's Likelihood */
      for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!EARLY_ALIGN_FILTER){
	    if(!align)
	      continue;
	    Cmap *rmap = refmap[refid];
	    if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
	      continue;
	  }
	  if(DEBUG>=2) assert(align->mapid1 == refid);

	  int mapid = align->mapid2;
	  Cmap *nanomap = Gmap[mapid];
	  if(DEBUG>=2) assert(!nanomap->origmap);
	  Calign_brief *nalign = nanomap->nalign;
	  if(DEBUG>=2) assert(nalign && nalign->mapid1 >= 0);
	  double bestscore = BESTREF_PV ? min(BestRefPV_MaxConf, nalign->logPV) : nalign->score;

	  if(MultiMatches){/* iterate over all matchgroups */
	    for(int t = 0; t < align->multicnt; t++){
	      Calign *q = align->Malign[t];
	      if(DEBUG>=2) assert(q->mapid1 == refid);
	      if(q->logPV <= 0.0){
		q->mapWT = 0.0;// NEW157
		continue;
	      }
	      double deltascore = BESTREF_PV ? (min(BestRefPV_MaxConf, q->logPV) - bestscore) * Log10 : q->score - bestscore;
	      if((TRACE && nanomap->id == MAP_TRACE) || (DEBUG>=2 && !BESTREF_PV && !(deltascore <= 0.0))){
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.6f,logPV=%0.6f:bestscore=%0.6f\n",
		       refid,refmap[refid]->id,mapid,nanomap->id,align->orientation,align->score,align->logPV,bestscore);
		printf("\t t=%d/%d:q->score=%0.6f,q->logPV=%0.6f,deltascore=%0.6e,mapWT=%0.6f,Likelihood=%0.6f->%0.6f\n",
		       t,align->multicnt,q->score,q->logPV,deltascore,exp(deltascore),nanomap->Likelihood,nanomap->Likelihood + exp(deltascore));
		fflush(stdout);
		assert(deltascore <= 0.0);
	      }
	      q->mapWT = exp(deltascore);
	      nanomap->Likelihood += q->mapWT;
	    }
	  } else {
	    double deltascore = BESTREF_PV ? (min(BestRefPV_MaxConf, align->logPV) - bestscore) * Log10 : align->score - bestscore;
	    if((TRACE && /* refmap[refid]->id == REF_TRACE && */ nanomap->id == MAP_TRACE)  || (DEBUG>=2 && !BESTREF_PV && !(deltascore <= 0.0))){
	      Cmap *rmap = refmap[refid];
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.6f,logPV=%0.6f:bestscore=%0.6f,deltascore=%0.6f,mapWT=%0.6f,Likelihood=%0.6f->%0.6f\n",
		     refid,rmap->id,mapid,nanomap->id,align->orientation,align->score,align->logPV,bestscore,deltascore,exp(deltascore),nanomap->Likelihood,nanomap->Likelihood+exp(deltascore));
	      fflush(stdout);
	      assert(deltascore <= 0.0);
	    }
	    align->mapWT = exp(deltascore);
	    nanomap->Likelihood += align->mapWT;
	  }
	}
      }

      /* compute alignment weight by normalizing align->mapWT by Gmap[align->mapid2]->Likelihood */
      for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!EARLY_ALIGN_FILTER){
	    if(!align)
	      continue;
	    Cmap *rmap = refmap[refid];
	    if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
	      continue;
	  }
	  if(DEBUG>=2) assert(align->mapid1 == refid);
	  int mapid = align->mapid2;
	  Cmap *nanomap = Gmap[mapid];
	  if(DEBUG>=2) assert(nanomap->Likelihood >= 1.0);
	  if(DEBUG>=2) assert(0.0 <= nanomap->mapWT && nanomap->mapWT <= 1.0);
	  double Inorm = nanomap->mapWT/nanomap->Likelihood;// NOTE : nanomap->mapWT is the input mapWT from mapped BNX (or 1.0 if NA) 
	  if(MultiMatches){/* iterate over all matchgroups */
	    for(int t = 0; t < align->multicnt; t++){
	      align->Malign[t]->mapWT *= Inorm;
	      if(DEBUG>=2) assert(0 <= align->Malign[t]->mapWT && align->Malign[t]->mapWT <= 1.0);
	      if(TRACE && nanomap->id == MAP_TRACE){
		Calign *p = align->Malign[t];
		int U = p->numpairs;
		Cmap *rmap = refmap[refid];
		printf("refid=%d(id=%lld),alignid=%lu,mapid=%d(id=%lld):t=%d/%d:or=%d,score=%0.6f,logPV2=%0.2f,U=%d,IL=%d,IR=%d:nanomap->mapWT= %0.6f,Likelihood= %0.6f align->Malign[t]->mapWT= %0.6f\n",
		       refid,rmap->id,alignid,mapid,nanomap->id,t,align->multicnt,p->orientation,p->score,p->logPV,U,p->sites1[0],p->sites1[U-1],nanomap->mapWT,nanomap->Likelihood,p->mapWT);
		fflush(stdout);
	      }
	    }
	  } else {
	    align->mapWT  *= Inorm;
	    if(DEBUG>=2) assert(0 <= align->mapWT && align->mapWT <= 1.0);
	    if(TRACE && nanomap->id == MAP_TRACE){
	      Calign *p = align;
	      int U = p->numpairs;
	      Cmap *rmap = refmap[refid];
	      printf("refid=%d(id=%lld),alignid=%lu,mapid=%d(id=%lld):or=%d,score=%0.6f,logPV2=%0.2f,U=%d,IL=%d,IR=%d:nanomap->mapWT=%0.6f,Likelihood=%0.6f align->mapWT= %0.6f\n",
		     refid,rmap->id,alignid,mapid,nanomap->id,p->orientation,p->score,p->logPV,U,p->sites1[0],p->sites1[U-1],nanomap->mapWT, nanomap->Likelihood,p->mapWT);
	      fflush(stdout);
	    }
	  }
	}
      }      

      if(AddFragsWT && MultiMatches){
	if(DEBUG) assert(!MappedPrefix);
	for(int refid = 0; refid < numrefmaps; refid++){
	  for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	    Calign *align = alignment[alignid];
	    if(!EARLY_ALIGN_FILTER){
	      if(!align)
		continue;
	      Cmap *rmap = refmap[refid];
	      if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	    }
	    if(DEBUG>=2) assert(align->mapid1 == refid);

	    if(align->multicnt <= 1)
	      continue;
	    //	    int mapid = align->mapid2;
	    //	    Cmap *nanomap = Gmap[mapid];
	    /* First handle orientation == 0 */
	    double wtsum = 0.0;
	    for(int t = 0; t < align->multicnt; t++){
	      Calign *q = align->Malign[t];
	      if(q->orientation == 0)
		wtsum += q->mapWT;
	    }
	    double wtsum0 = wtsum;

	    /* Next handle orientation == 1 */
	    wtsum = 0.0;
	    for(int t = 0; t < align->multicnt; t++){
	      Calign *q = align->Malign[t];
	      if(q->orientation == 1)
		wtsum += q->mapWT;
	    }
	    if((VERB>=2 && (refmap[refid]->id == 411 || refmap[refid]->id==412) /* &&  Gmap[align->mapid2]->id == MAP_TRACE*/) ||
	       (DEBUG>=2 && !(0.0 <= wtsum0 + wtsum && wtsum0 + wtsum <= 1.0 + 1e-7))){
	      Cmap *rmap = refmap[refid];
	      printf("refid=%d(id=%lld),alignid=%lu,mapid=%d(id=%lld):multicnt=%d,wtsum0=%0.10f,wtsum=%0.10f(tot=%0.10f, 1-tot= %0.10e)\n",
		     refid,rmap->id,alignid,align->mapid2,Gmap[align->mapid2]->id,align->multicnt,wtsum0,wtsum,wtsum0+wtsum,1.0-(wtsum0+wtsum));
	      for(int t = 0; t < align->multicnt; t++){
		Calign *q = align->Malign[t];
		printf(" Malign[%d]: or=%d, mapWT= %0.10f\n",t,q->orientation,q->mapWT);
	      }
	      fflush(stdout);
	      if(DEBUG) assert(0.0 <= wtsum0+wtsum && wtsum0+wtsum <= 1.0 + 1e-7);
	    }
	    wtsum0 = min(1.0,wtsum0);
	    wtsum = min(1.0,wtsum);

	    for(int t = 0; t < align->multicnt; t++){
	      Calign *q = align->Malign[t];
	      if(q->orientation == 0)
		q->mapWT = wtsum0;
	    }
	    for(int t = 0; t < align->multicnt; t++){
	      Calign *q = align->Malign[t];
	      if(q->orientation == 1)
		q->mapWT = wtsum;
	    }
	  }
	}
      }
    } // if(BestRefWT ... )
    else if(giter == RefRepeats-1) {// !BestRefWT : just use the input nanomap->mapwt which could be based on a previous command with BestRefWT (or 1.0 if NA)
      if(DEBUG && EARLY_ALIGN_FILTER) assert(LogPvThreshold == startLogPvThreshold && ScoreThreshold == startScoreThreshold);

      for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!EARLY_ALIGN_FILTER && !align)
	    continue;
	  if(DEBUG>=2) assert(align->mapid1 == refid);
#if 0 // old code 
	  Cmap *rmap = refmap[refid];
	  if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
	    continue;
	  int mapid = align->mapid2;
	  Cmap *nanomap = Gmap[mapid];
	  if(DEBUG>=2) assert(nanomap->mapWT <= 1.0);
	  if(MultiMatches)/* iterate over all matchgroups */
	    for(int t = 0; t < align->multicnt; t++)
	      align->Malign[t]->mapWT = nanomap->mapWT;
	  align->mapWT  = nanomap->mapWT;
#else // new code : just set all mapWT values to 1.0
	  if(MultiMatches)/* iterate over all matchgroups */
	    for(int t = 0; t < align->multicnt; t++)
	      align->Malign[t]->mapWT = 1.0;
	  align->mapWT  = 1.0;
#endif
	}
      }      
    } // compute weights for alignments

    //    double cumnormsq = 0.0;
    //    size_t normcnt = 0;

    if(DEBUG && !(RefineHmap /* WAS && (HapSitePvalue > 0.0 || HapIndelPvalue > 0.0)*/))
      assert(Hapnumrefmaps == numrefmaps);

    if(DEBUG>=3){
      for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!align)
	    continue;
	  if(DEBUG) assert(align->mapid1 == refid);
	}
      }
    }

    if(extendSplit && (!extsplitNE || extTrim)){
      if(extsplitExtOnly) free(extsplitExtOnly);

      if((extsplitExtOnly = (double *)malloc(maxnumrefmaps * sizeof(double))) == NULL){
	printf("malloc of %lu bytes failed (maxnumrefmaps=%d)\n",maxnumrefmaps*sizeof(double),maxnumrefmaps);
	fflush(stdout);exit(1);
      }
      for(int r = 0; r < maxnumrefmaps; r++)
	extsplitExtOnly[r] = EndLen;

      if(VERB>=2){
	printf("Allocated extsplitExtOnly = %p, numrefmaps= %d, maxnumrefmaps= %d\n",extsplitExtOnly, numrefmaps, maxnumrefmaps);
	fflush(stdout);
      }
    }

    int origextTrim = extTrim;

    mapcnt = 0;

    if(EXTSPLIT_FORK && extendSplit && Refine && !(MapScale && giter==0 && !origMapScale && !pSNRtotLL) && !child_pid)
      child_pid = new pid_t[MaxThreads];

    int orignumrefmaps = numrefmaps;/* extendSplit can increase numrefmaps */

    for(int refid = 0;refid < (extendSplit ? numrefmaps : Hapnumrefmaps);refid++){

      if(EXTSPLIT_FORK && extendSplit && Refine && !(MapScale && giter==0 && !origMapScale && !pSNRtotLL)
	 && refid >= orignumrefmaps && child_pid != NULL && numchild <= 0 && numrefmaps - refid >= 4){/* fork into multiple jobs and distribute refid .. numrefmaps-1 accross them */

	int startnumrefmaps = numrefmaps;
	int startrefid = refid;
	int origMaxThreads = MaxThreads;

	int numforks = min(numrefmaps - refid, (MaxThreads + EXTSPLIT_FORK-1)/max(1,EXTSPLIT_FORK));
	int maxforks = numforks;
	long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
	getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    

	if(MaxMem > 0.0){/* limit number of additional forks by memory remaining and EXTSPLIT_FORK_MEM required per fork */
	
	  double MemLeft = max(0.0,MaxMem - VmRSS*1e-9);
	  maxforks = 1 + (int)floor(MemLeft / EXTSPLIT_FORK_MEM); // NOTE : numforks includes parent job
	} 

	if(VERB){
	  printf("VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f, MaxMem= %0.1f, ForkMem= %0.2f Gb : Number of forks = %d -> %d\n",
		 VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9,MaxMem, EXTSPLIT_FORK_MEM, numforks, min(numforks,maxforks));
	  fflush(stdout);
	}

	numforks = min(maxforks,numforks);

	if(numforks > 1){

	  /* reduce number of threads per fork */
	  MaxThreads = RefineThreads = BoostThreads = numthreads = min(EXTSPLIT_FORK, (MaxThreads + numforks - 1)/numforks);
	    
	  int fblock = max(1,(startnumrefmaps - refid) / numforks);
	  numrefmaps = min(startnumrefmaps, refid + fblock);
	  /* next refid interval is refid .. numrefmaps - 1 */

	  for(int F = 1; F < numforks; F++){/* fork : in child update stdout and break out of loop. In parent update refid interval and continue */
	    char filename[PATH_MAX];
	    if(!origCMapID)
	      sprintf(filename,"%s_C%d.stdout",output_prefix,F);
	    else
	      sprintf(filename,"%s_id%lld_C%d.stdout",output_prefix,origCMapID,F);

	    if(VERB/* HERE HERE >=2*/){
	      printf("Forking child with %d threads to refine refid= %d .. %d (out of %d .. %d): stdout will be in %s\n",MaxThreads,refid,numrefmaps-1,startrefid,startnumrefmaps-1,filename);
	      fflush(stdout);
	    }
	    pid_t pid = fork();
	    if(pid == -1){/* fork failed */
	      int myerrno = errno;
	      fprintf(stderr,"Unable to fork %d'th child: %s\n",F,strerror(myerrno));
	      fflush(stdout);exit(1);
	    }

	    if(!pid){/* child */
#if USE_MIC
	      extern SCIF_IO_CONTEXT *main_context;
	      main_context = NULL;// need to force reset of SCIF interface in child
#endif
	      if(freopen(filename,"a",stdout)==NULL){
		int myerrno = errno;
		fprintf(stderr,"Unable to redirect stdout of %d'th child to %s: %s\n",F, filename, strerror(myerrno));
		fflush(stderr);
	      }
	      printversion(stdout);

	      stdout_file = strdup(filename);

	      numchild = 0;
	      child_pid = NULL;// identifies child jobs 
	      
	      break;
	    }

	    child_pid[numchild++] = pid;
	    if(DEBUG && !(numchild <= origMaxThreads)){
	      printf("numchild= %d, origMaxThreads= %d\n",numchild,origMaxThreads);
	      fflush(stdout);
	      assert(numchild <= origMaxThreads);
	    }
	      
	    refid = numrefmaps;
	    numrefmaps = min(startnumrefmaps, refid + fblock);	      

	    if(numrefmaps >= startnumrefmaps){
	      if(numforks > F+1){
		if(VERB){
		  printf("Reducing numforks = %d -> %d : ran out of refids\n",numforks, F+1);
		  fflush(stdout);
		}

		numforks = F+1;
	      }
	      break;
	    } else if(DEBUG) assert(refid < numrefmaps);
	  }
	}

	if(child_pid != NULL){
	  MaxThreads = RefineThreads = BoostThreads = numthreads = min(3,origMaxThreads);// Parent process can continue to use OpenMP and can complete unrefined file IO before waiting on child job completion
	  numrefmaps = startnumrefmaps;

	  if(VERB/* HERE HERE >=2 */){
	    printf("Parent using %d threads to refine refid= %d .. %d (out of %d .. %d)\n",MaxThreads,refid,numrefmaps-1,startrefid,startnumrefmaps-1);
	    fflush(stdout);
	  }
	}

	if(refid >= numrefmaps)
	  break;
      }

      extTrim = origextTrim;

      Cmap *rmap = refmap[refid];
      FLOAT *Y = rmap->site[0];
      int N = rmap->numsite[0];

      if(VERB>=2){
	printf("refid=%d/%d:PoutlierEnd=%0.6f:OutlierEndBias=%0.6f,OutlierEndPenalty=%0.6f,OutlierPenalty=%0.6f:ChimScore=%0.6f\n",
	       refid,numrefmaps,PoutlierEnd,OutlierEndBias,OutlierEndPenalty,OutlierPenalty,ChimScore);
	fflush(stdout);
      }

      //      double ExpOutlierPenalty = exp(OutlierPenalty);

      int origmapcnt = mapcnt;

      if(!NoStat || (MapScale && giter==0 && !origMapScale && !pSNRtotLL)){      /*  The following autonoise code is not needed during Refinement or if -nostat (unless MapScale && !origMapScale) */

	Cprtab **PRtabY = PRtab[refid];

	if(REFDEBUG && !logLRarray){
	  logLRarray = new double[nummaps];
	  logSDarray = new double[nummaps];
	  Xlen = new double[nummaps];
	  for(int i = 0; i < nummaps; i++){
	    logLRarray[i] = -1e5;
	    logSDarray[i] = 1e5;
	    Xlen[i] = -1.0;
	  }
	}

	Cmap *rmap = refmap[refid];// refmap[align->mapid1]

	double origXlen3cum, origlogLR3cum, origlogLR2cum, origlogLR1cum, orignoFP3cum;
	int origFPcnt3;
	if(FPDEBUG){
	  FPcnt3 = 0;
	  Xlen3cum = 0.0;
	  logLR3cum = logLR2cum = logLR1cum = 0.0;
	  noFP3cum = 0.0;
	}

	if(VERB>=2 && giter2 + 1 == 3 && giter + 1 == 3){
	  printf("refid=%d:alignid=%lu..%lu\n",refid,numalign_start[refid],numalign_end[refid]-1);
	  fflush(stdout);
        }

	if(VERB>=3){
          printf("refid=%d: numalign_start=%lu,numalign_end=%lu\n",
		 refid,numalign_start[refid],numalign_end[refid]);
	  fflush(stdout);
        }

	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(DEBUG) assert(align != 0);
	  if(DEBUG && !(align->mapid1 == refid)){
	    printf("giter=%d,giter2=%d:refid=%d,numalign_start[refid]=%lu,numalign_end[refid]=%lu,alignid=%lu,align->mapid1=%d,align->mapid2=%d\n",
		   giter,giter2,refid,numalign_start[refid],numalign_end[refid],alignid,align->mapid1,align->mapid2);
	    fflush(stdout);
	    assert(align->mapid1 == refid);
	  }
	  if(DEBUG>=2) assert(0 <= refid && refid < numrefmaps);
	  int mapid = align->mapid2;
	  if(DEBUG) assert(0 <= mapid);
	  if(DEBUG && !hash_filename && !(mapid < startmaps || (NoSplit <= 1 && startmaps <= mapid && mapid < totalmaps))){
	    printf("alignid=%lu:refid=%d,mapid1=%d,mapid2=%d(id=%lld),nummaps=%d,startmaps=%d,totalmaps=%d,NoSplit=%d\n",
		   alignid,refid,align->mapid1,align->mapid2,Gmap[align->mapid2]->id,nummaps,startmaps,totalmaps,NoSplit);
	    fflush(stdout);
	    assert(mapid < nummaps || (NoSplit <= 1 && startmaps <= mapid && mapid < totalmaps));
	  }
	  if(DEBUG && hash_filename && !(mapid < nummaps || (NoSplit <= 1 && startmaps <= mapid && mapid < totalmaps))){
	    printf("alignid=%lu:refid=%d,mapid1=%d,mapid2=%d(id=%lld),nummaps=%d,startmaps=%d,totalmaps=%d,NoSplit=%d\n",
		   alignid,refid,align->mapid1,align->mapid2,Gmap[align->mapid2]->id,nummaps,startmaps,totalmaps,NoSplit);
	    fflush(stdout);
	    assert(mapid < nummaps || (NoSplit <= 1 && startmaps <= mapid && mapid < totalmaps));
	  }

	  Cmap *nanomap = Gmap[mapid];
	  Cmap *origmap = nanomap;
	  while(origmap->origmap)
	    origmap = origmap->origmap;
	  if(TRACE>=2 && YYmap[refid]->id == REF_TRACE && XXmap[mapid]->id == MAP_TRACE  && align && AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold)){
	    printf("refid=%d/%d(id=%lld),mapid=%d/%d(id=%lld):align score=%0.6f,logPV=%0.2f,numpairs=%d,or=%d: best refid=%d:%s\n",
		   refid,numrefmaps,YYmap[refid]->id,mapid,nummaps,XXmap[mapid]->id,align->score,align->logPV,align->numpairs,align->orientation, origmap->nalign->mapid1,
		   (BestRef && origmap->nalign->mapid1 != refid) ? "Skipping suboptimal refid" : "");
	    fflush(stdout);
	  }
	  if(DEBUG>=2 && BestRef) assert(origmap->nalign->mapid1 >= 0);
	  if(BestRef && origmap->nalign->mapid1 != refid && BestRefExtCheck(align,origmap->nalign,mapid,refid)){
	    if(VERB>=2 && giter2 + 1 == 3 && giter + 1 == 3){
	      printf("BestRef Skipping: refid=%d/%d,mapid=%d/%d:align score=%0.6f,logPV=%0.2f,numpairs=%d,or=%d: best refid=%d,BestRefExtCheck()=%d\n",
	        refid,numrefmaps,mapid,nummaps,align->score,align->logPV,align->numpairs,align->orientation, origmap->nalign->mapid1,BestRefExtCheck(align,origmap->nalign,mapid,refid));
	      fflush(stdout);
	    }
	    continue;/* skip alignment unless it is with the reference with the best alignment score with mapid */
	  }

	  double scale = (align && align->numpairs > 0 && align->scaleID) ? ScaleFactor[align->scaleID] : 1.0;	    
	  double escale = ScaleDeltaBPP ? 1.0 : scale;/* with ScaleDeltaBPP correction : multiply x by escale */
	  double rescale = ScaleDeltaBPP ? scale : 1.0;/* without ScaleDeltaBPP correction : multiply x by (escale * rescale) */

	  int M = nanomap->numsite[0];
	  FLOAT *X = nanomap->site[0];

	  //	  if(AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))/* good alignment */
	  //	    mapcnt++;

	  if(TRACE>=2 && YYmap[refid]->id == REF_TRACE && XXmap[mapid]->id == MAP_TRACE){
	    if(!align || align->numpairs <= 0)
	      printf("refid=%d,mapid=%d(id=%lld),M=%d:no alignment found\n",
		     refid,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0]);
	    else if (!(AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold)))/* no good alignment */
	      printf("refid=%d,mapid=%d(id=%lld),M=%d:no good alignment:score=%0.4f,logPV=%0.3f,orientation=%d,scale=%d(%0.4f),pairs=%d,Lend=%d,Rend=%d,len=%0.3f\n",
		     refid,mapid,Gmap[mapid]->id, Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, align->scaleID, scale,
		     align->numpairs,align->Lend,align->Rend, X[M+1]*origPixelLen/PixelLen);
	    else
	      printf("refid=%d,mapid=%d,M=%d:score=%0.4f,logPV=%0.3f,orientation=%d,scale=%d(%0.4f),pairs=%d,Lend=%d,Rend=%d,mapcnt=%d\n",
		     refid,mapid,Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation, align->scaleID, scale, align->numpairs,align->Lend,align->Rend, mapcnt);
	    fflush(stdout);
	  }

	  if(TRACE && giter == RefRepeats-1 && align->numpairs <= 0){
	    printf("refid=%d,mapid=%d(id=%lld),M=%d:no alignment found\n",
		   refid,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0]);
	    fflush(stdout);
	  }

	  if(1){
	    /* accumulate basic statistics for all remaining alignments.
	       Also re-estimate error parameters from alignments scoring above the thresholds :
	       NOTE : We only look at alignments scoring above the original thresholds (without adjustment with -MapRate) (origgoodalign==1).
	              However Autonoise only uses the subset of those alignments that also satisfy thresholds after adjustment with -MapRate (goodalign==1).
	    */
	    int origgoodalign = AlignedThreshold(align, rmap->site[0], startScoreThreshold, startLogPvThreshold) ? 1 : 0;
	    int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	    if(VERB>=2){
	      printf("alignment[%lu]=%p:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d:numpairs=%d,score=%0.6f,LogPV=%0.2f,len=%0.2f,maxoutlier=%0.4f,Lend=%d,Rend=%d:goodalign=%d,%d\n",
		     alignid,align,refid,rmap->id,mapid,nanomap->id,align->orientation,align->scaleID,align->numpairs,align->score,align->logPV,AlignedLength(align,rmap->site[0]),align->maxoutlier,
		     align->Lend,align->Rend,origgoodalign,goodalign);
	      fflush(stdout);
	    }
	    if(DEBUG && (ALIGN_COMPRESS || align->numpairs >= 1) && !(MultiMatchesUniqueQuery > 0)) 
	      assert(origgoodalign);

	    tcnt++;

	    if(goodalign){
	      mapcnt++;

	      if(VERB>=2  && giter2 + 1 == 3 && giter + 1 == 3){
	        printf("%d:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.6f,logPV=%0.2f,numpairs=%d,origmap->id=%lld: good alignments=%d\n",
		       mapcnt,refid,mapid,nanomap->id,align->orientation,align->score,align->logPV,align->numpairs,origmap->id,mapcnt-origmapcnt);
		fflush(stdout);
	      }
	    }

	    if(DEBUG && !BestRefPV && !((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign))){
	      printf("refid=%d,mapid=%d(id=%lld),or=%d:score= %0.6f, logPV= %0.2f, numpairs=%d, AlignedLength= %0.3f, MapRate= %0.3f, ScoreThreshold= %0.3f, goodalign=%d\n",
		     refid,mapid,Gmap[mapid]->id,align->orientation, align->score, align->logPV, align->numpairs, AlignedLength(align,rmap->site[0]), MapRate, ScoreThreshold, goodalign);
	      fflush(stdout);
	      assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	    }

	    //	    double trueoffset = nanomap->endloc - X[M+1];
	    double LR = 0.0, LRsd = 0.0;

	    int Lij = align->Lij1;
	    int Rij = align->Rij1;
	    int Lijx = align->Lij2;
	    int Rijx = align->Rij2;

	    int I=0,K=0,J=0,RI=0,RK=0,RJ=0;
	    int U = align->numpairs;

	    if(U >= 1){
	      I = align->sites1[0];
	      K = align->sitesK1[0];
	      J = align->sites2[0];
	      RI = align->sites1[align->numpairs-1];
	      RK = align->sitesK1[align->numpairs-1];
	      RJ = align->sites2[align->numpairs-1];
	      
	      //	      offset = Yc(Y,I,K) - (align->orientation==0 ? X[J] : X[M+1]-X[M+1-J]);
	    }

	    if(AlignedFractionThreshold > 0.0 || AlignedLabelDensityThreshold > 0.0){
	      double Xlen = (align->orientation==0) ? X[RJ]-X[J] : X[M+1-J] - X[M+1-RJ];
	      if(Xlen < X[M+1] * AlignedFractionThreshold){
		goodalign = 0;
		fraccnt++;
	      }
	      else if(RJ-J > Xlen * 0.01 * AlignedLabelDensityThreshold){/* NOTE : threshold is in labels per 100kb */
		goodalign = 0;
		LDcnt++;
	      }
	    }

	    //	    double offset = 0.0;

	    
	    totlen += X[M+1] * escale;
	    scoresum += align->score;
	    logPVsum += align->logPV;
	    NumpairsSum += align->numpairs;

	    if(REFSCORE && U >= 1){
	      if(FPDEBUG){
		origFPcnt3 = FPcnt3;
		origXlen3cum = Xlen3cum;
		origlogLR1cum = logLR1cum;
		origlogLR2cum = logLR2cum;
		origlogLR3cum = logLR3cum;
		orignoFP3cum = noFP3cum;
	      }
	      LR = logLR(mapid,refid,X,Y,M,N,align,I,J,K,RJ,Lij,Rij,Lijx,Rijx,0,
			 /* (giter==0 && refid==5 && Gmap[mapid]->id == 3513250) ? 1 : 0 */ 0, SDDEBUG ? &LRsd : 0, NULL);
	      if(DEBUG>=2 && biasWT == 0.0 && align->scaleID==0 && fabs(LR - align->score) >= 1e-3){
	         double LR2 = logLR(mapid,refid,X,Y,M,N,align,I,J,K,RJ,Lij,Rij,Lijx,Rijx,0,1, SDDEBUG ? &LRsd : 0, NULL);
		 printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.6f,logPV=%0.2f:biasWT=%0.6f:LR= %0.6f, LR2= %0.6f\n",
			refid,refmap[refid]->id,mapid,Gmap[mapid]->id,align->orientation,align->score,align->logPV,biasWT,LR,LR2);
		 fflush(stdout);
		 assert(fabs(LR - LR2) < 1e-3 && fabs(LR - align->score) < 1e-3);
	      }

	      if(FPDEBUG && !goodalign){
		Xlen3cum = origXlen3cum;
		FPcnt3 = origFPcnt3;
		logLR1cum = origlogLR1cum;
		logLR2cum = origlogLR2cum;
		logLR3cum = origlogLR3cum;
		noFP3cum = orignoFP3cum;
	      }
	      if(REFDEBUG && (!HashGen || RefRepeats2 <= 1) && !(minSNRestimate && maxresbias > mres * 0.5) && (numrefmaps <= 1 || (BestRef && !BestRefPV)) && !(LR > logLRarray[mapid] - (USE_RFLOAT ? 1e-4 : 1e-6))){
		printf("WARNING: refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:logLR()=%0.6f,score=%0.6f (previous alignment logLR=%0.6f)\n",
		       refid, refmap[refid]->id, mapid, Gmap[mapid]->id, align->orientation, LR,align->score, logLRarray[mapid]);
		double LRb = logLR(mapid,refid,X,Y,M,N,align,I,J,K,RJ,Lij,Rij,Lijx,Rijx,0,1,0,0);
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:logLR()=%0.6f,%0.6f,LRsd=%0.6f,score=%0.6f(previous alignment logLR=%0.6f,LRsd= %0.6f -> %0.6f)\n",
		       refid, refmap[refid]->id, mapid, Gmap[mapid]->id, align->orientation, LR,LRb,LRsd,align->score,logLRarray[mapid],logSDarray[mapid], LRsd);
		if(minSNRestimate)
		  printf("-minSNRestimate requires large values of deltaX and deltaY to work\n");
		fflush(stdout);
		if(!minSNRestimate)
		  assert(LR > logLRarray[mapid] - (USE_RFLOAT ? 1e-4 : 1e-6));
	      }
	      LRsum += LR;

	      if(VERB>=2){
		if(logLRarray){
		  if(SDDEBUG)
		    printf("iter=%d:mapid=%d(id=%lld),or=%d,sc=%d:logLR()=%0.6f -> %0.6f,sum= %0.6f, LRsd= %0.6f -> %0.6f,score=%0.6f,N=%d,M=%d:best I=%d,K=%d,J=%d,Y[I]=%0.3f\n",
			   giter,mapid,Gmap[mapid]->id,align->orientation,align->scaleID,logLRarray[mapid],LR,LRsum, logSDarray[mapid], LRsd, align->score,N,M, RI, RK, RJ, Y[RI]);
		  else
		    printf("iter=%d:mapid=%d(id=%lld),or=%d,sc=%d:logLR()=%0.6f -> %0.6f,sum=%0.6f,score=%0.6f,LRsum=%0.6f,N=%d,M=%d:best I=%d,K=%d,J=%d,Y[I]=%0.3f\n",
			   giter,mapid,Gmap[mapid]->id,align->orientation,align->scaleID,logLRarray[mapid],LR,LRsum, align->score,LRsum,N,M, RI, RK, RJ, Y[RI]);
		} else
		  printf("iter=%d:i=%lu:rid=%d,mapid=%d(id=%lld),or=%d,sc=%d:logLR()=%0.6f,score=%0.6f,LRsum=%0.6f,logPV=%0.2f,N=%d,M=%d:best I=%d,K=%d,J=%d,Y[I]=%0.3f,mapcnt=%d (fp=%d,fn=%0.1f,sitecnt=%d)\n",
			 giter,alignid,refid,mapid,Gmap[mapid]->id,align->orientation,align->scaleID,LR,align->score,LRsum,align->logPV,N,M,  RI, RK, RJ, Y[RI], mapcnt,fp,fn,sitecnt);
		if(VERB>=2){
		  printf("  X[]=");
		  for(int j = 1; j <= M+1; j++)
		    printf("%0.3f,", X[j]);
		  printf("\n");
		  printf("N=%d:Y[1]=%0.3f,Y[N+1]=%0.3f\n",N,Y[1],Y[N+1]);
		}
		fflush(stdout);
	      }
	      if(DEBUG) assert(isfinite(LRsum));

	    } else if(biasWT==0.0)
	      LRsum += LR = align->score;

	    if(REFDEBUG){
	      logLRarray[mapid] = LR;
	      logSDarray[mapid] = LRsd;
	    }

	    if(DEBUG && !(isfinite(align->score) && isfinite(align->logPV))){
	      printf("refid=%d,mapid=%d,M=%d:invalid score or logPV:score=%0.4f,logPV=%0.3f,orientation=%d,pairs=%d,Lend=%d,Rend=%d\n",
		     refid,mapid,Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation,align->numpairs,align->Lend,align->Rend);
	      assert(isfinite(align->score));
	      assert(isfinite(align->logPV));
	    }

	    if(TRACE>=2 && giter == RefRepeats-1 && !goodalign){/* no good alignment */
	      printf("refid=%d,mapid=%d(id=%lld),M=%d:no good alignment:score=%0.4f,logPV=%0.3f,orientation=%d,pairs=%d,Lend=%d,Rend=%d,len=%0.3f\n",
	         refid,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0],align->score,align->logPV, align->orientation,align->numpairs,align->Lend,align->Rend,X[M+1]*origPixelLen/PixelLen);
	      fflush(stdout);
	    }

	    if(goodalign){/* good alignment */
	      if(DEBUG/* >=2 */) assert(align->scaleID < max(1,NumScaleFactor));
	      scaleIDcnt[align->scaleID]++;

	      ATtotlen += X[M+1] * escale;
	      ATscoresum += align->score;
	      ATlogPVsum += align->logPV;
	      ATNumpairsSum += align->numpairs;
	      totsitecnt += M;

	      ATlogLRsum += LR;
	      if(REFDEBUG && SDDEBUG)
		logLRsdsum += logSDarray[mapid];

	      if((TRACE && giter == RefRepeats-1 /* && giter==1 */) || (TRACE && YYmap[refid]->id == REF_TRACE && XXmap[mapid]->id == MAP_TRACE && align->orientation == OR_TRACE)){
		printf("refid=%d,mapid=%d,or=%d,sc=%d(%0.6f):M=%d:score=%0.4f,logPV=%0.3f,pairs=%d,Lend=%d,Rend=%d (mapcnt=%d):ATlogLRsum=%0.6f(LR=%0.6f),ATscoresum=%0.6f,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d\n",
		       refid,mapid,align->orientation,align->scaleID,scale,Gmap[mapid]->numsite[0],align->score,align->logPV,align->numpairs,align->Lend,align->Rend, mapcnt, ATlogLRsum, LR,ATscoresum,
		       I,K,J,RI,RK,RJ);
		fflush(stdout);
	      }

	      if(align->Lend <= -2 && align->sites2[0]-1 >= AlignedSiteThreshold)
		chimcnt++;
	      if(align->Rend <= -2 &&  M-align->sites2[align->numpairs-1] >= AlignedSiteThreshold)
		chimcnt++;
	      if(align->Lend <= -2){
		outlierEndcnt++;
		if(MaxSiteDensity > 0.0){
		  double Xlen = (align->orientation==0 ? X[J] : X[M+1]-X[M+1-J]) * 0.01;/* left length as multiple of 100kb */
		  if(J-1 > MaxSiteDensity * Xlen){
		    HDoutliercnt++;
		    HDsites += J-1;
		    HDlen += Xlen;
		  }
		}
	      }
	      if(align->Rend <= -2){
		outlierEndcnt++;
		if(MaxSiteDensity > 0.0){
		  double Xlen = (align->orientation==0 ? X[M+1] - X[RJ] : X[M+1-RJ]) * 0.01;/* left length as multiple of 100kb */
		  if(M-RJ > MaxSiteDensity * Xlen){
		    HDoutliercnt++;
		    HDsites += M-RJ;
		    HDlen += Xlen;
		  }
		}
	      }
	      if(Gmap[align->mapid2]->origmap){
		chimconf++;
		Cmap *pmap = Gmap[align->mapid2]->origmap;
		if(!NoSplit)
		  while(pmap->origmap)
		    pmap = pmap->origmap;
		if(pmap->name && !(strstr(pmap->name,"R_") || strstr(pmap->name,"C_")))
		  chimconfFP++;
	      }

	      if(TRACE && giter == RefRepeats-1){
		printf("mapid=%d(id=%lld):alignment range Y = %0.3f to %0.3f (X = %0.3f to %0.3f,len=%0.3f)\n", mapid, Gmap[mapid]->id,
		       Y[I-K]/* - (align->Lend <= -2 ? 0.0 : (align->orientation ? X[M+1]-X[M+1-J] : X[J]))*/,
		       Y[RI]/* + (align->Rend <= -2 ? 0.0 : (align->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]))*/,
		       scale * (/*align->Lend > -2 ? 0.0 :*/ (align->orientation ? X[M+1]-X[M+1-J] : X[J])) * origPixelLen/PixelLen,
		       scale * (/*align->Rend > -2 ? X[M+1] :*/ (align->orientation ? X[M+1]-X[M+1-RJ] : X[RJ])) * origPixelLen/PixelLen, X[M+1]*origPixelLen/PixelLen);
		fflush(stdout);
	      }

	      int Ysites = 0, Xsites = 0;/* labels in endoutlier regions */

	      if(nanomap->stitch[0]){
		/* check if there is a stitch anywhere between X[max(1,Lijx)-1 .. J] */
		int stitch = 0;
		for(int j = max(1,Lijx); j <= J; j++)
		  if(nanomap->stitch[0][align->orientation ? M+2-j : j]){
		    stitch = j;
		    if(DEBUG>=2)assert(stitch);
		    break;
		  }
		if(stitch){
		  stitchEnd++;
		  if(align->Lend <= -2)
		    stitchEndOut++;
		}
		/* check if there is a stitch anywhere between X[RJ .. min(M,Rijx)+1] */
		stitch = 0;
		int jmax = min(M,Rijx);
		for(int j = J; j <= jmax; j++)
		  if(nanomap->stitch[0][align->orientation ? M+1-j : j+1]){
		    stitch = j+1;
		    if(DEBUG>=2)assert(stitch);
		    break;
		  }
		if(stitch){
		  stitchEnd++;
		  if(align->Rend <= -2)
		    stitchEndOut++;
		}
	      }

	      /* left end interval */
	      if(align->Lend <= -2){/* end outliers */
		double x = escale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]);
		lenEnd += x;
		sitecntEnd += J-1;
	      } else if(align->Lend > -2){/* regular end interval */
		double x = escale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]);
		lenY += x;/* assume y scaling matches x */
		len += x;
		lenB += max(0.0,x - resK2);

		// HERE HERE : If align->scaleID != 0 && ScaleDeltaBPP : may need to first adjust lij to current unscaled x

		for(int t = max(1,Lij); t < I-K; t++){
		  if(Y[I-K] - Y[t] >= FP_DIST){
		    fnI++;
		    if(TRACE && giter==RefRepeats-1){
		      if(K>0)
			printf("mapid=%d:missing cut at Y[%d]=%0.3f(first aligned site X[%d]=%0.3f,Y[%d..%d]=%0.3f..%0.3f)\n",
			       mapid,t,Y[t],J, x * origPixelLen/PixelLen, I-K,I,Y[I-K],Y[I]);
		      else
			printf("mapid=%d:missing cut at Y[%d]=%0.3f(first aligned site X[%d]=%0.3f,Y[%d]=%0.3f)\n",
			       mapid,t,Y[t],J, x * origPixelLen/PixelLen, I,Y[I]);
		    }
		  }
		}
		for(int t = max(1,Lijx); t < J; t++){
		  double Xt = escale * (align->orientation ? X[M+1]-X[M+1-t] : X[t]);
		  double XJ = escale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]);
		  fp++;
		  if(XJ - Xt >= FP_DIST){
		    fpI++;
		    Xt *= origPixelLen/PixelLen;
		    XJ *= origPixelLen/PixelLen;
		    if(TRACE && giter==RefRepeats-1){
		      if(K>0)
			printf("mapid=%d:false cut at X[%d]=%0.3f(first aligned site X[%d]=%0.3f,Y[%d..%d]=%0.3f..%0.3f)\n",
			       mapid,t,Xt,J, XJ, I-K,I,Y[I-K],Y[I]);
		      else
			printf("mapid=%d:false cut at X[%d]=%0.3f(first aligned site X[%d]=%0.3f,Y[%d]=%0.3f)\n",
			       mapid,t,Xt, J, XJ,I,Y[I]);
		    }
		  }
		}
		// 	      fflush(stdout);

		Ysites += I - K - max(1,Lij);
		Xsites += J - max(1,Lijx);
		if(RESDATA)/* save left end aligned site information */
		  appendres(align,X,Y,M,N,I,K,J,0,0,0,0,0.0,escale,0);

		double y = -1.0;

		if(ENDFIX>=2 && x <= Yc(Y,I,K) && Lij > 1 && ((y = Yc(Y,I,K)-Y[Lij-1]) < x || ENDFIX>=3))/* Sbnd(x,Y[I,K]-Y[Lij-1],n,m) */{
		  double var = QUADRATIC_VARIANCE ? (F2var + S2var*y + R2var*y*y) : (F2var + S2var*y);    // NOTE : should match var in Sbnd()
		  double maxerr2 = var * FnPenalty, y2 = x, var2 = var;
		  if(Lij - 1 > 1 && (y2 = Yc(Y,I,K) - Y[Lij-2]) < x){
		    double var2 = QUADRATIC_VARIANCE ? (F2var + S2var*y2 + R2var*y2*y2) : (F2var + S2var*y2);    // NOTE : should match var in Sbnd()
		    double err2 = x - y2;
		    maxerr2 += err2*err2 * var / var2;
		  }
		  if(TRACE && YYmap[refid]->id == REF_TRACE && XXmap[mapid]->id == MAP_TRACE && align->orientation == OR_TRACE){
		    printf("refid=%d,mapid=%d,or=%d,sc=%d:Left End:I=%d,K=%d,J=%d,Lij=%d:x=%0.6f,Yc(Y,I,K)=%0.6f,Y[Lij-1]=%0.6f,y=%0.6f,y2=%0.6f,X[M+1]=%0.6f,X[M+1-J]=%0.6f,var(y,y2)=%0.6e,%0.6e\n",
			   refid,mapid,align->orientation,align->scaleID,I,K,J,Lij,x,Yc(Y,I,K),Y[Lij-1],y,y2,X[M+1],X[M+1-J],var,var2);
		    fflush(stdout);
		  }
		  appenderror(x,y,0.0,maxerr2,mapid, (align->orientation == 0) ? 0 : M+1-J, (align->orientation == 0) ? J : M+1, 1, 0, refid, align, -1, -1, I, K);
		}
	      }
	      /* right end interval */
	      if(align->Rend <= -2){
		double x = escale * (align->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]);
		lenEnd += x;
		sitecntEnd += M - RJ;
	      }
	      if(align->Rend > -2){
		double x = escale * (align->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]);
		lenY += x;
		len += x;
		lenB += max(0.0,x - resK2);

		// HERE HERE : If align->scaleID != 0 && ScaleDeltaBPP : may need to adjust Rij to current unscaled x

		int tmax = min(N,Rij);
		for(int t = RI+1; t <= tmax; t++){
		  if(Y[t]-Y[RI] >= FP_DIST){
		    fnI++;
		    if(TRACE && giter==RefRepeats-1){
		      if(RK>0)
			printf("mapid=%d:missing cut at Y[%d]=%0.3f(last aligned site X[%d]=%0.3f,Y[%d..%d]=%0.3f..%0.3f)\n",
			       mapid,t,Y[t],RJ, x * origPixelLen/PixelLen,RI-RK,RI,Y[RI-RK],Y[RI]);
		      else
			printf("mapid=%d:missing cut at Y[%d]=%0.3f(last aligned site X[%d]=%0.3f,Y[%d]=%0.3f)\n",
			       mapid,t,Y[t],RJ, x * origPixelLen/PixelLen,RI,Y[RI]);
		    }
		  }
		}
		tmax = min(M,Rijx);
		for(int t = RJ+1; t <= tmax; t++){
		  double Xt = escale * (align->orientation ? X[M+1]-X[M+1-t] : X[t]);
		  double XJ = escale * (align->orientation ? X[M+1]-X[M+1-RJ] : X[RJ]);
		  fp++;
		  if(Xt - XJ >= FP_DIST){
		    fpI++;
		    Xt *= origPixelLen/PixelLen;
		    XJ *= origPixelLen/PixelLen;
		    if(TRACE && giter==RefRepeats-1){
		      if(RK > 0)
			printf("mapid=%d:false cut at X[%d]=%0.3f(last aligned site X[%d]=%0.3f,Y[%d..%d]=%0.3f..%0.3f)\n",
			       mapid,t, Xt, RJ, XJ, RI-RK, RI, Y[RI-RK],Y[RI]);
		      else
			printf("mapid=%d:false cut at X[%d]=%0.3f(last aligned site X[%d]=%0.3f,Y[%d]=%0.3f)\n",
			       mapid,t, Xt, RJ, XJ,  RI, Y[RI]);
		    }
		  }
		}
		// 	      fflush(stdout);

		Ysites += min(N,Rij)-RI;
		Xsites += min(M,Rijx)-RJ;
		double y = -1.0;
		if(ENDFIX>=2 && x <= Y[N+1]-Yc(Y,RI,RK) && Rij < N && ((y = Y[Rij+1]-Yc(Y,RI,RK)) < x || ENDFIX>=3))/* Sbnd(x,Y[Rij+1]-Yc(Y,RI,RK),M+1-RJ,Rij+1-RI) */{
		  double var = QUADRATIC_VARIANCE ? (F2var + S2var*y + R2var*y*y) : (F2var + S2var*y);    // NOTE : should match var in Sbnd()
		  double maxerr2 = var * FnPenalty, y2 = x, var2 = var;
		  if(Rij + 1 < N && (y2 = Y[Rij+2] - Yc(Y,RI,RK)) < x){
		    double var2 = QUADRATIC_VARIANCE ? (F2var + S2var*y2 + R2var*y2*y2) : (F2var + S2var*y2);    // NOTE : should match var in Sbnd()
		    double err2 = x - y2;
		    maxerr2 += err2*err2 * var / var2;
		  }
		  
		  if(TRACE && YYmap[refid]->id == REF_TRACE && XXmap[mapid]->id == MAP_TRACE && align->orientation == OR_TRACE){
		    if(align->orientation)
		      printf("refid=%d,mapid=%d,or=%d,sc=%d:Right End:N=%d,M=%d:RI=%d,RK=%d,RJ=%d,Rij=%d:x=%0.6f,Yc(Y,RI,RK)=%0.6f,Y[N+1]=%0.6f,Y[Rij,Rij+1,Rij+2]=%0.6f,%0.6f,%0.6f,y=%0.6f,y2=%0.6f,X[M+1]=%0.6f,X[M+1-RJ]=%0.6f,var(y,y2)=%0.6e,%0.6e\n",
			     refid,mapid,align->orientation,align->scaleID,N,M,RI,RK,RJ,Rij,x,Yc(Y,RI,RK),Y[N+1],Y[Rij],Y[Rij+1],Y[Rij+2],y,y2,X[M+1],X[M+1-RJ],var,var2);
		    else
		      printf("refid=%d,mapid=%d,or=%d,sc=%d:Right End:N=%d,M=%d:RI=%d,RK=%d,RJ=%d,Rij=%d:x=%0.6f,Yc(Y,RI,RK)=%0.6f,Y[N+1]=%0.6f,Y[Rij,Rij+1,Rij+2]=%0.6f,%0.6f,%0.6f,y=%0.6f,y2=%0.6f,X[M+1]=%0.6f,X[RJ]=%0.6f,var(y,y2)=%0.6e,%0.6e\n",
			     refid,mapid,align->orientation,align->scaleID,N,M,RI,RK,RJ,Rij,x,Yc(Y,RI,RK),Y[N+1],Y[Rij],Y[Rij+1],Y[Rij+2],y,y2,X[M+1],X[RJ],var,var2);
		    fflush(stdout);
		  }
		  appenderror(x,y,0.0,maxerr2,mapid,(align->orientation == 0) ? RJ : 0, (align->orientation == 0) ? M+1 : M+1-RJ, 1, 0, refid, align, RI,RK,-1, -1);
		}
	      }// if(align->Rend > -2) 

	      sitecnt += Ysites + 1 + (RESSD ? K : (SCORE_APPROX && K) ? ((SCORE_APPROX>=2 || MIS_VITERBI) ? K : 1) : 0);
	      sitecntY += Ysites + 1;
	      sitecntX += Xsites + 1;
	      fn += Ysites + ((RESSD==0 && SCORE_APPROX>=2 && K >= 2) ? K-1 : 0);
	      if(VERB>=3 && giter==0 && mapid==11){
                printf("\t mapid=%d:Ysites=%d,K=%d:fp=%d,fn=%0.1f,sitecnt=%d\n",mapid,Ysites,K,fp,fn,sitecnt);
		fflush(stdout);
              }

	      if(K > 0)/* add penalty for Sm()-log(pTP) to PrPen */
		PrPen += PRtabY[K][I].Sm/*Sm(J,I,K,Y)*/ - log_pTP;
	      int H = I;
	      int D = K;
	      int G = J;
	      double xsum = 0.0;/* sum of x for non-outliers for this mapdi (for debugging) */
	      double ysum = 0.0;/* sum of y for non-outliers for this mapid */
	      double xysum = 0.0;/* sum of xy/var for this mapid */
	      double x2sum = 0.0;/* sum of xx/var for this mapid */
	      double y2sum = 0.0;/* sum of yy/var for this mapid */
	      double xtot = 0.0;/* sum of x for all aligned intervals */
	      double ytot = 0.0;/* sum of y for all aligned intervals */

	      for(int T=1;T < U;T++, H = I, D = K, G = J){
		I = align->sites1[T];
		K = align->sitesK1[T];
		J = align->sites2[T];
		double y = Yc(Y,I,K) - Yc(Y,H,D);
		double x = escale * ((align->orientation==0) ? X[J] - X[G] : X[M+1-G] - X[M+1-J]);
		int n = I - K - H;
		int m = J - G;

		int stitch;
		if(STITCH){/* check if there is a stitch anywhere between X[G..J] */
		  stitch = 0;
		  if(nanomap->stitch[0]){
		    for(int j = G; j < J; j++ )
		      if(nanomap->stitch[0][align->orientation ? M+1-j : j+1]){
			stitch = j+1;
			if(DEBUG>=2)assert(stitch);
			break;
		      }
		    if(stitch)
		      stitchcnt++;
		  }
		}

		lenY += y;
		ytot += y;
		xtot += x;

		double var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
		if(QUADRATIC_VARIANCE)
		  var += SR[0]*SR[0]*y*y;

		double resvar = 0.0;
		double errL = Y[H] - Y[H-D];
		double errR = Y[I] - Y[I-K];
		if(RES_VARIANCE)
		  resvar = errL*errL + errR*errR;
		var += resvar * SE[0] * SE[0];

		double err = x - y, maxerr2 = 1e+10;
		double errmargin = 1e+10; /* how much Gauss error term can increase before current interval becomes an outlier */

		double Bias= 0.0, Gauss= 0.0, Pen= 0.0, PenSm= 0.0, OutPen= 0.0, minscore = -1e+10, outscore= -1e+10, iscore = -1e+10;

		if(Poutlier > 0.0 && OUTLIER(maptype,x*rescale,y)){// NOTE : outlier error limit (see outlierMax) is determined without ScaleDeltaBPP correction
		  outliertot++;

		  // errmargin == align->iscore[T] - align->outscore[T]; /* how much Gauss error term can increase before current interval becomes an outlier */

		  SintDetail(x,y,m,n,J,I,K,D,PRtabY,Y,Bias,Pen,Gauss,PenSm,0);
		  OutPen = OutlierPenalty;
		  if(outlierBC)
		    OutPen += OutlierPenaltyBC[m] + OutlierPenaltyBC[n];
		  
		  outscore = Bias + Pen + Gauss + PenSm;
		  if(maptype){
		    if(OUTLIER_LTYPE==0)
		      OutPen -= (x+y) * OutlierLambdaInv;
		    else
		      OutPen -= fabs(x-y) * OutlierLambdaInv;

#if 0 // OLD
		    if(DEBUG/* HERE HERE && REFDEBUG */)
		      iscore = (OUTLIER_TYPE1 == 0) ? OutlierBias + max(Bias + Pen + Gauss, OutPen + Bias * biasWToutlierF) + PenSm :
			OutlierBias + Pen + max(Bias + Gauss, OutPen + Bias * biasWToutlierF) + PenSm;
		    minscore = (OUTLIER_TYPE1 == 0) ? OutlierBias + OutPen + Bias * biasWToutlierF + PenSm :
		      OutlierBias + Pen + OutPen + Bias * biasWToutlierF + PenSm;
#else // NEW
		    if(DEBUG/* HERE HERE && REFDEBUG */)
		      iscore = OutlierBias + max(Bias + Pen + Gauss, OutPen + Pen*OUTLIER_TYPE1 + Bias * biasWToutlierF) + PenSm;
		    minscore = OutlierBias + Pen*OUTLIER_TYPE1 + OutPen + Bias * biasWToutlierF + PenSm;
#endif
		  } else {
		    if(DEBUG) assert(OUTLIER_DELTA(x*rescale - y));
		    OutPen -= fabs(x-y) * OutlierLambdaInv;
		    
#if 0 // OLD
		    if(DEBUG/* HERE HERE && REFDEBUG */)
		      iscore = (OUTLIER_TYPE==0) ? OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + OutPen) + PenSm :
			OutlierBias + Pen + max(Bias + Gauss, Bias * biasWToutlierF + OutPen) + PenSm;
		    minscore = (OUTLIER_TYPE==0) ? OutlierBias + Bias * biasWToutlierF + OutPen + PenSm :
			OutlierBias + Pen + Bias * biasWToutlierF + OutPen + PenSm;
#else // NEW
		    if(DEBUG/* HERE HERE && REFDEBUG */)
		      iscore = OutlierBias + max(Bias + Pen + Gauss, Bias * biasWToutlierF + Pen * OUTLIER_TYPE + OutPen) + PenSm;
		    minscore = OutlierBias + Pen*OUTLIER_TYPE + Bias * biasWToutlierF + OutPen + PenSm;
#endif
		  }

		  // NOTE : outscore is the current score without outlier adjustment, minscore is the outlier score, iscore is the final score : for outliers outscore < minscore
		  // iscore == max(outscore,minscore)
		  errmargin = outscore /* WAS7 align->outscore[T] */ + OUTLIER_MARGIN - minscore;
		  maxerr2 = min(1.0e+10, err*err + errmargin * var * 2.0);

		  double ExpOutPen = exp(OutPen);
		  double val = ExpOutPen <= 0.0 ? 0.0 : ExpOutPen/(ExpOutPen + exp(Pen + Gauss));
		  if(DEBUG && !isfinite(val)){
	            printf("WARNING:refid=%d(id=%lld),mapid=%d(id=%lld),M=%d,N=%d:score=%0.4f,logPV=%0.3f,or=%d,pairs=%d:Pen=%0.6e,Gauss=%0.6e,OutPen=%0.6e,val=%0.6e\n",
			   refid,YYmap[refid]->id,mapid,Gmap[mapid]->id,Gmap[mapid]->numsite[0],YYmap[refid]->numsite[0],align->score,align->logPV, align->orientation, align->numpairs, Pen, Gauss,OutPen, val);
		    printf("    I=%d,K=%d,J=%d,m=%d,n=%d,x=%0.4f,y=%0.4f,Bias=%0.6e,PenSm=%0.6e,OutlierPenalty=%0.6e,OutlierPenaltyBC[m,n]=%0.6e,%0.6e,maxN=%lld,maxM=%lld\n",
	              I,K,J,m,n,x,y,Bias,PenSm,OutlierPenalty,OutlierPenaltyBC[m],OutlierPenaltyBC[n],maxN,maxM);
		    printf("    OutlierLambdaInv=%0.6e,ExpOutPen=%0.6e,exp(Pen+Gauss)=%0.6e\n",OutlierLambdaInv,ExpOutPen,exp(Pen+Gauss));

		    SintDetail(x,y,m,n,J,I,K,D,PRtabY,Y,Bias,Pen,Gauss,PenSm,1);

	            fflush(stdout);
	            assert(isfinite(val));
	          }
		  outliersum += val;
		  if(DEBUG) assert(isfinite(outliersum));

		  if(align->outscore[T] + OUTLIER_MARGIN < align->iscore[T] || maxerr2 < 0.0){// NOTE : maxerr2 < 0 is rare and can only happen if align->scaleID != 0
		    if(DEBUG && !ScaleDeltaBPP && REFDEBUG && !(outscore < iscore)){
		      #pragma omp critical
		      {
			printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:outlier alignment between Y[%d..%d]=%0.3f..%0.3f(y=%0.4f) and X[%d..%d]=%0.3f..%0.3f(x=%0.4f)\n",
			       refid,rmap->id,mapid,nanomap->id,align->orientation,H,I,Yc(Y,H,D),Yc(Y,I,K),Yc(Y,I,K)-Yc(Y,H,D),G,J,
			       escale*(align->orientation ? X[M+1]-X[M+1-G] : X[G])*origPixelLen/PixelLen,
			       escale*(align->orientation ? X[M+1]-X[M+1-J] : X[J])*origPixelLen/PixelLen,
			       escale*(align->orientation ? X[M+1-J]-X[M+1-G] : X[J]-X[G])*origPixelLen/PixelLen);
			printf("\t Bias=%0.6f,Gauss=%0.6f,Pen=%0.6f,PenSm=%0.6f,OutPen=%0.6f,outscore=%0.6f,iscore=%0.6f:T=%d:align->outscore[T]=%0.6f,align->iscore[T]=%0.6f\n",
			       Bias,Gauss,Pen,PenSm,OutPen,outscore,iscore,T,align->outscore[T],align->iscore[T]);
			fflush(stdout);
			assert(outscore < iscore);
		      }
		    }
		    outliercnt++;
		    if(STITCH && stitch)
		      stitchOut++;
		    if(TRACE && giter==RefRepeats-1){
		      printf("mapid=%d:outlier alignment between Y[%d..%d]=%0.3f..%0.3f and X[%d..%d]=%0.3f..%0.3f\n",
			     mapid,H,I,Yc(Y,H,D),Yc(Y,I,K),G,J,
			     escale*(align->orientation ? X[M+1]-X[M+1-G] : X[G])*origPixelLen/PixelLen,
			     escale*(align->orientation ? X[M+1]-X[M+1-J] : X[J])*origPixelLen/PixelLen);
		      fflush(stdout);
		    }
		    int Slabels = (RESSD ? K : ((SCORE_APPROX && K) ? ((SCORE_APPROX>=2 || MIS_VITERBI) ? K : 1) : 0));
		    int Mlabels = ((RESSD==0 && SCORE_APPROX>=2 && K >= 2) ? K-1 : 0);

		    if(1 /* WAS maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE*/){/* include both fp,fn and Sm() term at right end, since they are not excluded from outlier */
		      double TYPE = maptype ? OUTLIER_TYPE1 : OUTLIER_TYPE;
		      double NotTYPE = 1.0 - TYPE;

		      len += x * TYPE;
		      lenB += max(0.0,x - resK2) * TYPE;
		      
		      sitecnt += (n + Slabels)*TYPE;
		      sitecntY += n*TYPE;
		      sitecntX += m*TYPE;
		      fn += (n-1)*TYPE + Mlabels;
		      fp += (m-1)*TYPE;

		      if(STITCH && stitch){/* ???*/
			lenS += x * TYPE;
			sitecntS += (n + Slabels)*TYPE;
			fnS += (n-1 + Mlabels)*TYPE;
			fpS += (m-1)*TYPE;
		      }

		      lenOut += x * NotTYPE;
		      sitecntOut += (n+Slabels)*NotTYPE;
		      sitecntOutY += n*NotTYPE;
		      sitecntOutX += n*NotTYPE;
		      
		      Cprtab *pr = &PRtabY[K][I];
		      if(FIX_OUTLIER_MIS){/* Sm() term at right end is not part of outlier */
		        PrPen += pr->Sm - log_pTP;
			sitecntOut -= Slabels*NotTYPE;
			sitecnt += Slabels*NotTYPE;
			fn += Mlabels * NotTYPE;
		      } else {
			PrPen += (pr->Sm - log_pTP) * TYPE;
		      }
		    } else {
		      lenOut += x;
		      sitecntOut += n + Slabels;
		      sitecntOutY += n;
		      sitecntOutX += m;
		      if(FIX_OUTLIER_MIS){/* Sm() term at right end is not part of outlier */
			Cprtab *pr = &PRtabY[K][I];
			PrPen += pr->Sm - log_pTP;
			sitecntOut -= Slabels;
			sitecnt += Slabels;
			fn += Mlabels;
		      }
		    }

		    if(VERB>=3 && giter==0 && mapid==11){
                      printf("\t mapid=%d:T=%d/%d:I=%d,K=%d,J=%d(H=%d,D=%d,G=%d),m=%d,n=%d: outlier: fp=%d,fn=%0.1f,sitecnt=%d\n",mapid,T,U,I,K,J,H,D,G,m,n,fp,fn,sitecnt);
		      fflush(stdout);
                    }

		    if(RESDATA)/* save res/resKB based information for current interval (including outliers) */
		      appendres(align,X,Y,M,N,I,K,J,H,D,G,T,x,escale,1);
		    continue;// don't include this outlier interval in error parameter estimation
		  }
		} // if( Poutlier > 0 ... )

		if(RESDATA)/* save res/resKB based information for current interval (including outliers) */
		  appendres(align,X,Y,M,N,I,K,J,H,D,G,T,x,escale,0);

		Cprtab *pr = &PRtabY[K][I];
		PrPen += pr->LogPr + pr->Sm - log_pTP;

		len += x;
		lenB += max(0.0,x - resK2);
		for(int t = H+1; t < I-K; t++){
		  if(Y[t]-Y[H] >= FP_DIST && Y[I-K]-Y[t] >= FP_DIST){
		    fnI++;
		    if(TRACE && giter==RefRepeats-1){
		      if(D > 0 || K > 0)
			printf("mapid=%d:missing cut at Y[%d]=%0.3f (between aligned sites X[%d]=%0.3f,Y[%d..%d]=%0.3f..%0.3f and X[%d]=%0.3f,Y[%d..%d]=%0.3f..%0.3f)\n",
			       mapid,t,Y[t],G, escale*(align->orientation ? X[M+1]-X[M+1-G] : X[G])*origPixelLen/PixelLen,H-D,H,Y[H-D],Y[H], J, escale*(align->orientation ? X[M+1]-X[M+1-J]: X[J])*origPixelLen/PixelLen,I-K,I,Y[I-K],Y[I]);
		      else
			printf("mapid=%d:missing cut at Y[%d]=%0.3f (between aligned sites X[%d]=%0.3f,Y[%d]=%0.3f and X[%d]=%0.3f,Y[%d]=%0.3f)\n",
			       mapid,t,Y[t],G, escale*(align->orientation ? X[M+1]-X[M+1-G] : X[G])*origPixelLen/PixelLen,H,Y[H], J, escale*(align->orientation ? X[M+1]-X[M+1-J]: X[J])*origPixelLen/PixelLen,I,Y[I]);
		    }
		  }
		}

		for(int t = G+1; t < J; t++){
		  double Xt = escale * (align->orientation ? X[M+1]-X[M+1-t] : X[t]);
		  double XG = escale * (align->orientation ? X[M+1]-X[M+1-G] : X[G]);
		  double XJ = escale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]);
		  if(Xt-XG >= FP_DIST && XJ - Xt >= FP_DIST){
		    fpI++;
		    Xt *= origPixelLen/PixelLen;
		    XG *= origPixelLen/PixelLen;
		    XJ *= origPixelLen/PixelLen;
		    if(TRACE && giter==RefRepeats-1){
		      if(D > 0 || K > 0)
			printf("mapid=%d:false cut at X[%d]=%0.3f (between aligned sites X[%d]=%0.3f,Y[%d..%d]=%0.3f..%0.3f and X[%d]=%0.3f,Y[%d..%d]=%0.3f..%0.3f)\n",
			       mapid,t, Xt, G, XG ,H-D,H,Y[H-D],Y[H], J, XJ, I-K,I,Y[I-K],Y[I]);
		      else
			printf("mapid=%d:false cut at X[%d]=%0.3f (between aligned sites X[%d]=%0.3f,Y[%d]=%0.3f and X[%d]=%0.3f,Y[%d]=%0.3f)\n",
			       mapid,t, Xt, G, XG, H, Y[H], J, XJ, I, Y[I]);
		    }
		  }
		}
		fflush(stdout);

		sitecnt += n + (RESSD ? K : ((SCORE_APPROX && K) ? ((SCORE_APPROX>=2 || MIS_VITERBI) ? K : 1) : 0));
		sitecntY += n;
		sitecntX += m;
		fn += n-1 + ((RESSD==0 && SCORE_APPROX>=2 && K >= 2) ? K-1 : 0);
		fp += m-1;
		if(VERB>=3 && giter==0 && mapid==11){
                  printf("\t mapid=%d:T=%d/%d:I=%d,K=%d,J=%d(H=%d,D=%d,G=%d)m=%d,n=%d: fp=%d,fn=%0.1f,sitecnt=%d\n",mapid,T,U,I,K,J,H,D,G,m,n,fp,fn,sitecnt);
		  fflush(stdout);
                }

		if(STITCH && stitch){
		  lenS += x;
		  sitecntS += n + (RESSD ? K : (SCORE_APPROX && K) ? ((SCORE_APPROX>=2 || MIS_VITERBI) ? K : 1) : 0);
		  fnS += n-1 + ((RESSD==0 && SCORE_APPROX>=2 && K >= 2) ? K-1 : 0);
		  fpS += m-1;
		}

		/* Update bppSD estimate */
		double Ivar = 1.0/var;
		xsum += x;
		ysum += y;
		y2sum += y * y * Ivar;
		xysum += y * x * Ivar;
		x2sum += x * x * Ivar;
		if(VERB>=3 && Gmap[mapid]->id == 92 && giter2==RefRepeats2-1 && giter==RefRepeats-1 && xysum > 0.0){
		  printf("    T=%d/%d:x=%0.4f,y=%0.4f,sd=%0.6f,Ivar=%0.8e(resvar=%0.8e):y2sum=%0.8f,xysum=%0.8f,x2sum=%0.8f (incscale = %0.6f, ysum = %0.6f)\n",
			 T,U,x,y,sqrt(var),Ivar,resvar,y2sum,xysum,x2sum, y2sum/xysum, ysum);
		  fflush(stdout);
		}

		if((DEBUG/* HERE >=2 */ && !align->scaleID && (NumScaleFactor <= 1 || hashScaleDelta >= 3) && !(errmargin >= -1e-8 && maxerr2 >= 1e-8)) || (VERB>=2 && giter==1 && mapid==11)){
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,sc=%d: T=%d/%d: I=%d,K=%d,J=%d,D=%d,m=%d,n=%d,x=%0.6f,y=%0.6f(errL=%0.6f,errR=%0.6f),var=%0.8e,err=%0.6f,errmargin=%0.8e,err*err=%0.8f,maxerr2=%0.8f\n",
	             refid,YYmap[refid]->id,mapid,XXmap[mapid]->id,align->orientation,align->scaleID,T,U,I,K,J,D,m,n,x,y,errL,errR,var,err,errmargin,err*err,maxerr2);
		  printf("\t scale= %0.8f, rescale= %0.8f, align->outscore[T]= %0.8f, align->iscore[T]= %0.8f, OUTLIER_MARGIN= %0.8f, minscore= %0.8f, outscore= %0.8f, iscore= %0.8f\n", 
			 scale, rescale, align->outscore[T], align->iscore[T], OUTLIER_MARGIN, minscore, outscore, iscore);
#if DEBUG // HERE HERE && REFDEBUG
		  printf("\t Pen= %0.8f, Gterm= %0.8f, Gerr= %0.8f, Gauss= %0.8f, Bias= %0.8f, Sm= %0.8f, OutlierBias + OutPen= %0.8f\n",
			 Pen,Gauss + err*err/(var*2.0), err*err/(var*2.0), Gauss, Bias, PenSm, OutlierBias + OutPen);
#endif
		  fflush(stdout);
		  if(DEBUG>=1+RELEASE && !align->scaleID && (NumScaleFactor <= 1 || hashScaleDelta >= 3)){
		    assert(errmargin >= -1e-5 * max(fabs(outscore),fabs(minscore)));
		    assert(maxerr2 >= -1e-8);
		  }
		}
		maxerr2 = max(0.0, maxerr2);

		segcnt++;

		/* append error information of current interval to errors[0..numerrors-1] */
 		appenderror(x,y,resvar,maxerr2,mapid,(align->orientation == 0) ? G : M+1-J, (align->orientation == 0) ? J : M+1-G, 0, (STITCH && stitch) ? (align->orientation ? -1 : 1) : 0, refid, align, H,D,I,K);
	      }// for(T=1; T < U; T++)

	      if(DEBUG) assert(H==RI && G==RJ && D==RK);
	      if(DEBUG>=2) assert(align->numpairs >= AlignedSiteThreshold);

	      if(xysum > 0.0){/* update local Query map scaling factor */
 	        if(DEBUG>=2) assert(ysum > 0.0);
	        nanomap->y2sum += y2sum;
	        nanomap->xysum += xysum;
		nanomap->incwt += ysum;
		nanomap->incscale = nanomap->y2sum/nanomap->xysum;
		
#if 0
		nanomap->xsum += xsum;
		nanomap->Xlen += xtot;
		nanomap->Ylen += ytot;
#endif
	      }

	      if(VERB>=2 && Gmap[mapid]->id == 2 && giter2==RefRepeats2-1 && giter==RefRepeats-1){
		printf("mapid=%d(id=%lld):score=%0.2f,logPV=%0.3f,numpairs=%d:len=%0.3f kb, local scaling = %0.6f (cum = %0.6f) fn=%0.1f, fp=%d, sitecnt=%d\n",
		       mapid,nanomap->id,align->score,align->logPV,align->numpairs, X[M+1], nanomap->incscale, nanomap->incscale * nanomap->cumscale, fn, fp, sitecnt);
		fflush(stdout);
	      }
	    }
	  }

          if(VERB>=2){
	    if(!align || align->numpairs <= 1) {
	      if(align)
		printf("refid=%d,mapid=%d,M=%d:no valid alignment:score=%0.4f,orientation=%d,pairs=%d,Lend=%d,Rend=%d\n",
		       refid,mapid,Gmap[mapid]->numsite[0],align->score,align->orientation,align->numpairs,align->Lend,align->Rend);
	      else
		printf("refid=%d,mapid=%d,M=%d:no valid alignment\n", refid,mapid,Gmap[mapid]->numsite[0]);
	    } else {
	      int I = align->sites1[0];
	      int K = align->sites1[0];
	      int J = align->sites2[0];
	      int M = nanomap->numsite[0]; 
	      //	    FLOAT *Y = rmap->site[0];
	      FLOAT *X = nanomap->site[0];
	      double offset = Yc(Y,I,K) - scale*(align->orientation==0 ? X[J] : X[M+1]-X[M+1-J]);
	      double trueoffset = nanomap->endloc - scale*X[M+1];
	      if(fabs(offset- trueoffset) > 2*Ylambda)
		errcnt++;
	      totcnt++;
	      printf("refid=%d,mapid=%d,N=%d,M=%d:best alignment:score=%0.4f,logPV=%0.4f,orientation=%d,pairs=%d,loc=%0.3f,offset=%0.3f%c(%llu/%llu):Lend=%d,Rend=%d,chimcnt=%d,confirmed=%d(FP=%d),pairs=%d,id=%lld,origid=%lld\n",
		     refid,mapid,N,M,align->score,align->logPV,align->orientation,align->numpairs,offset,trueoffset,
		     fabs(offset - trueoffset) > 2*Ylambda ? '!' : ' ',(unsigned long long)errcnt,(unsigned long long)totcnt,
		     align->Lend,align->Rend,chimcnt,chimconf,chimconfFP,chimpaircnt,Gmap[mapid]->id,Gmap[mapid]->origmap ? Gmap[mapid]->origmap->id : -1);
	    }
	    fflush(stdout);
	  }
	} /* loop over alignid/mapid */
      }/* if ( !NoStat) */ else {/* Update mapcnt : cumulative number of maps with good alignment to refid */

	if(VERB>=2 && giter2 + 1 == 3 && giter + 1 == 3){
	  printf("refid=%d:numalign_start=%lu,numalign_end=%lu\n",refid,numalign_start[refid],numalign_end[refid]);
	  fflush(stdout);
	}

	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(DEBUG) assert(align != 0);
	  if(DEBUG) assert(align->mapid1 == refid);
	  int mapid = align->mapid2;
	  if(DEBUG) assert(mapid >= 0);
	  if(DEBUG && !hash_filename) assert(mapid < startmaps || (NoSplit <= 1 && orignummaps[refid] <= mapid && (refid >= numrefmaps-1 ? mapid < totalmaps : mapid < orignummaps[refid+1])));
	  if(DEBUG && hash_filename) assert(mapid < nummaps || (NoSplit <= 1 && startmaps <= mapid && mapid < totalmaps));
	  Cmap *nanomap = Gmap[mapid];
	  Cmap *origmap = nanomap;
	  while(origmap->origmap)
	    origmap = origmap->origmap;
	  if(DEBUG>=2 && BestRef) assert(origmap->nalign->mapid1 >= 0);
	  if(DEBUG>=2) assert(align->mapid1 == refid);
	  if(DEBUG>=2) assert(align->mapid2 == mapid);
	  Cmap *rmap = refmap[refid];

	  if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
	    continue;
	    
	  if(BestRef && origmap->nalign->mapid1 != refid && BestRefExtCheck(align,origmap->nalign,mapid,refid))
	    continue;/* skip alignment unless it is with the reference with the best alignment score with mapid */

	  mapcnt++;/* good alignments */
	}
      }

      if(VERB>=2 && BestRef){
	printf("[refid=%d:alignments=mapcnt=%d/%llu (alignids=%llu..%llu), origmapcnt=%d]\n",refid,mapcnt,(unsigned long long)numaligns,(unsigned long long)numalign_start[refid],(unsigned long long)numalign_end[refid]-1,origmapcnt);
	fflush(stdout);
      }

#if 0 // HERE : terminate refid = 0 .. numrefmaps-1 loop and start another one later to handle Refine() AFTER doing all pre-refinement file output. This will allow score_free() to be called
      // before doing refinement. Needs validation
    }

    for(int refid = 0;refid < (extendSplit ? numrefmaps : Hapnumrefmaps);refid++){// NOTE : with extendSplit, numrefmaps loop bound may increase due to contig splits. Original value of numrefmaps is orignumrefmaps
      Cmap *rmap = refmap[refid];
      FLOAT *Y = rmap->site[0];
      int N = rmap->numsite[0];
#endif // HERE

      if(Refine && !(MapScale && giter==0 && !origMapScale && !pSNRtotLL)){/* create a refined reference map and output it */
	if(DEBUG>=1+RELEASE) assert(!RefSplit);

	if(SCORE_MINMEM && !NoStat)
	  score_free(0,scorerefmaps);// will be recomputed after Refine

	if(DEBUG) assert(giter == RefRepeats-1 && giter2==0);
	if(DEBUG && EARLY_ALIGN_FILTER) assert(LogPvThreshold == startLogPvThreshold && ScoreThreshold == startScoreThreshold);

	if(VERB){
	  printf("Refining refmap %d(id=%lld,len=%0.3f,Y[N]-Y[1]=%0.3f,Y[1]=%0.3f), mapcnt=%d(%d-%d)/%d (Refine=%d, start=%lu,end=%lu, L= 0x%lx, R= 0x%lx)\n",
		 refid,rmap->id,Y[N+1],Y[N]-Y[1],Y[1],mapcnt-origmapcnt,mapcnt,origmapcnt,nummaps,Refine, numalign_start[refid], numalign_end[refid],
		 rmap->Mask[0] ? rmap->Mask[0][1] : 0x0, rmap->Mask[0] ? rmap->Mask[0][N+1] : 0x0);
	  printf("\t refineMinWT= %0.3e, refineWT= %0.3f, extendWT= %0.3f, extendMinWT= %0.3e, splitFiltMinWT= %0.3e, extendMaxOutlierKB= %0.3f,%d,%0.3f,%d extendMaxWT= %0.3e\n",
		 refineMinWT,refineWT, extendWT,extendMinWT,splitFiltMinWT,extendMaxOutlierKB, extendMaxOutlierLabels,extendMaxOutlierKBsplit,extendMaxOutlierLabelsSplit,extendMaxWT);
	  if(VERB>=2)
	    for(int t = 0; t < numrefmaps; t++){
	      printf("refmap[%d]= %p: id=%lld, Allele=%d, contig=%p\n", t, refmap[t], refmap[t]->id, refmap[t]->Allele, refmap[t]->contig);
	      if(refmap[t]->contig && refmap[t]->contig->contig)
		printf("\t contig->contig[0].id= %lld, contig->contig[1].id= %lld\n", refmap[t]->contig->contig[0].id, refmap[t]->contig->contig[1].id);
	    }
	  fflush(stdout);
	}

	size_t align_start = numalign_start[refid];
	size_t align_end = numalign_end[refid];
	Calign **Lalignment = NULL;

	// Compute Lalignment[align_start .. align_end-1] that includes all matchgroups that are above threshold

	if(refid >= orignumrefmaps){
	  if(DEBUG) assert(extendSplit);
	  Lalignment = alignment;
	} else if(MultiMatches && !BestRef){// expand list of alignments to include alternate alignments with the same reference map 
	  // first count how many total matchgroups there are
	  size_t cnt = 0;
	  for(size_t alignid = align_start; alignid < align_end; alignid++){
	    Calign *align = alignment[alignid];
	    if(!EARLY_ALIGN_FILTER){
	      if(!align)
		continue;
	      Cmap *rmap = refmap[refid];
	      if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	    }
	    if(DEBUG>=2) assert(align->mapid1 == refid);
	    int mapid = align->mapid2;
	    if(DEBUG>=2) assert(!Gmap[mapid]->origmap);
	    if(DEBUG>=2) assert(align->Malign && align->multicnt > 0);
	    cnt += align->multicnt;
	  }
	  if(DEBUG) assert(0 <= cnt);
	  if(VERB>=2 || (TRACE && refmap[refid]->id == REF_TRACE)){
	    printf("refid=%d:align_start=%lu,align_end=%lu: Number of alignments above thresholds (cnt)=%lu\n",
		   refid,align_start,align_end,cnt);
	    fflush(stdout);
	  }

	  Lalignment = new Calign*[cnt];
	  size_t end = 0;
	  for(size_t alignid = align_start; alignid < align_end; alignid++){
	    Calign *align = alignment[alignid];
	    if(!EARLY_ALIGN_FILTER){
	      if(!align)
		continue;
	      Cmap *rmap = refmap[refid];
	      if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	    }
	    if(DEBUG>=2) assert(align->mapid1 == refid);
	    int mapid = align->mapid2;
	    if(DEBUG>=2) assert(!Gmap[mapid]->origmap);
	    
	    for(int t = 0; t < align->multicnt; t++){
	      Calign *q = align->Malign[t];
	      if(DEBUG>=2) assert(q->mapid1 == refid);
	      int mapid = q->mapid2;
	      Cmap *nanomap = Gmap[mapid];
	      int orientation = q->orientation;
	      
	      if((VERB>=2-PVERB && align->multicnt > 1 && rmap->id==4738) || (DEBUG && !(q->Malign==NULL))){
		double wt = q->mapWT;// weight of current qmap (1 unless -BestRefWT was used)
		int M = nanomap->numsite[0];
		double scale = q->scaleID ? ScaleFactor[q->scaleID] : 1.0;	    
		FLOAT *X = nanomap->site[0];

		int I = q->sites1[0];
		int K = q->sitesK1[0];
		int J = q->sites2[0];
		int U = q->numpairs;
		int RI = q->sites1[U-1];
		int RK = q->sitesK1[U-1];
		int RJ = q->sites2[U-1];
		
		printf("alignid=%lu->%lu:t=%d/%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:wt=%0.6f,N=%d,M=%d,score=%0.4f,logPV=%0.4f,len=%0.3f,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d:Lend=%d,Rend=%d\n",
		       alignid,end,t,align->multicnt,refid,rmap->id,mapid,nanomap->id,q->orientation,wt,N,M,q->score,q->logPV, X[M+1] * scale, I, K, J, RI, RK, RJ, q->Lend, q->Rend);
		fflush(stdout);
	      }
	      Lalignment[end++] = q;
	      if(DEBUG>=2 && !(q->Malign == NULL)){
		printf("\t t=%d/%d:q=%p:Malign=%p,multicnt=%d\n",t,align->multicnt,q,q->Malign,q->multicnt);
		fflush(stdout);
		assert(q->Malign == NULL);
	      }
	    }
	  }
	  if(DEBUG) assert(end == cnt);
	  align_start = 0;
	  align_end = end;
	} else {/* just filter out alignments that are below threshold */
	  // first count how many total matchgroups there are
	  size_t cnt = 0;
	  for(size_t alignid = align_start; alignid < align_end; alignid++){
	    Calign *align = alignment[alignid];
	    if(!EARLY_ALIGN_FILTER){
	      if(!align)
		continue;
	      Cmap *rmap = refmap[refid];
	      if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	    }
	    if(DEBUG>=2) assert(align->mapid1 == refid);
	    int mapid = align->mapid2;
	    if(DEBUG>=2) assert(!Gmap[mapid]->origmap);
	    if(DEBUG>=2 && BestRef) assert(Gmap[mapid]->nalign->mapid1 >= 0);
	    if(BestRef && Gmap[mapid]->nalign->mapid1 != refid && BestRefExtCheck(align,Gmap[mapid]->nalign,mapid,refid))
	      continue;// skip alignment unless it is with the reference with the best alignment score with mapid
	    cnt++;
	  }

	  Lalignment = new Calign*[cnt];
	  size_t end = 0;
	  for(size_t alignid = align_start; alignid < align_end; alignid++){
	    Calign *align = alignment[alignid];
	    if(!EARLY_ALIGN_FILTER){
	      if(!align)
		continue;
	      Cmap *rmap = refmap[refid];
	      if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	    }
	    if(DEBUG>=2) assert(align->mapid1 == refid);
	    int mapid = align->mapid2;
	    if(DEBUG>=2) assert(!Gmap[mapid]->origmap);
	    if(DEBUG>=2 && BestRef) assert(Gmap[mapid]->nalign->mapid1 >= 0);
	    if(BestRef && Gmap[mapid]->nalign->mapid1 != refid && BestRefExtCheck(align,Gmap[mapid]->nalign,mapid,refid))
	      continue;// skip alignment unless it is with the reference with the best alignment score with mapid

	    if(VERB>=2 && align->multicnt > 1){
	      Cmap *nanomap = Gmap[mapid];
	      Cmap *rmap = refmap[refid];
	      double wt = align->mapWT;// weight of current qmap (1 unless -BestRefWT was used)
	      int M = nanomap->numsite[0];
	      double scale = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;	    
	      FLOAT *X = nanomap->site[0];

	      int I = align->sites1[0];
	      int K = align->sitesK1[0];
	      int J = align->sites2[0];
	      int U = align->numpairs;
	      int RI = align->sites1[U-1];
	      int RK = align->sitesK1[U-1];
	      int RJ = align->sites2[U-1];
		
	      printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:wt=%0.6f,N=%d,M=%d,score=%0.4f,logPV=%0.4f,len=%0.3f,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d:Lend=%d,Rend=%d\n",
		     refid,rmap->id,mapid,nanomap->id,align->orientation,wt,N,M,align->score,align->logPV, X[M+1] * scale, I, K, J, RI, RK, RJ, align->Lend, align->Rend);
	      fflush(stdout);
	    }

	    Lalignment[end++] = align;
	    if(DEBUG>=2) assert(align->Malign == NULL);
	  }
	  if(DEBUG) assert(end == cnt);
	  align_start = 0;
	  align_end = end;
	}

	if(extendWT > 0.0 && !extendWTdup){/* avoid raising weight of more than one alignment of each map */
	  for(size_t alignid = align_start; alignid < align_end; alignid++){
	    Calign *align = Lalignment[alignid];
	    int mapid = align->mapid2;
	    Cmap *nanomap = Gmap[mapid];
	    nanomap->pMapWT = NULL;
	  }
	}

	// NOTE : -extsplit is ignored if used with -mapped AND -extendWT
	if(DEBUG && extendSplit && extendLen > 0.0 && extendWT > 0.0) assert(!MappedPrefix);


	if(EXTSPLIT_TRACE>=2 && refid >= orignumrefmaps && rmap->id != EXTSPLIT_NREFID && rmap->id != 424846LL && rmap->id != 428743LL){
	  if(VERB){
	    printf("Skipping split contig refid=%d(id=%lld) due to EXTSPLIT_NREFID=%lld\n",refid,rmap->id,EXTSPLIT_NREFID);
	    fflush(stdout);
	  }

	  continue;
	}

	if(extendSplit && refid < orignumrefmaps){/* clone contig at locations with at least extendSplit endoutliers (+ outliers treated as 2 endoutliers, if extsplitOutlier > 0.0) */

	  // first compute coverage[1..N], endoutlierL[1..N], endoutlierR[1..N] (similar to coverage[],N2[],N3[] in updateMap() of refine.cpp)
	  if(DEBUG) assert(N <= maxN && coverage && endoutlierL && endoutlierR);
	  memset(coverage,0, (N+1)*sizeof(double));
	  memset(endoutlierL,0, (N+1)*sizeof(double));
	  memset(endoutlierR,0, (N+1)*sizeof(double));
	  memset(endoutlierLi,0, (N+1)*sizeof(int));
	  memset(endoutlierRi,0, (N+1)*sizeof(int));

	  if(EXTSPLIT_RANGE){
	    if(DEBUG) assert(endoutlierStartL);
	    memset(endoutlierEndL,0,(N+1)*sizeof(size_t));
	    memset(endoutlierEndR,0,(N+1)*sizeof(size_t));
	    for(int I = 0; I <= N; I++)
	      endoutlierStartL[I] = endoutlierStartR[I] = align_end;
	    
	    qsort(Lalignment, align_end - align_start, sizeof(Calign *), (intcmp*)CalignRefSiteInc);
	  }

	  if(extsplitOutlier > 0.0){
	    memset(outlierLB, 0, (N+1)*sizeof(char));
	    memset(outlierRB, 0, (N+1)*sizeof(char));
	    
	    for(int k = 0; k < KBcnt - 1; k++){
	      memset(endoutlierLm[k], 0, (N+2)*sizeof(double));
	      memset(endoutlierRm[k], 0, (N+2)*sizeof(double));
	      memset(endoutlierLim[k],0, (N+2)*sizeof(int));
	      memset(endoutlierRim[k],0, (N+2)*sizeof(int));
	      memset(outlierLBm[k], 0, (N+1)*sizeof(char));
	      memset(outlierRBm[k], 0, (N+1)*sizeof(char));

	      if(EXTSPLIT_DELBIN){
		memset(endoutlierLm[-1-k], 0, (N+2)*sizeof(double));
		memset(endoutlierRm[-1-k], 0, (N+2)*sizeof(double));
		memset(endoutlierLim[-1-k],0, (N+2)*sizeof(int));
		memset(endoutlierRim[-1-k],0, (N+2)*sizeof(int));
		memset(outlierLBm[-1-k], 0, (N+1)*sizeof(char));
		memset(outlierRBm[-1-k], 0, (N+1)*sizeof(char));
	      }
	    }

	    if(EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000){
	      for(int k = KBend+1; k <= KBend+2; k++){
		memset(endoutlierLm[k], 0, (N+2)*sizeof(double));
		memset(endoutlierRm[k], 0, (N+2)*sizeof(double));
		memset(endoutlierLim[k],0, (N+2)*sizeof(int));
		memset(endoutlierRim[k],0, (N+2)*sizeof(int));
		memset(outlierLBm[k], 0, (N+1)*sizeof(char));
		memset(outlierRBm[k], 0, (N+1)*sizeof(char));
	      }
	    }
	  }

	  Cmap *rmap = refmap[refid];

	  if(VERB>=2){
	    printf("refid=%d(id=%lld):align_start= %lu, align_end= %lu:\n",refid,rmap->id, align_start, align_end);
	    fflush(stdout);
	  }
	  if(DEBUG) assert(ContigCntFile != NULL);
	  if(SplitCnt < 0){
	    SplitCnt = nextContigId(ContigCntFile);
	    if(DEBUG) assert(SplitCnt > 0);
	    if(VERB/* HERE >=2 */){
	      printf("nextContigId(\"%s\") returned SplitCnt=%lld\n", ContigCntFile, SplitCnt);
	      fflush(stdout);
	    }
	  }
	  if(DEBUG && rmap->id > SplitCnt){
	    printf("ERROR: rmap->id = %lld is larger than value of %lld in ID file %s (Invalid Pipeline restart ?)\n",rmap->id, SplitCnt, ContigCntFile);
	    fflush(stdout);
	    exit(1);
	  }

	  for(size_t alignid = align_start; alignid < align_end; alignid++){
	    Calign *align = Lalignment[alignid];
	    if(DEBUG>=2) assert(align && align->mapid1 == refid);
	    align->chimpair = 0;// this flag will be used to mark alignments with endoutliers that have been used in 1 or more splits and will be deleted from main extension alignment
	    int mapid = align->mapid2;
	    if(DEBUG>=2) assert(!Gmap[mapid]->origmap);

	    if(DEBUG>=2) assert(0.0 <= align->mapWT && align->mapWT <= 1.0);

	    //	    align->mapWT = 1.0;// remove after debugging why cnt1 + miss1 < floor(endoutlierL[i] + 0.999)

	    double wt = align->mapWT;// weight of current alignment (1 unless -BestRefWT was used now or to generate BNX input)
	    

	    Cmap *nanomap = Gmap[mapid];
	    int M = nanomap->numsite[0];
	    double scale = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;	    
	    FLOAT *X = nanomap->site[0];

	    int I = align->sites1[0];
	    int K = align->sitesK1[0];
	    int J = align->sites2[0];
	    int U = align->numpairs;
	    int RI = align->sites1[U-1];
	    int RK = align->sitesK1[U-1];
	    int RJ = align->sites2[U-1];
	    
	    if(VERB>=3 && rmap->id == 1 && nanomap->id == MAP_TRACE && align->Lend <= -2 && align->Rend <= -2 && alignid == 6387 && max(RI-RK - extendSplitFN, 346) <= min(RI-RK+extendSplitFP, 347)){
	      printf("alignid=%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:wt=%0.4f,N=%d,M=%d,score=%0.4f,logPV=%0.4f,len=%0.3f,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d:Lend=%d,Rend=%d\n",
		     alignid,refid,rmap->id,mapid,nanomap->id,align->orientation,wt,N,M,align->score,align->logPV, X[M+1] * scale, I, K, J, RI, RK, RJ, align->Lend, align->Rend);

	      if(align->Lend <= -2){
		double QueryLeftend = (align->orientation ? X[M+1] - X[M+1-J] : X[J]) * scale;
		double Leftend = (align->orientation ? X[M+1] - X[M] : X[1]) * scale;
		double RefLeftend = Yc(Y,I,K);
		printf("\t QueryLeftend = %0.3f, Leftend = %0.3f, RefLeftend= %0.3f, extendSplitLen= %0.3f, \n",QueryLeftend, Leftend, RefLeftend, extendSplitLen);
		fflush(stdout);
		int i = max(1, I-K - extendSplitFN);
		while(i > 1 && RefLeftend - Y[i-1] <= extendSplitFNlen)
		  i--;
		while(i < I && RefLeftend - Y[i] > QueryLeftend - Leftend - extendSplitLen)
		  i++;
		int right = min(RI, I-K + extendSplitFP);
		printf("\t alignid=%lu:Left endoutlier of %0.3f kb at Y[%d..%d]=%0.3f..%0.3f will be applied to Y[%d..%d] = %0.3f .. %0.3f\n", 
		       alignid, QueryLeftend, I-K,I,Y[I-K],Y[I], i, right, Y[i], Y[right]);
	      }
	      if(align->Rend <= -2){
		double QueryRightend = (align->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]) * scale;
		double Rightend = (align->orientation ? X[1] : X[M+1]-X[M]) * scale;
		double RefRightend = Yc(Y,RI,RK);
		int i = min(N, RI + extendSplitFN);
		while(i < N && Y[i+1] - RefRightend <= extendSplitFNlen)
		  i++;
		while(Y[i] - RefRightend > QueryRightend - Rightend - extendSplitLen)
		  i--;
		int left = max(I, RI - extendSplitFP /* WAS8 RI-RK - extendSplitFP*/);
		
		printf("\t alignid=%lu:Right endoutlier of %0.3f kb at Y[%d..%d]=%0.3f..%0.3f will be applied to Y[%d..%d] = %0.3f .. %0.3f (wt= %0.3f)\n",
		       alignid,QueryRightend,RI-RK,RI,Y[RI-RK],Y[RI],left,i,Y[left],Y[i],wt);
	      }
	      fflush(stdout);
	    }

	    // NOTE : -extendWT also applies to main contig extensions if -extsplit OR -splitFilt are used (and -extendWTend 0 is not used)
	    if(!EXTENDWT_DELAY && extendLen > 0.0 && extendWT > wt && wt >= extendMinWT && extendWTend){
	      // NOTE this only effects the align->mapWT passed to refine() & non-refined XMAP, not the endoutlier density computation based on original wt
	      double leftlenX = scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]);/* unaligned left end length of X */
	      double rightlenX = scale * (align->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]);/* unaligned right end length of X */

#if CALIGN_END==0
	      double leftend = (Y[I-K] < leftlenX) ? 
		((align->Lend > -2 || Y[I-K] <= extendFNlen || I-K-1 + J-align->LijX <= extendFN) ? Yc(Y,I,K) - scale*(align->orientation ? X[M]-X[M+1-J] : X[J]-X[1]) : Yc(Y,I,K)) :
		((align->Lend > -2 || leftlenX <= extendFNlen || I-K-align->LijY + J-1 <= extendFN) ? Yc(Y,I,K) - scale*(align->orientation ? X[M]-X[M+1-J] : X[J]-X[1]) : Yc(Y,I,K));
	      double rightend = (Y[N+1]-Y[RI] < rightlenX) ?
	        ((align->Rend > -2 || Y[N+1] - Y[RI] <= extendLen || N-RI + align->RijX-RJ <= extendFN/* NEW280*/) ?  Yc(Y,RI,RK) + scale*(align->orientation ? X[M+1-RJ]-X[1] : X[M] - X[RJ]) : Yc(Y,RI,RK)) :
	        ((align->Rend > -2 || rightlenX <= extendLen || align->RijY-RI + M-RJ <= extendFN/* NEW280 */) ?  Yc(Y,RI,RK) + scale*(align->orientation ? X[M+1-RJ]-X[1] : X[M] - X[RJ]) : Yc(Y,RI,RK));
#else // NOT quite correct : only misaligned labels on Y[] or X[] are counted (whichever ends first)
	      double leftend = (Y[I-K] < leftlenX) ? 
		((align->Lend > -2 || Y[I-K] <= extendFNlen || I-K <= extendFN+1) ? Yc(Y,I,K) - scale*(align->orientation ? X[M]-X[M+1-J] : X[J]-X[1]) : Yc(Y,I,K)) :
		((align->Lend > -2 || leftlenX <= extendFNlen || J <= extendFN+1) ? Yc(Y,I,K) - scale*(align->orientation ? X[M]-X[M+1-J] : X[J]-X[1]) : Yc(Y,I,K));
	      double rightend = (Y[N+1]-Y[RI] < rightlenX) ?
	        ((align->Rend > -2 || Y[N+1] - Y[RI] <= extendLen || N-RI <= extendFN) ?  Yc(Y,RI,RK) + scale*(align->orientation ? X[M+1-RJ]-X[1] : X[M] - X[RJ]) : Yc(Y,RI,RK)) :
	        ((align->Rend > -2 || rightlenX <= extendLen || M-RJ <= extendFN) ?  Yc(Y,RI,RK) + scale*(align->orientation ? X[M+1-RJ]-X[1] : X[M] - X[RJ]) : Yc(Y,RI,RK));
#endif
	      
	      if((leftend < -extendLen && !(rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT))) || 
		 (rightend > Y[N+1] + extendLen && !(rmap->Mask[0] && (rmap->Mask[0][N+1] & END_NOEXT)))){
		if(extendWTdup || nanomap->pMapWT == NULL || align->mapWT > nanomap->origMapWT){
		  if(!extendWTdup){// NEW73
		    if(nanomap->pMapWT){
		      if(VERB>=2){
			printf("\t mapid=%d(id=%lld): Restoring mapWT= %0.6f to %0.6f at %p\n", nanomap->mapid,nanomap->id, *nanomap->pMapWT, nanomap->origMapWT, nanomap->pMapWT);
			fflush(stdout);
		      }
		      *nanomap->pMapWT = nanomap->origMapWT;
		    }
		    nanomap->pMapWT = &align->mapWT;
		    nanomap->origMapWT = align->mapWT;
		  }
		  if(VERB>=2){
		    printf("alignid=%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.2f: mapWT= %0.6f -> %0.6f at %p\n",
			   alignid,align->mapid1,refmap[align->mapid1]->id,mapid,nanomap->id,align->orientation,align->score,align->logPV, align->mapWT, extendWT, &align->mapWT);
		    fflush(stdout);
		  }
		  align->mapWT = extendWT;
		}
		if(DEBUG>=2) assert(0.0 <= align->mapWT && align->mapWT <= 1.0);
	      }

	      if(VERB>=3 && rmap->id == 1 && nanomap->id == MAP_TRACE /* && align->Lend <= -2 && align->Rend <= -2 && alignid == 6387*/){
		printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:mapWT=%0.6f->%0.6f,N=%d,M=%d,score=%0.4f,logPV=%0.4f,len=%0.3f,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d:Y[I-K]= %0.3f,Lend=%d,Rend=%d(Eleft=%0.3f,Eright=%0.3f),Mask:L=%d,R=%d\n",
		       refid,rmap->id,mapid,nanomap->id,align->orientation,wt,align->mapWT,N,M,align->score,align->logPV, X[M+1] * scale, I, K, J, RI, RK, RJ, Y[I-K], align->Lend, align->Rend,
		       Y[0] - leftend, rightend - Y[N+1],(rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT)) ? 1 : 0, (rmap->Mask[0] && (rmap->Mask[0][N+1] & END_NOEXT)) ? 1 : 0);
		fflush(stdout);
	      }
	    }

	    //	    wt = 1.0;

	    if(wt < extsplitMinWT)// WAS300 wt <= extsplitMinWT
	      continue;

	    if(splitWT > 0.0)
	      wt = max(splitWT, wt);

            if(DEBUG) assert(wt <= 1.0);

	    for(int i = I-K; i <= RI; i++)
	      coverage[i] += wt;

	    int Lmin = N, Lmax = 1;/* range of outlierLB*[1..N] with non-zero values (for current alignment only) */
	    int Rmin = N, Rmax = 1;/* range of outlierRB*[1..N] with non-zero values (for current alignment only) */

	    if(align->Lend <= -2){/* left endoutlier */
	      double QueryLeftend = (align->orientation ? X[M+1] - X[M+1-J] : X[J]) * scale;
	      double Leftend = (align->orientation ? X[M+1] - X[M] : X[1]) * scale;
	      if(QueryLeftend - Leftend >= extendSplitLen){
		double RefLeftend = Yc(Y,I,K);

		int i = max(1, I-K - extendSplitFN);
		while(i > 1 && RefLeftend - Y[i-1] <= extendSplitFNlen)
		  i--;
		while(RefLeftend - Y[i] > QueryLeftend - Leftend - extendSplitLen)
		  i++;
		if(DEBUG && !(i <= I)){
		  printf("refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:wt=%0.4f,N=%d,M=%d,score=%0.4f,logPV=%0.4f,len=%0.3f,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d:Lend=%d,Rend=%d\n",
			 refid,rmap->id,mapid,nanomap->id,align->orientation,wt,N,M,align->score,align->logPV, X[M+1] * scale, I, K, J, RI, RK, RJ, align->Lend, align->Rend);
		  printf("\t i=%d,RefLeftend=%0.4f, Y[I]=%0.4f, QueryLeftend=%0.4f,Leftend=%0.4f,extendSplitLen=%0.4f,extendSplitFN=%d\n",
			 i,RefLeftend,Y[I], QueryLeftend,Leftend,extendSplitLen,extendSplitFN);
		  fflush(stdout);

		  assert(i <= I);
		}

		int right = min(RI, I-K + extendSplitFP);
		if(extsplitOutlier > 0.0){/* defer updates to endoutlierL*[] to avoid duplicate updates for both endoutlier and outlier from same alignment */
		  for(int j = i; j <= right; j++)
		    outlierLB[j] |= 1;

		  if(EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000)
		    for(int B = KBend+1; B <= KBend+2; B++)
		      for(int j = i; j <= right; j++)		    
			outlierLBm[B][j] |= 1;
		    
		  Lmin = min(i,Lmin);
		  Lmax = max(right,Lmax);

		  if(EXTSPLIT_TRACE && max(i,EXTSPLIT_I) <= min(right,EXTSPLIT_I) && rmap->id == EXTSPLIT_REFID){
		    printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f,Lend=%d:Left endoutlier of %0.3f kb at Y[%d..%d]=%0.3f..%0.3f:wt=%0.3e -> %0.4f,X[1]=%0.3f \n", 
			   alignid, nanomap->id,align->orientation,align->scaleID,align->logPV,align->Lend,QueryLeftend, I-K,I,Y[I-K],Y[I], align->mapWT, wt, Leftend);
		    fflush(stdout);
		  }
		} else {
		  for(int j = i; j <= right; j++){
		    endoutlierL[j] += wt;
		    endoutlierLi[j]++;

		    if(EXTSPLIT_RANGE){
		      endoutlierStartL[j] = min(alignid, endoutlierStartL[j]);
		      endoutlierEndL[j] = max(alignid, endoutlierEndL[j]);
		    }
		  }

		  if(EXTSPLIT_TRACE && max(i,EXTSPLIT_I) <= min(right,EXTSPLIT_I) && rmap->id == EXTSPLIT_REFID){
		    printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f,Lend=%d:Left endoutlier of %0.3f kb at Y[%d..%d]=%0.3f..%0.3f applied to Y[%d..%d] = %0.3f .. %0.3f:endoutlierL[%d]=%d,%0.4f(wt=%0.3e -> %0.4f),X[1]=%0.3f \n", 
			   alignid, nanomap->id,align->orientation,align->scaleID,align->logPV,align->Lend,
			   QueryLeftend, I-K,I,Y[I-K],Y[I], i, right, Y[i], Y[right], EXTSPLIT_I, endoutlierLi[EXTSPLIT_I],endoutlierL[EXTSPLIT_I], align->mapWT,wt, Leftend);
		    fflush(stdout);
		  }
		}
	      }
	    }

	    if(align->Rend <= -2){/* right endoutlier */
	      double QueryRightend = (align->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]) * scale;
	      double Rightend = (align->orientation ? X[1] : X[M+1]-X[M]) * scale;
	      if(QueryRightend - Rightend >= extendSplitLen){
		double RefRightend = Yc(Y,RI,RK);

		int i = min(N, RI + extendSplitFN);
		while(i < N && Y[i+1] - RefRightend <= extendSplitFNlen)
		  i++;
		while(Y[i] - RefRightend > QueryRightend - Rightend - extendSplitLen)
		  i--;
		if(DEBUG) assert(i >= RI-RK);

		int left = max(I, RI - extendSplitFP /* WAS8 RI-RK - extendSplitFP*/);

		if(extsplitOutlier > 0.0){/* defer updates to endoutlierR[] to avoid duplicate updates for both endoutlier and outliers */
		  for(int j = i; j >= left; j--)
		    outlierRB[j] |= 1;

		  if(EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000)
		    for(int B = KBend+1; B <= KBend+2; B++)
		      for(int j = i; j >= left; j--)
			outlierRBm[B][j] |= 1;

		  Rmin = min(left,Rmin);
		  Rmax = max(i,Rmax);

		  if(EXTSPLIT_TRACE && max(left,EXTSPLIT_I) <= min(i, EXTSPLIT_I) && rmap->id == EXTSPLIT_REFID/* && nanomap->id == MAP_TRACE */){
		    printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f,Rend=%d:Right endoutlier of %0.3f kb (RJ=%d,M=%d, X[M+1..M]= %0.3f) at Y[%d]= %0.3f, wt=%0.3e -> %0.4f\n", 
			   alignid,nanomap->id,align->orientation,align->scaleID,align->logPV,align->Rend,QueryRightend, RJ, M, Rightend,RI,Y[RI], align->mapWT,wt);
		    fflush(stdout);
		  }
		} else {
		  for(int j = i; j >= left; j--){
		    endoutlierR[j] += wt;
		    endoutlierRi[j]++;
		    if(EXTSPLIT_RANGE){
		      endoutlierStartR[j] = min(alignid, endoutlierStartR[j]);
		      endoutlierEndR[j] = max(alignid, endoutlierEndR[j]);
		    }
		  }

		  if(EXTSPLIT_TRACE && max(left,EXTSPLIT_I) <= min(i, EXTSPLIT_I) && rmap->id == EXTSPLIT_REFID/* && nanomap->id == MAP_TRACE */){
		    printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f,Rend=%d:Right endoutlier (RJ=%d,M=%d, Xend= %0.3f - %0.3f) at Y[%d]= %0.3f applied to Y[%d..%d] = %0.3f .. %0.3f: endoutlierR[%d]=%d,%0.4f,wt=%0.3e -> %0.4f\n", 
			   alignid,nanomap->id,align->orientation,align->scaleID,align->logPV,align->Rend,RJ, M, QueryRightend, Rightend,RI,Y[RI], left, i, Y[left], Y[i], EXTSPLIT_I, endoutlierRi[EXTSPLIT_I],endoutlierR[EXTSPLIT_I],align->mapWT, wt);
		    fflush(stdout);
		  }
		}
	      }
	    }

	    if(extsplitOutlier > 0.0){/* check for internal outliers */
	      double Leftend = (align->orientation ? X[M+1] - X[M] : X[1]) * scale;
	      double Rightend = (align->orientation ? X[1] : X[M+1]-X[M]) * scale;

	      double YLik = Yc(Y,I,K), YRik;
	      int IL = I, KL = K, JL = J, IR,KR,JR;
	      for(int t = 1; t < U; t++, IL = IR, KL = KR, JL = JR, YLik = YRik){
		IR = align->sites1[t];
		KR = align->sitesK1[t];
		JR = align->sites2[t];
		YRik = Yc(Y,IR,KR);

		/* check if interval (IL,KL,JL) to (IR,KR,JR) is an outlier with size at least extsplitOutlier kb */
		double delY = YRik - YLik;
		double delX = (align->orientation ? X[M+1-JL]-X[M+1-JR] : X[JR] - X[JL]) * scale;
		if(EXTSPLIT_TRACE>=2 && rmap->id == EXTSPLIT_REFID){
		  int left = min(max(1,IR-KR - extendSplitFN), max(I,IL - extendSplitFP));
		  int right = max(min(RI, IR-KR + extendSplitFP), min(N,IL + extendSplitFN));
		  if(max(left,EXTSPLIT_I) <= min(right,EXTSPLIT_I)){
		    printf("\t alignid=%lu/%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f:t=%d..%d:U=%d,I=%d..%d,K=%d..%d,J=%d..%d,N=%d,M=%d:outlier= %0.3f,%d, iscore= %0.6f, outscore= %0.6f\n",
			   alignid,align_end,nanomap->id,align->orientation,align->scaleID,align->logPV,t-1,t,U,IL,IR,KL,KR,JL,JR,N,M,delX - delY, IR-KR-IL + JR-JL -2,align->iscore[t],align->outscore[t]);
		    fflush(stdout);
		  }
		}
		if(DEBUG) assert(delX > 0.0);
		double delta = delX - delY;
		double adelta = fabs(delta);
		if(!(adelta >= extsplitOutlier || (IR-KR-IL + JR-JL - 2) >= extsplitOutlierLabels) || 
		   !(align->iscore[t] > align->outscore[t] + (FLOAT)0.01 || (outlierExtend && (IL >= IR-KR || JL >= JR))))
		  continue;// NOTE: align->iscore[t] corresponds to interval align->sites1[t-1 .. t] 
		
		if(DEBUG/* HERE HERE >=2 */ && !(align->noutliers > 0 && align->maxoutlier >= adelta - 1e-6)){
 		  printf("alignid=%lu,rid=%lld,id=%lld,or=%d,sc=%d,logPV=%0.2f:t=%d..%d:U=%d,I=%d..%d,K=%d..%d,J=%d..%d,N=%d,M=%d:delY=%0.3f,delX=%0.3f,outlier= %0.3f, iscore= %0.6f, outscore= %0.6f\n",
 			 alignid,YYmap[refid]->id,nanomap->id,align->orientation,align->scaleID,align->logPV,t-1,t,U,IL,IR,KL,KR,JL,JR,N,M,delY,delX,delta,align->iscore[t],align->outscore[t]);
 		  printf("\t align->noutliers=%d, align->maxoutlier= %0.3f, align->maxoutlierLabels= %d\n",align->noutliers,align->maxoutlier,align->maxoutlierLabels);
 		  fflush(stdout);
 		  assert(align->noutliers > 0 && align->maxoutlier >= adelta - 1e-6);
 		}

		/* locate outlier size bin (0 or 1 if KBcnt == 0): 
		   bin = 0 .. KBcnt-1 : size range : extsplitOutlierKB[bin] <= adelta < extsplitOutlierKB[bin+1]
		   bin = KBcnt : size range : extsplitOutlierKB[bin] <= adelta
		   bin = KBcnt+1 : size range : below extsplitOutlier (with misaligned labels >= extsplitOutlierLabels)

		   NOTE : OutlierKB[0] == extsplitOutlier and OutlierKB[KBcnt + 1] == 9999.0
		*/
		int bin = (adelta < extsplitOutlier && extsplitOutlierLabels < 1000) ? KBcnt+1 : findBin(adelta,KBcnt,extsplitOutlierKB);
		/* If KBcnt == 0: Update only outlierLBm[bin], where OutlierLB == outlierLBm[0])
		   If KBcnt > 0 && bin < KBcnt && (!EXTSPLIT_DELBIN || delta > 0) : Update outlierLBm[max(0,bin-1)..bin] etc,
		   If KBcnt > 0 && bin < KBcnt-1 && (EXTSPLIT_DELBIN && delta < 0) : Update outlierLBm[-1-bin .. -1-max(0,bin-1)] etc,
		   If KBcnt > 0 && bin == KBcnt-1 && (EXTSPLIT_DELBIN && delta < 0) : Update outlierLBm[1-KBcnt, KBcnt-1] etc,
		   If KBcnt > 0 && bin == KBcnt : Update outlierLBm[KBcnt-1] etc, where outlierLBm[KBcnt-1] == outlierLB
		   If EXTSPLIT_BALANCED && KBcnt > 0 && bin == KBcnt+1 : Update outlierLBm[KBcnt] etc */

		/* treat right end of outlier (IR,KR,JR) as start of left endoutlier */
		int D = EXTSPLIT_OUTLIER_RANGE ? max(0,min(JR-JL-1, IR-KR-IL - extendSplitFN)) : 0;// NEW360 Increase extendSplitFN by D, since boundary of outlier may have expanded
		double QueryLeftend = (align->orientation ? X[M+1] - X[M+1-JR] : X[JR]) * scale;
		double QueryRight = (align->orientation ? X[M+1-JR] : X[M+1] - X[JR]) * scale;
		if(EXTSPLIT_TRACE/* HERE HERE >=2 */ && rmap->id == EXTSPLIT_REFID){
		  int left = min(max(1,IR-KR - extendSplitFN - D), max(I,IL - extendSplitFP));
		  int right = max(min(RI, IR-KR + extendSplitFP), min(N,IL + extendSplitFN));

		  if(max(left,EXTSPLIT_I) <= min(right,EXTSPLIT_I)){
		    if(QueryLeftend - Leftend >= extendSplitLen && QueryRight - Rightend >= extsplitOutlierLS && U-t >= extsplitOutlierAS){
		      int i = max(1, IR-KR - extendSplitFN - D);
		      double RefLeftend = Yc(Y,IR,KR); // EXTSPLIT_OUTLIER_RANGE ? min(Yc(Y,IR,KR), Y[IL+1]) : Yc(Y,IR,KR);
		      while(i > 1 && RefLeftend - Y[i-1] <= extendSplitFNlen)
			i--;
		      while(RefLeftend - Y[i] > QueryLeftend - Leftend - extendSplitLen)
			i++;
		      int iR = min(RI, IR-KR + extendSplitFP);
		      printf("\t    QueryLeftend= %0.3f,QueryRight= %0.3f,Leftend= %0.3f,Rightend= %0.3f,Y(IR,KR)= %0.3f,LB[%d..%d] (extendSplitLen= %0.3f, extsplitOutlierLS= %0.3f,%d), B=%d\n",
			     QueryLeftend,QueryRight,Leftend,Rightend, RefLeftend, i, iR, extendSplitLen, extsplitOutlierLS, extsplitOutlierAS,bin);
		    } else 
		      printf("\t    QueryLeftend= %0.3f,QueryRight= %0.3f,Leftend= %0.3f,Rightend= %0.3f (extendSplitLen= %0.3f, extsplitOutlierLS= %0.3f,%d), B=%d\n",
			     QueryLeftend,QueryRight,Leftend,Rightend, extendSplitLen, extsplitOutlierLS, extsplitOutlierAS,bin);
		    fflush(stdout);
		  }
		}

		if(QueryLeftend - Leftend >= extendSplitLen && QueryRight - Rightend >= extsplitOutlierLS && U-t >= extsplitOutlierAS){
		  double RefLeftend = Yc(Y,IR,KR); // EXTSPLIT_OUTLIER_RANGE ? min(Yc(Y,IR,KR), Y[IL+1]) : Yc(Y,IR,KR);

		  int i = max(1, IR-KR - extendSplitFN - D);
		  while(i > 1 && RefLeftend - Y[i-1] <= extendSplitFNlen)
		    i--;
		  while(RefLeftend - Y[i] > QueryLeftend - Leftend - extendSplitLen)
		    i++;
		  if(DEBUG) assert(i <= IR);

		  int right = min(RI, IR-KR + extendSplitFP);

		  if(i <= right){
		    if(!KBcnt) {
		      if(DEBUG) assert(0 <= bin && bin <= (extsplitOutlierLabels < 1000 ? 1 : 0));

		      for(int j = i; j <= right; j++)
			outlierLBm[bin][j] |= 1;
		    } else if(EXTSPLIT_BALANCED && bin == KBcnt+1){
		      if(DEBUG/* HERE HERE >=2 */) assert(adelta < extsplitOutlier);

		      for(int j = i; j <= right; j++)
			outlierLBm[KBcnt][j] |= 1;
		    } else if(!EXTSPLIT_DELBIN || delta > 0.0 || bin >= KBcnt){
		      if(DEBUG/* HERE HERE >=2 */ && bin < KBcnt) assert((EXTSPLIT_DELBIN ? delta : adelta) >= extsplitOutlier);

		      for(int B = max(0,bin-1); B <= min(KBcnt-1,bin); B++)
			for(int j = i; j <= right; j++)
			  outlierLBm[B][j] |= 1;
		    } else if(EXTSPLIT_DELBIN /* && delta < 0.0 */){
		      if(DEBUG/* HERE HERE >=2 */) assert(bin < KBcnt && delta <= -extsplitOutlier);

		      if(bin < KBcnt-1){
			for(int B = -1-bin; B <= -1-max(0,bin-1); B++)
			  for(int j = i; j <= right; j++)
			    outlierLBm[B][j] |= 1;
		      } else {
			if(DEBUG/* HERE HERE >=2 */) assert(KBend > 0);

			for(int B = -KBend; B <= KBend; B += 2*KBend)
			  for(int j = i; j <= right; j++)
			    outlierLBm[B][j] |= 1;
		      }
		    }

		    Lmin = min(i,Lmin);
		    Lmax = max(right,Lmax);

		    if(EXTSPLIT_TRACE && max(i,EXTSPLIT_I) <= min(right,EXTSPLIT_I) && rmap->id == EXTSPLIT_REFID){
		      printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f:Left outlier of %0.3f kb (I=%d..%d,K=%d..%d,J=%d..%d,M=%d, Xend= %0.3f - %0.3f),i=%d..%d,right end at Y[%d..%d]=%0.3f..%0.3f,wt=%0.3e -> %0.4f\n", 
			     alignid, nanomap->id,align->orientation,align->scaleID,align->logPV,delX-delY,IL,IR,KL,KR,JL,JR,M,QueryLeftend, Leftend, i,right,IR-KR,IR,Y[IR-KR],Y[IR], align->mapWT, wt);
		      fflush(stdout);
		    }
		  }
		}
		
		/* treat left end of outlier (IL,KL,JL) as start of right endoutlier*/
		D = EXTSPLIT_OUTLIER_RANGE ? max(0,min(JR-JL-1, IR-KR-IL - extendSplitFN)) : 0;// NEW360 Increase extendSplitFN by D, since boundary of outlier may have expanded
		double QueryRightend = (align->orientation ? X[M+1-JL] : X[M+1] - X[JL]) * scale;
		double QueryLeft = (align->orientation ? X[M+1] - X[M+1-JL] : X[JL]) * scale;
		if(EXTSPLIT_TRACE>=2 && rmap->id == EXTSPLIT_REFID){
		  int left = min(max(1,IR-KR - extendSplitFN), max(I,IL - extendSplitFP));
		  int right = max(min(RI, IR-KR + extendSplitFP), min(N,IL + extendSplitFN + D));

		  if(max(left,EXTSPLIT_I) <= min(right,EXTSPLIT_I)){
		    if(QueryRightend - Rightend >= extendSplitLen && QueryLeft - Leftend >= extsplitOutlierLS && t /* WAS361 t-1 */>= extsplitOutlierAS){
		      double RefRightend = Yc(Y,IL,KL);

		      int i = min(N, IL + extendSplitFN + D);
		      while(i < N && Y[i+1] - RefRightend <= extendSplitFNlen)
			i++;
		      while(Y[i] - RefRightend > QueryRightend - Rightend - extendSplitLen)
			i--;
		      int iL = max(I, IL - extendSplitFP);

		      printf("\t    QueryRightend= %0.3f,QueryLeft= %0.3f,Leftend= %0.3f,Rightend= %0.3f,Y(IL,KL)=%0.3f, RB[%d..%d] (extendSplitLen= %0.3f, extsplitOutlierLS= %0.3f,%d), B=%d\n",
			     QueryRightend,QueryLeft,Leftend,Rightend,Yc(Y,IL,KL), iL,i,extendSplitLen, extsplitOutlierLS, extsplitOutlierAS,bin);
		    } else
		      printf("\t    QueryRightend= %0.3f,QueryLeft= %0.3f,Leftend= %0.3f,Rightend= %0.3f (extendSplitLen= %0.3f, extsplitOutlierLS= %0.3f,%d), B=%d\n",
			     QueryRightend,QueryLeft,Leftend,Rightend,extendSplitLen, extsplitOutlierLS, extsplitOutlierAS,bin);
		    fflush(stdout);
		  }
		}

		if(QueryRightend - Rightend >= extendSplitLen && QueryLeft - Leftend >= extsplitOutlierLS && t /* WAS361 t-1 */ >= extsplitOutlierAS){
		  double RefRightend = Yc(Y,IL,KL);

		  int i = min(N, IL + extendSplitFN + D);
		  while(i < N && Y[i+1] - RefRightend <= extendSplitFNlen)
		    i++;
		  while(Y[i] - RefRightend > QueryRightend - Rightend - extendSplitLen)
		    i--;
		  if(DEBUG) assert(i >= IL-KL);

		  int left = max(I, IL - extendSplitFP);

		  if(EXTSPLIT_TRACE>=2 && rmap->id == EXTSPLIT_REFID && !(left <= i)){
		    int tleft = min(max(1,IR-KR - extendSplitFN), max(I,IL - extendSplitFP));
		    int tright = max(min(RI, IR-KR + extendSplitFP), min(N,IL + extendSplitFN));
		    if(max(tleft,EXTSPLIT_I) <= min(tright,EXTSPLIT_I)){
		      printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f:Right outlier of %0.3f kb(I=%d..%d,K=%d..%d,J=%d..%d,M=%d, Xend= %0.3f - %0.3f) left end at Y[%d]= %0.3f,wt=%0.6f:failed:left=%d,i=%d\n", 
			     alignid,nanomap->id,align->orientation,align->scaleID,align->logPV,delX-delY,IL,IR,KL,KR,JL,JR, M, QueryRightend, Rightend,IL,Y[IL],wt,left,i);
		      fflush(stdout);
		    }
		  }

		  if(left <= i){
		    if(!KBcnt) {
		      if(DEBUG) assert(0 <= bin && bin <= (extsplitOutlierLabels < 1000 ? 1 : 0));

		      for(int j = i; j >= left; j--)
			outlierRBm[bin][j] |= 1;
		    } else if(EXTSPLIT_BALANCED && bin == KBcnt+1){
		      if(DEBUG/* HERE HERE >=2 */) assert(adelta < extsplitOutlier);

		      for(int j = i; j >= left; j--)
			outlierRBm[KBcnt][j] |= 1;
		    } else if(!EXTSPLIT_DELBIN || delta > 0.0 || bin >= KBcnt){
		      if(DEBUG/* HERE HERE >=2 */ && bin < KBcnt) assert((EXTSPLIT_DELBIN ? delta : adelta) >= extsplitOutlier);

		      for(int B = max(0,bin-1); B <= min(KBcnt-1,bin); B++)
			for(int j = i; j >= left; j--)
			  outlierRBm[B][j] |= 1;
		    } else if(EXTSPLIT_DELBIN /* && delta < 0.0 */){
		      if(DEBUG/* HERE HERE >=2 */) assert(bin < KBcnt && delta <= -extsplitOutlier);

		      if(bin < KBcnt-1){
			for(int B = -1-bin; B <= -1-max(0,bin-1); B++)
			  for(int j = i; j >= left; j--)
			    outlierRBm[B][j] |= 1;
		      } else {
			if(DEBUG/* HERE HERE >=2 */) assert(KBend > 0);

			for(int B = -KBend; B <= KBend; B += 2*KBend)
			  for(int j = i; j >= left; j--)
			    outlierRBm[B][j] |= 1;
		      }
		    }
		    Rmin = min(left,Rmin);
		    Rmax = max(i,Rmax);

		    if(EXTSPLIT_TRACE && max(left,EXTSPLIT_I) <= min(i, EXTSPLIT_I) && rmap->id == EXTSPLIT_REFID){
		      printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f:Right outlier of %0.3f kb(I=%d..%d,K=%d..%d,J=%d..%d,M=%d, Xend= %0.3f - %0.3f),i=%d..%d,left end at Y[%d]= %0.3f,wt=%0.3e -> %0.4f\n", 
			     alignid,nanomap->id,align->orientation,align->scaleID,align->logPV,delX-delY,IL,IR,KL,KR,JL,JR, M, QueryRightend, Rightend,i,left,IL,Y[IL],align->mapWT, wt);
		      fflush(stdout);
		    }
		  }
		}
	      }

	      if(Lmin <= Lmax){
		for(int B = (EXTSPLIT_DELBIN ? -KBend : 0); B <= KBend + (EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000 ? 2 : 0); B++){
		  for(int j = Lmin; j <= Lmax; j++){
		    if(outlierLBm[B][j]){
		      endoutlierLm[B][j] += wt;
		      endoutlierLim[B][j]++;
		      if(EXTSPLIT_RANGE){
			endoutlierStartL[j] = min(alignid, endoutlierStartL[j]);
			endoutlierEndL[j] = max(alignid, endoutlierEndL[j]);
		      }
		      if(EXTSPLIT_TRACE && j == EXTSPLIT_I && rmap->id == EXTSPLIT_REFID){
			printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f:Left (end)outlier applied to B=%d/%d:Y[%d..%d] = %0.3f .. %0.3f:endoutlierL[%d]=%d,%0.4f(wt=%0.3e -> %0.4f),X[1]=%0.3f \n", 
			       alignid, nanomap->id,align->orientation, align->scaleID,align->logPV,B,KBend,Lmin,Lmax, Y[Lmin], Y[Lmax], EXTSPLIT_I, 
			       endoutlierLim[B][EXTSPLIT_I],endoutlierLm[B][EXTSPLIT_I], align->mapWT, wt, Leftend);
			fflush(stdout);
		      }
		      outlierLBm[B][j] = 0;
		    }
		  }
		}
	      } // if (Lmin <= Lmax)

	      if(Rmin <= Rmax){
		for(int B = (EXTSPLIT_DELBIN ? -KBend : 0); B <= KBend + (EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000 ? 2 : 0); B++){
		  for(int j = Rmax; j >= Rmin; j--){
		    if(outlierRBm[B][j]){
		      endoutlierRm[B][j] += wt;
		      endoutlierRim[B][j]++;
		      if(EXTSPLIT_RANGE){
			endoutlierStartR[j] = min(alignid, endoutlierStartR[j]);
			endoutlierEndR[j] = max(alignid, endoutlierEndR[j]);
		      }
		      if(EXTSPLIT_TRACE && j==EXTSPLIT_I && rmap->id == EXTSPLIT_REFID){
			printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f:Right (end)outlier applied to B=%d/%d,Y[%d..%d] = %0.3f .. %0.3f: endoutlierR[%d]=%d,%0.4f,wt=%0.3e -> %0.4f\n", 
			       alignid,nanomap->id,align->orientation, align->scaleID,align->logPV,B,KBend,Rmin,Rmax, Y[Rmin], Y[Rmax], EXTSPLIT_I, 
			       endoutlierRim[B][EXTSPLIT_I],endoutlierRm[B][EXTSPLIT_I],align->mapWT,wt);
			fflush(stdout);
		      }
		      outlierRBm[B][j] = 0;
		    }
		  }
		}
	      } // if (Rmin <= Rmax)
	    } // if(extsplitOutlier > 0.0)
	  } // for alignid = align_start .. align_end -1
	  
	  if(DEBUG>=2){
	    if(extsplitOutlier > 0.0){
	      for(int B = (EXTSPLIT_DELBIN ? -KBend : 0); B <= KBend + (EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000 ? 2 : 0); B++){
		for(int I = 1; I <= N; I++){
		  if(outlierLBm[B][I] != 0){
		    printf("outlierLB[B=%d][I=%d]= %d, N= %d, KBcnt= %d, KBend= %d\n", B,I,(int)outlierLBm[B][I],N,KBcnt,KBend);
		    fflush(stdout);
		    assert(outlierLBm[B][I] == 0);
		  }
		  if(outlierRBm[B][I] != 0){
		    printf("outlierRB[B=%d][I=%d]= %d, N= %d, KBcnt= %d, KBend= %d\n", B,I,(int)outlierRBm[B][I],N,KBcnt,KBend);
		    fflush(stdout);
		    assert(outlierRBm[B][I] == 0);
		  }
		}
	      }
	    }
	  }

 	  /* scan endoutlierL[i] and endoutlierR[i] arrays for values that are local maxima within scanning range = max(extendSplitFP,extendSplitFN,extendSplitSpacing) labels,
   	     and endoutlierL[i] or endoutlierR[i] are above threshold = max(extendSplit, extendFrac * coverage[i]).
	     
	     If EXPSPLIT_SPACING_FIX >= 1 : 
	            1a. Split label i must be at least (extendSplitFP + extendSplitEndSpacing - 1) labels from end label, OR
		    1b. Split label i must be at least Xrange2 = Xlambda * extendSplitEndSpacingX kb from the end.
		    2. Limit Scanning distance to Xrange = Xlambda * extendSplitSpacingX kb, provided peak has been verify
		        If EXTSPLIT_SPACING_FIX == 2, this limit applies even if peak has not been verified (requires EXTSPLIT_VERIFYPEAK == 0)
	  */

	  int range = max(extendSplitFP,extendSplitFN);
	  range = max(extendSplitSpacing,range);
	  double Xrange = Xlambda * extendSplitSpacingX;
	  int range2 = extendSplitFP + extendSplitEndSpacing - 1;
	  double Xrange2 = Xlambda * extendSplitEndSpacingX;
	  int NumSplits = 0;
	  double extendSplitD = extendSplit;

	  if(VERB && extsplitOutlier > 0.0 /* EXTSPLIT_TRACE && rmap->id == EXTSPLIT_REFID*/){
	    printf("refid=%d(id=%lld):N=%d,Y[1]= %0.3f, Y[N+1]=%0.3f:\n",refid,rmap->id,N,Y[1], Y[N+1]);
	    if(KBcnt > 0){
	      if(DEBUG) assert(KBcnt >= 2);
	      for(int B = 0; B <= KBend; B++)
		printf("B=%d: outlier size range = %0.3f .. %0.3f kb\n", B, extsplitOutlierKB[B], extsplitOutlierKB[B+2]);
	      if(EXTSPLIT_DELBIN)
		for(int B = 0; B < KBend-1;B++)
		  printf("B=%d: outlier size range = %0.3f .. %0.3f kb\n",-1-B, -extsplitOutlierKB[B+2], -extsplitOutlierKB[B]);
	    }
	    fflush(stdout);
	    if(EXTSPLIT_TRACE && rmap->id == EXTSPLIT_REFID){
	      for(int i = 1; i <= N; i++){
		double threshold = max(extendSplitD, extendFrac * coverage[i]);
		printf("i=%d:Y[i]=%0.3f,cov[i]=%0.2f,thr=%0.2f:\n  outlierL[i]=", i,Y[i],coverage[i],threshold);
		for(int B = (EXTSPLIT_DELBIN ? -KBend : 0); B <= KBend + (EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000 ? 2 : 0); B++){
		  if(0.005 <= endoutlierLm[B][i] && endoutlierLm[B][i] < 0.995)
		    printf("%d(%d,%.2f)",B,endoutlierLim[B][i],endoutlierLm[B][i]);
		  else
		    printf("%d(%d,%0.1f)",B,endoutlierLim[B][i],endoutlierLm[B][i]);
		}
		printf("\n outlierR[i]=");
		for(int B = (EXTSPLIT_DELBIN ? -KBend : 0); B <= KBend + (EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000 ? 2 : 0); B++){
		  if(0.005 <= endoutlierRm[B][i] && endoutlierRm[B][i] < 0.995)
		    printf("%d(%d,%.2f)",B,endoutlierRim[B][i],endoutlierRm[B][i]);
		  else
		    printf("%d(%d,%0.1f)",B,endoutlierRim[B][i],endoutlierRm[B][i]);
		}
		printf("\n");
	      }
	      fflush(stdout);
	    }
	  }

	  if(VERB/* HERE >=2 */){
	    if(extsplitOutlier > 0.0)
	      printf("Looking for endoutlier+outlier clusters of at least %0.1f (end)outliers (AND %0.4f * coverage): range= %d, Xrange = %0.3f, %0.3f kb, extendSplitFNlen= %0.3f\n", 
		     extendSplitD, extendFrac,range,Xrange, Xrange2, extendSplitFNlen);
	    else
	      printf("Looking for endoutlier clusters of at least %0.1f endoutliers (AND %0.4f * coverage): range= %d,%d Xrange = %0.3f, %0.3f kb, extendSplitFNlen= %0.3f\n", 
		     extendSplitD, extendFrac,range,range2,Xrange, Xrange2, extendSplitFNlen);
	    fflush(stdout);
	  }

	  for(int B = (EXTSPLIT_DELBIN ? -KBend : 0); B <= KBend + (EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000 ? 1 : 0); B++)
	    SplitBinCnt[B] = 0;/* count how many splits used bin B */

	  for(int i = 1; i <= N; i++){
	   int left = max(1, i - range);
	   int right = min(N, i + range);

	   for(int B = (EXTSPLIT_DELBIN ? -KBend : 0); B <= KBend + (EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000 ? 1 : 0); B++){
	     int B1 = (B >= 0) ? B : -1-B;
	     int B2 = min(KBcnt+1, B1+2);/* outlier size range is extsplitOutlierKB[B1 .. B2]*sign(B) (IF B==KBend+1, then size range is < extsplitOutlier && misaligned labels >= extsplitOutlierLabels) */
	     double LB = (B<0) ? -extsplitOutlierKB[B2] : extsplitOutlierKB[B1];
	     double UB = (B<0) ? -extsplitOutlierKB[B1] : extsplitOutlierKB[B2];

	     double extendSplitB = (B >= KBend || -B >= KCcnt) ? extendSplitD : (B >= 0) ? extsplitOutlierC[0] : extsplitOutlierC[-B];
	     double threshold = max(extendSplitB, extendFrac * coverage[i]);


	     if(endoutlierLm[B][i] >= threshold && (i >= range2 || (EXTSPLIT_SPACING_FIX && Y[i] >= Xrange2))){
	      double maxEnd = 0.0;
	      int jmax = -1;

	      double minLeft, minRight;
	      minLeft = minRight = endoutlierLm[B][i];

	      for(int j = right; j >= left; j--){
		if(j==i)
		  continue;

		if(EXTSPLIT_VERIFYPEAK){
		  if(j < i)
		    minLeft = min(minLeft,endoutlierLm[B][j]);
		  else
		    minRight = min(minRight,endoutlierLm[B][j]);
		}
		if(EXTSPLIT_SPACING_FIX && fabs(Y[j] - Y[i]) > Xrange && (EXTSPLIT_SPACING_FIX >=2 || endoutlierLm[B][j] < endoutlierLm[B][i])){
		  if(j > i)
		    continue;
		  break;
		}
		if(DEBUG>=2) assert(jmax < 0 || jmax > j);
		
		if(endoutlierLm[B][j] >= maxEnd && endoutlierLm[B][j] >= max(extendSplitB, extendFrac * coverage[j]) &&
		   (jmax < 0 || maxEnd < endoutlierLm[B][j] || !EXTSPLIT_BIAS/* || jmax > j */)){// NOTE : ties are broken in favor of leftmost split if EXTSPLIT_BIAS == 0, rightmost otherwise
		  maxEnd = endoutlierLm[B][j];
		  jmax = j;
		}
	      }

	      if(EXTSPLIT_TRACE /* HERE HERE >=2 */ && i==20){
		if(EXTSPLIT_VERIFYPEAK)
		  printf("i=%d:left=%d,right=%d:B=%d:jmax=%d, endoutlierL[jmax]= %0.2f (maxEnd= %0.2f), endoutlierL[i]= %0.2f,minLeft=%0.2f,minRight=%0.2f,threshold=%0.2f\n",
			 i,left,right,B,jmax,endoutlierLm[B][(jmax < 0) ? i : jmax],maxEnd, endoutlierLm[B][i],minLeft,minRight,threshold);
		else
		  printf("i=%d:left=%d,right=%d:B=%d:jmax=%d, endoutlierL[jmax]= %0.2f (maxEnd= %0.2f), endoutlierL[i]= %0.2f,threshold=%0.2f,coverage[i]=%0.2f,C=%0.2f\n",
			 i,left,right,B,jmax,endoutlierLm[B][(jmax < 0) ? i : jmax],maxEnd, endoutlierLm[B][i],threshold,coverage[i],extendSplitB);
		fflush(stdout);
	      }

	      if(maxEnd <= endoutlierLm[B][i] && (!EXTSPLIT_BALANCED || B <= KBend || endoutlierLm[B][i] > endoutlierLm[KBend+2][i]) &&
		 (jmax < 0 || maxEnd < endoutlierLm[B][i] || (EXTSPLIT_BIAS ? 
							      (jmax < i && (!EXTSPLIT_VERIFYPEAK || minLeft < endoutlierLm[B][i])) :
							      (jmax > i && (!EXTSPLIT_VERIFYPEAK || minRight < endoutlierLm[B][i]))))){
		/* split off left endoutliers (plus outliers, if extsplitOutlier > 0.0) along with Y[i .. N+1] as a new extension refinement */
		NumSplits++;

		if(DEBUG && EXTSPLIT_VERIFYPEAK && jmax >= 0 && maxEnd >= endoutlierLm[B][i] && 
		   !(EXTSPLIT_BIAS ? minLeft < endoutlierLm[B][i] && minRight <= endoutlierLm[B][i] : minLeft <= endoutlierLm[B][i] && minRight < endoutlierLm[B][i])){
		  printf("i=%d: left=%d,right=%d:B=%d:jmax=%d, endoutlierL[jmax]= %0.4f (maxEnd= %0.4f), endoutlierL[i]= %0.4f\n",
			 i,left,right,B,jmax,endoutlierLm[B][(jmax < 0) ? i : jmax],maxEnd, endoutlierLm[B][i]);
		  printf("\t minLeft= %0.4f, minRight= %0.4f, Y[i]= %0.4f\n",minLeft,minRight, Y[i]);
		  fflush(stdout);

		  assert(EXTSPLIT_BIAS ? minLeft < endoutlierLm[B][i] && minRight <= endoutlierLm[B][i] : minLeft <= endoutlierLm[B][i] && minRight < endoutlierLm[B][i]);
		}

		/* reallocate numalign_start[] and numalign_end[] if needed */
		if(numrefmaps >= maxnumrefmaps){
		  int new_maxnumrefmaps = max(maxnumrefmaps*5/4, maxnumrefmaps + 16);
		  size_t *new_numalign_start = new size_t[new_maxnumrefmaps+1];
		  size_t *new_numalign_end = new size_t[new_maxnumrefmaps+1];
		  memcpy(new_numalign_start,numalign_start,(numrefmaps+1)*sizeof(size_t));
		  memcpy(new_numalign_end,numalign_end,(numrefmaps+1)*sizeof(size_t));
		  delete [] numalign_start;
		  delete [] numalign_end;
		  if(!extsplitNE || extTrim){
		    if(DEBUG) assert(extsplitExtOnly);
		    if((extsplitExtOnly = (double *)realloc(extsplitExtOnly, new_maxnumrefmaps * sizeof(double))) == NULL){
		      printf("realloc of %lu bytes filed (new maxnumrefmaps=%d)\n",new_maxnumrefmaps*sizeof(double), new_maxnumrefmaps);
		      fflush(stdout);exit(1);
		    }
		    if(VERB>=2){
		      printf("Reallocated extsplitExtOnly = %p : maxnumrefmaps= %d -> %d\n",extsplitExtOnly, maxnumrefmaps, new_maxnumrefmaps);
		      fflush(stdout);
		    }
		    for(int r = maxnumrefmaps; r < new_maxnumrefmaps; r++)
		      extsplitExtOnly[r] = EndLen;
		  }
		  numalign_start = new_numalign_start;
		  numalign_end = new_numalign_end;
		  maxnumrefmaps = new_maxnumrefmaps;
		}
		numalign_start[numrefmaps] = numalign_end[numrefmaps] = numaligns;
	
		int L = max(1, i - max(splitFiltFP, extendSplitFP));// NEW152
		int R = min(N, i + max(splitFiltFN, extendSplitFN));// NEW152
		double FNlen = max(splitFiltFNlen, extendSplitFNlen);// NEW152
		while(R < N && Y[R+1] - Y[i] <= FNlen)
		  R++;// NEW8

		if(!extsplitNE || extTrim){
		  if(DEBUG) assert(extsplitExtOnly);
		  extsplitExtOnly[numrefmaps] = min(EndLen, Y[R] - Y[L]);
		}

		int Rend = N+1;
		if(CloneLimitLen > 0.0){
		  if(EndLen < CloneLimitLen)
		    Rend = N;/* NEW106 : to force creation of Mask[0][N+1] */
		  while(Rend > R && Y[Rend-1] - Y[i] >= CloneLimitLen && Rend - 1 - i >= CloneLimitN)
		    Rend--;
		}

		size_t start = EXTSPLIT_RANGE ? endoutlierStartL[i] : align_start;
		size_t end = EXTSPLIT_RANGE ? endoutlierEndL[i]+1 : align_end;

		SplitBinCnt[B]++;

		if(EXTSPLIT_TRACE/* HERE HERE >=2 */ && i== EXTSPLIT_I){
		  if(extsplitOutlier > 0.0)
		    printf("Splitting off refid=%d(alignids=%lu..%lu/%lu) i=%d:B=%d: region Y[i ... %d]= %0.3f ... %0.3f  with expected %d(wt=%0.2f) left endoutliers or outliers\n", 
			   refid, start,end-1,align_end, i,B,Rend, Y[i], Y[Rend], endoutlierLim[B][i], endoutlierLm[B][i]);
		  else
		    printf("Splitting off refid=%d(alignids=%lu..%lu/%lu) i=%d: region Y[i ... %d]= %0.3f ... %0.3f  with expected %d(wt=%0.2f) left endoutliers\n", 
			   refid, start,end-1,align_end, i,Rend, Y[i], Y[Rend], endoutlierLi[i], endoutlierL[i]);
		  printf(": maxEnd=%0.3f,jmax=%d,endoutlierL[jmax]=%0.3f, numrefmaps=%d/%d, L=%d(%0.3f), R=%d(%0.3f),FNlen=%0.3f\n",
			 maxEnd,jmax,endoutlierLm[B][max(0,jmax)],numrefmaps,maxnumrefmaps,L,Y[L],R,Y[R],FNlen);
		  fflush(stdout);
		}

		/* copy rmap from just before site L to just after site Rend (or right end) */
		FLOAT *Y = rmap->site[0];
		double leftend = max(0.0, Y[L] - MININTERVAL);
		double rightend = min(Y[N+1],Y[Rend] + MININTERVAL);

		/* make sure the array refmap[] is large enough */
		maxmapalloc(maxnumrefmaps, maxrefmaps, refmap, 0, 1);
		YYmap = refmap;

		Cmap *newrmap;
		if(!EXTSPLIT_MINMEM){
		  newrmap = refmap[numrefmaps] =  new Cmap(rmap);// NOTE : this will waste the space allocated by maxmapalloc() for refmap[numrefmaps] and leak this replacement memory
		  newrmap->trim(leftend, rightend);// NOTE : this will waste space for the untrimmed map even though trimmed map may be much smaller
		} else {
		  Cmap *nrmap = new Cmap(rmap);
		  nrmap->trim(leftend, rightend);		
		  newrmap = new Cmap(nrmap);// compacts the memory for the trimmed map

		  delete nrmap;// frees memory of original untrimmed map

		  /* swap *refmap[numrefmaps] and *newrmap */
		  Cmap tmp = *refmap[numrefmaps];
		  *refmap[numrefmaps] = *newrmap;
		  *newrmap = tmp;

		  delete newrmap;// normally there will be nothing to delete, other than Cmap allocated above
		  newrmap = refmap[numrefmaps];
		}

		newrmap->mapid = numrefmaps;

		FLOAT *newY = newrmap->site[0];
		int newN = newrmap->numsite[0];

		if(DEBUG && leftend <= 1e-6 && rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT) && !(newrmap->Mask[0] && (newrmap->Mask[0][1] & END_NOEXT))){
		  printf("rmap->id=%lld,rmap->Mask[0][1]= %lx, L=%d,R=%d,Rend=%d,N=%d,Y[L]=%0.6f,Y[Rend]=%0.6f,Y[N+1]=%0.6f,leftend= %0.6f, rightend= %0.6f; newrmap->Mask[0]= %p",
			 rmap->id,rmap->Mask[0][1], L, R, Rend, N, Y[L], Y[Rend], Y[N+1], leftend, rightend, newrmap->Mask[0]);
		  if(newrmap->Mask[0])
		    printf(",mask[0][1]= %lx", newrmap->Mask[0][1]);
		  printf("\n");
		  fflush(stdout);
		  assert(newrmap->Mask[0] && (newrmap->Mask[0][1] & END_NOEXT));
		}
		if(DEBUG && rightend >= Y[N+1] - 1e-6 && rmap->Mask[0] && (rmap->Mask[0][N+1] & END_NOEXT) && !(newrmap->Mask[0] && (newrmap->Mask[0][newrmap->numsite[0]+1] & END_NOEXT))){
		  printf("rmap->id=%lld,rmap->Mask[0][N+1]= %lx, L=%d,R=%d,Rend=%d,N=%d,Y[L]=%0.6f,Y[Rend]=%0.6f,Y[N+1]=%0.6f,leftend=%0.6f,rightend=%0.6f; newrmap->Mask[0]= %p",
			 rmap->id, rmap->Mask[0][N+1], L, R, Rend, N, Y[L], Y[Rend], Y[N+1], leftend, rightend, newrmap->Mask[0]);
		  if(newrmap->Mask[0])
		    printf(",newrmap->Mask[0][%d] = %lx", newrmap->numsite[0]+1, newrmap->Mask[0][newrmap->numsite[0]+1]);
		  printf("\n");
		  printf("newrmap->site[0][%d]= %0.6f\n", newrmap->numsite[0]+1, newrmap->site[0][newrmap->numsite[0]+1]);
		  fflush(stdout);
		  assert(newrmap->Mask[0] && (newrmap->Mask[0][newrmap->numsite[0]+1] & END_NOEXT));
		}
		if(DEBUG) assert(newrmap->numsite[0] == (Rend > N ? N - L + 1 : Rend - L + 1));

		/* compute unique ID for new consensus map */
		newrmap->id = rmap->id;
		if(SplitCnt)
		  newrmap->id += NumSplits * SplitCnt;
		else
		  newrmap->id = nextContigId(ContigCntFile);
		if(DEBUG && newrmap->id < 0){
		  if(SplitCnt){
		    printf("During Extension Split new id=%lld (overflowed 63 bit int) : id=%lld,NumSplits=%d,SplitCnt=%lld\n",newrmap->id, rmap->id, NumSplits, SplitCnt);
		    fflush(stdout);
		  }
		  assert(newrmap->id > 0);
		}
		
		if(Rend <= N){/* mark right end of newrmap as non-extendable */
		  if(!newrmap->Mask[0]){
		    newrmap->Mask[0] = new size_t[newrmap->numsite[0] + 2];
		    memset(newrmap->Mask[0], 0, (newrmap->numsite[0] + 2) * sizeof(size_t));
		  }
		  newrmap->Mask[0][newrmap->numsite[0]+1] |= END_NOEXT;
		  if(VERB/* HERE HERE >=2 */){
		    printf("Marking right end of new split contig refid=%d(id=%lld) with Mask[0][%d]= %#10lx (orig:leftend=%0.3f,rightend=%0.3f,Len=%0.3f) new N=%d,Y[1,N,N+1]=%0.3f,%0.3f,%0.3f\n",
			   newrmap->mapid,newrmap->id,newrmap->numsite[0]+1,newrmap->Mask[0][newrmap->numsite[0]+1], leftend,rightend,rmap->site[0][N+1],newN,newY[1],newY[newN],newY[newN+1]);
		    fflush(stdout);
		  }
		}


		// This loop over all alignments will result in quadractic performance for large contigs : see EXTSPLIT_RANGE to avoid this. Also see smaller improvements under "HERE HERE"

		/* Move all alignments with left endoutliers (if B == KBend or KBend+1) starting at L..R to new contig.
		   If extsplitOutlier > 0.0 : Also copy alignments with outliers (in correct size bin B) with right end at L..R + D, treating outlier plus region left of it as endoutlier.
		                                  where D = max(0,min(JR-JL-1, IR-KR-IL - extendSplitFN))
		   If extsplitNE : Also copy alignments without endoutliers that are aligned only to the new contig region
		   If extsplitNE : Also copy alignments with right endoutlier only that are within extendSplitSpacing of right end (IF right end was not truncated) */

		int cnt = 0, cnt1 = 0, miss1 = 0;

		for(size_t alignid = start; alignid < end; alignid++){
		  Calign *align = Lalignment[alignid];
		  if(!align)
		    continue;
		  if(DEBUG>=2) assert(align->mapid1 == refid);
		  if(0/* HERE HERE */ && !EXTSPLIT_TRACE && align->mapWT < splitFiltMinWT && !extsplitNE)
		    continue;
		  int I = align->sites1[0];
		  int K = align->sitesK1[0];
		  if(0/* HERE HERE */&& !EXTSPLIT_TRACE && !extsplitNE){
		    if(I-K > R)
		      continue;
		    if(extsplitOutlier > 0.0){
		      int t = max(0, align->numpairs - extsplitOutlierAS);
		      int IR = align->sites1[t];
		      int KR = align->sitesK1[t];
		      if(IR-KR < L)
			continue;
		    } else if(I-K < L)
		      continue;
		  }
		  
		  if(DEBUG/* HERE HERE >=2 */) assert(align->noutliers >= 0 && align->maxoutlier >= 0.0 && align->maxoutlierLabels >= 0 &&
						      (align->noutliers <= 0 || align->maxoutlier > 0.0 || align->maxoutlierLabels > 0));

		  int J = align->sites2[0];
		  int mapid = align->mapid2;
		  Cmap *nanomap = Gmap[mapid];		  
		  int M = nanomap->numsite[0];
		  double scale = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;	    
		  FLOAT *X = nanomap->site[0];

		  /* First check if alignment has left endoutlier */
		  double QueryLeftend = (align->orientation ? X[M+1] - X[M+1-J] : X[J]) * scale;
		  double Leftend = (align->orientation ? X[M+1] - X[M] : X[1]) * scale;
		  double RefLeftend = Yc(Y,I,K);

		  if(DEBUG) assert(align->Malign == NULL);/* Lalignment should only contain sub-matchgroups */
		  
		  // HERE HERE if(DEBUG/* HERE >=2 */) assert(L <= I-K && I-K <= R);

		  if(EXTSPLIT_TRACE>=2 && newrmap->id == EXTSPLIT_NREFID && i==EXTSPLIT_I){
		    printf("alignid=%lu:nrefid=%lld,id=%lld,or=%d,N=%d,M=%d,wt=%0.3e,Y[%d,%d]=%0.3f,%0.3f(end=%0.3f-%0.3f),JL=%d(end=%0.3f-%0.3f),Lend=%d,Rend=%d:L=%d,i=%d,R=%d\n",
			   alignid,newrmap->id,Gmap[align->mapid2]->id,align->orientation,newrmap->numsite[0],Gmap[align->mapid2]->numsite[0],align->mapWT,
			   I-K,I,Y[I-K],Y[I],RefLeftend,Y[min(i,I)],J,QueryLeftend,Leftend,align->Lend,align->Rend,L,i,R);
		    fflush(stdout);
		  }

		  if(align->Lend <= -2 && B >= KBend && L <= I-K && I-K <= R /* NEW8 */&& RefLeftend - Y[min(i,I)] <= QueryLeftend - Leftend - extendSplitLen &&
		     (/* HERE HERE !EXTSPLIT_TRACE || */align->mapWT >= splitFiltMinWT/* NEW52 */)){/* left endoutliers */
		    int U = align->numpairs;
		    if(Rend <= N){/* truncate alignment, to not extend beyond label Y[Rend] */
		      while(U > 0 && align->sites1[U-1] > Rend)
			U--;
		      if(U <= 0){/* can happen if Rend == R and I-K == R and I > R (very rare) */
			miss1++;
			continue;// next alignment
		      }
		    } 
		    cnt1++;

		    /* NOTE : cannot just move the align pointer from align == Lalignment[alignid] to alignment[numaligns], since align may be same as alignment[t]->Malign[k]
		       since Lalignment[align_start..align_end-1] is derived from alignment[numalign_start[refid]..numalign_end[refid]-1]->Malign[] and hence
		       align would end up being freed twice via alignment[numaligns] and alignment[t]->Malign[k] */

		    maxalignallocNULL(numaligns+1,alignment,numaligns,maxaligns,&alignment_blockid);
		    size_t nalignid = numaligns;
		    Calign *nalign = alignment[nalignid] = new Calign[1];
		    copy(nalign,align,1, 1);// copy : automatically resets Malign
		    if(DEBUG) assert(nalign->Malign == NULL);
		    if(DEBUG/* HERE HERE >=2 */) assert(nalign->noutliers >= 0 && nalign->maxoutlier >= 0.0 && nalign->maxoutlierLabels >= 0 &&
							(nalign->noutliers <= 0 || nalign->maxoutlier > 0.0 || nalign->maxoutlierLabels > 0));

		    // NOTE : The same endoutlier could be part of multiple splits. Just mark it for deletion here, so it can be reused, then delete it later
		    align->chimpair = 1;// HERE HERE : check to make sure this left endoutlier does not extend beyond left end of original contig and satisfies -extendWT (its mapWT may be modified)
		    //		    Lalignment[alignid] = NULL;
		    numalign_end[numrefmaps] = ++numaligns;

		    nalign->mapid1 = numrefmaps;
		    nalign->Lend = -1;// NOT endoutlier any more!
		    if(U < nalign->numpairs) nalign->Rend = -1;// NEW301: NOT endoutlier any more since split reference was truncated on right side !
		    nalign->numpairs = U;

		    // reduce nalign->site1[],sitesK1[] values by L-1
		    int shift = L-1;
		    for(int t = 0; t < U; t++){
		      int I = nalign->sites1[t];
		      int K = nalign->sitesK1[t];
		      if(DEBUG>=2 && !(I-K >= L)){
			printf("alignid=%lu: nrefid=%lld,mapid=%lld,or=%d,N=%d,M=%d,L=%d,i=%d,R=%d,Lend=%d,Rend=%d:U=%d -> %d,I=%d..%d,K=%d..%d,J=%d..%d (cnt1=%d,miss1=%d)\n",
			       alignid,newrmap->id,Gmap[nalign->mapid2]->id,nalign->orientation,newrmap->numsite[0],Gmap[nalign->mapid2]->numsite[0],L,i,R,nalign->Lend,nalign->Rend,align->numpairs,U,
			     nalign->sites1[0],nalign->sites1[U-1],nalign->sitesK1[0],nalign->sitesK1[U-1],nalign->sites2[0],nalign->sites2[U-1],cnt1,miss1);

			assert(I-K >= L);
		      }
		      nalign->sites1[t] -= shift;
		      if(DEBUG>=2) assert(nalign->sites1[t] <= newrmap->numsite[0]);
		    }

#if CALIGN_END==0
		    int IL = nalign->sites1[0];
		    int KL = nalign->sitesK1[0];
		    int JL = nalign->sites2[0];
		    nalign->LijY = nalign->Lij1 = LijY(newY,X,IL-KL,JL,newN,M,nalign->orientation,scale);
		    if(DEBUG) assert(nalign->Lij1 <= max(0,align->Lij1 - shift));
		    nalign->Lij2 = nalign->LijX;// NOT left endoutlier any more

		    FLOAT xL = (nalign->orientation ? X[M+1] - X[M+1-JL] : X[JL]) * scale;
		    FLOAT yL = Yc(newY,IL,KL);
		    nalign->iscore[0] = nalign->outscore[0] = Send(min(xL,yL),JL+1-max(1,nalign->LijX),IL-KL+1-max(1,nalign->LijY),IL-KL,newrmap->mapid,0);

		    if(U < align->numpairs){
		      int IR = nalign->sites1[U-1];
		      int KR = nalign->sitesK1[U-1];
		      int JR = nalign->sites2[U-1];
		      nalign->RijY = nalign->Rij1 = RijY(newY,X,IR,JR,newN,M,nalign->orientation,scale);
		      nalign->RijX = nalign->Rij2 = RijX(newY,X,IR,JR,newN,M,nalign->orientation,scale);
		      FLOAT xR = (nalign->orientation ? X[M+1-JR] : X[M+1]-X[JR]) * scale;
		      FLOAT yR = Yc(newY,IR,KR);
		      nalign->iscore[U] = nalign->outscore[U] = Send(min(xR,yR),min(M,nalign->RijX)+1-JR,min(newN,nalign->RijY)+1-IR,min(N,nalign->RijY),newrmap->mapid,0);
		    } else {
		      nalign->RijY = min(newN + 1, nalign->RijY - shift);
		      nalign->Rij1 = (nalign->Rend >= -1) ? nalign->RijY : nalign->sites1[U-1];
		    }
#else
		    /* NOTE : nalign->Lij1 should be recomputed for non-endoutlier and is not related to align->Lij1 which is same as original align->sites1[0]
		       The final value is almost always 0, but will always be <= align->Lij1 - shift */
		    nalign->Lij1 = max(0,align->Lij1 - shift);// NEW48
		    nalign->Rij1 = min(newrmap->numsite[0]+1, nalign->Rij1 - shift);// NEW48
#endif
		    if(DEBUG) assert(0 <= nalign->Lij1 && nalign->Lij1 <= nalign->sites1[0] - nalign->sitesK1[0]);
		    if(DEBUG) assert(nalign->sites1[U-1] <= nalign->Rij1 && nalign->Rij1 <= newrmap->numsite[0]+1);

		    if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID /*  && Gmap[nalign->mapid2]->id==MAP_TRACE */ && i==EXTSPLIT_I){
		      double QueryLeftend = (align->orientation ? X[M+1] - X[M+1-J] : X[J]) * scale;
		      printf("alignid=%lu->%lu: nrefid=%lld,id=%lld,or=%d,N=%d,M=%d,Y[%d,%d]=%0.3f,%0.3f,JL=%d(end=%0.3f),L=%d,i=%d,R=%d,Lend=%d,Rend=%d:U=%d->%d,Lij1=%d,Rij1=%d,I=%d..%d,K=%d..%d,J=%d..%d (cnt1=%d,miss1=%d),wt=%0.4f->%0.4f\n",
			     alignid,nalignid,newrmap->id,Gmap[nalign->mapid2]->id,nalign->orientation,newrmap->numsite[0],Gmap[nalign->mapid2]->numsite[0],I-K,I,Y[I-K],Y[I],J,QueryLeftend,L,i,R,
			     nalign->Lend,nalign->Rend,align->numpairs,U, nalign->Lij1,nalign->Rij1, 
			     nalign->sites1[0],nalign->sites1[U-1],nalign->sitesK1[0],nalign->sitesK1[U-1],nalign->sites2[0],nalign->sites2[U-1],cnt1,miss1,align->mapWT,nalign->mapWT);
		      fflush(stdout);
		    }
		    if(DEBUG>=2) assert(nalign->sites1[U-1] <= newrmap->numsite[0]);
		    if(DEBUG>=2) assert(nalign->sites1[0]-nalign->sitesK1[0] >= 1);
		    if(DEBUG>=2) assert(nalign->sites2[U-1] <= Gmap[nalign->mapid2]->numsite[0]);
		    if(DEBUG>=2) assert(nalign->sites2[0] >= 1);

		    nalign->noutliers = 0;
		    nalign->maxoutlier = 0.0;
		    nalign->maxoutlierLabels = 0;
                    if(extendMaxOutlierKBsplit < 998.0){    // update nalign->maxoutlier etc
		      int I,lastI = nalign->sites1[0];
		      int K,lastK = nalign->sitesK1[0];
		      int J,lastJ = nalign->sites2[0];
		      for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
			I = nalign->sites1[t];
			K = nalign->sitesK1[t];
			J = nalign->sites2[t];
			if(nalign->outscore[t] + (FLOAT)0.01 < nalign->iscore[t]){
			  nalign->noutliers++;
			  FLOAT deltaY = Yc(newY,I,K) - Yc(newY,lastI,lastK);
			  FLOAT deltaX = (nalign->orientation ? X[M+1-lastJ] - X[M+1-J] : X[J] - X[lastJ]) * scale;
			  if(DEBUG) assert(deltaX > 0.0);			  
			  FLOAT delta = deltaX - deltaY;
			  FLOAT adelta = fabs(delta);
			  nalign->maxoutlier = max(adelta,nalign->maxoutlier);
			  nalign->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, nalign->maxoutlierLabels);// NEW302
			  if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID /* && adelta > nalign->maxoutlier */){
			    printf("\t alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f:t=%d(delY=%0.3f,delX=%0.3f,I=%d->%d,K=%d->%d,J=%d->%d),iscore=%0.4f,%0.4f,max=%0.3f,%d\n",
				   alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, t, 
				   deltaY,deltaX,lastI,I,lastK,K,lastJ,J,nalign->iscore[t],nalign->outscore[t],nalign->maxoutlier,nalign->maxoutlierLabels);
			    printf("\t\t Yik=%0.4f,%0.4f,Xj=%0.4f,%0.4f\n",
				   Yc(newY,lastI,lastK),Yc(newY,I,K),nalign->orientation?X[M+1]-X[M+1-lastJ]:X[lastJ],nalign->orientation?X[M+1]-X[M+1-J]:X[J]);
			    fflush(stdout);
			  }
			} else if(EXTSPLIT_TRACE>=2 && newrmap->id == EXTSPLIT_NREFID){
			  FLOAT deltaY = Yc(newY,I,K) - Yc(newY,lastI,lastK);
			  FLOAT deltaX = (nalign->orientation ? X[M+1-lastJ] - X[M+1-J] : X[J] - X[lastJ]) * scale;
			  if(DEBUG) assert(deltaX > 0.0);			  
			  printf("\t alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f:t=%d(delY=%0.3f,delX=%0.3f,I=%d->%d,K=%d->%d,J=%d->%d),iscore=%0.4f,%0.4f,max=%0.3f,%d\n",
				 alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, t,
				 deltaY,deltaX,lastI,I,lastK,K,lastJ,J,nalign->iscore[t],nalign->outscore[i],nalign->maxoutlier,nalign->maxoutlierLabels);
			  printf("\t\t Yik=%0.4f,%0.4f,Xj=%0.4f,%0.4f\n",
				 Yc(newY,lastI,lastK),Yc(newY,I,K),nalign->orientation?X[M+1]-X[M+1-lastJ]:X[lastJ],nalign->orientation?X[M+1]-X[M+1-J]:X[J]);
			  fflush(stdout);
			}
		      }
                    }

		    if(splitWT > 0.0 && extendWT > 0.0 && nalign->mapWT >= extendMinWT){
		      if(DEBUG>=2) assert(0.0 <= nalign->mapWT && nalign->mapWT <= 1.0);
		      if(DEBUG/* HERE HERE >=2 */) assert(nalign->noutliers >= 0 && nalign->maxoutlier >= 0.0 && nalign->maxoutlierLabels >= 0 &&
							  (nalign->noutliers <= 0 || nalign->maxoutlier > 0.0 || nalign->maxoutlierLabels > 0));

		      if(nalign->maxoutlier <= extendMaxOutlierKBsplit && nalign->maxoutlierLabels < extendMaxOutlierLabelsSplit){/* try to increase nalign->mapWT */
			if(extendWTdup || nanomap->pMapWT == NULL || nalign->mapWT > nanomap->origMapWT){
			  if(!extendWTdup){// NEW73
			    if(nanomap->pMapWT){
			      if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
				printf("\t alignid=%lu->%lu:mapid=%d(id=%lld): Restoring mapWT= %0.6f to %0.6f at %p\n", 
				       alignid,nalignid,nanomap->mapid,nanomap->id, *nanomap->pMapWT, nanomap->origMapWT, nanomap->pMapWT);
				fflush(stdout);
			      }
			      *nanomap->pMapWT = nanomap->origMapWT;
			    }
			    nanomap->pMapWT = &nalign->mapWT;
			    nanomap->origMapWT = nalign->mapWT;
			  }
			  if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
			    printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.6f -> %0.6f at %p : -extendWT %0.1f %0.3f %d %0.1f %0.3f %0.1f %d %0.3f %0.1f %d\n",
				   alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, nalign->maxoutlier,nalign->maxoutlierLabels,
				   nalign->mapWT, max(nalign->mapWT,extendWT), &nalign->mapWT,
				   extendLen,extendWT,extendFN,extendFNlen,extendMinWT,extendMaxOutlierKB,extendMaxOutlierLabels,extendMaxWT,extendMaxOutlierKBsplit,extendMaxOutlierLabelsSplit);
			    fflush(stdout);
			  }
			  nalign->mapWT = max(extendWT, nalign->mapWT);
			}
		      } else {
			if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
			  printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.6f -> %0.6f at %p: -extendWT %0.1f %0.3f %d %0.1f %0.3f %0.1f %d %0.3f %0.1f %d\n",
				 alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV,nalign->maxoutlier,nalign->maxoutlierLabels,
				 nalign->mapWT, min(nalign->mapWT,extendMaxWT), &nalign->mapWT,
				 extendLen,extendWT,extendFN,extendFNlen,extendMinWT,extendMaxOutlierKB,extendMaxOutlierLabels,extendMaxWT,extendMaxOutlierKBsplit,extendMaxOutlierLabelsSplit);
			  fflush(stdout);
			}
			nalign->mapWT = min(extendMaxWT, nalign->mapWT);
		      }


		      if(DEBUG>=2) assert(0.0 <= nalign->mapWT && nalign->mapWT <= 1.0);
		    }

		    continue;
		  }

		  int U = align->numpairs;

		  if(extsplitOutlier > 0.0 && align->mapWT >= splitFiltMinWT){
		    /* check if there is any internal outliers in size bin B (or B+1) with right end in L..R that can be treated like left endoutlier */
		    double Rightend = (align->orientation ? X[1] : X[M+1]-X[M]) * scale;

		    int t = U-1;// HERE HERE max(0,U - extsplitOutlierAS)
		    int IR = align->sites1[t],IL;
		    int KR = align->sitesK1[t],KL;
		    int JR = align->sites2[t],JL;
                    double YR = Yc(Y,IR,KR), YL;
		    
		    for(; --t >= 0;IR = IL, KR = KL, JR = JL, YR = YL){/* scan from right end in case multiple outliers have right end in L..R, so we pick the rightmost internal outlier */
		      IL = align->sites1[t];
		      KL = align->sitesK1[t];
		      JL = align->sites2[t];
		      YL = Yc(Y,IL,KL);
		      int D = EXTSPLIT_OUTLIER_RANGE ? max(0,min(JR-JL-1, IR-KR-IL - extendSplitFN)) : 0;// NEW360

		      /* check if interval (IL,KL,JL) to (IR,KR,JR) is an outlier with size at least extsplitOutlier kb OR extsplitOutlierLabels misaligned labels*/
		      if(EXTSPLIT_TRACE>=2 && rmap->id == EXTSPLIT_REFID && i==EXTSPLIT_I){
			double delY = YR - YL;
			double delX = (align->orientation ? X[M+1-JL]-X[M+1-JR] : X[JR] - X[JL]) * scale;
			printf("\t alignid=%lu,id=%lld,or=%d,sc=%d,logPV=%0.2f:t=%d..%d:U=%d,I=%d..%d,K=%d..%d,J=%d..%d:B=%d(%0.3f..%0.3f):outlier= %0.3f, iscore= %0.6f, outscore= %0.6f\n",
			       alignid,nanomap->id,align->orientation,align->scaleID,align->logPV,t-1,t,U,IL,IR,KL,KR,JL,JR,B,LB,UB,delX-delY,align->iscore[t],align->outscore[t]);
			fflush(stdout);
		      }

		      if(!(L <= IR-KR && IR-KR <= R+D))
			continue;

		      // HERE HERE if(DEBUG/* HERE >=2 */) assert(U-t-1 >= extsplitOutlierAS);
		      if(!(U-t-1 >= extsplitOutlierAS))
			continue;

		      double delY = YR - YL;
		      double delX = (align->orientation ? X[M+1-JL]-X[M+1-JR] : X[JR] - X[JL]) * scale;
		      if(DEBUG) assert(delX > 0.0);
		      double delta = delX - delY;
		      double adelta = fabs(delta);

		      if(!((adelta >= extsplitOutlier) || (B==KBend+EXTSPLIT_BALANCED && IR-KR-IL + JR-JL -2 >= extsplitOutlierLabels)) || 
			 !(align->iscore[t+1] > align->outscore[t+1] + (FLOAT)0.01 || (outlierExtend && (IL >= IR-KR || JL >= JR))))
			continue;// NOTE: align->outscore[t+1] corresponds to interval align->sites1[t..t+1]

		      if(DEBUG/* HERE HERE >=2 */) assert(align->noutliers > 0 && align->maxoutlier >= delta - 1e-6);

		      if(!((EXTSPLIT_DELBIN && delta < 0.0 && B < KBend) ? (LB < delta && delta <= UB) : (LB <= adelta && adelta < UB)) && !(B==KBend+EXTSPLIT_BALANCED && adelta < extsplitOutlier))
			continue;

		      double QueryLeftend = (align->orientation ? X[M+1] - X[M+1-JR] : X[JR]) * scale;
		      double QueryRight = (align->orientation ? X[M+1-JR] : X[M+1] - X[JR]) * scale;
		      double RefLeftend = Yc(Y,IR,KR);
		      if(RefLeftend - Y[min(i,IR)] <= QueryLeftend - Leftend - extendSplitLen && QueryRight - Rightend >= extsplitOutlierLS){
			int U = align->numpairs;// local U !!! (Required so we can truncate the alignment length for the split contig, if needed)
			if(Rend <= N){/* truncate alignment, to not extend beyond label Y[Rend] */
			  while(U > 0 && align->sites1[U-1] > Rend)
			    U--;
			  if(U <= t+1 /* WAS360 <= 0 */){/* very rare */
			    miss1++;
			    continue;// next outlier
			  }
			} 
			cnt1++;

			maxalignallocNULL(numaligns+1,alignment,numaligns,maxaligns,&alignment_blockid);
			size_t nalignid = numaligns;
			Calign *nalign = alignment[nalignid] = new Calign[1];
			copy(nalign,align,1, 1);// copy : automatically resets Malign
			if(DEBUG) assert(nalign->Malign == NULL);
			if(DEBUG) assert(nalign->maxoutlier >= extsplitOutlier || (B==KBend+EXTSPLIT_BALANCED && IR-KR-IL + JR-JL - 2 >= extsplitOutlierLabels));

			// NOTE : The same alignment could be part of multiple splits. Just mark it for deletion here, so it can be reused, then delete it later from main contig
			align->chimpair = 1;// HERE HERE : check to make sure this left endoutlier does not extend beyond left end of original contig and satisfies -extendWT (its mapWT may be modified)
			//		    Lalignment[alignid] = NULL;
			numalign_end[numrefmaps] = ++numaligns;

			nalign->mapid1 = numrefmaps;
			nalign->Lend = -1;// NO left endoutlier
			if(U < nalign->numpairs) nalign->Rend = -1;// NEW301: NOT endoutlier any more since split reference was truncated on right side !
			nalign->numpairs = U;

			int Ashift = t + 1;/* alignment is truncated to align->sites*[t+1 .. U-1] */
			if(DEBUG) assert(Ashift > 0);
			if(Ashift > 0){
			  nalign->numpairs = U -= Ashift;
			  for(int k = 0; k < U; k++){
			    nalign->sites1[k] = nalign->sites1[k + Ashift];
			    nalign->sitesK1[k] = nalign->sitesK1[k + Ashift];
			    nalign->sites2[k] = nalign->sites2[k + Ashift];
			    nalign->iscore[k+1] = nalign->iscore[k+1 + Ashift];
			    nalign->outscore[k+1] = nalign->outscore[k+1 + Ashift];
			  }
			}

			// reduce nalign->site1[],sitesK1[] values by L-1
			int shift = L-1;
			for(int k = 0; k < U; k++){
			  int I = nalign->sites1[k];
			  int K = nalign->sitesK1[k];
			  if(DEBUG>=2) assert(I-K >= L);
			  nalign->sites1[k] -= shift;
			  if(DEBUG>=2) assert(nalign->sites1[k] <= newrmap->numsite[0]);
			}

#if CALIGN_END==0
			int IL = nalign->sites1[0];
			int KL = nalign->sitesK1[0];
			int JL = nalign->sites2[0];
			nalign->LijY = nalign->Lij1 = LijY(newY,X,IL-KL,JL,newN,M,nalign->orientation,scale);
			nalign->Lij2 = nalign->LijX;// No left endoutlier

			FLOAT xL = (nalign->orientation ? X[M+1] - X[M+1-JL] : X[JL]) * scale;
			FLOAT yL = Yc(newY,IL,KL);
			nalign->iscore[0] = nalign->outscore[0] = Send(min(xL,yL),JL+1-max(1,nalign->LijX),IL-KL+1-max(1,nalign->LijY),IL-KL,newrmap->mapid,0);

			if(U < align->numpairs){
			  int IR = nalign->sites1[U-1];
			  int KR = nalign->sitesK1[U-1];
			  int JR = nalign->sites2[U-1];
			  nalign->RijY = nalign->Rij1 = RijY(newY,X,IR,JR,newN,M,nalign->orientation,scale);
			  nalign->RijX = nalign->Rij2 = RijX(newY,X,IR,JR,newN,M,nalign->orientation,scale);
			  FLOAT xR = (nalign->orientation ? X[M+1-JR] : X[M+1]-X[JR]) * scale;
			  FLOAT yR = Yc(newY,IR,KR);
			  nalign->iscore[U] = nalign->outscore[U] = Send(min(xR,yR),min(M,nalign->RijX)+1-JR,min(newN,nalign->RijY)+1-IR,min(N,nalign->RijY),newrmap->mapid,0);
			} else {
			  nalign->RijY = min(newrmap->numsite[0]+1, align->RijY - shift);
			  nalign->Rij1 = (nalign->Rend >= -1) ? nalign->RijY : nalign->sites1[U-1];
			}
#else
			/* NOTE : nalign->Lij1 should be recomputed for non-endoutlier and is not related to align->Lij1 : The final value is almost always 0 either way */
			nalign->Lij1 = max(0, align->Lij1 - shift);
			nalign->Rij1 = min(newrmap->numsite[0]+1, align->Rij1 - shift);
#endif
			if(DEBUG>=1+RELEASE) assert(0 <= nalign->Lij1 && nalign->Lij1 <= nalign->sites1[0] - nalign->sitesK1[0]);
			if(DEBUG>=1+RELEASE) assert(nalign->sites1[U-1] <= nalign->Rij1 && nalign->Rij1 <= newrmap->numsite[0]+1);

			if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID /*  && Gmap[nalign->mapid2]->id==MAP_TRACE */ && i==EXTSPLIT_I){
			  double QueryLeftend = (align->orientation ? X[M+1] - X[M+1-JR] : X[JR]) * scale;
			  printf("alignid=%lu->%lu: nrefid=%lld,mapid=%lld,or=%d,N=%d,M=%d,Y[%d,%d]=%0.3f,%0.3f,JL=%d(end=%0.3f),L=%d,i=%d,R=%d,Lend=%d,Rend=%d:U=%d->%d,Lij1=%d,Rij1=%d,I=%d..%d,K=%d..%d,J=%d..%d:B=%d: (cnt1=%d,miss1=%d),wt=%0.4f->%0.4f,outlier:t=%d..%d:I=%d..%d,K=%d..%d,J=%d..%d(%0.3f kb)\n",
				 alignid,nalignid,newrmap->id,Gmap[nalign->mapid2]->id,nalign->orientation,newrmap->numsite[0],Gmap[nalign->mapid2]->numsite[0],IR-KR,IR,Y[IR-KR],Y[IR],JR,QueryLeftend,L,i,R,
				 nalign->Lend,nalign->Rend,align->numpairs,U, nalign->Lij1,nalign->Rij1, 
				 nalign->sites1[0],nalign->sites1[U-1],nalign->sitesK1[0],nalign->sitesK1[U-1],nalign->sites2[0],nalign->sites2[U-1],B,cnt1,miss1,align->mapWT,nalign->mapWT,
				 t,t+1,IL,IR,KL,KR,JL,JR,delX-delY);
			  fflush(stdout);
			}
			if(DEBUG>=2) assert(nalign->sites1[U-1] <= newrmap->numsite[0]);
			if(DEBUG>=2) assert(nalign->sites1[0]-nalign->sitesK1[0] >= 1);
			if(DEBUG>=2) assert(nalign->sites2[U-1] <= Gmap[nalign->mapid2]->numsite[0]);
			if(DEBUG>=2) assert(nalign->sites2[0] >= 1);

			nalign->maxoutlier = 0.0;
			nalign->noutliers = 0;
			nalign->maxoutlierLabels = 0;
			if(extendMaxOutlierKBsplit < 998.0){// update nalign->maxoutlier : will not include outlier we split on 
			  int I,lastI = nalign->sites1[0];
			  int K,lastK = nalign->sitesK1[0];
			  int J,lastJ = nalign->sites2[0];
			  for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
			    I = nalign->sites1[t];
			    K = nalign->sitesK1[t];
			    J = nalign->sites2[t];
			    if(nalign->outscore[t] + (FLOAT)0.01 < nalign->iscore[t]){
			      nalign->noutliers++;
			      FLOAT deltaY = Yc(newY,I,K) - Yc(newY,lastI,lastK);
			      FLOAT deltaX = (nalign->orientation ? X[M+1-lastJ] - X[M+1-J] : X[J] - X[lastJ]) * scale;
			      if(DEBUG) assert(deltaX > 0.0);			  
			      FLOAT delta = fabs(deltaY-deltaX);
			      nalign->maxoutlier = max(delta,nalign->maxoutlier);
			      nalign->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, nalign->maxoutlierLabels);// NEW302
			      if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID /* && delta > nalign->maxoutlier */){
				printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f:t=%d(delY=%0.3f,delX=%0.3f,I=%d->%d,K=%d->%d,J=%d->%d),iscore=%0.4f,%0.4f,max=%0.3f,%d\n",
				       alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, t,
				       deltaY,deltaX,lastI,I,lastK,K,lastJ,J,nalign->iscore[t],nalign->outscore[t],nalign->maxoutlier,nalign->maxoutlierLabels);
				printf("\t\t Yik=%0.4f,%0.4f,Xj=%0.4f,%0.4f\n",
				       Yc(newY,lastI,lastK),Yc(newY,I,K),nalign->orientation?X[M+1]-X[M+1-lastJ]:X[lastJ],nalign->orientation?X[M+1]-X[M+1-J]:X[J]);
				fflush(stdout);
			      }
			    } else if(EXTSPLIT_TRACE>=2 && newrmap->id == EXTSPLIT_NREFID){
			      FLOAT deltaY = Yc(newY,I,K) - Yc(newY,lastI,lastK);
			      FLOAT deltaX = (nalign->orientation ? X[M+1-lastJ] - X[M+1-J] : X[J] - X[lastJ]) * scale;
			      if(DEBUG) assert(deltaX > 0.0);			  
			      printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f:t=%d(delY=%0.3f,delX=%0.3f,I=%d->%d,K=%d->%d,J=%d->%d),iscore=%0.4f,%0.4f,max=%0.3f,%d\n",
				     alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, t,
				     deltaY,deltaX,lastI,I,lastK,K,lastJ,J,nalign->iscore[t],nalign->outscore[t],nalign->maxoutlier,nalign->maxoutlierLabels);
			      printf("\t\t Yik=%0.4f,%0.4f,Xj=%0.4f,%0.4f\n",
				     Yc(newY,lastI,lastK),Yc(newY,I,K),nalign->orientation?X[M+1]-X[M+1-lastJ]:X[lastJ],nalign->orientation?X[M+1]-X[M+1-J]:X[J]);
			      fflush(stdout);
			    }
			  }
			}

			if(splitWT > 0.0 && extendWT > 0.0 && nalign->mapWT >= extendMinWT){
			  if(DEBUG>=2) assert(0.0 <= nalign->mapWT && nalign->mapWT <= 1.0);
			  if(DEBUG/* HERE HERE >=2 */) assert(nalign->noutliers >= 0 && nalign->maxoutlier >= 0.0 && nalign->maxoutlierLabels >= 0 &&
							      (nalign->noutliers <= 0 || nalign->maxoutlier > 0.0 || nalign->maxoutlierLabels > 0));

			  if(nalign->maxoutlier <= extendMaxOutlierKBsplit && nalign->maxoutlierLabels < extendMaxOutlierLabelsSplit){/* try to increase nalign->mapWT */
			    if(extendWTdup || nanomap->pMapWT == NULL || nalign->mapWT > nanomap->origMapWT){
			      if(!extendWTdup){// NEW73
				if(nanomap->pMapWT){
				  if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
				    printf("\t alignid=%lu->%lu:mapid=%d(id=%lld): Restoring mapWT= %0.6f to %0.6f at %p\n", 
					   alignid,nalignid,nanomap->mapid,nanomap->id, *nanomap->pMapWT, nanomap->origMapWT, nanomap->pMapWT);
				    fflush(stdout);
				  }
				  *nanomap->pMapWT = nanomap->origMapWT;
				}
				nanomap->pMapWT = &nalign->mapWT;
				nanomap->origMapWT = nalign->mapWT;
			      }
			      if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
				printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.6f -> %0.6f at %p: -extendWT %0.1f %0.3f %d %0.1f %0.3f %0.1f %d %0.3f %0.1f %d\n",
				       alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, nalign->maxoutlier,nalign->maxoutlierLabels,
				       nalign->mapWT, max(nalign->mapWT,extendWT), &nalign->mapWT,
				       extendLen,extendWT,extendFN,extendFNlen,extendMinWT,extendMaxOutlierKB,extendMaxOutlierLabels,extendMaxWT,extendMaxOutlierKBsplit,extendMaxOutlierLabelsSplit);
				fflush(stdout);
			      }
			      nalign->mapWT = max(extendWT, nalign->mapWT);
			    }
			  } else {
			    if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
			      printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.6f -> %0.6f at %p: -extendWT %0.1f %0.3f %d %0.1f %0.3f %0.1f %d %0.3f %0.1f %d\n",
				     alignid,nalignid,numrefmaps,newrmap->id,mapid, nanomap->id, nalign->orientation, nalign->numpairs, nalign->score, nalign->logPV, nalign->maxoutlier,nalign->maxoutlierLabels,
				     nalign->mapWT, min(nalign->mapWT,extendMaxWT), &nalign->mapWT,
				     extendLen,extendWT,extendFN,extendFNlen,extendMinWT,extendMaxOutlierKB,extendMaxOutlierLabels,extendMaxWT,extendMaxOutlierKBsplit,extendMaxOutlierLabelsSplit);
			      fflush(stdout);
			    }
			    nalign->mapWT = min(extendMaxWT, nalign->mapWT);
			  }

			  if(DEBUG>=2) assert(0.0 <= nalign->mapWT && nalign->mapWT <= 1.0);
			}

			break;/* found internal outlier */
		      }
		    } // for(;--t >= 0;IR=IL,KR=KL,JR=JL)

		    if(t >= 0)// used internal outlier
		      continue;// next alignment
		  }// if (extsplitOutlier > 0 && align->mapWT >= splitFiltMinWT)

		  int IR = align->sites1[U-1];

		  if(extsplitNE && align->Lend >= -1 && I-K >= L && (align->Rend >= -1 || (Rend >= N+1 && IR >= N+1 - extendSplitSpacing)) /* no endoutliers or only right endoutlier near right end of refid */
		     && (Rend >= N+1 || I <= Rend)){
		    // HERE : these maps are not needed if the right end is trunctated, unless the split left end falls within EndLen of the right end of  contig refid
		    int U = align->numpairs;
		    if(Rend <= N){/* truncate alignment, to not extend beyond label Y[Rend] */
		      while(U > 0 && align->sites1[U-1] > Rend)
			U--;
		      if(U <= 0)/* can happen if Rend == R and I-K == R and I > R */
			continue;
		    } 

		    maxalignallocNULL(numaligns+1,alignment,numaligns,maxaligns,&alignment_blockid);
		    Calign *nalign = alignment[numaligns] = new Calign[1];
		    copy(nalign,align,1, 1);// copy : automatically resets Malign
		    if(DEBUG) assert(nalign->Malign == NULL);

		    numalign_end[numrefmaps] = ++numaligns;
		    nalign->mapid1 = numrefmaps;
		    if(U < nalign->numpairs) nalign->Rend = -1;// NEW301: NOT endoutlier any more since split reference was truncated on right side !
		    nalign->numpairs = U;

		    // reduce align->site1[],sitesK1[] values by L-1
		    int shift = L-1;
		    for(int t = 0; t < U; t++){
		      int I = nalign->sites1[t];
		      int K = nalign->sitesK1[t];
		      if(DEBUG>=2) assert(I-K >= L);
		      nalign->sites1[t] -= shift;
		      if(DEBUG>=2) assert(nalign->sites1[t] <= newrmap->numsite[0]);
		    }

#if CALIGN_END==0
		    nalign->Lij1 = nalign->LijY = max(0, align->LijY - shift);
		    nalign->Lij2 = nalign->LijX = LijX(newY,X,nalign->sites1[0]-nalign->sitesK1[0],nalign->sites2[0],newN,M,nalign->orientation, scale);

		    int IR = nalign->sites1[U-1];
		    int KR = nalign->sitesK1[U-1];
		    int JR = nalign->sites2[U-1];
		    if(DEBUG/* HERE HERE >=2 */) assert(JR <= M);
		    nalign->RijY = RijY(newY,X,IR,JR,newN,M,nalign->orientation, scale);
		    nalign->Rij1 = (nalign->Rend >= -1) ? nalign->RijY : IR;
		    nalign->RijX = RijX(newY,X,IR,JR,newN,M,nalign->orientation, scale);
		    nalign->Rij2 = (nalign->Rend >= -1) ? nalign->RijX : JR;
		    if(U < align->numpairs){
		      FLOAT xR = (nalign->orientation ? X[M+1-JR] : X[M+1]-X[JR]) * scale;
		      FLOAT yR = Yc(newY,IR,KR);
		      nalign->iscore[U] = nalign->outscore[U] = Send(min(xR,yR),min(M,nalign->RijX)+1-JR,min(newN,nalign->RijY)+1-IR,min(N,nalign->RijY),newrmap->mapid,0);
		    }
#else
		    // NOTE : nalign->Lij1 not quite accurate : see above
		    nalign->Lij1 = max(0, align->Lij1 - shift);// NEW48
		    nalign->Rij1 = min(newrmap->numsite[0]+1, align->Rij1 - shift);// NEW48
#endif

		    if((VERB>=2 && newrmap->id == 1253000002LL /* && Gmap[nalign->mapid2]->id==MAP_TRACE */) ||
		       !((0 <= nalign->Lij1 && nalign->Lij1 <= nalign->sites1[0] - nalign->sitesK1[0]) &&
			 (nalign->sites1[U-1] <= nalign->Rij1 && nalign->Rij1 <= newrmap->numsite[0]+1))){
		      printf("nrefid=%lld,mapid=%lld,or=%d,N=%d->%d,M=%d,Lend=%d,Rend=%d:U=%d,Lij1=%d,Rij1=%d,I=%d..%d,K=%d..%d,J=%d..%d\n",
			     newrmap->id,Gmap[nalign->mapid2]->id,nalign->orientation,N,newrmap->numsite[0],Gmap[nalign->mapid2]->numsite[0],nalign->Lend,nalign->Rend,U,
			     nalign->Lij1,nalign->Rij1,			     
			     nalign->sites1[0],nalign->sites1[U-1],nalign->sitesK1[0],nalign->sitesK1[U-1],nalign->sites2[0],nalign->sites2[U-1]);
		      fflush(stdout);
		    }
		    if(DEBUG) assert(0 <= nalign->Lij1 && nalign->Lij1 <= nalign->sites1[0] - nalign->sitesK1[0]);
		    if(DEBUG) assert(nalign->sites1[U-1] <= nalign->Rij1 && nalign->Rij1 <= newrmap->numsite[0]+1);
		    if(DEBUG>=2) assert(nalign->sites1[U-1] <= newrmap->numsite[0]);
		    if(DEBUG>=2) assert(nalign->sites1[0]-nalign->sitesK1[0] >= 1);
		    if(DEBUG>=2) assert(nalign->sites2[U-1] <= Gmap[nalign->mapid2]->numsite[0]);
		    if(DEBUG>=2) assert(nalign->sites2[0] >= 1);

		    cnt++;
		    continue;
		  }
		}

		if(VERB/* HERE >=2 */){
		  if(newrmap->Mask[0]){
		    if(extsplitOutlier > 0.0)
		      printf("Splitting off refid=%d(id=%lld,Len=%0.3f,N=%d,alignids=%lu..%lu/%lu) right region Y[%d,%d,%d..%d]=%0.3f,%0.3f,%0.3f..%0.3f,cov[%d]=%0.2f,B=%d with %d+%d left (end)outliers(orig=%d,wt=%0.2f) + %d other alignments into refid=%d(id=%lld,Len=%0.3f,N=%d,aligids=%lu..%lu),Mask[1]= x%lx, Mask[N+1]= x%lx\n",
			     refid, rmap->id, rmap->site[0][N+1], N, start,end-1, align_end,L, i, R, Rend, leftend, Y[i],Y[R],rightend, i, coverage[i], B,cnt1, miss1, endoutlierLim[B][i], endoutlierLm[B][i], cnt, numrefmaps, newrmap->id, newrmap->site[0][newrmap->numsite[0]+1],newrmap->numsite[0],numalign_start[numrefmaps],numalign_end[numrefmaps],newrmap->Mask[0][1],newrmap->Mask[0][newrmap->numsite[0]+1]);
		    else
		      printf("Splitting off refid=%d(id=%lld,Len=%0.3f,N=%d,alignids=%lu..%lu/%lu) right region Y[%d,%d,%d..%d]=%0.3f,%0.3f,%0.3f..%0.3f,cov[%d]=%0.2f with %d+%d left endoutliers(orig=%d,wt=%0.2f) + %d other alignments into refid=%d(id=%lld,Len=%0.3f,N=%d,aligids=%lu..%lu),Mask[1]= x%lx, Mask[N+1]= x%lx\n",
			     refid, rmap->id, rmap->site[0][N+1], N, start, end-1, align_end,L, i, R, Rend, leftend, Y[i],Y[R],rightend, i, coverage[i], cnt1, miss1, endoutlierLi[i], endoutlierL[i], cnt, numrefmaps, newrmap->id, newrmap->site[0][newrmap->numsite[0]+1],newrmap->numsite[0],numalign_start[numrefmaps],numalign_end[numrefmaps],newrmap->Mask[0][1],newrmap->Mask[0][newrmap->numsite[0]+1]);
		  } else
		    printf("Splitting off refid=%d(id=%lld,Len=%0.3f,N=%d,alignids=%lu..%lu/%lu) right region Y[%d,%d,%d..%d]=%0.3f,%0.3f,%0.3f..%0.3f,cov[%d]=%0.2f,B=%d with %d+%d left endoutliers(orig=%d,wt=%0.2f) + %d other alignments into refid=%d(id=%lld,Len=%0.3f,N=%d,aligids=%lu..%lu),Mask= NULL\n",
			   refid, rmap->id, rmap->site[0][N+1], N, start,end-1, align_end,L, i, R,Rend, leftend, Y[i],Y[R],rightend, i, coverage[i], B,cnt1, miss1, endoutlierLim[B][i], endoutlierLm[B][i], cnt, numrefmaps, newrmap->id, newrmap->site[0][newrmap->numsite[0]+1],newrmap->numsite[0],numalign_start[numrefmaps],numalign_end[numrefmaps]);

		  fflush(stdout);
		}

		/*		if(numrefmaps >= 2){
		  printf("DEBUG EXIT\n");
		  fflush(stdout);exit(1);
		  }*/

		if(DEBUG>=1+RELEASE) assert(cnt1 + miss1 >= floor(endoutlierLm[B][i] + 0.999));
		if(DEBUG>=1+RELEASE) assert(cnt1 + miss1 >= endoutlierLim[B][i]);

		//		assert(cnt1 + miss1 <= endoutlierLm[B][i] + 0.01);// only valid if wt == 1.0 

		if(DEBUG) assert(!(EXTSPLIT_FORK && extendSplit && Refine && !(MapScale && giter==0 && !origMapScale && !pSNRtotLL) && child_pid==NULL && numchild==0));// cannot be a child job

		numY = ++numrefmaps;
		numalign_start[numrefmaps] = numalign_end[numrefmaps] = numaligns;
	      }
	    }

	    if(endoutlierRm[B][i] >= threshold && (i <= N+1 - range2 || (EXTSPLIT_SPACING_FIX && Y[N+1]-Y[i] >= Xrange2))){
	      double maxEnd = 0.0;
	      int jmax = -1;

	      double minLeft, minRight;
	      minLeft = minRight = endoutlierRm[B][i]; // WAS162 endoutlierL[i];

	      for(int j = left; j <= right; j++){
		if(j==i)
		  continue;

		if(EXTSPLIT_VERIFYPEAK){
		  if(j < i)
		    minLeft = min(minLeft,endoutlierRm[B][j]);
		  else
		    minRight = min(minRight,endoutlierRm[B][j]);
		}

		if(EXTSPLIT_SPACING_FIX && fabs(Y[j] - Y[i]) > Xrange && (EXTSPLIT_SPACING_FIX >=2 || endoutlierRm[B][j] < endoutlierRm[B][i])){// NEW8
		  if(j < i)
		    continue;
		  break;
		}

		if(DEBUG>=2) assert(jmax < j);

		if(endoutlierRm[B][j] >= maxEnd && endoutlierRm[B][j] >= max(extendSplitB, extendFrac * coverage[j]) &&
		   (jmax < 0 || maxEnd < endoutlierRm[B][j] || !EXTSPLIT_BIAS /* && jmax < j*/)){// NOTE : ties are broken in favor of rightmost split if EXTSPLIT_BIAS == 0, leftmost otherwise
		  maxEnd = endoutlierRm[B][j];
		  jmax = j;
		}
	      }

	      if(VERB>=2 && 1362 <= i && i <= 1369/* && i==17658*/){
		if(EXTSPLIT_VERIFYPEAK)
		  printf("i=%d:left=%d,right=%d:B=%d:jmax=%d, endoutlierR[jmax]= %0.2f (maxEnd= %0.2f), endoutlierR[i]= %0.2f,minLeft=%0.2f,minRight=%0.2f\n",
			 i,left,right,B,jmax,endoutlierRm[B][(jmax < 0) ? i : jmax],maxEnd, endoutlierRm[B][i],minLeft,minRight);
		else
		  printf("i=%d:left=%d,right=%d:B=%d:jmax=%d, endoutlierR[jmax]= %0.2f (maxEnd= %0.2f), endoutlierR[i]= %0.2f\n",
			 i,left,right,B,jmax,endoutlierRm[B][(jmax < 0) ? i : jmax],maxEnd, endoutlierRm[B][i]);
		fflush(stdout);
	      }

	      if(maxEnd <= endoutlierRm[B][i] && (!EXTSPLIT_BALANCED || B <= KBend || endoutlierRm[B][i] > endoutlierRm[KBend+2][i]) &&
		 (jmax < 0 || maxEnd < endoutlierRm[B][i] || (EXTSPLIT_BIAS ? 
							      (jmax > i && (!EXTSPLIT_VERIFYPEAK || minRight < endoutlierRm[B][i])) : 
							      (jmax < i && (!EXTSPLIT_VERIFYPEAK || minLeft < endoutlierRm[B][i])) ))){
		size_t start = EXTSPLIT_RANGE ? endoutlierStartR[i] : align_start;
		size_t end = EXTSPLIT_RANGE ? endoutlierEndR[i]+1 : align_end;

		SplitBinCnt[B]++;

		/* split off right endoutliers along with Y[0 .. i] as a new extension refinement */
		if(EXTSPLIT_TRACE/* HERE HERE >=2 */ && i== EXTSPLIT_I){
		  printf("Splitting off refid=%d(id=%lld,Len=%0.3f,N=%d,alignids=%lu..%lu/%lu) region left of Y[%d]=%0.3f,cov=%0.2f,B=%d with %d(wt=%0.3f) right endoutliers: maxEnd=%0.3f,jmax=%d(right endoutliers=%0.3f,cov=%0.3f),minLeft=%0.3f,minRight=%0.3f,range=%d,%d,Xrange=%0.3f,%0.3f\n", 
			 refid, rmap->id, rmap->site[0][N+1], N, start,end-1,align_end, i,Y[i], coverage[i], B, endoutlierRim[B][i], endoutlierRm[B][i], maxEnd, jmax, endoutlierRm[B][jmax],coverage[jmax],minLeft,minRight,left,right,Xrange,Xrange2);
		  fflush(stdout);
		}
		NumSplits++;

		/* reallocate numalign_start[] and numalign_end[] if needed */
		if(numrefmaps >= maxnumrefmaps){
		  int new_maxnumrefmaps = max(maxnumrefmaps*5/4, maxnumrefmaps + 16);
		  size_t *new_numalign_start = new size_t[new_maxnumrefmaps+1];
		  size_t *new_numalign_end = new size_t[new_maxnumrefmaps+1];
		  memcpy(new_numalign_start,numalign_start,(numrefmaps+1)*sizeof(size_t));
		  memcpy(new_numalign_end,numalign_end,(numrefmaps+1)*sizeof(size_t));
		  delete [] numalign_start;
		  delete [] numalign_end;
		  if(!extsplitNE || extTrim){
		    if(DEBUG) assert(extsplitExtOnly);
		    if((extsplitExtOnly = (double *)realloc(extsplitExtOnly, new_maxnumrefmaps * sizeof(double))) == NULL){
		      printf("realloc of %lu bytes filed (new maxnumrefmaps=%d)\n",new_maxnumrefmaps*sizeof(double), new_maxnumrefmaps);
		      fflush(stdout);exit(1);
		    }
		    if(VERB>=2){
		      printf("Reallocated extsplitExtOnly = %p : maxnumrefmaps= %d -> %d\n",extsplitExtOnly, maxnumrefmaps, new_maxnumrefmaps);
		      fflush(stdout);
		    }
		    for(int r = maxnumrefmaps; r < new_maxnumrefmaps; r++)
		      extsplitExtOnly[r] = EndLen;
		  }
		  numalign_start = new_numalign_start;
		  numalign_end = new_numalign_end;
		  maxnumrefmaps = new_maxnumrefmaps;
		}
		numalign_start[numrefmaps] = numalign_end[numrefmaps] = numaligns;
	
		int L = max(1, i - max(splitFiltFN, extendSplitFN));// NEW152
		int R = min(N, i + max(splitFiltFP, extendSplitFP));// NEW152
		double FNlen = max(splitFiltFNlen, extendSplitFNlen);// NEW152
		while(L > 1 && Y[i] - Y[L-1] <= FNlen)
		  L--;// NEW8
		  
		if(!extsplitNE || extTrim){
		  if(DEBUG) assert(extsplitExtOnly);
		  extsplitExtOnly[numrefmaps] = min(EndLen, Y[R] - Y[L]);
		}

		int Lend = 0;
		if(CloneLimitLen > 0.0){
		  if(EndLen < CloneLimitLen)
		    Lend = 1;/* NEW106 : to force creation of Mask[0][1] */
		  while(Lend < L && Y[i] - Y[Lend+1] >= CloneLimitLen && L - Lend - 1 >= CloneLimitN)
		    Lend++;
		}

		/* copy rmap from just before site Lend (or left end if Lend==0) to just past site R */
		FLOAT *Y = rmap->site[0];
		double leftend = max(0.0, Y[Lend] - MININTERVAL);
		double rightend = min(Y[N+1], Y[R] + MININTERVAL);

		/* make sure the array refmap[] is large enough */
		maxmapalloc(maxnumrefmaps, maxrefmaps, refmap, 0, 1);
		YYmap = refmap;

		Cmap *newrmap;
		if(!EXTSPLIT_MINMEM){
		  newrmap = refmap[numrefmaps] =  new Cmap(rmap);// NOTE : this will waste the space allocated by maxmapalloc() for refmap[numrefmaps] and leak this replacement memory
		  newrmap->trim(leftend, rightend);
		} else {
		  Cmap *nrmap = new Cmap(rmap);
		  nrmap->trim(leftend, rightend);		
		  newrmap = new Cmap(nrmap);// compacts the memory for the trimmed map
		  delete nrmap;// frees memory of original untrimmed map

		  /* swap *refmap[numrefmaps] and *newrmap*/
		  Cmap tmp = *refmap[numrefmaps];
		  *refmap[numrefmaps] = *newrmap;
		  *newrmap = tmp;

		  delete newrmap;// frees deep memory from refmap[numrefmaps] (typically nothing) and container Cmap allocated with 2nd "new Cmap" above
		  newrmap = refmap[numrefmaps];
		}

		newrmap->mapid = numrefmaps;

		FLOAT *newY = newrmap->site[0];
		int newN = newrmap->numsite[0];

		if(DEBUG && leftend <= 1e-6 && rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT)) assert(newrmap->Mask[0] && (newrmap->Mask[0][1] & END_NOEXT));
		if(DEBUG && rightend >= Y[N+1] - 1e-6 && rmap->Mask[0] && (rmap->Mask[0][N+1] & END_NOEXT)) assert(newrmap->Mask[0] && (newrmap->Mask[0][newrmap->numsite[0]+1] & END_NOEXT));
		if(DEBUG) assert(newrmap->numsite[0] == (Lend <= 0 ? R : R - Lend + 1));

		/* compute unique ID for new consensus map */
		newrmap->id = rmap->id;
		if(SplitCnt)
		  newrmap->id += NumSplits * SplitCnt;
		else
		  newrmap->id = nextContigId(ContigCntFile);
		if(DEBUG) assert(newrmap->id > 0);

		if(Lend > 0){/* mark left end of newrmap as non-extendable */
		  if(!newrmap->Mask[0]){
		    newrmap->Mask[0] = new size_t[newrmap->numsite[0] + 2];
		    memset(newrmap->Mask[0], 0, (newrmap->numsite[0] + 2) * sizeof(size_t));
		  }
		  newrmap->Mask[0][1] |= END_NOEXT;// NOTE Mask[c][0] is not used since it cannot be output into the CMAP file
		  if(VERB/* HERE HERE >=2 */){
		    printf("Marking left end of new split contig refid=%d(id=%lld) with Mask[0][1]= %#10lx (orig:leftend=%0.3f,rightend=%0.3f,Len=%0.3f),new N=%d,Y[1,N,N+1]=%0.3f,%0.3f,%0.3f\n",
			   newrmap->mapid,newrmap->id,newrmap->Mask[0][1], leftend, rightend, rmap->site[0][N+1],newN,newY[1],newY[newN],newY[newN+1]);
		    fflush(stdout);
		  }
		}

		/* Move all alignments with right endoutliers (if B >= KBend) starting at L..R to new contig.
		   If extsplitOutlier > 0.0 : Also copy alignments with outliers with left end at L-D..R, treating outlier plus region right of it as endoutlier
		                                  where D = max(0,min(JR-JL-1,IR-KR-IL - extendSplitFN))
		   If extsplitNE : Also copy alignments without endoutliers that are aligned only to the new contig region (Y[Lend .. R])
		   If extsplitNE : Also copy alignments with left endoutliers that are within extendSplitSpacing of left end (and left end was not truncated) */

		int cnt = 0, cnt1 = 0, miss1 = 0;

		for(size_t alignid = start; alignid < end; alignid++){
		  Calign *align = Lalignment[alignid];
		  if(!align)
		    continue;
		  if(DEBUG>=2) assert(align->mapid1 == refid);
		  if(0/* HERE HERE */ && !EXTSPLIT_TRACE && align->mapWT < splitFiltMinWT && !extsplitNE)
		    continue;
		  int U = align->numpairs;
		  int IR = align->sites1[U-1];
		  int KR = align->sitesK1[U-1];
		  if(0/* HERE HERE */ && !EXTSPLIT_TRACE && !extsplitNE){
		    if(IR < L)
		      continue;
		    if(extsplitOutlier > 0.0){
		      int t = min(U-1,extsplitOutlierAS);
		      int IL = align->sites1[t];
		      //		      int KL = align->sitesK1[t];
		      if(IL > R)
			continue;
		    } else if(IR > R)
		      continue;
		  }
		  
		  int JR = align->sites2[U-1];
		  int mapid = align->mapid2;
		  Cmap *nanomap = Gmap[mapid];
		  int M = nanomap->numsite[0];
		  double scale = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;	    
		  FLOAT *X = nanomap->site[0];

		  /* First check if alignment has right endoutlier */
		  double QueryRightend = (align->orientation ? X[M+1-JR] : X[M+1] - X[JR]) * scale;
		  double Rightend = (align->orientation ? X[1] : X[M+1]-X[M]) * scale;
		  double RefRightend = Yc(Y,IR,KR);		  

		  if(EXTSPLIT_TRACE>=2 && rmap->id == EXTSPLIT_REFID && newrmap->id == EXTSPLIT_NREFID && i==EXTSPLIT_I){
		    printf("refid=%d:alignid=%lu(%lu..%lu/%lu):mapid1=%d(%lld),mapid2=%d(id=%lld),score=%0.6f,logPV=%0.2f,numpairs=%d:Malign=%p,multicnt=%d:U=%d,I=%d..%d,K=%d..%d,J=%d..%d\n",
			   refid,alignid,start,end-1,align_end,align->mapid1,newrmap->id,align->mapid2,Gmap[align->mapid2]->id,align->score,align->logPV,align->numpairs,
			   align->Malign,align->multicnt,U,align->sites1[0],IR,align->sitesK1[0],KR,align->sites2[0],JR);
		    fflush(stdout);
		  }

		  if(align->Rend <= -2 && B >= KBend && L <= IR && IR <= R /* NEW8 */&& Y[max(i,IR-KR)] - RefRightend <= QueryRightend - Rightend - extendSplitLen && align->mapWT >= splitFiltMinWT){/* right endoutliers */
		    if(DEBUG && !(align->Malign == NULL)){/* Lalignment should only contain sub-matchgroups */
		      printf("refid=%d:alignid=%lu(%lu..%lu/%lu):mapid1=%d(%lld),mapid2=%d(id=%lld),score=%0.6f,logPV=%0.2f,numpairs=%d:Malign=%p,multicnt=%d\n",
			     refid,alignid,start,end-1,align_end,align->mapid1,newrmap->id,align->mapid2,Gmap[align->mapid2]->id,align->score,align->logPV,align->numpairs,
			     align->Malign,align->multicnt);
		      fflush(stdout);
		      assert(align->Malign == NULL);
		    }

		    int Ashift = 0;
		    if(Lend > 0){/* truncate alignment to not extend before label Y[Lend] */
		      while(Ashift < U && align->sites1[Ashift] - align->sitesK1[Ashift] < Lend)
			Ashift++;
		      if(Ashift >= U){/* very rare */
			miss1++;
			continue;// next alignment (NOTE : no need to check for internal outliers since they won't match same interval L..R for same alignment
		      }
		    }
		    cnt1++;

		    /* NOTE : cannot just move the align pointer from align == Lalignment[alignid] to alignment[numaligns], since align may be same as alignment[t]->Malign[k]
		       since Lalignment[align_start..align_end-1] is derived from alignment[numalign_start[refid]..numalign_end[refid]-1]->Malign[] and hence
		       align would end up being freed twice via alignment[numaligns] and alignment[t]->Malign[k] */

		    maxalignallocNULL(numaligns+1,alignment,numaligns,maxaligns,&alignment_blockid);
		    size_t nalignid = numaligns;
		    Calign *nalign = alignment[nalignid] = new Calign[1];
		    copy(nalign,align, 1, 1);// copy : automatically resets Malign
		    if(DEBUG) assert(nalign->Malign == NULL);// HERE : check to make sure this right endoutlier does not extend beyond right end of original contig ?
		    if(DEBUG) assert(nalign->maxoutlier >= 0.0);

		    // NOTE : The same endoutlier could be part of multiple splits. Just mark it for deletion here, so it can be reused, then delete it later
		    align->chimpair = 1;// HERE HERE : check to make sure this right endoutlier does not extend beyond right end of original contig
		    //		    Lalignment[alignid] = NULL;
		    numalign_end[numrefmaps] = ++numaligns;

		    nalign->mapid1 = numrefmaps;
		    nalign->Rend = -1;// NOT endoutlier any more !

		    if(Ashift > 0){
		      nalign->numpairs = U -= Ashift;
		      nalign->Lend = -1;// NEW301 : NOT endoutlier any more since split reference was truncated on left side !
		      for(int t = 0; t < U; t++){
			nalign->sites1[t] = nalign->sites1[t + Ashift];
			nalign->sitesK1[t] = nalign->sitesK1[t + Ashift];
			nalign->sites2[t] = nalign->sites2[t + Ashift];
			nalign->iscore[t+1] = nalign->iscore[t+1 + Ashift];
			nalign->outscore[t+1] = nalign->outscore[t+1 + Ashift];
		      }
		    }

		    int shift = max(0, Lend - 1);
		    if(shift > 0 || DEBUG>=2){
		      for(int t = 0; t < U; t++){
			int I = nalign->sites1[t];
			int K = nalign->sitesK1[t];
			if(DEBUG && !(I-K >= Lend)){
			  printf("nrefid=%lld,mapid=%lld,or=%d,N=%d,M=%d:alignid=%lu:Lend=%d,Rend=%d,t=%d,U=%d:I=%d,K=%d,J=%d,shift=%d,Lend=%d,L=%d,R=%d\n",
				 newrmap->id,Gmap[nalign->mapid2]->id,nalign->orientation,newrmap->numsite[0],Gmap[nalign->mapid2]->numsite[0],
				 alignid,nalign->Lend,nalign->Rend,t,U,I,K,nalign->sites2[t],shift,Lend,L,R);
			  fflush(stdout);
			  assert(I-K >= Lend);
			}
			nalign->sites1[t] -= shift;
			if(DEBUG>=2) assert(nalign->sites1[t] <= newrmap->numsite[0]);
		      }
		    }

#if CALIGN_END==0
		    if(Ashift > 0){
		      int IL = nalign->sites1[0];
		      int KL = nalign->sitesK1[0];
		      int JL = nalign->sites2[0];
		      nalign->LijY = nalign->Lij1 = LijY(newY,X,IL-KL,JL,newN,M,nalign->orientation,scale);
		      nalign->LijX = nalign->Lij2 = LijX(newY,X,IL-KL,JL,newN,M,nalign->orientation,scale);

		      FLOAT xL = (nalign->orientation ? X[M+1] - X[M+1-JL] : X[JL]) * scale;
		      FLOAT yL = Yc(newY,IL,KL);
		      nalign->iscore[0] = nalign->outscore[0] = Send(min(xL,yL),JL+1-max(1,nalign->LijX),IL-KL+1-max(1,nalign->LijY),IL-KL,newrmap->mapid,0);
		    } else {
		      nalign->Lij1 = nalign->LijY = max(0, align->LijY - shift);
		      nalign->Lij1 = (nalign->Lend >= -1) ? nalign->LijY : nalign->sites1[0] - nalign->sitesK1[0];
		    }

		    int IR = nalign->sites1[U-1];
		    int KR = nalign->sitesK1[U-1];
		    int JR = nalign->sites2[U-1];
		    nalign->Rij1 = nalign->RijY = RijY(newY,X,IR,JR,newN,M,nalign->orientation,scale);// min(newrmap->numsite[0]+1, align->RijY - shift);
		    if(DEBUG) assert(nalign->Rij1 >= min(newrmap->numsite[0]+1,align->Rij1 - shift));
		    nalign->Rij2 = nalign->RijX;// NOT right endoutlier any more

		    FLOAT xR = (nalign->orientation ? X[M+1-JR] : X[M+1]-X[JR]) * scale;
		    FLOAT yR = Yc(newY,IR,KR);
		    nalign->iscore[U] = nalign->outscore[U] = Send(min(xR,yR),min(M,nalign->RijX)+1-JR,min(newN,nalign->RijY)+1-IR,min(N,nalign->RijY),newrmap->mapid,0);
#else
		    /* NOTE : nalign->Rij1 should be recomputed as non-endoutlier and should be at least align->Rij1 - shift + 1 */
		    nalign->Lij1 = max(0, align->Lij1 - shift);// NEW48
		    nalign->Rij1 = min(newrmap->numsite[0]+1, align->Rij1 - shift);// NEW48
#endif

		    if(DEBUG) assert(0 <= nalign->Lij1 && nalign->Lij1 <= nalign->sites1[0] - nalign->sitesK1[0]);
		    if(DEBUG) assert(nalign->sites1[U-1] <= nalign->Rij1 && nalign->Rij1 <= newrmap->numsite[0]+1);

		    if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID && i==EXTSPLIT_I /* && Gmap[nalign->mapid2]->id==MAP_TRACE */){
		      printf("alignid=%lu,nrefid=%lld,map id=%lld,or=%d,N=%d,M=%d:pairs=%d,score=%0.6f,logPV=%0.2f:Y[%d,%d]=%0.3f,%0.3f,JR=%d,L=%d,i=%d,R=%d,Lend=%d,Rend=%d:U=%d,Lij1=%d,Rij1=%d,I=%d..%d,K=%d..%d,J=%d..%d:\n\t right endoutlier (Xend=%0.3f - %0.3f,Yend=%0.3f),cnt1=%d,miss1=%d,wt=%0.4f->%0.4f\n",
			     alignid,newrmap->id,Gmap[nalign->mapid2]->id,nalign->orientation, newrmap->numsite[0],Gmap[nalign->mapid2]->numsite[0],nalign->numpairs,nalign->score,nalign->logPV,
			     IR-KR,IR,Y[IR-KR],Y[IR],JR,L,i,R,nalign->Lend,nalign->Rend,U,
			     nalign->Lij1,nalign->Rij1,nalign->sites1[0],nalign->sites1[U-1],nalign->sitesK1[0],nalign->sitesK1[U-1],nalign->sites2[0],nalign->sites2[U-1],
			     QueryRightend,Rightend,Y[max(i,IR-KR)]-RefRightend,cnt1,miss1,align->mapWT,nalign->mapWT);
		      fflush(stdout);
		    }
		    if(DEBUG>=2) assert(nalign->sites1[U-1] <= newrmap->numsite[0]);
		    if(DEBUG>=2) assert(nalign->sites1[0]-nalign->sitesK1[0] >= 1);
		    if(DEBUG>=2) assert(nalign->sites2[U-1] <= Gmap[nalign->mapid2]->numsite[0]);
		    if(DEBUG>=2) assert(nalign->sites2[0] >= 1);

		    nalign->maxoutlier = 0.0;
		    nalign->noutliers = 0;
		    nalign->maxoutlierLabels = 0;
                    if(extendMaxOutlierKBsplit < 998.0){    // update nalign->maxoutlier etc
		      int I,lastI = nalign->sites1[0];
		      int K,lastK = nalign->sitesK1[0];
		      int J,lastJ = nalign->sites2[0];
		      for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
			I = nalign->sites1[t];
			K = nalign->sitesK1[t];
			J = nalign->sites2[t];
			if(nalign->outscore[t] + (FLOAT)0.01 < nalign->iscore[t]){
			  nalign->noutliers++;
			  FLOAT deltaY = Yc(newY,I,K) - Yc(newY,lastI,lastK);
			  FLOAT deltaX = (nalign->orientation ? X[M+1-lastJ] - X[M+1-J] : X[J] - X[lastJ]) * scale;
			  if(DEBUG) assert(deltaX > 0.0);			  
			  FLOAT delta = fabs(deltaY-deltaX);
			  nalign->maxoutlier = max(delta,nalign->maxoutlier);
			  nalign->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, nalign->maxoutlierLabels);// NEW302
			  if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID /* && delta > nalign->maxoutlier */){
			    printf("\t alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f:t=%d,(delY=%0.3f,delX=%0.3f,I=%d->%d,K=%d->%d,J=%d->%d),iscore=%0.4f,%0.4f,max=%0.3f,%d\n",
		                   alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, t,
		                   deltaY,deltaX,lastI,I,lastK,K,lastJ,J,nalign->iscore[t],nalign->outscore[t],nalign->maxoutlier,nalign->maxoutlierLabels);
			    printf("\t\t Yik=%0.4f,%0.4f,Xj=%0.4f,%0.4f\n",
				   Yc(newY,lastI,lastK),Yc(newY,I,K),nalign->orientation?X[M+1]-X[M+1-lastJ]:X[lastJ],nalign->orientation?X[M+1]-X[M+1-J]:X[J]);
			    fflush(stdout);
			  }
		        } else if(EXTSPLIT_TRACE>=2 && newrmap->id == EXTSPLIT_NREFID){
			  FLOAT deltaY = Yc(newY,I,K) - Yc(newY,lastI,lastK);
			  FLOAT deltaX = (nalign->orientation ? X[M+1-lastJ] - X[M+1-J] : X[J] - X[lastJ]) * scale;
			  if(DEBUG) assert(deltaX > 0.0);			  
      		          printf("\t alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f:t=%d(delY=%0.3f,delX=%0.3f,I=%d->%d,K=%d->%d,J=%d->%d),iscore=%0.4f,%0.4f,max=%0.3f,%d\n",
				 alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, t,
				 deltaY,deltaX,lastI,I,lastK,K,lastJ,J,nalign->iscore[t],nalign->outscore[t],nalign->maxoutlier,nalign->maxoutlierLabels);
			  printf("\t\t Yik=%0.4f,%0.4f,Xj=%0.4f,%0.4f\n",
				 Yc(newY,lastI,lastK),Yc(newY,I,K),nalign->orientation?X[M+1]-X[M+1-lastJ]:X[lastJ],nalign->orientation?X[M+1]-X[M+1-J]:X[J]);
			  fflush(stdout);
			}
		      }
                    }

		    if(splitWT > 0.0 && extendWT > 0.0 && nalign->mapWT >= extendMinWT){
		      if(DEBUG>=2) assert(0.0 <= nalign->mapWT && nalign->mapWT <= 1.0);
		      if(DEBUG/* HERE HERE >=2 */) assert(nalign->noutliers >= 0 && nalign->maxoutlier >= 0.0 && nalign->maxoutlierLabels >= 0 &&
							  (nalign->noutliers <= 0 || nalign->maxoutlier > 0.0 || nalign->maxoutlierLabels > 0));

		      if(nalign->maxoutlier <= extendMaxOutlierKBsplit && nalign->maxoutlierLabels < extendMaxOutlierLabelsSplit){/* try to increase nalign->mapWT */
			if(extendWTdup || nanomap->pMapWT == NULL || nalign->mapWT > nanomap->origMapWT){
			  if(!extendWTdup){// NEW73
			    if(nanomap->pMapWT){
			      if(EXTSPLIT_TRACE  && newrmap->id == EXTSPLIT_NREFID){
				printf("\t mapid=%d(id=%lld): Restoring mapWT= %0.6f to %0.6f at %p\n", nanomap->mapid,nanomap->id, *nanomap->pMapWT, nanomap->origMapWT, nanomap->pMapWT);
				fflush(stdout);
			      }
			      *nanomap->pMapWT = nanomap->origMapWT;
			    }
			    nanomap->pMapWT = &nalign->mapWT;
			    nanomap->origMapWT = nalign->mapWT;
			  }
			  if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID /* && Gmap[nalign->mapid2]->id==MAP_TRACE */){
			    printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.6f -> %0.6f at %p: -extendWT %0.1f %0.3f %d %0.1f %0.3f %0.1f %d %0.3f %0.1f %d\n",
				   alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV,nalign->maxoutlier,nalign->maxoutlierLabels,
				   nalign->mapWT, max(nalign->mapWT,extendWT), &nalign->mapWT,
		                   extendLen,extendWT,extendFN,extendFNlen,extendMinWT,extendMaxOutlierKB,extendMaxOutlierLabels,extendMaxWT,extendMaxOutlierKBsplit,extendMaxOutlierLabelsSplit);
			    fflush(stdout);
			  }
			  nalign->mapWT = max(extendWT, nalign->mapWT);
			}
		      } else {
			nalign->mapWT = min(extendMaxWT, nalign->mapWT);
			if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
			  printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.6f -> %0.6f at %p: -extendWT %0.1f %0.3f %d %0.1f %0.3f %0.1f %d %0.3f %0.1f %d\n",
				 alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV,nalign->maxoutlier,nalign->maxoutlierLabels,
				 nalign->mapWT, min(nalign->mapWT,extendMaxWT), &nalign->mapWT,
		                 extendLen,extendWT,extendFN,extendFNlen,extendMinWT,extendMaxOutlierKB,extendMaxOutlierLabels,extendMaxWT,extendMaxOutlierKBsplit,extendMaxOutlierLabelsSplit);
			  fflush(stdout);
			}
		      }

		      if(DEBUG>=2) assert(0.0 <= nalign->mapWT && nalign->mapWT <= 1.0);
		    }

		    continue;// next alignment
		  }

		  if(extsplitOutlier > 0.0 && align->mapWT >= splitFiltMinWT){/* check if there is any internal outliers with left end L..R that can be treated like right endoutlier */
		    double Leftend = (align->orientation ? X[M+1] - X[M] : X[1]) * scale;

		    int t = 0;// HERE HERE t = extsplitOutlierAS
		    int IL = align->sites1[t], IR;
		    int KL = align->sitesK1[t], KR;
		    int JL = align->sites2[t], JR;
		    double YL = Yc(Y,IL,KL), YR;

		    for(; ++t < U; IL = IR, KL = KR, JL = JR, YL = YR){/* scan from left end in case multiple outliers have left end in L..R, so we pick the leftmost internal outlier */
		      IR = align->sites1[t];
		      KR = align->sitesK1[t];
		      JR = align->sites2[t];
		      YR = Yc(Y,IR,KR);
		      int D = EXTSPLIT_OUTLIER_RANGE ? max(0,min(JR-JL-1, IR-KR-IL - extendSplitFN)) : 0;// NEW360

		      /* check if interval (IL,KL,JL) to (IR,KR,JR) is an outlier with size at least extsplitOutlier kb */
		      if(EXTSPLIT_TRACE>=2 && newrmap->id == EXTSPLIT_NREFID && i==EXTSPLIT_I /* && Gmap[nalign->mapid2]->id==MAP_TRACE */){
			double delY = YR - YL;
			double delX = (align->orientation ? X[M+1-JL]-X[M+1-JR] : X[JR] - X[JL]) * scale;
			printf("\t alignid=%lu:refid=%d,id=%lld,or=%d:i=%d,t=%d,U=%d:IL=%d,KL=%d,JL=%d,IR=%d,KR=%d,JR=%d,D=%d:B=%d,B2=%d:L=%d,R=%d,outlier= %0.3f,iscore= %0.6f,outscore= %0.6f,AS=%d,LB=%0.3f,%0.3f\n",
			       alignid,refid,Gmap[align->mapid2]->id,align->orientation,i,t,U,IL,KL,JL,IR,KR,JR,D,B,B2,L,R,delX-delY,align->iscore[t],align->outscore[t],extsplitOutlierAS,LB,UB);
			fflush(stdout);
		      }

		      if(!(L-D <= IL && IL <= R))
			continue;

		      // HERE HERE if(DEBUG/* HERE >=2 */) assert(t-1 >= extsplitOutlierAS);
		      if(!(t /* WAS361 t-1 */ >= extsplitOutlierAS))
			continue;

		      double delY = YR - YL;
		      double delX = (align->orientation ? X[M+1-JL]-X[M+1-JR] : X[JR] - X[JL]) * scale;
		      if(DEBUG) assert(delX > 0.0);
		      double delta = delX - delY;
		      double adelta = fabs(delta);

		      if(!((adelta >= extsplitOutlier) || (B==KBend+EXTSPLIT_BALANCED && IR-KR-IL + JR-JL -2 >= extsplitOutlierLabels)) || 
			 !(align->iscore[t] > align->outscore[t] + (FLOAT)0.01 || (outlierExtend && (IL >= IR-KR || JL >= JR))))
			continue;// NOTE : align->outscore[t] corresponds to interval align->sites1[t-1 .. t]

		      if(DEBUG/* HERE HERE >=2 */) assert(align->noutliers > 0 && align->maxoutlier >= adelta - 1e-6);

		      if(!((EXTSPLIT_DELBIN && delta < 0.0 && B < KBend) ? (LB < delta && delta <= UB) : (LB <= adelta && adelta < UB)) && !(B==KBend+EXTSPLIT_BALANCED && adelta < extsplitOutlier))
			continue;

		      double QueryRightend = (align->orientation ? X[M+1-JL] : X[M+1] - X[JL]) * scale;
		      double QueryLeft = (align->orientation ? X[M+1] - X[M+1-JL] : X[JL]) * scale;
		      double RefRightend = Yc(Y,IL,KL);	

		      if(EXTSPLIT_TRACE/* HERE HERE >=2 */ && newrmap->id == EXTSPLIT_NREFID && i==EXTSPLIT_I /* && Gmap[nalign->mapid2]->id==MAP_TRACE */){
			printf("\t Y[max(i,IL-KL)]= %0.4f, RefRightend= %0.4f, QueryRightend= %0.4f, Rightend= %0.4f, QueryLeft= %0.4f, Leftend= %0.4f(extendSplitLen=%0.3f,extsplitOutlierLS=%0.3f)\n",
			       Y[max(i,IL-KL)],RefRightend,QueryRightend,Rightend,QueryLeft,Leftend,extendSplitLen,extsplitOutlierLS);
			fflush(stdout);
		      }

		      if(Y[max(i,IL-KL)] - RefRightend <= QueryRightend - Rightend - extendSplitLen && QueryLeft - Leftend >= extsplitOutlierLS){
			int U = /* WAS361 t-1 */ t;// local U !!!

			int Ashift = 0;
			if(Lend > 0){/* truncate alignment to not extend before label Y[Lend] */
			  while(Ashift < U && align->sites1[Ashift] - align->sitesK1[Ashift] < Lend)
			    Ashift++;
			  if(Ashift >= U){/* very rare */
			    miss1++;
			    continue;// next outlier
			  }
			}
			cnt1++;
			
			maxalignallocNULL(numaligns+1,alignment,numaligns,maxaligns,&alignment_blockid);
			size_t nalignid = numaligns;
			Calign *nalign = alignment[nalignid] = new Calign[1];
			copy(nalign,align, 1, 1);// copy : automatically resets Malign
			if(DEBUG) assert(nalign->Malign == NULL);// HERE : check to make sure this right endoutlier does not extend beyond right end of original contig ?
			if(DEBUG) assert(nalign->maxoutlier >= extsplitOutlier || (B==KBend+EXTSPLIT_BALANCED && IR-KR-IL + JR-JL -2 >= extsplitOutlierLabels));

			// NOTE : The same alignment could be part of multiple splits. Just mark it for deletion here, so it can be reused, then delete it later
			align->chimpair = 1;// HERE HERE : check to make sure this right endoutlier does not extend beyond right end of original contig
			//		    Lalignment[alignid] = NULL;
			numalign_end[numrefmaps] = ++numaligns;

			nalign->mapid1 = numrefmaps;
			nalign->Rend = -1;// NO right endoutlier
			nalign->numpairs = U;

			if(Ashift > 0){
			  nalign->numpairs = U -= Ashift;
			  nalign->Lend = -1;// NOT endoutlier any more since split reference was truncated on left side !
			  for(int k = 0; k < U; k++){
			    nalign->sites1[k] = nalign->sites1[k + Ashift];
			    nalign->sitesK1[k] = nalign->sitesK1[k + Ashift];
			    nalign->sites2[k] = nalign->sites2[k + Ashift];
			    nalign->iscore[k+1] = nalign->iscore[k+1 + Ashift];
			    nalign->outscore[k+1] = nalign->outscore[k+1 + Ashift];
			  }
			}

			int shift = max(0, Lend - 1);
			if(shift > 0 || DEBUG>=2){
			  for(int k = 0; k < U; k++){
			    int I = nalign->sites1[k];
			    int K = nalign->sitesK1[k];
			    if(DEBUG>=2) assert(I-K >= Lend);
			    nalign->sites1[k] -= shift;
			    if(DEBUG>=2 && !(nalign->sites1[k] <= newrmap->numsite[0])){
#if CALIGN_END==0
			      int Lij1 = max(0, align->LijY - shift);
			      int Rij1 = min(newrmap->numsite[0]+1, align->RijY - shift);
#else
			      int Lij1 = max(0, align->Lij1 - shift);
			      int Rij1 = min(newrmap->numsite[0]+1, align->Rij1 - shift);
#endif
			      printf("alignid=%lu,nrefid=%lld:mapid=%lld,or=%d,N=%d,M=%d,Y[%d,%d]=%0.3f,%0.3f,JR=%d,L=%d,i=%d,R=%d,Lend=%d,Rend=%d:U=%d,Lij1=%d,Rij1=%d,I=%d..%d,K=%d..%d,J=%d..%d: right outlier (Xend=%0.3f - %0.3f,Yend=%0.3f),cnt1=%d,miss1=%d,wt=%0.4f->%0.4f:outlier= %0.3f kb, t=%d,I=%d..%d,K=%d..%d,J=%d..%d\n",
				 alignid,newrmap->id,Gmap[nalign->mapid2]->id,nalign->orientation,newrmap->numsite[0],Gmap[nalign->mapid2]->numsite[0],IL-KL,IL,Y[IL-KL],Y[IL],JL,L,i,R,nalign->Lend,nalign->Rend,U,
				 Lij1,Rij1,nalign->sites1[0],nalign->sites1[U-1],nalign->sitesK1[0],nalign->sitesK1[U-1],nalign->sites2[0],nalign->sites2[U-1],
				     QueryRightend,Rightend,Y[max(i,IL-KL)]-RefRightend,cnt1,miss1,align->mapWT,nalign->mapWT,delX-delY,t,IL,IR,KL,KR,JL,JR);
			      printf("\t orig Lend=%d,Ashift=%d, shift=%d, align->Lij1= %d, align->Rij1= %d, align->numpairs=%d,align->sites1[0..%d]=%d..%d,align->sitesK1[0]=%d\n",
				     Lend,Ashift,shift,align->Lij1,align->Rij1,align->numpairs,align->numpairs-1,align->sites1[0],align->sites1[align->numpairs-1],align->sitesK1[0]);
			      printf("\t k=%d,U=%d:nalign->sites1[k]= %d, newrmap->numsite[0]= %d\n",k,U,nalign->sites1[k],newrmap->numsite[0]);
			      fflush(stdout);
			      assert(nalign->sites1[k] <= newrmap->numsite[0]);
			    }
			  }
			}

#if CALIGN_END==0
			if(Ashift > 0){
			  int IL = nalign->sites1[0];
			  int KL = nalign->sitesK1[0];
			  int JL = nalign->sites2[0];
			  nalign->LijY = nalign->Lij1 = LijY(newY,X,IL-KL,JL,newN,M,nalign->orientation,scale);
			  nalign->LijX = nalign->Lij2 = LijX(newY,X,IL-KL,JL,newN,M,nalign->orientation,scale);

			  FLOAT xL = (nalign->orientation ? X[M+1] - X[M+1-JL] : X[JL]) * scale;
			  FLOAT yL = Yc(newY,IL,KL);
			  nalign->iscore[0] = nalign->outscore[0] = Send(min(xL,yL),JL+1-max(1,nalign->LijX),IL-KL+1-max(1,nalign->LijY),IL-KL,newrmap->mapid,0);
			} else {
			  nalign->LijY = max(0, align->LijY - shift);
			  nalign->Lij1 = (nalign->Lend >= -1) ? nalign->LijY : nalign->sites1[0] - nalign->sitesK1[0];
			}

			int IR = nalign->sites1[U-1];
			int KR = nalign->sitesK1[U-1];
			int JR = nalign->sites2[U-1];
			nalign->Rij1 = nalign->RijY = RijY(newY,X,IR,JR,newN,M,nalign->orientation,scale);// min(newrmap->numsite[0]+1, align->RijY - shift);
			nalign->Rij2 = nalign->RijX;// No right endoutlier

			FLOAT xR = (nalign->orientation ? X[M+1-JR] : X[M+1]-X[JR]) * scale;
			FLOAT yR = Yc(newY,IR,KR);
			nalign->iscore[U] = nalign->outscore[U] = Send(min(xR,yR),min(M,nalign->RijX)+1-JR,min(newN,nalign->RijY)+1-IR,min(N,nalign->RijY),newrmap->mapid,0);
#else
			/* NOTE : nalign->Rij1 should be recomputed for non-endoutlier and is not related to align->Rij1 : The final value is almost alwys newrmap->numsite[0]+1 either way */
			nalign->Lij1 = max(0, align->Lij1 - shift);
			nalign->Rij1 = min(newrmap->numsite[0]+1, align->Rij1 - shift);
#endif

			if((EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID && i==EXTSPLIT_I /* && Gmap[nalign->mapid2]->id==MAP_TRACE */) ||
			   (DEBUG && !(0 <= nalign->Lij1 && nalign->Lij1 <= nalign->sites1[0] - nalign->sitesK1[0])) ||
			   (DEBUG && !(nalign->sites1[U-1] <= nalign->Rij1 && nalign->Rij1 <= newrmap->numsite[0]+1))){
			  printf("alignid=%lu,nrefid=%lld:map id=%lld,or=%d,pairs=%d,score=%0.6f,logPV=%0.2f:N=%d,M=%d,Y[%d,%d]=%0.3f,%0.3f,JR=%d,L=%d,i=%d,R=%d,Lend=%d,Rend=%d:U=%d,Lij1=%d,Rij1=%d,I=%d..%d,K=%d..%d,J=%d..%d:B=%d:\n\t right outlier (Xend=%0.3f - %0.3f,Yend=%0.3f),cnt1=%d,miss1=%d,wt=%0.4f->%0.4f:outlier= %0.3f kb, t=%d,I=%d..%d,K=%d..%d,J=%d..%d\n",
				 alignid,newrmap->id,Gmap[nalign->mapid2]->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV,
				 newrmap->numsite[0],Gmap[nalign->mapid2]->numsite[0],IL-KL,IL,Y[IL-KL],Y[IL],JL,L,i,R,nalign->Lend,nalign->Rend,U,
				 nalign->Lij1,nalign->Rij1,nalign->sites1[0],nalign->sites1[U-1],nalign->sitesK1[0],nalign->sitesK1[U-1],nalign->sites2[0],nalign->sites2[U-1],B,
				     QueryRightend,Rightend,Y[max(i,IL-KL)]-RefRightend,cnt1,miss1,align->mapWT,nalign->mapWT,delX-delY,t,IL,IR,KL,KR,JL,JR);
			  printf("\t orig Lend=%d,Ashift=%d, shift=%d, align->Lij1= %d, align->Rij1= %d, align->numpairs=%d,align->sites1[0..%d]=%d..%d,align->sitesK1[0]=%d\n",
				 Lend,Ashift,shift,align->Lij1,align->Rij1,align->numpairs,align->numpairs-1,align->sites1[0],align->sites1[align->numpairs-1],align->sitesK1[0]);
			  fflush(stdout);
			}
			if(DEBUG>=1+RELEASE) assert(0 <= nalign->Lij1 && nalign->Lij1 <= nalign->sites1[0] - nalign->sitesK1[0]);
			if(DEBUG>=1+RELEASE) assert(nalign->sites1[U-1] <= nalign->Rij1 && nalign->Rij1 <= newrmap->numsite[0]+1);
			if(DEBUG>=2) assert(nalign->sites1[U-1] <= newrmap->numsite[0]);
			if(DEBUG>=2) assert(nalign->sites1[0]-nalign->sitesK1[0] >= 1);
			if(DEBUG>=2) assert(nalign->sites2[U-1] <= Gmap[nalign->mapid2]->numsite[0]);
			if(DEBUG>=2) assert(nalign->sites2[0] >= 1);

			nalign->maxoutlier = 0.0;
			nalign->noutliers = 0;
			nalign->maxoutlierLabels = 0;
			if(extendMaxOutlierKBsplit < 998.0){// update nalign->maxoutlier : will not include outlier we split on 
			  int I,lastI = nalign->sites1[0];
			  int K,lastK = nalign->sitesK1[0];
			  int J,lastJ = nalign->sites2[0];
			  for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
			    I = nalign->sites1[t];
			    K = nalign->sitesK1[t];
			    J = nalign->sites2[t];
			    if(nalign->outscore[t] + (FLOAT)0.01 < nalign->iscore[t]){
			      nalign->noutliers++;
			      FLOAT deltaY = Yc(newY,I,K) - Yc(newY,lastI,lastK);
			      FLOAT deltaX = (nalign->orientation ? X[M+1-lastJ] - X[M+1-J] : X[J] - X[lastJ]) * scale;
			      if(DEBUG) assert(deltaX > 0.0);			  
			      FLOAT delta = fabs(deltaY-deltaX);
			      nalign->maxoutlier = max(delta,nalign->maxoutlier);
			      nalign->maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, nalign->maxoutlierLabels);// NEW302
			      if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID /* && delta > nalign->maxoutlier */){
				printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f:t=%d(delY=%0.3f,delX=%0.3f,I=%d->%d,K=%d->%d,J=%d->%d),iscore=%0.4f,%0.4f,max=%0.3f,%d\n",
				       alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, t,
				       deltaY,deltaX,lastI,I,lastK,K,lastJ,J,nalign->iscore[t],nalign->outscore[t],nalign->maxoutlier,nalign->maxoutlierLabels);
				printf("\t\t Yik=%0.4f,%0.4f,Xj=%0.4f,%0.4f\n",
				       Yc(newY,lastI,lastK),Yc(newY,I,K),nalign->orientation?X[M+1]-X[M+1-lastJ]:X[lastJ],nalign->orientation?X[M+1]-X[M+1-J]:X[J]);
				fflush(stdout);
			      }
			    } else if(EXTSPLIT_TRACE>=2 && newrmap->id == EXTSPLIT_NREFID){
			      FLOAT deltaY = Yc(newY,I,K) - Yc(newY,lastI,lastK);
			      FLOAT deltaX = (nalign->orientation ? X[M+1-lastJ] - X[M+1-J] : X[J] - X[lastJ]) * scale;

			      printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f:t=%d(delY=%0.3f,delX=%0.3f,I=%d->%d,K=%d->%d,J=%d->%d),iscore=%0.4f,%0.4f,max=%0.3f,%d\n",
				     alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, t,
				     deltaY,deltaX,lastI,I,lastK,K,lastJ,J,nalign->iscore[t],nalign->outscore[t],nalign->maxoutlier,nalign->maxoutlierLabels);
			      printf("\t\t Yik=%0.4f,%0.4f,Xj=%0.4f,%0.4f\n",
				     Yc(newY,lastI,lastK),Yc(newY,I,K),nalign->orientation?X[M+1]-X[M+1-lastJ]:X[lastJ],nalign->orientation?X[M+1]-X[M+1-J]:X[J]);
			      fflush(stdout);
			    }
			  }
			}

			if(splitWT > 0.0 && extendWT > 0.0 && nalign->mapWT >= extendMinWT){
			  if(DEBUG>=2) assert(0.0 <= nalign->mapWT && nalign->mapWT <= 1.0);
			  if(DEBUG/* HERE HERE >=2 */) assert(nalign->noutliers >= 0 && nalign->maxoutlier >= 0.0 && nalign->maxoutlierLabels >= 0 &&
							      (nalign->noutliers <= 0 || nalign->maxoutlier > 0.0 || nalign->maxoutlierLabels > 0));

			  if(nalign->maxoutlier <= extendMaxOutlierKBsplit && nalign->maxoutlierLabels < extendMaxOutlierLabelsSplit){/* try to increase nalign->mapWT */
			    if(extendWTdup || nanomap->pMapWT == NULL || nalign->mapWT > nanomap->origMapWT){
			      if(!extendWTdup){// NEW73
				if(nanomap->pMapWT){
				  if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
				    printf("\t alignid=%lu->%lu:mapid=%d(id=%lld): Restoring mapWT= %0.6f to %0.6f at %p\n", 
					   alignid,nalignid,nanomap->mapid,nanomap->id, *nanomap->pMapWT, nanomap->origMapWT, nanomap->pMapWT);
				    fflush(stdout);
				  }
				  *nanomap->pMapWT = nanomap->origMapWT;
				}
				nanomap->pMapWT = &nalign->mapWT;
				nanomap->origMapWT = nalign->mapWT;
			      }
			      if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
				printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.6f -> %0.6f at %p: -extendWT %0.1f %0.3f %d %0.1f %0.3f %0.1f %d %0.3f %0.1f %d\n",
				       alignid,nalignid,numrefmaps,newrmap->id,mapid,nanomap->id,nalign->orientation,nalign->numpairs,nalign->score,nalign->logPV, nalign->maxoutlier,nalign->maxoutlierLabels,
				       nalign->mapWT, max(nalign->mapWT,extendWT), &nalign->mapWT,
				       extendLen,extendWT,extendFN,extendFNlen,extendMinWT,extendMaxOutlierKB,extendMaxOutlierLabels,extendMaxWT,extendMaxOutlierKBsplit,extendMaxOutlierLabelsSplit);
				fflush(stdout);
			      }
			      nalign->mapWT = max(extendWT, nalign->mapWT);
			    }
			  } else {
			    if(EXTSPLIT_TRACE && newrmap->id == EXTSPLIT_NREFID){
			      printf("alignid=%lu->%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.4f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.6f -> %0.6f at %p: -extendWT %0.1f %0.3f %d %0.1f %0.3f %0.1f %d %0.3f %0.1f %d\n",
				     alignid,nalignid,numrefmaps,newrmap->id,mapid, nanomap->id, nalign->orientation, nalign->numpairs, nalign->score,nalign->logPV,nalign->maxoutlier,nalign->maxoutlierLabels,
				     nalign->mapWT, min(nalign->mapWT,extendMaxWT), &nalign->mapWT,
				     extendLen,extendWT,extendFN,extendFNlen,extendMinWT,extendMaxOutlierKB,extendMaxOutlierLabels,extendMaxWT,extendMaxOutlierKBsplit,extendMaxOutlierLabelsSplit);
			      fflush(stdout);
			    }
			    nalign->mapWT = min(extendMaxWT, nalign->mapWT);
			  }

			  if(DEBUG>=2) assert(0.0 <= nalign->mapWT && nalign->mapWT <= 1.0);
			}

			break;// found internal outlier
		      } 
		    } // for(;++t < U; IL = IR, KL = KR, JL = JR)

		    if(t < U)// used internal outlier
		      continue;// next alignment
		  }// if(extsplitOutlier > 0.0 && align->mapWT >= splitFiltMinWT)

		  int I = align->sites1[0];
		  int K = align->sitesK1[0];

		  if(extsplitNE && align->Rend >= -1 && IR <= R && (align->Lend >= -1 || (Lend <= 0 && I-K <= extendSplitSpacing)) /* no endoutliers or only left endoutlier near left end of refid */
		     && (Lend <= 0 || IR - KR >= Lend)){
		    // HERE : these maps are not needed if the left end is truncated, unless the split right end falls within EndLen of the left end of contig refid
		    int Ashift = 0;
		    if(Lend > 0){ /* truncate alignment to not extend before label Y[Lend] */
		      while(Ashift < U && align->sites1[Ashift] - align->sitesK1[Ashift] < Lend)
			Ashift++;
		      if(Ashift >= U)
			continue;
		    }

		    maxalignallocNULL(numaligns+1,alignment,numaligns,maxaligns,&alignment_blockid);
		    Calign *nalign = alignment[numaligns] = new Calign[1];
		    copy(nalign,align,1, 1);// copy : automatically resets Malign
		    if(DEBUG) assert(nalign->Malign == NULL);

		    numalign_end[numrefmaps] = ++numaligns;
		    nalign->mapid1 = numrefmaps;

		    if(Ashift > 0){
		      nalign->numpairs = U -= Ashift;
		      nalign->Lend = -1;// NEW301 : NOT endoutlier any more since split reference was truncated on left side !
		      for(int t = 0; t < U; t++){
			nalign->sites1[t] = nalign->sites1[t + Ashift];
			nalign->sitesK1[t] = nalign->sitesK1[t + Ashift];
			nalign->sites2[t] = nalign->sites2[t + Ashift];
			nalign->iscore[t+1] = nalign->iscore[t+1 + Ashift];
			nalign->outscore[t+1] = nalign->outscore[t+1 + Ashift];
		      }
		    }

		    int shift = max(0, Lend - 1);
		    if(shift > 0 || DEBUG>=2){
		      for(int t = 0; t < U; t++){
			int i = nalign->sites1[t];
			int k = nalign->sitesK1[t];
			if(DEBUG>=2 && !(i-k >= Lend)){
			  printf("alignid=%lu(%lu..%lu/%lu):mapid=%d(id=%lld),or=%d:U=%d,Ashift=%d,Lend=%d,L=%d,R=%d,N=%d,I=%d,K=%d,IR=%d,KR=%d:t=%d,i=%d,k=%d\n",
				 alignid,start,end-1,align_end,align->mapid2,Gmap[align->mapid2]->id,align->orientation,U,Ashift,Lend,L,R,N,I,K,IR,KR,t,i,k);
			  fflush(stdout);
			  assert(i-k >= Lend);
			}
			nalign->sites1[t] -= shift;
			if(DEBUG>=2) assert(nalign->sites1[t] <= newrmap->numsite[0]);
		      }
		    }

#if CALIGN_END==0
		    int IL = nalign->sites1[0];
		    int KL = nalign->sitesK1[0];
		    int JL = nalign->sites2[0];
		    nalign->LijY = LijY(newY,X,IL-KL,JL,newN,M,nalign->orientation,scale);
		    nalign->Lij1 = (nalign->Lend >= -1) ? nalign->LijY : IL-KL;
		    nalign->LijX = LijX(newY,X,IL-KL,JR,newN,M,nalign->orientation,scale);
		    nalign->Lij2 = (nalign->Lend >= -1) ? nalign->LijX : JL;
                    if(nalign->Lend >= -1){
		      FLOAT xL = (nalign->orientation ? X[M+1] - X[M+1-JL] : X[JL]) * scale;
		      FLOAT yL = Yc(newY,IL,KL);
		      nalign->iscore[0] = nalign->outscore[0] = Send(min(xL,yL),JL+1-max(1,nalign->LijX),IL-KL+1-max(1,nalign->LijY),IL-KL,newrmap->mapid,0);
		    } /* else
			 nalign->iscore[0] = nalign->outscore[0] = ChimScore + Sm(JL,IL,KL,newY); */

		    int IR = nalign->sites1[U-1];
		    int KR = nalign->sitesK1[U-1];
		    int JR = nalign->sites2[U-1];
		    nalign->Rij1 = nalign->RijY = min(newrmap->numsite[0]+1, align->RijY - shift);
		    if(DEBUG/* HERE HERE >=2 */) assert(nalign->sites2[U-1] <= M);
		    nalign->Rij2 = nalign->RijX = RijX(newY,X,IR,JR,newN,M,nalign->orientation,scale);
		    FLOAT xR = (nalign->orientation ? X[M+1-JR] : X[M+1]-X[JR]) * scale;
		    FLOAT yR = Yc(newY,IR,KR);
		    nalign->iscore[U] = nalign->outscore[U] = Send(min(xR,yR),min(M,nalign->RijX)+1-JR,min(newN,nalign->RijY)+1-IR,min(N,nalign->RijY),newrmap->mapid,0);
#else
		    // NOTE : non-endoutlier Lij1 etc need to be recomputed for max accuracy
		    // HERE HERE : in rare cases (molecule extending beyond both ends of truncated Y) the Lij2 etc also need to be recomputed
		    nalign->Lij1 = max(0, align->Lij1 - shift);// NEW48
		    nalign->Rij1 = min(newrmap->numsite[0]+1, align->Rij1 - shift);// NEW48
#endif
		    if(DEBUG) assert(0 <= nalign->Lij1 && nalign->Lij1 <= nalign->sites1[0] - nalign->sitesK1[0]);
		    if(DEBUG) assert(nalign->sites1[U-1] <= nalign->Rij1 && nalign->Rij1 <= newrmap->numsite[0]+1);

		    cnt++;

		    if(VERB>=2 && newrmap->id == 48000002LL /* && Gmap[nalign->mapid2]->id==MAP_TRACE*/){
		      printf("nrefid=%lld,mapid=%lld,or=%d,N=%d,M=%d,IR=%d,KR=%d,I=%d,K=%d,Lend=%d,L=%d,i=%d,R=%d,Lend=%d,Rend=%d:U=%d,Lij1=%d,Rij1=%d,I=%d..%d,K=%d..%d,J=%d..%d: NOT right endoutlier(cnt=%d)\n",
			     newrmap->id,Gmap[nalign->mapid2]->id,nalign->orientation,newrmap->numsite[0],Gmap[nalign->mapid2]->numsite[0],IR,KR,I,K,Lend,L,i,R,nalign->Lend,nalign->Rend,U,
			     nalign->Lij1,nalign->Rij1,
			     nalign->sites1[0],nalign->sites1[U-1],nalign->sitesK1[0],nalign->sitesK1[U-1],nalign->sites2[0],nalign->sites2[U-1],cnt);
		      fflush(stdout);
		    }
		    if(DEBUG>=2) assert(nalign->sites1[U-1] <= newrmap->numsite[0]);
		    if(DEBUG>=2) assert(nalign->sites1[0]-nalign->sitesK1[0] >= 1);
		    if(DEBUG>=2) assert(nalign->sites2[U-1] <= Gmap[nalign->mapid2]->numsite[0]);
		    if(DEBUG>=2) assert(nalign->sites2[0] >= 1);

		    continue;
		  }
		}

		if(VERB/* HERE >=2 */){
		  if(extsplitOutlier > 0.0)
		    printf("Splitting off refid=%d(id=%lld,Len=%0.3f,N=%d,alignids=%lu..%lu/%lu) left region Y[%d..%d,%d,%d]=%0.3f..%0.3f,%0.3f,%0.3f,cov[%d]=%0.2f,B=%d with %d+%d right (end)outliers(orig=%d,wt=%0.2f) + %d other alignments into refid=%d(id=%lld,Len=%0.3f,N=%d,alignids=%lu..%lu)\n",
			   refid,rmap->id,rmap->site[0][N+1],N,start,end-1,align_end,Lend,L,i,R,leftend,Y[L],Y[i],rightend,i,coverage[i],B,cnt1,miss1,
			   endoutlierRim[B][i],endoutlierRm[B][i],cnt,numrefmaps, newrmap->id, newrmap->site[0][newrmap->numsite[0]+1],
			   newrmap->numsite[0], numalign_start[numrefmaps], numalign_end[numrefmaps]-1);
		  else
		    printf("Splitting off refid=%d(id=%lld,Len=%0.3f,N=%d,alignids=%lu..%lu/%lu) left region Y[%d..%d,%d,%d]=%0.3f..%0.3f,%0.3f,%0.3f,cov[%d]=%0.2f with %d+%d right endoutliers(orig=%d,wt=%0.2f) + %d other alignments into refid=%d(id=%lld,Len=%0.3f,N=%d,alignids=%lu..%lu)\n",
			   refid,rmap->id,rmap->site[0][N+1],N,start,end-1,align_end,Lend,L,i,R,leftend,Y[L],Y[i],rightend,i,coverage[i],cnt1,miss1,
			   endoutlierRi[i],endoutlierR[i],cnt,numrefmaps, newrmap->id, newrmap->site[0][newrmap->numsite[0]+1],
			   newrmap->numsite[0], numalign_start[numrefmaps], numalign_end[numrefmaps]-1);
		  fflush(stdout);
		}

		if(DEBUG>=1+RELEASE) assert(cnt1 + miss1 >= floor(endoutlierRm[B][i] + 0.999));
		if(DEBUG>=1+RELEASE) assert(cnt1 + miss1 >= endoutlierRim[B][i]);

		//		assert(cnt1 + miss1 <= endoutlierR[i] + 0.01);// only valid if wt == 1.0

		if(DEBUG) assert(!(EXTSPLIT_FORK && extendSplit && Refine && !(MapScale && giter==0 && !origMapScale && !pSNRtotLL) && child_pid==NULL && numchild==0));// cannot be a child job

		numY = ++numrefmaps;
		numalign_start[numrefmaps] = numalign_end[numrefmaps] = numaligns;
	      }
	    } // if(endoutlierRm[B][i] >= threshold ... )
	   } // for(int B = EXTSPLIT_DELBIN ? -KBend : 0; B <= KBend + (EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000 ? 1 : 0); B++)
	  } // for(int i = 1; i <= N; i++)

	  if(VERB){/* show distribution of Splits by Bin B */
	    for(int B = (EXTSPLIT_DELBIN ? -KBend : 0); B <= KBend + (EXTSPLIT_BALANCED && extsplitOutlierLabels < 1000 ? 1 : 0); B++){
	      int B1 = (B >= 0) ? B : -1-B;
	      int B2 = min(KBcnt+1, B1+2);/* outlier size range is extsplitOutlierKB[B1 .. B2]*sign(B) (IF B==KBend+1, then size range is < extsplitOutlier && misaligned labels >= extsplitOutlierLabels) */
	      double LB = (B<0) ? -extsplitOutlierKB[B2] : extsplitOutlierKB[B1];
	      double UB = (B<0) ? -extsplitOutlierKB[B1] : extsplitOutlierKB[B2];
	      
	      if(B==KBend+1)
		printf("B=%d:LB=%0.2f,UB=%0.2f,mis=%d: Splits= %d\n",B, -extsplitOutlier,extsplitOutlier,extsplitOutlierLabels, SplitBinCnt[B]);
	      else
		printf("B=%d:LB=%0.2f,UB=%0.2f: Splits= %d\n", B, LB, UB, SplitBinCnt[B]);
	    }
	    fflush(stdout);
	  }

	  if(!keepsplitmaps){ /* remove cloned endoutlier alignments (with chimpair==1) from Lalignment[align_start .. align_end-1] */
	    double FilterLogPV = 0.0;// WAS143 min(LogPvThreshold2,LogPvThresholdTE) - 1.0;

	    size_t end = align_start;
	    for(size_t alignid = align_start; alignid < align_end; alignid++){
	      Calign *align = Lalignment[alignid];
	      if(align->chimpair){
		if(FilterXmapSplit){
		  if(TRACE>=2 && YYmap[align->mapid1]->id == REF_TRACE && XXmap[align->mapid2]->id == MAP_TRACE){
		    printf("\t refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.6f,logPV=%0.2f -> %0.2f : suppressing due to use by split contig (-keepsplitmaps %d)\n",
			   align->mapid1,YYmap[align->mapid1]->id,align->mapid2,XXmap[align->mapid2]->id,align->orientation,align->numpairs,align->score,align->logPV,FilterLogPV,keepsplitmaps);
		    fflush(stdout);
		  }
		  align->logPV = FilterLogPV;
		}
		continue;
	      }
	      Lalignment[end++] = align;
	    }

	    if(VERB/* HERE >=2 */ && align_end > end){
	      printf("refid=%d:alignid= %lu .. %lu -> %lu\n",refid,align_start,align_end-1,end-1);
	      fflush(stdout);
	    }
	    align_end = end;
	  }
	} // if (extendSplit)

	if(EXTENDWT_DELAY && extendLen > 0.0 && extendWT > 0.0 && extendWTend && refid < orignumrefmaps){/* applies -extendWT to extensions even if -extsplit does NOT apply ! */
	  Cmap *rmap = refmap[refid];
	  
	  int Lwcnt = 0, Rwcnt = 0, Lrcnt = 0, Rrcnt = 0;
	  double LwcntWT = 0.0, RwcntWT = 0.0, LrcntWT = 0.0, RrcntWT = 0.0;

	  for(size_t alignid = align_start; alignid < align_end; alignid++){
	    Calign *align = Lalignment[alignid];
	    if(DEBUG>=2) assert(align && align->mapid1 == refid);
	    align->chimpair = 0;// this flag will be used to mark alignments with endoutliers that have been used in 1 or more splits and will be deleted from mail extension alignment
	    int mapid = align->mapid2;
	    if(DEBUG>=2) assert(!Gmap[mapid]->origmap);

	    if(DEBUG>=2) assert(0.0 <= align->mapWT && align->mapWT <= 1.0);

	    //	    align->mapWT = 1.0;// remove after debugging why cnt1 + miss1 < floor(endoutlierL[i] + 0.999)

	    double wt = align->mapWT;// weight of current alignment (1 unless -BestRefWT was used now or to generate BNX input)
	    
	    Cmap *nanomap = Gmap[mapid];
	    int M = nanomap->numsite[0];
	    double scale = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;	    
	    FLOAT *X = nanomap->site[0];

	    int I = align->sites1[0];
	    int K = align->sitesK1[0];
	    int J = align->sites2[0];
	    int U = align->numpairs;
	    int RI = align->sites1[U-1];
	    int RK = align->sitesK1[U-1];
	    int RJ = align->sites2[U-1];
	    
	    if(DEBUG/* HERE HERE >=2 */) assert(align->noutliers >= 0 && align->maxoutlier >= 0.0 && align->maxoutlierLabels >= 0 &&
						(align->noutliers <= 0 || align->maxoutlier > 0.0 || align->maxoutlierLabels > 0));

	    if((extendWT > wt || extendMaxWT < wt) && wt >= extendMinWT){
	      double leftlenX = scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]);/* unaligned left end length of X */
	      double rightlenX = scale * (align->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]);/* unaligned right end length of X */

#if CALIGN_END==0
	      double leftend = (Y[I-K] < leftlenX) ? 
		((align->Lend > -2 || Y[I-K] <= extendFNlen || I-K-1 + J-align->LijX <= extendFN) ? Yc(Y,I,K) - scale*(align->orientation ? X[M]-X[M+1-J] : X[J]-X[1]) : Yc(Y,I,K)) :
		((align->Lend > -2 || leftlenX <= extendFNlen || I-K-align->LijY + J-1 <= extendFN) ? Yc(Y,I,K) - scale*(align->orientation ? X[M]-X[M+1-J] : X[J]-X[1]) : Yc(Y,I,K));
	      double rightend = (Y[N+1]-Y[RI] < rightlenX) ?
	        ((align->Rend > -2 || Y[N+1] - Y[RI] <= extendLen || N-RI + align->RijX-RJ/*NEW280*/ <= extendFN) ?  Yc(Y,RI,RK) + scale*(align->orientation ? X[M+1-RJ]-X[1] : X[M] - X[RJ]) : Yc(Y,RI,RK)) :
	        ((align->Rend > -2 || rightlenX <= extendLen || align->RijY-RI/*NEW280*/ + M-RJ <= extendFN) ?  Yc(Y,RI,RK) + scale*(align->orientation ? X[M+1-RJ]-X[1] : X[M] - X[RJ]) : Yc(Y,RI,RK));
#else // NOT quite correct : only misaligned labels on Y[] or X[] are counted (whichever ends first)
	      double leftend = (Y[I-K] < leftlenX) ? 
		((align->Lend > -2 || Y[I-K] <= extendFNlen || I-K-1 <= extendFN) ? Yc(Y,I,K) - scale*(align->orientation ? X[M]-X[M+1-J] : X[J]-X[1]) : Yc(Y,I,K)) :
		((align->Lend > -2 || leftlenX <= extendFNlen || J-1 <= extendFN) ? Yc(Y,I,K) - scale*(align->orientation ? X[M]-X[M+1-J] : X[J]-X[1]) : Yc(Y,I,K));
	      double rightend = (Y[N+1]-Y[RI] < rightlenX) ?
	        ((align->Rend > -2 || Y[N+1] - Y[RI] <= extendLen || N-RI <= extendFN) ?  Yc(Y,RI,RK) + scale*(align->orientation ? X[M+1-RJ]-X[1] : X[M] - X[RJ]) : Yc(Y,RI,RK)) :
	        ((align->Rend > -2 || rightlenX <= extendLen || M-RJ <= extendFN) ?  Yc(Y,RI,RK) + scale*(align->orientation ? X[M+1-RJ]-X[1] : X[M] - X[RJ]) : Yc(Y,RI,RK));
#endif

	      int maxoutlierLoc = -1;
	      if(VERB>=2 && !(align->maxoutlier <= extendMaxOutlierKB && align->maxoutlierLabels < extendMaxOutlierLabels)){
		FLOAT maxoutlier = 0.0;
		int maxoutlierLabels = 0;

		/* locate max outlier */
		int U = align->numpairs;
		int I,lastI = align->sites1[0];
		int K,lastK = align->sitesK1[0];
		int J,lastJ = align->sites2[0];
		for(int t = 1; t < U; lastI = I, lastK = K, lastJ = J, t++){
		  I = align->sites1[t];
		  K = align->sitesK1[t];
		  J = align->sites2[t];
		  if(align->outscore[t] + (FLOAT)0.01 < align->iscore[t]){
		    align->noutliers++;
		    FLOAT deltaY = Yc(Y,I,K) - Yc(Y,lastI,lastK);
		    FLOAT deltaX = (align->orientation ? X[M+1-lastJ] - X[M+1-J] : X[J] - X[lastJ]) * scale;
		    if(DEBUG) assert(deltaX > 0.0);			  
		    FLOAT delta = fabs(deltaY-deltaX);
		    if(delta > maxoutlier){
		      maxoutlier = delta;
		      maxoutlierLoc = t;
		    }
		    maxoutlierLabels = max(I-K-lastI + J-lastJ - 2, maxoutlierLabels);// NEW302
		  }
		}
	      }

	      if((leftend < -extendLen && !(rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT))) || 
		 (rightend > Y[N+1] + extendLen && !(rmap->Mask[0] && (rmap->Mask[0][N+1] & END_NOEXT)))){
		if(DEBUG/* HERE HERE >=2 */) assert(align->noutliers >= 0 && align->maxoutlier >= 0.0 && align->maxoutlierLabels >= 0 &&
						    (align->noutliers <= 0 || align->maxoutlier > 0.0 || align->maxoutlierLabels > 0));

		if(align->maxoutlier <= extendMaxOutlierKB && align->maxoutlierLabels < extendMaxOutlierLabels){// try to increase align->mapWT 
		  if(extendWTdup || nanomap->pMapWT == NULL || align->mapWT > nanomap->origMapWT){
		    if(!extendWTdup){// NEW73
		      if(nanomap->pMapWT){
			if(extendWT > nanomap->origMapWT + 1e-6){
			  if(leftend < -extendLen && !(rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT))){
			    Lwcnt--;
			    LwcntWT -= nanomap->origMapWT;
			  } else {
			    Rwcnt--;
			    RwcntWT -= nanomap->origMapWT;
			  }
			}
			if((TRACE>=2 && rmap->id == REF_TRACE && XXmap[align->mapid2]->id == MAP_TRACE) ||
			   (EXTSPLIT_TRACE/* HERE HERE >=2 */ && rmap->id == EXTSPLIT_NREFID /* && XXmap[align->mapid2]->id == MAP_TRACE */)){
			  printf("\t mapid=%d(id=%lld): Restoring mapWT= %0.6f to %0.6f at %p\n", nanomap->mapid,nanomap->id, *nanomap->pMapWT, nanomap->origMapWT, nanomap->pMapWT);
			  fflush(stdout);
			}
			*nanomap->pMapWT = nanomap->origMapWT;
		      }
		      nanomap->pMapWT = &align->mapWT;
		      nanomap->origMapWT = align->mapWT;
		    }
		    if(extendWT > align->mapWT + 1e-6){
		      if(leftend < -extendLen && !(rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT))){
			Lwcnt++;
			LwcntWT += wt;
		      } else {
			Rwcnt++;
			RwcntWT += wt;
		      }
		    }
		    if((TRACE>=2 && rmap->id == REF_TRACE && XXmap[align->mapid2]->id == MAP_TRACE) ||
		       (EXTSPLIT_TRACE/* HERE HERE >=2 */ && rmap->id == EXTSPLIT_NREFID /* && XXmap[align->mapid2]->id == MAP_TRACE */)){
		      printf("alignid=%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.6f -> %0.6f at %p\n",
			     alignid,align->mapid1,refmap[align->mapid1]->id,mapid,nanomap->id,align->orientation,align->score,align->logPV,
			     align->maxoutlier,align->maxoutlierLabels,align->mapWT, max(align->mapWT,extendWT), &align->mapWT);
		      fflush(stdout);
		    }
		    align->mapWT = max(align->mapWT,extendWT);
		  } else {// try to decrease align->mapWT 
		    if(extendMaxWT < align->mapWT - 1e-6){
		      if(leftend < -extendLen && !(rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT))){
			Lrcnt++;
			LrcntWT += wt;
		      } else {
			Rrcnt++;
			RrcntWT += wt;
		      }
		    }
		    if((TRACE>=2 && rmap->id == REF_TRACE && XXmap[align->mapid2]->id == MAP_TRACE) ||
		       (EXTSPLIT_TRACE/* HERE HERE >=2 */ && rmap->id == EXTSPLIT_NREFID /* && XXmap[align->mapid2]->id == MAP_TRACE */)){
		      printf("alignid=%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.4f,logPV=%0.2f,maxoutlier=%0.3f,%d: mapWT= %0.6f -> %0.6f\n",
			     alignid,align->mapid1,refmap[align->mapid1]->id,mapid,nanomap->id,align->orientation,align->score,align->logPV,
			     align->maxoutlier,align->maxoutlierLabels,align->mapWT, min(align->mapWT,extendMaxWT));
		      fflush(stdout);
		    }
		    align->mapWT = min(align->mapWT,extendMaxWT);
		  }

		  if(DEBUG>=2) assert(0.0 <= align->mapWT && align->mapWT <= 1.0);
		}
	      }
	      if((TRACE>=2 && rmap->id == REF_TRACE && XXmap[align->mapid2]->id == MAP_TRACE) ||
		 (EXTSPLIT_TRACE/* HERE HERE >=2 */ && rmap->id == EXTSPLIT_NREFID /* && XXmap[align->mapid2]->id == MAP_TRACE */)){
		int IL = -1, IR = -1;
		if(maxoutlierLoc > 0){
		  IL = align->sites1[maxoutlierLoc-1];
		  IR = align->sites1[maxoutlierLoc];
		}
		printf("alignid=%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:mapWT=%0.6f->%0.6f,N=%d,M=%d,score=%0.4f,logPV=%0.4f,len=%0.3f,outlierKB=%0.3f(I=%d..%d),LijY=%d,LijX=%d,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d,RijY=%d,RijX=%d:Y[I-K,RI]= %0.3f,%0.3f,Lend=%d,Rend=%d(Eleft=%0.3f,Eright=%0.3f),Mask:L=%d,R=%d\n",
		       alignid,refid,rmap->id,mapid,nanomap->id,align->orientation,wt,align->mapWT,N,M,align->score,align->logPV, X[M+1] * scale, align->maxoutlier, IL,IR,
		       align->LijY,align->LijX,I, K, J, RI, RK, RJ, align->RijY,align->RijX,Y[I-K], Y[RI], align->Lend, align->Rend,
		       Y[0] - leftend, rightend - Y[N+1],(rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT)) ? 1 : 0, (rmap->Mask[0] && (rmap->Mask[0][N+1] & END_NOEXT)) ? 1 : 0);
		fflush(stdout);
	      }
	    } else 
	      if((TRACE>=2 && rmap->id == REF_TRACE && XXmap[align->mapid2]->id == MAP_TRACE) ||
		 (EXTSPLIT_TRACE>=2 && rmap->id == EXTSPLIT_NREFID /* && XXmap[align->mapid2]->id == MAP_TRACE */)){
		printf("alignid=%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:mapWT=%0.6f,N=%d,M=%d,score=%0.4f,logPV=%0.4f,len=%0.3f,outlierKB=%0.3f,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d:Y[I-K,RI]= %0.3f,%0.3f,Lend=%d,Rend=%d,Mask:L=%d,R=%d\n",
		       alignid,refid,rmap->id,mapid,nanomap->id,align->orientation,align->mapWT,N,M,align->score,align->logPV, X[M+1] * scale, align->maxoutlier,I, K, J, RI, RK, RJ, Y[I-K],Y[RI], align->Lend, align->Rend,
		       (rmap->Mask[0] && (rmap->Mask[0][1] & END_NOEXT)) ? 1 : 0, (rmap->Mask[0] && (rmap->Mask[0][N+1] & END_NOEXT)) ? 1 : 0);
		fflush(stdout);
	      }

	  } // for alignid = align_start .. align_end - 1
	  if(VERB){
	    if(Lwcnt > 0)
	      printf("refid=%d(id=%lld): %d left extending molecules (with avg weight= %0.6f) had weight increased to extendWT= %0.6f\n",
		     refid,rmap->id,Lwcnt, LwcntWT/max(1,Lwcnt), extendWT);
	    if(Lrcnt > 0)
	      printf("refid=%d(id=%lld): %d left extending molecules (with avg weight= %0.6f) had weight decreased to extendMaxWT= %0.3e\n",
		     refid,rmap->id,Lrcnt, LrcntWT/max(1,Lrcnt), extendMaxWT);
	      
	    if(Rwcnt > 0)
	      printf("refid=%d(id=%lld): %d right extending molecules (with avg weight= %0.6f) had weight increased to extendWT= %0.6f\n",
		     refid,rmap->id,Rwcnt, RwcntWT/max(1,Rwcnt), extendWT);
	    if(Rrcnt > 0)
	      printf("refid=%d(id=%lld): %d right extending molecules (with avg weight= %0.6f) had weight decreased to extendMaxWT= %0.3e\n",
		     refid,rmap->id,Rrcnt, RrcntWT/max(1,Rrcnt), extendMaxWT);
	    fflush(stdout);
	  }
	} // if(EXTENDWT_DELAY && extendLen > 0.0 && extendWT > 0.0 && extendWTend && refid < orignumrefmaps)

#if 0 // DEBUG CODE
	if(refid == 0 && 144 < numrefmaps){
	  refid = 144 - 1;
	  continue;/* continue with refid + 1 */
	}
	if(refid > 144){
	  printf("Debug exit\n");
	  fflush(stdout);exit(1);
	}
	  
#endif // DEBUG CODE

#if 1 // RefineOverwrite : New (Wait until contigs have been split, so it can be applied to each split output contig) 
	if(RefineOverwrite < 0)
	  RefineOverwrite = (HapSitePvalue || HapIndelPvalue) ? 0 : 1;
	if(RefineOverwrite==0){/* check if .hmap or .cmap file already exists : if so skip this contig */
	  Cmap *rmap = refmap[refid];
	  long long CMapID = rmap->id;
	  char filename[PATH_MAX];
	  FILE *fp;

	  if(HapSitePvalue || HapIndelPvalue){
	    CMapID *= 10;
	    sprintf(filename,"%s_contig%lld.hmap",draft_prefix, CMapID);
	    if((fp = fopen(filename,"r")) != NULL){
	      fclose(fp);
	      printf("WARNING: Output file %s already exists : skipping Haplotype refinment of contig%lld\n",filename, rmap->id);
	      fflush(stdout);
	    
	      continue;
	    } 
	  }

	  sprintf(filename,"%s_contig%lld.cmap",draft_prefix, CMapID);
	  if((fp = fopen(filename,"r")) != NULL){
	    fclose(fp);
	    printf("WARNING: Output file %s already exists : skipping refinment of contig%lld\n",filename, rmap->id);
	    fflush(stdout);
	    
	    continue;
	  } 

	  if(VERB/* HERE >=2 */){
	    if(HapSitePvalue || HapIndelPvalue)
	      printf("%s (or .hmap) not found: proceeding with Haplotype refinement of contig%lld\n",filename, rmap->id);
	    else
	      printf("%s (or .hmap) not found: proceeding with refinement of contig%lld\n",filename, rmap->id);
	    fflush(stdout);
	  }
	}
#endif // RefineOverwrite : New 

	/* filter out alignments with mapWT below refineMinWT (command line parameter, default 0.0) to speed up refinement
	   If 2nd ChimQuality arg is >=2, instead of filtering them out, just reduce the wt to 0, which will provide the same speed benefit during refinement, but allows -ChimQuality 2 2 (or 2 3)
	   to restore full weight before computing CMAP Quality scores */
	if(refineMinWT > 0.0){
	  double FilterLogPV = 0.0;// WAS143 min(LogPvThreshold2,LogPvThresholdTE) - 1.0;

	  size_t end = align_start;
	  size_t cnt = 0, zcnt = 0;
	  double cntWT = 0.0, zcntWT = 0.0;
	  for(size_t alignid = align_start; alignid < align_end; alignid++){
	    Calign *align = Lalignment[alignid];
	    if(DEBUG>=2) assert(0.0 <= align->mapWT && align->mapWT <= 1.0);
	    if(DEBUG/* HERE HERE >=2 */) assert(align->noutliers >= 0 && align->maxoutlier >= 0.0 && align->maxoutlierLabels >= 0 &&
						(align->noutliers <= 0 || align->maxoutlier > 0.0 || align->maxoutlierLabels > 0));

	    if(align->mapWT < refineMinWT){
	      if(EXTSPLIT_TRACE/* HERE HERE >=2 */ && YYmap[align->mapid1]->id == EXTSPLIT_NREFID /* && XXmap[align->mapid2]->id == MAP_TRACE */){
		printf("\t alignid=%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.6f,logPV=%0.2f,outlier=%0.3f,%d: mapWT= %0.3e (Deleting due to refineMinWT %0.3e)\n",
		       alignid,align->mapid1,YYmap[align->mapid1]->id,align->mapid2,XXmap[align->mapid2]->id,align->orientation,align->numpairs,align->score,align->logPV,
		       align->maxoutlier,align->maxoutlierLabels,align->mapWT,refineMinWT);
		fflush(stdout);
	      }
	      if(FilterXmapWT)
		align->logPV = FilterLogPV;
	      zcntWT += align->mapWT;
	      if(ChimQuality && HapMapWT >= 2){// NEW161
		zcnt++;
		align->mapWT = 0.0;
	      } else
		continue;
	    } else if(align->mapWT < refineWT && align->maxoutlier <= refineWT_MaxOutlierKB && (align->maxoutlierLabels < refineWT_MaxOutlierLabels || align->noutliers <= 0)){
	      int mapid = align->mapid2;
	      Cmap *nanomap = Gmap[mapid];
	      int M = nanomap->numsite[0];
	      double scale = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;	    
	      FLOAT *X = nanomap->site[0];

	      int I = align->sites1[0];
	      int K = align->sitesK1[0];
	      int J = align->sites2[0];
	      int U = align->numpairs;
	      int RI = align->sites1[U-1];
	      // int RK = align->sitesK1[U-1];
	      int RJ = align->sites2[U-1];
	      
	      double leftlenX = scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]);/* unaligned left end length of X */
	      double rightlenX = scale * (align->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]);/* unaligned right end length of X */

#if CALIGN_END==0
	      if(((Y[I-K] < leftlenX) ? 
		  (align->Lend > -2 || Y[I-K] <= refineWT_NL || I-K-1 + J-align->LijX <= refineWT_N) : 
		  (align->Lend > -2 || leftlenX <= refineWT_NL || I-K-align->LijY + J-1 <= refineWT_N)) && 
		 ((Y[N+1]-Y[RI] < rightlenX) ? 
		  (align->Rend > -2 || Y[N+1] - Y[RI] <= refineWT_NL || N-RI + align->RijX-RJ/*NEW208*/ <= refineWT_N) : 
		  (align->Rend > -2 || rightlenX <= refineWT_NL || align->RijY-RI/*NEW208*/ + M-RJ <= refineWT_N))){
		cnt++;
		cntWT += align->mapWT;
		if(EXTSPLIT_TRACE/* HERE HERE >=2 */ && YYmap[align->mapid1]->id == EXTSPLIT_NREFID /* && XXmap[align->mapid2]->id == MAP_TRACE */){
		  printf("\t alignid=%lu:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.6f,logPV=%0.2f,outlier=%0.3f,%d: mapWT %0.3e -> %0.3f due to -refineWT %0.2f %d %0.1f %0.1f %d\n",
			 alignid,align->mapid1,YYmap[align->mapid1]->id,align->mapid2,XXmap[align->mapid2]->id,align->orientation,align->numpairs,align->score,align->logPV,align->maxoutlier,
			 align->maxoutlierLabels,align->mapWT,max(align->mapWT,refineWT), refineWT, refineWT_N, refineWT_NL, refineWT_MaxOutlierKB, refineWT_MaxOutlierLabels);
		  fflush(stdout);
		}

		align->mapWT = max(align->mapWT, refineWT);
	      }
#else // NOT quite correct : only misaligned labels on Y[] or X[] are counted (whichever ends first)
	      if(((Y[I-K] < leftlenX) ? 
		  (align->Lend > -2 || Y[I-K] <= refineWT_NL || I-K-1 <= refineWT_N) : 
		  (align->Lend > -2 || leftlenX <= refineWT_NL || J-1 <= refineWT_N)) && 
		 ((Y[N+1]-Y[RI] < rightlenX) ? 
		  (align->Rend > -2 || Y[N+1] - Y[RI] <= refineWT_NL || N-RI <= refineWT_N) : 
		  (align->Rend > -2 || rightlenX - Y[RI] <= refineWT_NL || M-RJ <= refineWT_N))){
		cnt++;
		cntWT += align->mapWT;
		align->mapWT = max(align->mapWT, refineWT);
	      }
#endif
	    }

	    Lalignment[end++] = align;
	  }
	  if(VERB/* HERE >=2 */ && (align_end > end || cnt > 0 || zcnt > 0)){

	    printf("refid=%d(id=%lld): Deleted %lu alignments (and zero'd wt of %lu) with avg wt= %0.6f due to -refineMinWT %0.3e: cum wall= %0.6f secs\n",
		   refid,rmap->id,align_end-end,zcnt,zcntWT/max(1ul,align_end-end+zcnt),refineMinWT,wtime());
	    if(refineWT > 0.0)
	      printf("\t Increased wt of %lu alignments with avg wt= %0.6f due to -refineWT %0.3f %d %0.1f %0.1f %d\n",  
		     cnt,cntWT/max(1ul,cnt), refineWT,refineWT_N, refineWT_NL, refineWT_MaxOutlierKB, refineWT_MaxOutlierLabels);
	    fflush(stdout);
	  }
	  align_end = end;
	}

	// sort Lalignment[align_start..align_end-1] in descending order of alignment label range so qprobeval(),mprobeval() have better load balancing (see also -finalsort-sitesdec)
	qsort(&Lalignment[align_start],align_end - align_start, sizeof(Calign *), (intcmp*)CalignSiteRangeDec);
	// Try sorting by alignment location (left end, right end) on contig to make memory reference in qprobeval(), mprobeval() become more local
	// qsort(&Lalignment[align_start],align_end - align_start, sizeof(Calign *), (intcmp*)CalignRefSiteInc);

	if(VERB/* HERE >=2 */ && align_end > align_start){
	  printf("refid=%d(id=%lld): Sorted %lu alignments in descending order of alignment label range: cum wall= %0.6f\n",refid,rmap->id,align_end-align_start,wtime());
	  //	  printf("refid=%d(id=%lld): Sorted %lu alignments in ascending order of contig location: cum wall= %0.6f\n",refid,rmap->id,align_end-align_start,wtime());
	  fflush(stdout);
	}

	if(extendSplit && refid >= orignumrefmaps){
	  if(VERB/* HERE HERE >=2 */ && LogPvThreshold != LogPvThresholdTS){
	    printf("refid=%d:Changing Log10 of -T = %0.2f -> %0.2f (-TS value)\n",refid,LogPvThreshold,LogPvThresholdTS);
	    fflush(stdout);
	  }
	  LogPvThreshold = LogPvThresholdTS;/* use -TS value */
	  if(extsplitOutlier > 0.0){/* use either -AS -LS or -extsplitOutlierAS, -extsplitOutlierLS values, whichever are smaller */
	    if(VERB/* HERE HERE >=2 */ && AlignedSiteThreshold != min(AlignedSiteThresholdS, extsplitOutlierAS)){
	      printf("refid=%d:Changing -A : %d -> %d (min of -AS and -extsplitOutlier values)\n",refid,AlignedSiteThreshold,min(AlignedSiteThresholdS,extsplitOutlierAS));
	      fflush(stdout);
	    }
	    if(VERB/* HERE HERE >=2 */ && AlignedLengthThreshold != min(AlignedLengthThresholdS, extsplitOutlierLS)){
	      printf("refid=%d:Changing -L : %0.2f -> %0.2f kb (min of -LS and -extsplitOutlier values)\n",refid,AlignedLengthThreshold,min(AlignedLengthThresholdS,extsplitOutlierLS));
	      fflush(stdout);
	    }
	    AlignedSiteThreshold = min(AlignedSiteThresholdS,extsplitOutlierAS);/* use min of -AS and extsplitOutlierAS values */
	    AlignedLengthThreshold = min(AlignedLengthThresholdS,extsplitOutlierLS);/* use min of -LS and extsplitOutlierLS values */
	  } else {
	    if(VERB/* HERE HERE >=2 */ && AlignedSiteThreshold != AlignedSiteThresholdS){
	      printf("refid=%d:Changing -A : %d -> %d (-AS value)\n",refid,AlignedSiteThreshold,AlignedSiteThresholdS);
	      fflush(stdout);
	    }
	    if(VERB/* HERE HERE >=2 */ && AlignedLengthThreshold != AlignedLengthThresholdS){
	      printf("refid=%d:Changing -L : %0.2f -> %0.2f kb (-LS value)\n",refid,AlignedLengthThreshold,AlignedLengthThresholdS);
	      fflush(stdout);
	    }
	    AlignedSiteThreshold = AlignedSiteThresholdS;/* use -AS value */
	    AlignedLengthThreshold = AlignedLengthThresholdS;/* use -LS value */
	  }

	  if(VERB/* HERE HERE >=2 */ && LogPvThreshold2 != LogPvThresholdTS){
	    printf("refid=%d:Changing Log10 of -T2 = %0.2f -> %0.2f (-TS value)\n",refid,LogPvThreshold2,LogPvThresholdTS);
	    fflush(stdout);
	  }
	  LogPvThreshold2 = LogPvThresholdTS;/* use -TS value */
	  if(extsplitOutlier > 0.0){/* use either -AS -LS or -extsplitOutlierAS, -extsplitOutlierLS values, whichever are smaller */
	    if(VERB/* HERE HERE >=2 */ && AlignedSiteThreshold2 != min(AlignedSiteThresholdS,extsplitOutlierAS)){
	      printf("refid=%d:Changing -A2 : %d -> %d (min of -AS and -extsplitOutlier values)\n",refid,AlignedSiteThreshold2,min(AlignedSiteThresholdS,extsplitOutlierAS));
	      fflush(stdout);
	    }
	    if(VERB/* HERE HERE >=2 */ && AlignedLengthThreshold2 != min(AlignedLengthThresholdS,extsplitOutlierLS)){
	      printf("refid=%d:Changing -L2 : %0.2f -> %0.2f kb (min of -LS and -extsplitOutlier values)\n",refid,AlignedLengthThreshold2,min(AlignedLengthThresholdS,extsplitOutlierLS));
	      fflush(stdout);
	    }
	    AlignedSiteThreshold2 = min(AlignedSiteThresholdS,extsplitOutlierAS);/* use min of -AS and extsplitOutlierAS values */
	    AlignedLengthThreshold2 = min(AlignedLengthThresholdS,extsplitOutlierLS);/* use min of -LS and extsplitOutlierLS values */
	  } else {
	    if(VERB/* HERE HERE >=2 */ && AlignedSiteThreshold2 != AlignedSiteThresholdS){
	      printf("refid=%d:Changing -A2 : %d -> %d (-AS value)\n",refid,AlignedSiteThreshold2,AlignedSiteThresholdS);
	      fflush(stdout);
	    }
	    if(VERB/* HERE HERE >=2 */ && AlignedLengthThreshold2 != AlignedLengthThresholdS){
	      printf("refid=%d:Changing -L2 : %0.2f -> %0.2f kb (-LS value)\n",refid,AlignedLengthThreshold2,AlignedLengthThresholdS);
	      fflush(stdout);
	    }
	    AlignedSiteThreshold2 = AlignedSiteThresholdS;/* use -AS value */
	    AlignedLengthThreshold2 = AlignedLengthThresholdS;/* use -LS value */
	  }

	  if(VERB/* HERE HERE >=2 */ && LogPvThresholdTE != LogPvThresholdTS){
	    printf("refid=%d:Changing Log10 of -TE = %0.2f -> %0.2f (-TS value)\n",refid,LogPvThresholdTE,LogPvThresholdTS);
	    fflush(stdout);
	  }
	  LogPvThresholdTE = LogPvThresholdTS;/* use -TS value */
	  if(extsplitOutlier > 0.0){/* use either -AS -LS or -extsplitOutlierAS, -extsplitOutlierLS values, whichever are smaller */
	    if(VERB/* HERE HERE >=2 */ && AlignedSiteThresholdE != min(AlignedSiteThresholdS,extsplitOutlierAS)){
	      printf("refid=%d:Changing -AE : %d -> %d (min of -AS and -extsplitOutlier values)\n",refid,AlignedSiteThresholdE,min(AlignedSiteThresholdS,extsplitOutlierAS));
	      fflush(stdout);
	    }
	    if(VERB/* HERE HERE >=2 */ && AlignedLengthThresholdE != min(AlignedLengthThresholdS,extsplitOutlierLS)){
	      printf("refid=%d:Changing -LE : %0.2f -> %0.2f kb (min of -LS and -extsplitOutlier values)\n",refid,AlignedLengthThresholdE,min(AlignedLengthThresholdS,extsplitOutlierLS));
	      fflush(stdout);
	    }
	    AlignedSiteThresholdE = min(AlignedSiteThresholdS,extsplitOutlierAS);/* use min of -AS and extsplitOutlierAS values */
	    AlignedLengthThresholdE = min(AlignedLengthThresholdS,extsplitOutlierLS);/* use min of -LS and extsplitOutlierLS values */
	  } else {
	    if(VERB/* HERE HERE >=2 */ && AlignedSiteThresholdE != AlignedSiteThresholdS){
	      printf("refid=%d:Changing -AE : %d -> %d (-AS value)\n",refid,AlignedSiteThresholdE,AlignedSiteThresholdS);
	      fflush(stdout);
	    }
	    if(VERB/* HERE HERE >=2 */ && AlignedLengthThresholdE != AlignedLengthThresholdS){
	      printf("refid=%d:Changing -LE : %0.2f -> %0.2f kb (-LS value)\n",refid,AlignedLengthThresholdE,AlignedLengthThresholdS);
	      fflush(stdout);
	    }
	    AlignedSiteThresholdE = AlignedSiteThresholdS;/* use -AS value */
	    AlignedLengthThresholdE = AlignedLengthThresholdS;/* use -LS value */
	  }

	} else {
	  if(VERB/* HERE HERE >=2 */ && LogPvThreshold != origLogPvThreshold){
	    printf("refid=%d:Changing log10 of -T : %0.2f -> %0.2f (original value), align_start=%lu,align_end=%lu\n",refid,LogPvThreshold,origLogPvThreshold,align_start,align_end);
	    fflush(stdout);
	  }
	  if(VERB/* HERE HERE >=2 */ && AlignedSiteThreshold != origAlignedSiteThreshold){
	    printf("refid=%d:Changing -A : %d -> %d (original value)\n",refid,AlignedSiteThreshold,origAlignedSiteThreshold);
	    fflush(stdout);
	  }
	  if(VERB/* HERE HERE >=2 */ && AlignedLengthThreshold != origAlignedLengthThreshold){
	    printf("refid=%d:Changing -L : %0.2f -> %0.2f kb (original value)\n",refid,AlignedLengthThreshold,origAlignedLengthThreshold);
	    fflush(stdout);
	  }
	  LogPvThreshold = origLogPvThreshold;/* -T before -TE or -TS (or -MapRate) adjustment */
	  AlignedSiteThreshold = origAlignedSiteThreshold;/* -A before -AE or -AS adjustment */
	  AlignedLengthThreshold = origAlignedLengthThreshold;/* -L before -LE or -LS adjustment */

	  if(VERB/* HERE HERE >=2 */ && LogPvThreshold2 != origLogPvThreshold2){
	    printf("refid=%d:Changing Log10 of -T2 = %0.2f -> %0.2f (original value)\n",refid,LogPvThreshold2,origLogPvThreshold2);
	    fflush(stdout);
	  }
	  if(VERB/* HERE HERE >=2 */ && AlignedSiteThreshold2 != origAlignedSiteThreshold2){
	    printf("refid=%d:Changing -A2 : %d -> %d (original value)\n",refid,AlignedSiteThreshold2,origAlignedSiteThreshold2);
	    fflush(stdout);
	  }
	  if(VERB/* HERE HERE >=2 */ && AlignedLengthThreshold2 != origAlignedLengthThreshold2){
	    printf("refid=%d:Changing -L2 : %0.2f -> %0.2f kb (original value)\n",refid,AlignedLengthThreshold2,origAlignedLengthThreshold2);
	    fflush(stdout);
	  }

	  LogPvThreshold2 = origLogPvThreshold2;/* -T2 before -TE or -TS adjustment */
	  AlignedSiteThreshold2 = origAlignedSiteThreshold2;/* -A2 before -AE or -AS adjustment */
	  AlignedLengthThreshold2 = origAlignedLengthThreshold2;/* -L2 before -LE or -LS adjusment */

	  if(VERB/* HERE HERE >=2 */ && LogPvThresholdTE != origLogPvThresholdTE){
	    printf("refid=%d:Changing Log10 of -TE = %0.2f -> %0.2f (original value)\n",refid,LogPvThresholdTE,origLogPvThresholdTE);
	    fflush(stdout);
	  }
	  if(VERB/* HERE HERE >=2 */ && AlignedSiteThresholdE != origAlignedSiteThresholdE){
	    printf("refid=%d:Changing -AE : %d -> %d (original value)\n",refid,AlignedSiteThresholdE,origAlignedSiteThresholdE);
	    fflush(stdout);
	  }
	  if(VERB/* HERE HERE >=2 */ && AlignedLengthThresholdE != origAlignedLengthThresholdE){
	    printf("refid=%d:Changing -LE : %0.2f -> %0.2f kb (original value)\n",refid,AlignedLengthThresholdE,origAlignedLengthThresholdE);
	    fflush(stdout);
	  }
	  LogPvThresholdTE = origLogPvThresholdTE;/* -TE before -TS adjustment */
	  AlignedSiteThresholdE = origAlignedSiteThresholdE;/* -AE before -AS adjustment */
	  AlignedLengthThresholdE = origAlignedLengthThresholdE;/* -LE before -LS adjustment */
	}

	/* first create a Ccontig structure of the original reference map and the alignments of all Query maps with it */
	Ccontig contig1;
	int *nmap1 = new int[N+2];/* memory for mapping from Y[I=0..N+1] to contig1.site[0][i=0..contig1.numsite[0]+1], where contig1.numsite[0] == n1 */
	int maligncnt1;
	size_t *alignids1;
	int n1 = build_contig(contig1,nmap1,refid,rmap,N,Y,align_start,align_end,Lalignment, mapcnt,origmapcnt,maligncnt1, alignids1);/* uses -T2,-L2 and -TE,-LE threshold */

	if(VERB>=2){
	  printf("Calling dumpmemmap() after building refinement contig data:\n");
	  fflush(stdout);
	  dumpmemmap();      
	}

	if(RefineHmap && (HapSitePvalue > 0.0 || HapIndelPvalue > 0.0) && rmap->contig){/* locate the other Allele at refmap[rmap->contig->Allele] and call HaploTypeR() instead of refine() */
	  if(DEBUG>=2){
	    int m = rmap->contig->numsite[0];/* real sites in input Hapmap */
	    int *HapSite = rmap->contig->HapSite[0];/* HapSite[0..m+1] for input Hapmap */
	    if(DEBUG && !(HapSite[0]==0 && HapSite[m+1]==0)){
	      printf("refid=%d: m=%d,HapSite[0]=%d,HapSite[m+1]=%d\n",
		     refid,m,HapSite[0],HapSite[m+1]);
	      fflush(stdout); 
	      assert(HapSite[0]==0 && HapSite[m+1]==0);
	    }
	  }

	  /* Add some aliases to simplify variable names */
	  //	  int &refid1 = refid;
	  //	  Cmap *&rmap1 = rmap;
	  int &N1 = N;
	  //	  FLOAT *&Y1 = Y;

	  int refid2 = rmap->Allele;
	  if(DEBUG && !(refid < Hapnumrefmaps && Hapnumrefmaps <= refid2 && refid2 < numrefmaps)){
	    printf("refid= %d, refid2= %d, Hapnumrefmaps= %d, numrefmaps= %d, refmap[refid]->Allele= %d\n",refid,refid2,Hapnumrefmaps, numrefmaps, refmap[refid]->Allele);
	    fflush(stdout);
	    assert(refid < Hapnumrefmaps && Hapnumrefmaps <= refid2 && refid2 < numrefmaps);
	  }
	  Cmap *rmap2 = refmap[refid2];
	  if(DEBUG && !(rmap2->Allele == refid)){
	    printf("refid=%d(id=%lld):refid2=%d(id=%lld),refmap[refid]->Allele=%d,refmap[refid2]->Allele=%d\n",
		   refid,rmap->id,refid2,rmap2->id,rmap->Allele,rmap2->Allele);
	    fflush(stdout);
	    assert(rmap2->Allele == refid);
	  }
	  int N2 = rmap2->numsite[0];
	  FLOAT *Y2 = rmap2->site[0];

	  size_t align_start2 = numalign_start[refid2];
	  size_t align_end2 = numalign_end[refid2];

	  if(VERB>=2){
	    printf("refid2=%d:align_start2=%lu,align_end2=%lu\n",refid2,align_start2,align_end2);
	    fflush(stdout);
	  }

	  if(DEBUG) assert(!extendSplit);
	  int origmapcnt2 = mapcnt;
	  int mapcnt2 = mapcnt;
	  /* increment mapcnt2 with number of maps with good alignment to refid2 */
	  for(size_t alignid = align_start2; alignid < align_end2; alignid++){
	    Calign *align = alignment[alignid];
	    if(DEBUG) assert(align != 0);
	    if(DEBUG) assert(align->mapid1 == refid2);
	    int mapid = align->mapid2;
	    if(DEBUG) assert(mapid >= 0);
	    if(DEBUG && hash_filename) assert(mapid < nummaps || (NoSplit <= 1 && startmaps <= mapid && mapid < totalmaps));
	    Cmap *nanomap = Gmap[mapid];
	    Cmap *origmap = nanomap;
	    while(origmap->origmap)
	      origmap = origmap->origmap;
	    if(DEBUG>=2 && BestRef) assert(origmap->nalign->mapid1 >= 0);
	    if(DEBUG) assert(align->mapid1 == refid2);
	    if(DEBUG) assert(align->mapid2 == mapid);

	    if(!AlignedThreshold(align, rmap2->site[0], ScoreThreshold, LogPvThreshold))
	      continue;
	    
	    if(BestRef && origmap->nalign->mapid1 != refid2 && BestRefExtCheck(align,origmap->nalign,mapid,refid2))
	      continue;/* skip alignment unless it is with the reference with the best alignment score with mapid */

	    mapcnt2++;/* good alignments */
	  }
	  if(VERB){
	    printf("Refining refmap %d(id=%lld,len2=%0.3f,Y2[N2]-Y2[1]=%0.3f,Y2[1]=%0.3f), mapcnt2=%d(%d-%d)/%d (2nd Allele, refid2=%d,start2=%lu,end2=%lu)\n",
		   refid,rmap->id,Y2[N2+1],Y2[N2]-Y2[1],Y2[1],mapcnt2-origmapcnt2,mapcnt2,origmapcnt2,nummaps,refid2,align_start2,align_end2);
	    fflush(stdout);
	  }

	  /* compute Lalignment2[align_start2..align_end2-1], corresponding to rmap2 */
	  Calign **Lalignment2 = alignment;
	  if(MultiMatches && !BestRef){// expand list of alignments to include alternate alignments with the same reference map 
	    // first count how many total matchgroups there are
	    size_t cnt = 0;
	    for(size_t alignid = align_start2; alignid < align_end2; alignid++){
	      Calign *align = alignment[alignid];
	      if(!align)
		continue;
	      if(DEBUG>=2) assert(align->mapid1 == refid2);
	      if(!AlignedThreshold(align, rmap2->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	      int mapid = align->mapid2;
	      if(DEBUG>=2) assert(!Gmap[mapid]->origmap);
	      if(DEBUG>=2) assert(align->Malign && align->multicnt > 0);
	      cnt += align->multicnt;
	    }
	    if(VERB/* HERE HERE >=2 */){
	      printf("refid2=%d:align_start2=%lu,align_end2=%lu: Number of alignments above thresholds (cnt)=%lu\n",
		     refid2,align_start2,align_end2,cnt);
	      fflush(stdout);
	    }
	    Lalignment2 = new Calign*[cnt];
	    size_t end = 0;
	    for(size_t alignid = align_start2; alignid < align_end2; alignid++){
	      Calign *align = alignment[alignid];
	      if(!align)
		continue;
	      if(DEBUG>=2) assert(align->mapid1 == refid2);
	      if(!AlignedThreshold(align, rmap2->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	      int mapid = align->mapid2;
	      if(DEBUG>=2) assert(!Gmap[mapid]->origmap);
	    
	      for(int t = 0; t < align->multicnt; t++){
		Calign *q = align->Malign[t];
		if(DEBUG>=2) assert(q->mapid1 == refid2);
		if((VERB>=2 && align->multicnt > 1) || (DEBUG && !(q->Malign==NULL))){
		  int mapid = q->mapid2;
		  double wt = q->mapWT;// weight of current qmap (1 unless -BestRefWT was used)
		  Cmap *nanomap = Gmap[mapid];
		  int M = nanomap->numsite[0];
		  double scale = q->scaleID ? ScaleFactor[q->scaleID] : 1.0;	    
		  FLOAT *X = nanomap->site[0];

		  int I = q->sites1[0];
		  int K = q->sitesK1[0];
		  int J = q->sites2[0];
		  int U = q->numpairs;
		  int RI = q->sites1[U-1];
		  int RK = q->sitesK1[U-1];
		  int RJ = q->sites2[U-1];
		
		  printf("t=%d/%d:refid2=%d(id=%lld),mapid=%d(id=%lld),or=%d:wt=%0.4f,N=%d,M=%d,score=%0.4f,logPV=%0.4f,len=%0.3f,I=%d,K=%d,J=%d,RI=%d,RK=%d,RJ=%d:Lend=%d,Rend=%d\n",
			 t,align->multicnt,refid2,rmap->id,mapid,nanomap->id,q->orientation,wt,N,M,q->score,q->logPV, X[M+1] * scale, I, K, J, RI, RK, RJ, q->Lend, q->Rend);
		  fflush(stdout);
		}
		Lalignment2[end++] = q;
		if(DEBUG>=2 && !(q->Malign == NULL)){
		  printf("\t t=%d/%d:q=%p:Malign=%p,multicnt=%d\n",t,align->multicnt,q,q->Malign,q->multicnt);
		  fflush(stdout);
		  assert(q->Malign == NULL);
		}
	      }
	    }
	    if(DEBUG) assert(end == cnt);
	    align_start2 = 0;
	    align_end2 = end;
	  } else {/* just filter out alignments that are below threshold */
	    // first count how many total matchgroups there are
	    size_t cnt = 0;
	    for(size_t alignid = align_start2; alignid < align_end2; alignid++){
	      Calign *align = alignment[alignid];
	      if(!align)
		continue;
	      if(DEBUG>=2) assert(align->mapid1 == refid2);
	      if(!AlignedThreshold(align, rmap2->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	      int mapid = align->mapid2;
	      if(DEBUG>=2) assert(!Gmap[mapid]->origmap);
	      if(DEBUG>=2 && BestRef) assert(Gmap[mapid]->nalign->mapid1 >= 0);
	      if(BestRef && Gmap[mapid]->nalign->mapid1 != refid2 && BestRefExtCheck(align,Gmap[mapid]->nalign,mapid,refid2))
		continue;// skip alignment unless it is with the reference with the best alignment score with mapid
	      cnt++;
	    }
	    Lalignment2 = new Calign*[cnt];
	    size_t end = 0;
	    for(size_t alignid = align_start2; alignid < align_end2; alignid++){
	      Calign *align = alignment[alignid];
	      if(!align)
		continue;
	      if(DEBUG>=2) assert(align->mapid1 == refid2);
	      if(!AlignedThreshold(align, rmap2->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	      int mapid = align->mapid2;
	      if(DEBUG>=2) assert(!Gmap[mapid]->origmap);
	      if(DEBUG>=2 && BestRef) assert(Gmap[mapid]->nalign->mapid1 >= 0);
	      if(BestRef && Gmap[mapid]->nalign->mapid1 != refid2 && BestRefExtCheck(align,Gmap[mapid]->nalign,mapid,refid2))
		continue;// skip alignment unless it is with the reference with the best alignment score with mapid
	      Lalignment2[end++] = align;
	      if(DEBUG>=2) assert(align->Malign == NULL);
	    }
	    if(DEBUG) assert(end == cnt);
	    align_start2 = 0;
	    align_end2 = end;
	  }
	  if(DEBUG) assert(LogPvThresholdTE >= LogPvThreshold);/* If this is NOT true, then LogPvThreshold should have been adjusted to LogPvThresholdTE before computing Lalignment2[] */
	  if(VERB>=2){
	    printf("refid2=%d:numalignment_start=%lu,numalign_end=%lu, align_start2=%lu,align_end2=%lu\n",refid2,numalign_start[refid2],numalign_end[refid2],align_start2,align_end2);
	    fflush(stdout);
	  }

	  /* filter out alignments with mapWT below refineMinWT (command line parameter, default 0.0) to speed up refinement
	     If 2nd ChimQuality arg is >=2, instead of filtering them out, just reduce the wt to 0, which will provide the same speed benefit during refinement, but allows -ChimQuality 2 2 (or 2 3)
	     to restore full weight before computing CMAP Quality scores */
	  if(refineMinWT > 0.0){
	    size_t end = align_start2;
	    size_t cnt = 0, zcnt = 0;
	    for(size_t alignid = align_start2; alignid < align_end2; alignid++){
	      Calign *align = Lalignment2[alignid];
	      if(DEBUG>=2) assert(0.0 <= align->mapWT && align->mapWT <= 1.0);
	      if(DEBUG/* HERE HERE >=2 */) assert(align->noutliers >= 0 && align->maxoutlier >= 0.0 && align->maxoutlierLabels >= 0 &&
						  (align->noutliers <= 0 || align->maxoutlier > 0.0 || align->maxoutlierLabels > 0));

	      if(align->mapWT < refineMinWT){
		if(VERB>=2){
		  printf("\t refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:pairs=%d,score=%0.6f,logPV=%0.2f: mapWT= %0.3f (Deleting due to refineMinWT %0.3f)\n",
			 align->mapid1,YYmap[align->mapid1]->id,align->mapid2,XXmap[align->mapid2]->id,align->orientation,align->numpairs,align->score,align->logPV,align->mapWT,refineMinWT);
		  fflush(stdout);
		}
		if(ChimQuality && HapMapWT >= 2){
		  zcnt++;
		  align->mapWT = 0.0;
		} else
		  continue;
	      } else if(align->mapWT < refineWT && align->maxoutlier <= refineWT_MaxOutlierKB && (align->maxoutlierLabels < refineWT_MaxOutlierLabels || align->noutliers <= 0)){
		int N = N2;// NEW425
		FLOAT *Y = Y2;// NEW425

		int mapid = align->mapid2;
		Cmap *nanomap = Gmap[mapid];
		int M = nanomap->numsite[0];
		double scale = align->scaleID ? ScaleFactor[align->scaleID] : 1.0;	    
		FLOAT *X = nanomap->site[0];

		int I = align->sites1[0];
		int K = align->sitesK1[0];
		int J = align->sites2[0];
		int U = align->numpairs;
		int RI = align->sites1[U-1];
		//		int RK = align->sitesK1[U-1];
		int RJ = align->sites2[U-1];
	      
		double leftlenX = scale * (align->orientation ? X[M+1]-X[M+1-J] : X[J]);/* unaligned left end length of X */
		double rightlenX = scale * (align->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]);/* unaligned right end length of X */

#if CALIGN_END==0
		if(((Y[I-K] < leftlenX) ? 
		    (align->Lend > -2 || Y[I-K] <= refineWT_NL || I-K-1 + J-align->LijX <= refineWT_N) : 
		    (align->Lend > -2 || leftlenX <= refineWT_NL || I-K-align->LijY + J-1 <= refineWT_N)) && 
		   ((Y[N+1]-Y[RI] < rightlenX) ? 
		    (align->Rend > -2 || Y[N+1] - Y[RI] <= refineWT_NL || N-RI + align->RijX-RJ/*NEW280*/ <= refineWT_N) : 
		    (align->Rend > -2 || rightlenX <= refineWT_NL || align->RijY-RI/*NEW280*/ + M-RJ <= refineWT_N))){
		  cnt++;
		  align->mapWT = max(align->mapWT, refineWT);
		}
#else // NOT quite correct : only misaligned labels on Y[] or X[] are counted (whichever ends first)
		if(((Y[I-K] < leftlenX) ? 
		    (align->Lend > -2 || Y[I-K] <= refineWT_NL || I-K-1 <= refineWT_N) : 
		    (align->Lend > -2 || leftlenX <= refineWT_NL || J-1 <= refineWT_N)) && 
		   ((Y[N+1]-Y[RI] < rightlenX) ? 
		    (align->Rend > -2 || Y[N+1] - Y[RI] <= refineWT_NL || N-RI <= refineWT_N) : 
		    (align->Rend > -2 || rightlenX - Y[RI] <= refineWT_NL || M-RJ <= refineWT_N))){
		  cnt++;
		  align->mapWT = max(align->mapWT, refineWT);
		}
#endif
	      /* OLD CODE
		if((align->Lend > -2 || I-K <= refineWT_N || Y[I-K] <= refineWT_NL) &&
		   (align->Rend > -2 || N-RI <= refineWT_N || Y[N+1] - Y[RI] <= refineWT_NL)){
		  cnt++;
		  align->mapWT = max(align->mapWT, refineWT);
		}
	      */
	      }

	      Lalignment2[end++] = align;
	    }
	    if(VERB/* HERE >=2 */ && (align_end2 > end || cnt > 0 || zcnt > 0)){
	      if(cnt > 0)
		printf("refid=%d(id=%lld): Deleted %lu (and zero'd wt of %lu) of %lu alignments that were below -refineMinWT %0.3f: Increased wt of %lu alignments to -refineWT %0.1f %d %0.1f %0.1f %d:cum wall= %0.6f secs\n",
		       refid,rmap->id,align_end2-end,zcnt,align_end2-align_start2,refineMinWT,cnt,refineWT,refineWT_N,refineWT_NL,refineWT_MaxOutlierKB,refineWT_MaxOutlierLabels,wtime());
	      else
		printf("refid=%d(id=%lld): Deleted %lu (and zero'd wt of %lu) of %lu alignments that were below -refineMinWT %0.3f: cum wall= %0.6f secs\n",refid,rmap->id,align_end2-end,zcnt,align_end2-align_start2,refineMinWT,wtime());
	      fflush(stdout);
	    }
	    align_end2 = end;
	  }

	  // sort Lalignment2[align_start2..align_end2 - 1] in descending order of alignment or molecule size so qprobeval(),mprobeval() have better load balancing
	  qsort(&Lalignment2[align_start2],align_end2 - align_start2, sizeof(Calign *), (intcmp*)CalignSiteRangeDec);

	  // Try sorting by alignment location (left end, right end) on contig to make memory reference in qprobeval(), mprobeval() become more local
	  // qsort(&Lalignment2[align_start2],align_end2 - align_start2, sizeof(Calign *), (intcmp*)CalignRefSiteInc);
	  if(VERB/* HERE >=2 */ && align_end2 > align_start2){
	    printf("refid=%d(id=%lld): Sorted %lu alignments in descending order of alignment label range: cum wall= %0.6f\n",refid,rmap->id,align_end2-align_start2,wtime());
	    //	    printf("refid=%d(id=%lld): Sorted %lu alignments in ascending order of contig location: cum wall= %0.6f\n",refid,rmap->id,align_end2-align_start2,wtime());
	    fflush(stdout);
	  }

	  
	  if(VERB/* HERE HERE >=2 */ && LogPvThreshold != origLogPvThreshold){
	    printf("refid2=%d:Changing LogPvThreshold = %0.2f -> %0.2f (original value)\n",refid2,LogPvThreshold,origLogPvThreshold);
	    fflush(stdout);
	  }
	  LogPvThreshold = origLogPvThreshold;

	  /* creat Ccontig structure for 2nd Allele reference map and the alignments of all Query maps with it */
	  Ccontig contig2;
	  int *nmap2 = new int[N2+2];
	  int maligncnt2;
	  size_t *alignids2;
	  int n2 = build_contig(contig2,nmap2,refid2,rmap2,N2,Y2,align_start2,align_end2,Lalignment2, mapcnt2, origmapcnt2, maligncnt2, alignids2);

	  if(DEBUG) assert(N1 == rmap->contig->contig[0].numsite[0]);
	  if(DEBUG) assert(N2 == rmap->contig->contig[1].numsite[0]);
	  
	  /* collect all the data we need to build a merged Haplotype contig */
	  int m = rmap->contig->numsite[0];/* real sites in input Hapmap */
	  //	  double *Hcuts = rmap->contig->site[0];/* Hcuts[0..m+1] are sites in input Hapmap */
	  int *HapSite = rmap->contig->HapSite[0];/* HapSite[0..m+1] for input Hapmap */
	  size_t *Mask = rmap->Mask[0];/* Mask[0..m+1] for input Hapmap */
	  if(DEBUG && !(HapSite[0]==0 && HapSite[m+1]==0)){
	    printf("refid=%d: m=%d,HapSite[0]=%d,HapSite[m+1]=%d\n",
		   refid,m,HapSite[0],HapSite[m+1]);
	    fflush(stdout); 
	    assert(HapSite[0]==0 && HapSite[m+1]==0);
	  }

	  if(VERB>=2){
	    printf("refid2=%d:N1=%d,N2=%d,m=%d:Collecting all the data needed to build a merged Haplotype contig: cum wall= %0.6f secs\n",refid2,N1,N2,m,wtime());
	    fflush(stdout);
	  }

	  int *sitemap1 = rmap->contig->sitemap[0][0];/* sitemap1[I = 0..N1+1] maps Y1[I] to Hcuts[i] */
	  int *sitemap2 = rmap->contig->sitemap[0][1];/* sitemap2[I = 0..N2+1] maps Y2[I] to Hcuts[i] */

	  double *Hcuts1 = contig1.site[0];/* Hcuts1[0..n1+1] are Allele1 sites including unaligned labels and map ends */
	  double *Hcuts2 = contig2.site[0];/* Hcuts2[0..n2+1] are Allele2 sites including unaligned labels and map ends */
	  float *sitecnt1 = contig1.sitecnt[0];/* sitecnt1[0..n1+1] is the type of site in Allele1 (2 = real, 1 = unaligned, 0 = ends) */
	  float *sitecnt2 = contig2.sitecnt[0];/* sitecnt2[0..n2+1] is the type of site in Allele2 (2 = real, 1 = unaligned, 0 = ends) */
	  // nmap1[I=0..N1+1] maps Y1[I] to Hcuts1[i]
	  // nmap2[I=0..N2+1] maps Y2[I] to Hcuts2[i]

	  /* now build a merged Haplotype contig, consisting of contig12 (contains n12,Hcuts12[],HapSite12[],HapDelta12[],sitecnt[]) and map1[],mapK1[],map2[],mapK2[] */
	  Ccontig contig12;
	  contig12.id = rmap->id;
	  int &n12 = contig12.numsite[0] = 0;
	  double *&Hcuts12 = contig12.site[0] = NULL;
	  int *&HapSite12 = contig12.HapSite[0] = NULL;
	  float *&sitecnt12 = contig12.sitecnt[0] = NULL;
	  double *&HapDelta12 = contig12.HapDelta[0] = NULL;
	  size_t *&Mask12 = contig12.Mask[0] = NULL;

	  if(DEBUG) assert(contig1.sitecnt[0][0] == 0 && contig1.sitecnt[0][n1 + 1] == 0);
	  if(DEBUG) assert(contig2.sitecnt[0][0] == 0 && contig2.sitecnt[0][n2 + 1] == 0);
	  /* first compute n12 :
	     n12 + 2 == (n1+2) + (n2+2) - (H+2), where H is number of Homozygous labels in original HapMap  */
	  n12 = n1+n2;
	  for(int i = 1; i <= m; i++)
	    if(HapSite[i]==3)
	      n12--;
	  int H = (n1+n2 - n12);/* number of homozygous labels in original HapMap : to help with debugging */
	  if(VERB>=2){
	    printf("m=%d,n1=%d,n2=%d:n12=%d\n",m,n1,n2,n12);
	    fflush(stdout);
	  }

	  /* allocate Hcuts12,HapSite12,HapDelta12 and temporary arrays nsitemap1[0..n1+1] & nsitemap2[0..n2+1] */
	  Hcuts12 = new double[n12+2];
	  HapSite12 = new int[n12+2];
	  HapDelta12 = new double[n12+2];
	  Mask12 = new size_t[n12+2];
	  sitecnt12 = new float[n12+2];
	  memset(sitecnt12,0,(n12+2)*sizeof(float));
	  int *nsitemap1 = new int[n1+2];/* nsitemap1[i=0..n1+1] will map from Hcuts1[i] to Hcuts12[k] */
	  int *nsitemap2 = new int[n2+2];/* nsitemap2[i=0..n2+1] will map from Hcuts2[i] to Hcuts12[k] */
	  
	  memset(HapDelta12, 0, (n12+2)*sizeof(double));
	  memset(Mask12, 0, (n12+2)*sizeof(size_t));
	  memset(HapSite12, 0, (n12+2)*sizeof(int));

	  /* Allocate coverage arrays used as output by refine() for use in output_draft() */
	  contig12.sitecntFN[0] = new float[n12+2];
	  if(mCNT > 0){
	    contig12.sitecntN1[0][0] = new float[(n12+2)*mCNT];
	    for(int t = 1; t < mCNT; t++)
	      contig12.sitecntN1[0][t] = contig12.sitecntN1[0][0] + (n12+2)*t;
	  }
	  contig12.fragcnt[0] = new float[n12+2];
	  contig12.fragcntT[0] = new float[n12+2];
	  if(CovNorm)
	    contig12.fragcntTnorm[0] = new float[n12+2];
	  if(TrimNorm >= 0){
	    contig12.sitecntFNnorm[0] = new float[n12+2];
	    contig12.sitecntN2[0] = new float[n12+2];
	    contig12.sitecntN3[0] = new float[n12+2];
	    contig12.sitecntN4[0] = new float[n12+2];
	    contig12.sitecntN5[0] = new float[n12+2];
	    contig12.sitecntN6[0] = new float[n12+2];

	    contig12.fragSd[0] = new float[n12+2];
	    contig12.expSd[0] = new float[n12+2];
	    contig12.fragBias[0] = new float[n12+2];
	    contig12.fragCov[0] = new float[n12+2];
	    contig12.fragChiSq[0] = new float[n12+2];
	  }

	  /* Scan Y1 and Y2 from left to right based on location in original Hapmap Hcuts[] and fill in Hcuts12,HapSite12,HapDelta12,sitecnt12,sitemap1,sitemap2 */
	  int I1 = 0, I2 = 0, i12 = 0, i1= 0, i2 = 0;
	  int h = 0;/* number of homozygous labels + ends encountered : should add up to H+2 */
	  /* process unaligned/end labels left of Y1[0],Y2[0], which are the same location loc12 in Hcut12[] */
	  int ni1 = nmap1[I1];
	  int ni2 = nmap2[I2];
	  double loc1 = Hcuts1[ni1];/* location of Y1[0] on Hcuts1[] */
	  double loc2 = Hcuts2[ni2];/* location of Y2[0] on Hcuts2[] */
	  double loc12 = max(loc1,loc2);/* location of Y1[0] & Y2[0] on Hcuts12[] */
	  while(i1 < ni1 || i2 < ni2){
	    if(i2 >= ni2 || (i1 < ni1 && loc1 - Hcuts1[i1] > loc2 - Hcuts2[i2])){/* Hcuts1[i1] is left of Hcuts2[i2] */
	      /* map Hcuts1[i1] to Hcuts12[i12] */
	      if(DEBUG) assert(i1 < ni1);
	      if(DEBUG) assert(i12 <= n12+1);
	      nsitemap1[i1] = i12;
	      sitecnt12[i12] = sitecnt1[i1];
	      Hcuts12[i12] = loc12 - (loc1 - Hcuts1[i1]);
	      if(DEBUG && !(i12 <= n12+1 && 0.0 <= Hcuts12[i12] && Hcuts12[i12] <= loc12 + 1e-8)){
		printf("refid=%d(id=%lld),refid2=%d(id=%lld):i1=%d,ni1=%d,i2=%d,ni2=%d,loc1=%0.8f,Hcuts1[i1]=%0.8f,loc2=%0.8f,Hcuts2[i2]=%0.8f,i12=%d,n12=%d,loc12=%0.8f,Hcuts12[i12]=%0.8f,Hcuts12[i12-1]=%0.8f\n",
		       refid,rmap->id,refid2,rmap2->id,i1,ni1,i2,ni2,loc1,Hcuts1[i1],loc2,Hcuts2[i2],i12,n12,loc12,Hcuts12[i12],Hcuts12[i12-1]);
		printf("\t loc12 - Hcuts12[i12] = %0.8e\n",loc12-Hcuts12[i12]);
		fflush(stdout);
		assert(i12 <= n12+1 && 0.0 <= Hcuts12[i12] && Hcuts12[i12] <= loc12 + 1e-8);
	      }
	      if(DEBUG && i12 > 0 && !(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10)){
		printf("refid=%d,refid2=%d:i1=%d,ni1=%d,i2=%d,ni2=%d,loc1=%0.8f,Hcuts1[i1]=%0.8f,loc2=%0.8f,Hcuts2[i2]=%0.8f,i12=%d,loc12=%0.8f,Hcuts12[i12]=%0.8f,Hcuts12[i12-1]=%0.8f\n",
		       refid,refid2,i1,ni1,i2,ni2,loc1,Hcuts1[i1],loc2,Hcuts2[i2],i12,loc12,Hcuts12[i12],Hcuts12[i12-1]);
		fflush(stdout);
		assert(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10);
	      }
	      if(i12 > 0)
		Hcuts12[i12] = max(Hcuts12[i12],Hcuts12[i12-1]);
	      Hcuts12[i12] = min(Hcuts12[i12],loc12);
	      i12++;
	      i1++;
	    } else {/* Hcuts1[i1] is right of Hcuts2[i2] */
	      /* map Hcuts2[i2] to Hcuts12[i12] */
	      if(DEBUG) assert(i2 < ni2);
	      if(DEBUG) assert(i12 <= n12+1);
	      nsitemap2[i2] = i12;
	      sitecnt12[i12] = sitecnt2[i2];
	      Hcuts12[i12] = loc12 - (loc2 - Hcuts2[i2]);
	      if(DEBUG) assert(i12 <= n12+1 && 0.0 <= Hcuts12[i12] && Hcuts12[i12] <= loc12 + 1e-8);
	      if(DEBUG && i12 > 0) assert(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10);
	      if(i12 > 0)
		Hcuts12[i12] = max(Hcuts12[i12],Hcuts12[i12-1]);
	      Hcuts12[i12] = min(Hcuts12[i12],loc12);	      
	      i12++;
	      i2++;
	    }
	  }
	  if(DEBUG) assert(i1 == ni1 && i2 == ni2);
	  /* handle location of Y1[0] & Y2[0] on Hcuts12[] */
	  contig12.Y1 = contig12.left = loc12;
	  if(DEBUG) assert(sitecnt1[i1] <= 0.0);
	  if(DEBUG) assert(sitecnt2[i2] <= 0.0);
	  sitecnt12[i12] = 2;
	  if(DEBUG) assert(i1 <= n1+1);
	  if(DEBUG) assert(i2 <= n2+1);
	  nsitemap1[i1++] = i12;
	  nsitemap2[i2++] = i12;
	  if(DEBUG) assert(i12 <= n12+1);
	  Hcuts12[i12] = loc12;
	  if(I1 > 0 && I2 > 0){
	    HapSite12[i12] = 3;
	    if(Mask){
	      int I = sitemap1[I1];
	      if(DEBUG) assert(sitemap2[I2] == I);
	      if(DEBUG) assert(1 <= I && I <= m);
	      Mask12[i12] = Mask[I];
	    }
	  }

	  if(VERB>=2){
	    printf("Hcuts12[i12=%d]= %0.4f, I1=%d,I2=%d\n",i12,Hcuts12[i12],I1,I2);
	    fflush(stdout);
	  }
	  if(DEBUG) assert(i12 <= n12+1);
	  if(DEBUG && i12 > 0) assert(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10);
	  if(DEBUG) assert(h <= H+1);
	  int p12 = i12;/* next HapDelta update will be at HapDelta[p12] */

	  i12++;    
	  h++;
	  if(DEBUG) assert(i1+i2 == i12 + h);
	  while(I1 <= N1 && I2 <= N2){
	    if(DEBUG) assert(sitemap1[I1] == sitemap2[I2]);/* since Y1[I1] and Y2[I2] are the left end of Hcuts OR the same Homozygous site in Hcuts */
	    /* locate next Homozygous label pair Y1[nI1],Y2[nI2] */
	    int nI1 = I1+1;
	    int nI2 = I2+1;
	    while(nI1 <= N1 && HapSite[sitemap1[nI1]] != 3)
	      nI1++;
	    if(DEBUG) assert(nI1 > N1 || HapSite[sitemap1[nI1]] == 3);
	    while(nI2 <= N2 && HapSite[sitemap2[nI2]] != 3)
	      nI2++;
	    if(DEBUG) assert(nI2 > N2 || HapSite[sitemap2[nI2]] == 3);
	    if(DEBUG) assert(sitemap1[nI1] == sitemap2[nI2]);
	    if(DEBUG && nI1 > N1) assert(nI2 > N2);/* since Y1[nI1] and Y2[nI2] are the right end of Hcuts OR the same Homozygous site in Hcuts */
	    
	    ni1 = nmap1[nI1];
	    ni2 = nmap2[nI2];
	    /* interpolate labels within Y1[I1..nI1] and Y2[I2..nI2], corresponding to labels Hcuts1[i1..ni1-1] and Hcuts2[i2..ni2-1] */
	    double nloc1 = Hcuts1[ni1];
	    double nloc2 = Hcuts2[ni2];
	    if(DEBUG) assert(nloc1 > loc1 && nloc2 > loc2);
	    double len12 = (nloc1 - loc1 + nloc2 - loc2) * 0.5;/* interval size on Hcuts12 or Hcuts */
	    double nloc12 = loc12 + len12;/* location of next Homozygous site on Hcuts12 */

	    double Ilen1 = 1.0/(nloc1 - loc1);
	    double Ilen2 = 1.0/(nloc2 - loc2);

	    double totHapDelta = (nloc1 - loc1) - (nloc12 - loc12);
	    double incHapDelta = 0.0;
	    if(VERB>=2){
	      printf("I1=%d..%d,I2=%d..%d,i1=%d..%d,i2=%d..%d,p12=%d:loc1= %0.6f..%0.6f,loc2=%0.6f..%0.6f,loc12=%0.6f..%0.6f (%0.6f..%0.6f),HapSite12[p12]=%d\n",
		     I1,nI1,I2,nI2,i1,ni1,i2,ni2,p12,loc1,nloc1,loc2,nloc2,loc12,nloc12,loc12-contig12.left,nloc12-contig12.left,HapSite12[p12]);
	      fflush(stdout);
	    }

	    while(i1 < ni1 || i2 < ni2){
	      double inc1 = Hcuts1[min(ni1,i1)] - loc1;
	      double inc2 = Hcuts2[min(ni2,i2)] - loc2;
	      double f1 = inc1 * Ilen1;
	      double f2 = inc2 * Ilen2;
	      if(DEBUG && !(f1 <= 1.0 && f2 <= 1.0)){
		printf("i1=%d,ni1=%d,i2=%d,ni2=%d,loc1=%0.8f,nloc1=%0.8f,Hcuts1[i1]=%0.8f,loc2=%0.8f,nloc2=%0.8f,Hcuts2[i2]=%0.8f,f1=%0.8f,f2=%0.8f\n",
		       i1,ni1,i2,ni2,loc1,nloc1,Hcuts1[min(ni1,i1)], loc2, nloc2, Hcuts2[min(ni2,i2)], f1,f2);
		fflush(stdout);
		assert(f1 <= 1.0 && f2 <= 1.0);
	      }
	      if(i2 >= ni2 || (i1 < ni1 && f1 < f2)){/* Hcuts1[i1] is left of Hcuts2[i2] */
		/* map Hcuts1[i1] to Hcuts12[i12] */
		if(DEBUG)  assert(i1 < ni1);
		if(DEBUG) assert(i12 <= n12+1);
		nsitemap1[i1] = i12;
		sitecnt12[i12] = sitecnt1[i1];
		Hcuts12[i12] = loc12 + f1 * len12;

		while(nmap1[I1] < i1)
		  I1++;
		if(nmap1[I1] == i1){/* real site on Allele 1 */
		  if(DEBUG) assert(sitecnt1[i1] > 1.99f);
		  HapSite12[i12] = 1;
		  if(Mask){
		    int I = sitemap1[I1];
		    if(DEBUG) assert(1 <= I && I <= m);
		    Mask12[i12] = Mask[I];
		  }
		  double cumHapDelta = inc1 - (Hcuts12[i12] - loc12);
		  HapDelta12[p12] = cumHapDelta - incHapDelta;
		  if(DEBUG && !(HapSite12[p12] || fabs(HapDelta12[p12]) <= 1e-7)){
		    printf("\ti1=%d/%d,i12=%d:Hcuts12[i12]= %0.4f, Hcuts1[min(ni1,i1)]=%0.6f, f1= %0.8f, loc1= %0.8f, len12= %0.8f\n",i1,ni1,i12,Hcuts12[i12],Hcuts1[min(ni1,i1)],f1,loc1,len12);
		    printf("p12=%d,cumHapDelta= %0.8f, incHapDelta= %0.8f, HapDelta12[p12]= %0.8f, HapSite12[p12]= %d\n",p12,cumHapDelta,incHapDelta,HapDelta12[p12],HapSite12[p12]);
		    fflush(stdout);
		    assert(HapSite12[p12] || fabs(HapDelta12[p12]) <= 1e-7);
		  }

		  double origHapDelta = HapDelta12[p12];
		  if(!HapSite12[p12] || fabs(HapDelta12[p12]) <= 1e-7)// NEW7
		    HapDelta12[p12] = 0.0;
		  if(VERB>=2 || (DEBUG>=2 && origHapDelta && fabs(origHapDelta) <= 1e-7)){
		    printf("\tHapDelta12[p12=%d] = %0.8e -> %0.8f, HapSite12[%d,%d]= %d,%d\n",p12,origHapDelta, HapDelta12[p12],p12,i12,HapSite12[p12],HapSite12[i12]);
		    fflush(stdout);
		  }
		  p12 = i12;
		  incHapDelta = cumHapDelta;
		} else {
		  if(DEBUG) assert(sitecnt1[i1] < 1.99f);
		  if(DEBUG) assert(HapSite12[i12] == 0);
		}

		if(VERB>=2 && nmap1[I1] == i1){
		  printf("\ti1=%d/%d,i12=%d:Hcuts12[i12]= %0.6f, Hcuts1[min(ni1,i1)]=%0.6f, f1= %0.8f, loc1= %0.8f, len12= %0.8f\n",i1,ni1,i12,Hcuts12[i12],Hcuts1[min(ni1,i1)],f1,loc1,len12);
		  fflush(stdout);
		}
		if(DEBUG) assert(i12 <= n12+1 && 0.0 <= Hcuts12[i12] && Hcuts12[i12] <= nloc12 + 1e-8);
		if(DEBUG && i12 > 0) assert(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10);
		i12++;
		i1++;
		if(DEBUG) assert(i1+i2 == i12 + h);
	      } else {/* Hcuts1[i1] is right of Hcuts2[i2] */
		/* map Hcuts2[i2] to Hcuts12[i12] */
		if(DEBUG) assert(i2 < ni2);
		if(DEBUG) assert(i12 <= n12+1);
		nsitemap2[i2] = i12;
		sitecnt12[i12] = sitecnt2[i2];
		Hcuts12[i12] = loc12 + f2 * len12;

		while(nmap2[I2] < i2)
		  I2++;
		if(nmap2[I2] == i2){/* real site on Allele2 */
		  if(DEBUG) assert(sitecnt2[i2] > 1.99f);
		  HapSite12[i12] = 2;
		  if(Mask){
		    int I = sitemap2[I2];
		    if(DEBUG) assert(1 <= I && I <= m);
		    Mask12[i12] = Mask[I];
		  }
		  double cumHapDelta = (Hcuts12[i12] - loc12) - inc2;
		  HapDelta12[p12] = cumHapDelta - incHapDelta;
		  if(DEBUG && !(HapSite12[p12] || fabs(HapDelta12[p12]) <= 1e-7)){
		    printf("\ti2=%d/%d,i12=%d:Hcuts12[i12]= %0.4f, Hcuts2[min(ni2,i2)]=%0.6f, f2= %0.8f, loc2= %0.8f, len12= %0.8f\n",i2,ni2,i12,Hcuts12[i12],Hcuts2[min(ni2,i2)],f2,loc2,len12);
		    printf("p12=%d,cumHapDelta= %0.8f, incHapDelta= %0.8f, HapDelta12[p12]= %0.8f, HapSite12[p12]= %d\n",p12,cumHapDelta,incHapDelta,HapDelta12[p12],HapSite12[p12]);
		    fflush(stdout);
		    assert(HapSite12[p12] || fabs(HapDelta12[p12]) <= 1e-7);
		  }

		  double origHapDelta = HapDelta12[p12];
		  if(!HapSite12[p12] || fabs(HapDelta12[p12]) <= 1e-7)
		    HapDelta12[p12] = 0.0;
		  if(VERB>=2 || (DEBUG>=2 && origHapDelta && fabs(origHapDelta) <= 1e-7)){
		    printf("\tHapDelta12[p12=%d] = %0.8e -> %0.8f,HapSite12[%d,%d]= %d,%d\n",p12,origHapDelta,HapDelta12[p12],p12,i12,HapSite12[p12],HapSite12[i12]);
		    fflush(stdout);
		  }
		  p12 = i12;
		  incHapDelta = cumHapDelta;
		} else {
		  if(DEBUG) assert(sitecnt2[i2] < 1.99f);
		  if(DEBUG) assert(HapSite12[i12] == 0);
		}

		if(VERB>=2 && nmap2[I2]==i2){
		  printf("\ti2=%d/%d,i12=%d:Hcuts12[i12]= %0.6f, Hcuts2[min(ni2,i2)]=%0.6f, f2= %0.8f, loc2= %0.8f, len12= %0.8f\n",i2,ni2,i12,Hcuts12[i12],Hcuts2[min(ni2,i2)],f2,loc2,len12);
		  fflush(stdout);
		}
		if(DEBUG) assert(i12 <= n12+1 && 0.0 <= Hcuts12[i12] && Hcuts12[i12] <= nloc12 + 1e-8);
		if(DEBUG && i12 > 0) assert(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10);
		i12++;
		i2++;
		if(DEBUG) assert(i1+i2 == i12 + h);
	      }
	    }
	    if(DEBUG) assert(i1 == ni1 && i2 == ni2);
	    if(DEBUG) assert(i1 <= n1+1);
	    if(DEBUG) assert(i2 <= n2+1);
	    /* handle location of Y1[nI1] & Y2[nI2] on Hcuts12[] */
	    if(DEBUG && nI1 <= N1 && !(sitecnt1[i1] >= 1.99f)){
	      printf("nI1=%d,N1=%d: i1=%d,n1=%d,sitecnt1[i1]= %0.3e\n",nI1,N1,i1,n1,sitecnt1[i1]);
	      fflush(stdout);
	      assert(sitecnt1[i1] >= 1.99f);
	    }
	    if(DEBUG && nI1 > N1) assert(sitecnt1[i1] == 0.0f);
	    if(DEBUG && nI2 <= N2) assert(sitecnt2[i2] >= 1.99f);
	    if(DEBUG && nI2 > N2) assert(sitecnt2[i2] == 0.0f);
	    sitecnt12[i12] = 2;
	    nsitemap1[i1++] = i12;
	    nsitemap2[i2++] = i12;
	    if(DEBUG) assert(i12 <= n12+1);
	    Hcuts12[i12] = nloc12;

	    if(nI1 <= N1 && nI2 <= N2){
	      HapSite12[i12] = 3;
	      if(Mask){
		int I = sitemap1[nI1];
		if(DEBUG) assert(sitemap2[nI2] == I);
		if(DEBUG) assert(1 <= I && I <= m);
		Mask12[i12] = Mask[I];
	      }
	      HapDelta12[p12] = totHapDelta - incHapDelta;
	      if(DEBUG && !(HapSite12[p12] || fabs(HapDelta12[p12]) <= 1e-7)){
		printf("p12=%d,totHapDelta= %0.8f, incHapDelta= %0.8f, HapDelta12[p12]= %0.8f, HapSite12[p12]= %d\n",p12,totHapDelta,incHapDelta,HapDelta12[p12],HapSite12[p12]);
		fflush(stdout);
		assert(HapSite12[p12] || fabs(HapDelta12[p12]) <= 1e-7);
	      }
	      double origHapDelta = HapDelta12[p12];
	      if(!HapSite12[p12] || fabs(HapDelta12[p12]) <= 1e-7)
		HapDelta12[p12] = 0.0;
	      if(VERB>=2 || (DEBUG>=2 && origHapDelta && fabs(origHapDelta) <= 1e-7)){
		printf("\tHapDelta12[p12=%d] = %0.8e -> %0.8f, HapSite12[%d,%d]= %d,%d\n",p12,origHapDelta, HapDelta12[p12],p12,i12,HapSite12[p12],HapSite12[i12]);
		fflush(stdout);
	      }
	      p12 = i12;
	    }
	    if(DEBUG) assert(i12 <= n12+1);
	    if(DEBUG && i12 > 0) assert(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10);// NEW2
	    if(DEBUG) assert(h <= H+1);
	    i12++;
	    h++;
	    if(DEBUG) assert(i1+i2 == i12 + h);

	    /* start next Homozygous interval */
	    I1 = nI1;
	    I2 = nI2;
	    loc1 = nloc1;
	    loc2 = nloc2;
	    loc12 = nloc12;
	  }
	  if(DEBUG) assert(I1==N1+1);
	  if(DEBUG) assert(I2==N2+1);
	  /* process unaligned/end labels right of Y1[N1+1],Y2[N2+1], which have the same location loc12 in Hcuts12[] */
	  contig12.YN = contig12.right = loc12;
	  ni1 = nmap1[N1+1];
	  ni2 = nmap2[N2+1];
	  while(i1 <= n1+1 || i2 <= n2+1){
	    if(VERB>=3){
	      printf("i1=%d,n1=%d,i2=%d,n2=%d,i12=%d,n12=%d:loc12=%0.8f,loc1=%0.8f,loc2=%0.8f,Hcuts1[i1]=%0.8f,Hcuts2[i2]=%0.8f,Hcuts[i12-1]=%0.13f\n",
		     i1,n1,i2,n2,i12,n12,loc12,loc1,loc2,Hcuts1[min(n1+1,i1)],Hcuts2[min(n2+1,i2)],Hcuts12[i12-1]);
	      printf("\tHcuts[i12]= %0.13f,%0.13f, Hcuts1[i1] - loc1= %0.13f, Hcuts2[i2] - loc2= %0.13f\n",
		     (i1 <= n1+1 ? loc12 + (Hcuts1[min(n1+1,i1)] - loc1) : -1.0), (i2 <= n2+1 ? loc12 + (Hcuts2[min(n2+1,i2)] - loc2) : -1.0), 
		     Hcuts1[min(n1+1,i1)]-loc1, Hcuts2[min(n2+1,i2)] - loc2);
	      fflush(stdout);
	    }
	    if(i2 > n2+1 || (i1 <= n1+1 && Hcuts1[i1] - loc1 < Hcuts2[i2] - loc2)){/* Hcuts1[i1] is left of Hcuts2[i2] */
	      /* map Hcuts1[i1] to Hcuts12[i12] */
	      if(DEBUG) assert(i1 <= n1+1);
	      if(DEBUG) assert(i12 <= n12+1);
	      nsitemap1[i1] = i12;
	      sitecnt12[i12] = sitecnt1[i1];
	      Hcuts12[i12] = loc12 + (Hcuts1[i1] - loc1);
	      if(DEBUG) assert(i12 <= n12+1 && loc12 <= Hcuts12[i12] + 1e-8);// NEW2
	      if(DEBUG>=1+RELEASE && i12 > 0 && !(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10)){
		#pragma omp critical
		{
		  printf("i1=%d,n1=%d,i2=%d,n2=%d,i12=%d,n12=%d:loc12=%0.8f,loc1=%0.8f,loc2=%0.8f,Hcuts1[i1]=%0.8f,Hcuts2[i2]=%0.8f,Hcuts[i12-1]=%0.13f\n",
			 i1,n1,i2,n2,i12,n12,loc12,loc1,loc2,Hcuts1[min(n1+1,i1)],Hcuts2[min(n2+1,i2)],Hcuts12[i12-1]);
		  printf("\t Hcuts[i12]= %0.13f,%0.13f, Hcuts1[i1] - loc1= %0.13f, Hcuts2[i2] - loc2= %0.13f\n",
			 (i1 <= n1+1 ? loc12 + (Hcuts1[min(n1+1,i1)] - loc1) : -1.0), (i2 <= n2+1 ? loc12 + (Hcuts2[min(n2+1,i2)] - loc2) : -1.0), 
			 Hcuts1[min(n1+1,i1)]-loc1, Hcuts2[min(n2+1,i2)] - loc2);
		  printf("\t   i12=%d,Hcuts12[i12-1]= %0.6f, Hcuts12[i12]= %0.6f, Hcuts12[i12]-Hcuts12[i12-1]=%0.6e\n",i12,Hcuts12[i12-1],Hcuts12[i12],Hcuts12[i12]-Hcuts12[i12-1]);
		  fflush(stdout);
		  assert(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10);
		}
	      }
	      Hcuts12[i12] = max(Hcuts12[i12-1],Hcuts12[i12]);// NEW

	      i12++;
	      i1++;
	      if(DEBUG) assert(i1+i2 == i12 + h);
	    } else {/* Hcuts1[i1] is right of Hcuts2[i2] */
	      /* map Hcuts2[i2] to Hcuts12[i12] */
	      if(DEBUG) assert(i2 <= n2+1);
	      if(DEBUG) assert(i12 <= n12+1);
	      nsitemap2[i2] = i12;
	      sitecnt12[i12] = sitecnt2[i2];
	      Hcuts12[i12] = loc12 + (Hcuts2[i2] - loc2);
	      if(DEBUG) assert(i12 <= n12+1 && loc12 <= Hcuts12[i12]);
	      if(DEBUG>=1+RELEASE && i12 > 0) assert(Hcuts12[i12] >= Hcuts12[i12-1] - 1e-10);
	      Hcuts12[i12] = max(Hcuts12[i12-1],Hcuts12[i12]);// NEW

	      i12++;
	      i2++;
	      if(DEBUG) assert(i1+i2 == i12 + h);
	    }
	  }
	  if(DEBUG) assert(i1 == n1+2);
	  if(DEBUG) assert(i2 == n2+2);
	  if(DEBUG) assert(i12 == n12+2);
	  if(DEBUG) assert(h == H+2);

#if 0 // OLD CODE : not quite correct due to interpolation used to compute Hcuts12[], which does not exactly reproduce Hcuts[] + offset
	  double *HapDelta = rmap->contig->HapDelta[0];/* HapDelta[0..m+1] for input Hapmap */

#if DEBUG>=2
	  double *origHapDelta12 = new double[n12+2];
	  int *origHapSite12 = new int[n12+2];
	  size_t *origMask12 = new size_t[n12+2];

	  memcpy(origHapDelta12,HapDelta12,(n12+2)*sizeof(double));
	  memcpy(origHapSite12,HapSite12,(n12+2)*sizeof(int));
	  memcpy(origMask12,Mask12,(n12+2)*sizeof(size_t));
#endif

	  memset(HapDelta12, 0, (n12+2)*sizeof(double));
	  memset(Mask12, 0, (n12+2)*sizeof(size_t));
	  memset(HapSite12, 0, (n12+2)*sizeof(int));

	  /* rescan Y1[I1=0..N1] and Y2[I2=0..N2] to copy HapSite and HapDelta values to HapSite12 and HapDelta12 (all other values are 0) */
	  for(int I1 = 0; I1 <= N1; I1++){
	    int I = sitemap1[I1];
	    if(DEBUG) assert(0 <= I && I <= m);
	    int i1 = nmap1[I1];
	    if(DEBUG) assert(0 <= i1 && i1 <= n1);
	    int i12 = nsitemap1[i1];
	    if(DEBUG) assert(0 <= i12 && i12 <= n12);
	    if(DEBUG && I > 0) assert(HapSite[I] >= 1);
	    if(DEBUG && !(sitecnt12[i12] >= 1.99f)){
	      printf("I1=%d,N1=%d,I=%d,i1=%d,i12=%d,sitecnt12[i12]= %0.3f\n",I1,N1,I,i1,i12,sitecnt12[i12]);
	      fflush(stdout);
	      assert(sitecnt12[i12] >= 1.99f);
	    }
	    HapSite12[i12] = HapSite[I];
	    if(Mask)
	      Mask12[i12] = Mask[I];
	    if(DEBUG && i12 <= 0 && HapSite12[0]){
	      printf("I1=%d,N1=%d,I=%d,i1=%d,i12=%d,HapSite[I]=%d\n",I,N1,I,i1,i12,HapSite[I]);
	      fflush(stdout);
	    }
	    HapDelta12[i12] = HapDelta[I];
#if DEBUG>=2
	    if(HapSite12[i12] != origHapSite12[i12] || (Mask && Mask12[i12] != origMask12[i12]) || fabs(HapDelta12[i12] - origHapDelta12[i12]) > 1e-6){
	      if(Mask)
		printf("WARNING:I1=%d: I=%d,i1=%d,i12=%d,Hcuts12[i12]= %0.6f (%0.6f) : HapSite12[i12]= %d -> %d, Mask12[i12]= %lx -> %lx, HapDelta12[i12]= %0.7f -> %0.7f\n",
		       I1,I,i1,i12,Hcuts12[i12],Hcuts12[i12]-contig12.left,origHapSite12[i12],HapSite12[i12],origMask12[i12],Mask12[i12],origHapDelta12[i12],HapDelta12[i12]);
	      else
		printf("WARNING:I1=%d: I=%d,i1=%d,i12=%d,Hcuts12[i12]= %0.6f (%0.6f) : HapSite12[i12]= %d -> %d, HapDelta12[i12]= %0.7f -> %0.7f (delta= %0.7f)\n",
		       I1,I,i1,i12,Hcuts12[i12],Hcuts12[i12]-contig12.left,origHapSite12[i12],HapSite12[i12],origHapDelta12[i12],HapDelta12[i12],HapDelta12[i12]-origHapDelta12[i12]);
	    }
#endif
	  }
	  if(DEBUG && !(HapSite12[0]==0 && HapSite12[n12+1]==0)){
	    printf("n12=%d:HapSite12[0]=%d,HapSite12[n12+1]=%d\n",n12,HapSite12[0],HapSite12[n12+1]);
	    fflush(stdout);
	    assert(HapSite12[0]==0 && HapSite12[n12+1]==0);
	  }
	  for(int I2 = 0; I2 <= N2; I2++){
	    int I = sitemap2[I2];/* index in Hcuts */
	    if(DEBUG) assert(0 <= I && I <= m);
	    int i2 = nmap2[I2];/* index in Hcuts2 */
	    if(DEBUG) assert(0 <= i2 && i2 <= n2);
	    int i12 = nsitemap2[i2];/* index in Hcuts12 */
	    if(DEBUG) assert(0 <= i12 && i12 <= n12);
	    if(DEBUG && HapSite12[i12]) assert(HapSite12[i12] == 3 && HapSite[I] == 3);
	    if(DEBUG && I > 0) assert(HapSite[I] >= 1);
	    if(DEBUG) assert(sitecnt12[i12] >= 1.99f);
	    HapSite12[i12] = HapSite[I];
	    if(Mask)
	      Mask12[i12] = Mask[I];
	    if(DEBUG && HapDelta12[i12] != 0.0) assert(HapDelta12[i12] == HapDelta[I] && HapSite[I] == 3);
	    HapDelta12[i12] = HapDelta[I];
#if DEBUG>=2
	    if(HapSite12[i12] != origHapSite12[i12] || (Mask && Mask12[i12] != origMask12[i12]) || fabs(HapDelta12[i12] - origHapDelta12[i12]) > 1e-6){
	      if(Mask)
		printf("I2=%d: I=%d,i2=%d,i12=%d,Hcuts12[i12]= %0.6f (%0.6f) : HapSite12[i12]= %d -> %d, Mask12[i12]= %lx -> %lx, HapDelta12[i12]= %0.7f -> %0.7f\n",
		       I2,I,i2,i12,Hcuts12[i12],Hcuts12[i12]-contig12.left,origHapSite12[i12],HapSite12[i12],origMask12[i12],Mask12[i12],origHapDelta12[i12],HapDelta12[i12]);
	      else
		printf("I2=%d: I=%d,i2=%d,i12=%d,Hcuts12[i12]= %0.6f (%0.6f) : HapSite12[i12]= %d -> %d, HapDelta12[i12]= %0.7f -> %0.7f (delta= %0.7f)\n",
		       I2,I,i2,i12,Hcuts12[i12],Hcuts12[i12]-contig12.left,origHapSite12[i12],HapSite12[i12],origHapDelta12[i12],HapDelta12[i12], HapDelta12[i12]-origHapDelta12[i12]);
	      fflush(stdout);
	      assert(HapSite12[i12] == origHapSite12[i12]);
	      assert(fabs(HapDelta12[i12] - origHapDelta12[i12]) < 0.100);
	    }
#endif
	  }

#if DEBUG>=2
	  delete [] origHapSite12;
	  delete [] origHapDelta12;
	  delete [] origMask12;
#endif

	  if(DEBUG)
	    for(int i12 = 1; i12 <= n12; i12++)
	      if(HapDelta12[i12]) 
		assert(HapSite12[i12]);
	  if(DEBUG) assert(HapSite12[0]==0 && HapSite12[n12+1]==0);
#endif // OLD CODE

	  if(DEBUG){
	    /* check that all HapDelta[i] values are zero if HapSite[i]==0 */
	    for(int i = 1; i <= n12; i++){
	      if(!HapSite12[i] && HapDelta12[i]){
		printf("i=%d,n12=%d:HapSite12[i]=%d,HapDelta12[i]= %0.10f\n",i,n12,HapSite12[i],HapDelta12[i]);
		fflush(stdout);
		assert(!HapDelta12[i]);
	      }
	      if(HapDelta12[i]){
		/* also check that fabs(HapDelta12[i]) does not exceed Hcuts[R] - Hcuts[i], where R is next site with HapSite12[R] != 0 */
		assert(HapSite12[i]);

		int R = i+1;
		while(R <= n12 && !HapSite12[R])
		  R++;
		if(!(fabs(HapDelta12[i] <= Hcuts12[R] - Hcuts12[i] + 1e-8))){
		  if(VERB/* HERE >=2*/){
		    printf("WARNING:i=%d,n12=%d,R=%d:HapSite12[i,R]=%d,%d, HapDelta12[i]= %0.10f, Hcuts[i,R]= %0.8f,%0.8f (%0.8f,%0.8f) (delta= %0.10f)\n",
			   i,n12,R,HapSite12[i],HapSite12[R],HapDelta12[i],Hcuts12[i],Hcuts12[R],Hcuts12[i]-contig12.left,Hcuts12[R]-contig12.left,Hcuts12[R]-Hcuts12[i]);
		    fflush(stdout);
		    //		    assert(fabs(HapDelta12[i] <= Hcuts12[R]-Hcuts12[i] + 1e-8));
		  }
		  HapDelta12[i] = copysign(Hcuts12[R] - Hcuts12[i], HapDelta12[i]);
		  assert(fabs(HapDelta12[i] <= Hcuts12[R]-Hcuts12[i] + 1e-8));
		}
	      }
	    }
	  }

	  if(VERB>=2){
	    printf("\tN1=%d,N2=%d,m=%d,n12=%d,n1=%d,n2=%d:contig1.nummaps=%d,contig2.nummaps=%d: finding matching maps for contig1 & contig2: cum wall= %0.6f secs\n",N1,N2,m,n12,n1,n2,contig1.nummaps,contig2.nummaps,wtime());
	    fflush(stdout);
	  }

	  /* combine all the maps in contig1 and contig2 : maps that are present in only contig1 or contig2 will have their alignment duplicated for the other Allele */
	  int *idmap1 = new int[contig1.nummaps];
	  int *idmap2 = new int[contig2.nummaps];
	  int *match1 = new int[contig1.nummaps];
	  int *match2 = new int[contig2.nummaps];
	  for(int i = contig1.nummaps; --i >= 0;){
	    idmap1[i] = i;
	    match1[i] = -1;
	  }
	  for(int i = contig2.nummaps; --i >= 0;){
	    idmap2[i] = i;
	    match2[i] = -1;
	  }
	  
	  /* sort map1[m = 0 .. contig1.nummaps-1] so contig1.contig[map1[m]].mapid are in ascending order of m */
	  gcontig = &contig1;
	  qsort(idmap1, contig1.nummaps, sizeof(int), (intcmp*) CcontigMapidInc);

	  /* sort map2[t = 0 .. contig2.nummaps-1] so contig2.contig[map2[t]].mapid are in ascending order of t */
	  gcontig = &contig2;
	  qsort(idmap2, contig2.nummaps, sizeof(int), (intcmp*) CcontigMapidInc);

	  gcontig = NULL;

	  if(VERB>=3){
	    printf("\t After allocating data structures for matching maps for contig1 & contig2: cum wall= %0.6f secs\n",wtime());
	    fflush(stdout);
	  }

	  /* Try to match up each map/matchgroup contig1.contig[m] with a map/matchgroup contig2.contig[t] and set match1[m] = t and match2[t] = m. 
	     If there is more than one match (due to -MultiMatch), for now we just pick the first match that is not already taken by another matchgroup */
	  if(1){
	    int m = 0, t = 0;
	    for(; m < contig1.nummaps; m++){
	      int mmap = idmap1[m];
	      int mapid1 = contig1.contig[mmap].mapid;
	      for(; t < contig2.nummaps; t++){
		int tmap = idmap2[t];
		int mapid2 = contig2.contig[tmap].mapid;
		if(mapid2 < mapid1)
		  continue;

		if(mapid2 > mapid1)
		  break;/* mapid2 are in ascending order, so subsequent values will not match mapid1 */

		if(/* mapid1 == mapid2 && */ contig1.flip[mmap] == contig2.flip[tmap] && match2[tmap] < 0){
		  if(DEBUG && !(contig1.contig[mmap].id == contig2.contig[tmap].id)){
		    printf("refid=%d,refid2=%d:contig1.contig[idmap1[m=%d/%d]=mmap=%d].mapid=%d,id=%lld; contig2.contig[idmap2[t=%d/%d]=tmap=%d].mapid=%d,id=%lld\n",
			   refid,refid2,m,contig1.nummaps,mmap,contig1.contig[mmap].mapid,contig1.contig[mmap].id,t,contig2.nummaps,tmap,contig2.contig[tmap].mapid,contig2.contig[tmap].id);
		    fflush(stdout);
		    assert(contig1.contig[mmap].id == contig2.contig[tmap].id);
		  }
		  if(DEBUG) assert(contig1.contig[mmap].numsite[0] == contig2.contig[tmap].numsite[0]);
		  match1[mmap] = tmap;
		  match2[tmap] = mmap;
		  break;
		}
	      }
	    }
	  }

	  if(VERB>=3){
	    printf("refid=%d,refid2=%d: After matching maps: cum wall= %0.6f secs\n",refid,refid2,wtime());
	    fflush(stdout);
	  }
	  
	  /* count number of maps in both alleles */
	  int MD = contig1.nummaps;
	  for(int t = 0; t < contig2.nummaps; t++)
	    if(match2[t] < 0)
	      MD++;

	  if(VERB/* HERE >=2 */){
	    printf("refid=%d,refid2=%d: alignments=%d,%d : Combined alignments for both Alleles (MD) = %d: cum wall= %0.6f secs\n",refid,refid2,contig1.nummaps,contig2.nummaps,MD,wtime());
	    fflush(stdout);
	  }

	  /* allocate contig12 arrays that depend on number of maps MD */
	  contig12.nummaps = MD;
	  contig12.contig = new Ccontig[MD];
	  contig12.flip = new int[MD];
	  contig12.sitemap[0] = new int*[MD];/* NOTE : sitemap and sitemapL are used by HaploTypeR for single Allele Cmap output. They are initialized based on best Allele so output_draft() can 
						be called right away (eg if MD < 2) */
	  contig12.sitemapL[0] = new int*[MD];
	  contig12.scale = new double[MD];
	  contig12.X[0] = new double*[MD];
	  contig12.align = new Calign*[MD];/* will be used to store the better of the two refalign alignments for each map */
	  contig12.maxoutlier = new double[MD];
	  contig12.mapWT = new double[MD];/* will be used to store the total weight of both matching alignments (if present) */
	  memset(contig12.mapWT, 0, MD * sizeof(double));
	  
	  int **map1 = new int*[MD + 1];
	  int **map2 = new int*[MD + 1];
	  int **mapK1 = new int*[MD];
	  int **mapK2 = new int*[MD];
	  map1[MD] = new int[n12+2];// follows convention of HaploType() : no allocation of map1[MD][-1] as in refine() for Gmap[MD][-1] 
	  map2[MD] = new int[n12+2];
	  if(DEBUG>=2){/* trigger out of bounds value if NOT initialized */
	    memset(map1[MD],-1,MD*sizeof(int));
	    memset(map2[MD],-1,MD*sizeof(int));
	  }

	  /* first copy all maps from contig1 */
	  for(int m = 0; m < contig1.nummaps; m++){
	    contig12.contig[m].mapid = contig1.contig[m].mapid;
	    int M = contig12.contig[m].numsite[0] = contig1.contig[m].numsite[0];
	    contig12.contig[m].trimL[0] = 0;
	    contig12.contig[m].trimR[0] = M+1;
	    contig12.flip[m] = contig1.flip[m];
	    contig12.scale[m] = contig1.scale[m];
	    contig12.X[0][m] = new double[M+2];
	    memcpy(contig12.X[0][m], contig1.X[0][m], (M+2)*sizeof(double));
	    contig12.sitemap[0][m] = new int[M+3];
	    *contig12.sitemap[0][m]++ = -1;
	    contig12.sitemapL[0][m] = new int[M+3];
	    *contig12.sitemapL[0][m]++ = -1;

	    map1[m] = new int[M+3];
	    *map1[m]++ = -1;
	    map2[m] = new int[M+3];
	    *map2[m]++ = -1;
	    mapK1[m] = new int[M+3];
	    *mapK1[m]++ = -1;
	    mapK2[m] = new int[M+3];
	    *mapK2[m]++ = -1;

	    if(DEBUG) assert(contig1.sitemap[0] && contig1.sitemap[0][m]);
	    for(int J = 0; J <= M+1; J++)
	      map1[m][J] = nsitemap1[contig1.sitemap[0][m][J]];
	    for(int J = 0; J <= M+1; J++)
	      mapK1[m][J] = 0;
	    if(contig1.sitemapL[0] && contig1.sitemapL[0][m])
	      for(int J = 0; J <= M+1; J++)
		mapK1[m][J] = map1[m][J] - nsitemap1[contig1.sitemapL[0][m][J]];

	    contig12.mapWT[m] += contig1.align[m]->mapWT;

	    int t = match1[m];
	    if(t < 0){/* map m is present in Allele 1 only */
	      contig12.align[m] = contig1.align[m];
	      contig12.maxoutlier[m] = contig1.align[m]->maxoutlier;
	      if(contig1.sitemapL[0] && contig1.sitemapL[0][m])
		for(int J = 0; J <= M+1; J++)
		  contig12.sitemapL[0][m][J] = nsitemap1[contig1.sitemapL[0][m][J]];
	      for(int J = 0; J <= M+1; J++){
		contig12.sitemap[0][m][J] = nsitemap1[contig1.sitemap[0][m][J]];
		map2[m][J] = map1[m][J];
		mapK2[m][J] = mapK1[m][J];
	      }
	    } else {
	      if(DEBUG) assert(match2[t] == m);
	      contig12.mapWT[m] += contig2.align[t]->mapWT;

	      if(contig1.align[m]->logPV > contig2.align[t]->logPV){
		contig12.align[m] = contig1.align[m];
		contig12.maxoutlier[m] = contig1.maxoutlier[m];
		for(int J = 0; J <= M+1; J++)
		  contig12.sitemap[0][m][J] = nsitemap1[contig1.sitemap[0][m][J]];
		if(contig1.sitemapL[0] && contig1.sitemapL[0][m])
		  for(int J = 0; J <= M+1; J++)
		    contig12.sitemapL[0][m][J] = nsitemap1[contig1.sitemapL[0][m][J]];
	      } else {
		contig12.align[m] = contig2.align[t];
		contig12.maxoutlier[m] = contig2.align[t]->maxoutlier;
		for(int J = 0; J <= M+1; J++)
		  contig12.sitemap[0][m][J] = nsitemap2[contig2.sitemap[0][t][J]];
		if(contig2.sitemapL[0] && contig2.sitemapL[0][m])
		  for(int J = 0; J <= M+1; J++)
		    contig12.sitemapL[0][m][J] = nsitemap2[contig2.sitemapL[0][t][J]];
	      }
	      for(int J = 0; J <= M+1; J++)
		map2[m][J] = nsitemap2[contig2.sitemap[0][t][J]];
	      for(int J = 0; J <= M+1; J++)
		mapK2[m][J] = 0;
	      if(contig2.sitemapL[0] && contig2.sitemapL[0][t])
		for(int J = 0; J <= M+1; J++)
		  mapK2[m][J] = map2[m][J] - nsitemap2[contig2.sitemapL[0][t][J]];
	    }
	  }

	  /* next copy unmatched matchgroups from contig2 */
	  int mcnt = contig1.nummaps;
	  for(int t = 0; t < contig2.nummaps; t++){
	    if(match2[t] >= 0)
	      continue;
	    
	    /* map mcnt is present in Allele 2 only */
	    contig12.contig[mcnt].mapid = contig2.contig[t].mapid;
	    int M = contig12.contig[mcnt].numsite[0] = contig2.contig[t].numsite[0];
	    contig12.contig[mcnt].trimL[0] = 0;
	    contig12.contig[mcnt].trimR[0] = M+1;
	    contig12.flip[mcnt] = contig2.flip[t];
	    contig12.scale[mcnt] = contig2.scale[t];
	    contig12.X[0][mcnt] = new double[M+2];
	    memcpy(contig12.X[0][mcnt], contig2.X[0][t], (M+2)*sizeof(double));
	    contig12.sitemap[0][mcnt] = new int[M+3];
	    *contig12.sitemap[0][mcnt]++ = -1;
	    contig12.sitemapL[0][mcnt] = new int[M+3];
	    *contig12.sitemapL[0][mcnt]++ = -1;

	    map1[mcnt] = new int[M+3];
	    *map1[mcnt]++ = -1;
	    map2[mcnt] = new int[M+3];
	    *map2[mcnt]++ = -1;
	    mapK1[mcnt] = new int[M+3];
	    *mapK1[mcnt]++ = -1;
	    mapK2[mcnt] = new int[M+3];
	    *mapK2[mcnt]++ = -1;

	    if(DEBUG) assert(contig2.sitemap[0] && contig2.sitemap[0][t]);
	    for(int J = 0; J <= M+1; J++)
	      map1[mcnt][J] = nsitemap2[contig2.sitemap[0][t][J]];
	    for(int J = 0; J <= M+1; J++)
	      mapK1[mcnt][J] = 0;
	    if(contig2.sitemapL[0] && contig2.sitemapL[0][t])
	      for(int J = 0; J <= M+1; J++)
		mapK1[mcnt][J] = map1[mcnt][J] - nsitemap2[contig2.sitemapL[0][t][J]];
	    
	    contig12.mapWT[mcnt] += contig2.align[t]->mapWT;

	    contig12.align[mcnt] = contig2.align[t];
	    if(contig2.sitemapL[0] && contig2.sitemapL[0][m])
	      for(int J = 0; J <= M+1; J++)
		contig12.sitemapL[0][m][J] = nsitemap2[contig2.sitemapL[0][t][J]];
	    for(int J = 0; J <= M+1; J++){
	      contig12.sitemap[0][mcnt][J] = nsitemap2[contig2.sitemap[0][t][J]];
	      map2[mcnt][J] = map1[mcnt][J];
	      mapK2[mcnt][J] = mapK1[mcnt][J];
	    }

	    mcnt++;
	  }
	  if(DEBUG) assert(mcnt == contig12.nummaps);

	  /* compute Lfrozen,Rfrozen */

	  int Lfrozen = 0, Rfrozen = 0;
	  if(Refine){ 
	    if(extend >= 2 && extendonly){
	      printf("Extension only refinement of previously Haplotyped Cmap not supported (extend=%d, extendonly=%d)\n", extend, extendonly);
	      fflush(stdout);exit(1);
	    } else if(extend <= 1) {
	      /* locate range of Hcuts[Lfrozen..Rfrozen] that corresponds to original map reference region contig12.left .. contig12..right :
		 Any extension regions will not be modifed in refine() (and hence will have no sites and be trimmed to MININTERVAL in output_draft())
	      */

	      /* If needed, round to nearest site to make region larger (since the frozen region is outside this region ) */
	      for(int i = 1; i <= n12; i++)
		if(contig12.site[0][i] >= contig12.left - 1e-6){
		  Lfrozen = Rfrozen = max(0,i-1);
		  break;
		}
	      for(int i = n12; i >= 1; i--)
		if(contig12.site[0][i] <= contig12.right + 1e-6){
		  Rfrozen = min(n12+1,i+1);
		  break;
		}
	    }

	    contig12.Lfrozen = contig12.site[0][Lfrozen];
	    contig12.Rfrozen = contig12.site[0][Rfrozen ? Rfrozen : n12+1];

	    if(rmap->Mask[0]){
	      /* copy end mask information to contig : note Mask[0][i = 0..m+1] index corresponds to original HapMap index */
	      contig12.MaskL = rmap->Mask[0][1] & ~SegDupMask;
	      contig12.MaskR = rmap->Mask[0][m+1] & ~SegDupMask;
	      if(VERB/* HERE >=2 */){
		printf("rmap->id= %lld: contig12.MaskL = 0x%lx, contig12.MaskR = 0x%lx, n12=%d\n",rmap->id, contig12.MaskL, contig12.MaskR,n12);
		fflush(stdout);
	      }
	      
	      if(SegDupMask){   /* copy SegDup mask information to contig12 */
		int LI = -1, RI = -1;
		contig12.SegDupCnt = 0;
		if(contig12.SegDupMax < 16){
		  if(contig12.SegDupStart)
		    delete [] contig12.SegDupStart;
		  if(contig12.SegDupEnd)
		    delete [] contig12.SegDupEnd;
		  contig12.SegDupMax = 16;
		  contig12.SegDupStart = new double[contig12.SegDupMax];
		  contig12.SegDupEnd = new double[contig12.SegDupMax];
		}

		double Ilen = 1.0/max(0.001, contig12.right - contig12.left);

		for(int I = 1; I <= n12; I++){
		  if(HapSite12[I] && (Mask12[I] & SegDupMask)){
		    LI = I;
		    int pI = I;
		    for(I++; I <= n12+1; I++){
		      if(HapSite12[I]){
			if(!(Mask12[I] & SegDupMask)){
			  RI = pI;
			  break;
			}
			pI = I;
		      }
		    }
		    if(I > n12)
		      RI = n12;

		    if(DEBUG) assert( 1 <= LI && LI <= RI && RI <= n12);

		    int li = LI, ri = RI;
		    for(;--li > 0;)
		      if(HapSite12[li])
			break;
		    for(;++ri <= n12;)
		      if(HapSite12[ri])
			break;

		    if(contig12.SegDupCnt + 1 >= contig12.SegDupMax){
		      contig12.SegDupMax = (contig12.SegDupCnt + 1) * 2;
		      double *nSegDupStart = new double[contig12.SegDupMax];
		      double *nSegDupEnd = new double[contig12.SegDupMax];
		      memcpy(nSegDupStart,contig12.SegDupStart, contig12.SegDupCnt * sizeof(double));
		      memcpy(nSegDupEnd,contig12.SegDupEnd, contig12.SegDupCnt * sizeof(double));
		      delete [] contig12.SegDupStart; contig12.SegDupStart = nSegDupStart;
		      delete [] contig12.SegDupEnd; contig12.SegDupEnd = nSegDupEnd;
		    }
		    if(DEBUG) assert(contig12.SegDupCnt < contig12.SegDupMax);

		    contig12.SegDupStart[contig12.SegDupCnt] = max(0.0, (contig12.site[0][li] - contig12.left) * Ilen);
		    contig12.SegDupEnd[contig12.SegDupCnt] = min(1.0, (contig12.site[0][ri] - contig12.left) * Ilen);
		    if(VERB/* HERE >=2 */){
		      int S = contig12.SegDupCnt;
		      printf("rmap->id=%lld: LI=%d,RI=%d,n12=%d,left=%0.4f,contig12[%d,%d]=%0.4f,%0.4f,right=%0.4f: SegDupStart[%d]= %0.6f, SegDupEnd[%d]= %0.6f\n",
			     rmap->id, LI, RI, n12, contig12.left,li,ri,contig12.site[0][li],contig12.site[0][ri],contig12.right, S,contig12.SegDupStart[S],S,contig12.SegDupEnd[S]);
		      fflush(stdout);
		    }

		    contig12.SegDupCnt++;
		    LI = RI = -1;
		  }
		}
	      }
	    }
	  }

	  if(DEBUG) assert(fabs(resSD[0] - resSDorig) < 1e-10);

	  contig12.totalsites = -1;

	  if(origCMapID > 0 || numrefmaps > 0 || CMapID != rmap->id){
	    /* Adjust global CMapID to reflect id of reference contig */
	    if(rmap->id < 0){
	      printf("refid=%d: id=%lld : negative values are not supported with -id 0 or multiple contigs\n", refid, rmap->id);
	      fflush(stdout);exit(1);
	    }
	  
	    if(VERB/* >=2 */){
	      printf("refid=%d/%d:Changing CMapID from %lld to %lld\n",refid, numrefmaps, CMapID, rmap->id);
	      fflush(stdout);

	      //	      if(CMapID == 5 && rmap->id == 1000005) exit(1);
	    }

	    if(DEBUG) assert(rmap->id <= (long long)MASK_LL(63) && rmap->id > 0);

	    CMapID = rmap->id;
	    if(CMapID <= 0){
	      printf("refid=%d: id=%lld: WARNING: 0 contig id value will result in missing ID in output file name of refined contig\n", refid, rmap->id);
	      fflush(stdout);
	    }
	  }

	  if(VERB/* HERE HERE >=2 */ && LogPvThreshold != min(origLogPvThreshold,LogPvThresholdTE)){
	    printf("Restoring LogPvThreshold %0.2f -> %0.2f\n",LogPvThreshold, min(origLogPvThreshold,LogPvThresholdTE));
	    fflush(stdout);
	  }
	  LogPvThreshold = min(origLogPvThreshold,LogPvThresholdTE);
	  
	  if(contig12.nummaps >= 2){
	    if(VERB>=2){
	      printf("refid=%d:contig12.nummaps=%d\n",refid,contig12.nummaps);
	      fflush(stdout);
	    }

	    if(DEBUG) assert(contig12.mapWT != NULL);

	    // NOTE : -Erefine does not apply during HaploTyping or ChimQuality computation, so is ignored here

	    if(VERB>=2 && (Lfrozen || Rfrozen)){
	      printf("Calling HaploTypeR():Lfrozen=%d(%0.3f),Rfrozen=%d(%0.3f),contig12.left=%0.3f,contig12.right=%0.3f,Len=%0.3f\n",
		     Lfrozen,contig12.site[0][Lfrozen],Rfrozen,contig12.site[0][Rfrozen],contig12.left,contig12.right,contig12.site[0][contig12.numsite[0]+1]);
	      fflush(stdout);
	    }

	    int origRefine = Refine;
	    double origEndTrimCov = EndTrimCov;
	    if(MaxContigSiteDensity > 0.0 && Refine > 1){/* check if this contig should NOT be refined due to high site density */
	      if(N1+N2 > 2 && (N1+N2-2)*50.0 > MaxContigSiteDensity * (contig12.right - contig12.left)){
		if(VERB){
		  printf("Skipping full haplotype refinement of contig%lld due to label density = %0.2f / 100kb (using -refine 1 instead)\n", refmap[refid]->id, ((N1+N2-2) * 50.0)/ (contig12.right-contig12.left));
		  fflush(stdout);
		}
		Refine = 1;
		EndTrimCov = 0.0;
	      }
	    }

	    if(contig12.nummaps < 4){
	      if(VERB){
		printf("Skipping full haplotype refinement of contig%lld due to too few maps = %d (using -refine 1 instead)\n", refmap[refid]->id, contig12.nummaps);
		fflush(stdout);
	      }
	      Refine = 1;
	      EndTrimCov = 0.0;
	    }

	    /* free up memory for contig.align[m] */
	    if(contig12.align){
	      delete [] contig12.align;
	      contig12.align = NULL;
	    }
	    if(contig1.align){
	      delete [] contig1.align;
	      contig1.align = NULL;
	    }
	    if(contig2.align){
	      delete[] contig2.align;
	      contig2.align = NULL;
	    }

	    /* call refineHap() : this sets up skip[], TBmapWT and some global variables before calling HaploTypeR() */
	    try {
	      refineHap(&contig12, map1, mapK1, map2, mapK2, Lfrozen, Rfrozen);
	    } catch (exception& e){
	      cout << e.what() << endl;
	      printf("refalign_allpairs : refineHap() threw an exception\n");
	      fflush(stdout);
	      assert(0);
	    }
	    //	    if(DEBUG) assert(contig12.HapSite[0]);

	    long long startCMapID = CMapID;
	    double startContigSplitRatio = ContigSplitRatio;

	    /* output refined contig as .cmap OR .hmap file (uses global CMapID value) */
	    output_draft(&contig12, -rmap->id, draft_prefix, Lfrozen, Rfrozen, 0);

	    CMapID = startCMapID;
	    ContigSplitRatio = startContigSplitRatio;

	    Refine = origRefine;
	    EndTrimCov = origEndTrimCov;

	  } else {/* too few maps to refine contig */
	    double origEndTrimCov = EndTrimCov;
	    double origContigSplitRatio = ContigSplitRatio;
	    //	    EndTrimCov = 0.0; // NOTE : Need to allow trimming away of entire map, to avoid spurious contigs below -L size
	    ContigSplitRatio = 0.0;

	    if(extendonly && Refine <= 2)
	      printf("Unable to haplotype refine reference map since only %d maps aligned with it AND extended beyond original consensus\n",contig12.nummaps);
	    else
	      printf("Unable to haplotype refine reference map since only %d maps aligned with it\n",contig12.nummaps);
	    if(EndTrimCov < 2.0)
	      printf("Reference map left unchanged\n");
	    fflush(stdout);

	    /* set sitecnt[i] = 0 unless it is consensus site (ie sitecnt[i] >= 1.99f) */
	    /* Also set fragcnt and sitecntFN to 0 except at the original consensus sites, where it is set to 2.0 */
	    contig12.fragcnt[0][0] = 0.0f;
	    int first = -1;
	    int last = -1;
	    for(int i = 1; i <= n12; i++){
	      if(VERB>=2){
		printf("i=%d,n12=%d:sitecnt[i]=%0.1f,site[i]=%0.3f\n",i,n12,contig12.sitecnt[0][i],contig12.site[0][i]);
		fflush(stdout);
	      }
	      if(contig12.sitecnt[0][i] <= 1.5f)
		contig12.sitecnt[0][i] = 0;
	      else {
		last = i;
		if(first < 0)
		  first = i;
	      }
	      contig12.sitecntFN[0][i] = contig12.fragcnt[0][i] = contig12.fragcntT[0][i] = 0.0f;
	      for(int t = 0; t < mCNT; t++)
		contig12.sitecntN1[0][t][i] = 0.0f;
	      if(CovNorm)
		contig12.fragcntTnorm[0][i] = 0.0f;
	      if(TrimNorm >= 0)
		contig12.sitecntFNnorm[0][i] = contig12.sitecntN2[0][i] = contig12.sitecntN3[0][i] = contig12.sitecntN4[0][i] = contig12.sitecntN5[0][i] = contig12.sitecntN6[0][i] = 
		  contig12.fragSd[0][i] = contig12.expSd[0][i] = contig12.fragBias[0][i] = contig12.fragCov[0][i] = contig12.fragChiSq[0][i] = 0.0f;
	    }
	    if(VERB>=2){
	      printf("first=%d,last=%d,n12=%d\n",first,last,n12);
	      fflush(stdout);
	    }
	    if(first > 0)
	      for(int i = first;i <= last; i++){
		contig12.sitecntFN[0][i] = contig12.fragcnt[0][i] = contig12.fragcntT[0][i] = 2.0f;
		for(int t = 0; t < mCNT; t++)
		  contig12.sitecntN1[0][t][i] = 0.0f;
		if(TrimNorm >= 0){
		  contig12.sitecntFN[0][i] = 100.0f;
		  contig12.sitecntFNnorm[0][i] = 2.0f;
		}
	      }

	    output_draft(&contig12,0,draft_prefix, 0, 0, 0);

	    EndTrimCov = origEndTrimCov;
	    ContigSplitRatio = origContigSplitRatio;
	  }

	  for(int m = 0; m < contig12.nummaps; m++){
	    delete [] &map1[m][-1];
	    delete [] &map2[m][-1];
	    delete [] &mapK1[m][-1];
	    delete [] &mapK2[m][-1];
	  }
	  delete [] map1[MD];
	  delete [] map2[MD];
	  delete [] map1;
	  delete [] map2;
	  delete [] mapK1;
	  delete [] mapK2;
	  delete [] match1;
	  delete [] match2;
	  delete [] idmap1;
	  delete [] idmap2;
	  delete [] nsitemap1;
	  delete [] nsitemap2;

	  if(Lalignment2 != alignment)
	    delete [] Lalignment2;
	  delete [] alignids2;
	  delete [] nmap2;
	} else {/* start with a non-haplotyped map and call refine() */
	  /* add some aliases to allow original non-Haplotype code to refer to Allele1 (contig1) */
	  Ccontig &contig = contig1;
	  int &n = n1;
	  //	  int &maligncnt = maligncnt1;
	  //	  size_t *&alignids = alignids1;

	  int Lfrozen = 0, Rfrozen = 0;

	  if(Refine){
	    if(rmap->Mask[0]){
	      /* copy end mask information to contig */
	      contig.MaskL = rmap->Mask[0][1] & ~SegDupMask;
	      contig.MaskR = rmap->Mask[0][N+1] & ~SegDupMask;
	      if(VERB/* HERE >=2 */){
		printf("rmap->id= %lld: contig.MaskL = 0x%lx, contig.MaskR = 0x%lx, N=%d\n",rmap->id, contig.MaskL, contig.MaskR, N);
		fflush(stdout);
	      }

	      if(SegDupMask){   /* copy SegDup mask information to contig */
		int LI = -1, RI = -1;
		contig.SegDupCnt = 0;
		if(contig.SegDupMax < 16){
		  if(contig.SegDupStart)
		    delete [] contig.SegDupStart;
		  if(contig.SegDupEnd)
		    delete [] contig.SegDupEnd;
		  contig.SegDupMax = 16;
		  contig.SegDupStart = new double[contig.SegDupMax];
		  contig.SegDupEnd = new double[contig.SegDupMax];
		}

		double Ilen = 1.0/max(0.001, contig.right - contig.left);

		for(int I = 1; I <= N; I++){
		  if(rmap->Mask[0][I] & SegDupMask){
		    LI = I;
		    for(I++; I <= N+1; I++){
		      if(!(rmap->Mask[0][I] & SegDupMask)){
			RI = I-1;
			break;
		      }
		    }
		    if(I > N)
		      RI = N;

		    if(DEBUG) assert(1 <= LI && LI <= RI && RI <= N);

		    int li = nmap1[LI-1];
		    if(DEBUG) assert(0 <= li && li <= n1);
		    int ri = nmap1[RI+1];
		    if(DEBUG) assert(li <= ri && ri <= n1+1);

		    if(contig.SegDupCnt + 1 >= contig.SegDupMax){
		      contig.SegDupMax = (contig.SegDupCnt + 1) * 2;
		      double *nSegDupStart = new double[contig.SegDupMax];
		      double *nSegDupEnd = new double[contig.SegDupMax];
		      memcpy(nSegDupStart,contig.SegDupStart, contig.SegDupCnt * sizeof(double));
		      memcpy(nSegDupEnd,contig.SegDupEnd, contig.SegDupCnt * sizeof(double));
		      delete [] contig.SegDupStart; contig.SegDupStart = nSegDupStart;
		      delete [] contig.SegDupEnd; contig.SegDupEnd = nSegDupEnd;
		    }

		    if(DEBUG) assert(contig.SegDupCnt < contig.SegDupMax);

		    contig.SegDupStart[contig.SegDupCnt] = max(0.0, (contig.site[0][li] - contig.left) * Ilen);
		    contig.SegDupEnd[contig.SegDupCnt] = min(1.0, (contig.site[0][ri] - contig.left) * Ilen);
		    if(VERB/* HERE >=2 */){
		      int S = contig.SegDupCnt;
		      printf("rmap->id=%lld: contig.len= %0.3f, LI=%d,RI=%d,N=%d,li=%d,ri=%d,n=%d,left=%0.4f,site[li,ri]=%0.4f,%0.4f,right=%0.4f: SegDupStart[%d]= %0.6f, SegDupEnd[%d]= %0.6f\n",
			     rmap->id,contig.site[0][n+1], LI,RI,N,li,ri,n,contig.left,contig.site[0][li],contig.site[0][ri],contig.right,S,contig.SegDupStart[S],S,contig.SegDupEnd[S]);
		      fflush(stdout);
		    }
		    contig.SegDupCnt++;
		    LI = RI = -1;
		  }
		}
	      }
	    }

	    // need to adjust EndLen2 to also include any labels that will be deleted due to extTrim (even if extsplitNE==1)
	    if(extsplitExtOnly && refid >= orignumrefmaps){/* adjust -extonly and -maxExtend values for current E&S contig */
#if 0 // OLD
	      EndLen = extsplitExtOnly[refid];
	      if(!extsplitNE)
		EndLen = max(extsplitNEL, EndLen);
	      MaxExtend = max(max(extsplitNEE, origMaxExtend * 0.5), origMaxExtend - EndLen);
#else // NEW106
	      if(!extsplitNE){
		EndLen = max(extsplitNEL, extsplitExtOnly[refid]);
		MaxExtend = max(max(extsplitNEE, origMaxExtend * 0.5), origMaxExtend - EndLen);
	      }
#endif

	      if(extTrim)
		EndLen2 = extsplitExtOnly[refid];
	      else
		EndLen2 = min(origEndLen2, EndLen);
	      if(VERB/* HERE >=2 */){
		printf("Adjusted -extonly %0.3f %0.3f -> %0.3f %0.3f and -maxExtend %0.3f -> %0.3f due to -extTrim\n",origEndLen,origEndLen2,EndLen,EndLen2,origMaxExtend,MaxExtend);
		fflush(stdout);
	      }
	    }

	    if(extTrim && refid < orignumrefmaps)
	      extTrim = 0;// NEW57 : avoid using -extTrim on normal extension refinement (NOT a split contig), since the trimmed region is not refined during -endoutlierRef initial refinement 

	    /* locate range of Hcuts[Lfrozen..Rfrozen] that corresponds to original map reference region Y[0..N+1] :
	       1. If extend >= 2 && extendonly, this region (reduced by EndLen + (orig unlabeled end) at either end) will not be modified in refine() (and will NOT be trimmed in output_draft())
	       2. If extend <= 1, the remaining extension regions will not be modifed in refine() (and hence will have no sites and be trimmed to MININTERVAL in output_draft())
	    */

	    if(extend >= 2 && extendonly){
	      /* Initialize frozen region to original contig : If needed, round to nearest site to make frozen region smaller */
	      for(int i = 1; i <= n; i++)
		if(contig.site[0][i] >= contig.left + 1e-6){
		  Lfrozen = Rfrozen = i;
		  break;
		}
	      for(int i = n; i >= 1; i--)
		if(contig.site[0][i] <= contig.right - 1e-6){
		  Rfrozen = i;
		  break;
		}

	      if(VERB/* HERE HERE >=2 */){
		if(rmap->Mask[0])
		  printf("Initializing Lfrozen=%d, Rfrozen=%d, n=%d : left= %0.3f, right= %0.3f, site[Lfrozen,Rfrozen,n+1]= %0.3f,%0.3f,%0.3f, MaskL= x%lx, MaskR= x%lx: Mask[1]= x%lx, Mask[N+1]= x%lx\n",
			 Lfrozen,Rfrozen,n,contig.left,contig.right,contig.site[0][Lfrozen],contig.site[0][Rfrozen],contig.site[0][n+1], contig.MaskL, contig.MaskR, rmap->Mask[0][1],rmap->Mask[0][N+1]);
		else
		  printf("Initializing Lfrozen=%d, Rfrozen=%d, n=%d : left= %0.3f, right= %0.3f, site[Lfrozen,Rfrozen,n+1]= %0.3f,%0.3f,%0.3f, MaskL= x%lx, MaskR= x%lx: Mask = NULL\n",
			 Lfrozen,Rfrozen,n,contig.left,contig.right,contig.site[0][Lfrozen],contig.site[0][Rfrozen],contig.site[0][n+1],contig.MaskL,contig.MaskR);
		fflush(stdout);
	      }

	      if((!extendSplit || CloneLimitLen > 0.0) && rmap->Mask[0]){// NEW95 : also apply without extendSplit
		if((rmap->Mask[0][1] & (END_NOEXT | END_NOEXT2))){
		  if(VERB/* HERE HERE >=2*/){
		    printf("Before Refining refid=%d(id=%lld),ExtLen=%0.3f,left=%0.3f,right=%0.3f:Blocking extension of left end by expanding frozen region of %0.3f..%0.3f to 0.000..%0.3f:Lfrozen -> 0\n",
			   refid,rmap->id,contig.site[0][n+1],contig.left,contig.right,contig.site[0][Lfrozen],contig.site[0][Rfrozen],contig.site[0][Rfrozen]);
		    fflush(stdout);
		  }
		  Lfrozen = 0;
		}
		if((rmap->Mask[0][N+1] & (END_NOEXT | END_NOEXT2))){
		  if(VERB/* HERE HERE >=2 */){
		    printf("Before Refining refid=%d(id=%lld),ExtLen=%0.3f,left=%0.3f,right=%0.3f:Blocking extension of right end by expanding frozen region of %0.3f..%0.3f to %0.3f..%0.3f:Rfrozen -> %d\n",
			   refid,rmap->id,contig.site[0][n+1],contig.left,contig.right,contig.site[0][Lfrozen],contig.site[0][Rfrozen],contig.site[0][Lfrozen],contig.site[0][n+1],n+1);
		    fflush(stdout);
		  }
		  Rfrozen = n+1;
		}
	      }
	      if(extendonly && EndLen > 0.0){/* reduce frozen region by EndLen (+ orig unlabeled ends) at both ends (unless END_NOEXT Mask is present)*/
		int origLfrozen = Lfrozen, origRfrozen = Rfrozen;
		int i;
		if(!(contig.MaskL & (END_NOEXT | END_NOEXT2))){
		  for(i = Lfrozen; ++i <= Rfrozen;)
		    if(contig.site[0][i] >= contig.Y1 + EndLen /* WAS105 contig.left + EndLen + Y[1] */)
		      break;
		  Lfrozen = min(i,Rfrozen);
		}
		if(!(contig.MaskR & (END_NOEXT | END_NOEXT2))){
		  for(i = Rfrozen; --i >= Lfrozen;)
		    if(contig.site[0][i] <= contig.YN - EndLen /* WAS105 contig.right - (EndLen + Y[N+1]-Y[N])*/)
		      break;
		  Rfrozen = max(i,Lfrozen);
		}
		if(VERB/* HERE HERE >=2 */){
		  printf("Before Refining refid=%d(id=%lld),EndLen=%0.3f,left=%0.3f,right=%0.3f,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]-Y[N]=%0.3f:Narrowing frozen region from %0.3f..%0.3f to %0.3f..%0.3f due to -extonly\n",
			 refid,rmap->id,EndLen,contig.left,contig.right,Y[1],Y[N],Y[N+1]-Y[N],contig.site[0][origLfrozen],contig.site[0][origRfrozen],contig.site[0][Lfrozen],contig.site[0][Rfrozen]);
		  fflush(stdout);
		}
	      }
	    } else if(extend <= 1) {/* If needed, round to nearest site to make region larger (since the frozen region is outside this region ) */
	      for(int i = 1; i <= n; i++)
		if(contig.site[0][i] >= contig.left - 1e-6){
		  Lfrozen = Rfrozen = max(0,i-1);
		  break;
		}
	      for(int i = n; i >= 1; i--)
		if(contig.site[0][i] < contig.right + 1e-6){
		  Rfrozen = min(n+1,i+1);
		  break;
		}
	    }	
	    contig.Lfrozen = contig.site[0][Lfrozen];
	    contig.Rfrozen = contig.site[0][Rfrozen];
	  }

	  if(DEBUG>=2){
	    for(int m = 0; m < contig.nummaps; m++){
	      Ccontig *pcontig = &contig.contig[m];
	      int M = pcontig->numsite[0];
	      assert(contig.sitemap[0][m][1] <= contig.numsite[0]);
	      int lastsite = contig.sitemap[0][m][1];
	      for(int J = 2; J <= M; J++){
		if(contig.sitemap[0][m][J] >= 0){
		  if(!(contig.sitemap[0][m][J] > contig.sitemap[0][m][J-1])){
		    printf("refid=%d:m=%d/%d,M=%d,N=%d,J=%d,contig.sitemap[m][J]=%d, contig.sitemap[m][J-1]=%d\n",
			   refid,m,nummaps,M,contig.numsite[0],J,contig.sitemap[0][m][J],contig.sitemap[0][m][J-1]);
		    fflush(stdout);
		    assert(contig.sitemap[0][m][J] > contig.sitemap[0][m][J-1]);
		  }
		  assert(contig.sitemap[0][m][J] > lastsite);
		  lastsite = contig.sitemap[0][m][J];
		}
		assert(contig.sitemap[0][m][J] <= contig.numsite[0]);
	      }
	    }
	  }

	  if(DEBUG) assert(fabs(resSD[0] - resSDorig) < 1e-10);
	  //	resSD[0] = resSDorig;
	  //	gmap = Gmap;

	  contig.totalsites = -1;

	  if(origCMapID > 0 || numrefmaps > 0 || CMapID != rmap->id){
	    /* Adjust global CMapID to reflect id of reference contig */
	    if(rmap->id < 0){
	      printf("refid=%d: id=%lld : negative values are not supported with -id 0 or multiple contigs\n", refid, rmap->id);
	      fflush(stdout);exit(1);
	    }
	  
	    if(VERB/* >=2 */){
	      printf("refid=%d/%d:Changing CMapID from %lld to %lld\n",refid, numrefmaps, CMapID, rmap->id);
	      fflush(stdout);

	      //	      if(CMapID == 5 && rmap->id == 1000005) exit(1);
	    }

	    if(DEBUG) assert(rmap->id <= (long long)MASK_LL(63) && rmap->id > 0);

	    CMapID = rmap->id;
	    if(CMapID <= 0){
	      printf("refid=%d: id=%lld: WARNING: 0 contig id value will result in missing ID in output file name of refined contig\n", refid, rmap->id);
	      fflush(stdout);
	    }
	  }

	  if(VERB/* HERE HERE >=2 */ && LogPvThreshold != min(origLogPvThreshold,LogPvThresholdTE)){
	    printf("Restoring LogPvThreshold %0.2f -> %0.2f\n",LogPvThreshold, min(origLogPvThreshold,LogPvThresholdTE));
	    fflush(stdout);
	  }
	  LogPvThreshold = min(origLogPvThreshold,LogPvThresholdTE);

	  if(contig.nummaps >= 2 || Refine == 1/* NEW43*/ || (extendonly && Refine == 2)/* NEW77 */){
	    if(VERB>=2){
	      printf("refid=%d:contig.nummaps=%d\n",refid,contig.nummaps);
	      fflush(stdout);
	    }

	    if(contig.mapWT){
	      delete [] contig.mapWT;
	      contig.mapWT = NULL;
	    }
	    contig.mapWT = new double[contig.nummaps];

	    /* copy alignments weights to contig.mapWT */
	    int zcnt = 0;/* number of maps with zero weight */
	    double WTsum = 0.0;
	    for(int m = 0; m < contig.nummaps; m++){
	      if(DEBUG>=2) assert(0.0 <= contig.align[m]->mapWT && contig.align[m]->mapWT <= 1.0);
	      WTsum += contig.mapWT[m] = contig.align[m]->mapWT;
	      zcnt += (contig.mapWT[m] <= 0.0) ? 1 : 0;
	      if(EXTSPLIT_TRACE/* HERE HERE >=3 */ && rmap->id == EXTSPLIT_NREFID /* && XXmap[align->mapid2]->id == MAP_TRACE */){
		Calign *p = contig.align[m];
		printf("m=%d/%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:score=%0.6f,logPV=%0.2f,numpairs=%d:mapWT=%0.6f, zcnt=%d (Before calling refine())\n",
		       m,contig.nummaps,p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->score,p->logPV,p->numpairs,p->mapWT,zcnt);
		fflush(stdout);
	      }
	    }

	    if(VERB/* HERE >=2 && zcnt > 0*/){
	      printf("%d out of %d maps have zero mapWT, WTsum= %0.3f\n",zcnt,contig.nummaps, WTsum);
	      fflush(stdout);
	    }

	    if((RefineEndOutlierThreshold < 2 && RefineEndOutlierWt < 1.0) || (extendonly && Refine >= 3)){/* re-compute contig.mapWT[] (save original values as contig.origmapWT[])*/
	      if(VERB/* HERE >=2 */){
		printf("Initializing Map Weights based on -Erefine %d %0.6f and/or -extonly %0.3f -refine 3\n",
		       RefineEndOutlierThreshold, RefineEndOutlierWt,EndLen);
		fflush(stdout);
	      }
	      if(!contig.origmapWT)
		contig.origmapWT = new double[contig.nummaps];

	      WTsum = 0.0;
	      int ecnt = 0;
	      zcnt = 0;
	      double wt;

	      for(int m = 0; m < contig.nummaps; m++){
		Calign *p = contig.align[m];
		contig.origmapWT[m] = contig.mapWT[m];
		if(DEBUG>=2) assert(0.0 <= contig.mapWT[m] && contig.mapWT[m] <= 1.0);
		if(RefineEndOutlierLen <= 0.0 && RefineEndOutlierN <= 0)
		  WTsum += contig.mapWT[m] *= wt = ((p->Lend <= -2 ? 1 : 0) + (p->Rend <= -2 ? 1 : 0)) <= RefineEndOutlierThreshold ? 1.0 : RefineEndOutlierWt;
		else {
		  double scale = p->scaleID ? ScaleFactor[p->scaleID] : 1.0;	    
		  Cmap *nanomap = Gmap[p->mapid2];
		  FLOAT *X = nanomap->site[0];
		  int M = nanomap->numsite[0];
		  int I = p->sites1[0];
		  int K = p->sitesK1[0];
		  int J = p->sites2[0];
		  int U = p->numpairs;
		  int RI = p->sites1[U-1];
		  //		  int RK = p->sitesK1[U-1];
		  int RJ = p->sites2[U-1];

		  double leftlenX = scale * (p->orientation ? X[M+1]-X[M+1-J] : X[J]);/* unaligned left end length of X */
		  double rightlenX = scale * (p->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]);/* unaligned right end length of X */

		  double Xleft = min(Y[I-K] , leftlenX);// WAS277 min(Yc(Y,I,K), scale * (p->orientation ? X[M+1]-X[M+1-J] : X[J]));
		  double Xright = min(Y[N+1]-Y[RI], rightlenX); // WAS277 min(Y[N+1] - Yc(Y,RI,RK), scale * (p->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]));
#if CALIGN_END==0
		  int XleftN = (Y[I-K] < leftlenX) ? I-K-1 + J-p->LijX : I-K-p->LijY + J-1;
		  int XrightN = (Y[N+1]-Y[RI] < rightlenX) ? N-RI + p->RijX-RJ : p->RijY-RI + M-RJ; // WAS280 (Y[N+1]-Y[RI] < rightlenX) ? N-RI + M-p->RijX : N-p->RijY + M-RJ;
#else // NOT quite correct : only misaligned labels on Y[] or X[] are counted (whichever is less)
		  int XleftN = min(I-K, J) - 1;
		  int XrightN = min(N-RI, M-RJ);
#endif

		  WTsum += contig.mapWT[m] *= wt = (((p->Lend <= -2 && Xleft >= RefineEndOutlierLen && XleftN >= RefineEndOutlierN) ? 1 : 0) + 
						    ((p->Rend <= -2 && Xright >= RefineEndOutlierLen && XrightN >= RefineEndOutlierN) ? 1 : 0)) <= RefineEndOutlierThreshold ? 1.0 : RefineEndOutlierWt;
		}
		if(DEBUG>=2) assert(0.0 <= contig.mapWT[m] && contig.mapWT[m] <= 1.0);
		zcnt += (contig.mapWT[m] <= 0.0) ? 1 : 0;
		ecnt += (wt < 1.0) ? 1 : 0;

		if(EXTSPLIT_TRACE/* HERE HERE >=2 */ && rmap->id == EXTSPLIT_NREFID && (wt < 1.0 || contig.mapWT[m] <= 0.0)){
		  //		  int refid = p->mapid1;
		  //		  Cmap *rmap = refmap[refid];// WAS280 Gmap[refid]
		  //		  int N = rmap->numsite[0];
		  //		  FLOAT *Y = rmap->site[0];

		  int mapid = p->mapid2;
		  Cmap *nanomap = Gmap[mapid];
		  int M = nanomap->numsite[0];
		  
		  double scale = p->scaleID ? ScaleFactor[p->scaleID] : 1.0;	    
		  FLOAT *X = nanomap->site[0];
		  int I = p->sites1[0];
		  int K = p->sitesK1[0];
		  //	    if(DEBUG) assert(K==0);
		  int J = p->sites2[0];
		  int U = p->numpairs;
		  int RI = p->sites1[U-1];
		  int RK = p->sitesK1[U-1];
		  int RJ = p->sites2[U-1];

		  double leftend = (p->Lend > -2) ? Yc(Y,I,K) - scale*(p->orientation ? X[M+1]-X[M+1-J] : X[J]) : Yc(Y,I,K);
		  double rightend = (p->Rend > -2) ?  Yc(Y,RI,RK) + scale*(p->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]) : Yc(Y,RI,RK);
		  //		  int extendleft = (leftend < 0.0 /* WAS EndLen */) ? 1 : 0;
		  //		  int extendright = (rightend > Y[N+1]/* WAS -EndLen */) ? 1 : 0;

		  double leftlenX = scale * (p->orientation ? X[M+1]-X[M+1-J] : X[J]);/* unaligned left end length of X */
		  double rightlenX = scale * (p->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]);/* unaligned right end length of X */

		  double Xleft = min(Y[I-K] , leftlenX);// WAS277 min(Yc(Y,I,K), scale * (p->orientation ? X[M+1]-X[M+1-J] : X[J]));
		  double Xright = min(Y[N+1]-Y[RI], rightlenX); // WAS277 min(Y[N+1] - Yc(Y,RI,RK), scale * (p->orientation ? X[M+1-RJ] : X[M+1]-X[RJ]));
#if CALIGN_END==0
		  int XleftN = (Y[I-K] < leftlenX) ? I-K-1 + J-p->LijX : I-K-p->LijY + J-1;
		  int XrightN = (Y[N+1]-Y[RI] < rightlenX) ? N-RI + p->RijX-RJ : p->RijY-RI + M-RJ; // WAS280 (Y[N+1]-Y[RI] < rightlenX) ? N-RI + M-p->RijX : N-p->RijY + M-RJ;
#else // NOT quite correct : only misaligned labels on Y[] or X[] are counted (whichever is less)
		  int XleftN = min(I-K, J) - 1;
		  int XrightN = min(N-RI, M-RJ);
#endif

		  printf("m=%d/%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,score=%0.6f,logPV=%0.2f,Len=%0.1f,outlier=%0.3f,repeat=%d,mapWT=%0.6f -> %0.6f, Lend=%d(%0.3f,%d),Rend=%d(%0.3f,%d,RI=%d,RJ=%d,RijY=%d,RijX=%d,N=%d,M=%d,Y[N+1]-Y[RI]=%0.3f,rightlenX=%0.3f),Y[N+1]=%0.3f,X[M+1]=%0.3f,Lext=%0.3f,Rext=%0.3f,zcnt=%d,ecnt=%d)\n",
			 m,contig.nummaps,p->mapid1,refmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->score,p->logPV,AlignedLength(p,Y),p->maxoutlier,p->repeat,contig.origmapWT[m],
			 contig.mapWT[m], p->Lend,Xleft,XleftN,p->Rend, Xright, XrightN,RI,RJ,p->RijY,p->RijX,N,M,Y[N+1]-Y[RI],rightlenX,Y[N+1],X[M+1],-leftend,rightend - Y[N+1], zcnt, ecnt);
		  fflush(stdout);
		}
	      }
	      
	      if(VERB && (zcnt > 0 || ecnt > 0)){
		if(RefineEndOutlierLen <= 0.0 && RefineEndOutlierN <= 0)
		  printf("\t %d out of %d maps have zero mapWT (%d maps had more than %d endoutliers):WTsum= %0.3f\n",zcnt,contig.nummaps,ecnt, RefineEndOutlierThreshold, WTsum);
		else
		  printf("\t %d out of %d maps have zero mapWT (%d maps had more than %d endoutliers of at least %0.3f kb AND %d Labels):WTsum= %0.3f\n",
			 zcnt,contig.nummaps,ecnt, RefineEndOutlierThreshold, RefineEndOutlierLen, RefineEndOutlierN, WTsum);
		fflush(stdout);
	      }
	    }

	    if(extendonly && Refine >= 3 /* && !(contig.MaskL || contig.MaskR) */){/* zero out weights for maps that overlap only the central region contig.site[0][Lfrozen .. Rfrozen] */
	      double Lfreeze = contig.site[0][Lfrozen] + 500.0/* HERE HERE should be more precise : see below */; 
	      double Rfreeze = contig.site[0][Rfrozen] - 500.0/* HERE HERE should be more precise : see below */;
	      int tcnt = 0;
	      zcnt = 0;
	      WTsum = 0.0;

	      for(int m = 0; m < contig.nummaps; m++){
		if(DEBUG>=1+RELEASE) assert(0.0 <= contig.mapWT[m] && contig.mapWT[m] <= 1.0);

		if(RefineEndOutlierType)
		  contig.origmapWT[m] = contig.mapWT[m];/* NEW277 prevent original weight from being restored due to -extonly -refine 3 */

		if(contig.mapWT[m] <= 0.0)
		  continue;

		tcnt++;

		int M = contig.contig[m].numsite[0];
		int R = 0, L = n+1;// NEW53

		int *mapM = contig.sitemap[0][m];

		for(int J = 1; J <= M; J++){
		  int i = mapM[J];
		  if(i <= 0)
		    continue;
		  if(DEBUG) assert(0 < i && i <= n);
		  L = min(i,L);// NEW53
		  R = max(i,R);// NEW53
		}

		// HERE HERE : need to expand range from contig.site[0][L..R] by unaligned ends of map PLUS (RANGE + LRANGE) labels with sitecnt >= 1.99f

		if(L <= R && Lfreeze <= contig.site[0][L] && contig.site[0][R] <= Rfreeze){
		  if(VERB>=3){
		    printf("m=%d/%d:id=%lld,M=%d,L=%d,R=%d:site[L]= %0.3f,site[R]= %0.3f, site[Lfrozen=%d]= %0.3f(%0.3f), site[Rfrozen=%d]= %0.3f(%0.3f): mapWT= %0.6f -> 0\n",
			   m,contig.nummaps,Gmap[contig.contig[m].mapid]->id,M,L,R,contig.site[0][L],contig.site[0][R],
			   Lfrozen,contig.site[0][Lfrozen],Lfreeze,Rfrozen,contig.site[0][Rfrozen],Rfreeze,contig.mapWT[m]);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(Lfreeze <= Rfreeze);
		  zcnt++;
		  contig.mapWT[m] = 0.0;
		}
		WTsum += contig.mapWT[m];
	      }
	      if(VERB/* HERE >=2 */ && zcnt > 0){
		printf("%d out of %d remaining maps overlapped central region only : their mapWT was reset to zero: WTsum= %0.3f\n",zcnt,tcnt,WTsum);
		fflush(stdout);
	      }
	    }

	    if(VERB>=2 && (Lfrozen || Rfrozen)){
	      printf("Calling refine():Lfrozen=%d(%0.3f),Rfrozen=%d(%0.3f),contig.left=%0.3f,contig.right=%0.3f,n=%d,Len=site[n+1]=%0.3f\n",
		     Lfrozen,contig.site[0][Lfrozen],Rfrozen,contig.site[0][Rfrozen],contig.left,contig.right,contig.numsite[0],contig.site[0][contig.numsite[0]+1]);
	      fflush(stdout);
	    }

	    int origRefine = Refine;
	    double origEndTrimCov = EndTrimCov;
	    if(MaxContigSiteDensity > 0.0 && Refine > 1){/* check if this contig should NOT be refined due to high site density */
	      if(N > 1 && (N-1)*100.0 > MaxContigSiteDensity * (Y[N] - Y[1])){
		if(VERB){
		  printf("Skipping full refinement of contig%lld due to label density = %0.2f / 100kb (using -refine 1 instead)\n", refmap[refid]->id, ((N-1) * 100.0)/ (Y[N]-Y[1]));
		  fflush(stdout);
		}
		Refine = 1;
		EndTrimCov = 0.0;
	      }
	    }
	    if((contig.MaskL & (END_NOEXT | END_NOEXT2)) && (contig.MaskR & (END_NOEXT | END_NOEXT2)) && Refine > 1 && extend >= 2 && extendonly){
	      if(VERB){
		printf("Skipping full refinement of contig%lld due to extensions being blocked on both ends (using -refine 1 instead)\n", refmap[refid]->id);
		fflush(stdout);
	      }
	      Refine = 1;
	      EndTrimCov = 0.0;
	    }

	    if(contig.nummaps < 4 && HapSitePvalue > 0.0){
	      if(VERB){
		printf("Skipping full haplotype refinement of contig%lld due to too few maps = %d (using -refine 1 instead)\n", refmap[refid]->id, contig.nummaps);
		fflush(stdout);
	      }
	      Refine = 1;
	      EndTrimCov = 0.0;
	    }
	    if(contig.nummaps < 2 && HapSitePvalue <= 0.0){
	      if(VERB){
		printf("Skipping non-haplotype refinement of contig%lld due to too few maps = %d (using -refine 1 instead)\n", refmap[refid]->id, contig.nummaps);
		fflush(stdout);
	      }
	      Refine = 1;
	      EndTrimCov = 0.0;
	    }

	    if(VERB>=2){
	      printf("Before calling refine() for contig%lld: cpu time=%0.6f, wall time=%0.6f\n",refmap[refid]->id,mtime(),wtime());
	      fflush(stdout);
	      dumpmemmap();
	    }

	    /* free contig.align */
	    if(contig.align){
	      delete [] contig.align;
	      contig.align = NULL;
	    }

	    try {
	      refine(&contig, 0, Lfrozen, Rfrozen);
	    } catch (exception& e){
	      cout << e.what() << endl;
	      printf("refalign_allpairs : refine() threw an exception\n");
	      fflush(stdout);
	      dumpmemmap();
	      assert(0);
	    }
	    long long startCMapID = CMapID;
	    double startContigSplitRatio = ContigSplitRatio;

	    /* output refined contig as .cmap OR .hmap file (uses global CMapID value) */
	    output_draft(&contig, -rmap->id, draft_prefix, Lfrozen, Rfrozen, 0);

	    CMapID = startCMapID;
	    ContigSplitRatio = startContigSplitRatio;

	    Refine = origRefine;
	    EndTrimCov = origEndTrimCov;

	  } else {/* too few maps to refine contig */
	    double origEndTrimCov = EndTrimCov;
	    double origContigSplitRatio = ContigSplitRatio;
	    //	  EndTrimCov = 1.0; // NOTE : allow trimming away of entire map, since it is useless if the entire coverage is under EndTrimCov everywhere 
	    ContigSplitRatio = 0.0;

	    if(extendonly && Refine <= 2)
	      printf("Unable to refine reference map since only %d maps aligned with it AND extended beyond original consensus\n",contig.nummaps);
	    else
	      printf("Unable to refine reference map since only %d maps aligned with it\n",contig.nummaps);
	    if(EndTrimCov < 2.0)
	      printf("Reference map left unchanged\n");
	    fflush(stdout);

	    /* set sitecnt[i] = 0 unless it is consensus site (ie sitecnt[i] == 2) */
	    /* Also set fragcnt and sitecntFN to 0 except at the original consensus sites, where it is set to 2.0 */
	    contig.fragcnt[0][0] = 0.0;
	    int first = -1;
	    int last = -1;
	    for(int i = 1; i <= n; i++){
	      if(VERB>=2){
		printf("i=%d,n=%d:sitecnt[i]=%0.1f,site[i]=%0.3f\n",i,n,contig.sitecnt[0][i],contig.site[0][i]);
		fflush(stdout);
	      }
	      if(contig.sitecnt[0][i] <= 1.5f)
		contig.sitecnt[0][i] = 0;
	      else {
		last = i;
		if(first < 0)
		  first = i;
	      }
	      contig.sitecntFN[0][i] = contig.fragcnt[0][i] = contig.fragcntT[0][i] = 0.0;
	      for(int t = 0; t < mCNT; t++)
		contig.sitecntN1[0][t][i] = 0.0f;
	      if(TrimNorm >= 0)
		contig.sitecntFNnorm[0][i] = contig.sitecntN2[0][i] = contig.sitecntN3[0][i] = contig.sitecntN4[0][i] = contig.sitecntN5[0][i] = contig.sitecntN6[0][i] = 
		  contig.fragSd[0][i] = contig.expSd[0][i] = contig.fragBias[0][i] = contig.fragCov[0][i] = contig.fragChiSq[0][i] = 0.0f;
	      if(CovNorm)
		contig.fragcntTnorm[0][i] = 0.0f;
	    }
	    if(VERB>=2){
	      printf("first=%d,last=%d,n=%d\n",first,last,n);
	      fflush(stdout);
	    }
	    if(first > 0)
	      for(int i = first;i <= last; i++){
		contig.sitecntFN[0][i] = contig.fragcnt[0][i] = contig.fragcntT[0][i] = 2.0f;
		for(int t = 0; t < mCNT; t++)
		  contig.sitecntN1[0][t][i] = 0.0f;
		if(TrimNorm >= 0){
		  contig.sitecntFN[0][i] = 100.0f;
		  contig.sitecntFNnorm[0][i] = 2.0f;
		}
	      }

	    output_draft(&contig,0,draft_prefix, 0, 0, 0);

	    EndTrimCov = origEndTrimCov;
	    ContigSplitRatio = origContigSplitRatio;
	  }
	}

	CMapID = origCMapID;

	if(Lalignment != alignment)
	  delete [] Lalignment;
        delete [] alignids1;

	delete [] nmap1;

#if 0    // This should happen automatically when stack variable contig goes out of scope and its destructor is called
	for(int m = 0; m < contig.nummaps; m++){	  /* free memory of contig.contig[m] */
	  if(DEBUG) assert(contig.contig[m].mapid >= 0);
	  contig.contig[m].allfree();
	  if(contig.sitemap[0][m]){
	    delete [] &contig.sitemap[0][m][-1];
	    contig.sitemap[0][m] = 0;
	  }
	  if(DEBUG) assert(contig.X[0]);
	  delete [] contig.X[0][m];
	  contig.X[0][m] = 0;
	}
#endif
	if(SCORE_MINMEM)
	  (void)score_init(refmap,0,scorerefmaps,nummaps,RKmax);
      } /* if(Refine) */
      
      if(extsplitExtOnly){
	if(VERB/* HERE >=2 */ && (EndLen != origEndLen || EndLen2 != origEndLen2 || MaxExtend != origMaxExtend)){
	  printf("Restored -extonly %0.3f %0.3f -> %0.3f %0.3f and -maxExtend %0.3f -> %0.3f\n",EndLen,EndLen2,origEndLen,origEndLen2,MaxExtend,origMaxExtend);
	  fflush(stdout);
	}
	EndLen = origEndLen;
	EndLen2 = origEndLen2;
	MaxExtend = origMaxExtend;
      }

    } /* for ( refid = 0; refid < (extendSplit ? numrefmaps : Hapnumrefmaps); refid++) */

    if(EXTSPLIT_FORK && extendSplit && Refine && !(MapScale && giter==0 && !origMapScale && !pSNRtotLL) 
       && child_pid==NULL && numchild==0){/* This is a child job : close stdout and call exit(0) */
      printf("Terminating child job\n");
      time_t my_time = time(NULL); 
      printf("END TIME: %s", ctime(&my_time));   // ctime() used to give the present time 
      
      printf("END of output\n");
      fflush(stdout);

#ifndef WIN32
      if(stdout_file){
	int fd = fileno(stdout);
	if(fd < 0){
	  fprintf(stdout,"fileno(stdout) returned -1\n");
	  fflush(stdout);
	} else {
	  if(fsync(fd) < 0){
	    char *err = strerror(errno);
	    printf("fsync(fd=%d) returned -1:%s\n",fd,err);
	    printf("STDOUT_FILENO=%d\n",STDOUT_FILENO);
	    printf("CPU time= %0.6f, wall time= %0.6f\n",mtime(),wtime());
	    printf("END of output\n");
	    fflush(stdout);
	  }
	}
      }
#endif
      exit(0);
    }

    if(DEBUG>=3){
      for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!align)
	    continue;
	  if(DEBUG) assert(align->mapid1 == refid);
	}
      }
    }

    if(MapScale && giter==0 && !origMapScale && !pSNRtotLL){/* repeat first iteration after rescaling each map that aligned above threshold */
      double y2sum = 0.0, xysum = 0.0;
      for(int i = 0; i < nummaps; i++){
	Cmap *pmap = Gmap[i];
	y2sum += pmap->y2sum;
	xysum += pmap->xysum;
      }
      double CscaleInv = (xysum <= 0.0) ? 1.0 : xysum / y2sum;

      if(VERB/* HERE >=2 */){
	printf("  Rescaling map site[] (and rawsite[]) values by per map scaling factors (excluding average scaling= %0.8f):wtime=%0.6f\n",1.0/CscaleInv,wtime());
	if(NumScaleFactor > 1)
	  for(int i = 0; i < NumScaleFactor; i++)
	    printf("scaleID=%d,scale=%0.4f:mapcnt=%d\n",i,ScaleFactor[i],scaleIDcnt[i]);
	fflush(stdout);
      }

      // NOTE : if minSNRestimate, Gmap[i]->cumscale will be re-applied if site[] is ever recomputed from origsite after minSNR[] changes */

      int origcolors = colors;
      if(usecolor)
	colors = 2;

      int cnt = 0;

      #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
      {
        int mycnt = 0;

        #pragma omp for schedule(dynamic,256)
        for(int i = 0; i < nummaps; i++){
          Cmap *pmap = Gmap[i];
	  pmap->cumscale = 1.0;

	  if(pmap->incwt <= 0.0 /* || C == 1.0*/){
	    if(DEBUG>=2) assert(pmap->xysum <= 0.0);
	    if(VERB>=2){
#if 0
	      printf("Skipping map i=%d/%d(id=%lld) due to no non-outlier alignment intervals : (xysum= %0.6e, y2sum= %0.6e, incscale= %0.6f, incwt= %0.4f, xsum= %0.4f, lenY=%0.4f, lenX=%0.4f)\n",
   	          i,nummaps, pmap->id, pmap->xysum , pmap->y2sum, pmap->incscale, pmap->incwt,pmap->xsum, pmap->Ylen, pmap->Xlen);
#else
	      printf("Skipping map i=%d/%d(id=%lld) due to no non-outlier alignment intervals : (xysum= %0.6e, y2sum= %0.6e, incscale= %0.6f, incwt= %0.4f)\n",
   	          i,nummaps, pmap->id, pmap->xysum , pmap->y2sum, pmap->incscale, pmap->incwt);
#endif
	      fflush(stdout);
	    }
	    continue;
	  }
	
	  mycnt++;
	  double C = pmap->incscale;
	  C *= CscaleInv;
	  pmap->cumscale = C;

	  if(TRACE && pmap->id == MAP_TRACE){
	    printf("MapScale: id= %lld : xysum= %0.8e, y2sum= %0.8e, incscale= %0.8f, incwt= %0.4f, C= %0.8f\n",pmap->id, pmap->xysum, pmap->y2sum, pmap->incscale, pmap->incwt, C);
	    fflush(stdout);
	  }

	  if(VERB>=2){
            FLOAT *X = pmap->site[0];
	    int M = pmap->numsite[0];

#if 0
	    printf("Rescaling i=%d/%d(id=%lld) by %0.6f (cum = %0.6f), len = %0.3f -> %0.3f (xysum= %0.6e, y2sum= %0.6e, incscale= %0.6f, incwt= %0.4f, xsum= %0.4f, Ylen= %0.4f, Xlen=%0.4f)\n",
	      i, nummaps, pmap->id, C, pmap->cumscale, X[M+1], X[M+1] * C, pmap->xysum,pmap->y2sum,pmap->incscale,pmap->incwt,pmap->xsum,pmap->Ylen,pmap->Xlen);
#else
	    printf("Rescaling i=%d/%d(id=%lld) by %0.6f (cum = %0.6f), len = %0.3f -> %0.3f (xysum= %0.6e, y2sum= %0.6e, incscale= %0.6f, incwt= %0.4f)\n",
	      i, nummaps, pmap->id, C, pmap->cumscale, X[M+1], X[M+1] * C, pmap->xysum,pmap->y2sum,pmap->incscale,pmap->incwt);
#endif
	    fflush(stdout);
          }

	  for(int c = 0; c < colors; c++){
            FLOAT *X = pmap->site[c];
	    int M = pmap->numsite[c];
	    for(int j= M+1; j > 0; j--)
	      X[j] *= C;
          }
	  if(maxresbias > mres * 0.5){/* also rescale rawsite[] */
            for(int c = 0; c < colors; c++){
              FLOAT *X = pmap->rawsite[c];
	      int M = pmap->numsite[c];
	      for(int j= M+1; j > 0; j--)
		X[j] *= C;
            }
          }
        } // for i = 0 .. nummaps-1
	
	#pragma omp atomic
	cnt += mycnt;

      }// parallel 

      colors = origcolors;

      /* restore normal parameters */
      BestRef = origBestRef;
      BestRefWT = origBestRefWT;
      MultiMatches = origMultiMatches;
      RefSplit = origRefSplit;
      LogPvThreshold = MSorigLogPvThreshold;
      ScoreThreshold = MSorigScoreThreshold;
      AlignedLengthThreshold = MSorigAlignedLengthThreshold;
      AlignedSiteThreshold = MSorigAlignedSiteThreshold;

      ScaleDelta = origScaleDelta;
      NumScaleFactor = 1 + 2 * ScaleDelta;
      ScaleDeltaSize = origScaleDeltaSize;
      ScaleDeltaBPP = origScaleDeltaBPP;

      hashdeltaAdjust = orighashdeltaAdjust;

      if(ScaleDelta > 0){
	if(Refine>=2/*WAS169 RefRepeats==1 && RefRepeats2==1*/ &&  !(hash_filename && hashScaleDelta>=2)){
	  ScaleDelta = 0;// no need to waste time on -ScaleDelta for redoing alignments since rescaled maps will only very rarely benefit from it
	  NumScaleFactor = 1;
	}

	for(int i = 1; i <= ScaleDelta; i++){
	  double scale = 1.0 + i * ScaleDeltaSize;
	  ScaleFactor[2*i-1] = scale;
	  ScaleFactor[2*i] = 1.0/scale;
	}
      }

      if(VERB){
        printf("MapScale : Rescaled %d maps, restoring -T(L10=%0.2f) -S %0.2f -L %0.3f -A %d and -MultiMatches %d .. -RefSplit %d and -BestRef %d -BestRefWT %d -BestRefPV %d %0.1f and redoing alignments: wtime= %0.6f\n",
	       cnt,LogPvThreshold,ScoreThreshold,AlignedLengthThreshold,AlignedSiteThreshold,MultiMatches,RefSplit,BestRef,BestRefWT,BestRefPV,BestRefPV_MaxConf, wtime());
	if(orighashdeltaAdjust > 0.0)
	  printf("\t Restored -hashdelta %0.1f %0.1f %0.1f\n",hashdelta,hashdeltaAdjust,hashdeltaLim);
	fflush(stdout);
      }

      origMapScale = 1;

      giter--;
      continue; // repeat first -M iteration
    }

    if(extendSplit && MultiMatches){
      if(VERB/* HERE >=2 */ && LogPvThreshold2 < LogPvThreshold){
	printf("LogPvThreshold = %0.2f -> %0.2f (due to -extsplit -MultiMatches %d %0.2f %0.4f)\n",LogPvThreshold,LogPvThreshold2,MultiMatches,LogPvThreshold2,ScoreThreshold2);
	fflush(stdout);
      }
      LogPvThreshold = min(LogPvThreshold, LogPvThreshold2);
      ScoreThreshold = min(ScoreThreshold, ScoreThreshold2);

      origLogPvThreshold = min(origLogPvThreshold, LogPvThreshold);// this will have no effect with -M 1
      origScoreThreshold = min(origScoreThreshold, ScoreThreshold);// this will have no effect with -M 1
    }

    if(DEBUG && !EARLY_ALIGN_FILTER) assert(numalign_end[numrefmaps-1] >= numaligns);

    /* save nanomap->nalign to nanomap->align for use during next giter with FAST (or during output with BestRef) */
    for(int mapid = 0;mapid < nummaps;mapid++){	    
      Cmap *nanomap = Gmap[mapid];      
      if(nanomap->nalign->mapid1 >= 0){
	nanomap->align->update(nanomap->nalign[0]);
	nanomap->nalign->reset();
      }
    }
    for(int mapid = startmaps;mapid < totalmaps;mapid++){	    
      Cmap *nanomap = Gmap[mapid];      
      if(nanomap->nalign->mapid1 >= 0){
	nanomap->align->update(nanomap->nalign[0]);
	nanomap->nalign->reset();
      }
    }

    size_t maxmapid = (totalmaps > startmaps ? totalmaps : nummaps);
    if(!NoStat){
      delete [] Narray;
      Narray = new double[max(numaligns,maxmapid)];
      if(VERB>=2){
	printf("Allocated Narray[0..%lu] = %p\n",max(numaligns,maxmapid), Narray);
	fflush(stdout);
      }
      if(SNR_BESTREF_FIX){
	delete [] Sarray;
	Sarray = new AlignStat[maxmapid];
      }
    }

    if(DEBUG>=2) assert(0 <= giter && giter <= RefRepeats-1);

    if(VERB>=3){
      printf("iter=%d:Before svcheck block: numaligns=%lu\n",giter,numaligns);
      size_t cnt = 0;
      for(size_t i = 0; i < numaligns; i++){
        Calign *align = alignment[i];
	if(!align || align->numpairs <= 1)
	  continue;
	if(MapRate > 0.0 && !(BestRefPV ? (align->logPV > LogPvThreshold) : (align->score > ScoreThreshold)))
	  continue;
	int mid = align->mapid2;
	if(BestRef){
	  Cmap *origmap = Gmap[mid];
	  while(origmap->origmap)
	    origmap = origmap->origmap;
	  if(origmap->align->mapid1 != align->mapid1)// NOTE : BestRefExtCheck() not used for parameter estimation
	    continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	}
	printf("cnt=%lu,i=%lu:mid=%d(id=%lld),rid=%d(id=%lld)\n", cnt,i,mid,Gmap[mid]->id,align->mapid1,refmap[align->mapid1]->id);
	cnt++;
      }
      printf("\n");
      fflush(stdout);
    }

    if(DEBUG>=3){
      for(int refid = 0;refid < numrefmaps;refid++){
	for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	  Calign *align = alignment[alignid];
	  if(!align)
	    continue;
	  if(DEBUG) assert(align->mapid1 == refid);
	}
      }
    }

    if(giter == RefRepeats-1){
      if(VERB/* HERE >=2 */){
	printf("refalign:nummaps=%d,startmaps=%d,totalmaps=%d,refmaps=%d:end time=%0.6f(Elapsed=%0.6f)\n",nummaps,startmaps,totalmaps,numrefmaps,mtime(),wtime());
	fflush(stdout);
      }

      if(MultiMatches && CutFlip > 0){// lower -S2 and -T2 and -A2 and -L2 thresholds to CutFlip levels, so flipped matchgroups are not discarded in SV code */
	if(DEBUG) assert(RefSplit);// CutFlip not supported without RefSplit
	ScoreThreshold2 = min(ScoreThreshold3,ScoreThreshold2);
	LogPvThreshold2 = min(LogPvThreshold3,LogPvThreshold2);
	AlignedSiteThreshold2 = min(2, AlignedSiteThreshold2);
	AlignedLengthThreshold2 = 0.0;
	if(VERB){
	  printf("Lowering RefSplit 2nd Thresholds : S2 to %0.6f, T2 to %0.2f, A2 to %d, L2 to 0\n", ScoreThreshold2, LogPvThreshold2, AlignedSiteThreshold2);
	  fflush(stdout);
	}
      }
#if 0
      else if(MultiMatches && MultiMatchesRev){/* lower -S -T -A -L to -S2 -T2 -A2 -L2 levels, so matchgroups are not discarded in SV code */
	ScoreThreshold = min(ScoreThreshold,ScoreThreshold2);
	LogPvThreshold = min(LogPvThreshold,LogPvThreshold2);
	AlignedSiteThreshold = min(AlignedSiteThreshold,AlignedSiteThreshold2);
	AlignedLengthThreshold = min(AlignedLengthThreshold,AlignedLengthThreshold2);
	if(VERB){
	  printf("Lowering Thresholds : -S to %0.6f, logPV to %0.2f, -A to %d, -L to 0\n", ScoreThreshold, LogPvThreshold, AlignedSiteThreshold);
	  fflush(stdout);
	}
      }
#endif

      int orignummaps = nummaps;
      nummaps = totalmaps;/* most output routines expect numaps to be the total size of Gmap[] array */

      if(svcheck){/* for each pair of references, check which had better total score (above threshold) :
		     Equalize number of molecules for the two references by picking the best molecules (by score) for the reference with more molecules above threshold.
		     Output a .indel file with updated confidence values, based on total score difference = log(likelihood ratio with/without SV).
		     Output corrected versions of all Query maps (some query maps may have no corrections, some more than one SV correction)
		  */
	/* HERE : Add option to pick best molecules by Pvalue instead of score AND/OR updated confidence based on Pvalue differences instead score differences */
	extern int StartRef,NummapsRef,StartQuery,NummapsQuery;
	extern xmapEntry *SVtocheck;/* The SVs to be checked : SVtocheck[i = 0 .. xmapCnt - 1] corresponds to refmap[2*i .. 2i+1] (refmap[2*i] is the uncorrected i'th Query) */
	extern int svCnt, svCntOrig;
	extern Cmap *findidBS(Cmap **fmap, int num, long long id);/* see input_svcheck.cpp */

	if(DEBUG) assert(svCnt*2 == numrefmaps);

	int vcnt = 0;

	for(int i = 0; i < svCnt; i++){
	  xmapEntry *pSV = &SVtocheck[i];
	  int refid1 = 2*i;
	  int refid2 = 2*i+1;
	  size_t cnt1 = numalign_end[refid1] - numalign_start[refid1];
	  size_t cnt2 = numalign_end[refid2] - numalign_start[refid2];

	  Calign **alignment1 = new Calign*[cnt1];
	  Calign **alignment2 = new Calign*[cnt2];

	  /* filter out alignments that are below threshold (eg due to BestRef) */
	  cnt1 = 0;
	  for(size_t alignid = numalign_start[refid1]; alignid < numalign_end[refid1];alignid++){
	    Calign *align = alignment[alignid];
	    
	    if(!align)
	      continue;
	    if(DEBUG) assert(align->mapid1 == refid1);
	    Cmap *rmap = refmap[refid1];
	    if(!(AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold)))
	      continue;
	    int mapid = align->mapid2;
	    if(DEBUG>=2) assert(!Gmap[mapid]->origmap);
	    
	    if(DEBUG>=2 && BestRef && !(Gmap[mapid]->align->mapid1 >= 0)){
	      Cmap *Qmap = Gmap[mapid];
	      Calign_brief *nalign = Qmap->align;
	      printf("mapid=%d,refid1=%d:Qmap->mapid=%d,Qmap->id=%lld,rmap->mapid=%d,rmap->id=%lld:nalign->mapid1=%d,numrefmaps=%d\n",
		     mapid,refid1,Qmap->mapid,Qmap->id,rmap->mapid,rmap->id,nalign->mapid1,numrefmaps);
	      printf("   align->mapid1=%d,align->mapid2=%d,or=%d:score=%0.6f,logPV=%0.2f,numpairs=%d\n",align->mapid1,align->mapid2,align->orientation,align->score,align->logPV,align->numpairs);
	      fflush(stdout);
	      assert(Gmap[mapid]->align->mapid1 >= 0);
	    }
	    if(BestRef && Gmap[mapid]->align->mapid1 != refid1 && BestRefExtCheck(align,Gmap[mapid]->align,mapid,refid1))
	      continue;

	    alignment1[cnt1++] = align;
	  }

	  cnt2 = 0;
	  for(size_t alignid = numalign_start[refid2]; alignid < numalign_end[refid2];alignid++){
	    Calign *align = alignment[alignid];
	    if(!align)
	      continue;
	    if(DEBUG) assert(align->mapid1 == refid2);
	    Cmap *rmap = refmap[refid2];
	    if(!AlignedThreshold(align, rmap->site[0], ScoreThreshold, LogPvThreshold))
	      continue;
	    int mapid = align->mapid2;
	    if(DEBUG) assert(!Gmap[mapid]->origmap);
	    
	    if(DEBUG>=2 && BestRef) assert(Gmap[mapid]->align->mapid1 >= 0);
	    if(BestRef && Gmap[mapid]->align->mapid1 != refid2 && BestRefExtCheck(align,Gmap[mapid]->align,mapid,refid2))
	      continue;

	    alignment2[cnt2++] = align;
	  }

	  /* sort alignments in descending order of score */
	  qsort(alignment1, cnt1, sizeof(alignment1[0]),(intcmp*)CalignScoreDec);
	  qsort(alignment2, cnt2, sizeof(alignment2[0]),(intcmp*)CalignScoreDec);
	  
	  double scoresum1 = 0.0,scoresum2 = 0.0, PVsum1 = 0.0, PVsum2 = 0.0;
	  for(int t = min(cnt1,cnt2); --t >= 0;){
	    scoresum1 += alignment1[t]->score;
	    scoresum2 += alignment2[t]->score;
	  }

	  /* sort alignments in descending order of logPV */
	  qsort(alignment1, cnt1, sizeof(alignment1[0]),(intcmp*)CalignLogPVDec);
	  qsort(alignment2, cnt2, sizeof(alignment2[0]),(intcmp*)CalignLogPVDec);
	  for(int t = min(cnt1,cnt2); --t >= 0;){
	    PVsum1 += alignment1[t]->logPV;
	    PVsum2 += alignment2[t]->logPV;
	  }
	  Cmap *QryMap = findidBS(&Gmap[StartQuery],NummapsQuery,(long long)pSV->qrycontigid);
	  Cmap *RefMap = findidBS(&Gmap[StartRef],NummapsRef,(long long)pSV->refcontigid);
	  if(VERB/* HERE */ >=2){
	    double len1 = refmap[refid1]->site[0][refmap[refid1]->numsite[0]+1];
	    double len2 = refmap[refid2]->site[0][refmap[refid2]->numsite[0]+1];
	    printf("SV[%d]:mcnt=%d,qid=%lld,rid=%lld:QueryRange=%0.3f..%0.3f(%0.3f),RefRange=%0.3f..%0.3f(%0.3f),or=%d,type=%s:\n\t cnt1=%lu(score=%0.2f,logPV=%0.2f,len=%0.3f),cnt2=%lu(score=%0.2f,logPV=%0.2f,len=%0.3f):confidence=%0.2f -> %0.2f\n",
		   i,pSV->mergecnt,pSV->qrycontigid,pSV->refcontigid,pSV->qrystartpos,pSV->qryendpos, QryMap->site[0][QryMap->numsite[0]+1],
		   pSV->refstartpos,pSV->refendpos,RefMap->site[0][RefMap->numsite[0]+1], pSV->orientforward ? 0 : 1, pSV->type,
		   cnt1, scoresum1, PVsum1, len1, cnt2, scoresum2, PVsum2, len2, pSV->confidence,  (scoresum1 - scoresum2) / log(10.0));
	    if(VERB>=3 && i==56){/* NOTE : this example shows that the reference SV region is penalized because it hasn't been "refined" the way the assembly SV region has */
	      printf("\t Aligned Molecule List1 (sorted by logPV) for refid=%lld:\n", refmap[refid1]->id);
	      for(size_t t = 0; t < cnt1; t++){
		Calign *palign = alignment1[t];
		int mapid2 = palign->mapid2;
		printf("\t\t Map[%lu]:id=%lld,logPV=%0.2f,score=%0.2f,aligned sites=%d\n", t, Gmap[mapid2]->id, palign->logPV, palign->score, palign->numpairs);
	      }
	      printf("\t Aligned Molecule List2 (sorted by logPV) for refid=%lld:\n", refmap[refid2]->id);
	      for(size_t t = 0; t < cnt2; t++){
		Calign *palign = alignment2[t];
		int mapid2 = palign->mapid2;
		printf("\t\t Map[%lu]:id=%lld,logPV=%0.2f,score=%0.2f,aligned sites=%d\n", t, Gmap[mapid2]->id, palign->logPV, palign->score, palign->numpairs);
	      }
	    }
	    fflush(stdout);
	  }
	  SVtocheck[i].confidence = (scoresum1 - scoresum2) / log(10.0);
	  if(SVtocheck[i].confidence > svcheck_confidence)
	    vcnt++;
	  /* propagate confidence of merged SV to individual SVs (if merged SV has more -ve confidence) with small offset, so later decision on which SV to delete favors the one (merged or single) with more -ve SV */
	  if(SVtocheck[i].mergecnt > 1)
	    for(int t = SVtocheck[i].mergestart; t < SVtocheck[i].mergestart + SVtocheck[i].mergecnt; t++)
	      SVtocheck[t].confidence = min(SVtocheck[t].confidence, SVtocheck[i].confidence + 0.01);
	  
	  delete [] alignment1;
	  delete [] alignment2;
	}

	if(VERB){
	  printf("%d SVs: validated %d SVs, correctable SVs = %d (includes merged SVs)\n",svCnt, vcnt, svCnt - vcnt);
	  fflush(stdout);
	}

	/* output .indel file with updated confidence values */
	extern void output_indel(char *output_prefix, xmapEntry *SVs, int SVcnt);/* see output_smap.cpp */
	output_indel(output_prefix,SVtocheck,svCntOrig);

	xmapEntry **SVlist = new xmapEntry*[svCnt];

	/* compute and output corrected Query maps */
	char basename[PATH_MAX];
	int correctedCnt = 0, totalCnt = 0;
	for(int i = 0; i < NummapsQuery; i++){
	  Cmap *QryMap = Gmap[StartQuery + i];
	  long long qryid = QryMap->id;

	  /* create list of SVs that need to be removed from Query i */
	  int SVlistCnt = 0;
	  for(int j = 0; j < svCnt; j++){
	    xmapEntry *pSV = &SVtocheck[j];
	    if(pSV->confidence <= svcheck_confidence && pSV->qrycontigid == qryid)
	      SVlist[SVlistCnt++] = pSV;
	  }

	  /* sort the SVs from left to right based on min(qrystartpos,qryendpos) */
	  qsort(SVlist,SVlistCnt,sizeof(SVlist[0]),(intcmp*)SVQrystartposInc);

	  if(VERB/* HERE */ >= 2 && SVlistCnt > 2){
	    printf("Checking SVlist[%d..%d] for overlaps (qryid=%lld):\n",0,SVlistCnt-1,qryid);
	    for(int t = 0; t < SVlistCnt; t++){
	      xmapEntry *pSV = SVlist[t];
	      printf("\t SV[%d/%d]==SVlist[%d/%d]:qid=%lld,rid=%lld:QueryRange=%0.3f..%0.3f(len=%0.3f),RefRange=%0.3f..%0.3f(len=%0.3f),or=%d,type=%s,confidence=%0.2f\n",
		     pSV->smapentryid - 1, svCnt, t, SVlistCnt, pSV->qrycontigid,pSV->refcontigid,pSV->qrystartpos,pSV->qryendpos, pSV->QryMap->site[0][pSV->QryMap->numsite[0]+1],
		     pSV->refstartpos,pSV->refendpos,pSV->RefMap->site[0][pSV->RefMap->numsite[0]+1], pSV->orientforward ? 0 : 1, pSV->type, pSV->confidence);
	    }
	    fflush(stdout);
	  }

	  /* check for overlapping SVs : If so ignore the SV with lower magnitude of (-ve) confidence */
	  for(int t = 1; t < SVlistCnt; t++){
	    if(DEBUG) assert(t > 0);
	    if(SVlist[t] && SVlist[t-1] && !(min(SVlist[t]->qrystartpos,SVlist[t]->qryendpos) >= max(SVlist[t-1]->qrystartpos,SVlist[t-1]->qryendpos) - 0.001)){
	      if(VERB/* HERE */ >=2){
		printf("Overlapping SV[%d] and SV[%d] for Query id=%lld\n",SVlist[t-1]->smapentryid-1,SVlist[t]->smapentryid-1,qryid);
		for(int k = t-1; k <= t; k++){
		  xmapEntry *pSV = SVlist[k];
		  printf("\t SV[%d/%d]==SVlist[%d/%d]:qid=%lld,rid=%lld:QueryRange=%0.3f..%0.3f(%0.3f),RefRange=%0.3f..%0.3f(%0.3f),or=%d,type=%s,confidence=%0.2f\n",
			 pSV->smapentryid - 1, svCnt, k, SVlistCnt, pSV->qrycontigid,pSV->refcontigid,pSV->qrystartpos,pSV->qryendpos, pSV->QryMap->site[0][pSV->QryMap->numsite[0]+1],
			 pSV->refstartpos,pSV->refendpos,pSV->RefMap->site[0][pSV->RefMap->numsite[0]+1], pSV->orientforward ? 0 : 1, pSV->type, pSV->confidence);
		  fflush(stdout);
		  if(DEBUG) assert(&SVtocheck[pSV->smapentryid-1] == pSV);
		}
		fflush(stdout);
	      }
	      if(SVlist[t-1]->confidence < SVlist[t]->confidence){/* NOTE : Typically both values are -ve, hence SVlist[t-1] is more significant */
		for(int u = t+1; u < SVlistCnt; u++)
		  SVlist[u-1] = SVlist[u];
	      } else {
		for(int u = t; u < SVlistCnt; u++)
		  SVlist[u-1] = SVlist[u];
	      }
	      SVlistCnt--;
	      t--;
	    }
	  }

	  if(SVlistCnt > 0){
	    if(VERB/* HERE >=2 */){
	      printf("Correcting %d SV's from Query id=%lld\n", SVlistCnt, qryid);
	      if(VERB/* HERE >=2 */){
		for(int t = 0; t < SVlistCnt; t++){
		  xmapEntry *pSV = SVlist[t];
		  printf("\t SV[%d/%d]==SVlist[%d/%d]:qid=%lld,rid=%lld:QueryRange=%0.3f..%0.3f(%0.3f),RefRange=%0.3f..%0.3f(%0.3f),or=%d,type=%s,confidence=%0.2f(mergecnt=%d)\n",
			 pSV->smapentryid-1,svCnt,t, SVlistCnt, pSV->qrycontigid,pSV->refcontigid,pSV->qrystartpos,pSV->qryendpos, pSV->QryMap->site[0][pSV->QryMap->numsite[0]+1],
			 pSV->refstartpos,pSV->refendpos,pSV->RefMap->site[0][pSV->RefMap->numsite[0]+1], pSV->orientforward ? 0 : 1, pSV->type, pSV->confidence, pSV->mergecnt);
		  if(pSV->mergecnt > 1){
		    for(int u = pSV->mergestart, v = pSV->mergecnt; --v >= 0; u++){
		      xmapEntry *qSV = &SVtocheck[u];
		      printf("\t\t SV[%d/%d]:qid=%lld,rid=%lld:QueryRange=%0.3f..%0.3f(%0.3f),RefRange=%0.3f..%0.3f(%0.3f),or=%d,type=%s,confidence=%0.2f\n",
			     qSV->smapentryid-1,svCnt, qSV->qrycontigid,qSV->refcontigid,qSV->qrystartpos,qSV->qryendpos, qSV->QryMap->site[0][qSV->QryMap->numsite[0]+1],
			     qSV->refstartpos,qSV->refendpos,qSV->RefMap->site[0][qSV->RefMap->numsite[0]+1], qSV->orientforward ? 0 : 1, qSV->type, qSV->confidence);
		      
		      if(DEBUG) assert(u < svCntOrig);
		      if(DEBUG) assert(SVtocheck[u].mergecnt==1);
		      if(DEBUG) assert(SVtocheck[u].mergestart == u);
		    }
		  }
		}
	      }
	      fflush(stdout);
	    }

	    extern void mapsplice(Cmap * &pmap, long long id, xmapEntry *pSV, double svcheckKB, int corrected, Cmap *QryMap, Cmap *RefMap);/* see input_svcheck.cpp */

	    /* repeatedly call mapsplice() to remove the next SV from Query i and shift the location of the remaining SVs by the size of the removed indel */
	    Cmap *qmap1 = NULL, *qmap2 = NULL;
	    mapsplice(qmap1, qryid, NULL, 0.0, 0, QryMap, NULL);/* copies QryMap[0] to qmap1[0] */

	    for(int t = 0; t < SVlistCnt; t++){
	      Cmap *RefMap = SVlist[t]->RefMap;
	      mapsplice(qmap2,qryid, SVlist[t], 1.0e+300, 1, qmap1, RefMap);

	      correctedCnt++;
	      totalCnt += SVlist[t]->mergecnt;
	      if(SVlist[t]->mergecnt > 1){/* mark original SVs that comprise this merged SV with mergestart = -1 */
		for(int u = SVlist[t]->mergestart, v = SVlist[t]->mergecnt; --v >= 0; u++){
		  if(DEBUG) assert(u < svCntOrig);
		  if(DEBUG) assert(SVtocheck[u].mergecnt==1);
		  if(DEBUG && !(SVtocheck[u].mergestart == u)){
		    printf("t=%d/%d:qryid=%lld,RefMap->id=%lld:SVlist[t]->mergecnt=%d,SVlist[t]->mergestart=%d:u=%d,v=%d,SVtocheck[u].mergecnt=%d,SVtocheck[u].mergestart=%d\n",
			   t,SVlistCnt,qryid,RefMap->id,SVlist[t]->mergecnt,SVlist[t]->mergestart,u,v,SVtocheck[u].mergecnt,SVtocheck[u].mergestart);
		    fflush(stdout);
		    assert(SVtocheck[u].mergestart == u);
		  }
		  SVtocheck[u].mergestart = -1;
		}
	      } else {
		if(DEBUG) assert(SVlist[t]->mergestart >= 0);
		SVlist[t]->mergestart = -1;
	      }
	      delete qmap1;
	      qmap1 = qmap2;
	      qmap2 = NULL;

	      double shift = fabs(SVlist[t]->refendpos - SVlist[t]->refstartpos) - fabs(SVlist[t]->qryendpos - SVlist[t]->qrystartpos);
	      for(int u = t+1; u < SVlistCnt; u++){
		SVlist[u]->qrystartpos += shift;
		SVlist[u]->qryendpos += shift;
	      }
	      if(VERB/* HERE */ >= 2 && t+1 < SVlistCnt){
		printf("After adjusting SVlist[%d..%d] by adding %0.3f to qrystartpos and qryendpos:\n",t+1,SVlistCnt-1,shift);
		for(int u = t+1; u < SVlistCnt; u++){
		  xmapEntry *pSV = SVlist[u];
		  printf("SVlist[%d/%d]:qid=%lld,rid=%lld:QueryRange=%0.3f..%0.3f(%0.3f),RefRange=%0.3f..%0.3f(%0.3f),or=%d,type=%s,confidence=%0.2f\n",
			 u, SVlistCnt, pSV->qrycontigid,pSV->refcontigid,pSV->qrystartpos,pSV->qryendpos, pSV->QryMap->site[0][pSV->QryMap->numsite[0]+1],
			 pSV->refstartpos,pSV->refendpos,pSV->RefMap->site[0][pSV->RefMap->numsite[0]+1], pSV->orientforward ? 0 : 1, pSV->type, pSV->confidence);
		}
		fflush(stdout);
	      }
	    }
	    /* save qmap1 as corrected Gmap[StartQuery+i] */
	    Gmap[StartQuery+i]->allfree();
	    //	    Cmap tmp = Gmap[StartQuery+i][0];
	    Gmap[StartQuery+i][0] = qmap1[0];
	    //	    qmap1[0] = tmp;
	    //	    delete qmap1;
	  }
	    
	  /* output the (corrected) Query i to <output_prefix>_contig<qryid>.cmap */
	  sprintf(basename,"%s_contig%lld",output_prefix,qryid);
	  if(VERB>=2){
	    printf("Will output corrected Query i=%d to %s.cmap\n",i,basename);
	    fflush(stdout);
	  }
	  output_cmap(basename, Gmap, StartQuery+i, StartQuery+i);
	} /* i = 0..NumMapsQuery -1 */
	if(VERB){
	  printf("Corrected %d single or merged SVs (corresponds to %d of %d original SVs)\n",correctedCnt, totalCnt, svCntOrig);
	  if(VERB/* HERE */ >=2){/* list all SVs that were NOT corrected */
	    printf("Uncorrected SVs are:\n");
	    for(int S = 0; S < svCntOrig; S++){
	      xmapEntry *pSV = &SVtocheck[S];
	      if(DEBUG) assert(pSV->smapentryid == S+1);
	      if(pSV->mergestart >= 0)
		printf("\t SV[%d/%d]:qid=%lld,rid=%lld:QueryRange=%0.3f..%0.3f(%0.3f),RefRange=%0.3f..%0.3f(%0.3f),or=%d,type=%s,confidence=%0.2f\n",
			 S,svCntOrig, pSV->qrycontigid,pSV->refcontigid,pSV->qrystartpos,pSV->qryendpos, pSV->QryMap->site[0][pSV->QryMap->numsite[0]+1],
		       pSV->refstartpos,pSV->refendpos,pSV->RefMap->site[0][pSV->RefMap->numsite[0]+1], pSV->orientforward ? 0 : 1, pSV->type, pSV->confidence);
	    }
	  }
	  fflush(stdout);
	}
      } /* if(svcheck) */

      if(DEBUG>=2) assert(giter == RefRepeats-1);

      int split_maps = (MappedUnsplit >= 0) ? !MappedUnsplit : (SplitRef && CMapID > 0) ? 1 : (svcheck && numrefmaps > 0) ? 1 : 0;
      if(split_maps && BestAlignments > 0){// cannot rely on numalign_start[],numalign_end[] or order of alignment[] 
	printf("Cannot split output files by contig with -bestalignments\n");
	fflush(stdout);
      }
      if(VERB>=2){
	printf("split_maps=%d\n",split_maps);
	fflush(stdout);
      }

      if(!pSNRtotLL){
	// MAJOR BUG introduced by qsort between r3933 and r3987, which will cause the numalign_start[] and numalign_end[] arrays to become invalid and hence the coverage profiles
	// in _r.cmap to become invalid since it indexes refmap[]. Also YYmap[] is an alias to refmap[], so later .xmap and mapped outputs may be refering to an incorrect ref map
	// There is no problem when hashtable is used since the remap[] array is already sorted by id so the following qsort() has no effect.

        // qsort(refmap,numrefmaps,sizeof(Cmap *), (intcmp*)CmapIdInc);

	printf("refalign.cpp:numrefmaps=%d\n",numrefmaps);
	fflush(stdout);

	extern Cmap **YYmap,**XXmap;
	extern int numY,numX;
	numY = numrefmaps;
	YYmap = refmap;
	numX = nummaps;
	XXmap = Gmap;

	output_csites(0, numrefmaps-1, output_prefix, split_maps, alignment, numalign_start, numalign_end, (MultiMatches && RefSplit && dosvdetect) ); /* output condensed reference map(s) as *_r.cmap file(s) */
      }

      int AlignmentOrdered = 1;/* If alignment[] are ordered by refid and numalign_start[],numalign_end[] are still valid */

      if(BestAlignments > 0){/* output only the best few alignments (based on logPV) */
	/* first remove below threshold alignments */
	size_t aligncnt = 0;
	for(size_t i=0; i < numaligns; i++){
	  Calign *p = alignment[i];
	  if(!p)
	    continue;
	  alignment[i] = 0;
	  Cmap *rmap = refmap[p->mapid1];
	  if(!AlignedThreshold(p, rmap->site[0], ScoreThreshold, LogPvThreshold)){
	    p->allfree();
	    delete [] p;
	    continue;
	  }
	  if(DEBUG) assert(alignment[i] == 0);
	  alignment[aligncnt++] = p;
	}
	if(DEBUG) assert(aligncnt <= numaligns);
	if(VERB>=2 && numaligns > aligncnt){
	  printf("filtered numaligns = %lu -> %lu\n",numaligns,aligncnt);
	  fflush(stdout);
	}
	numaligns = aligncnt;
	if(numaligns > (size_t)BestAlignments){
	  /* now sort alignments by logPV */
	  qsort(alignment,numaligns,sizeof(Calign *), (intcmp*)logPVdec);
	  numaligns = BestAlignments;
	}
	if(VERB){
	  printf("BestAlignments=%d,numaligns=%llu\n",BestAlignments,(unsigned long long)numaligns);
	  fflush(stdout);
	}

	AlignmentOrdered = 0;
      }

      if(DEBUG) assert(!(RepeatShift > 0.0 || FirstAlignments > 0));

      if(DEBUG>=2) assert(giter == RefRepeats-1);

      if(DEBUG>=3 && AlignmentOrdered){
        for(int refid = 0;refid < numrefmaps;refid++){
          for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
            Calign *align = alignment[alignid];
	    if(!align)
	      continue;
	    if(DEBUG) assert(align->mapid1 == refid);
          }
	}
      }

      if(!pSNRtotLL){
	if(!NoStat)
	  output_refalign(0, numrefmaps-1, output_prefix);/* output .map file  */

	if(Ch > 0.0 && ChFdr > 0.0)
	  output_chimmaps(output_prefix);/* output .chim file */

	if(DEBUG>=3 && AlignmentOrdered){
	  for(int refid = 0;refid < numrefmaps;refid++){
	    for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	      Calign *align = alignment[alignid];
	      if(!align)
		continue;
	      if(DEBUG) assert(align->mapid1 == refid);
	    }
	  }
	}

	if(DEBUG>=2) assert(colors==1);

	if(DEBUG>=2) assert(giter == RefRepeats-1);

	if(((Ch > 0.0 && ChFdr > 0.0) || (NEW && PoutlierEnd >= 0.0)) && giter2 == RefRepeats2 - 1){/* output XMAP and _q.cmap */
	  for(int refid = 0; refid < numrefmaps; refid++)
	    refmap[refid]->origmap = 0;/* reference maps are never chimeric fragments in refalign.cpp */

	  extern Cmap **YYmap,**XXmap;
	  extern int numY,numX;
	  numY = numrefmaps;
	  YYmap = refmap;
	  numX = nummaps;
	  XXmap = Gmap;

	  if(DEBUG) assert(0 <= nummaps && nummaps <= MASK(31));
	  if(DEBUG) assert(0 <= numrefmaps && numrefmaps <= MASK(31));

	  int numLL = (numrefmaps + 63)/64;/* number of 64 bit words required to represent a bit of of size = numrefmaps (bits). NOTE : bits run 0 .. numrefmaps -1 */
	  unsigned long long *MapSave = NULL;
	  if(split_maps && (MultiMatches || DEBUG>=2)){/* duplicate maps should only happen with MultiMatches */
	    size_t siz = (size_t)nummaps * (size_t)numLL;
	    MapSave = new unsigned long long[siz];
	    memset(MapSave,0,siz*sizeof(unsigned long long));
	  }

	  int refmax = split_maps ? numrefmaps : 1;

	  int nthreads = usecolor ? 1 : max(1,min(numthreads, refmax));

	  //	  nthreads = 1;

	  if(VERB/* HERE >=2 */ && refmax > 1 && nthreads > 0){
	    printf("Using %d threads to output to %d .xmap and _q.cmap files (numrefmaps=%d,nummaps=%d,refmax=%d,numthreads=%d,usecolor=%d)\n", nthreads, refmax, numrefmaps,nummaps,refmax,numthreads,usecolor);
	    fflush(stdout);
	  }

	  #pragma omp parallel num_threads(nthreads) if(nthreads > 1 && refmax > 1)
	  {
	    int tid = 0;
#ifdef _OPENMP
	    tid = omp_get_thread_num ();
#endif
	    /* need to create single CMAP file of input CMAP file(s) from possibly rescaled & filtered maps */
	    char refid_prefix[PATH_MAX],cmapprefix[PATH_MAX],queryfilename[PATH_MAX];
	
	    /* assemble array of pointers to maps that have an alignment above all 3 thresholds into array goodmap[0..goodmapcnt-1] */
	    int goodmaps_alloc = mapcnt;
	    Cmap **goodmaps = new Cmap *[goodmaps_alloc];

#if !USE_MIC
            #pragma omp for schedule(dynamic,1)
#endif
	    for(int refid = 0; refid < refmax; refid++){
	      if(USE_MIC && !((refid % nthreads) == tid)){ // approximate #pragma omp for schedule(static,1)
	        continue;
	      }

	      size_t align_start = 0, align_end = numaligns;
	      if(!split_maps)
		for(int i = 0; i < nummaps; i++)
		  Gmap[i]->paired = 0;/* initialize duplicate check */
	      else {
		if(DEBUG) assert(AlignmentOrdered);
	        align_start = numalign_start[refid];
		align_end = numalign_end[refid];
	      }
	      int RefWord = refid / 64; // WAS10 (refid - 1) / 64;
	      int RefBit = refid % 64; // WAS10 (refid - 1) % 64;
	      unsigned long long RefMask = 1LL << RefBit;

	      int numgoodmaps = 0;
	      if(VERB>=2 && giter2 + 1 == 3 && giter + 1 == 3 && refmap[refid]->id == 25285LL){
		if(split_maps)
		  printf("refid=%d:alignid=%lu..%lu\n",refid,align_start,align_end-1);
		else
		  printf("refid=%d..%d:alignid=%lu..%lu\n",0,numrefmaps-1,align_start,align_end-1);
		fflush(stdout);
	      }

	      for(size_t i = align_start; i < align_end; i++){
		Calign *p = alignment[i];
		if(!p || p->numpairs <= 0)
		  continue;
		if(DEBUG && split_maps && !(p->mapid1 == refid)){
		  printf("refid=%d,align_start=%lu,align_end=%lu,i=%lu:alignment[i]->mapid1=%d\n",
			 refid,align_start,align_end,i,alignment[i]->mapid1);
		  fflush(stdout);
		  assert(p->mapid1 == refid);
		}
		Cmap *rmap = refmap[p->mapid1];
		if(!split_maps){
		  FLOAT *Y = rmap->site[0];
		  int N = rmap->numsite[0];
		  if(N < max(1, AlignedSiteThreshold) || Y[N] <= Y[1] + max(res[0]*PixelLen,AlignedLengthThreshold)){
		    if(TRACE/* HERE HERE >=2 */ && YYmap[p->mapid1]->id == REF_TRACE && XXmap[p->mapid2]->id == MAP_TRACE){
		      printf("alignid=%lu(%lu..%lu):Skipping refid=%d(id=%lld),mapid=%d(%lld): N=%d(AlignedSiteThreshold=%d),Y[1]=%0.3f,Y[N]=%0.3f(PixelLen=%0.6f,AlignedLengthThreshold=%0.3f)\n",
			     i,align_start,align_end,p->mapid1,YYmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,N,AlignedSiteThreshold,Y[1],Y[N],PixelLen,AlignedLengthThreshold);
		      fflush(stdout);
		    }
		    p->logPV = -1.0;// NEW45 : Make sure this alignment does not accidentally end up in xmap
		    continue;
		  }
		}

		if(!AlignedThreshold(p, rmap->site[0], RefSplit ? ScoreThreshold2 : ScoreThreshold, RefSplit ? LogPvThreshold2 : LogPvThreshold)){
 	          if(TRACE/* HERE HERE >=2 */ && YYmap[p->mapid1]->id == REF_TRACE && XXmap[p->mapid2]->id == MAP_TRACE){
		    printf("alignid=%lu(%lu..%lu):Skipping refid=%d(id=%lld),mapid=%d(id=%lld): numpairs= %d, score= %0.3f, logPV= %0.2f, maxoutlier= %0.3f, EndPass=%d, Length= %0.3f (RefSplit=%d,A=%d,S=%0.2f,T=%0.2f,I=%0.2f,E=%d,L=%0.2f)\n",
			   i,align_start,align_end, p->mapid1,YYmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->numpairs,p->score,p->logPV,p->maxoutlier, AlignedEndOutlier(p), AlignedLength(p,rmap->site[0]),
	              RefSplit, AlignedSiteThreshold, RefSplit ? ScoreThreshold2 : ScoreThreshold, RefSplit ? LogPvThreshold2 : LogPvThreshold, 
	              min(1000.0,AlignedOutlierThreshold),AlignedEndOutlierThreshold,AlignedLengthThreshold);
		    fflush(stdout);
		  }
		  p->logPV = -1.0;// NEW45 : Make sure this alignment does not accidentally end up in xmap (output_xmap() does not check thresholds other than -A,-S,-T)
		  continue;
		}
		if(DEBUG>=1+RELEASE/* HERE >=2 */ && !(p->mapWT >= 0.0 && p->mapWT <= 1.0)){
		  printf("refid=%d(id=%lld),mapid=%d(%lld),or=%d: mapWT= %0.8e, UnrefinedMinMapwt= %0.4f\n",p->mapid1,YYmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->mapWT,UnrefineMinMapwt);
		  fflush(stdout);
		  assert(p->mapWT >= 0.0 && p->mapWT <= 1.0);
		}
	        if(TRACE/* HERE HERE >=2 */ && YYmap[p->mapid1]->id == REF_TRACE && XXmap[p->mapid2]->id == MAP_TRACE){
		  printf("alignid=%lu(%lu..%lu):refid=%d(id=%lld),mapid=%d(%lld),or=%d: mapWT= %0.4f, UnrefinedMinMapwt= %0.4f %s\n",
			 i,align_start,align_end,p->mapid1,YYmap[p->mapid1]->id,p->mapid2,Gmap[p->mapid2]->id,p->orientation,p->mapWT,UnrefineMinMapwt,
			 (p->mapWT < UnrefineMinMapwt) ? ": Filtered out" : "");
		  fflush(stdout);
		}
		if(p->mapWT < UnrefineMinMapwt){
	          p->logPV = -1.0;// NEW45 : Make sure this alignment does not accidentally end up in xmap
		  continue;
		}

		Cmap *Xmap = Gmap[p->mapid2];

		//	    if(BestRef && Xmap->align->mapid1 != p->mapid1)
		//	      continue;/* skip alignment unless it is with the reference with the best alignment score with this map Xmap */

		Cmap *origmap = Xmap;
		while(origmap->origmap)
		  origmap = origmap->origmap;

		if(DEBUG>=2){
		  int origgoodalign = AlignedThreshold(p, rmap->site[0], startScoreThreshold, startLogPvThreshold) ? 1 : 0;
		  int goodalign = (origgoodalign && p->score > ScoreThreshold && p->logPV > LogPvThreshold) ? 1 : 0;
		  if(!goodalign){
		    printf("%d:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.6f(Thr=%0.6f,%0.6f),logPV=%0.2f(Thr=%0.2f,%0.2f),numpairs=%d,origmap->id=%lld,origmap->paired=%d,mapcnt=%d:origgoodalign=%d,goodalign=%d\n",
			   numgoodmaps,p->mapid1,p->mapid2,Xmap->id,p->orientation,p->score,startScoreThreshold,ScoreThreshold, 
			   p->logPV, startLogPvThreshold, LogPvThreshold,p->numpairs,origmap->id,origmap->paired,mapcnt,origgoodalign,goodalign);
		    fflush(stdout);
		    assert(goodalign);
		  }
		}

		if(BestRef && origmap->align->mapid1 != p->mapid1 && BestRefExtCheck(p,origmap->align,p->mapid2,p->mapid1)){
	          if(TRACE/* HERE HERE >=2 */ && YYmap[p->mapid1]->id == REF_TRACE && XXmap[p->mapid2]->id == MAP_TRACE){
		    printf("BestRef Skipping: refid=%d,mapid=%d(%lld):align score=%0.6f,logPV=%0.2f,numpairs=%d,or=%d: best refid=%d,BestRefExtCheck()=%d\n",
			   p->mapid1,p->mapid2,Xmap->id,p->score,p->logPV,p->numpairs,p->orientation,origmap->nalign->mapid1,BestRefExtCheck(p,origmap->align,p->mapid2,p->mapid1));
		    fflush(stdout);
		  }
	          p->logPV = -1.0;// NEW45 : Make sure this alignment does not accidentally end up in xmap
		  continue;/* No xmap output of alignment unless it is with the reference with the best alignment score with Xmap->origmap */
		}

	        if(TRACE/* HERE HERE >=2 */ && YYmap[p->mapid1]->id == REF_TRACE && XXmap[p->mapid2]->id == MAP_TRACE){
		  int origgoodalign = AlignedThreshold(p, rmap->site[0], startScoreThreshold, startLogPvThreshold) ? 1 : 0;
		  int goodalign = (origgoodalign && p->score > ScoreThreshold && p->logPV > LogPvThreshold) ? 1 : 0;
		  printf("%d:refid=%d,mapid=%d(id=%lld),or=%d:score=%0.6f,logPV=%0.2f,numpairs=%d,origmap->id=%lld,origmap->paired=%d,mapcnt=%d,origgoodalign=%d,goodalign=%d\n",
			 numgoodmaps,p->mapid1,p->mapid2,Xmap->id,p->orientation,p->score,p->logPV,p->numpairs,origmap->id,origmap->paired,mapcnt,origgoodalign,goodalign);
		  fflush(stdout);
		}

		if(!split_maps){
		  if(DEBUG && BestRef && NoSplit==2 && !(BestRefExt > 0.0 || BestRefOutlier <= 999.0) && origmap->paired){
		    printf("align_start=%lu,align_end=%lu,i=%lu:p->mapid1=%d(id=%lld),p->mapid2=%d(id=%lld):Xmap->paired = %d (expected 0),origmap->align->mapid1=%d(id=%lld)\n",
			   align_start,align_end,i,p->mapid1,YYmap[p->mapid1]->id,p->mapid2,XXmap[p->mapid2]->id,origmap->paired,origmap->align->mapid1,YYmap[origmap->align->mapid1]->id);
		    fflush(stdout);
		    assert(!origmap->paired);
		  }
		  if(origmap->paired)
		    continue;/* avoid duplicate map */
		  origmap->paired = 1 + p->mapid1;
		  if(DEBUG/* >=2 */) assert(origmap->paired);
		}

		/* check for duplicate maps (should only be needed with -MultiMatches) */
#if 0 // OLD slow code (newer code checks complete list goodmaps[0.. numgoodmaps-1] later for duplicates
		if(split_maps && (MultiMatches || DEBUG>=2)){// this is very slow : Use faster bitmap method used with -mapped output  (see below)
		  int t = 0;
		  for(; t < numgoodmaps; t++)
		    if(origmap == goodmaps[t])
		      break;
		  if(t < numgoodmaps){/* duplicate map */
		    if(DEBUG) assert(MultiMatches);
		    continue;
		  }
		}
#endif

		if(numgoodmaps >= goodmaps_alloc){
		  if(MultiMatches || RefineHmap){
		    int ngoodmaps_alloc = max(16,(numgoodmaps * 5)/4);
		    Cmap **ngoodmaps = new Cmap *[ngoodmaps_alloc];
		    memcpy(ngoodmaps,goodmaps,numgoodmaps * sizeof(Cmap *));
		    delete [] goodmaps;
		    goodmaps = ngoodmaps;
		    if(VERB>=2 && rmap->id == 25285){
		      printf("numgoodmaps=%d, goodmaps_alloc= %d -> %d\n",numgoodmaps,goodmaps_alloc,ngoodmaps_alloc);
		      fflush(stdout);
		    }
		    goodmaps_alloc = ngoodmaps_alloc;
		  } else {
		    printf("refid=%d:numgoodmaps=%d,mapcnt=%d (goodmaps_alloc=%d): buffer overflow!\n",refid,numgoodmaps,mapcnt, goodmaps_alloc);

		    for(size_t i = align_start; i < align_end; i++){
		      Calign *p = alignment[i];		      
		      if(!p || p->numpairs <= 0)
			continue;
		      Cmap *rmap = refmap[p->mapid1];
		      if(!split_maps){
			FLOAT *Y = rmap->site[0];
			int N = rmap->numsite[0];
			if(N < max(1,AlignedSiteThreshold) || Y[N] <= Y[1] + max(res[0]*PixelLen,AlignedLengthThreshold))
			  continue;
		      }

		      if(!AlignedThreshold(p, rmap->site[0], ScoreThreshold, LogPvThreshold))
			continue;
		      if(DEBUG>=1+RELEASE/* HERE >=2 */) assert(p->mapWT >= 0.0 && p->mapWT <= 1.0);
		      if(p->mapWT < UnrefineMinMapwt)
			continue;

		      Cmap *Xmap = Gmap[p->mapid2];
		      Cmap *origmap = Xmap;
		      while(origmap->origmap)
			origmap = origmap->origmap;
		      if(BestRef && origmap->align->mapid1 != p->mapid1 && BestRefExtCheck(p,origmap->align,p->mapid2,p->mapid1))
			continue;
		      if(!split_maps){
			if(origmap->paired)
			  continue;
			origmap->paired = 1 + p->mapid1;
		      }
		      int U = p->numpairs;
		      printf("i=%lu(%lu..%lu):refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,score=%0.6f,logPV=%0.2f,numpairs=%d:I=%d..%d,J=%d..%d\n",
			     i,align_start,align_end,p->mapid1,rmap->id,p->mapid2,Xmap->id,p->orientation,p->score,p->logPV,U,p->sites1[0],p->sites1[U-1],p->sites2[0],p->sites2[U-1]);
		    }
		    fflush(stdout);
		  }
		}
		if(DEBUG) assert(numgoodmaps < goodmaps_alloc);
		goodmaps[numgoodmaps++] = origmap;
	      } // for i = align_start .. align_end - 1


	      if(DEBUG && !(numgoodmaps <= goodmaps_alloc)){
		printf("refid=%d(%lld):numgoodmaps=%d,mapcnt=%d,nummaps=%d,goodmaps_alloc=%d\n",refid,YYmap[refid]->id,numgoodmaps,mapcnt,orignummaps,goodmaps_alloc);
		fflush(stdout);
		assert(numgoodmaps <= goodmaps_alloc);
	      }

	      if(split_maps && (MultiMatches || DEBUG>=2)){ /* check for duplicate maps (requires read/write of shared bitmap MapSave[]) */
                #pragma omp critical(MapSavelock)
		{
		  for(int i = 0; i < numgoodmaps; i++){
		    size_t /* WAS27 int */ Mindex = goodmaps[i]->mapid * (size_t) numLL + RefWord;
		    if(TRACE/* HERE HERE >=2 */ && YYmap[refid]->id == REF_TRACE && XXmap[goodmaps[i]->mapid]->id == MAP_TRACE){
		      printf("refid=%d(id=%lld):goodmaps[%d]:mapid=%d(%lld),Mindex=%lu,RefMask=%llu,MapSave[Mindex]=%llu\n",
		        refid,YYmap[refid]->id,i,goodmaps[i]->mapid,goodmaps[i]->id,Mindex,RefMask,MapSave[Mindex]);
		      fflush(stdout);
		    }
		    if(MapSave[Mindex] & RefMask){
		      if(TRACE/* HERE HERE >=2 */ && YYmap[refid]->id == REF_TRACE && XXmap[goodmaps[i]->mapid]->id == MAP_TRACE){
		        printf("refid=%d(id=%lld):deleted mapid=%d(%lld) from goodmaps[]\n",refid,YYmap[refid]->id,goodmaps[i]->mapid,goodmaps[i]->id);
			fflush(stdout);
		      }
		      goodmaps[i] = 0;
		    } else
		      MapSave[Mindex] |= RefMask;
		  }
		}

		int j = 0;
		for(int i = 0; i < numgoodmaps; i++){
		  if(!goodmaps[i])
		    continue;
		  goodmaps[j++] = goodmaps[i];
		}
		if(j < numgoodmaps){
		  if(VERB/* HERE HERE >=2 */){
		    printf("refid=%d:numgoodmaps=%d->%d due to duplicate maps (RefWord=%d,RefBit=%d,RefMask=%llu)\n",refid,numgoodmaps,j,RefWord,RefBit,RefMask);
		    fflush(stdout);
		  }
		  numgoodmaps = j;
		}
	      }

	      if(!split_maps)
		strcpy(refid_prefix,output_prefix);
	      else
		sprintf(refid_prefix,"%s_contig%lld",output_prefix,YYmap[refid]->id);

	      sprintf(cmapprefix,"%s_q",refid_prefix);
	  
	      if(usecolor)
		colors = 2;
	      if(usecolor==2){
		for(int i = 0; i < numgoodmaps; i++)
		  goodmaps[i]->colorswap(usecolor);
		char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;

		if(VERB/* HERE HERE >=2 */){
		  printf("Swapped 1st and 2nd color for %d query maps due to -usecolor 2 before output of query maps %s.%s (colors=%d)\n",numgoodmaps, cmapprefix, CmapMergeBnx ? ".bnx" : ".cmap", colors);
		  printf("Nickase[0]= %s\n",Nickase[0]);
		  printf("Nickase[1]= %s\n",Nickase[1]);
		  fflush(stdout);
	        }
	      }

	      qsort(goodmaps,numgoodmaps,sizeof(Cmap *), (intcmp*)CmapIdInc);

	      if(CmapMergeBnx){
		output_bnx(cmapprefix,goodmaps,0,numgoodmaps-1, 0,  NULL, NULL, -1);
		sprintf(queryfilename,"%s.bnx",cmapprefix);	  /* output xmap queryfilename */
	      } else {
		output_cmap(cmapprefix,goodmaps,0,numgoodmaps-1);
		sprintf(queryfilename,"%s.cmap",cmapprefix);	  /* output xmap queryfilename */
	      }

	      if(usecolor==2){
		for(int i = 0; i < numgoodmaps; i++)
		  goodmaps[i]->colorswap(usecolor);
		char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
		if(VERB/* HERE HERE >=2 */){
		  printf("Swapped 1st and 2nd color for %d query maps due to -usecolor 2 after output of query maps %s (colors = 1)\n",numgoodmaps, queryfilename);
		  printf("Nickase[0]= %s\n",Nickase[0]);
		  printf("Nickase[1]= %s\n",Nickase[1]);
		  fflush(stdout);
	        }
	      }
	      if(usecolor)
		colors = 1;

	      if(VERB>=2){
		#pragma omp critical
		{
		  printf("tid=%d,refid=%d:calling output_xmap:split_maps=%d,SplitRef=%d,CMapID=%lld,refid_prefix=%s,queryfilename=%s,start=%lu,end=%lu\n",
			 tid,refid,split_maps,SplitRef,CMapID,refid_prefix,queryfilename,align_start,align_end);
		  fflush(stdout);
	        }
	      }

	      char *qtmp = strdup(queryfilename);// output_xmap() & output_smap() expect a pointer to a malloc'd string that can be re-allocated 

	      if(DEBUG>=3 && AlignmentOrdered && !split_maps){
		for(int refid = 0;refid < numrefmaps;refid++){
		  for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
		    Calign *align = alignment[alignid];
		    if(!align)
		      continue;
		    if(DEBUG) assert(align->mapid1 == refid);
		  }
		}
	      }

	      output_xmap(refid_prefix,qtmp,align_start,align_end, (MultiMatches && RefSplit && dosvdetect));/* output alignments (above 3 thresholds) as .xmap file : should not reorder alignment[] */
	      
	      if(DEBUG>=3 && AlignmentOrdered && !split_maps){
		for(int refid = 0;refid < numrefmaps;refid++){
		  for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
		    Calign *align = alignment[alignid];
		    if(!align)
		      continue;
		    if(DEBUG) assert(align->mapid1 == refid);
		  }
		}
	      }

	      if(MultiMatches && RefSplit && dosvdetect){
		/*		if(MultiMatchTrim_MaxCnt > 0){
		  printf("MM_MaxCnt=%lld, rid=%lld,mid=%lld,or=%d,rev=%d\n",MultiMatchTrim_MaxCnt,MM_refid,MM_mapid,MM_or,MM_rev);
		  fflush(stdout);
		  }*/
		size_t orig_numaligns = numaligns;

		output_smap(refid_prefix,qtmp);// output .smap file

		if(!NoStat && numaligns > orig_numaligns){/* ignore split alignments in parameter estimation */
		  if(VERB>=2){
		    printf("After output_smap: restored numaligns = %lu -> %lu\n",numaligns,orig_numaligns);
		    fflush(stdout);
		  }
		  numaligns = orig_numaligns;
		}

	      }

	      free(qtmp);
	    } // refid = 0 .. (split_maps ? numrefmaps - 1 : 0)

	    delete [] goodmaps;
	  } // omp parallel
		
	  delete [] MapSave;
        }
	  
	if(DEBUG>=3 && AlignmentOrdered){
	  for(int refid = 0;refid < numrefmaps;refid++){
	    for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
	      Calign *align = alignment[alignid];
	      if(!align)
		continue;
	      if(DEBUG) assert(align->mapid1 == refid);
	    }
	  }
	}

	if(MappedPrefix){/* output maps that scored above threshold to <MappedPrefix>.bnx */
	  if(VERB){
	    printf("Starting output of mapped bnx files: CPU time=%0.6f, wall time=%0.6f\n", mtime(),wtime());
	    fflush(stdout);
	  }
	  int nthreads = usecolor ? 1 : max(1,min(numthreads,numrefmaps));

	  if(groupfile) {
	    if(SplitHmap /* WAS && (HapSitePvalue > 0.0 || HapIndelPvalue > 0.0) */ && Hapmaps > 0){/* make Allele 2 id match that of Allele 1 (same as input id) */
	      // HERE HERE : eventually this should be removed and instead the groupfile() function should use SplitHmap to correctly map both Alleles back to the Allele1's group
	      if(!RefineHmap && Hapmaps > 0){
		printf("Input of %d Haplotyped Cmaps with -mapped %s and -grouped %s not supported without -RefineHmap 1\n", Hapmaps, MappedPrefix, groupfile);
		fflush(stdout);exit(1);
	      }
	      if(DEBUG) assert(MaxContigID > 0);
	      int cnt = 0;
	      for(int i = 0; i < numrefmaps; i++){
		if(refmap[i]->id > MaxContigID){
		  if(VERB>=2){
		    printf("refmap[%d]->id = %lld -> %lld to match Allele 1 (MaxContigID=%lld)\n",
			   i,refmap[i]->id, refmap[i]->id - MaxContigID, MaxContigID);
		    fflush(stdout);
		  }
		  refmap[i]->id -= MaxContigID;
		  cnt++;
		}
	      }
	      if(VERB/* HERE >=2 */){
		printf("Reset Allele 2 contig id to match the id of Allele 1 for %d Haplotyped map pairs (MaxContigID=%lld)\n",cnt,MaxContigID);
		fflush(stdout);
	      }
	      if(DEBUG) assert(cnt == Hapmaps);
	    }

	    if(!AlignmentOrdered){
	      if(DEBUG) assert(BestAlignments > 0);
	      printf("Cannot used -group option with -bestalignments\n");
	      fflush(stdout);exit(1);
	    }


	    if(DEBUG) assert(0 <= nummaps && nummaps <= MASK(31));

	    int numgroups = input_groups(groupfile,refmap,numrefmaps);/* refmap[0..numrefmaps-1]->paired are set to group ids ranging from 1 .. numgroups */
	    if(DEBUG) assert(0 <= numgroups && numgroups <= MASK(31));

	    int numLL = (numgroups + 63)/64;/* number of 64bit words required to represent a bitmap of size = numgroups (bits). NOTE : bits run 0..numgroups-1 */
	    size_t siz = (size_t) nummaps * (size_t) numLL;
	    unsigned long long *MapSave = new unsigned long long[siz];/* bitmap used to keep track of which maps have been saved to each group output (to avoid duplicates) */
	    memset(MapSave,0,siz*sizeof(unsigned long long));

	    FILE **groupFP  =  new FILE*[numgroups+1];
	    char **groupbuffer = new char*[numgroups+1];
	    omp_lock_t *lock = new omp_lock_t[numgroups+1];/* omp file locks */
	    for(int i = 1; i <= numgroups; i++){
	      groupFP[i] = NULL;
	      groupbuffer[i] = NULL;
#ifdef _OPENMP
	      omp_init_lock(&lock[i]);
#endif
	    }

#if SPARSE_MAPWT == 1
	    std::map<int,float> *mapWT = new std::map<int,float> [nummaps];// array of map<int,float> : mapWT[mapid][groupid]
#else
	    float **mapWT = new float*[numgroups+1];
	    float *mapWTmem = NULL;  // This array can be very large
	    memset(mapWT, 0, (numgroups+1) * sizeof(float *));
#endif

	    if(DEBUG>=3){
	      for(int refid = 0;refid < numrefmaps;refid++){
		for(size_t alignid = numalign_start[refid]; alignid < numalign_end[refid]; alignid++){
		  Calign *align = alignment[alignid];
		  if(!align)
		    continue;
		  if(DEBUG) assert(align->mapid1 == refid);
		}
	      }
	    }

	    if(BestRefWT){/* compute mapWT[group=0..numgroups-1][mapid = 0 .. nummaps-1] by summing up the corresponding mapWT values over all matching matchgroups (alignments) */
#if SPARSE_MAPWT == 0
	      /* initialize mapWT[group][mapid] = 0.0 */
	      size_t siz = (size_t)numgroups * (size_t)nummaps;
	      mapWTmem = new float[siz];
	      for(size_t g = 1; g <= (size_t)numgroups; g++)
		mapWT[g] = &mapWTmem[(g-1) * (size_t)nummaps];
	      memset(mapWTmem, 0, siz * sizeof(float));
	      if(VERB/* HERE HERE >=2 */){
		printf("Allocated %lu floats at mapWTmem=%p: numgroups=%d, nummaps=%d, mapWT= %p\n",
		       siz,mapWTmem,numgroups,nummaps,mapWT);
		if(VERB/* HERE HERE >=2 */){
		  long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
		  getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
		  printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb : CPU time= %0.6f, wall time= %0.6f\n",
			 VmSize * 1e-9, VmRSS * 1e-9, VmHWM * 1e-9, VmSwap * 1e-9, mtime(), wtime());
		}
		fflush(stdout);
	      }
#endif
	      /* loop over mapWT of all matchgroups (alignments) */
	      for(size_t i = 0; i < numaligns; i++){
		Calign *p = alignment[i];
		if(!p /* WAS157 || p->numpairs <= 0*/)
		  continue;
		int refid = p->mapid1;
		if(DEBUG>=2) assert(0 <= refid && refid < numrefmaps);
		Cmap *rmap = refmap[refid];
		int group = rmap->paired;
		if(DEBUG>=2) assert(0 < group && group <= numgroups);

		if(!AlignedThreshold(p, rmap->site[0], ScoreThreshold, LogPvThreshold))
		  continue;
		int mapid = p->mapid2;
		if(DEBUG>=2) assert(Gmap[mapid]->mapid == mapid);
		if(DEBUG>=2) assert(0 <= mapid && mapid < nummaps);
		if(MultiMatches){/* iterate over all matchgroups */
		  for(int t = 0; t < p->multicnt; t++){
#if SPARSE_MAPWT == 1
		    mapWT[mapid][group] += p->Malign[t]->mapWT;
		    if(DEBUG>=2 && !(mapWT[mapid][group] <= 1.0 + 1e-7)){
		      printf("refid=%d(id=%lld,group=%d),mapid=%d(id=%lld),or=%d:t=%d/%d:mapWT[mapid][group]= %0.8f,p->Malign[t]:mapWT=%0.8f,or=%d,score=%0.6f,logPV=%0.2f(S=%0.4f,T=%0.2f)\n",
			     refid,rmap->id,group,mapid,Gmap[mapid]->id,p->orientation,t,p->multicnt,mapWT[mapid][group],p->Malign[t]->mapWT,p->Malign[t]->orientation,
			     p->Malign[t]->score,p->Malign[t]->logPV,ScoreThreshold,LogPvThreshold);
#else
		    mapWT[group][mapid] += p->Malign[t]->mapWT;
		    if(DEBUG>=2 && !(mapWT[group][mapid] <= 1.0 + 1e-7)){
		      printf("refid=%d(id=%lld,group=%d),mapid=%d(id=%lld),or=%d:t=%d/%d:mapWT[group][mapid]= %0.8f,p->Malign[t]:mapWT=%0.8f,or=%d,score=%0.6f,logPV=%0.2f(S=%0.4f,T=%0.2f)\n",
			     refid,rmap->id,group,mapid,Gmap[mapid]->id,p->orientation,t,p->multicnt,mapWT[group][mapid],p->Malign[t]->mapWT,p->Malign[t]->orientation,
			     p->Malign[t]->score,p->Malign[t]->logPV,ScoreThreshold,LogPvThreshold);
#endif
		      double WTsum = 0.0;
		      for(size_t j = 0; j < numaligns; j++){
			Calign *q = alignment[j];
			if(!q /* WAS157 || q->numpairs <= 0*/)
			  continue;
			int rid = q->mapid1;
			if(!AlignedThreshold(q, refmap[rid]->site[0], ScoreThreshold, LogPvThreshold))
			  continue;
			int mid = q->mapid2;
			if(mid != mapid)
			  continue;
			for(int u = 0; u < q->multicnt; u++){
			  Calign *r = q->Malign[u];
			  WTsum += r->mapWT;
			  printf("rid=%d(id=%lld),mid=%d(id=%lld):u=%d/%d:q->Malign[u]:score=%0.6f,logPV=%0.2f/%0.2f,np=%d,mapWT=%0.6f,or=%d:WTsum=%0.6f\n",
				 rid,refmap[rid]->id,mid,Gmap[mid]->id,u,q->multicnt,r->score,r->logPV,LogPvThreshold,r->numpairs,r->mapWT,r->orientation,WTsum);
			}
		      }
		      fflush(stdout);
#if SPARSE_MAPWT == 1
		      assert(mapWT[mapid][group] <= 1.0 + 1e-7);
#else
		      assert(mapWT[group][mapid] <= 1.0 + 1e-7);
#endif
		    }
		  }
		} else {
#if SPARSE_MAPWT == 1
		  if(DEBUG>=2) assert(0 <= mapid && mapid < nummaps);  
		  mapWT[mapid][group] += p->mapWT;
		  if(DEBUG>=2) assert(mapWT[mapid][group] <= 1.0 + 1e-7);
#else
		  mapWT[group][mapid] += p->mapWT;
		  if(DEBUG>=2) assert(mapWT[group][mapid] <= 1.0 + 1e-7);
#endif
		}
	      }
	    }

	    if(VERB/* HERE HERE >=2 */){
	      long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
	      getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
	      printf("After computing mapWT[][] : VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb : CPU time= %0.6f, wall time= %0.6f\n",
		     VmSize * 1e-9, VmRSS * 1e-9, VmHWM * 1e-9, VmSwap * 1e-9, mtime(), wtime());
	      fflush(stdout);
	    }

	    if(usecolor)
	      colors = 2;

	    //	    if(USE_MIC) nthreads = 1;

	    if(VERB){
	      if(VERB>=2)
		printf("numthreads=%d,nthreads=%d\n",numthreads,nthreads);
	      printf("Using %d threads to output to %d BNX files (numrefmaps=%d)\n", nthreads, numgroups, numrefmaps);
	      fflush(stdout);
	    }

	    #pragma omp parallel num_threads(nthreads) if(nthreads > 1)
	    {
	      int tid = 0;
#ifdef _OPENMP
	      tid = omp_get_thread_num ();
#endif

	      /* assemble all good maps for one refid into array goodmap[0..goodmapcnt-1] */
	      char MappedIdPrefix[PATH_MAX];
	      Cmap **goodmaps = new Cmap *[mapcnt];
	    
#if !USE_MIC
              #pragma omp for schedule(dynamic,1)
#endif
	      for(int refid = 0; refid < numrefmaps; refid++){
  	        if(USE_MIC && !((refid % nthreads) == tid)){// approximate #pragma omp for schedule(static,1)
		  continue;
		}

		Cmap *rmap = refmap[refid];
		int group = rmap->paired;
		if(VERB>=2){
                  #pragma omp critical
	          {
		    printf("refid=%d:tid=%d,group=%d (-S %0.3f -T %0.6e -A %d -L %0.2f)\n",refid,tid,group,ScoreThreshold,LogPvThreshold,AlignedSiteThreshold, AlignedLengthThreshold);
		    fflush(stdout);
	          }
		}
		if(DEBUG) assert(0 < group && group <= numgroups);
		int groupWord = (group-1)/64;
		int groupBit = (group-1)%64;
		unsigned long long groupMask = 1LL << groupBit;
		size_t align_start = numalign_start[refid], align_end = numalign_end[refid];
		if(DEBUG) assert(AlignmentOrdered);

		int numgoodmaps = 0;
		for(size_t i = align_start; i < align_end; i++){
		  Calign *p = alignment[i];
		  if(!p /* WAS157 || p->numpairs <= 0 */)
		    continue;
		  if(DEBUG>=2) assert(p->mapid1 == refid);
		  Cmap *rmap = refmap[refid];
		  if(!AlignedThreshold(p, rmap->site[0], ScoreThreshold, LogPvThreshold))
		    continue;
		  Cmap *Xmap = Gmap[p->mapid2];
		  if(DEBUG>=2 && !(Xmap->mapid == p->mapid2)){
		    #pragma omp critical
		    {
		      printf("tid=%d:refid=%d(id=%lld),group=%d,i=%lu(%lu..%lu):mapid1=%d,mapid2=%d,Xmap=Gmap[mapid2]=%p,Xmap->mapid=%d\n",
			     tid,refid,rmap->id,group,i,align_start,align_end-1,p->mapid1,p->mapid2,Xmap,Xmap->mapid);
		      fflush(stdout);
		      assert(Xmap->mapid == p->mapid2);
		    }
		  }
		  if(Xmap->origmap)
		    continue;/* skip map fragments : the best alignment of a map fragment should always be worse than that of the full molecules */
		  if(BestRef){
		    Cmap *origmap = Xmap;
		    while(origmap->origmap)
		      origmap = origmap->origmap;
		    if(origmap->align->mapid1 != p->mapid1 && BestRefExtCheck(p,origmap->align,p->mapid2,p->mapid1))
		      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
		  }
		  //		if(BestRef && Xmap->align->mapid1 != p->mapid1)
		  //		  continue;/* skip alignment unless it is with the reference with the best alignment score with this map Xmap */

		  if(CenterMapped > 0.0){/* skip alignment if it overlaps anywhere within CenterMapped kb of reference contig ends */
		    double scale = p->scaleID ? ScaleFactor[p->scaleID] : 1.0;	    
		    FLOAT *X = Xmap->site[0];
		    FLOAT *Y = rmap->site[0];
		    int M = Xmap->numsite[0];
		    int N = rmap->numsite[0];
		    int I = p->sites1[0];
		    int K = p->sitesK1[0];
		    int J = p->sites2[0];
		    int RI = p->sites1[p->numpairs-1];
		    int RK = p->sitesK1[p->numpairs-1];
		    int RJ = p->sites2[p->numpairs-1];
		    double leftend = (p->Lend > -2) ? Yc(Y,I,K) - scale*(p->orientation ? X[M+1]-X[M+1-J] : X[J]) : Yc(Y,I,K);
		    double rightend = (p->Rend > -2) ?  Yc(Y,RI,RK) + scale*(p->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]) : Yc(Y,RI,RK);
		    if((leftend < CenterMapped) || (rightend > Y[N+1] - CenterMapped))
		      continue;
		  }

		  if(DEBUG>=2) assert(Xmap->mapid == p->mapid2);
		  if(DEBUG>=2) assert(numgoodmaps < mapcnt);
		  goodmaps[numgoodmaps++] = Xmap;
	        }

		if((DEBUG && !(numgoodmaps <= mapcnt)) || VERB>=2){
		  printf("refid=%d:numgoodmaps=%d,mapcnt=%d,nummaps=%d,startmaps=%d,totalmaps=%d\n",refid,numgoodmaps,mapcnt,orignummaps,startmaps,totalmaps);
		  fflush(stdout);
		  assert(numgoodmaps <= mapcnt);
		}

		/* check for duplicate maps (requires read/write of shared bitmap MapSave[]) */
                #pragma omp critical(MapSavelock)
		{
   	          for(int i = 0; i < numgoodmaps; i++){
		    size_t /* WAS27 int */ Mindex = goodmaps[i]->mapid * (size_t) numLL + groupWord;
		    if(VERB>=2){
		      printf("refid=%d:group=%d,goodmaps[%d]:mapid=%d(%lld),Mindex=%lu,groupMask=%llu,MapSave[Mindex]=%llu\n",refid,group,i,goodmaps[i]->mapid,goodmaps[i]->id,Mindex,groupMask,MapSave[Mindex]);
		      fflush(stdout);
		    }
		    if(MapSave[Mindex] & groupMask){
		      if(VERB>=2){
			printf("refid=%d:deleted mapid=%d(%lld) from group=%d\n",refid,goodmaps[i]->mapid,goodmaps[i]->id,group);
			fflush(stdout);
		      }
		      goodmaps[i] = 0;
		    } else // NOTE : most of this loop could be run outside critical section, except for following update (would need to recheck MapSave[Mindex] & groupMask)
		      MapSave[Mindex] |= groupMask;
		  }
		}

		int j = 0;
		for(int i = 0; i < numgoodmaps; i++){
		  if(!goodmaps[i])
		    continue;
		  goodmaps[j++] = goodmaps[i];
		}
		if(j < numgoodmaps){
		  if(VERB>=2){
		    printf("refid=%d:numgoodmaps=%d->%d due to duplicate maps in same group (groupWord=%d,groupBit=%d,groupMask=%llu)\n",refid,numgoodmaps,j,groupWord,groupBit,groupMask);
		    fflush(stdout);
		  }
		  numgoodmaps = j;
		}

		if(VERB>=2){
		  #pragma omp critical
		  {
		    printf("tid=%d:Locking output_bnx:refid=%d,group=%d/%d,maps=%d,FP[group]=%p,buffer[group]=%p\n",
			   tid,refid,group,numgroups,numgoodmaps,groupFP[group],groupbuffer[group]);
		    fflush(stdout);
		  }
		}

		sprintf(MappedIdPrefix,"%s_group%d",MappedPrefix, group);

#ifdef _OPENMP
		omp_set_lock(&lock[group]);/* lock file */
#endif

		if(numgoodmaps > 0 || groupFP[group] == NULL){
		  if(VERB>=2){
		    #pragma omp critical
		    {
		      printf("tid=%d:Calling output_bnx(%s.bnx):refid=%d,group=%d/%d,maps=%d,FP[group]=%p,buffer[group]=%p\n",
			     tid,MappedIdPrefix,refid,group,numgroups,numgoodmaps,groupFP[group],groupbuffer[group]);
		      fflush(stdout);
		    }
		  }

		  if(maptype==0 || MapType >= 0 || CmapMergeBnx){
		    if(usecolor==2){
		      for(int i = 0; i < numgoodmaps; i++)
			goodmaps[i]->colorswap(usecolor);
		      char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
		    }

#if SPARSE_MAPWT == 1
		    output_bnx(MappedIdPrefix,goodmaps,0,numgoodmaps-1, 1, groupFP, groupbuffer, tid, group, lock, numgroups, refid, NULL, mapWT);
#else
		    output_bnx(MappedIdPrefix,goodmaps,0,numgoodmaps-1, 1, groupFP, groupbuffer, tid, group, lock, numgroups, refid, mapWT[group]);
#endif

		    if(usecolor==2){
		      for(int i = 0; i < numgoodmaps; i++)
			goodmaps[i]->colorswap(usecolor);
		      char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
		    }
		  } else {
		    printf("CMAP output of grouped _mapped files not implemented: Use -maptype or -bnx to output BNX file\n");
		    fflush(stdout);exit(1);
		    //	output_cmap(MappedIdPrefix,goodmaps,0,numgoodmaps-1, &groupFP[group]);
		  }
		}

#ifdef _OPENMP
		omp_unset_lock(&lock[group]);/* unlock file */
#endif

		if(VERB>=2){
		  #pragma omp critical
		  {
		    printf("tid=%d:Unlocked output_bnx:refid=%d,group=%d/%d,maps=%d,FP[group]=%p,buffer[group]=%p\n",
			   tid,refid,group,numgroups,numgoodmaps,groupFP[group],groupbuffer[group]);
		    fflush(stdout);
		  }
		}
	      }// refid = 0 .. numrefmaps-1

	      delete [] goodmaps;
	    } // parallel

	    if(usecolor)
	      colors = 1;

	    delete [] MapSave;
	    for(int i = 1; i <= numgroups; i++){
	      if(groupFP[i] && groupFP[i] != (FILE *)-1){
		if(VERB>=2){
		  printf("group=%d:calling FILEclose(FP[group]=%p) and deleting buffer[group]=%p\n",
			 i, groupFP[i], groupbuffer[i]);
		  fflush(stdout);
		}
		FILEclose(groupFP[i], 1);
	      }
	      if(groupbuffer[i]){
		if(VERB>=2){
		  printf("group=%d:freeing buffer[group]=%p\n",
			 i, groupbuffer[i]);
		  fflush(stdout);
		}
		free(groupbuffer[i]);
	      }
#ifdef _OPENMP
	      omp_destroy_lock(&lock[i]);
#endif
	    }
	    delete [] groupFP;
	    delete [] groupbuffer;
	    delete [] lock;

#if SPARSE_MAPWT == 0
	    if(BestRefWT)
	      delete [] mapWTmem;
#endif
	    delete [] mapWT;

	  } else {// No groupfile

	    int refmax = split_maps ? numrefmaps : 1;

	    if(VERB/* HERE >=2 */ && refmax > 1){
	      printf("Using %d threads to output to %d BNX files (numrefmaps=%d)\n", nthreads, refmax, numrefmaps);
	      fflush(stdout);
	    }

	    #pragma omp parallel num_threads(nthreads) if(nthreads > 1 && refmax > 1)
	    {
	      int tid = 0;
#ifdef _OPENMP
	      tid = omp_get_thread_num ();
#endif
	      /* assemble all good maps for one refid into array goodmaps[0..numgoodmaps-1] */
	      char MappedIdPrefix[PATH_MAX];
	      Cmap **goodmaps = new Cmap *[mapcnt];

	      float *mapWT = NULL;
	      if(BestRefWT && split_maps)
		mapWT = new float[nummaps];

#if !USE_MIC
              #pragma omp for schedule(dynamic,1)
#endif
	      for(int refid = 0; refid < refmax; refid++){
		if(USE_MIC && !((refid % nthreads) == tid)){// approximate #pragma omp for schedule(static,1)
		  continue;
		}

		size_t align_start = 0, align_end = numaligns;
		if(!split_maps)
		  for(int i = 0; i < nummaps; i++)
		    Gmap[i]->paired = 0;
		else if(AlignmentOrdered){
		  align_start = numalign_start[refid];
		  align_end = numalign_end[refid];
		}

		if(BestRefWT && split_maps){/* compute mapWT[mapid = 0 .. nummaps - 1] for the current refid */
		  memset(mapWT, 0, nummaps * sizeof(float));
		  for(size_t i = align_start; i < align_end; i++){
		    Calign *p = alignment[i];
		    if(!p || p->numpairs <= 0)
		      continue;
		    if(p->mapid1 != refid){
	              if(DEBUG>=2) assert(!AlignmentOrdered);
		      continue;
	            }
		    Cmap *rmap = refmap[refid];
		    if(!AlignedThreshold(p, rmap->site[0], ScoreThreshold, LogPvThreshold))
		      continue;
		    int mapid = p->mapid2;
		    if(DEBUG>=2) assert(Gmap[mapid]->mapid == mapid);
		    if(DEBUG>=2) assert(0 <= mapid && mapid < nummaps);
		    if(MultiMatches){/* iterate over all matchgroups */
		      for(int t = 0; t < p->multicnt; t++)
			mapWT[mapid] += p->Malign[t]->mapWT;
		    } else
		      mapWT[mapid] += p->mapWT;
		  }
		}

		int numgoodmaps = 0;

		for(size_t i = align_start; i < align_end; i++){
		  Calign *p = alignment[i];
		  if(!p || p->numpairs <= 0)
		    continue;
		  if(split_maps && p->mapid1 != refid){
		    if(DEBUG) assert(!AlignmentOrdered);
		    continue;
		  }
		  Cmap *rmap = refmap[p->mapid1];
		  if(!AlignedThreshold(p, rmap->site[0], ScoreThreshold, LogPvThreshold))
		    continue;
		  Cmap *Xmap = Gmap[p->mapid2];
		  if(Xmap->origmap)
		    continue;/* skip map fragments : the best alignment of a map fragment should always be worse than that of the full molecules */
		  if(BestRef){
		    Cmap *origmap = Xmap;
		    while(origmap->origmap)
		      origmap = origmap->origmap;
		    if(origmap->align->mapid1 != p->mapid1 && BestRefExtCheck(p,origmap->align,p->mapid2,p->mapid1))
		      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
		  }
		  //	      if(BestRef && Xmap->align->mapid1 != p->mapid1)
		  //		continue;/* skip alignment unless it is with the reference with the best alignment score with this map Xmap */

		  if(CenterMapped > 0.0){/* skip alignment if it does overlaps within CenterMapped kb of contig ends */
		    double scale = p->scaleID ? ScaleFactor[p->scaleID] : 1.0;	    
		    FLOAT *X = Xmap->site[0];
		    FLOAT *Y = rmap->site[0];
		    int M = Xmap->numsite[0];
		    int N = rmap->numsite[0];
		    int I = p->sites1[0];
		    int K = p->sitesK1[0];
		    int J = p->sites2[0];
		    int RI = p->sites1[p->numpairs-1];
		    int RK = p->sitesK1[p->numpairs-1];
		    int RJ = p->sites2[p->numpairs-1];
		    double leftend = (p->Lend > -2) ? Yc(Y,I,K) - scale*(p->orientation ? X[M+1]-X[M+1-J] : X[J]) : Yc(Y,I,K);
		    double rightend = (p->Rend > -2) ?  Yc(Y,RI,RK) + scale*(p->orientation ? X[M+1-RJ] : X[M+1] - X[RJ]) : Yc(Y,RI,RK);
		    if((leftend < CenterMapped) || (rightend > Y[N+1] - CenterMapped))
		      continue;
		  }

		  if(!split_maps){
		    if(DEBUG && BestRef) assert(!Xmap->paired);
		    if(Xmap->paired)
		      continue;
		    Xmap->paired = 1;
		  }
		  if(DEBUG>=2) assert(numgoodmaps <= mapcnt);
		  goodmaps[numgoodmaps++] = Xmap;
		}
		if(DEBUG && !(numgoodmaps <= mapcnt)){
		  printf("numgoodmaps=%d,mapcnt=%d,nummaps=%d\n",numgoodmaps,mapcnt,nummaps);
		  fflush(stdout);
		  assert(numgoodmaps <= mapcnt);
		}
		if(!split_maps)
		  strcpy(MappedIdPrefix,MappedPrefix);
		else
		  sprintf(MappedIdPrefix,"%s_contig%lld",MappedPrefix, refmap[refid]->id);

		int Mthreads = 1;

		if(usecolor){
		  colors = 2;

		  if(usecolor==2){
#ifdef _OPENMP
		    if(!(nthreads > 1 && refmax > 1)){
		      Mthreads = MaxThreads; // WAS omp_get_max_threads();
		      //		      Mthreads = min(Mthreads,MaxThreads);
		      if(Mthreads > numgoodmaps/1024)
			Mthreads = max(1,numgoodmaps/1024);
		    }
#endif

                    #pragma omp parallel for num_threads(Mthreads) schedule(static,1024) if(Mthreads > 1)
		    for(int i = 0; i < numgoodmaps; i++)
		      goodmaps[i]->colorswap(usecolor);

		    char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
		  }
		}
		if(maptype==0 || MapType >= 0 || CmapMergeBnx)
		  output_bnx(MappedIdPrefix,goodmaps,0,numgoodmaps-1, 1, NULL, NULL,-1, 0, NULL, 1, -1, mapWT);
		else
		  output_cmap(MappedIdPrefix,goodmaps,0,numgoodmaps-1);

		if(usecolor==2){
                  #pragma omp parallel for num_threads(Mthreads) schedule(static,1024) if(Mthreads > 1)
		  for(int i = 0; i < numgoodmaps; i++)
		    goodmaps[i]->colorswap(usecolor);

		  char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
		}

		if(usecolor)
		  colors = 1;
	      }// refid = 0 .. numrefmaps-1

	      delete [] goodmaps;
	      if(BestRefWT && split_maps)
		delete [] mapWT;
	    } // omp parallel
	  } // no groupfile

	  if(VERB){
	    printf("Finished output of mapped bnx files: CPU time=%0.6f, wall time=%0.6f\n", mtime(),wtime());
	    if(VERB/* HERE HERE >=2 */){
	      static long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
	      getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
	      printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb\n",  VmSize * 1e-9, VmRSS * 1e-9, VmHWM * 1e-9, VmSwap * 1e-9);
	    }
	    fflush(stdout);
	  }
	}

	if(DEBUG>=2) assert(colors==1);

	if(UnMappedPrefix){/* output maps that scored below threshold to <UnMappedPrefix>.cmap */
	  char UnMappedIdPrefix[PATH_MAX];

	  /* assemble all good maps into array badmaps[0..numbadmaps-1] */
	  Cmap **badmaps = new Cmap *[nummaps];
	  for(int i = 0; i < nummaps; i++)
	    Gmap[i]->paired = 0;

	  for(int refid = 0; refid < numrefmaps; refid++){
	    size_t align_start = 0, align_end = numaligns;
	    for(int i = 0; i < nummaps; i++)
	      Gmap[i]->paired = 0;
	    if(split_maps && AlignmentOrdered){
	      align_start = numalign_start[refid];
	      align_end = numalign_end[refid];
	    }

	    int numbadmaps = 0;

	    for(size_t i = align_start; i < align_end; i++){
	      Calign *p = alignment[i];
	      if(!p || p->numpairs <= 0)
		continue;
	      if(DEBUG && split_maps && p->mapid1 != refid){
		if(DEBUG) assert(!AlignmentOrdered);
		continue;
	      }
	      Cmap *rmap = refmap[p->mapid1];
	      if(!AlignedThreshold(p, rmap->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	      Cmap *Xmap = Gmap[p->mapid2];
	      if(Xmap->origmap)
		continue;/* skip map fragments : the best alignment of a map fragment should always be worse than that of the full molecules */
	      if(BestRef){
		Cmap *origmap = Xmap;
		while(origmap->origmap)
		  origmap = origmap->origmap;
		if(origmap->align->mapid1 != p->mapid1 && BestRefExtCheck(p,origmap->align,p->mapid2,p->mapid1))
		  continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	      }
	      //	    if(BestRef && Xmap->align->mapid1 != p->mapid1)
	      //	      continue;/* skip alignment unless it is with the reference with the best alignment score with this map Xmap */

	      if(!split_maps){
		if(DEBUG && BestRef) assert(!Xmap->paired);
		if(Xmap->paired)
		  continue;
	      }
	      Xmap->paired = 1;
	    }
	    for(int i = 0; i < nummaps; i++){
	      Cmap *pmap = Gmap[i];
	      if(!pmap->paired){
		if(DEBUG>=2) assert(numbadmaps <= nummaps);
		badmaps[numbadmaps++] = pmap;
	      }
	    }
	    if(DEBUG) assert(numbadmaps <= nummaps);
	    if(!split_maps)
	      strcpy(UnMappedIdPrefix,UnMappedPrefix);
	    else
	      sprintf(UnMappedIdPrefix,"%s_contig%lld",UnMappedPrefix, refmap[refid]->id);

	    if(usecolor)
	      colors = 2;
	    if(usecolor==2){
	      for(int i = 0; i < numbadmaps; i++)
		badmaps[i]->colorswap(usecolor);

	      char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
	    }

	    if(maptype==0 || MapType >= 0 || CmapMergeBnx)
	      output_bnx(UnMappedIdPrefix,badmaps,0,numbadmaps-1, 1, NULL, NULL,-1);
	    else
	      output_cmap(UnMappedIdPrefix,badmaps,0,numbadmaps-1);

	    if(usecolor==2){
	      for(int i = 0; i < numbadmaps; i++)
		badmaps[i]->colorswap(usecolor);

	      char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
	    }
	    if(usecolor)
	      colors = 1;
	    if(!split_maps)
	      break;
	  }
	  delete [] badmaps;
	}

	if(DEBUG>=2) assert(colors==1);

	if(PartMappedPrefix){/* output maps that scored above threshold but aligned only partly due to -endoutlier to <PartMappedPrefix>.cmap */
	  char PartMappedIdPrefix[PATH_MAX];

	  /* assemble all good maps with endoutliers into array partmaps[0..numpartmaps-1] */
	  Cmap **partmaps = new Cmap *[nummaps];
	  for(int refid = 0; refid < numrefmaps; refid++){
	    size_t align_start = 0, align_end = numaligns;
	    if(!split_maps)
	      for(int i = 0; i < nummaps; i++)
		Gmap[i]->paired = 0;
	    else if(AlignmentOrdered) {
	      align_start = numalign_start[refid];
	      align_end = numalign_end[refid];
	    }

	    if(0){ // sort alignments by logPV for debugging
	      extern int LogPVSiteInc(Calign **p1, Calign **p2);
	      qsort(&alignment[align_start],align_end - align_start,sizeof(Calign *), (intcmp*)LogPVSiteInc);
	    }

	    int numpartmaps = 0;

	    for(size_t i = align_start; i < align_end; i++){
	      Calign *p = alignment[i];
	      if(!p || p->numpairs <= 0)
		continue;
	      if(DEBUG && split_maps && p->mapid1 != refid){
		if(DEBUG) assert(!AlignmentOrdered);
		continue;
	      }
	      Cmap *rmap = refmap[p->mapid1];
	      if(!AlignedThreshold(p, rmap->site[0], ScoreThreshold, LogPvThreshold))
		continue;
	      if(p->Lend > -2 && p->Rend > -2)
		continue;
	    
	      Cmap *Xmap = Gmap[p->mapid2];
	      if(Xmap->origmap)
		continue;/* skip map fragments : the best alignment of a map fragment should always be worse than that of the full molecules */

	      if(BestRef){
		Cmap *origmap = Xmap;
		while(origmap->origmap)
		  origmap = origmap->origmap;
		if(origmap->align->mapid1 != p->mapid1 && BestRefExtCheck(p,origmap->align,p->mapid2,p->mapid1))
		  continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	      }
	      //	    if(BestRef && Xmap->align->mapid1 != p->mapid1)
	      //	      continue;/* skip alignment unless it is with the reference with the best alignment score with this map Xmap */

	      if(!split_maps){
		if(DEBUG && BestRef) assert(!Xmap->paired);
		if(Xmap->paired)
		  continue;
	      }
	      Xmap->paired = 1;
	      partmaps[numpartmaps++] = Xmap;
	    }
	    if(DEBUG) assert(numpartmaps <= nummaps);
	    if(!split_maps)
	      strcpy(PartMappedIdPrefix,PartMappedPrefix);
	    else
	      sprintf(PartMappedIdPrefix,"%s_contig%lld",PartMappedPrefix, refmap[refid]->id);

	    if(usecolor)
	      colors = 2;
	    if(usecolor==2){
	      for(int i = 0; i < numpartmaps; i++)
		partmaps[i]->colorswap(usecolor);
	      char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
	    }

	    if(maptype==0 || MapType >= 0 || CmapMergeBnx)
	      output_bnx(PartMappedIdPrefix,partmaps,0,numpartmaps-1, 1, NULL, NULL,-1);
	    else
	      output_cmap(PartMappedIdPrefix,partmaps,0,numpartmaps-1);

	    if(usecolor==2){
	      for(int i = 0; i < numpartmaps; i++)
		partmaps[i]->colorswap(usecolor);
	      char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
	    }
	    if(usecolor)
	      colors = 1;

	    if(!split_maps)
	      break;
	  }
	  delete [] partmaps;
	}

	nummaps = orignummaps;
      }// if(!pSNRtotLL)
    } // if(giter == RefRepeats-1)

    if(DEBUG>=2) assert(colors==1);

    if(DEBUG>=2) assert(0 <= giter && giter <= RefRepeats-1);

    if(NoStat){
      score_free(0,numrefmaps);
      if(VERB/* HERE HERE >=2 */){
	static long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
	getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
	printf("After score_free(): VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb\n",  VmSize * 1e-9, VmRSS * 1e-9, VmHWM * 1e-9, VmSwap * 1e-9);
	fflush(stdout);
      }
      continue;/* skip parameter display/estimation/output */
    }

    double startPixelLen = PixelLen;
    double FPorig = FP[0];
    double FNorig = FN[0];
    double SForig = SF[0];
    double SDorig = SD[0];
    double SRorig = SR[0];
    double SEorig = SE[0];

    int goodcnt = mapcnt - fraccnt - LDcnt;

    if(VERB){/* display statistics */
      printf("refmaps=%d,maps=%d(totlen= %0.3f kb),totalmaps=%d,%d:\n",
	     numrefmaps,nummaps,maplen,startmaps,totalmaps);
      if(biasWT==0.0)
	printf("  %llu alignments(%d failed -F %0.3f, %d failed -D %0.1f):score=%0.4f,LogPV=%0.4f,pairs=%0.2f,LogLR=%0.6f, avg len= %0.3f kb\n",
	       (unsigned long long)tcnt, fraccnt,AlignedFractionThreshold,LDcnt,AlignedLabelDensityThreshold, (tcnt <= 0) ? 0.0 : scoresum/tcnt, (tcnt <= 0) ? 0.0 : logPVsum/tcnt,
	       (tcnt <= 0) ? 0.0 : ((double)NumpairsSum)/tcnt, (tcnt <= 0) ? 0.0 : LRsum/tcnt, (tcnt <= 0) ? 0.0 : totlen/tcnt);
      else
 	printf("  %llu alignments(%d failed -F %0.3f, %d failed -D %0.1f):score=%0.6f,LogPV=%0.4f, avg len= %0.3f kb\n",
 	       (unsigned long long)tcnt, fraccnt, AlignedFractionThreshold,LDcnt,AlignedLabelDensityThreshold, (tcnt <= 0) ? 0.0 : scoresum/tcnt, (tcnt <= 0) ? 0.0 : logPVsum/tcnt,
	       (tcnt <= 0.0) ? 0.0 : totlen/tcnt);

      printf("  %d above all thresholds:score=%0.6f,LogPV=%0.4f,pairs=%0.2f,logLR=%0.6f(%0.6f/site), avg len= %0.3f kb\n",
	     goodcnt, (goodcnt <= 0) ? 0.0 : ATscoresum/goodcnt, (goodcnt <= 0) ? 0.0 : ATlogPVsum/goodcnt,
	     (goodcnt <= 0) ? 0.0 : ((double)ATNumpairsSum)/goodcnt, (goodcnt <= 0) ? 0.0 : ATlogLRsum/goodcnt,
	     (sitecnt-goodcnt <= 0) ? 0.0 : ATlogLRsum/((sitecnt-goodcnt)), ATtotlen/max(1,goodcnt));
      if(Poutlier>0.0){
	printf("  outliers=%d/%d(rate=%0.6f)(qry sites=%d, len=%0.3f kb, density=%0.2f/100kb), total aligned intervals= %d (non-outlier intervals=%d)\n",
	       outliercnt, outliertot, outliersum/outliertot, sitecntOutX, lenOut, sitecntOutX / max(0.001, lenOut*0.01), segcnt+outliercnt, segcnt);
	printf("  endoutliers=%d(aligned sites= %d, rate=%0.6f)(sites=%d, len=%0.3f kb, density=%0.2f/100kb), HD endoutliers= %d(sites=%d,len=%0.3f kb,density=%0.2f/100kb)\n",
	       outlierEndcnt, outliercnt+segcnt+2*goodcnt, outlierEndcnt/((double)(outliercnt+segcnt+2*goodcnt)), 
	       sitecntEnd, lenEnd, sitecntEnd / max(0.001, lenEnd*0.01),
	       HDoutliercnt,HDsites,HDlen*100.0,HDsites/max(0.001,HDlen));
      }
      if((Ch > 0.0 && ChFdr > 0.0) || (NEW && PoutlierEnd > 0.0))
	printf("  chimeric sites=%d/%d(%0.6f),chimeric frags=%d(FP=%d,close pairs=%d)):\n",
	       chimcnt,outliercnt+segcnt+2*goodcnt,((double)chimcnt)/((double)(outliercnt+segcnt+2*goodcnt)),chimconf,chimconfFP,chimpaircnt);
      if(STITCH && stitchcnt > 0){
	printf("  stitch intervals=%d(outliers=%d/%d,endoutliers=%d/%d):sitecnt=%d\n",stitchcnt+stitchEnd,stitchOut,stitchcnt, stitchEndOut, stitchEnd, sitecntS);
	printf("  (Regular intervals only: outliers=%d/%d)\n", outliercnt-stitchOut, outliertot-stitchcnt);
      }
      fflush(stdout);
    }

    if(minSNRestimate && pSNRtotLL){
      if(giter2==0 && BppSteps){
	double goodcntD = goodcnt;
	if(VERB>=2){
	  printf("goodcnt=%d, BppMincnt=%d, ATlogLRsum= %0.6f\n",goodcnt, BppMincnt, ATlogLRsum);
	  fflush(stdout);
	}

	if(goodcnt < BppMincnt)
	  *pSNRtotLL = goodcntD;
	else
	  *pSNRtotLL = max(ATlogLRsum, goodcntD);

	if(newPixelLen){
	  double scalesum = 0.0, scalewtsum = 0.0;
	  for(int i = 0; i < nummaps; i++){
	    double incscale = Gmap[i]->incscale;
	    double wt = Gmap[i]->incwt;
	    if(DEBUG>=2) assert(isfinite(wt) && wt >= 0.0);
	    if(DEBUG>=2) assert(isfinite(incscale));
	    scalesum += incscale * wt ;
	    scalewtsum += wt;
	    if(DEBUG>=2) assert(isfinite(scalewtsum));	    
	  }
	  if(scalewtsum > 0.0)
	    *newPixelLen = PixelLen * scalesum / scalewtsum;
	  else
	    *newPixelLen = PixelLen;
	}
      } else {
	if(VERB>=2){
	  printf("goodcnt=%d, BppMincnt=%d, ATlogLRsum= %0.6f\n",goodcnt, BppMincnt, ATlogLRsum);
	  fflush(stdout);
	}
	*pSNRtotLL = ATlogLRsum; // WAS ATlogLRsum / max(goodcnt,1);
      }
      goto Lreturn;
    }

    if(DEBUG>=2) assert(0 <= giter && giter <= RefRepeats-1);

    parameters[giter].mapcnt = tcnt;
    parameters[giter].logLR = (tcnt <= 0 ? 0.0 : LRsum/tcnt);
    parameters[giter].ATmapcnt = goodcnt;
    parameters[giter].ATlogLR = (goodcnt <= 0 ? 0.0 : ATlogLRsum/goodcnt);
    parameters[giter].sitecnt = sitecnt + sitecntOut;
    parameters[giter].sumX = len + lenOut;
    parameters[giter].totlen = maplen;
    parameters[giter].outlierRate = outliersum/max(1,outliertot);
    parameters[giter].EndoutlierRate = outlierEndcnt/((double)(outliercnt+segcnt+2*goodcnt));
    parameters[giter].LabelDensity[0] = (sitecnt+sitecntOut)*100.0/max(0.001, lenY);// NOTE lenY includes internal outlier regions, while len does NOT (unless -outlierType 1) */
    parameters[giter].LabelDensityX[0] = (sitecntX+sitecntOutX) * 100.0 / max(0.001,len + lenOut);
    for(int c = 1; c < (usecolor ? MAXCOLOR : colors); c++)
      parameters[giter].LabelDensity[c] = parameters[giter].LabelDensityX[c] = 0.0;

    if(REFDEBUG && logLRsum > LARGE_NEGATIVE && (!(ATlogLRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6) * goodcnt) || VERB)){
      if(SDDEBUG)
	printf("giter=%d:After alignment update:score=%0.6f -> %0.6f,goodcnt=%llu(logLRsd= %0.6f)\n",
	       giter,logLRsum/max(1,goodcnt),ATlogLRsum/max(1,goodcnt),(unsigned long long)goodcnt, logLRsdsum/max(1,goodcnt));
      else
	printf("giter=%d:After alignment update:score=%0.6f -> %0.6f,goodcnt=%llu\n",giter,logLRsum/max(1,goodcnt),ATlogLRsum/max(1,goodcnt),(unsigned long long)goodcnt);
      if(FPDEBUG && Xlen3cum > 0.0){
	printf("\t Xlen= %0.6f, FPcnt=%d : FPcnt*100/Xlen = %0.8f, LRsum=%0.8f, logLR1cum=%0.8f,logLR2cum=%0.8f,logLR3cum=%0.8f\n",Xlen3cum,FPcnt3, FPcnt3*100.0/Xlen3cum, ATlogLRsum, logLR1cum, logLR2cum, logLR3cum);
	fflush(stdout);
      }
      if(HashGen && !(ATlogLRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6) * goodcnt))
	printf("WARNING: Can happen with -hashgen\n");
      fflush(stdout);
      
      if(!HashGen) assert(ATlogLRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6) * goodcnt);
    }
    logLRsum = ATlogLRsum;
    if(DEBUG) assert(isfinite(logLRsum));

    if(0 && minSNRestimate && goodcnt > 0){
      
      //      int orignumthreads = numthreads;

      #ifdef _OPENMP
      numthreads = MaxThreads; // WAS omp_get_max_threads();
      //      numthreads = min(numthreads,MaxThreads);
      if(numthreads > goodcnt)
        numthreads = max(1,goodcnt);
      #endif

      double origSNR = minSNR[0];
      double origLL = SNRtotLL(origSNR,numthreads,numaligns,alignment,Narray, /* (fabs(origSNR - 4.8) < 0.01) ? 1 : 0 */ 0, maxmapid, Sarray);
      double bestLL = origLL;

      double phi = (1.0 + sqrt(5.0))*0.5;
      double resphi = 2.0 - phi;

      double Low = minSNR[0];
      double High = SNRmax;
      double MidL = minSNR[0];
      double MidH = minSNR[0];

      if(VERB/* HERE>=2 */){
        printf("minSNR= %0.3f(LL=%0.6f), Low= %0.3f, High= %0.3f\n",MidL,bestLL,Low,High);
	fflush(stdout);
      }

      if(1/* giter == 0 */){
	for(double Mid = Low + 0.01; Mid <= High; Mid += 0.01){
	  double LL = SNRtotLL(Mid,numthreads,numaligns,alignment,Narray, /* (fabs(Mid - 4.8) < 0.01) ? 1 : 0 */ 0, maxmapid, Sarray);
	  if(LL > bestLL - 1e-6){
	    if(LL > bestLL + 1e-6){
	      bestLL = LL;
	      MidL = MidH = Mid;
	    } else
	      MidH = Mid;
	  }
	  if(VERB/* HERE >=2 */){
	    printf("minSNR= %0.4f (LL=%0.6f): Low= %0.4f, Mid=%0.4f..%0.4f (LL=%0.6f), High= %0.4f\n", Mid, LL, Low, MidL, MidH, bestLL, High);
	    fflush(stdout);
	  }
	}
      }

      while(max(High - MidH, MidL - Low) > 0.001){
	double minSNR,LL;
	if(High - MidH > MidL - Low){
	  minSNR = MidH + resphi * (High - Low - (MidH-MidL));
	  LL = SNRtotLL(minSNR,numthreads,numaligns,alignment,Narray, 0, maxmapid, Sarray);
	  if(LL > bestLL + 1e-6){
	    bestLL = LL;
	    Low = MidH;
	    MidL = MidH = minSNR;
	  } else if(LL < bestLL - 1e-6)
	    High = minSNR;
	  else /* tied with previous best : extend peak range MidL..MidH */
	    MidH = minSNR;
	} else {
	  minSNR = MidL - resphi * (High - Low - (MidH-MidL));
	  LL = SNRtotLL(minSNR,numthreads,numaligns,alignment,Narray, 0, maxmapid, Sarray);
	  if(LL > bestLL + 1e-6){
	    bestLL = LL;
	    High = MidL;
	    MidL = MidH = minSNR;
	  } else if(LL < bestLL - 1e-6)
	    Low = minSNR;
	  else /* tried with previous best : extend peak range MidL .. MidH */
	    MidL = minSNR;
	}
	if(VERB/* HERE >=2 */){
	  printf("minSNR= %0.4f (LL=%0.6f): Low= %0.4f, Mid=%0.4f..%0.4f (LL=%0.6f), High= %0.4f\n", minSNR, LL, Low, MidL, MidH, bestLL, High);
	  fflush(stdout);
	}
      }
      double Mid = 0.5*(MidL + MidH);
      if(VERB){
	printf("  minSNR[0]= %0.4f -> %0.4f (%0.4f..%0.4f): LL=%0.6f -> %0.6f\n",origSNR,Mid,MidL,MidH,origLL,bestLL);
	printf("    Reverting to minSNR[0] = %0.4f\n",origSNR);
	fflush(stdout);
      }

      minSNR[0] = origSNR;
    }// debug code

    /* update estimates of PRbias */
    if(sitecnt-fn+fp > 0.0){
#if 0
      if(VERB){
	printf("  PrPen=%0.6f,Xsites=%0.1f: PRbias = %0.6f -> %0.6f\n",
	       PrPen, sitecnt-fn+fp, PRbias, PrPen/(sitecnt-fn+fp));
	fflush(stdout);
      }
#endif
      if(0)// to enable PRbias updates
	PRbias = PrPen/(sitecnt-fn+fp);
    }

    if(VERB>=3){
      printf("iter=%d:Before FP update: numaligns=%lu\n",giter,numaligns);
      size_t cnt = 0;
      for(size_t i = 0; i < numaligns; i++){
        Calign *align = alignment[i];
	if(!align || align->numpairs <= 1)
	  continue;
	if(MapRate > 0.0 && !(BestRefPV ? (align->logPV > LogPvThreshold) : (align->score > ScoreThreshold)))
	  continue;
	int mid = align->mapid2;
	if(BestRef){
	  Cmap *origmap = Gmap[mid];
	  while(origmap->origmap)
	    origmap = origmap->origmap;
	  if(origmap->align->mapid1 != align->mapid1)// NOTE : BestRefExtCheck() not used for parameter estimation
	    continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	}
	printf("cnt=%lu,i=%lu:mid=%d(id=%lld),rid=%d(id=%lld)\n", cnt,i,mid,Gmap[mid]->id,align->mapid1,refmap[align->mapid1]->id);
	cnt++;
      }
      printf("\n");
      fflush(stdout);
    }

    /* update estimates of FP[] */
    if(AUTONOISE_FP && len*FP[0] > 0.0){
      if(VERB){
	if(sitecnt<=0)
	  printf("  sumX=%0.3f(outlier=%0.3f,ends=%0.3f,tot=%0.3f),sumY=%0.3f w/outliers,FPcnt=%d(isolated=%d) : FP = %0.8f -> %0.8f(unbiased=%0.6f) (per 100kb), FPrate=%0.8f\n",
		 len,lenOut,lenEnd,ATtotlen,lenY,fp,fpI, FP[0], fp*100.0/len, fp*100.0/lenB, 0.0);
	else
	  printf("  sumX=%0.3f(outlier=%0.3f,ends=%0.3f,tot=%0.3f),sumY=%0.3f w/outliers,FPcnt=%d(isolated=%d) : FP = %0.8f -> %0.8f(unbiased=%0.6f) (per 100kb), FPrate=%0.8f\n",
		 len,lenOut,lenEnd,ATtotlen,lenY,fp,fpI, FP[0], fp*100.0/len, fp*100.0/lenB, ((double)fp)/sitecnt);
	if(STITCH && lenS > 0.0)
	  printf("  Stitched Intervals:%s=%0.3f,FPcnt=%d: FP -> %0.6f (per 100kb)\n", REFSCORE?"sumX":"sumY",lenS,fpS,fpS*100.0/lenS);
	fflush(stdout);
      }
      FP[0] = fp*100.0/len;

      if(FP[0] < MINFP)
	FP[0] = MINFP;
      else if(FP[0] > MAXFP)
	FP[0] = MAXFP;
    }

    parameters[giter+1].FPfrac[0] = 0.0;
    if(sitecnt > 0)
      parameters[giter+1].FPfrac[0] = ((double)fp)/sitecnt;

    if(VERB>=2){
      printf("giter=%d:REFDEBUG=%d,numrefmaps=%d,BestRef=%d,BestRefPV=%d\n",giter, REFDEBUG,numrefmaps,BestRef,BestRefPV);
      fflush(stdout);
    }

    size_t lcnt = goodcnt;

    if(VERB>=2 && WITH_RESBIAS && giter== 9)/* sort alignments in ascending order of mapid2 */
      qsort(alignment, numaligns, sizeof(Calign*), (intcmp*)CalignMapidInc);

    if(VERB>=2 && ((!WITH_RESBIAS && giter== -1) || (WITH_RESBIAS && giter== 9))){/* sort errors[] in order of mapid,L */
      //      numthreads = 1;
      qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorIdInc);
    }

    if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
      if(DEBUG) assert(logLRarray);
      (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
      double LRsum = 0.0;
      double LRsdsum = 0.0;
      double *origLRarray = new double[nummaps];
      double *origSDarray = new double[nummaps];
      lcnt = 0;
      for(int mid = 0; mid < nummaps; mid++){
        origLRarray[mid] = logLRarray[mid];
	origSDarray[mid] = logSDarray[mid];
      }

      if(FPDEBUG){
	FPcnt3 = 0;
	Xlen3cum = 0.0;
	logLR3cum = logLR2cum = logLR1cum = 0.0;
	noFP3cum = 0.0;
      }

      for(size_t i = 0; i < numaligns; i++){
	Calign *align = alignment[i];
	if(!align || align->numpairs <= 1)
	  continue;
	int mid = align->mapid2;
	if(DEBUG) assert(!Gmap[mid]->origmap);
	if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	  if(DEBUG) assert(BestRefExt == 0.0);
	  if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	  continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	}
	int rid = align->mapid1;
	if(DEBUG>=2){
	  int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	  assert(origgoodalign);
	  int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	  assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	}
	FLOAT *X = Gmap[mid]->site[0];
	int M = Gmap[mid]->numsite[0];
	FLOAT *Y = refmap[rid]->site[0];
	int N = refmap[rid]->numsite[0];

	double origXlen3cum;
	int origFPcnt3;
	if(FPDEBUG){
	  origXlen3cum = Xlen3cum;
	  origFPcnt3 = FPcnt3;
	}

	double LRsd = 0.0;
	double LR = logLR(mid,align->mapid1,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
			  /*(giter==9 && !(MapRate > 0.0 && !(align->score > ScoreThreshold))) ? 1 : 0 */ 0,SDDEBUG ? &LRsd : 0,0);
	logLRarray[mid] = LR;
	logSDarray[mid] = LRsd;
	if(MapRate > 0.0 && !(align->score > ScoreThreshold)){
	  if(FPDEBUG){
	    Xlen3cum = origXlen3cum;
	    FPcnt3 = origFPcnt3;
	  }
	  continue;
	}
	LRsum += LR;
	lcnt++;
	if(SDDEBUG)
	  LRsdsum += LRsd;
	if(VERB>=2)
	  printf("i=%llu/%llu:refid=%d,mapid=%d,pairs=%d,logLR=%0.6f(delta=%0.6f),lcnt=%llu\n",(unsigned long long)i,(unsigned long long)numaligns,rid,mid,align->numpairs,LRsum,LR,(unsigned long long)lcnt);
      }
      if(SDDEBUG)
	printf("After FP update:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd=%0.6f -> %0.6f)\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt,logLRsdsum/lcnt,LRsdsum/lcnt);
      else
	printf("After FP update:lcnt=%llu:score=%0.6f -> %0.6f\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
      if(FPDEBUG && Xlen3cum > 0.0)
	printf("\t Xlen= %0.6f, FPcnt=%d : FPcnt*100/Xlen = %0.8f, LRsum=%0.8f, logLR1cum=%0.8f, logLR2cum=%0.8f, logLR3cum=%0.8f\n",Xlen3cum,FPcnt3, FPcnt3*100.0/Xlen3cum, LRsum, logLR1cum, logLR2cum, logLR3cum);
      fflush(stdout);

      if(DEBUG && !(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt)){
	if(VERB){
	  double sum1 = 0.0,sum2 = 0.0, sum3 = 0.0, sum4 = 0.0;
	  for(size_t i = 0; i < numaligns; i++){
	    Calign *align = alignment[i];
	    if(!align || align->numpairs <= 1)
	      continue;
	    int mid = align->mapid2;
	    if(DEBUG>=2) assert(!Gmap[mid]->origmap);
	    if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	      if(DEBUG) assert(BestRefExt == 0.0);
	      continue;
	    }
	    if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	      continue;
	    sum1 += origLRarray[mid];
	    sum2 += logLRarray[mid];
	    sum3 += origSDarray[mid];
	    sum4 += logSDarray[mid];
	    printf("i=%lu/%lu:mid=%d,id=%lld:logLRarray[mid]=%0.8f -> %0.8f (delta=%0.8f,cum=%0.8f -> %0.8f), LLsd=%0.8f -> %0.8f(delta=%0.8f,cum=%0.8f -> %0.8f)\n",
		i,numaligns,mid,Gmap[mid]->id,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid],sum1, sum2,
		origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4);
	  }
	  fflush(stdout);
        }
	      
	assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
      }

      if(DEBUG && MapRate <= 0.0 &&  !(lcnt==tcnt)){
	printf("lcnt=%llu,tcnt=%llu\n",(unsigned long long)lcnt,(unsigned long long)tcnt);
	fflush(stdout);
	assert(lcnt == tcnt);
      }
      logLRsum = LRsum;
      if(SDDEBUG)
	logLRsdsum = LRsum;
      score_free(0,numrefmaps);
      
      delete [] origLRarray;
      delete [] origSDarray;
    }

    if(VERB>=3){
      printf("iter=%d:Before FN update: numaligns=%lu\n",giter,numaligns);
      size_t cnt = 0;
      for(size_t i = 0; i < numaligns; i++){
        Calign *align = alignment[i];
	if(!align || align->numpairs <= 1)
	  continue;
	if(MapRate > 0.0 && !(BestRefPV ? (align->logPV > LogPvThreshold) : (align->score > ScoreThreshold)))
	  continue;
	int mid = align->mapid2;
	if(BestRef){
	  Cmap *origmap = Gmap[mid];
	  while(origmap->origmap)
	    origmap = origmap->origmap;
	  if(origmap->align->mapid1 != align->mapid1)// NOTE : BestRefExtCheck() not used for parameter estimation
	    continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	}
	printf("cnt=%lu,i=%lu:mid=%d(id=%lld),rid=%d(id=%lld)\n", cnt,i,mid,Gmap[mid]->id,align->mapid1,refmap[align->mapid1]->id);
	cnt++;
      }
      printf("\n");
      fflush(stdout);
    }

    /* update estimates of FN[] */
    if(sitecnt*FN[0] > 0.0){
      double origFN = FN[0];
      FN[0] = ((double)fn)/((double)sitecnt);
      if(VERB){
        printf("  sitecnt=%d(sitecntY=%d,sitecntX=%d,segcnt=%d),FNcnt=%d(isolated=%d) : FN= %0.6f -> %0.6f\n",sitecnt,sitecntY,sitecntX,segcnt,(int)floor(fn+0.5),fnI, origFN, FN[0]);
	if(STITCH && sitecntS > 0)
	  printf("  Stitched Intervals:sitecnt=%d,FNcnt=%d : FN -> %0.6f\n", sitecntS, (int) floor(fnS+0.5), ((double)fnS)/((double)sitecntS));
	fflush(stdout);
      }

      FN[0] = min(FN[0],MAXFN);
      FN[0] = max(FN[0],MINFN);

      /* if SCORE_APPROX <= 1 && MIS_VITERBI==0 this simple estimate of FN may underestimate : use Golden Mean search and calls to logLR() to correct it */
      if(FN_GM){/* use goldenmean search and calls to totLL() to estimate FN */
	origFN = FN[0];

	#ifdef _OPENMP
	numthreads = MaxThreads; // WAS omp_get_max_threads();
	//	numthreads = min(numthreads,MaxThreads);
	if(numthreads > goodcnt)
	  numthreads = max(1,goodcnt);
	#endif

	double bestLL = FNtotLL(FN[0], numthreads, numaligns, alignment, Narray);
	double origLL = bestLL;

	double phi = (1.0 + sqrt(5.0))*0.5;
	double resphi = 2.0 - phi;
	
	double Low = MINFN;
	double High = MAXFN;
	double Mid = FN[0];
	if(VERB>=2){
	  printf("FN=%0.6f:LL=%0.6f, Low=%0.6f,High=%0.6f\n", FN[0], bestLL, Low, High);
	  fflush(stdout);
	}

	while(max(High - Mid, Mid - Low) > 0.000001){
	  double Lsum;
	  if(High - Mid > Mid - Low){
	    FN[0] = Mid + resphi * (High - Mid /* WAS6 Low */);
	    Lsum = FNtotLL(FN[0],numthreads,numaligns,alignment,Narray);

	    if(Lsum > bestLL){
	      bestLL = Lsum;
	      Low = Mid;
	      Mid = FN[0];
	    } else
	      High = FN[0];
	  } else {
	    FN[0] = Mid - resphi * (Mid /* WAS6 High */ - Low);
	    Lsum = FNtotLL(FN[0],numthreads,numaligns,alignment,Narray);

	    if(Lsum > bestLL){
	      bestLL = Lsum;
	      High = Mid;
	      Mid = FN[0];
	    } else 
	      Low = FN[0];
	  }
	  if(VERB>=2){
	    printf("FN=%0.6f:LL=%0.6f (best:FN=%0.6f,LL=%0.6f), Low=%0.6f,High=%0.6f\n",FN[0],Lsum, Mid, bestLL, Low, High);
	    fflush(stdout);
	  }
	}
	FN[0] = Mid;
	score_update();  /* update score_init() terms that depend on FN (or FP) */
	//  FNtotLL(FN[0],numthreads,numaligns,alignment,Narray,1/* verb */);

	if(VERB){
	  printf("\tGolden Mean Search: FN= %0.6f -> %0.6f (score= %0.6f -> %0.6f,lcnt=%lu)\n", origFN, FN[0], origLL/max((size_t)1,lcnt), bestLL/max((size_t)1,lcnt), lcnt );
	  fflush(stdout);
	}
      }
    }
    if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
      if(DEBUG) assert(logLRarray);
      (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
      double LRsum = 0.0;
      double LRsdsum = 0.0;
      lcnt= 0;
      for(size_t i = 0; i < numaligns; i++){
	Calign *align = alignment[i];
	if(!align || align->numpairs <= 1)
	  continue;
	int mid = align->mapid2;
	if(DEBUG) assert(!Gmap[mid]->origmap);
	if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	  if(DEBUG) assert(BestRefExt==0.0);
	  if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	  continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	}
	int rid = align->mapid1;
	if(DEBUG>=2){
	  int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	  assert(origgoodalign);
	  int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	  assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	}
	FLOAT *X = Gmap[mid]->site[0];
	int M = Gmap[mid]->numsite[0];
	FLOAT *Y = refmap[rid]->site[0];
	int N = refmap[rid]->numsite[0];
	double LRsd = 0.0;
	double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
			  /* (WITH_RESBIAS && giter== 0 && mid== 77) ? 1 : */ 0, SDDEBUG ? &LRsd : 0,0);
	logLRarray[mid] = LR;
	logSDarray[mid] = LRsd;
	if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	  continue;
	LRsum += LR;
	lcnt++;
	if(SDDEBUG)
	  LRsdsum += LRsd;
      }
      if(SDDEBUG)
	printf("After FN update:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd= %0.6f -> %0.6f)\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt,logLRsdsum/lcnt,LRsdsum/lcnt);
      else
	printf("After FN update:lcnt=%llu:score=%0.6f -> %0.6f\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
      fflush(stdout);
      if(DEBUG) assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
      if(DEBUG && MapRate <= 0.0 && !(lcnt==tcnt)){
	printf("tcnt=%lu,lcnt=%lu\n",tcnt,lcnt);
	fflush(stdout);
	assert(lcnt == tcnt);
      }
      logLRsum = LRsum;
      if(SDDEBUG)
	logLRsdsum = LRsdsum;
      score_free(0,numrefmaps);
    }

    if(numerrors > 0){

      double A = SF[0]*SF[0];
      double B = fabs(SD[0])*SD[0];
      double R = SR[0]*SR[0];
      double E = SE[0]*SE[0];

      double Amin = MINSF*MINSF, Amax = MAXSF*MAXSF;
      double Bmin = fabs(MINSD)*MINSD, Bmax = MAXSD*MAXSD;
      double Rmin = MINSR*MINSR, Rmax = MAXSR*MAXSR;
      double Emin = MINSE*MINSE, Emax = MAXSE*MAXSE;

      double As = A, Bs = B, Rs = R, Es = E;/* parameter estimates for stitched intervals */
      double Ms = 0.0;/* for stitched intervals x = y + G(Ms,As+Bs*y), where G(mean,var) is the gaussian distribution */

      if(REFDEBUG_STRICT < 2 && maxresbias > mres * 0.5 /* HERE HERE && giter2 >= RefRepeats2 - 2 */){

	if(VERB/* HERE >=2 */){
	  printf("Estimating -resbias parameters:numerrors=%d:wall time=%0.6f\n",numerrors,wtime());
	  fflush(stdout);
	}

	Imaxresbias = (int)floor(maxresbias*1000.0+0.5);

	/* save original bias values, incase we need to backtrack */
	double startresbiasX[RESBINS+1],startresbias[RESBINS+1];
	int startResBins = ResBins[0];
	for(int Bin = 0; Bin <= ResBins[0]; Bin++){
	  startresbiasX[Bin] = resbiasX[0][Bin];
	  startresbias[Bin] = resbias[0][Bin];
	}
	if(VERB>=2){
	  printf("maxresbias=%0.6f,ResBins[0]=%d,resbiasX[0][ResBins[0]]= %0.6f\n",maxresbias,ResBins[0],resbiasX[0][ResBins[0]]);
	  fflush(stdout);
	}

	SizeToBin[0] = new int[Imaxresbias + 1];

	if(DEBUG) assert(!NoStat);

	if(rawsitemaps < totalmaps){/* in case maps were split */
	  rawsitealloc(Gmap,rawsitemaps,totalmaps);
	  rawsitemaps = totalmaps;
	}

	if(VERB>=2 && nummaps > 0){
	  printf("giter=%d:Before estimating bias parameters:Gmap[0]->numsite[0]=M=%d,Gmap[0]->site[0][M]=%0.3f,Gmap[0]->rawsite[0][1]=%0.3f,Gmap[0]->rawsite[0][M]=%0.3f\n",
		 giter,Gmap[0]->numsite[0],Gmap[0]->site[0][Gmap[0]->numsite[0]],Gmap[0]->rawsite[0][1],Gmap[0]->rawsite[0][Gmap[0]->numsite[0]]);
	  fflush(stdout);
	}

#ifdef _OPENMP
	numthreads = MaxThreads; // WAS omp_get_max_threads();
	//	numthreads = min(numthreads,MaxThreads);
	if(numthreads > numerrors/64)
	  numthreads = max(1,numerrors/64);
#endif

	/* precompute rawx */
	int OrigX = (ResBins[0] == 1 && resbias[0][0] == 0.0) ? 1 : 0;

	#pragma omp parallel for num_threads(numthreads) schedule(static,64)
	for(int i = 0; i < numerrors; i++){
	  Cinterval *perr = &errors[i];
	  if(ENDFIX>=2 && perr->end){/* ends will not be used for resbias estimation */
 	    perr->rawx = maxresbias + 10.0;
	    continue;
          }
	  double *rawsite = Gmap[perr->mapid]->rawsite[0];
	  if(DEBUG>=2 && !rawsite){
	    #pragma omp critical
	    {
	      printf("errors[%d]:mapid=%d,Gmap[mapid]->rawsite=%p\n",i,perr->mapid,rawsite);
	      fflush(stdout);
	      assert(rawsite != 0);
	    }
	  }
 	  perr->rawx = rawsite[perr->R] - rawsite[perr->L];
	  if(DEBUG>=2 && !(OrigX ? fabs(perr->rawx - perr->x) <= 1e-6 : perr->rawx > 0.0)){
	    #pragma omp critical
	    {
	      printf("perror[%d]:mapid=%d(id=%lld,M=%d),L=%d,R=%d:rawsite=%p,rawsite[L]=%0.4f,rawsite[R]=%0.4f,rawx=%0.4f\n",
		     i,perr->mapid,Gmap[perr->mapid]->id,Gmap[perr->mapid]->numsite[0],perr->L,perr->R,rawsite,rawsite[perr->L],rawsite[perr->R],perr->rawx);
	      fflush(stdout);
	      assert(OrigX ? fabs(perr->rawx - perr->x) <= 1e-6 : perr->rawx > 0.0);
	    }
	  }
        } // parallel for

	/* estimate bias parameters */
	
	/* first sort aligned intervals in ascending order of rawx */
	qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorRawxInc);

	/* locate largest size <= maxresbias */
	int maxindex = 0;
	for(; maxindex < numerrors; maxindex++)
	  if(errors[maxindex].rawx > maxresbias)
	    break;
	maxindex--;
	if(DEBUG) assert(maxindex < numerrors);
	
	int Start[RESBINS], End[RESBINS];
	double meanbias[RESBINS+1];
	double meanbias2[RESBINS+1];

	if(maxindex < 0){
	  printf("WARNING: No misresolved intervals below %0.4f in aligned maps : skipping -resbias\n",maxresbias);
	  fflush(stdout);
        } 
	if(maxindex >= 0){

	if(VERB>=2){
          printf("Previously : ResBins[0]= %d, resbiasX[0][0,1]= %0.4f, %0.4f, resbias[0][0]= %0.4f, origResBins[0]=%d\n",ResBins[0],resbiasX[0][0],resbiasX[0][1],resbias[0][0], origResBins[0]);
	  fflush(stdout);
        }

	if(RESBIAS_FIXBINS && !(ResBins[0] == 1 && resbiasX[0][1] == maxresbias && resbias[0][0] == 0.0)){/* resbiasX[0][] is already initialized and will be left unchanged */
  	  /* just compute Start[0..ResBins[0]-1] */
	  Start[0] = 0;
	  for(int Bin = 1; Bin < ResBins[0]; Bin++){
	    double LB = resbiasX[0][Bin];
	    int BinStart = Start[Bin-1];
	    for(;BinStart <= maxindex; BinStart++)
	      if(errors[BinStart].rawx >= LB)
		break;
	    Start[Bin] = BinStart;
          }
        } else {	/* initialize ResBins[0], resbiasX[0][0..ResBins[0]]  && Start[0..ResBins[0]-1] : assume equal interval size per Bin */

          ResBins[0] = origResBins[0];/* in case last iteration reduced ResBins */

	  if(maxindex < ResBins[0] * RESBIAS_MINSAMPLE){
	    if(VERB){
	      printf("Reduced ResBins from %d to %d due to limited total number of samples = %d\n",
		     ResBins[0], max(1,maxindex/RESBIAS_MINSAMPLE),maxindex);
	      fflush(stdout);
	    }
	    ResBins[0] = max(1,maxindex/RESBIAS_MINSAMPLE);
	  }

	  resbiasX[0][ResBins[0]] = maxresbias;
	  resbiasX[0][0] = min(mres * 0.5, errors[0].rawx);
	  Start[0] = 0;
	  double BinWidth = (resbiasX[0][ResBins[0]]-resbiasX[0][0])/((double)ResBins[0]);
	  if(VERB/* HERE >=2 */){
	    printf("maxresbias=%0.4f,ResBins=%d,errors[0].rawx=%0.4f(mapid=%d,id=%lld,x=%0.4f,L=%d,R=%d,M=%d),numerrors=%d,maxindex=%d\n",
		   maxresbias,ResBins[0],errors[0].rawx,errors[0].mapid,Gmap[errors[0].mapid]->id,errors[0].x,errors[0].L,errors[0].R,Gmap[errors[0].mapid]->numsite[0],numerrors,maxindex);
	    printf("BinWidth = %0.4f, numerrors=%d, resbiasX[0][0]= %0.4f\n", BinWidth, numerrors, resbiasX[0][0]);
	    fflush(stdout);
	  }
	  if(DEBUG && numerrors > 0) assert(errors[0].rawx > 0.0);
	  if(DEBUG && numerrors > 0) assert(resbiasX[0][0] > 0.0);
	  if(DEBUG) assert(BinWidth > 0.0);
	  for(int Bin = 1; Bin < ResBins[0]; Bin++){
	    double LB = resbiasX[0][Bin] = min(maxresbias,resbiasX[0][Bin-1] + BinWidth);
	    if(DEBUG>=2) assert(resbiasX[0][Bin] <= maxresbias);

	    /* locate the start of this Bin */
	    int BinStart = Start[Bin-1];
	    for(;BinStart <= maxindex; BinStart++)
	      if(errors[BinStart].rawx >= LB)
		break;
	    if(BinStart < Start[Bin-1] + RESBIAS_MINSAMPLE)/* make sure each bin has at least RESBIAS_MINSAMPLE data points */
	      BinStart = Start[Bin-1] + RESBIAS_MINSAMPLE;

	    //	    int origBinStart = BinStart;

	    /* avoid placing boundary point between two almost identical sample values */
	    if(BinStart > 0)
	      for(;BinStart < maxindex; BinStart++)
		if(errors[BinStart-1].rawx + 1e-8 < errors[BinStart].rawx)
		  break;
	    if(BinStart >= maxindex+1 || (errors[BinStart].rawx >= maxresbias)){
	      if(VERB){
		printf("Reduced ResBins from %d to %d due to reaching maxresbias=%0.4f in Bin %d(possibly limited number of quantized values)\n",
		       ResBins[0], Bin-1, maxresbias, Bin-1);
		if(VERB>=2)
		  printf("Bin=%d,Start[Bin-1]=%d,LB=%0.4f,BinStart=%d,errors[BinStart].rawx=%0.4f,maxresbias=%0.4f,maxindex=%d\n",
			 Bin,Start[Bin-1],LB,BinStart,errors[BinStart].rawx,maxresbias,maxindex);
		fflush(stdout);
	      }
	      resbiasX[0][Bin-1] = resbiasX[0][ResBins[0]];
	      ResBins[0] = Bin-1;
	    } else {
	      if(DEBUG) assert(errors[BinStart].rawx >= resbiasX[0][Bin]);
	      resbiasX[0][Bin] = min(maxresbias,0.5*(errors[BinStart-1].rawx + errors[BinStart].rawx));/* avoid placing Bin boundary close to actual sample value */
	      if(VERB>=2 || (DEBUG && !(resbiasX[0][Bin] > resbiasX[0][Bin-1]))){
		printf("resbiasX[%d]=%0.8f : BinStart=%d, errors[BinStart-1].rawx=%0.8f, errors[BinStart].rawx=%0.8f\n",Bin,resbiasX[0][Bin],BinStart,errors[BinStart-1].rawx,errors[BinStart].rawx);
		fflush(stdout);
		if(DEBUG) assert(resbiasX[0][Bin] > resbiasX[0][Bin-1]);
	      }
	      Start[Bin] = BinStart;
	      if(DEBUG) assert(BinStart < maxindex+1);
	    }
	    if(VERB>=2){
	      printf("Bin=%d:resBiasX[Bin]= %0.4f,Start[Bin]= %d (maxresbias=%0.4f,maxindex=%d,ResBins=%d)\n",
		     Bin, resbiasX[0][Bin], Start[Bin],maxresbias,maxindex,ResBins[0]);
	      fflush(stdout);
	    }
	    if(DEBUG && Bin < ResBins[0]) assert(resbiasX[0][Bin] > resbiasX[0][Bin-1]);
	  }
	  
	  if(RESBIAS_FIXBINS){/* update startbias[] so resbiasX[0] matches current values but leave resbias[0][] at 0.0 */
	    if(DEBUG) assert(startResBins == 1 && startresbiasX[1] == maxresbias && startresbias[0] == 0.0);

	    startResBins = ResBins[0];
	    for(int Bin = 0; Bin <= ResBins[0]; Bin++){
	      startresbiasX[Bin] = resbiasX[0][Bin];
	      startresbias[Bin] = 0.0;
	    }
          }
	} /* normal case : computed both resbiasX[0][] and Start[] */

	/* compute End[0..ResBins[0]-1] */
	End[ResBins[0]-1] = maxindex+1;
	for(int Bin= ResBins[0]-1; --Bin >= 0;)
	  End[Bin] = Start[Bin+1];

	if(VERB>=2){
	  printf("maxresbias=%0.6f,ResBins[0]=%d,resbiasX[0][ResBins[0]]= %0.6f\n",maxresbias,ResBins[0],resbiasX[0][ResBins[0]]);
	  if(ResBins[0] > 2){
	    for(int Bin = 0; Bin <= 1; Bin++){
	      int BinStart = Start[Bin];
	      int BinEnd = End[Bin];
	      printf("Bin=%d: Start=%d, End=%d : resbiasX[0][Bin,Bin+1]= %0.6f, %0.6f :\n",Bin,BinStart,BinEnd,resbiasX[0][Bin],resbiasX[0][Bin+1]);
	      double errsum = 0.0;
	      double errcnt = 0.0;
	      for(int t = BinStart; t < BinEnd; t++){
		Cinterval *perr = &errors[t];
		double y = perr->y;
		double x = perr->rawx;
		if(DEBUG>=2) assert(!perr->end);
		double var = A + B * y;
		if(QUADRATIC_VARIANCE)
		  var += R*y*y;
		if(RES_VARIANCE)
		  var += E * perr->resvar;
		if(!(ENDFIX>=3 && perr->end && y >= perr->x)){
		  double Ivar = 1.0/var;
		  errsum += (x - y) * Ivar;
		  errcnt += Ivar;
		}
		printf("\t errors[%d]: mapid=%d (id=%lld), L=%d,R=%d, end=%d: rawx= %0.8f, y= %0.8f (err= %0.8f, var= %0.6e): cum av err= %0.8f\n",
		       t,perr->mapid,Gmap[perr->mapid]->id,perr->L,perr->R,perr->end,x,y,x-y, var, errsum/errcnt);
              }
	      fflush(stdout);
	    }
	  }

	  fflush(stdout);
	}
	if(VERB>=2 && nummaps > 0){
	  printf("giter=%d:While estimating bias parameters(2):Gmap[0]->numsite[0]=M=%d,Gmap[0]->site[0][M]=%0.3f,Gmap[0]->rawsite[0][1]=%0.3f,Gmap[0]->rawsite[0][M]=%0.3f\n",
		 giter,Gmap[0]->numsite[0],Gmap[0]->site[0][Gmap[0]->numsite[0]],Gmap[0]->rawsite[0][1],Gmap[0]->rawsite[0][Gmap[0]->numsite[0]]);
	  printf("resbiasX[ResBins=%d]=%0.4f,maxresbias=%0.4f\n",ResBins[0],resbiasX[0][ResBins[0]],maxresbias);
	  fflush(stdout);
	}
	if(DEBUG>=2) assert(resbiasX[0][ResBins[0]] <= maxresbias);

#if SIMPLE_BIAS==2 // weighted piecewise linear fit 
	// NOTE : cases with end==1 have already been removed (by setting rawx > maxresbias) and are not included in the below summation
	/* For k = 0..ResBins[0], compute tri-diagonal matrix coeficients:
	   AA[k] = Sum(i=Start[k-1]..End[k-1]-1) (1-T(i,k))*T(i,k)/var(i) (With AA[0] = 0)
	   BB[k] = Sum(i=Start[k-1]..End[k-1]-1) T(i,k)^2/var(i)   +   Sum(i=Start[k]..End[k]-1) U(i,k)^2/var(i)
	   CC[k] = Sum(i=Start[k]..End[k]-1) (1-U(i,k))*U(i,k)/var(i)     (With C[ResBins[0]] = 0)
	   DD[k] = Sum(i=Start[k-1]..End[k-1]-1) (x(i)-y(i))*T(i,k)/var(i)   +   Sum(i=Start[k]..End[k]-1) (x(i)-y(i))U(i,k)/var(i)

	   Where:
	   T(i,k) = (x(i) - resbiasX[0][k-1])/(resbiasX[0][k] - resbiasX[0][k-1]), for k = 1..ResBins[0] (T(i,0) == 0)
	   U(i,k) = (resbiasX[0][k+1] - x(i))/(resbiasX[0][k+1] - resbiasX[0][k]), for k = 0..ResBins[0]-1 (U(i,ResBins[0]) == 0)
	   x(i) == errors[i].rawx
	   y(i) == errors[i].y
	   var(i) == A + B * y(i) + R*y(i)^2 + E * errors[i]->resvar

	   Then solve the tri-diagnonal set of equations for resbias[0][k = 0..ResBins[0]] as follows:
	     
	   nC[0] = CC[0]/BB[0]
	   nC[k] = CC[k]/(BB[k] - AA[k] * nC[k-1]), k = 1..ResBins[0]
	   nD[0] = DD[0]/BB[0]
	   nD[k] = (DD[k] - AA[k] * nD[k-1])/(BB[k] - AA[k] * nC[k-1]), k = 1 ... ResBins[0]

	   resbias[0][ResBins[0]] = nD[ResBins[0]]
	   resbias[0][k] = nD[k] - nC[k] * resbias[0][k+1], k = ResBins[0]-1 ... 0

	   Then compute corrected errors[i].x as follows :

	   For k = 0...ResBins[0]-1, 
	   For i = Start[k]..End[k] -1
	   errors[i].x = x(i) - (resbias[0][k] + (resbias[0][k+1]-resbias[0][k])(x(i)-resbiasX[0][k])/(resbiasX[0][k+1]-resbiasX[0][k]))
	*/
	if(maxindex >= 1){
	  /* compute coeficients of tridiagonal linear equations */
	  double AA[RESBINS+1], BB[RESBINS+1], CC[RESBINS+1], DD[RESBINS+1];
	  for(int k = 0; k <= ResBins[0]; k++){
	    AA[k] = BB[k] = CC[k] = DD[k] = 0.0;
	    meanbias[k] = 0.0;
	    if(k > 0){
	      if(DEBUG) assert(resbiasX[0][k] > resbiasX[0][k-1]);
	      double Tinv = 1.0/(resbiasX[0][k] - resbiasX[0][k-1]);
	      for(int i = Start[k-1]; i < End[k-1]; i++){// Multithread ??
		Cinterval *perr = &errors[i];
		double y = perr->y;
		if(DEBUG>=2) assert(!perr->end);
		double x = perr->rawx;
		double var = A + B * y;
		if(QUADRATIC_VARIANCE)
		  var += R*y*y;
		if(RES_VARIANCE)
		  var += E * perr->resvar;
		if(DEBUG>=2) assert(isfinite(var) && var > 0.0);
		double Tik = (x - resbiasX[0][k-1])*Tinv;
		double TIvar = Tik/var;
		
		AA[k] += (1.0 - Tik) * TIvar;
		BB[k] += Tik * TIvar;
		DD[k] += (x - y) * TIvar;
	      }
	    }
	    if(k < ResBins[0]){
	      double Wsum = 0.0;
	      if(DEBUG) assert(resbiasX[0][k+1] > resbiasX[0][k]);
	      double Uinv = 1.0/(resbiasX[0][k+1] - resbiasX[0][k]);
	      for(int i = Start[k]; i < End[k]; i++){// Multithread ??
		Cinterval *perr = &errors[i];
		double y = perr->y;
		if(DEBUG>=2) assert(!perr->end);
		double x = perr->rawx;
		double err = x - y;
		double var = A + B * y;
		if(QUADRATIC_VARIANCE)
		  var += R*y*y;
		if(RES_VARIANCE)
		  var += E * perr->resvar;
		if(DEBUG>=2) assert(isfinite(var) && var > 0.0);
		double Uik = (resbiasX[0][k+1] - x) * Uinv;
		double Ivar = 1.0/var;
		double UIvar = Uik * Ivar;

		BB[k] += Uik * UIvar;
		CC[k] += (1.0 - Uik) * UIvar;
		DD[k] += err * UIvar;

		meanbias[k] += err * Ivar;
		Wsum += Ivar;
	      }	      
	      meanbias[k] /= Wsum;
	    }
	  }
	  
	  /* solve tri-diagonoal linear equations */
	  double nC[RESBINS+1], nD[RESBINS+1];

	  if(BB[0] <= 0.0){
	    printf("During biaswt estimation equation system was singular:BB[0]=%0.8e\n",BB[0]);
	    printf(" skipping -resbias\n");
	    fflush(stdout);
	    goto Lnoresbias;
	  }

	  double Binv = 1.0/BB[0];
	  nC[0] = CC[0] * Binv;
	  nD[0] = DD[0] * Binv;
	  for(int k = 1; k <= ResBins[0]; k++){
	    double Bexp = BB[k] - AA[k] * nC[k-1];
	    if(DEBUG && !(Bexp != 0.0)){
	      printf("During biaswt estimation equation system was singular:\n");
	      printf("k=%d:BB[k]=%0.8e,AA[k]=%0.8e,nC[k-1]=%0.8e:Bexp=%0.8e\n",
		     k,BB[k],AA[k],nC[k-1],Bexp);
	      printf("BB[0]=%0.8e,AA[0]=%0.8e,CC[0]=%0.8e,DD[0]=%0.8e,nC[0]=%0.8e,nD[0]=%0.8e\n",
		     BB[0],AA[0],CC[0],DD[0],nC[0],nD[0]);
	      printf("ResBins[0]=%d,Start[0]=%d,End[0]=%d,maxindex=%d\n",ResBins[0],Start[0],End[0],maxindex);
	      printf("resbiasX[0][0]=%0.8e\n",resbiasX[0][0]);
	      printf(" skipping -resbias\n");
	      fflush(stdout);
	      goto Lnoresbias;
	    }
	    Binv = 1.0/Bexp;
	    nC[k] = CC[k] * Binv;
	    nD[k] = (DD[k] - AA[k] * nD[k-1]) * Binv;
	  }
	  
	  int K = ResBins[0];

	  // No monotonicty is enforced (it will be enforced later if RESBIAS_MONOTONIC)

 	  // solve for resbias[0][k] before applying <= 0 constraints
	  resbias[0][K] = nD[K];
	  for(int k = K; --k >= 0;)
	    resbias[0][k] = nD[k] - nC[k] * resbias[0][k+1];

	  for(K= 0;K <= ResBins[0]; K++)
	    if(meanbias[K] >= 0)
	      break;

	  int *BinCnt = new int[ResBins[0]];
	  size_t Icnt = 0;

	  if(VERB>=2){   /* compute counts of all molecule intervals */
	    for(int m = 0; m < nummaps; m++)
	      Icnt += Gmap[m]->numsite[0] - 1;

	    FLOAT *intervals = new FLOAT[Icnt];
	    size_t cnt = 0;
	    for(int m = 0; m < nummaps; m++){
	      Cmap *pmap = Gmap[m];
	      int M = pmap->numsite[0];
	      FLOAT *X = pmap->rawsite[0];
	      for(int I = 1; I < M; I++){
		intervals[cnt++] = X[I+1] - X[I];
		if(VERB>=3)
		  printf("m=%d(id=%lld):I=%d:X[I+1]-X[I]= %0.12f\n",m,pmap->id,I,X[I+1]-X[I]);
	      }
	    }
	    assert(cnt == Icnt);
	    qsort(intervals, Icnt, sizeof(double), (intcmp *)DoubleInc);

	    cnt = 0;
	    for(int Bin = 0; Bin < ResBins[0]; Bin++){
	      double UB = resbiasX[0][Bin+1];
	      size_t startcnt = cnt;
	      while(intervals[cnt] < UB)
		cnt++;
	      if(DEBUG) assert(cnt - startcnt <= MASK(31));
	      BinCnt[Bin] = cnt - startcnt;
	      if(VERB>=2){
		printf("Bin=%d : BinCnt= %d (%lu .. %lu):\n",Bin,BinCnt[Bin], startcnt, cnt);
		for(size_t i = startcnt; i < cnt; i++)
		  printf("\tinterval[%lu]= %0.12f\n", i, intervals[i]);

		fflush(stdout);
	      }
	    }

	    delete [] intervals;

	    printf("Original new resbias values (K=%d, Icnt=%lu, nummaps=%d):\n", K,Icnt,nummaps);
	    for(int k = min(ResBins[0]-1, K); k >= 0; k--)
	      printf("k=%d:resbias[0][k]=%0.8f at resbiasX[k]=%0.8f (mean bias between %0.3f .. %0.3f : %0.8f): samples= %d/%d nD[k]= %0.10f nC[k]= %0.10f\n",
		     k,resbias[0][k], resbiasX[0][k], resbiasX[0][k], resbiasX[0][k+1], meanbias[k], End[k]-Start[k], BinCnt[k], nD[k], nC[k]);
	    fflush(stdout);
	  }

	  /* constrain solution so highest few resbias[0][K..ResBins[0]] are == 0.0 where K is lowest value with meanbias[K] >= 0 */
	  for(int k = K; k <= ResBins[0]; k++)
	    resbias[0][k] = 0.0;

#if RESBIAS_MONOTONIC >= 2 // apply <= 0 constraints the OLD way
	  if(RESBIAS_BOUNDS){
	    /* average meanbias[] values accross nearby bins, so values are monotonic : result in meanbias2[] */
	    for(int k = 0; k <= ResBins[0]; k++)
	      meanbias2[k] = min(0.0,meanbias[k]);
	    for(int k = ResBins[0]-1; --k >= 0;){
	      if(meanbias2[k] > meanbias2[k+1]){
		for(int t = 1; k+t < ResBins[0]; t++){/* average meanbias2[k] with meanbias2[k+1...k+t] : stop if average is <= meanbias2[k+t+1] */
		  double meansum = 0.0, wtsum = 0.0;
		  for(int u = k; u <= k+t; u++){
		    double wt = End[u] - Start[u];
		    if(DEBUG && wt <= 0.0){
		      printf("WARNING: total samples for Bins %d is %d :\n",u,End[u]-Start[u]);
		      fflush(stdout);
		      assert(wt > 0.0);
		    }
		    wtsum += wt;
		    meansum += wt * meanbias2[u];
		  }
		  if(DEBUG && wtsum <= 0.0){
		    printf("WARNING: total samples for Bins %d..%d is 0 :\n",k,k+t);
		    for(int u = k; u <= k+t; u++)
		      printf("Bin=%d: mean bias between %0.3f .. %0.3f is %0.6f, samples= %d\n",u, resbiasX[0][u], resbiasX[0][u+1], meanbias2[u], End[u] - Start[u]);
		    fflush(stdout);
		    assert(wtsum > 0.0);
		  }
		  meansum /= wtsum;
		  for(int u = k; u <= k+t; u++)
		    meanbias2[u] = meansum;
		  if(k+t >= ResBins[0] || meansum <= meanbias2[k+t+1])
		    break;
		}
	      }
	    }
	    if(VERB>=2){
	      for(int k = ResBins[0]-1; --k >= 0;)
		if(meanbias[k] != meanbias2[k])
		  printf("adjusted meanbias[%d] = %0.8f -> %0.8f\n",k,meanbias[k],meanbias2[k]);
	      fflush(stdout);
	    }
	    for(int k = min(ResBins[0],K); --k >= 0;){
	      resbias[0][k] = min(meanbias2[k], resbias[0][k]);
	      if(k > 0)
		resbias[0][k] = max(meanbias2[k-1], resbias[0][k]);
	      if(RESBIAS_BOUNDS >=2 && k <= 1)
		resbias[0][k] = max(meanbias2[k], resbias[0][k]);
	    }
	  } else {
	    if(K > ResBins[0])
	      resbias[0][K = ResBins[0]] = min(0.0,nD[ResBins[0]]);
	    for(int k = K; --k >= 0;){
	      resbias[0][k] = nD[k] - nC[k] * resbias[0][k+1];
	      if(resbias[0][k+1] == 0.0)
		resbias[0][k] = min(0.0,resbias[0][k]);
	      if(RESBIAS_BOUNDS){
		resbias[0][k] = min(meanbias[k], resbias[0][k]);
		if(k > 0)
		  resbias[0][k] = max(meanbias[k-1], resbias[0][k]);
	      }
	    }
	  }
#endif

	  if(VERB>=2){
	    printf("New resbias values after applying constraints\n");
	    for(int k = min(ResBins[0]-1, K); k >= 0; k--){
	      if(Icnt > 0)
		printf("k=%d:resbias[0][k]=%0.8f at resbiasX[k]=%0.8f (adjusted mean bias between %0.3f .. %0.3f : %0.8f): samples= %d/%d, nD[k]= %0.10f nC[k]= %0.10f\n",
		       k,resbias[0][k], resbiasX[0][k], resbiasX[0][k], resbiasX[0][k+1], meanbias2[k], End[k]-Start[k], BinCnt[k], nD[k], nC[k]);
	      else
		printf("k=%d:resbias[0][k]=%0.8f at resbiasX[k]=%0.8f (adjusted mean bias between %0.3f .. %0.3f : %0.8f): samples= %d, nD[k]= %0.10f nC[k]= %0.10f\n",
		       k,resbias[0][k], resbiasX[0][k], resbiasX[0][k], resbiasX[0][k+1], meanbias2[k], End[k]-Start[k], nD[k], nC[k]);
	    }
	    fflush(stdout);
	  }

	  delete [] BinCnt;
	}
#else // SIMPLE_BIAS <= 1

	/* now estimate resbias[0][0..ResBins[0]] */
	resbias[0][ResBins[0]] = 0.0;/* assume bias is 0 at or above size cutoff : will be handled by -bpp adjustment if not correct */

	for(int Bin = ResBins[0]; --Bin >= 0; ){
	  int BinStart = Start[Bin];
	  int BinEnd = End[Bin];
	  if(DEBUG) assert(0 <= BinStart && BinStart < BinEnd && BinEnd <= maxindex+1);


	  /* resbias[0][Bin] = AVG((rawx - y)/var(y))/AVG(1/var(y)) */

	  double biassum = 0.0, Ivarsum = 0.0;

	  biascompute(biassum, Ivarsum, errors, Bin, BinStart, BinEnd, Tarray1, Tarray2, numthreads, A, B, R, E);

	  if(VERB>=2){
	    printf("Bin=%d:biassum=%0.18f,Ivarsum=%0.18f,BinStart=%d,BinEnd=%d\n",
		   Bin,biassum,Ivarsum,BinStart,BinEnd);
	    fflush(stdout);
	  }

          meanbias[Bin] = biassum / Ivarsum;
	  if(Bin+1 == ResBins[0])
	    resbias[0][Bin+1] = 0.0;
          resbias[0][Bin] = meanbias[Bin];
	}
#endif // SIMPLE_BIAS <= 1

	if(VERB>=2 && nummaps > 0){
	  printf("giter=%d:While estimating bias parameters(3):Gmap[0]->numsite[0]=M=%d,Gmap[0]->site[0][M]=%0.3f,Gmap[0]->rawsite[0][1]=%0.3f,Gmap[0]->rawsite[0][M]=%0.3f\n",
		 giter,Gmap[0]->numsite[0],Gmap[0]->site[0][Gmap[0]->numsite[0]],Gmap[0]->rawsite[0][1],Gmap[0]->rawsite[0][Gmap[0]->numsite[0]]);
	  fflush(stdout);
	}

	if(VERB>=3){
	  printf("\nRaw bias values:\n");
	  for(int Bin = ResBins[0];--Bin >= 0; )
	    printf("Bin=%d:size=%0.4f kb, bias=%7.4f (mean bias between %0.3f .. %0.3f : %0.4f, samples=%d)\n",
		   Bin, resbiasX[0][Bin], resbias[0][Bin], resbiasX[0][Bin],resbiasX[0][Bin+1], meanbias[Bin], End[Bin] - Start[Bin]);
	}
	if(DEBUG>=2) assert(resbiasX[0][ResBins[0]] == maxresbias);

	// suppress +ve bias values : let these be handled by bpp estimation
	// Also force it to be monotonic (to avoid extrapolated values near 0 going +ve) :
	resbias[0][0] = min(0.0,resbias[0][0]);
	for(int Bin = 1; Bin <= ResBins[0]; Bin++){
	  resbias[0][Bin] = min(0.0,resbias[0][Bin]);
	  if(RESBIAS_MONOTONIC)
	    resbias[0][Bin] = max(resbias[0][Bin-1],resbias[0][Bin]);
	}
	
	//	for(int Bin = 0; Bin <= ResBins[0]; Bin++)
	//	  resbias[0][Bin] = min(0.0,resbias[0][Bin]);

	/* create a table to quickly determine the Bin of any interval size up to maxresbias by the size expressed in bases : should match code in BiasCorrect() in Cmap.cpp*/
	if(DEBUG) assert(resbiasX[0][ResBins[0]] == maxresbias);

	int Ibot = (int)floor(resbiasX[0][0]*1000.0 + 0.5), Itop = 0;
	for(int i = 0; i < Ibot; i++)
	  SizeToBin[0][i] = 0;
	for(int Bin = 0; Bin < ResBins[0]; Bin++, Ibot = Itop){
	  Itop = (int)floor(resbiasX[0][Bin+1]*1000.0 + 0.5);
	  if(DEBUG>=2 && Bin && !(Ibot >= 0)){
	      for(int B = 0; B <= ResBins[0]; B++)
		printf("Bin=%d:resbiasX[0][Bin]=%0.4f,resbias[0][Bin]=%0.4f\n",B,resbiasX[0][B],resbias[0][B]);
	      printf("Bin=%d,Ibot=%d\n",Bin,Ibot);
	      fflush(stdout);
	    assert(Ibot >= 0);
	  }
	  if(DEBUG>=2) assert(Ibot <= Itop && Itop <= Imaxresbias);
	  for(int i = Ibot; i < Itop; i++)
	    SizeToBin[0][i] = Bin;
	  //	  SizeToBin[0][Itop] = Bin + 1;
	}
	if(DEBUG) assert(Itop >= Imaxresbias);
	for(int i = Ibot /* Itop+1 */; i <= Imaxresbias; i++)
	  SizeToBin[0][i] = ResBins[0];

	if(VERB>=2 && nummaps > 0){
	  printf("giter=%d:While estimating bias parameters(6):Gmap[0]->numsite[0]=M=%d,Gmap[0]->site[0][M]=%0.3f,Gmap[0]->rawsite[0][1]=%0.3f,Gmap[0]->rawsite[0][M]=%0.3f\n",
		 giter,Gmap[0]->numsite[0],Gmap[0]->site[0][Gmap[0]->numsite[0]],Gmap[0]->rawsite[0][1],Gmap[0]->rawsite[0][Gmap[0]->numsite[0]]);
	  fflush(stdout);
	}

	/* compute Offset[-1..ResBins[0]], Slope[-1..ResBins[0]] using code in BiasCorrect() in Cmap.cpp */
	double OffsetMem[MAXCOLOR][RESBINS+2], SlopeMem[MAXCOLOR][RESBINS+2];
	double *Offset[MAXCOLOR], *Slope[MAXCOLOR];
	for(int c = 0; c < colors; c++){
	  Offset[c] = &OffsetMem[c][1];
	  Slope[c] = &SlopeMem[c][1];
	}
	BiasCorrectSlope(Offset,Slope);

	/* estimate original LL (based on raw x), current LL and LL with simple bias removal (optimistically ignoring effect on neighboring intervals) */
	double Lsum = 0.0; /* sum of log(A+By+Ryy) excluding some cases with perr->end (see ENDFIX) */
	double errsum0 = 0.0, errsum1 = 0.0;/* sum of (x - y)^2/(A+By+Ryy) (for rawx and current x) */
	double logXtheta = 2.0*log(Xtheta) - log(2.0*M_PI);/* to match terms LLsd in logLR() */

	int orignumthreads = numthreads;
	if(VERB>=2 && WITH_RESBIAS && giter== -1){
	  numthreads = 1;
	  qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorIdInc);

	  printf("giter=%d : Original Resbias:\n",giter);
	  for(int Bin = 0; Bin <= ResBins[0]; Bin++)
	    printf("Bin=%d:resbiasX[0][0]=%0.3f,resbias=%0.6f\n",Bin,resbiasX[0][Bin],resbias[0][Bin]);
	  if(VERB>=2 && nummaps > 43){
	    Cmap *Xmap = Gmap[43];
	    FLOAT *X = Xmap->site[0];
	    FLOAT *rawX = Xmap->rawsite[0];
	    int M = Xmap->numsite[0];
	    for(int I = 0; I <= M+1; I++)
	      printf("I=%d: X[I]=%0.6f, rawX[I]=%0.6f\n",
		     I, X[I], rawX[I]);
	  }
	  fflush(stdout);
	}

	if(RESBIAS_TRACE){
	  numthreads = 1;
	  qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorIdInc);
	}

	for(int tid = 0; tid < numthreads; tid++)
	  Tarray1[tid] = Tarray2[tid] = Tarray3[tid] = 0.0;

	#pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	{
	  int tid = 0;
          #ifdef _OPENMP
	  tid = omp_get_thread_num ();
          #endif

	  double myLsum = 0.0;
	  double myerrsum0 = 0.0, myerrsum1 = 0.0;

#if !USE_MIC
          #pragma omp for schedule(static,64)
#endif
	  for(int i = 0; i < numerrors; i++){
	    if(USE_MIC && !(((i / 64) % numthreads) == tid)){ // NOTE : simulates #pragma omp for schedule(static,64)
	      continue;
	    }

	    Cinterval *perr = &errors[i];
	    double y = perr->y;
	    double x = perr->x;
#if REFDEBUG >= 1 || RESBIAS_DEBUG
	    perr->origx = x;// for debugging : see below
#endif
	    if(ENDFIX>=3 && perr->end && y >= x){
   	      if(VERB>=2 && WITH_RESBIAS && giter== -1 && perr->mapid == 43){
		printf("i=%d:    mapid=%d,L=%d,R=%d,end=%d:x=%0.6f,y=%0.6f : skipping since y >= x\n",
		       i,perr->mapid,perr->L,perr->R, perr->end, x, y);
		fflush(stdout);
	      }
	      
	      continue;
	    }
	    double rawx = perr->rawx;
            if(perr->end){ // NEW9 : compute correct rawx value 
              double *rawsite = Gmap[perr->mapid]->rawsite[0];
              rawx = rawsite[perr->R] - rawsite[perr->L];
            }
	    double var = A + B*y;
	    if(QUADRATIC_VARIANCE)
	      var += R*y*y;
	    if(RES_VARIANCE)
	      var += E * perr->resvar;
	    if(DEBUG>=2) assert(isfinite(var) && var > 0.0);
	    double err0 = y - rawx;
	    double err1 = y - x;
	    if(!(ENDFIX>=2 && perr->end))
	      myLsum += SDDEBUG ? log(var) - logXtheta : log(var);
	    double Ivar = 1.0/var;
	    myerrsum0 += RESBIAS_MAXERR2 ? min(err0*err0,perr->maxerr2)*Ivar : err0*err0*Ivar;
	    myerrsum1 += RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2)*Ivar : err1*err1*Ivar;
	    if(RESBIAS_TRACE || (DEBUG && bool(RESBIAS_MAXERR2) && !ScaleDelta && !(err1*err1 <= perr->maxerr2 * 1.01))){
	  //	      FLOAT *X = Gmap[perr->mapid]->site[0];
	      int M = Gmap[perr->mapid]->numsite[0];

	      #pragma omp critical
	      {
		if(!(ENDFIX>=2 && perr->end))
		  printf("i=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,L=%d,R=%d,M=%d,end=%d:Lsum=%0.6f,var=%0.6f,err0=%0.6f,err1=%0.6f,maxerr=%0.6f(cum=%0.6f,%0.6f),LLsd1=%0.6f:rawx=%0.6f, x1=%0.6f,y=%0.6f\n",
			 i,perr->refid, refmap[perr->refid]->id,perr->mapid,Gmap[perr->mapid]->id,perr->orientation,perr->L,perr->R,M,perr->end, -0.5*(log(var) - logXtheta), var, 
			 err0, err1, sqrt(perr->maxerr2), myerrsum0,myerrsum1,-0.5*(log(var)-logXtheta + (RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2) : err1*err1)*Ivar),rawx, x,y);
		else
		  printf("i=%d:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d,L=%d,R=%d,M=%d,end=%d:var=%0.6f,err0=%0.6f,err1=%0.6f,maxerr=%0.6f(cum=%0.6f,%0.6f),LLsd1=%0.6f:rawx=%0.6f, x1=%0.6f,y=%0.6f\n",
			 i,perr->refid,refmap[perr->refid]->id,perr->mapid,Gmap[perr->mapid]->id,perr->orientation,perr->L,perr->R,M,perr->end, var, 
			 err0, err1, sqrt(perr->maxerr2), myerrsum0,myerrsum1,-0.5*(RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2):err1*err1)*Ivar, rawx, x, y);
		fflush(stdout);
		if(DEBUG/* HERE >=2 */ && bool(RESBIAS_MAXERR2) && !ScaleDelta) assert(err1*err1 <= perr->maxerr2 * 1.01);
	      }
	    }
	    
	    if(DEBUG>=2 && (!isfinite(myerrsum1) || !isfinite(myerrsum0))){
	      printf("i=%d/%d:x=%0.4f,y=%0.4f,rawx=%0.4f,var=%0.6f,err0=%0.4f,err1=%0.4f,myerrsum0=%0.8f,myerrsum1=%0.8f\n",
		     i,numerrors, x, y, rawx, var, err0, err1, myerrsum0,myerrsum1);
	      fflush(stdout);
	      assert(isfinite(myerrsum0));
	      assert(isfinite(myerrsum1));
	    }
	  }

	  Tarray1[tid] = myLsum;
	  Tarray2[tid] = myerrsum0;
	  Tarray3[tid] = myerrsum1;
	}
	for(int tid = 0; tid < numthreads; tid++){
	  Lsum += Tarray1[tid];
	  errsum0 += Tarray2[tid];
	  errsum1 += Tarray3[tid];
	}
	if(DEBUG>=2) assert(isfinite(Lsum));
	if(DEBUG>=2) assert(isfinite(errsum0));
	if(DEBUG>=2) assert(isfinite(errsum1));

	if(VERB>=2){
	  for(int c = 0; c < (usecolor ? MAXCOLOR : colors); c++)
	    printf("maxresbias=%0.6f, c=%d, ResBins[c]=%d, resbiasX[c][ResBins[c]]=%0.6f\n",maxresbias,c, ResBins[c],resbiasX[c][ResBins[c]]);
	  fflush(stdout);
	}

	if(RESBIAS_TRACE){
	  numthreads = orignumthreads;
	  qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorRawxInc);
	}

	/* apply simple bias removal for each interval errors[BinStart .. BinEnd-1] to rawx and save result in x */
	for(int Bin = ResBins[0]; --Bin >= 0; ){
	  int BinStart = Start[Bin];
	  int BinEnd = End[Bin];

	  double slope = Slope[0][Bin];
	  double offset = Offset[0][Bin];

	  if(VERB/* HERE >=2 */ && resbiasX[0][Bin] < 2.0){
	    if(Bin <= startResBins)
	      printf("Bin=%d:size=%7.4f -> %7.4f kb, bias= %0.6f -> %0.6f (mean bias between %0.4f .. %0.4f : %0.6f, samples=%d, Offset=%0.4f,Slope=%0.6f)\n",
		     Bin, startresbiasX[Bin], resbiasX[0][Bin], startresbias[Bin], resbias[0][Bin], resbiasX[0][Bin],resbiasX[0][Bin+1], meanbias[Bin], BinEnd - BinStart, Offset[0][Bin], Slope[0][Bin]);
	    else
	      printf("Bin=%d:size=%7.4f, bias= %0.6f (mean bias between %0.3f .. %0.3f : %0.6f, samples=%d, Offset=%0.4f,Slope=%0.6f)\n",
		     Bin, resbiasX[0][Bin], resbias[0][Bin], resbiasX[0][Bin],resbiasX[0][Bin+1], meanbias[Bin], BinEnd - BinStart, Offset[0][Bin], Slope[0][Bin]);
	    fflush(stdout);
	  }
	  //          if(Bin > 0)continue;

          #pragma omp parallel for num_threads(numthreads) schedule(static,64)
	  for(int i = BinStart; i < BinEnd; i++){
	    Cinterval *perr = &errors[i];
	    if(DEBUG>=2) assert(!perr->end);
	    double bias = offset + slope * perr->rawx;
	    perr->x = perr->rawx - bias;
	    if(DEBUG>=2) assert(perr->x > 0.0);
	  }
	}

	  //	Offset[0][ResBins[0]] = resbias[0][ResBins[0]];
	  //	Slope[0][ResBins[0]] = 0.0;

	if(VERB>=2 && nummaps > 0){
	  printf("giter=%d:Before estimating LL with simple bias removal:Gmap[0]->numsite[0]=M=%d,Gmap[0]->site[0][M]=%0.3f,Gmap[0]->rawsite[0][1]=%0.3f,Gmap[0]->rawsite[0][M]=%0.3f\n",
		 giter,Gmap[0]->numsite[0],Gmap[0]->site[0][Gmap[0]->numsite[0]],Gmap[0]->rawsite[0][1],Gmap[0]->rawsite[0][Gmap[0]->numsite[0]]);
	  fflush(stdout);
	}

	/* estimate LL for rawx with simple bias removal (NOTE : For giter > 0, the result will not match the original LL, even if resbiasX/resbias are unchanged !)*/
	double errsum2 = 0.0;/* sum of (x - y)^2/(A+By+Ryy) (for rawx with simple bias removal from rawx) */
	for(int tid = 0; tid < numthreads; tid++)
	  Tarray2[tid] = 0.0;

	if(RESBIAS_TRACE){
	  numthreads = 1;
	  qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorIdInc);
	}

	#pragma omp parallel num_threads(numthreads)
	{
	  int tid = 0;
          #ifdef _OPENMP
	  tid = omp_get_thread_num ();
          #endif

	  double myerrsum2 = 0.0;

#if !USE_MIC
          #pragma omp for schedule(static,64)
#endif
	  for(int i = 0; i < numerrors; i++){
	    if(USE_MIC && !(((i / 64) % numthreads) == tid)){ // NOTE : simulates #pragma omp for schedule(static,64)
	      continue;
	    }

            Cinterval *perr = &errors[i];
	    double y = perr->y;
	    double x = perr->x;
	    if(ENDFIX>=3 && perr->end && y >= x)
	      continue;

	    double var = A + B*y;
	    if(QUADRATIC_VARIANCE)
	      var += R*y*y;
	    if(RES_VARIANCE)
	      var += E * perr->resvar;
	    if(DEBUG>=2) assert(isfinite(var) && var > 0.0);
	    double Ivar = 1.0/var;

	    double err2 = y - x;
	    myerrsum2 += RESBIAS_MAXERR2 ? min(err2*err2,perr->maxerr2)*Ivar : err2*err2*Ivar;
	    
	    if((DEBUG>=2 && !isfinite(myerrsum2)) || RESBIAS_TRACE){
              int M = Gmap[perr->mapid]->numsite[0];
	      printf("i=%d/%d:mapid=%d,L=%d,R=%d,M=%d,end=%d:var=%0.6f,err2=%0.6f(cum=%0.6f),maxerr=%0.6f:rawx=%0.6f, simple x=%0.6f, y=%0.6f\n",
		     i,numerrors, perr->mapid, perr->L, perr->R, M, perr->end,var, err2, myerrsum2,sqrt(perr->maxerr2),perr->rawx,x,y);
	      fflush(stdout);
	      assert(isfinite(myerrsum2));
	    }
	  }

	  Tarray2[tid] = myerrsum2;
	}
	for(int tid = 0; tid < numthreads; tid++)
	  errsum2 += Tarray2[tid];
	if(DEBUG>=2) assert(isfinite(errsum2));

	if(VERB>=2){
	  printf("BiasCorrect1:maxresbias=%0.10f,ResBins[0]=%d:\n",maxresbias,ResBins[0]);
	  for(int Bin = 0; Bin <= ResBins[0]; Bin++)
	    printf("Bin=%d:resbiasX[0]=%0.10f,resbias=%0.10f\n",Bin,resbiasX[0][Bin],resbias[0][Bin]);
	  fflush(stdout);
	}

	if(RESBIAS_TRACE){
	  numthreads = orignumthreads;
	  qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorRawxInc);
	}

	int nthreads = 1;
#ifdef _OPENMP
	nthreads = MaxThreads; // WAS omp_get_max_threads();
	//	nthreads = min(nthreads,MaxThreads);
	nthreads = max(1,min(nthreads, nummaps/2048));
#endif  

	/* Apply full bias removal to all sites using NEW CODE BiasCorrect2 in Cmap.cpp */

	/* NOTE : no need to handle -subset maps or split maps since they will not be re-aligned */
	BiasCorrect2(Gmap, 0, nummaps, nthreads, SizeToBin, Imaxresbias, Offset, Slope);// requires previous call to BiasCorrectSlope

#ifdef _OPENMP
	numthreads = MaxThreads; // WAS omp_get_max_threads();
	if(numthreads > numerrors/64)
	  numthreads = max(1,numerrors/64);
#endif

	/* now recompute x values in errors[] based on new site[] values and new LL value */
	double errsum3 = 0.0;
	for(int tid = 0; tid < numthreads; tid++)
	  Tarray3[tid] = 0.0;

	if(RESBIAS_TRACE){
	  numthreads = 1;
	  qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorIdInc);
	}

	#pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	{
	  int tid = 0;
          #ifdef _OPENMP
	  tid = omp_get_thread_num ();
          #endif

	  int lastid  = -1;
	  double LogSum = 0.0,Errsum1 = 0.0, Errsum2 = 0.0, LogCum = 0.0, Errcum1 = 0.0, Errcum2 = 0.0;/* for debugging */

#if REFDEBUG>=1 || RESBIAS_DEBUG
	  double myerrsum0 = 0.0;
	  double myerrsum1 = 0.0;
#endif
	  double myerrsum3 = 0.0;

#if !USE_MIC
	  #pragma omp for schedule(static,64)
#endif
  	  for(int i = 0; i < numerrors; i++){
	    if(USE_MIC && !(((i / 64) % numthreads) == tid)){ // NOTE : simulates #pragma omp for schedule(static,64)
	      continue;
	    }
	    Cinterval *perr = &errors[i];
	    FLOAT *X = Gmap[perr->mapid]->site[0], *rawX;
	    FLOAT newx = X[perr->R] - X[perr->L], oldx;
	    if(0 && DEBUG && (rawX = Gmap[perr->mapid]->rawsite[0], oldx  = rawX[perr->R] - rawX[perr->L]) <= maxresbias && 
	       resbias[0][0] < 0.0 && !(newx >= oldx + resbias[0][0] - 1e-6 && newx <= oldx - resbias[0][0] + 1e-6)){
	      #pragma omp critical
	      {
		printf("error[%d]:mapid=%d:L=%d,R=%d,M=%d:newx=%0.4f,oldx=%0.4f,resbias[0][0]=%0.4f:X[L-1..R+1]=%0.4f,%0.4f,%0.4f,%0.4f rawX[L-1..R+1]=%0.4f,%0.4f,%0.4f,%0.4f\n",
		       i,perr->mapid,perr->L,perr->R,Gmap[perr->mapid]->numsite[0],newx,oldx,resbias[0][0],X[perr->L-1],X[perr->L],X[perr->R],X[perr->R+1],rawX[perr->L-1],rawX[perr->L],rawX[perr->R],rawX[perr->R+1]);
		assert(newx >= oldx + resbias[0][0] - 1e-6 && newx <= oldx - resbias[0][0] + 1e-6);
	      }
	    }
	    double x = perr->x = newx;
	    if(DEBUG>=2) assert(perr->x > 0.0);
	    double y = perr->y;
	    if(ENDFIX>=3 && perr->end && y >= x){
	      if(VERB>=2 && WITH_RESBIAS && giter== -1 && perr->mapid == 43){
		printf("    mapid=%d,L=%d,R=%d,end=%d:x=%0.6f,y=%0.6f : skipping since y >= x\n",
	               perr->mapid,perr->L,perr->R, perr->end, x, y);
		fflush(stdout);
	      }
	      continue;
	    }
	    double var = A + B*y;
	    if(QUADRATIC_VARIANCE)
	      var += R*y*y;
	    if(RES_VARIANCE)
	      var += E * perr->resvar;
	    if(DEBUG>=2) assert(var > 0.0);
	    double Ivar = 1.0/var;
	    double err = y - x;
	    if(RESBIAS_TRACE){/* display per molecule statistics ( NOTE: must call qsort() before this parallel loop and reduced threads to 1) */
	      int mapid = perr->mapid;
	      if(mapid != lastid){
		LogCum += LogSum;
		Errcum1 += Errsum1;
		Errcum2 += Errsum2;
		if(lastid >= 0){/* display values for mol lastid */
		  printf("  mapid=%d(id=%lld):Lsum=%0.6f,errsum=%0.6f->%0.6f,LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
			 lastid,Gmap[lastid]->id, -0.5*LogSum, -0.5*Errsum1, -0.5*Errsum2, -0.5*(LogSum+Errsum1), -0.5*(LogSum+Errsum2),-0.5*(Errsum2-Errsum1),
			 -0.5*(LogCum + Errcum1), -0.5*(LogCum + Errcum2));
		  fflush(stdout);
		}
		lastid = mapid;
		LogSum = Errsum1 = Errsum2 = 0.0;
	      }
	      if(!(ENDFIX>=2 && perr->end)){
		LogSum += log(var) - logXtheta;
		if(DEBUG){
		  rawX = Gmap[perr->mapid]->rawsite[0];
		  oldx  = rawX[perr->R] - rawX[perr->L];
		  assert(fabs(oldx - perr->rawx) < 1e-6);
		}
	      }
              Errsum2 += (RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2):err*err)*Ivar;
#if REFDEBUG>=1 || RESBIAS_DEBUG
	      double err1 = y - perr->origx;
	      Errsum1 += (RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2):err1*err1)*Ivar;
	      if(VERB>=2 /* && mapid == 43 */){
	        int M = Gmap[perr->mapid]->numsite[0];
		if(!(ENDFIX>=2 && perr->end))
		  printf("    mapid=%d,L=%d,R=%d,end=%d:Lsum=%0.6f,errterm=%0.6f->%0.6f,LLsd=%0.6f->%0.6f(delta=%0.6f,cum=%0.6f -> %0.6f),x=%0.6f -> %0.6f,y=%0.6f\n",
	                  mapid,perr->L,perr->R,perr->end,-0.5*(log(var) - logXtheta), 
	                  (RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2) : err1*err1)*Ivar, (RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2):err*err)*Ivar,
	                  -0.5*(log(var)-logXtheta + (RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2):err1*err1)*Ivar),
	                  -0.5*(log(var)-logXtheta + (RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2) : err*err)*Ivar), 
	                  -0.5*(RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2)-min(err1*err1,perr->maxerr2) : err*err - err1*err1)*Ivar,
			 -0.5*(LogSum+Errsum1),-0.5*(LogSum+Errsum2), perr->origx, x, y);
		else
		  printf("    mapid=%d,L=%d,R=%d,end=%d:errterm=%0.6f->%0.6f,LLsd=%0.6f->%0.6f(delta=%0.6f,cum=%0.6f -> %0.6f),x=%0.6f -> %0.6f,y=%0.6f, X[L]=%0.6f,X[R]=%0.6f,X[%d]=%0.6f\n",
                         mapid,perr->L,perr->R,perr->end,
	                 (RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2) : err1*err1)*Ivar, (RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2):err*err)*Ivar,
                         -0.5*(RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2) : err1*err1)*Ivar, -0.5*(RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2) : err*err)*Ivar,
	                 -0.5*(RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2)-min(err1*err1,perr->maxerr2) : err*err - err1*err1)*Ivar,
	                 -0.5*(LogSum+Errsum1),-0.5*(LogSum+Errsum2), perr->origx, x, y, X[perr->L], X[perr->R], M+1, X[M+1]);
		fflush(stdout);
	      }
#endif
	    }

	    double delta3;
	    myerrsum3 += delta3 = RESBIAS_MAXERR2 ? min(err*err,perr->maxerr2)*Ivar : err*err*Ivar;

	    if((DEBUG>=2 && !(isfinite(err))) || RESBIAS_TRACE){
	      #pragma omp critical
	      {
		int M = Gmap[perr->mapid]->numsite[0];
		rawX = Gmap[perr->mapid]->rawsite[0];
#if REFDEBUG >= 1 || RESBIAS_DEBUG	       
                double rawx = perr->rawx;
                if(perr->end){// NEW9
		  rawx = rawX[perr->R] - rawX[perr->L];
		//		  double *rawsite = Gmap[perr->mapid]->rawsite[0];
		//		  rawx = rawsite[perr->R] - rawsite[perr->L];
		}
		double err0 = y - rawx;
		double err1 = y - perr->origx, delta1;	      
		myerrsum0 += RESBIAS_MAXERR2 ? min(err0*err0,perr->maxerr2)*Ivar : err0*err0*Ivar;
		myerrsum1 += delta1 = RESBIAS_MAXERR2 ? min(err1*err1,perr->maxerr2)*Ivar : err1*err1*Ivar;
		printf("i=%d/%d:mapid=%d,L=%d,R=%d,M=%d,end=%d:var=%0.6f,err0=%0.6f,err1=%0.6f,err3=%0.6f,maxerr=%0.6f(cum=%0.6f,%0.6f,%0.6f,del=%0.6f):rawx=%0.6f,x1=%0.6f,x3=%0.6f,y=%0.6f\n",
		       i,numerrors,perr->mapid,perr->L,perr->R,M,perr->end,var,err0,err1,err,sqrt(perr->maxerr2),myerrsum0,myerrsum1,myerrsum3, delta3-delta1, rawx, perr->origx, x,y);
#else
		printf("i=%d/%d:mapid=%d,L=%d,R=%d,M=%d,end=%d:X[R]=%0.3f,X[L]=%0.3f,rawX[R]=%0.6f,rawX[L]=%0.6f:var=%0.6f,err3=%0.6f,maxerr=%0.6f(cum=%0.6f):rawx=%0.6f, x=%0.6f, y=%0.6f\n",
		       i,numerrors,perr->mapid,perr->L,perr->R,M,perr->end,X[perr->R],X[perr->L],rawX[perr->R],rawX[perr->L],var,err,sqrt(perr->maxerr2),myerrsum3, rawx, x,y);
#endif
		if(!isfinite(err) || VERB>=2){
		  printf("mapid=%d,id=%lld\n",perr->mapid,Gmap[perr->mapid]->id);
		  for(int J = 1; J <= M+1; J++)
		    printf("J=%d:rawX[J]=%0.3f,X[J]=%0.3f\n",J,rawX[J],X[J]);
		}
		fflush(stdout);

		assert(isfinite(err));
	      }
	    }
	    if(DEBUG>=2) assert(isfinite(myerrsum3));
	  }
	  if(RESBIAS_TRACE && lastid >= 0){/* display values for lastid */
            LogCum += LogSum;
	    Errcum1 += Errsum1;
	    Errcum2 += Errsum2;
	    printf("  mapid=%d(id=%lld):Lsum=%0.6f,errsum=%0.6f->%0.6f,LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
	      lastid,Gmap[lastid]->id, -0.5*LogSum, -0.5*Errsum1, -0.5*Errsum2, -0.5*(LogSum+Errsum1), -0.5*(LogSum+Errsum2),-0.5*(Errsum2-Errsum1),
	      -0.5*(LogCum + Errcum1), -0.5*(LogCum + Errcum2));
	    fflush(stdout);
	  }

	  Tarray3[tid] = myerrsum3;
	}
	for(int tid = 0; tid < numthreads; tid++)
	  errsum3 += Tarray3[tid];

	double LL0 = -(Lsum+errsum0)*0.5;
	double LL1 = -(Lsum+errsum1)*0.5;
	double LL2 = -(Lsum+errsum2)*0.5;
	double LL3 = -(Lsum+errsum3)*0.5;

	if(RESBIAS_TRACE){
          numthreads = orignumthreads;
	  qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorRawxInc);
        }

	if(VERB){
	  printf("Raw LL=%0.6f(errsum0=%0.6f),Previous LL=%0.6f(errsum1=%0.6f), Simple Bias Correction LL=%0.6f(errsum2=%0.6f), Final Correction LL=%0.6f(Lsum=%0.6f,errsum3=%0.6f):wall time=%0.6f\n",
		 LL0, errsum0, LL1, errsum1, LL2, errsum2, LL3, Lsum, errsum3, wtime());
	  fflush(stdout);
	}
	
	if(DEBUG) assert(isfinite(Lsum));
	if(DEBUG) assert(isfinite(errsum0));
	if(DEBUG) assert(isfinite(errsum1));
	if(DEBUG) assert(isfinite(errsum2));
	if(DEBUG) assert(isfinite(errsum3));
	
	if(RESBIAS_BACKTRACK_PARTIAL /* && LL3 < LL1 */ && RESBIAS_FIXBINS){/* try partial backtrack to original bias values to maximize LL3 */
	  /* first save current bias values */
	  double origresbias[RESBINS+1];
	  int origResBins = ResBins[0];
	  for(int Bin = 0; Bin < origResBins; Bin++)
	    origresbias[Bin] = resbias[0][Bin];

	  double best = (LL3 <= LL1) ? 0.0 : 1.0;/* best interpolation value : 0 means startresbias[], 1 means origresbias[] */
	  double bestLL = max(LL3,LL1);
	  double Low = (LL3 <= LL1) ? -0.5 : 0.0;/* lower bound interpolation value : -0.5 means backtrack beyond startresbias[] by up to 50% (subject to all resbias values being <= 0) */
	  double High = (LL3 <= LL1) ? 1.0 : 1.5;/* upper bound interpolation value : 1.5 means extrapolate beyond origresbias[] by up to 50% */

#if 0
	  // first try binary backtrack to find approximate peak
	  while(best <= 0.0 && High - Low > 0.001){
	    double val = (High + Low) * 0.5;

	    for(int Bin = 0; Bin < origResBins; Bin++)
	      resbias[0][Bin] = val * origresbias[Bin] + (1.0 - val) * startresbias[Bin];
	    
	    errsum3 = updateBiasLL(val, errors, numerrors, A,B,R,E,logXtheta,Tarray3);
	    double newLL3 = -(Lsum + errsum3)*0.5;
	      
	    if(newLL3 > LL1){
	      LL3 = bestLL = newLL3;
	      best = val;
	    } else
	      High = val;

	    if(VERB){
	      printf("Backtracking resbias by %0.4f%%: ResBins[0]=%d,resbias[0][0]= %0.6f, resbias[0][1]= %0.6f, LL3= %0.6f(errsum3=%0.6f) (best backtrack = %0.4f%%, LL= %0.6f) Low= %0.6f,High=%0.6f\n",
		     (1.0 - val)*100.0, ResBins[0], resbias[0][0], resbias[0][1], newLL3, errsum3, (1.0-best)*100.0, bestLL, Low,High);
	      fflush(stdout);
	    }

	    if(newLL3 > LL1)
		    break;
	  }
#endif

          /* Use Goldenmean search to change all parameters by the same ratio */
	  double phi = (1.0 + sqrt(5.0))*0.5;
	  double resphi = 2.0 - phi;
	  double Mid = best;

	  double val = best, newLL3 = bestLL;

	  while(max(High - Mid, Mid - Low) > 0.000001){
	    if(High - Mid > Mid - Low){
	      val = Mid + resphi * (High - Mid);
	      for(int Bin = 0; Bin < origResBins; Bin++)
		resbias[0][Bin] = min(0.0, val * origresbias[Bin] + (1.0 - val) * startresbias[Bin]);

	      errsum3 = updateBiasLL(val, errors, numerrors, A,B,R,E,logXtheta,Tarray3);
	      newLL3 = -(Lsum + errsum3)*0.5;

	      if(/*NEW38*/(Mid < 1.0) ? (newLL3 >= bestLL) : (newLL3 > bestLL)){
		LL3 = bestLL = newLL3;
		best = val;
		Low = Mid;
		Mid = val;
	      } else
		High = val;
	    } else {
	      val = Mid - resphi * (Mid - Low);
	      for(int Bin = 0; Bin < origResBins; Bin++)
		resbias[0][Bin] = min(0.0/*NEW38*/, val * origresbias[Bin] + (1.0 - val) * startresbias[Bin]);

	      errsum3 = updateBiasLL(val, errors, numerrors, A,B,R,E,logXtheta,Tarray3);
	      newLL3 = -(Lsum + errsum3)*0.5;	      

	      if(/*NEW38*/(Mid > 1.0) ? (newLL3 >= bestLL) : (newLL3 > bestLL)){
		LL3 = bestLL = newLL3;
		best = val;
		High = Mid;
		Mid = val;
	      } else
		Low = val;
	    }

	    if(VERB>=2 || RESBIAS_TRACE){
	      printf("Backtracking resbias by %0.4f%%: ResBins[0]=%d,resbias[0][0]= %0.6f, resbias[0][1]= %0.6f, LL3= %0.6f(errsum3=%0.6f) (best backtrack = %0.4f%%, LL= %0.6f) Low= %0.6f,Mid=%0.6f,High=%0.6f\n",
		     (1.0 - val)*100.0, ResBins[0], resbias[0][0], resbias[0][1], newLL3, errsum3, (1.0-best)*100.0, bestLL, Low,Mid,High);
	      fflush(stdout);
	    }
	  } // while

	  if(val != best)
	    for(int Bin = 0; Bin < origResBins; Bin++)
	      resbias[0][Bin] = min(0.0, best * origresbias[Bin] + (1.0 - best) * startresbias[Bin]);
	  if(VERB){
	    printf("Backtracked resbias by %0.4f%%: resbias[0][0]= %0.6f, resbias[0][1]= %0.6f, LL3= %0.6f\n", (1.0-best)*100.0, resbias[0][0], resbias[0][1], bestLL);
	    fflush(stdout);
	  }

	  if(RESBIAS_BACKTRACK_PARTIAL >= 2 /* HERE HERE && !(giter==0 && giter2==0) */){/* try to optimise resbias[0][0.. RESBIAS_BACKTRACK_PARTIAL-2] individually */

	    for(int Bin = RESBIAS_BACKTRACK_PARTIAL - 1; --Bin >= 0;){
	      if(End[Bin] - Start[Bin] < RESBIAS_MINSAMPLE_BT)
		continue;

	      /* save original resbias values so we can enforce monotonicity */
	      for(int t = 0; t < origResBins; t++)
		origresbias[t] = resbias[0][t];

	      best = resbias[0][Bin];
	      if(DEBUG) assert(best <= 0.0);

	      if(best >= 0){
		Low = (Bin <= 0) ? -0.500 : resbias[0][Bin-1] - 0.050;
		High = 0.0;
	      } else {
		Low = min(-0.500, 2.0 * best);
		High = 0.0;
	      }

              if(Bin < ResBins[0] - 1){  /* avoid current Bin bias going more negative than that of previous bin - size difference */
                Low = max(Low, resbias[0][Bin+1] - (resbiasX[0][Bin+1] - resbiasX[0][Bin]));
		if(Low > best){/* This should happen rarely : update resbias[0][Bin] and recompute bestLL */
		  resbias[0][Bin] = Low;

		  /* keep resbias[0][0..ResBins[0]-1] monotonically increasing */
		  for(int t = 0; t < Bin; t++)
		    resbias[0][t] = min(origresbias[t], val);
		  for(int t = Bin + 1; t < ResBins[0]; t++)
		    resbias[0][t] = max(origresbias[t], val);

		  errsum3 = updateBiasLL(val, errors, numerrors, A,B,R,E,logXtheta,Tarray3);
		  if(VERB/* HERE HERE >=2 */){
		    printf("Enforced constraint on resbias[0][%d] = %0.6f -> %0.6f due to resbias[0][%d]= %0.6f: LL = %0.6f -> %0.6f\n",
			   Bin,best,Low,Bin+1,resbias[0][Bin+1],bestLL,-(Lsum+errsum3)*0.5);
		    fflush(stdout);
		  }
                  best = Low;
		  bestLL = -(Lsum + errsum3)*0.5;
		}
              }

	      Mid = best;

	      if(VERB>=2){
		printf("Optimizing resbias[0][%d] = %0.6f : Low= %0.6f, High= %0.6f: Initial LL= %0.6f, samples=%d\n",Bin, resbias[0][Bin], Low, High, bestLL, End[Bin]-Start[Bin]);
		fflush(stdout);
	      }
	      
	      while(max(High - Mid, Mid - Low) > 0.000001){
		//		double origval = resbias[0][Bin];
		if(High - Mid > Mid - Low){
		  resbias[0][Bin] = val = Mid + resphi * (High - Mid);

		  /* keep resbias[0][0..ResBins[0]-1] monotonically increasing */
		  for(int t = 0; t < Bin; t++)
		    resbias[0][t] = min(origresbias[t], val);
		  for(int t = Bin + 1; t < ResBins[0]; t++)
		    resbias[0][t] = max(origresbias[t], val);

		  errsum3 = updateBiasLL(val, errors, numerrors, A,B,R,E,logXtheta,Tarray3);
		  newLL3 = -(Lsum + errsum3)*0.5;

		  if(newLL3 > bestLL){
		    LL3 = bestLL = newLL3;
		    best = val;
		    Low = Mid;
		    Mid = val;
		  } else
		    High = val;
		} else {
		  resbias[0][Bin] = val = Mid - resphi * (Mid - Low);

		  /* keep resbias[0][0..ResBins[0]-1] monotonically increasing */
		  for(int t = 0; t < Bin; t++)
		    resbias[0][t] = min(origresbias[t], val);
		  for(int t = Bin + 1; t < ResBins[0]; t++)
		    resbias[0][t] = max(origresbias[t], val);

		  errsum3 = updateBiasLL(val, errors, numerrors, A,B,R,E,logXtheta,Tarray3);
		  newLL3 = -(Lsum + errsum3)*0.5;	      

		  if(newLL3 > bestLL){
		    LL3 = bestLL = newLL3;
		    best = val;
		    High = Mid;
		    Mid = val;
		  } else
		    Low = val;
		}

		if(VERB>=2){
		  printf("Changing resbias[0][%d] = %0.6f -> %0.6f: LL2= %0.6f(errsum3=%0.6f) (best = %0.6f, LL= %0.6f) Low= %0.6f, Mid= %0.6f, High= %0.6f\n",
			 Bin, origresbias[Bin], val, newLL3, errsum3, best, bestLL, Low, Mid, High);
		  fflush(stdout);
		}
	      } // while

	      if(val != best){
		resbias[0][Bin] = val;

		/* keep resbias[0][0..ResBins[0]-1] monotonically increasing */
		for(int t = 0; t < Bin; t++)
		  resbias[0][t] = min(origresbias[t], val);
		for(int t = Bin + 1; t < ResBins[0]; t++)
		  resbias[0][t] = max(origresbias[t], val);
	      }

	      if(VERB){
		printf("Updated resbias[0][%d]= %0.6f -> %0.6f, LL2= %0.6f, samples= %d\n", Bin, origresbias[Bin], resbias[0][Bin], bestLL, End[Bin]-Start[Bin]);
		fflush(stdout);
	      }
	    } // for Bin = 0 .. RESBIAS_BACKTRACK_PARTIAL - 2
	  } 

	  if(VERB){
	    printf("Final resbias values:\n");
	    for(int Bin = ResBins[0]; --Bin >= 0;){
	      if(resbias[0][Bin] == 0.0)
		continue;
	      printf("Bin=%2d:size= %0.6f, resbias= %0.6f -> %0.6f, samples=%d\n",Bin, resbiasX[0][Bin], startresbias[Bin], resbias[0][Bin], End[Bin]-Start[Bin]);
	    }
	    fflush(stdout);
	  }
	  BiasCorrect(Gmap, 0, nummaps, 0);
	}

	if(RESBIAS_BACKTRACK && LL3 < LL1){/* backtrack to original bias values */

	  ResBins[0] = startResBins;
	  for(int Bin = 0; Bin <= ResBins[0]; Bin++){
	    resbiasX[0][Bin] = startresbiasX[Bin];
	    resbias[0][Bin] = startresbias[Bin];
	  }

	  if(VERB){
	    printf("Undoing resbias changes: maxresbias=%0.6f,ResBins[0]=%d,resbiasX[0][ResBins[0]]= %0.6f,resbiasX[0][0]= %0.3f,resbias[0][0]= %0.6f\n",
		   maxresbias,ResBins[0],resbiasX[0][ResBins[0]], resbiasX[0][0], resbias[0][0]);
	    fflush(stdout);
  	  }

	  if(DEBUG/* >=2 */)
	    for(int c = 0; c < colors; c++)
	      assert(resbiasX[c][ResBins[c]] <= maxresbias);

	  /* NOTE : no need to handle -subset maps or split maps since they will not be re-aligned */
	  BiasCorrect(Gmap, 0, nummaps, 0);

	  /* recompute errors[i].x */
	  errsum3 = 0.0;
	  for(int tid = 0; tid < numthreads; tid++)
	    Tarray3[tid] = 0.0;

	  if(VERB>=2 && giter==10)
	    numthreads = 1;

	  #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	  {
	    int tid = 0;
            #ifdef _OPENMP
	    tid = omp_get_thread_num ();
            #endif

	    double myerrsum3 = 0.0;

#if !USE_MIC
            #pragma omp for schedule(static,64)
#endif
	    for(int i = 0; i < numerrors; i++){
	      if(USE_MIC && !(((i / 64) % numthreads) == tid)){ // NOTE : simulates #pragma omp for schedule(static,64)
		continue;
	      }

	      Cinterval *perr = &errors[i];
	      FLOAT *X = Gmap[perr->mapid]->site[0];
	      double x = perr->x = X[perr->R] - X[perr->L];
	      if(DEBUG>=2) assert(perr->x > 0.0);

	      if(REFDEBUG){
		double y = perr->y;
		if(ENDFIX>=3 && perr->end && y >= x){
	          if(VERB>=2 && WITH_RESBIAS && giter== -1 && perr->mapid == 43){
#if RESBIAS_DEBUG
		    printf("i=%d,tid=%d:    mapid=%d,L=%d,R=%d:x=%0.6f,y=%0.6f,end=%d : skipping since y >= x (origx=%0.6f)\n",
			   i,tid,perr->mapid,perr->L,perr->R, x, y, perr->end, perr->origx);
#else
		    printf("i=%d,tid=%d:    mapid=%d,L=%d,R=%d:x=%0.6f,y=%0.6f,end=%d : skipping since y >= x\n",
			   i,tid,perr->mapid,perr->L,perr->R, x, y, perr->end);
#endif
		    fflush(stdout);
		  }
		  continue;
		}
		double var = A + B*y;
		if(QUADRATIC_VARIANCE)
		  var += R*y*y;
		if(RES_VARIANCE)
		  var += E * perr->resvar;
		if(DEBUG>=2) assert(var > 0.0);
		double Ivar = 1.0/var;
		double err = y - x;
		if(VERB>=2 && WITH_RESBIAS && giter== -1 && perr->mapid == 43){
  	          int M = Gmap[perr->mapid]->numsite[0];
#if REFDEBUG >= 1 || RESBIAS_DEBUG	       
		  if(!(ENDFIX>=2 && perr->end))
		    printf("i=%d,tid=%d:    mapid=%d,L=%d,R=%d,end=%d:Lsum=%0.6f,errterm=%0.6f,LLsd=%0.6f,x=%0.6f,y=%0.6f (origx=%0.6f)\n",
			   i,tid,perr->mapid,perr->L,perr->R,perr->end,-0.5*(log(var) - logXtheta), -0.5*err*err*Ivar,
			   -0.5*(log(var)-logXtheta + err*err*Ivar),x,y, perr->origx);
		  else
		    printf("i=%d,tid=%d:    mapid=%d,L=%d,R=%d,end=%d:LLsd=%0.6f,x=%0.6f,y=%0.6f (origx=%0.6f), X[L]=%0.6f,X[R]=%0.6f,X[%d]=%0.6f\n",
	                   i,tid, perr->mapid,perr->L,perr->R,perr->end, -0.5*err*err*Ivar, x,y, perr->origx, X[perr->L], X[perr->R], M+1, X[M+1]);
#else
		  if(!(ENDFIX>=2 && perr->end))
		    printf("i=%d,tid=%d:    mapid=%d,L=%d,R=%d,end=%d:Lsum=%0.6f,errterm=%0.6f,LLsd=%0.6f,x=%0.6f,y=%0.6f\n",
			   i,tid,perr->mapid,perr->L,perr->R,perr->end,-0.5*(log(var) - logXtheta), -0.5*err*err*Ivar,
			   -0.5*(log(var)-logXtheta + err*err*Ivar),x,y);
		  else
		    printf("i=%d,tid=%d:    mapid=%d,L=%d,R=%d,end=%d:LLsd=%0.6f,x=%0.6f,y=%0.6f, X[L]=%0.6f,X[R]=%0.6f,X[%d]=%0.6f\n",
	                   i,tid, perr->mapid,perr->L,perr->R,perr->end, -0.5*err*err*Ivar, x,y, X[perr->L], X[perr->R], M+1, X[M+1]);
#endif
  
		  fflush(stdout);
		}
		myerrsum3 += err*err*Ivar;
	      }// REFDEBUG
	    } // for(i=0;i<numerrors;i++)
	    if(REFDEBUG)
	      Tarray3[tid] = myerrsum3;
	  } // parallel

	  if(REFDEBUG){
	    for(int tid = 0; tid < numthreads; tid++)
	      errsum3 += Tarray3[tid];
	    double LL4 = -(Lsum+errsum3)*0.5;
	    if(VERB){
	      printf("  After Undoing resbias changes: LL=%0.6f(errsum=%0.6f) (original value was LL=%0.6f)\n",LL4,errsum3,LL1);
	      for(int Bin = 0; Bin <= ResBins[0]; Bin++)
		printf("Bin=%d:resbiasX[0]=%0.3f,resbias=%0.6f\n",Bin,resbiasX[0][Bin],resbias[0][Bin]);
	      if(REFDEBUG>=3 && WITH_RESBIAS && giter == -1 && nummaps > 43){
		Cmap *Xmap = Gmap[43];
		FLOAT *X = Xmap->site[0];
		FLOAT *rawX = Xmap->rawsite[0];
		int M = Xmap->numsite[0];
		for(int I = 0; I <= M+1; I++)
		  printf("I=%d: X[I]=%0.6f, rawX[I]=%0.6f\n",
			 I, X[I], rawX[I]);
	      }
	      fflush(stdout);
	    }
	    if(DEBUG) assert(fabs(LL4 - LL1) < tcnt * 1e-6);
	  }
	}

	if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV))){/* check if logLRsum has improved */
	  if(DEBUG) assert(logLRarray);
	  (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	  double LRsum = 0.0;
	  double LRsdsum = 0.0;
	  lcnt= 0;
	  double *origLRarray = new double[nummaps];
	  double *origSDarray = new double[nummaps];
	  for(int mid = 0; mid < nummaps; mid++){
            origLRarray[mid] = logLRarray[mid];
	    origSDarray[mid] = logSDarray[mid];
          }

	  if(VERB>=2 && WITH_RESBIAS && giter== -1)/* sort alignments in ascending order of mapid2 */
	    qsort(alignment, numaligns, sizeof(Calign*), (intcmp*)CalignMapidInc);

	  for(size_t i = 0; i < numaligns; i++){
	    Calign *align = alignment[i];
	    if(DEBUG>=2) assert(align != NULL);
	    if(align->numpairs <= 1)
	      continue;
	    int mid = align->mapid2;
	    if(DEBUG)assert(!Gmap[mid]->origmap);
	    if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	      if(DEBUG) assert(BestRefExt==0.0);
	      if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	    }
	    int rid = align->mapid1;
	    if(DEBUG>=2){
	      int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	      assert(origgoodalign);
	      int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	      assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	    }
	    FLOAT *X = Gmap[mid]->site[0];
	    int M = Gmap[mid]->numsite[0];
	    FLOAT *Y = refmap[rid]->site[0];
	    int N = refmap[rid]->numsite[0];
	    double LRsd = 0.0;
	    double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
			      /* (WITH_RESBIAS && giter== -1 && mid == 43) ? 1 : 0*/  0,SDDEBUG ? &LRsd : 0,0);
	    logLRarray[mid] = LR;
	    logSDarray[mid] = LRsd;
	    if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	      continue;
	    LRsum += LR;
	    lcnt++;
	    if(SDDEBUG)
	      LRsdsum += LRsd;
	  }
	  if(SDDEBUG)
	    printf("After resbias updates:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd=%0.6f -> %0.6f)\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt, LRsdsum/lcnt);
	  else
	    printf("After resbias updates:lcnt=%llu:score=%0.6f -> %0.6f\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	  fflush(stdout);
	  if((DEBUG && !(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt)) || (VERB>=2 && giter==0)){
	    double sum1 = 0.0,sum2 = 0.0, sum3 = 0.0, sum4 = 0.0;
	    for(size_t i = 0; i < numaligns; i++){
	      Calign *align = alignment[i];
	      if(!align || align->numpairs <= 1)
		continue;
	      int mid = align->mapid2;
	      if(DEBUG)assert(!Gmap[mid]->origmap);
	      if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		if(DEBUG) assert(BestRefExt==0.0);
		continue;
	      }
	      if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		continue;
	      sum1 += origLRarray[mid];
	      sum2 += logLRarray[mid];
	      sum3 += origSDarray[mid];
	      sum4 += logSDarray[mid];
	      printf("mid=%d,id=%lld,or=%d:logLRarray[mid]=%0.6f -> %0.6f (delta=%0.6f,cum=%0.6f -> %0.6f), LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
		     mid,Gmap[mid]->id,align->orientation,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid],sum1, sum2,
		     origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4);
	    }
	    fflush(stdout);

	    assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
          }
	  if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	  logLRsum = LRsum;
	  if(SDDEBUG)
	    logLRsdsum = LRsdsum;
	  delete [] origLRarray;
	  delete [] origSDarray;
	  score_free(0,numrefmaps);
	}
	
	} // (if maxindex >= 0)

      Lnoresbias:

	delete [] SizeToBin[0]; SizeToBin[0] = 0;

      } /* if(REFDEBUG_STRICT < 2 && maxresbias > mres * 0.5) */
      
      /* Print out interval data for the very last iteration */
      if(giter == RefRepeats-1 && giter2 == RefRepeats2 - 1) {
	const size_t namelen = PATH_MAX;
	char ilf_name[namelen];
	sprintf(ilf_name, "%s_intervals.txt", output_prefix);
	if(DEBUG) assert(strlen(ilf_name) < namelen);

	if(!checkFile(ilf_name)) {
	  FILE *ilf = fopen(ilf_name, "w");
	  if(ilf == NULL){
	    int eno = errno;
	    char *err = strerror(eno);
	    fprintf(stderr,"Failed to write to file %s:errno=%d:%s\n",ilf_name,eno,err);
	    fflush(stdout);exit(1);
	  }
	  fprintf(ilf, "#interval_tag\tgiter\tx\ty\tend\tmol_length\tmol_sites\tmapid\tx0_loc\tx1_loc\tx0_site\tx1_site\n");
	  for(int i = 0; i < numerrors; i++){
	    int mapid = errors[i].mapid;
	    if(DEBUG>=2 && !errors[i].end) assert(errors[i].R <= Gmap[mapid]->numsite[0]);
	    fprintf(ilf,"interval_errors\t%d\t%g\t%g\t%d\t%g\t%d\t%d\t%g\t%g\t%d\t%d\n", giter, errors[i].x, errors[i].y,errors[i].end,
		    Gmap[mapid]->site[0][Gmap[mapid]->numsite[0]+1],Gmap[mapid]->numsite[0],mapid,
		    Gmap[mapid]->site[0][errors[i].L],Gmap[mapid]->site[0][errors[i].R],
		    errors[i].L, errors[i].R);
	  }
	  FILEclose(ilf);
	}
      }

      double C = 1.0;

      if(VERB/* HERE >=2 */){
	printf("giter=%d:Estimating sizing errors and scaling:wall time=%0.6f\n",giter,wtime());
	fflush(stdout);
      }

      if(VERB>=2 && ((!WITH_RESBIAS && giter== -1) || (WITH_RESBIAS && giter== 0)))
	qsort(alignment, numaligns, sizeof(Calign*), (intcmp*)CalignMapidInc);/* sort alignments in ascending order of mapid2 */

      if(VERB>=2 && ((!WITH_RESBIAS && giter== -1) || (WITH_RESBIAS && giter== 0))){/* sort errors[] in order of mapid,L */
	numthreads = 1;
	qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorIdInc);
      }

      /* also generate optimized scaling factor C for x : minimize MSE(x,y/C) */
      /* Note: There is a small possibility that the current alignment will become invalid if x is scaled up to overlap another site on Y.
	 The error should be small, especially if ENDFIX is used. 
	 REFDEBUG >= 2 requires special care when scaling up of maps X */
      
      double logXtheta = 2.0*log(Xtheta) - log(2.0*M_PI);/* to match terms LLsd in logLR() */

      for(int iter=0; iter < 30; iter++){

	/* Try to scale x (or C) by factor Cscale : 
	   Note that A & B & R & E will also be scaled by Cscale^2, while log(A+By+Ryy+E*resvar) - 2*log(Xtheta) is unchanged since Xtheta is also scaled by Cscale.
	   PixelLen will be scaled by Cscale (hence res,resSD are scaled by 1/Cscale, so that all Pn() terms remain the same)
	*/
	double Lsum = 0.0;/* sum of log(A+By+Ryy+E*resvar)-2*log(Xtheta) excluding cases with perr->end */
	double errsum = 0.0;/* sum of (Cx-y)^2/(A + By + Ryy + E * resvar) */
	double xysum = 0.0;/* sum of Cxy/(A + By + Ryy + E * resvar) */
	double y2sum = 0.0;/* sum of yy/(A + By + Ryy + E * resvar) */
	double Lcnt = 0.0; /* count of terms in errsum */

	Cinterval *perr = errors;

	if(AlignedSiteThreshold >= 2){/* NOTE : If REFDEBUG logLR may occasionally get worse if C > 1 due to additional FN sites overlapping with unaligned ends
					 Outliers that get reclassified due to changes in C will always provide unexpected improvement : Previous outliers are excluded and can only improve over the
					   fixed outlier score.
					   Curent non-outliers that become outliers are scored as non-outliers and can only improve by being treated as outliers.
					   This will only show up after new alignments are computed, so to guarantee improvement in logLR, limit each Cscale so cumulative C value is never greater than 1 */

	  for(int tid = 0; tid < numthreads; tid++)
	    Tarray1[tid] = Tarray2[tid] = Tarray3[tid] = Tarray4[tid] = 0.0;

	  // NOTE : non-deterministic with gcc 4.6, even if Tarray*[] are sorted by value, unless -fno-unsafe-math-optimizations is used
	  #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	  {
	    int tid = 0;
            #ifdef _OPENMP
	    tid = omp_get_thread_num ();
            #endif

	    double myLsum = 0.0;
	    double myerrsum = 0.0;
	    double myxysum = 0.0;
	    double myy2sum = 0.0;

#if !USE_MIC
            #pragma omp for schedule(static,64)
#endif
  	    for(int i = 0; i < numerrors; i++){
	      if(USE_MIC && !(((i / 64) % numthreads) == tid)) // NOTE : simulates #pragma omp for schedule(static,64)
		continue;

	      double y = perr[i].y;
	      double x = C*perr[i].x;
	      if(ENDFIX>=3 && perr[i].end && y >= x)
		continue;
	      double err = y-x;
	      if(RESBIAS_MAXERR2>=2 && err * err >= perr[i].maxerr2)
		continue;
	      double var = A + B * y;
	      if(QUADRATIC_VARIANCE)
		var += R * y*y;
	      if(RES_VARIANCE)
		var += E * perr[i].resvar;
	      if((VERB>=2 || SDDEBUG) && !(ENDFIX>=2 && perr[i].end))
		myLsum += log(var) - logXtheta;
	      double Ivar = 1.0/var;
	      myerrsum += err*err*Ivar;
	      Ivar *= y;
	      myy2sum += y*Ivar;
	      myxysum += x*Ivar;
	    }
	    
	    Tarray1[tid] = myLsum;
	    Tarray2[tid] = myerrsum;
	    Tarray3[tid] = myy2sum;
	    Tarray4[tid] = myxysum;
	  }

	  if(VERB>=2 || SDDEBUG)
	    qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray3, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray4, numthreads, sizeof(double), (intcmp *)DoubleInc);

	  for(int tid = 0; tid < numthreads; tid++){
	    if(VERB>=2 || SDDEBUG)
	      Lsum += Tarray1[tid];
	    errsum += Tarray2[tid];
	    y2sum += Tarray3[tid];
	    xysum += Tarray4[tid];
	    if(VERB>=2){
	      printf("tid=%d:errsum=%0.18f(delta=%0.18f),y2sum= %0.18f(delta=%0.18f),xysum=%0.18f(delta=%0.18f)\n",
		     tid,errsum,Tarray2[tid],y2sum,Tarray3[tid],xysum,Tarray4[tid]);
	      fflush(stdout);
	    }
	  }

	  double Cscale = y2sum/xysum;
	  if(VERB>=2){
	    printf("iter=%d:cnt=%d:LL=%0.6f,Cscale=%0.6f: C = %0.6f -> %0.6f\n",
		   iter,numerrors,-(Lsum+errsum)*0.5, Cscale,C, C*Cscale);
	    fflush(stdout);
	  }
	  if(DEBUG>=2 && (VERB>=2 || SDDEBUG) && !isfinite(-(Lsum+errsum)*0.5)){
	    printf("y2sum=%0.6f,xysum=%0.6f,Lsum=%0.6f,errsum=%0.6f\n",
		   y2sum,xysum,Lsum,errsum);
	    printf("A=%0.6f,B=%0.6f,numerrors=%d\n",A,B,numerrors);
	    fflush(stdout);
	    fflush(stdout);exit(1);
	  }
	  if(VERB && (VERB >= 2 || SDDEBUG)){
	    double delta = y2sum*(1.0-1.0/(Cscale*Cscale)) - 2.0*xysum*(1.0-1.0/Cscale);
	    printf("iter=%d:sf=%0.8f -> %0.8f,sd=%0.8f -> %0.8f,sr=%0.8f -> %0.8f,se=%0.8f -> %0.8f:y2sum=%0.8f,xysum=%0.8f,LLsd=%0.6f -> %0.6f,Cscale=%0.8f:C->%0.8f\n",
		   iter,sqrt(A),sqrt(A)*Cscale,copysign(sqrt(fabs(B)),B),copysign(sqrt(fabs(B)),B)*Cscale,sqrt(R),sqrt(R)*Cscale,sqrt(E),sqrt(E)*Cscale,
		   y2sum,xysum,-(Lsum+errsum)*0.5,-0.5*(Lsum+errsum-delta),Cscale,C*Cscale);

	    if(VERB>=2 && iter==2){/* display per molecule statistics */
	      int lastid = -1;/* current molecule id */
	      double LogSum;/* current molecule sum of log(A+By+Ryy+E*resvar) - 2 log(Xtheta) */
	      double Errsum;/* current molecule sum of (Cx-y)^2/(A+By+Ryy+E*resvar) */
	      double Y2sum;
	      double XYsum;
	      Lsum = errsum = xysum = y2sum = 0.0;/* cumulative sum */
	      for(int i = 0; i < numerrors; i++){
		double y = perr[i].y;
		double x = C*perr[i].x;
		if(ENDFIX>=3 && perr[i].end && y >= x)
		  continue;
		double err = y-x;
		if(RESBIAS_MAXERR2 >= 2 && err * err >= perr[i].maxerr2)
		  continue;
		double var = A + B * y;
		if(QUADRATIC_VARIANCE)
		  var += R * y*y;
		if(RES_VARIANCE)
		  var += E * perr[i].resvar;

		int mapid = perr[i].mapid;
		if(mapid != lastid){
		  if(lastid >= 0){/* display sums for lastid */
		    double Delta = Y2sum*(1.0-1.0/(Cscale*Cscale)) - 2.0*XYsum*(1.0-1.0/Cscale);

		    Lsum += LogSum;
		    errsum += Errsum;
		    xysum += XYsum;
		    y2sum += Y2sum;
		    double delta = y2sum*(1.0-1.0/(Cscale*Cscale)) - 2.0*xysum*(1.0-1.0/Cscale);

		    printf("  mapid=%d(id=%lld):Lsum=%0.6f,errsum=%0.6f->%0.6f,LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
			   lastid,Gmap[lastid]->id, -0.5*LogSum, -0.5*Errsum, -0.5*(Errsum-Delta), -0.5*(LogSum+Errsum), -0.5*(LogSum+Errsum-Delta), 0.5*Delta,
			   -0.5*(Lsum+errsum), -0.5*(Lsum+errsum-delta));
		  }
		  lastid = mapid;
		  LogSum = Errsum = Y2sum = XYsum = 0.0;
		}
		if(SDDEBUG && !(ENDFIX>=2 && perr[i].end))
		  LogSum += log(var) - logXtheta;
		double Ivar = 1.0/var;
		Errsum += err*err*Ivar;
		Ivar *= y;
		Y2sum += y*Ivar;
		XYsum += x*Ivar;
		if(VERB>=2 && mapid== -1){
		  double Delta = Y2sum*(1.0-1.0/(Cscale*Cscale)) - 2.0*XYsum*(1.0-1.0/Cscale);
		  double Lterm = (ENDFIX>=2 && perr[i].end && (ENDFIX<=2 || y < x)) ? 0.0 : log(var) - logXtheta;
		  double errterm = err*err/var;
		  double y2term = y*Ivar;
		  double xyterm = x*Ivar;
		  double deltaterm = y2term*(1.0-1.0/(Cscale*Cscale)) - 2.0*xyterm*(1.0-1.0/Cscale);
		  printf("mapid=%d:L=%d,R=%d:x=%0.6f,y=%0.6f,resvar=%0.6f:Lterm=%0.6f,errterm=%0.6f->%0.6f(var=%0.7f),LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f->%0.6f)\n",
			 mapid,perr[i].L,perr[i].R,x,y,perr[i].resvar,-0.5*Lterm, -0.5*errterm,-0.5*(errterm-deltaterm),var,-0.5*(Lterm+errterm), -0.5*(Lterm+errterm-deltaterm),
			 0.5*deltaterm,-0.5*(LogSum+Errsum), -0.5*(LogSum+Errsum-Delta));
		  fflush(stdout);
		}
	      }
	      if(lastid >= 0){/* display sums for lastid */
		double Delta = Y2sum*(1.0-1.0/(Cscale*Cscale)) - 2.0*XYsum*(1.0-1.0/Cscale);

		Lsum += LogSum;
		errsum += Errsum;
		xysum += XYsum;
		y2sum += Y2sum;
		double delta = y2sum*(1.0-1.0/(Cscale*Cscale)) - 2.0*xysum*(1.0-1.0/Cscale);

		printf("  mapid=%d(id=%lld):Lsum=%0.6f(cum=%0.6f),errsum=%0.6f->%0.6f,LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
		       lastid,Gmap[lastid]->id, -0.5*LogSum, -0.5*Lsum, -0.5*Errsum, -0.5*(Errsum-Delta), -0.5*(LogSum+Errsum), -0.5*(LogSum+Errsum-Delta), 0.5*Delta,
		       -0.5*(Lsum+errsum), -0.5*(Lsum+errsum-delta));
	      }
	    }

	    fflush(stdout);
	  }

	  if(DEBUG && REFDEBUG && REFDEBUG_STRICT >= 2) assert(C <= 1.0);
	  C *= Cscale;
	  if(REFDEBUG && REFDEBUG_STRICT >= 2 && C > 1.0){
	    double correction = 1.0/C;
	    C *= correction;
	    if(DEBUG) assert(Cscale > 1.0);
	    Cscale *= correction;
	    if(DEBUG) assert(Cscale >= 1.0);
	  }
	  A *= Cscale*Cscale;
	  B *= Cscale*Cscale;
	  if(QUADRATIC_VARIANCE)
	    R *= Cscale*Cscale;
	  if(RES_VARIANCE)
	    E *= Cscale*Cscale;
	  if(REFDEBUG_STRICT < 2){
	    A = min(A,Amax);
	    A = max(A,Amin);
	    B = min(B,Bmax);
	    B = max(B,Bmin);
	    R = min(R,Rmax);
	    R = max(R,Rmin);
	    E = max(E,Emin);
	    E = min(E,Emax);
	  }
	  if(DEBUG) assert(E >= 0.0);
	  if(DEBUG) assert(R >= 0.0);
	  if(DEBUG) assert(A >= 0.0);
	  if(R >= 0.0 && A >= 0.0)
	    B = max(B, -2.0*sqrt(A*R) * MINSD_MULT * MINSD_MULT);

	  if(STITCH){
	    As *= Cscale*Cscale;
	    Bs *= Cscale*Cscale;
	    if(QUADRATIC_VARIANCE)
	      Rs *= Cscale*Cscale;
	    if(RES_VARIANCE)
	      Es *= Cscale*Cscale;
	    if(REFDEBUG_STRICT < 2){
	      As = min(As,Amax);
	      As = max(As,Amin);
	      Rs = min(Rs,Rmax);
	      Rs = max(Rs,Rmin);
	      Bs = min(Bs,Bmax);
	      Bs = max(Bs,Bmin);
	      Es = max(Es,Emin);
	      Es = min(Es,Emax);
	    }
	    
	    if(DEBUG) assert(Rs >= 0.0);
	    if(DEBUG) assert(As >= 0.0);
	    if(Rs >= 0.0 && As >= 0.0)
	      Bs = max(Bs, -2.0*sqrt(As*Rs) * MINSD_MULT * MINSD_MULT);
	  }

	  if(REFDEBUG>=2 && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	    SF[0] = sqrt(A);
	    SD[0] = copysign(sqrt(fabs(B)),B);// (B < 0.0) ? -sqrt(-B) : sqrt(B);
	    SR[0] = sqrt(R);
	    SE[0] = sqrt(E);

	    if(Cscale != 1.0){ /* rescale all query map sizes by Cscale */
	      double C = Cscale;/* local value of C ! */
	      if(VERB/* HERE >=2 */){
		printf("    Rescaling all map site[] and rawsite[] values  by C=%0.12f (reflecting change in bpp)\n",C);
		fflush(stdout);
	      }

	      int origcolors = colors;
	      if(usecolor)
		colors = 2;

              #pragma omp parallel for num_threads(numthreads) schedule(dynamic,256) if(numthreads > 1)
	      for(int i= 0; i < nummaps; i++){
		Cmap *pmap = Gmap[i];
		if(DEBUG && colors>=2) assert(fabs(pmap->site[0][pmap->numsite[0]+1] - pmap->site[1][pmap->numsite[1]+1]) < 1e-3);
		for(int c = 0; c < colors; c++){
		  FLOAT *X = pmap->site[c];
		  int M = pmap->numsite[c];
		  for(int j= M+1; j > 0; j--)
		    X[j] *= C;
		}
		if(DEBUG && colors>=2) assert(fabs(pmap->site[0][pmap->numsite[0]+1] - pmap->site[1][pmap->numsite[1]+1]) < 1e-3);	    
	      }

	      if(maxresbias > mres * 0.5){/* also rescale rawsite[]. NOTE : applied to all maps including -subset maps (if -ScanScaling) and split maps */

		if(DEBUG) assert(rawsitemaps >= totalmaps);

                #pragma omp parallel for num_threads(numthreads) schedule(dynamic,256) if(numthreads > 1)
		for(int i= 0; i < totalmaps; i++){
		  Cmap *pmap = Gmap[i];
		  if(DEBUG && colors>=2) assert(fabs(pmap->rawsite[0][pmap->numsite[0]+1] - pmap->rawsite[1][pmap->numsite[1]+1]) < 1e-3);

		  for(int c = 0; c < colors; c++){
		    FLOAT *X = pmap->rawsite[c];
		    int M = pmap->numsite[c];
		    for(int j= M+1; j > 0; j--)
		      X[j] *= C;
		  }

		  if(DEBUG && colors>=2) assert(fabs(pmap->rawsite[0][pmap->numsite[0]+1] - pmap->rawsite[1][pmap->numsite[1]+1]) < 1e-3);
		}

		/* also scale resbiasX[c][] values */
		for(int c = 0; c < colors; c++){
		  for(int Bin = 0; Bin <= ResBins[c]; Bin++){
		    resbias[c][Bin] *= C;
		    resbiasX[c][Bin] *= C;
		  }
		}
		maxresbias *= C;

		if(maxresbias <= mres * 0.5)
		  maxresbias = mres * 0.5 + 1e-6;/* Fudge : should never happen */
		if(VERB>=2){
		  printf("maxresbias=%0.6f,ResBins[0]=%d,resbiasX[0][ResBins[0]]= %0.6f\n",maxresbias,ResBins[0],resbiasX[0][ResBins[0]]);
		  fflush(stdout);
		}
		if(DEBUG>=2)
		  for(int c = 0; c < colors; c++)
		    assert(resbiasX[c][ResBins[c]] <= maxresbias);
	      }

	      colors = origcolors;

	      double InvC = 1.0/C;
	      for(int i = 0; i < nummaps; i++)
		Gmap[i]->incscale *= InvC;
	      PixelLen *= C;
	      FP[0] *= InvC;
	      Xtheta *= C;
	      res[0] *= InvC;
	      resSD[0] *= InvC;

	      if(REFDEBUG_STRICT < 2){
		FP[0] = max(FP[0],MINFP);
		FP[0] = min(FP[0],MAXFP);
                res[0] = max(res[0],MinRes);
                res[0] = min(res[0],MaxRes);
                resSD[0] = max(resSD[0],MinResSD);
                resSD[0] = min(resSD[0],MaxResSD);
	      }
	    }

	    if(DEBUG) assert(logLRarray);
	    if(DEBUG) assert(colors==1);
	    (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	    double LRsum = 0.0;
	    double LRsdsum = 0.0;
	    lcnt= 0;
	    double *origLRarray = new double[nummaps];
	    double *origSDarray = new double[nummaps];
	    for(int mid = 0; mid < nummaps; mid++){
	      origLRarray[mid] = logLRarray[mid];
	      origSDarray[mid] = logSDarray[mid];
	    }
	    for(size_t i = 0; i < numaligns; i++){
	      Calign *align = alignment[i];
	      if(!align || align->numpairs <= 1)
		continue;
	      int mid = align->mapid2;
	      if(DEBUG)assert(!Gmap[mid]->origmap);
	      if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		if(DEBUG) assert(BestRefExt==0.0);
		if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
		continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	      }
	      int rid = align->mapid1;
	      if(DEBUG>=2){
		int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
		assert(origgoodalign);
		int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
		assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	      }
	      FLOAT *X = Gmap[mid]->site[0];
	      int M = Gmap[mid]->numsite[0];
	      FLOAT *Y = refmap[rid]->site[0];
	      int N = refmap[rid]->numsite[0];
	      double LRsd = 0.0;
	      double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2, 1,0,SDDEBUG ? &LRsd : 0,0);
	      logLRarray[mid] = LR;
	      logSDarray[mid] = LRsd;
	      if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		continue;
	      LRsum += LR;
	      lcnt++;
	      if(SDDEBUG)
		LRsdsum += LRsd;
	    }
	    if(SDDEBUG)
	      printf("iter=%d:After rescaling Xmaps by %0.12f:lcnt=%llu:score=%0.6f -> %0.6f (logLRsd= %0.6f -> %0.6f)\n",
		  iter,Cscale,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt,logLRsdsum/lcnt,LRsdsum/lcnt);
	    else
	      printf("iter=%d:After rescaling Xmaps by %0.12f:lcnt=%llu:score=%0.6f -> %0.6f\n",iter,Cscale,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	    fflush(stdout);
	    if((DEBUG && !(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt)) || (VERB>=2 && iter==2)){
	      double sum1 = 0.0,sum2 = 0.0, sum3 = 0.0, sum4 = 0.0;
	      for(size_t i = 0; i < numaligns; i++){
		Calign *align = alignment[i];
		if(!align || align->numpairs <= 1)
		  continue;
		int mid = align->mapid2;
		if(DEBUG)assert(!Gmap[mid]->origmap);
		if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		  if(DEBUG) assert(BestRefExt==0.0);
		  continue;
		}
		if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		  continue;
		sum1 += origLRarray[mid];
		sum2 += logLRarray[mid];
		sum3 += origSDarray[mid];
		sum4 += logSDarray[mid];
		printf("i=%lu/%lu:mid=%d,id=%lld:logLRarray[mid]=%0.6f -> %0.6f (delta=%0.6f,cum=%0.6f -> %0.6f), LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
		       i,numaligns,mid,Gmap[mid]->id,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid],sum1, sum2,
		       origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4);
	      }
	      fflush(stdout);
	      
	      assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	    }
	    if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	    logLRsum = LRsum;
	    if(SDDEBUG)
	      logLRsdsum = LRsdsum;
	    delete [] origLRarray;
	    delete [] origSDarray;
	    score_free(0,numrefmaps);
          }
	}// if(AlignedSiteThreshold >=2)

	/* Try to scale A, B, R and E by the same factor (errsum/Lcnt) */
	Lsum = 0.0;
	errsum = 0.0;
	Lcnt = 0.0;

	perr = errors;

	for(int tid = 0; tid < numthreads; tid++)
	  Tarray1[tid] = Tarray2[tid] = Tarray3[tid] = 0.0;

        // NOTE : non-deterministic with gcc 4.6, even if Tarray*[] are sorted by value, unless -fno-unsafe-math-optimizations is used
	#pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	{
	  int tid = 0;
          #ifdef _OPENMP
	  tid = omp_get_thread_num ();
          #endif

	  double myLsum = 0.0;
	  double myLcnt = 0.0;
	  double myerrsum = 0.0;
	  
#if !USE_MIC
          #pragma omp for schedule(static,64)
#endif
	  for(int i = 0; i < numerrors; i++){
	    if(USE_MIC && !(((i / 64) % numthreads) == tid)) // NOTE : simulates #pragma omp for schedule(static,64)
	      continue;

	    double y = perr[i].y;
	    double x = C * perr[i].x;
	    if(ENDFIX>=3 && perr[i].end && y >= x)
	      continue;
	    double err = y - x;
	    if(RESBIAS_MAXERR2 >= 2 && err * err >= perr[i].maxerr2)
	      continue;
	    double var = A + B * y;
	    if(QUADRATIC_VARIANCE)
	      var += R * y*y;
	    if(RES_VARIANCE)
	      var += E * perr[i].resvar;
	    if(!(ENDFIX>=2 && perr[i].end)){
	      if(VERB>=2 || SDDEBUG){
		myLsum += log(var);
		if(SDDEBUG)
		  myLsum -= logXtheta;
	      }
	      myLcnt += 1.0;
	    }
	    myerrsum += err*err/var;
	    if(VERB>=2 && iter <= 0){
	      printf("iter=%d:i=%d/%d: mapid=%d,L=%d,R=%d,end=%d:x=%0.4f,y=%0.4f,resvar=%0.6e,var=%0.6e,norm=%0.6f: errsum=%0.6f, Lcnt=%0.6f (cum norm=%0.6f)\n",
		     iter,i,numerrors,perr[i].mapid,perr[i].L,perr[i].R,perr[i].end,x,y,perr[i].resvar,var,err*err/var,myerrsum,myLcnt,myerrsum/max(0.001,myLcnt));
	      fflush(stdout);
	    }
	  }

	  if(VERB>=2 || SDDEBUG)
	    Tarray1[tid] = myLsum;
	  Tarray2[tid] = myLcnt;
	  Tarray3[tid] = myerrsum;
	}
	if(VERB>=2 || SDDEBUG)
	  qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
	qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);
	qsort(Tarray3, numthreads, sizeof(double), (intcmp *)DoubleInc);
	for(int tid = 0; tid < numthreads; tid++){
	  if(VERB>=2 || SDDEBUG)
	    Lsum += Tarray1[tid];
	  Lcnt += Tarray2[tid];
	  errsum += Tarray3[tid];
	}

	double delta = errsum/Lcnt;
	if(VERB && (VERB >= 2 || SDDEBUG)){
	  printf("iter=%d:Lcnt=%0.1f/%d:sf=%0.18f,sd=%0.18f,sr=%0.18f:LL=%0.18f,norm=%0.18f:sf->%0.8f,sd->%0.8f,sr->%0.8f,se->%0.8f\n",
	  iter,Lcnt,numerrors,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R),-(Lsum+errsum)*0.5,delta,sqrt(A*delta),copysign(sqrt(fabs(B*delta)),B),sqrt(R*delta),sqrt(E*delta));
	  fflush(stdout);
	}
	A *= delta;
	B *= delta;
	if(QUADRATIC_VARIANCE)
	  R *= delta;
	if(RES_VARIANCE)
	  E *= delta;
	if(REFDEBUG_STRICT < 2){
	  A = min(A,Amax);
	  A = max(A,Amin);
	  B = min(B,Bmax);
	  B = max(B,Bmin);
	  R = min(R,Rmax);
	  R = max(R,Rmin);
	  E = min(E,Emax);
	  E = max(E,Emin);
	}

	if(DEBUG) assert(E >= 0.0);
	if(DEBUG) assert(R >= 0.0);
	if(DEBUG) assert(A >= 0.0);
	if(QUADRATIC_VARIANCE && R >= 0.0 && A >= 0.0)
	  B = max(B, -2.0*sqrt(A*R) * MINSD_MULT * MINSD_MULT);

	if(REFDEBUG>=2 && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	  SF[0] = sqrt(A);
	  SD[0] = copysign(sqrt(fabs(B)),B);// (B < 0.0) ? -sqrt(-B) : sqrt(B);
	  SR[0] = sqrt(R);
	  SE[0] = sqrt(E);

	  if(DEBUG) assert(logLRarray);
	  (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	  double LRsum = 0.0;
	  double LRsdsum = 0.0;
	  lcnt= 0;
	  for(size_t i = 0; i < numaligns; i++){
	    Calign *align = alignment[i];
	    if(!align || align->numpairs <= 1)
	      continue;
	    int mid = align->mapid2;
	    if(DEBUG)assert(!Gmap[mid]->origmap);
	    if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	      if(DEBUG) assert(BestRefExt==0.0);
	      if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	    }
	    int rid = align->mapid1;
	    if(DEBUG>=2){
	      int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	      assert(origgoodalign);
	      int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	      assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	    }
	    FLOAT *X = Gmap[mid]->site[0];
	    int M = Gmap[mid]->numsite[0];
	    FLOAT *Y = refmap[rid]->site[0];
	    int N = refmap[rid]->numsite[0];
	    double LRsd = 0.0;
            double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,0,SDDEBUG ? &LRsd : 0,0);
	    logLRarray[mid] = LR;
            logSDarray[mid] = LRsd;
	    if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	      continue;
	    LRsum += LR;
	    lcnt++;
	    if(SDDEBUG)
	      LRsdsum += LRsd;
	  }
          if(SDDEBUG)
	    printf("iter=%d:After rescaling SF,SD,SR,SE:lcnt=%llu:score=%0.6f -> %0.6f (logLRsd= %0.6f -> %0.6f)\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt,logLRsdsum/lcnt,LRsdsum/lcnt);
          else
	    printf("iter=%d:After rescaling SF,SD,SR,SE:lcnt=%llu:score=%0.6f -> %0.6f\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	  fflush(stdout);
	  if(DEBUG) assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	  if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	  logLRsum = LRsum;
	  if(SDDEBUG)
	    logLRsdsum = LRsdsum;
	  score_free(0,numrefmaps);
	} // if(REFDEBUG>=2 ... )

	if(STITCH && stitchcnt > 0){
	  /* Try to scale As, Bs and Rs by the same factor */
	  Lsum = 0.0;
	  errsum = 0.0;
	  perr = errors;
	  Lcnt = 0.0;
	  for(int i = 0; i < numerrors; i++, perr++){
	    if(!perr->stitch)
	      continue;
	    double y = perr->y + Ms * perr->stitch;
	    double x = C * perr->x;
	    if(ENDFIX>=3 && perr->end && y >= x)
	      continue;
	    double err = y - x;
	    if(RESBIAS_MAXERR2 >= 2 && err * err >= perr->maxerr2)
	      continue;
	    double var = As + Bs * y;
	    if(QUADRATIC_VARIANCE)
	      var += Rs * y*y;
	    if(RES_VARIANCE)
	      var += Es * perr->resvar;
	    if(!(ENDFIX>=2 && perr->end)){
	      if(VERB >= 2 || SDDEBUG)
		Lsum += log(var);
	      Lcnt += 1.0;
	    }
	    errsum += err*err/var;
	  }
	  double delta = errsum/Lcnt;
	  if(VERB && (VERB >= 2 || SDDEBUG)){
	    printf("iter=%d:Stitched Intervals:Lcnt=%0.1f/%d:sf=%0.8f,sd=%0.8f,sr=%0.8f:LL=%0.8f,norm=%0.8f:sf->%0.8f,sd->%0.8f,sr->%0.8f,se->%0.8f\n",
	       iter,Lcnt,numerrors,sqrt(As),copysign(sqrt(fabs(Bs)),Bs),sqrt(Rs),-(Lsum+errsum)*0.5,delta,sqrt(As*delta),copysign(sqrt(fabs(Bs*delta)),Bs),sqrt(Rs*delta),sqrt(Es*delta));
	    fflush(stdout);
	  }
	  As *= delta;
	  Bs *= delta;
	  if(QUADRATIC_VARIANCE)
	    Rs *= delta;
	  if(RES_VARIANCE)
	    Es *= delta;

          if(REFDEBUG_STRICT < 2){
	    As = min(As,Amax);
	    As = max(As,Amin);
	    Bs = min(Bs,Bmax);
	    Bs = max(Bs,Bmin);
	    Rs = min(Rs,Rmax);
	    Rs = max(Rs,Rmin);
	    Es = min(Es,Emax);
	    Es = max(Es,Emin);
	  }

	  if(DEBUG) assert(Rs >= 0.0);
	  if(DEBUG) assert(As >= 0.0);
	  if(QUADRATIC_VARIANCE && Rs >= 0.0 && As >= 0.0)
	    Bs = max(Bs, -2.0*sqrt(As*Rs) * MINSD_MULT * MINSD_MULT);

	  /* update Ms */
	  Lcnt = 0.0;
	  Lsum = 0.0;
	  errsum = 0.0;
	  perr = errors;
	  double Ivarsum = 0.0;
	  double Serrsum = 0.0;
	  for(int i = 0; i < numerrors; i++, perr++){
	    if(!perr->stitch)
	      continue;
	    double y = perr->y;
	    double x = C * perr->x;
	    if(ENDFIX>=3 && perr->end && y >= x)
	      continue;
	    double err = x - y;
	    if(RESBIAS_MAXERR2 >= 2 && err * err >= perr->maxerr2)
	      continue;
	    double var = As + Bs * y;
	    if(QUADRATIC_VARIANCE)
	      var += Rs * y*y;
	    if(RES_VARIANCE)
	      var += Es * perr->resvar;
	    double Ivar = 1.0/var;
	    Serrsum += perr->stitch * err * Ivar;
	    Ivarsum += Ivar;
	    if(!(ENDFIX>=2 && perr->end) && (VERB>=2 || SDDEBUG)){
	      Lcnt += 1.0;
	      Lsum += log(var);
	      double terr = err - Ms * perr->stitch;
	      errsum += terr*terr*Ivar;
	    }
	  }
	  if(Ivarsum > 0.0){
	    double oldMs = Ms;
	    Ms = Serrsum / Ivarsum;
	    if(VERB && (VERB>=2 || SDDEBUG)){
	      Cinterval *perr = errors;

	      double Lcnt2 = 0.0;
	      double Lsum2 = 0.0;/* sum of log(A+By+Ryy+E*resvar) */
	      double errsum2 = 0.0;/* sum of (Cx-y-M*s)^2/(A+By+Ryy+E*resvar) */
	      for(int i = 0; i < numerrors; i++, perr++){
		if(!perr->stitch)
		  continue;
		double y = perr->y;
		double x = C * perr->x;
		if(ENDFIX>=3 && perr->end && y >= x)
		  continue;
		double err = x - y;
		if(RESBIAS_MAXERR2 >= 2 && err * err >= perr->maxerr2)
		  continue;
		double var = As + Bs * y;
		if(QUADRATIC_VARIANCE)
		  var += Rs * y*y;
		if(RES_VARIANCE)
		  var += Es * perr->resvar;
		double Ivar = 1.0/var;
		if(!(ENDFIX>=2 && perr->end)){
		  Lcnt2 += 1.0;
		  Lsum2 += log(var);
		}
		double terr = (err - Ms*perr->stitch);
		errsum2 += terr*terr*Ivar;
	      }
	      printf("iter=%d:Stitched Intervals:Serrsum=%0.6f,Ivarsum=%0.6f,cnt=%0.1f,LL=%0.6f->%0.6f:Ms=%0.4f -> %0.4f\n",
		     iter,Serrsum,Ivarsum,Lcnt,-(Lsum+errsum)*0.5,-(Lsum2+errsum2)*0.5,oldMs,Ms);
	      fflush(stdout);
	    }
	  }
	} /* stitchcnt > 0 */

	/* update estimate of A (seperately from B,R,E) (3 iterations with delta = -f'/f'') */
	double bestLL = MINSCORE;
	double bestA = A;

	int AiterMax = 3;
	for(int Aiter = 0; Aiter < AiterMax; Aiter++){
	  double Lsum = 0.0;/* sum of log(A+By+Ryy+E*resvar) */
	  double Isum = 0.0;/* sum of 1/(A+By+Ryy+E*resvar) */
	  double Isum2 = 0.0;/* sum of 1/(A+By+Ryy+E*resvar)^2 */
	  double errsum = 0.0;/* sum of (Cx-y)^2/(A+By+Ryy+E*resvar) */
	  double errsum2 = 0.0;/* sum of (Cx-y)^2/(A+By+Ryy+E*resvar)^2 */
	  double errsum3 = 0.0;/* sum of (Cx-y)^2/(A+By+Ryy+E*resvar)^3 */

	  Cinterval *perr = errors;

	  for(int tid = 0; tid < numthreads; tid++)
	    Tarray1[tid] = Tarray2[tid] = Tarray3[tid] = Tarray4[tid] = Tarray5[tid] = Tarray6[tid] = 0.0;

          // NOTE : non-deterministic with gcc 4.6, even if Tarray*[] are sorted by value, unless -fno-unsafe-math-optimizations is used
	  #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	  {
	    int tid = 0;
            #ifdef _OPENMP
	    tid = omp_get_thread_num ();
            #endif

	    double myLsum = 0.0;
	    double myIsum = 0.0;
	    double myIsum2 = 0.0;
	    double myerrsum = 0.0;
	    double myerrsum2 = 0.0;
	    double myerrsum3 = 0.0;

#if !USE_MIC
            #pragma omp for schedule(static,64)
#endif
	    for(int i = 0;i < numerrors;i++){
	      if(USE_MIC && !(((i / 64) % numthreads) == tid)) // NOTE : simulates #pragma omp for schedule(static,64)
		continue;

	      double y = perr[i].y;
	      double x = C*perr[i].x;
	      if(ENDFIX>=3 && perr[i].end && y >= x)
		continue;
	      double err = y - x;
	      err *= err;

	      if(RESBIAS_MAXERR2 >= 2 && err  >= perr[i].maxerr2)
		continue;

	      double var = A + B * y;
	      if(QUADRATIC_VARIANCE)
		var += R * y*y;
	      if(RES_VARIANCE)
		var += E * perr[i].resvar;

	      double Ivar = 1.0/var;
	      double Ivar2 = Ivar*Ivar;

	      if(!(ENDFIX>=2 && perr[i].end)){
		myLsum += log(var);
		myIsum += Ivar;
		myIsum2 += Ivar2;
	      }

	      myerrsum += err * Ivar;
	      myerrsum2 += err*Ivar2;
	      myerrsum3 += err*Ivar2*Ivar; 	      
	      if(DEBUG>=2) assert(isfinite(myerrsum3) && myerrsum3 >= 0.0);
	    }
	    
	    Tarray1[tid] = myLsum;
	    Tarray2[tid] = myIsum;
	    Tarray3[tid] = myIsum2;
	    Tarray4[tid] = myerrsum;
	    Tarray5[tid] = myerrsum2;
	    Tarray6[tid] = myerrsum3;
	  }
	  qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray3, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray4, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray5, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray6, numthreads, sizeof(double), (intcmp *)DoubleInc);

	  for(int tid = 0; tid < numthreads; tid++){
	    Lsum += Tarray1[tid];
	    Isum += Tarray2[tid];
	    Isum2 += Tarray3[tid];
	    errsum += Tarray4[tid];
	    errsum2 += Tarray5[tid];
	    errsum3 += Tarray6[tid];
	  }

	  double LL = -(Lsum+errsum)*0.5;
	  double LL1 = 0.5*(errsum2-Isum);
	  double LL2 = 0.5*Isum2-errsum3;
	  if(LL < bestLL){
	    if(VERB && (VERB >= 2 || SDDEBUG)){
	      printf("iter=%d,%d,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f:LL=%0.8f,LL1=%0.8f,LL2=%0.8f:bestLL=%0.8f,backtracking (sf->%0.8f)\n",
		     Aiter,iter,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R),sqrt(E),LL, LL1, LL2, bestLL,sqrt(0.5*(A+bestA)));
	      fflush(stdout);
	    }
	    A = (A+bestA)*0.5;
	    if(LL < bestLL - 1e-6 && fabs(A-bestA) > 1e-6)
	      Aiter--;/* add an iteration if drop is LL was significant */
	    continue;
	  }
	  bestA = A;
	  bestLL = LL;

	  double maxdelta = Amax * 0.5;
	  double delta = (LL2 < 0.0) ? min(maxdelta,fabs(LL1/LL2)) : maxdelta;
	  delta = copysign(delta,LL1);
	  if(A + delta < 0.0)
	    delta = -A;

	  if(VERB && (VERB >= 2 || SDDEBUG)){
	    printf("iter=%d,%d,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f:LL=%0.8f,LL1=%0.8f,LL2=%0.8f:delta=%0.8f(sf->%0.8f)\n",
	      Aiter,iter,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R),sqrt(E),LL, LL1, LL2, delta,sqrt(A+delta));
	    fflush(stdout);
	  }

	  if(fabs(delta) < 1e-10)
	    break;

	  A += delta;
	  if(REFDEBUG_STRICT < 2){
	    A = min(A,Amax);
	    A = max(A,Amin);
	  }
	  if(QUADRATIC_VARIANCE){
	    if(DEBUG) assert(R >= 0.0);
	    if(B < 0.0 && R >= 0.0)
	      A = max(A, B*B/(4.0*R * pow(MINSD_MULT,4.0)));
	  }
	} /* Aiter = 0..2 */

	A = bestA;

	if(REFDEBUG>=2 && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	  SF[0] = sqrt(A);
	  SD[0] = copysign(sqrt(fabs(B)),B);
	  SR[0] = sqrt(R);
	  SE[0] = sqrt(E);

	  if(DEBUG) assert(logLRarray);
	  (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	  double LRsum = 0.0;
	  double LRsdsum = 0.0;
	  lcnt= 0;
	  for(size_t i = 0; i < numaligns; i++){
	    Calign *align = alignment[i];
	    if(!align || align->numpairs <= 1)
	      continue;
	    int mid = align->mapid2;
	    if(DEBUG)assert(!Gmap[mid]->origmap);
	    if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	      if(DEBUG) assert(BestRefExt==0.0);
	      if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	    }
	    int rid = align->mapid1;
	    if(DEBUG>=2){
	      int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	      assert(origgoodalign);
	      int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	      assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	    }
	    FLOAT *X = Gmap[mid]->site[0];
	    int M = Gmap[mid]->numsite[0];
	    FLOAT *Y = refmap[rid]->site[0];
	    int N = refmap[rid]->numsite[0];
	    double LRsd = 0.0;
	    double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
			      /* (REFDEBUG>=2 && giter==0 && iter==0 && mid==3127) ? 1 : 0 */ 0, SDDEBUG ? &LRsd : 0,0);
	    logLRarray[mid] = LR;
	    logSDarray[mid] = LRsd;
	    if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	      continue;
	    LRsum += LR;
	    lcnt++;
	    if(SDDEBUG)
	      LRsdsum += LRsd;
	  }
	  if(SDDEBUG)
	    printf("iter=%d:After updating SF:lcnt=%llu:score=%0.6f -> %0.6f (logLRsd= %0.6f -> %0.6f)\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt,LRsdsum/lcnt);
	  else
	    printf("iter=%d:After updating SF:lcnt=%llu:score=%0.6f -> %0.6f\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	  fflush(stdout);
	  if(DEBUG) assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	  if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	  logLRsum = LRsum;
	  if(SDDEBUG)
	    logLRsdsum = LRsdsum;
	  score_free(0,numrefmaps);
        } // if(REFDEBUG>=2 ... )

	if(QUADRATIC_VARIANCE && MAXSR > MINSR) { /* update estimate of R (seperately from A , B & E) (3 iterations with delta = -f'/f'') */
	  bestLL = MINSCORE;
	  double bestR = R;
	  for(int Riter = 0; Riter < 3; Riter++){
	    double Lsum = 0.0;/* sum of log(A+By+Ryy+E*resvar) */
	    double Isum = 0.0;/* sum of yy/(A+By+Ryy+E*resvar) */
	    double Isum2 = 0.0;/* sum of yyyy/(A+By+Ryy+E*resvar)^2 */
	    double errsum = 0.0;/* sum of (Cx-y)^2/(A+By+Ryy+E*resvar) */
	    double errsum2 = 0.0;/* sum of yy (Cx-y)^2/(A+By+Ryy+E*resvar)^2 */
	    double errsum3 = 0.0;/* sum of yyyy (Cx-y)^2/(A+By+Ryy+E*resvar)^3 */
	    Cinterval *perr = errors;
	    double logXtheta = 2.0*log(Xtheta) - log(2.0*M_PI);/* to match terms LLsd in logLR() */

	    for(int tid = 0; tid < numthreads; tid++)
	      Tarray1[tid] = Tarray2[tid] = Tarray3[tid] = Tarray4[tid] = Tarray5[tid] = Tarray6[tid] = 0.0;

	    // NOTE : non-deterministic with gcc 4.6, even if Tarray*[] are sorted by value, unless -fno-unsafe-math-optimizations is used
	    #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	    {
	      int tid = 0;
              #ifdef _OPENMP
	      tid = omp_get_thread_num ();
              #endif

	      double myLsum = 0.0;
	      double myIsum = 0.0;
	      double myIsum2 = 0.0;
	      double myerrsum = 0.0;
	      double myerrsum2 = 0.0;
	      double myerrsum3 = 0.0;

#if !USE_MIC
              #pragma omp for schedule(static,64)
#endif
	      for(int i = 0;i < numerrors;i++){
	        if(USE_MIC && !(((i / 64) % numthreads) == tid)) // NOTE : simulates #pragma omp for schedule(static,64)
		  continue;

		double y = perr[i].y;
		double x = C*perr[i].x;
		if(ENDFIX>=3 && perr[i].end && y >= x)
		  continue;
		double err = y - x;
		err *= err;
		if(RESBIAS_MAXERR2 >= 2 && err  >= perr[i].maxerr2)
		  continue;

		double var = A + B * y;
		if(QUADRATIC_VARIANCE)
		  var += R * y*y;
		if(RES_VARIANCE)
		  var += E * perr[i].resvar;
		double Ivar = 1.0/var;
		double yIvar = y*y*Ivar;
		double yIvar2 = yIvar*yIvar;

		if(!(ENDFIX>=2 && perr[i].end)){
		  myLsum += log(var);
		  if(SDDEBUG) myLsum -= logXtheta;
		  myIsum += yIvar;
		  myIsum2 += yIvar2;
		}

		myerrsum += err *= Ivar;
		myerrsum2 += err * yIvar;
		myerrsum3 += err * yIvar2;
	      }
	    
	      Tarray1[tid] = myLsum;
	      Tarray2[tid] = myIsum;
	      Tarray3[tid] = myIsum2;
	      Tarray4[tid] = myerrsum;
	      Tarray5[tid] = myerrsum2;
	      Tarray6[tid] = myerrsum3;
	    }
	    qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray3, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray4, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray5, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray6, numthreads, sizeof(double), (intcmp *)DoubleInc);

	    for(int tid = 0; tid < numthreads; tid++){
	      Lsum += Tarray1[tid];
	      Isum += Tarray2[tid];
	      Isum2 += Tarray3[tid];
	      errsum += Tarray4[tid];
	      errsum2 += Tarray5[tid];
	      errsum3 += Tarray6[tid];
	    }

	    double LL = -(Lsum+errsum)*0.5;
	    double LL1 = 0.5*(errsum2-Isum);
	    double LL2 = 0.5*Isum2-errsum3;
	    if(LL < bestLL){
	      if(VERB && (VERB >= 2 || SDDEBUG)){
		printf("iter=%d,%d,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f:LL=%0.8f,LL1=%0.8f,LL2=%0.8f:backtracking (sr->%0.8f)\n",
		       Riter,iter,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R), sqrt(E),LL, LL1, LL2, sqrt(0.5*(R+bestR)));
		fflush(stdout);
	      }
	      R = (R+bestR)*0.5;
	      if(LL < bestLL - 1e-6 && fabs(R-bestR) > 1e-6)
		Riter--;/* add an iteration of drop is LL was significant */
	      continue;
	    }
	    bestR = R;
	    bestLL = LL;

	    double maxdelta = Rmax * 0.5;
	    double delta = (LL2 < 0.0) ? min(maxdelta,fabs(LL1/LL2)) : maxdelta;
	    delta = copysign(delta,LL1);
	    if(R + delta < Rmin)
	      delta = Rmin - R;
	    if(VERB && (VERB >= 2 || SDDEBUG)){
	      printf("iter=%d,%d,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f:LL=%0.8f,LL1=%0.8f,LL2=%0.8f:delta=%0.8f(sr->%0.8f)\n",
		     Riter,iter,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R),sqrt(E),LL, LL1, LL2, delta,sqrt(R+delta));
	      fflush(stdout);
	    }

	    R += delta;
	    if(REFDEBUG_STRICT < 2){
	      R = min(R,Rmax);
	      R = max(R,Rmin);
	    }
	    if(DEBUG) assert(A >= 0.0);
	    if(B < 0.0 && A >= 0.0)
	      R = max(R, B*B/(4.0*A * pow(MINSD_MULT, 4.0)));
	  } /* Riter = 0..2 */
	  R = bestR;

	  if(REFDEBUG>=2 && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	    SF[0] = sqrt(A);
	    SD[0] = (B < 0.0) ? -sqrt(-B) : sqrt(B);
	    SR[0] = sqrt(R);
	    SE[0] = sqrt(E);

	    if(DEBUG) assert(logLRarray);
	    (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	    double LRsum = 0.0;
	    double LRsdsum = 0.0;
	    lcnt= 0;
	    double *origLRarray = new double[nummaps];
	    double *origSDarray = new double[nummaps];
	    for(int mid = 0; mid < nummaps; mid++){
	      origLRarray[mid] = logLRarray[mid];
	      origSDarray[mid] = logSDarray[mid];
	    }
	    for(size_t i = 0; i < numaligns; i++){
	      Calign *align = alignment[i];
	      if(!align || align->numpairs <= 1)
		continue;
	      int mid = align->mapid2;
	      if(DEBUG)assert(!Gmap[mid]->origmap);
	      if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		if(DEBUG) assert(BestRefExt==0.0);
		if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
		continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	      }
	      int rid = align->mapid1;
	      if(DEBUG>=2){
		int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
		assert(origgoodalign);
		int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
		assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	      }
	      FLOAT *X = Gmap[mid]->site[0];
	      int M = Gmap[mid]->numsite[0];
	      FLOAT *Y = refmap[rid]->site[0];
	      int N = refmap[rid]->numsite[0];
	      double LRsd = 0.0;
	      double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
				/* (REFDEBUG>=2 && giter==0 && iter==18 && mid <= 2) ? 1 : 0  */ 0, SDDEBUG ? &LRsd : 0,0);
	      logLRarray[mid] = LR;
	      logSDarray[mid] = LRsd;
	      if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		continue;
	      LRsum += LR;
	      lcnt++;
	      if(SDDEBUG)
		LRsdsum += LRsd;
	      if(VERB>=2 && SDDEBUG && iter==18){
		printf("rid=%d,mid=%d,or=%d:LR=%0.8f(cum=%0.8f),LRsd=%0.8f(cum=%0.8f)\n",rid,mid,align->orientation,LR,LRsum,LRsd,LRsdsum);
		fflush(stdout);
	      }
	    }
	    if(SDDEBUG)
	      printf("iter=%d:After updating SR:lcnt=%llu:score=%0.6f -> %0.6f (logLRsd= %0.6f -> %0.6f)\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt,logLRsdsum/lcnt,LRsdsum/lcnt);
	    else
	      printf("iter=%d:After updating SR:lcnt=%llu:score=%0.6f -> %0.6f\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	    fflush(stdout);
	    if(DEBUG && !(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt)){
	      if(VERB){
		double sum1 = 0.0,sum2 = 0.0, sum3 = 0.0, sum4 = 0.0;
		for(size_t i = 0; i < numaligns; i++){
		  Calign *align = alignment[i];
		  if(!align || align->numpairs <= 1)
		    continue;
		  int mid = align->mapid2;
		  if(DEBUG)assert(!Gmap[mid]->origmap);
		  if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		    if(DEBUG) assert(BestRefExt==0.0);
		    continue;
		  }
		  if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		    continue;
		  sum1 += origLRarray[mid];
		  sum2 += logLRarray[mid];
		  sum3 += origSDarray[mid];
		  sum4 += logSDarray[mid];
		  printf("i=%lu/%lu:mid=%d,id=%lld:logLRarray[mid]=%0.6f -> %0.6f (delta=%0.6f),cum=%0.6f -> %0.6f(delta=%0.6f), LLsd=%0.6f -> %0.6f(delta=%0.6f),cum=%0.6f -> %0.6f(delta=%0.6f)\n",
			 i,numaligns,mid,Gmap[mid]->id,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid], sum1, sum2, sum2-sum1,
			 origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4,sum4-sum3);
		}
		if(SDDEBUG)
		  printf("giter=%d,iter=%d:After updating SR:lcnt=%llu,logLR=%0.6f -> %0.6f (logLRsd= %0.6f -> %0.6f),numthreads=%d\n",
			 giter,iter,(unsigned long long)lcnt,logLRsum,LRsum,logLRsdsum, LRsdsum,numthreads);
		else
		  printf("giter=%d,iter=%d:After updating SR:lcnt=%llu,logLR=%0.6f -> %0.6f\n",
			 giter,iter,(unsigned long long)lcnt,logLRsum,LRsum);
		fflush(stdout);
	      }
	      assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	    }
	    if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	    logLRsum = LRsum;
	    if(SDDEBUG)
	      logLRsdsum = LRsdsum;
	    delete [] origLRarray;
	    delete [] origSDarray;
	    score_free(0,numrefmaps);
	  }

	} // if(QUADRATIC_VARIANCE >= 1 && MAXSR > MINSR)

	/* update estimate of B (separately from A , R & E) (3 iterations with delta = -f'/f'') */
	bestLL = MINSCORE;
	double bestB = B;
	for(int Biter = 0; Biter < 3; Biter++){
	  double Lsum = 0.0;/* sum of log(A+By+Ryy+E*resvar) */
	  double Isum = 0.0;/* sum of y/(A+By+Ryy+E*resvar) */
	  double Isum2 = 0.0;/* sum of yy/(A+By+Ryy+E*resvar)^2 */
	  double errsum = 0.0;/* sum of (Cx-y)^2/(A+By+Ryy+E*resvar) */
	  double errsum2 = 0.0;/* sum of y (Cx-y)^2/(A+By+Ryy+E*resvar)^2 */
	  double errsum3 = 0.0;/* sum of yy (Cx-y)^2/(A+By+Ryy+E*resvar)^3 */
	  Cinterval *perr = errors;
	  double logXtheta = 2.0*log(Xtheta) - log(2.0*M_PI);/* to match terms LLsd in logLR() */

	  for(int tid = 0; tid < numthreads; tid++)
	    Tarray1[tid] = Tarray2[tid] = Tarray3[tid] = Tarray4[tid] = Tarray5[tid] = Tarray6[tid] = 0.0;

	  if(VERB>=2 && iter==18){
	    printf("iter=%d,%d:sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f,numerrors=%d\n",Biter,iter,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R),sqrt(E),numerrors);
	    fflush(stdout);
	  }

          // NOTE : non-deterministic with gcc 4.6, even if Tarray*[] are sorted by value, unless -fno-unsafe-math-optimizations is used
	  #pragma omp parallel num_threads(numthreads) if(numthreads > 1 /* && !(SDDEBUG && iter==18) */)
	  {
	    int tid = 0;
            #ifdef _OPENMP
	    tid = omp_get_thread_num ();
            #endif

	    double myLsum = 0.0;
	    double myIsum = 0.0;
	    double myIsum2 = 0.0;
	    double myerrsum = 0.0;
	    double myerrsum2 = 0.0;
	    double myerrsum3 = 0.0;

#if !USE_MIC
            #pragma omp for schedule(static,64)
#endif
	    for(int i = 0;i < numerrors;i++){
	      if(USE_MIC && !(((i / 64) % numthreads) == tid)) // NOTE : simulates #pragma omp for schedule(static,64)
		continue;

	      double y = perr[i].y;
	      double x = C*perr[i].x;
	      if(ENDFIX>=3 && perr[i].end && y >= x)
		continue;
	      double err = y - x;
	      err *= err;
	      if(RESBIAS_MAXERR2 >= 2 && err  >= perr[i].maxerr2)
		continue;

	      double var = A + B * y;
	      if(QUADRATIC_VARIANCE)
		var += R * y*y;
	      if(RES_VARIANCE)
		var += E * perr[i].resvar;
	      double Ivar = 1.0/var;
	      double yIvar = y*Ivar;
	      double yIvar2 = yIvar*yIvar;

	      if(!(ENDFIX>=2 && perr[i].end)){
		myLsum += log(var);
		if(SDDEBUG) myLsum -= logXtheta;
		myIsum += yIvar;
		myIsum2 += yIvar2;
	      }

	      myerrsum += err *= Ivar;
	      myerrsum2 += err * yIvar;
	      myerrsum3 += err * yIvar2;

	      if(VERB>=2 && iter==18){
		int mid = perr[i].mapid;
		int L = perr[i].L;
		int R = perr[i].R;
		printf("  i=%d:mid=%d,L=%d,R=%d,x=%0.6f,y=%0.6f,resvar=%0.8f,var=%0.8f:LL=%0.8f(cum=%0.8f)\n",
		       i,mid,L,R,x,y,perr[i].resvar,var,-0.5*(log(var)-logXtheta+err),-0.5*(myLsum + myerrsum));
	      }
	    }
	    
	    Tarray1[tid] = myLsum;
	    Tarray2[tid] = myIsum;
	    Tarray3[tid] = myIsum2;
	    Tarray4[tid] = myerrsum;
	    Tarray5[tid] = myerrsum2;
	    Tarray6[tid] = myerrsum3;
	  }// parallel
	  qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray3, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray4, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray5, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray6, numthreads, sizeof(double), (intcmp *)DoubleInc);

	  for(int tid = 0; tid < numthreads; tid++){
	    Lsum += Tarray1[tid];
	    Isum += Tarray2[tid];
	    Isum2 += Tarray3[tid];
	    errsum += Tarray4[tid];
	    errsum2 += Tarray5[tid];
	    errsum3 += Tarray6[tid];
	  }

	  double LL = -(Lsum+errsum)*0.5;
	  double LL1 = 0.5*(errsum2-Isum);
	  double LL2 = 0.5*Isum2-errsum3;
	  if(LL < bestLL){
	    if(VERB && (VERB >= 2 || SDDEBUG)){
	      printf("iter=%d,%d,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f:LL=%0.8f,LL1=%0.8f,LL2=%0.8f:backtracking (sd->%0.8f)\n",
	        Biter,iter,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R), sqrt(E),LL, LL1, LL2, copysign(sqrt(0.5*fabs(B+bestB)),B+bestB));
	      fflush(stdout);
	    }
	    B = (B+bestB)*0.5;
	    if(LL < bestLL - 1e-6 && fabs(B-bestB) > 1e-6)
	      Biter--;/* add an iteration of drop is LL was significant */
	    continue;
	  }
	  bestB = B;
	  bestLL = LL;

	  double maxdelta = Bmax * 0.5;
	  double delta = (LL2 < 0.0) ? min(maxdelta,fabs(LL1/LL2)) : maxdelta;
	  delta = copysign(delta,LL1);

	  if(DEBUG) assert(R >= 0.0 && A >= 0.0);
	  if(B + delta < -2.0*sqrt(A*R) * MINSD_MULT * MINSD_MULT)
	    delta = -2.0*sqrt(A*R) * MINSD_MULT * MINSD_MULT - B;
	  if(VERB && (VERB >= 2 || SDDEBUG)){
	    printf("iter=%d,%d,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f:LL=%0.8f,LL1=%0.8f,LL2=%0.8f:delta=%0.8f(sd->%0.8f)\n",
	    Biter,iter,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R),sqrt(E),LL, LL1, LL2, delta,copysign(sqrt(fabs(B+delta)),B+delta));
	    fflush(stdout);
	  }
	  B += delta;
	  if(REFDEBUG_STRICT < 2){
	    B = min(B,Bmax);
	    B = max(B,Bmin);
	  }
	} /* Biter = 0..2 */
        B = bestB;

	if(REFDEBUG>=2 && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	  SF[0] = sqrt(A);
	  SD[0] = (B < 0.0) ? -sqrt(-B) : sqrt(B);
	  SR[0] = sqrt(R);
	  SE[0] = sqrt(E);

	  if(DEBUG) assert(logLRarray);
	  (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	  double LRsum = 0.0;
	  double LRsdsum = 0.0;
	  lcnt= 0;
	  for(size_t i = 0; i < numaligns; i++){
	    Calign *align = alignment[i];
	    if(!align || align->numpairs <= 1)
	      continue;
	    int mid = align->mapid2;
	    if(DEBUG>=2)assert(!Gmap[mid]->origmap);
	    if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	      if(DEBUG) assert(BestRefExt==0.0);
	      if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	    }
	    int rid = align->mapid1;
	    if(DEBUG>=2){
	      int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	      assert(origgoodalign);
	      int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	      assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	    }
	    FLOAT *X = Gmap[mid]->site[0];
	    int M = Gmap[mid]->numsite[0];
	    FLOAT *Y = refmap[rid]->site[0];
	    int N = refmap[rid]->numsite[0];
	    double LRsd = 0.0;
	    double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
			      /* (iter==18 && mid <=2 ) ? 1 : 0 */ 0, SDDEBUG ? &LRsd : 0,0);
	    logLRarray[mid] = LR;
	    logSDarray[mid] = LRsd;
	    if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	      continue;
	    LRsum += LR;
	    lcnt++;
	    if(SDDEBUG)
	      LRsdsum += LRsd;
	    if(VERB>=2 && SDDEBUG && iter==18){
	      printf("rid=%d,mid=%d,or=%d:LR=%0.8f(cum=%0.8f),LRsd=%0.8f(cum=%0.8f)\n",rid,mid,align->orientation,LR,LRsum,LRsd,LRsdsum);
	      fflush(stdout);
	    }
	  }
	  if(SDDEBUG)
	    printf("iter=%d:After updating SD:lcnt=%llu:score=%0.6f -> %0.6f (logLRsd= %0.6f -> %0.6f),numthreads=%d\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt,LRsdsum/lcnt,numthreads);
	  else
	    printf("iter=%d:After updating SD:lcnt=%llu:score=%0.6f -> %0.6f\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	  fflush(stdout);
	  if(DEBUG) assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	  if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	  logLRsum = LRsum;
	  if(SDDEBUG)
	    logLRsdsum = LRsdsum;
	  score_free(0,numrefmaps);
	}
	
	if(RES_VARIANCE && MAXSE > MINSE){
	  bestLL = MINSCORE;
	  double bestE = E;

	  /* update estimate E (seperately from A, B, R) (e iterations with delta = -f'/f'') */
	  for(int Eiter = 0; Eiter < 3; Eiter++){
	    double Lsum = 0.0;/* sum of log(A+By+Ryy+E*resvar) */
	    double Isum = 0.0;/* sum of resvar/(A+By+Ryy+E*resvar) */
	    double Isum2 = 0.0;/* sum of resvar^2/(A+By+Ryy+E*resvar)^2 */
	    double errsum = 0.0;/* sum of (Cx-y)^2/(A+By+Ryy+E*resvar) */
	    double errsum2 = 0.0;/* sum of resvar (Cx-y)^2/(A+By+Ryy+E*resvar)^2 */
	    double errsum3 = 0.0;/* sum of resvar^2 (Cx-y)^2/(A+By+Ryy+E*resvar)^3 */
	    Cinterval *perr = errors;

	    for(int tid = 0; tid < numthreads; tid++)
	      Tarray1[tid] = Tarray2[tid] = Tarray3[tid] = Tarray4[tid] = Tarray5[tid] = Tarray6[tid] = 0.0;

            // NOTE : non-deterministic with gcc 4.6, even if Tarray*[] are sorted by value, unless -fno-unsafe-math-optimizations is used
	    #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	    {
	      int tid = 0;
#ifdef _OPENMP
	      tid = omp_get_thread_num ();
#endif

	      double myLsum = 0.0;
	      double myIsum = 0.0;
	      double myIsum2 = 0.0;
	      double myerrsum = 0.0;
	      double myerrsum2 = 0.0;
	      double myerrsum3 = 0.0;

#if !USE_MIC
              #pragma omp for schedule(static,64)
#endif
	      for(int i = 0; i < numerrors; i++){
		if(USE_MIC && !(((i / 64) % numthreads) == tid)) // NOTE : simulates #pragma omp for schedule(static,64)
		  continue;

	        double y = perr[i].y;
		double x = C*perr[i].x;
		if(ENDFIX>=3 && perr[i].end && y >= x)
		  continue;
		double err = y - x;
		err *= err;
		if(RESBIAS_MAXERR2 >= 2 && err  >= perr[i].maxerr2)
		  continue;

		double var = A + B * y;
		if(QUADRATIC_VARIANCE)
		  var += R * y*y;
		double resvar = perr[i].resvar;
		var += E * resvar;
		double Ivar = 1.0/var;
		double yIvar = resvar*Ivar;
		double yIvar2 = yIvar*yIvar;
		
		if(!(ENDFIX>=2 && perr[i].end)){
	          myLsum += log(var);
		  myIsum += yIvar;
		  myIsum2 += yIvar2;
	        }

		myerrsum += err *= Ivar;
		myerrsum2 += err * yIvar;
		myerrsum3 += err * yIvar2;
	      }
	    
	      Tarray1[tid] = myLsum;
	      Tarray2[tid] = myIsum;
	      Tarray3[tid] = myIsum2;
	      Tarray4[tid] = myerrsum;
	      Tarray5[tid] = myerrsum2;
	      Tarray6[tid] = myerrsum3;
	    }// parallel
	    qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray3, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray4, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray5, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray6, numthreads, sizeof(double), (intcmp *)DoubleInc);

	    for(int tid = 0; tid < numthreads; tid++){
	      Lsum += Tarray1[tid];
	      Isum += Tarray2[tid];
	      Isum2 += Tarray3[tid];
	      errsum += Tarray4[tid];
	      errsum2 += Tarray5[tid];
	      errsum3 += Tarray6[tid];
	    }

	    double LL = -(Lsum+errsum)*0.5;
	    double LL1 = 0.5*(errsum2-Isum);
	    double LL2 = 0.5*Isum2-errsum3;
	    if(LL < bestLL){
	      if(VERB && (VERB >= 2 || SDDEBUG)){
	        printf("iter=%d,%d,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f:LL=%0.8f,LL1=%0.8f,LL2=%0.8f:backtracking (se->%0.8f)\n",
		  Eiter,iter,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R), sqrt(E),LL, LL1, LL2, sqrt((E + bestE)*0.5));
		fflush(stdout);
	      }
	      E = (E+bestE)*0.5;
	      if(LL < bestLL - 1e-6 && fabs(E-bestE) > 1e-6)
		Eiter--;/* add an iteration if drop in LL was significant */
	      continue;
	    }
	    bestE = E;
	    bestLL = LL;

	    double maxdelta = Emax * 0.5;
	    double delta = (LL2 < 0.0) ? min(maxdelta,fabs(LL1/LL2)) : maxdelta;
	    delta = copysign(delta,LL1);
	    if(E + delta < Emin)
	      delta = Emin - E;

	    if(VERB && (VERB>=2 || SDDEBUG)){
	      printf("iter=%d,%d,sf=%0.8f,sd=%0.8f,sr=%0.8f,se=%0.8f:LL=%0.8f,LL1=%0.8f,LL2=%0.8f:delta=%0.8f(se->%0.8f)\n",
		Eiter,iter,sqrt(A),copysign(sqrt(fabs(B)),B),sqrt(R),sqrt(E),LL, LL1, LL2, delta, sqrt(E + delta));
	      fflush(stdout);
	    }
	    E += delta;
	    if(DEBUG) assert(E >= 0.0 && isfinite(E));
	    if(REFDEBUG_STRICT < 2){
	      E = min(E,Emax);
	      E = max(E,Emin);
	    }
	  } // Eiter = 0 ... 2
	  E = bestE;

	  if(REFDEBUG>=2 && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	    SF[0] = sqrt(A);
	    SD[0] = (B < 0.0) ? -sqrt(-B) : sqrt(B);
	    SR[0] = sqrt(R);
	    SE[0] = sqrt(E);

	    if(DEBUG) assert(logLRarray);
	    (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	    double LRsum = 0.0;
	    double LRsdsum = 0.0;
	    lcnt= 0;
	    double *origLRarray = new double[nummaps];
	    double *origSDarray = new double[nummaps];
	    for(size_t i = 0; i < numaligns; i++){
	      Calign *align = alignment[i];
	      if(!align || align->numpairs <= 1)
		continue;
	      int mid = align->mapid2;
	      if(DEBUG>=2)assert(!Gmap[mid]->origmap);
	      if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		if(DEBUG) assert(BestRefExt==0.0);
		if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
		continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	      }
	      int rid = align->mapid1;
	      if(DEBUG>=2){
		int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
		assert(origgoodalign);
		int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
		assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	      }
	      FLOAT *X = Gmap[mid]->site[0];
	      int M = Gmap[mid]->numsite[0];
	      FLOAT *Y = refmap[rid]->site[0];
	      int N = refmap[rid]->numsite[0];
	      double LRsd = 0.0;
	      double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,0,SDDEBUG ? &LRsd : 0,0);
	      logLRarray[mid] = LR;
	      logSDarray[mid] = LRsd;
	      if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		continue;
	      LRsum += LR;
	      lcnt++;
	      if(SDDEBUG)
		LRsdsum += LRsd;
	    }
	    if(SDDEBUG)
	      printf("iter=%d:After updating SE:lcnt=%llu:score=%0.6f -> %0.6f (logLRsd= %0.6f -> %0.6f)\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt,logLRsdsum/lcnt,LRsdsum/lcnt);
	    else
	      printf("iter=%d:After updating SE:lcnt=%llu:score=%0.6f -> %0.6f\n",iter,(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	    fflush(stdout);

	    if((DEBUG && !(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt)) || (VERB>=2 && iter==1)){
	      double sum1 = 0.0,sum2 = 0.0, sum3 = 0.0, sum4 = 0.0;
	      for(size_t i = 0; i < numaligns; i++){
		Calign *align = alignment[i];
		if(!align || align->numpairs <= 1)
		  continue;
		int mid = align->mapid2;
		if(DEBUG>=2)assert(!Gmap[mid]->origmap);
		if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		  if(DEBUG) assert(BestRefExt==0.0);
		  continue;
		}
		if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		  continue;
		sum1 += origLRarray[mid];
		sum2 += logLRarray[mid];
		sum3 += origSDarray[mid];
		sum4 += logSDarray[mid];
		printf("i=%lu/%lu:mid=%d,id=%lld:logLRarray[mid]=%0.6f -> %0.6f (delta=%0.6f,cum=%0.6f -> %0.6f), LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
		       i,numaligns,mid,Gmap[mid]->id,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid],sum1, sum2,
		       origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4);
	      }
	      fflush(stdout);
	      assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	    }
	      
	    if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	    logLRsum = LRsum;
	    if(SDDEBUG)
	      logLRsdsum = LRsdsum;
	    delete [] origLRarray;
	    delete [] origSDarray;
	    score_free(0,numrefmaps);
	  }
	} // if(RES_VARIANCE ... )

	if(STITCH && stitchcnt > 0){
	  /* update estimate of As (seperately from Bs & Rs) (3 iterations with delta = -f'/f'') */
	  double bestLL = MINSCORE;

	  double bestAs = As;
	  int AiterMax = 3;
	  for(int Aiter=0; Aiter < AiterMax; Aiter++){
	    double Lsum=0.0;/* sum of log(A+By+Ryy) */
	    double Isum=0.0;/* sum of 1/(A+By+Ryy) */
	    double Isum2=0.0;/* sum of 1/(A+By+Ryy)^2 */
	    double errsum=0.0;/* sum of (Cx-y)^2/(A+By+Ryy) */
	    double errsum2=0.0;/* sum of (Cx-y)^2/(A+By+Ryy)^2 */
	    double errsum3=0.0;/* sum of (Cx-y)^2/(A+By+Ryy)^3 */
	    Cinterval *perr = errors;

	    for(int i = 0;i < numerrors;i++,perr++){
	      if(!perr->stitch)
		continue;
	      double y = perr->y + Ms * perr->stitch;
	      double err = y - C*perr->x;
	      err *= err;

	      double var = As + Bs * y + Rs * y*y;
	      double Ivar = 1.0/var;
	      double Ivar2 = Ivar*Ivar;

	      Lsum += log(var);
	      Isum += Ivar;
	      Isum2 += Ivar2;

	      errsum += err * Ivar;
	      errsum2 += err*Ivar2;
	      errsum3 += err*Ivar2*Ivar;
	    }

	    double LL = -(Lsum+errsum)*0.5;
	    double LL1 = 0.5*(errsum2-Isum);
	    double LL2 = 0.5*Isum2-errsum3;

	    if(LL < bestLL){
	      if(VERB && (VERB>=2 || SDDEBUG)){
		printf("iter=%d,%d:Stitched Intervals:sf=%0.6f,sd=%0.4f,sr=%0.4f:LL=%0.6f,LL1=%0.6f,LL2=%0.3f:backtracking (sf->%0.6f)\n",
		       Aiter,iter,sqrt(As),sqrt(Bs),sqrt(Rs),LL, LL1, LL2, sqrt(0.5*(As+bestAs)));
		fflush(stdout);
	      }
	      As = (As+bestAs)*0.5;
	      if(LL < bestLL - 1e-6 && fabs(LL-bestLL) > 1e-6)
		Aiter--;
	      continue;
	    }
	    bestAs = As;
	    bestLL = LL;

	    double maxdelta = Amax * 0.5;
	    double delta = (LL2 < 0.0) ? min(maxdelta,fabs(LL1/LL2)) : maxdelta;
	    delta = copysign(delta,LL1);
	    if(As + delta < 0.0)
	      delta = -As;
	    if(VERB && (VERB>=2 || SDDEBUG)){
	      printf("iter=%d,%d:Stitched Intervals:sf=%0.6f,sd=%0.4f,sr=%0.4f:LL=%0.6f,LL1=%0.6f,LL2=%0.3f:delta=%0.6f(sf->%0.6f)\n",
		     Aiter,iter,sqrt(As),sqrt(Bs), sqrt(Rs), LL, LL1, LL2, delta,sqrt(As+delta));
	      fflush(stdout);
	    }

	    As += delta;
	    if(REFDEBUG_STRICT < 2){
	      As = min(As,Amax);
	      As = max(As,Amin);
	    }
	    if(QUADRATIC_VARIANCE){
	      if(DEBUG) assert(Rs >= 0.0);
	      if(Bs < 0.0 && Rs >= 0.0)
		As = max(As, Bs*Bs/(4.0*Rs * pow(MINSD_MULT, 4.0)));
	    }

	  } /* Aiter = 0..AiterMax-1 */

	  if(QUADRATIC_VARIANCE >= 1 && MAXSR > MINSR){  /* update estimate of Rs (seperately from As & Bs) (3 iterations with delta = -f'/f'') */
	    bestLL = MINSCORE;
	    double bestRs = Rs;
	    int RiterMax = 3;
	    for(int Riter=0; Riter < RiterMax; Riter++){
	      double Lsum=0.0;/* sum of log(A+By+Ryy) */
	      double Isum=0.0;/* sum of yy/(A+By+Ryy) */
	      double Isum2=0.0;/* sum of y^4/(A+By+Ryy)^2 */
	      double errsum=0.0;/* sum of (Cx-y)^2/(A+By+Ryy) */
	      double errsum2=0.0;/* sum of yy (Cx-y)^2/(A+By+Ryy)^2 */
	      double errsum3=0.0;/* sum of y^4 (Cx-y)^2/(A+By+Ryy)^3 */

	      Cinterval *perr = errors;
	      for(int i = 0;i < numerrors;i++,perr++){
		if(!perr->stitch)
		  continue;
		double y = perr->y + Ms * perr->stitch;
		double err = y - C*perr->x;
		err *= err;

		double var = As + Bs * y + Rs * y*y;
		double Ivar = 1.0/var;
		double yIvar = y*y*Ivar;
		double yIvar2 = yIvar*yIvar;
		
		Lsum += log(var);
		Isum += yIvar;
		Isum2 += yIvar2;
		
		errsum += err *= Ivar;
		errsum2 += err * yIvar;
		errsum3 += err * yIvar2;
	      }

	      double LL = -(Lsum+errsum)*0.5;
	      double LL1 = 0.5*(errsum2-Isum);
	      double LL2 = 0.5*Isum2-errsum3;

	      if(LL < bestLL){
		if(VERB && (VERB>=2 || SDDEBUG)){
		  printf("iter=%d,%d:Stitched Intervals:sf=%0.6f,sd=%0.4f,sr=%0.4f:LL=%0.6f,LL1=%0.6f,LL2=%0.3f:backtracking (sr->%0.6f)\n",
			 Riter,iter,sqrt(As),sqrt(Bs),sqrt(Rs),LL, LL1, LL2, sqrt(0.5*(Rs+bestRs)));
		  fflush(stdout);
		}
		Rs = (Rs+bestRs)*0.5;
		if(LL < bestLL - 1e-6 && fabs(LL - bestLL) > 1e-6)
		  Riter--;
		continue;
	      }
	      bestRs = Rs;
	      bestLL = LL;

	      double maxdelta = Rmax * 0.5;
	      double delta = (LL2 < 0.0) ? min(maxdelta,fabs(LL1/LL2)) : maxdelta;
	      delta = copysign(delta,LL1);
	      if(Rs + delta < 0.0)
		delta = -Rs;
	      if(VERB && (VERB>=2 || SDDEBUG)){
		printf("iter=%d,%d:Stitched Intervals:sf=%0.6f,sd=%0.4f,sr=%0.4f:LL=%0.6f,LL1=%0.6f,LL2=%0.3f:delta=%0.6f(sr->%0.6f)\n",
		       Riter,iter,sqrt(As),sqrt(Bs), sqrt(Rs), LL, LL1, LL2, delta,sqrt(Rs+delta));
		fflush(stdout);
	      }

	      Rs += delta;
	      if(REFDEBUG_STRICT < 2){
	        Rs = min(Rs,Rmax);
		Rs = max(Rs,Rmin);
	      }
	      if(DEBUG) assert(As >= 0.0);
	      if(Bs < 0.0 && As >= 0.0)
		Rs = max(Rs, Bs*Bs/(4.0*As * pow(MINSD_MULT, 4.0)));

	    } /* Riter = 0..RiterMax-1 */

	    /* update estimate of Bs (seperately from As & Rs) (3 iterations with delta = -f'/f'') */
	    bestLL = MINSCORE;
	    double bestBs = Bs;
	    int BiterMax = 3;
	    for(int Biter=0; Biter < BiterMax; Biter++){
	      double Lsum=0.0;/* sum of log(A+By+Ryy) */
	      double Isum=0.0;/* sum of y/(A+By+Ryy) */
	      double Isum2=0.0;/* sum of yy/(A+By+Ryy)^2 */
	      double errsum=0.0;/* sum of (Cx-y)^2/(A+By+Ryy) */
	      double errsum2=0.0;/* sum of y (Cx-y)^2/(A+By+Ryy)^2 */
	      double errsum3=0.0;/* sum of yy (Cx-y)^2/(A+By+Ryy)^3 */
	      Cinterval *perr = errors;

	      for(int i = 0;i < numerrors;i++,perr++){
		if(!perr->stitch)
		  continue;
		double y = perr->y + Ms * perr->stitch;
		double err = y - C*perr->x;
		err *= err;
		
		double var = As + Bs * y + Rs * y*y;
		double Ivar = 1.0/var;
		double yIvar = y*Ivar;
		double yIvar2 = yIvar*yIvar;
		
		Lsum += log(var);
		Isum += yIvar;
		Isum2 += yIvar2;

		errsum += err *= Ivar;
		errsum2 += err * yIvar;
		errsum3 += err * yIvar2;
	      }

	      double LL = -(Lsum+errsum)*0.5;
	      double LL1 = 0.5*(errsum2-Isum);
	      double LL2 = 0.5*Isum2-errsum3;

	      if(LL < bestLL){
		if(VERB && (VERB>=2 || SDDEBUG)){
		  printf("iter=%d,%d:Stitched Intervals:sf=%0.6f,sd=%0.4f,sr=%0.4f:LL=%0.6f,LL1=%0.6f,LL2=%0.3f:backtracking (sd->%0.6f)\n",
			 Biter,iter,sqrt(As),sqrt(Bs),sqrt(Rs),LL, LL1, LL2, copysign(sqrt(0.5*fabs(Bs+bestBs)),Bs+bestBs));
		  fflush(stdout);
		}
		Bs = (Bs+bestBs)*0.5;
		if(LL < bestLL - 1e-6 && fabs(Bs-bestBs) > 1e-6)
		  Biter--;
		continue;
	      }
	      bestBs = Bs;
	      bestLL = LL;

	      double maxdelta = Bmax * 0.5;
	      double delta = (LL2 < 0.0) ? min(maxdelta,fabs(LL1/LL2)) : maxdelta;
	      delta = copysign(delta,LL1);

	      if(DEBUG) assert(Rs >= 0.0 && As >= 0.0);
	      if(Bs + delta < -2.0*sqrt(As*Rs) * MINSD_MULT * MINSD_MULT)
		delta = -2.0*sqrt(As*Rs) * MINSD_MULT * MINSD_MULT - Bs;
	      if(VERB && (VERB>=2 || SDDEBUG)){
		printf("iter=%d,%d:Stitched Intervals:sf=%0.6f,sd=%0.4f,sr=%0.4f:LL=%0.6f,LL1=%0.6f,LL2=%0.3f:delta=%0.6f(sd->%0.6f)\n",
		       Biter,iter,sqrt(As),sqrt(Bs), sqrt(Rs), LL, LL1, LL2, delta,sqrt(Bs+delta));
		fflush(stdout);
	      }

	      Bs += delta;
	      if(REFDEBUG_STRICT < 2){
	        Bs = min(Bs,Bmax);
	        Bs = max(Bs,Bmin);
	      }
	    } /* Biter = 0..BiterMax-1 */
	  } // if(QUADRATIC_VARIANCE >=1 && MAXSR > MINSR)

	  /* HERE : add update of Es */

	}/* stitchcnt > 0 */
      }/* iter = 0 .. 29 */

      if(1){
	if(VERB) {
	  if(RES_VARIANCE)
	    printf("  var(y,r) = sf^2 + sd^2 y +sr^2 y^2 + se^2 r^2: sf = %0.6f -> %0.6f (kb), sd = %0.6f -> %0.6f (kb^1/2), sr = %0.6f -> %0.6f, se = %0.6f -> %0.6f:wtime=%0.6f\n", 
		   SF[0], sqrt(A), SD[0], copysign(sqrt(fabs(B)),B), SR[0], sqrt(R), SE[0], sqrt(E),wtime());
	  else
	    printf("  var(y) = sf^2 + sd^2 y +sr^2 y^2: sf = %0.6f -> %0.6f (kb), sd = %0.6f -> %0.6f (kb^1/2), sr = %0.6f -> %0.6f\n", SF[0], sqrt(A), SD[0], copysign(sqrt(fabs(B)),B), SR[0], sqrt(R));
	  if(STITCH && stitchcnt > 0)
	    printf("  Stitched Intervals: sf -> %0.6f (kb), sd ->%0.6f (kb^1/2), sr ->%0.6f, bias -> %0.6f (kb)\n", sqrt(As), sqrt(Bs), sqrt(Rs), Ms);
	}

	/* NOTE : bppSD computation ignores map splits (treating each split as a seperate map) */
	double scalesum=0.0,scalesumsq=0.0, scalewtsum = 0.0;
	for(int i = 0; i < nummaps; i++){
	  double incscale = Gmap[i]->incscale;// y2sum/xysum
	  double wt = Gmap[i]->incwt;// ysum
	  if(DEBUG>=2) assert(isfinite(wt));
	  if(DEBUG>=2) assert(isfinite(incscale));
	  scalesum += incscale * wt ;
	  scalesumsq += incscale*incscale * wt;
	  scalewtsum += wt;
	  if(VERB>=2 && giter2==RefRepeats2-1 && giter == RefRepeats-1){
	    printf("m=%d:mapid=%d,id=%lld,incscale=%0.8f,wt=%0.8f:scalesum=%0.8f,scalesumsq=%0.8f,scalewtsum=%0.8f\n",
		   i,Gmap[i]->mapid,Gmap[i]->id,incscale,wt,scalesum,scalesumsq,scalewtsum);
	    fflush(stdout);
	  }
	  if(DEBUG>=2) assert(isfinite(scalewtsum));
	  if(VERB>=2){
	    printf("i=%d/%d:incscale=%0.6f,incwt=%0.6f:scalewtsum=%0.6f\n",i,nummaps,incscale,wt,scalewtsum);
	    fflush(stdout);
	  }
	}	  

	double scaleSD = 0.0;
	if(scalewtsum > 0.0 && scalesum > 0.0){
	  scalesum /= scalewtsum;
	  scalesumsq /= scalewtsum;
	  scaleSD = sqrt(scalesumsq - scalesum*scalesum) /* NEW174*/ / scalesum;
	}
	if(nummaps <= 1)
	  scaleSD = 1.0;
	else
	  scaleSD *= sqrt((double) nummaps / (double)(nummaps - 1));

	PixelLenSD = scaleSD * PixelLen;
	if(VERB){
	  if(C != 1.0)
	    printf("  Bases per pixel = %0.4f -> %0.4f (mean= %0.4f, SD =%0.4f) (FP = %0.6f -> %0.6f, res = %0.6f -> %0.6f, resSD = %0.6f -> %0.6f)\n",
		   PixelLen*1000.0, PixelLen*C*1000.0, scalesum*PixelLen*1000.0, PixelLenSD * 1000.0, FP[0], FP[0]/C, res[0], res[0]/C, resSD[0], resSD[0]/C);
	  else
	    printf("  Bases per pixel = %0.4f (S.D. =%0.4f) not changed\n", 
		   PixelLen*1000.0, PixelLenSD * 1000.0);
	  if(NumScaleFactor > 1)
	    for(int i = 0; i < NumScaleFactor; i++)
	      printf("scaleID=%d,scale=%0.4f:goodcnt=%d\n",i,ScaleFactor[i],scaleIDcnt[i]);
	  fflush(stdout);
	}

	SF[0] = sqrt(A);
	if(REFDEBUG_STRICT < 2){
	  SF[0] = min(SF[0],MAXSF);
	  SF[0] = max(SF[0],MINSF);
	}

	SD[0] = copysign(sqrt(fabs(B)),B);
	if(REFDEBUG_STRICT < 2){
	  SD[0] = min(SD[0],MAXSD);
	  SD[0] = max(SD[0],MINSD);
	}
	
	SR[0] = sqrt(R);
	if(REFDEBUG_STRICT < 2){
	  SR[0] = min(SR[0],MAXSR);
	  SR[0] = max(SR[0],MINSR);
	}

	if(DEBUG) assert(E >= 0.0);
	SE[0] = sqrt(E);
	if(DEBUG) assert(isfinite(SE[0]));
	if(REFDEBUG_STRICT < 2){
	  SE[0] = min(SE[0],MAXSE);
	  SE[0] = max(SE[0],MINSE);
	}

	if(C != 1.0 && !(REFDEBUG>=2 && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0)))){ /* rescale all query maps */
	  if(VERB/* HERE >=2 */){
	    printf("  Rescaling all map site[] and rawsite[] values  by C=%0.12f (reflecting change in bpp):wtime=%0.6f\n",C,wtime());

	    //	    int *MM = Gmap[0]->numsite;
	    //	    printf("    Gmap[0]->numsite=MM={%d,%d},Gmap[0]->site[0][MM[0]+1]=%0.3f,Gmap[0]->site[1][MM[1]+1]=%0.3f,Gmap[0]->rawsite[0][MM[0]+1]=%0.3f,Gmap[0]->rawsite[1][MM[1]+1]=%0.3f\n",
	    //		   MM[0],MM[1],Gmap[0]->site[0][MM[0]+1],Gmap[0]->site[1][MM[1]+1],Gmap[0]->rawsite[0][MM[0]+1],Gmap[0]->rawsite[1][MM[1]+1]);
	    fflush(stdout);
	  }

	  int origcolors = colors;
	  if(usecolor)
	    colors = 2;

	  double totX = 0.0;
	  if(DEBUG>=2)
	    for(int i=0; i < nummaps; i++)
	      totX += Gmap[i]->site[0][Gmap[i]->numsite[0]+1];

	  #pragma omp parallel for num_threads(numthreads) schedule(dynamic,256) if(numthreads > 1)
	  for(int i= 0; i < nummaps; i++){
	    Cmap *pmap = Gmap[i];
	    if(DEBUG && colors>=2 && !(fabs(pmap->site[0][pmap->numsite[0]+1] - pmap->site[1][pmap->numsite[1]+1]) < 1e-3)){
	      #pragma omp critical
	      {
		printf("mapid=%d(id=%lld):numsite[0]=%d,numsite[1]=%d,site[0][numsite[0]+1]= %0.6f, site[1][numsite[1]+1]= %0.6f\n",
		       i,pmap->id,pmap->numsite[0],pmap->numsite[1],pmap->site[0][pmap->numsite[0]+1],pmap->site[1][pmap->numsite[1]+1]);
		fflush(stdout);
		assert(fabs(pmap->site[0][pmap->numsite[0]+1] - pmap->site[1][pmap->numsite[1]+1]) < 1e-3);
	      }
	    }
	    for(int c = 0; c < colors; c++){
	      FLOAT *X = pmap->site[c];
	      int M = pmap->numsite[c];

	      #pragma novector
	      for(int j= M+1; j > 0; j--)
		X[j] *= C;
	    }

	    if(BIAS_TRACE && pmap->id == BIAS_TRACE_ID){
	      #pragma omp critical
	      {
  	        printf("Rescaled sites for map id=%lld by C=%0.12f(site=%p,%p)\n",pmap->id,C,pmap->site[0],pmap->site[1]);
		for(int c = 0; c < colors; c++){
		  FLOAT *X = pmap->site[c];
		  int M = pmap->numsite[c];
		  for(int j= 1; j <= M+1; j++)
		    printf("site[%d][%d]= %0.8f\n",c,j,X[j]);
		}
		fflush(stdout);

		/*
		printf("rawsites for map id=%lld (rawsite=%p,%p)\n",pmap->id,pmap->rawsite[0],pmap->rawsite[1]);
		for(int c = 0; c < colors; c++){
	          FLOAT *X = pmap->rawsite[c];
	          int M = pmap->numsite[c];
		  for(int j= 1; j <= M+1; j++)
		    printf("rawsite[%d][%d]= %0.8f\n",c,j,X[j]);
	        }
		fflush(stdout); 
		*/
	      }
	    }
	    if(DEBUG && colors>=2) assert(fabs(pmap->site[0][pmap->numsite[0]+1] - pmap->site[1][pmap->numsite[1]+1]) < 1e-3);	    
          }

	  if(DEBUG>=2){
	    double newtotX = 0.0;
	    for(int i=0; i < nummaps; i++)
	      newtotX += Gmap[i]->site[0][Gmap[i]->numsite[0]+1];
	    if(fabs(newtotX - totX*C) >= newtotX * 0.000001){
	      printf("C=%0.8f,totX=%0.4f,newtotX=%0.4f(totX*C=%0.4f)\n",
		     C,totX,newtotX,totX*C);
	      fflush(stdout);exit(1);
	    }
	  }

	  if(maxresbias > mres * 0.5){/* also rescale rawsite[]. NOTE : applied to all maps including -subset maps (if -ScanScaling) and split maps */

	    if(DEBUG) assert(rawsitemaps >= totalmaps);

	    #pragma omp parallel for num_threads(numthreads) schedule(dynamic,256) if(numthreads > 1)
	    for(int i= 0; i < totalmaps; i++){
	      Cmap *pmap = Gmap[i];
	      if(DEBUG && colors>=2 && !(fabs(pmap->rawsite[0][pmap->numsite[0]+1] - pmap->rawsite[1][pmap->numsite[1]+1]) < 1e-3)){
	        #pragma omp critical
		{
		  printf("mapid=%d(id=%lld):numsite[0]=%d,numsite[1]=%d,rawsite[0][numsite[0]+1]= %0.6f, rawsite[1][numsite[1]+1]= %0.6f\n",
			 i,pmap->id,pmap->numsite[0],pmap->numsite[1],pmap->rawsite[0][pmap->numsite[0]+1],pmap->rawsite[1][pmap->numsite[1]+1]);
		  fflush(stdout);
		  assert(fabs(pmap->rawsite[0][pmap->numsite[0]+1] - pmap->rawsite[1][pmap->numsite[1]+1]) < 1e-3);
		}
	      }

	      for(int c = 0; c < colors; c++){
		FLOAT *X = pmap->rawsite[c];
		int M = pmap->numsite[c];
		for(int j= M+1; j > 0; j--)
		  X[j] *= C;
	      }

	      if(VERB>=2 && pmap->id == 1LL){
		printf("Rescaled rawsites for map id=%lld by C=%0.12f\n",pmap->id,C);
		for(int c = 0; c < colors; c++){
	          FLOAT *X = pmap->rawsite[c];
	          int M = pmap->numsite[c];
		  for(int j= 1; j <= M+1; j++)
		    printf("rawsite[%d][%d]= %0.8f\n",c,j,X[j]);
	        }
		fflush(stdout);
	      }

	      if(BIAS_TRACE && pmap->id == BIAS_TRACE_ID){
	        #pragma omp critical
		{
		  int M = pmap->numsite[0];
		  FLOAT *RawX = pmap->rawsite[0];
		  FLOAT *X = pmap->site[0];
		  printf("mapid=%d(id=%lld),M=%d,scan=%d,rawsite[0]=%p:\n",pmap->mapid,pmap->id,M,pmap->UniqueScanId,RawX);
		  for(int j = 1; j <= M+1; j++)
		    printf("  j=%d:rawX[j]=%0.10f,X[j]=%0.10f(shift=%0.10f)\n",j,RawX[j],X[j],X[j]-RawX[j]);
		  if(pmap->origsite[0]){
		    int origM = pmap->orignumsite[0];
		    double *origX = pmap->origsite[0];
		    double scale = PixelLen / 0.500;
		    printf("origM=%d:bpp/500 = %0.12f\n",origM,scale);
		    for(int j = 1; j <= origM+1; j++)
		      printf("  j=%d:origX[j]=%0.10f,origX[j]*bpp/500=%0.10f\n",j,origX[j],origX[j]*scale);
		  }
		  fflush(stdout);
		}
	      }

	      if(DEBUG && colors>=2) assert(fabs(pmap->rawsite[0][pmap->numsite[0]+1] - pmap->rawsite[1][pmap->numsite[1]+1]) < 1e-3);
	    }

	    /* also scale resbias[c][] values */
	    for(int c = 0; c < colors; c++){
	      for(int Bin = 0; Bin <= ResBins[c]; Bin++){
		resbias[c][Bin] *= C;
		resbiasX[c][Bin] *= C;
	      }
	    }
	    maxresbias *= C;
	    if(maxresbias <= mres * 0.5)
	      maxresbias = mres * 0.5 + 1e-6;/* Fudge : should never happen */
	    if(VERB>=2){
	      printf("maxresbias=%0.6f,ResBins[0]=%d,resbiasX[0][ResBins[0]]= %0.6f\n",maxresbias,ResBins[0],resbiasX[0][ResBins[0]]);
	      fflush(stdout);
	    }
	    if(DEBUG/* >=2 */)
	      for(int c = 0; c < colors; c++)
		assert(resbiasX[c][ResBins[c]] <= maxresbias);
	  }

	  colors = origcolors;

	  double InvC = 1.0/C;
	  for(int i = 0; i < nummaps; i++)
	    Gmap[i]->incscale *= InvC;
	  PixelLen *= C;
	  FP[0] *= InvC;
	  Xtheta *= C;
	  res[0] *= InvC;
	  resSD[0] *= InvC;

	  if(REFDEBUG_STRICT < 2){
	    FP[0] = min(FP[0],MAXFP);
	    FP[0] = max(FP[0],MINFP);
	    res[0] = max(res[0],MinRes);
	    res[0] = min(res[0],MaxRes);
	    resSD[0] = max(resSD[0],MinResSD);
	    resSD[0] = min(resSD[0],MaxResSD);
	  }
	}

	if(DEBUG>=2) assert(colors==1);

	if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	  if(DEBUG) assert(logLRarray);
	  (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	  double LRsum = 0.0;
	  double LRsdsum = 0.0;
	  lcnt= 0;
	  double *origLRarray = new double[nummaps];
	  double *origSDarray = new double[nummaps];
	  for(int mid = 0; mid < nummaps; mid++){
	    origLRarray[mid] = logLRarray[mid];
	    origSDarray[mid] = logSDarray[mid];
	  }
	  double ntotXlen = 0.0;
	  for(size_t i = 0; i < numaligns; i++){
	    Calign *align = alignment[i];
	    if(!align || align->numpairs <= 1)
	      continue;
	    int mid = align->mapid2;
	    if(DEBUG) assert(0 <= mid && mid < nummaps);
	    if(DEBUG>=2)assert(!Gmap[mid]->origmap);
	    if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	      if(DEBUG) assert(BestRefExt==0.0);
	      if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	    }
	    int rid = align->mapid1;
	    if(DEBUG>=2){
	      int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	      assert(origgoodalign);
	      int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	      assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	    }
	    FLOAT *X = Gmap[mid]->site[0];
	    int M = Gmap[mid]->numsite[0];
	    FLOAT *Y = refmap[rid]->site[0];
	    int N = refmap[rid]->numsite[0];
	    double LRsd = 0.0;
	    double XL = 0.0;
	    double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
			      /* ((!WITH_RESBIAS && giter== 0 && mid== 434) || (WITH_RESBIAS && giter== -1 && mid== 108)) ? 1 : 0*/ 0, SDDEBUG ? &LRsd : 0, SDDEBUG ? &XL : 0);
	    logLRarray[mid] = LR;
	    logSDarray[mid] = LRsd;
	    Xlen[mid] = XL;
	    if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	      continue;
	    LRsum += LR;
	    lcnt++;
	    if(SDDEBUG){
	      LRsdsum += LRsd;
	      ntotXlen += XL;
	    }
	  }
	  if(SD[0] != SDorig || SF[0] != SForig || SR[0] != SRorig || SE[0] != SEorig || C != 1.0){
	    if(SDDEBUG)
	      printf("After SF,SD,SR,SE,PixelLen updates:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd=%0.6f -> %0.6f)\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt, LRsdsum/lcnt);
	    else
	      printf("After SF,SD,SR,SE,PixelLen updates:lcnt=%llu:score=%0.6f -> %0.6f\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	    fflush(stdout);
	  }
	  if(DEBUG && !(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt)){
	    if(VERB){
	      double sum1 = 0.0,sum2 = 0.0;
	      for(size_t i = 0; i < numaligns; i++){
		Calign *align = alignment[i];
		if(!align || align->numpairs <= 1)
		  continue;
		int mid = align->mapid2;
		if(DEBUG>=2)assert(!Gmap[mid]->origmap);
		if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		  if(DEBUG) assert(BestRefExt==0.0);
		  continue;
		}
		if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		  continue;
		sum1 += origLRarray[mid];
		sum2 += logLRarray[mid];
		printf("i=%lu/%lu:mid=%d,id=%lld:logLRarray[mid]=%0.8f -> %0.8f (delta=%0.8f,cum=%0.8f -> %0.8f), LLsd=%0.8f\n",
		       i,numaligns,mid,Gmap[mid]->id,origLRarray[mid],logLRarray[mid], logLRarray[mid] - origLRarray[mid], sum1, sum2, logSDarray[mid]);
	      }
	      printf("After SF,SD,SR,SE,PixelLen updates:lcnt=%llu:logLR=%0.6f -> %0.6f\n",(unsigned long long)lcnt,logLRsum,LRsum);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	  }
	  if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	  logLRsum = LRsum;
	  if(SDDEBUG){
	    logLRsdsum = LRsdsum;
	    totXlen = ntotXlen;
	  }
	  delete [] origLRarray;
	  delete [] origSDarray;
	  score_free(0,numrefmaps);
	} // if(REFDEBUG ... )

	if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0)) && maxresbias > mres * 0.5){/* check if logLRsum has changed after calling BiasCompute() */
	  BiasCorrect(Gmap, 0, nummaps, 0);

	  if(DEBUG) assert(logLRarray);
	  (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	  double LRsum = 0.0;
	  double LRsdsum = 0.0;
	  lcnt= 0;
	  double *origLRarray = new double[nummaps];
	  double *origSDarray = new double[nummaps];
	  for(int mid = 0; mid < nummaps; mid++){
	    origLRarray[mid] = logLRarray[mid];
	    origSDarray[mid] = logSDarray[mid];
	  }
	  double ntotXlen = 0.0;
	  for(size_t i = 0; i < numaligns; i++){
	    Calign *align = alignment[i];
	    if(!align || align->numpairs <= 1)
	      continue;
	    int mid = align->mapid2;
	    if(DEBUG) assert(0 <= mid && mid < nummaps);
	    if(DEBUG>=2)assert(!Gmap[mid]->origmap);
	    if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	      if(DEBUG) assert(BestRefExt==0.0);
	      if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	    }
	    int rid = align->mapid1;
	    if(DEBUG>=2){
	      int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	      assert(origgoodalign);
	      int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	      if(MapRate > 0.0 && origgoodalign) assert((!(align->score > ScoreThreshold)) == (!goodalign));
	    }
	    FLOAT *X = Gmap[mid]->site[0];
	    int M = Gmap[mid]->numsite[0];
	    FLOAT *Y = refmap[rid]->site[0];
	    int N = refmap[rid]->numsite[0];
	    double LRsd = 0.0;
	    double XL = 0.0;
	    double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
			      /* ((!WITH_RESBIAS && giter== -1 && mid== 1) || (WITH_RESBIAS && giter== -1 && mid== 108)) ? 1 : 0 */ 0, SDDEBUG ? &LRsd : 0, SDDEBUG ? &XL : 0);
	    logLRarray[mid] = LR;
	    logSDarray[mid] = LRsd;
	    Xlen[mid] = XL;
	    if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	      continue;
	    LRsum += LR;
	    lcnt++;
	    if(SDDEBUG){
	      LRsdsum += LRsd;
	      ntotXlen += XL;
	    }
	  }
	  if(SDDEBUG)
	    printf("After extra BiasCorrect:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd=%0.6f -> %0.6f)\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt, LRsdsum/lcnt);
	  else
	    printf("After extra BiasCorrect:lcnt=%llu:score=%0.6f -> %0.6f\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	  fflush(stdout);

	  if(DEBUG && !(fabs(LRsum - logLRsum) < (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt)){
	    if(VERB){
	      double sum1 = 0.0,sum2 = 0.0, sum3 = 0.0, sum4 = 0.0;
	      for(size_t i = 0; i < numaligns; i++){
		Calign *align = alignment[i];
		if(!align || align->numpairs <= 1)
		  continue;
		int mid = align->mapid2;
		if(DEBUG>=2)assert(!Gmap[mid]->origmap);
		if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		  if(DEBUG) assert(BestRefExt==0.0);
		  continue;
		}
		if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		  continue;
		sum1 += origLRarray[mid];
		sum2 += logLRarray[mid];
		sum3 += origSDarray[mid];
		sum4 += logSDarray[mid];

		printf("i=%lu/%lu:mid=%d,id=%lld:logLRarray[mid]=%0.8f -> %0.8f (delta=%0.8f, cum=%0.8f -> %0.8f), LLsd=%0.8f->%0.8f(delta=%0.8f,cum=%0.8f->%0.8f)\n",
		       i,numaligns,mid,Gmap[mid]->id,origLRarray[mid],logLRarray[mid], logLRarray[mid] - origLRarray[mid], sum1, sum2, origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4);
	      }
	      fflush(stdout);
	    }
	    if(DEBUG) assert(fabs(LRsum - logLRsum) < (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	  }
	  if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	  logLRsum = LRsum;
	  if(SDDEBUG){
	    logLRsdsum = LRsdsum;
	    totXlen = ntotXlen;
	  }
	  delete [] origLRarray;
	  delete [] origSDarray;
	  score_free(0,numrefmaps);
	}
      } // if(1)

      if(ScanCorrection && UniqueScans > 1){/* per scan scaling of molecules */
	if(!ScanScale[0]){
	  ScanScale[0] = new CscanCorrection[UniqueScans];
	  if(DEBUG)
	    for(int scan = 0; scan < UniqueScans; scan++)
	      ScanScale[0][scan].RunIndex = -1;
	  for(int sindex = 0; sindex < RunDataListLen; sindex++){
	    CRunDataSort *r = &RunDataSort[sindex];
	    for(int scan = 0; scan < r->NumberOfScans; scan++){
	      if(DEBUG) assert(scan + r->UniqueScanIdStart < UniqueScans);
	      CscanCorrection *p = &ScanScale[0][scan + r->UniqueScanIdStart];
	      p->cumscale = 1.0;
	      p->RunIndex = sindex;
	      p->ScanNumber = scan;
	      
	      p->totmols = p->mols = 0;
	      p->totlen = p->len = p->mappedlen = 0.0;
	    }
	  }
	  if(DEBUG)
	    for(int scan = 0; scan < UniqueScans; scan++)
	      assert(ScanScale[0][scan].RunIndex >= 0 && ScanScale[0][scan].RunIndex < RunDataListLen);
	}

	/* precompute ThetaDelta[scan=0..UniqueScans-1] = { Sum(m=0..nummaps-1) X[m][M[m]+1] * (scan == Gmap[m]->UniqueScanId ? 1 : 0) } / { Sum(m=0..nummaps-1) M[m] } */
	for(int scan = 0; scan < UniqueScans; scan++){
	  CscanCorrection *p = &ScanScale[0][scan];
	  ThetaDelta[scan] = 0.0;
	  p->totmols = p->mols = 0;
	  p->totlen = p->len = p->mappedlen = 0.0;
	}
	size_t totsites = 0;
	for(int m = 0; m < nummaps; m++){
	  Cmap *pmap = Gmap[m];
	  int M = pmap->numsite[0];
	  double *X = pmap->site[0];
	  totsites += M;
	  int scan = pmap->UniqueScanId;
	  if(DEBUG && !(0 <= scan && scan < UniqueScans)){
	    printf("pmap:mapid=%d,id=%lld,M=%d,scan=%d,UniqueScans=%d:RunIndex=%d/%d,ScanNumber=%d, RunId=%d, ScanId=%d\n",
		   pmap->mapid,pmap->id,M,scan, UniqueScans, pmap->RunIndex, RunDataListLen, pmap->ScanNumber, pmap->RunId, pmap->ScanId);
	    fflush(stdout);
	    assert(0 <= scan && scan < UniqueScans);
	  }
	  ThetaDelta[scan] += X[M+1];

	  CscanCorrection *p = &ScanScale[0][scan];
	  p->totmols++;
	  p->totlen += X[M+1];
	}

	if(VERB/* HERE >=2 */){
	  int cummols = 0;
	  double cumlen = 0.0;
	  for(int scan = 0; scan < UniqueScans; scan++){
	    CscanCorrection *p = &ScanScale[0][scan];	    
	    cummols += p->totmols;
	    cumlen += p->totlen;
	  }
	  if(cummols > 0){
	    printf("nummaps=%d,scans=%d: cummols=%d, totsites= %lu, cumlen= %0.3f kb (avg= %0.3f kb, label density= %0.3f /100kb), C=%0.10f\n",
		   nummaps,UniqueScans, cummols, totsites, cumlen, cumlen/cummols, totsites*100.0/cumlen,C);
	    fflush(stdout);
	  }
	}

	double scale = 1.0/totsites;
	for(int scan = 0; scan < UniqueScans; scan++)
	  ThetaDelta[scan] *= scale;

	/* compute aligned map statistics on a per scan basis */
	for(size_t i = 0; i < numaligns; i++){
	  Calign *align = alignment[i];
	  if(DEBUG) assert(align != 0);
	  if(!align || align->numpairs <= 1)
	    continue;
	  int mapid = align->mapid2;
	  if(DEBUG) assert(0 <= mapid && mapid < nummaps);
	  Cmap *pmap = Gmap[mapid];
	  if(DEBUG) assert(!pmap->origmap);
	  if(BestRef && pmap->align->mapid1 != align->mapid1){
	    if(DEBUG) assert(BestRefExt==0.0);
	    continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	  }

	  int refid = align->mapid1;
	  if(DEBUG) assert(0 <= refid && refid < numrefmaps);
	  Cmap *rmap = refmap[refid];

	  int origgoodalign = AlignedThreshold(align, rmap->site[0], startScoreThreshold, startLogPvThreshold) ? 1 : 0;
	  int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	  if(DEBUG>=2 && (ALIGN_COMPRESS || align->numpairs >= 1)) {
	    if(!origgoodalign){
	      printf("alignment[%lu]:refid=%d(id=%lld),mapid=%d(id=%lld),or=%d:numpairs=%d,score=%0.6f,LogPV=%0.2f,len=%0.2f,maxoutlier=%0.4f,Lend=%d,Rend=%d\n",
		     i,refid,rmap->id,mapid,pmap->id,align->orientation,align->numpairs,align->score,align->logPV,AlignedLength(align,rmap->site[0]),align->maxoutlier,align->Lend,align->Rend);
	      fflush(stdout);
	      assert(origgoodalign);
	    }
	  }
	  if(DEBUG>=2 && !BestRefPV && MapRate > 0.0 && origgoodalign) assert((!(align->score > ScoreThreshold)) == (!goodalign));

	  if(!goodalign)
	    continue;

	  int M = pmap->numsite[0];
	  FLOAT *X = pmap->site[0];

	  int scan = pmap->UniqueScanId;
	  if(DEBUG) assert(0 <= scan && scan < UniqueScans);
	  CscanCorrection *p = &ScanScale[0][scan];
	  
	  p->mols++;
	  p->len += X[M+1];
	  if(DEBUG) assert(align->numpairs >= 1);
	  int LJ = align->sites2[0];
	  int RJ = align->sites2[align->numpairs-1];
	  p->mappedlen += X[M+1];
	  if(align->Lend <= -2)
	    p->mappedlen -= align->orientation ? X[M+1] - X[M+1-LJ] : X[LJ];
	  if(align->Rend <= -2)
	    p->mappedlen -= align->orientation ? X[M+1-RJ] : X[M+1] - X[RJ];
	}

	/* initialize per scan scale factors to 1.0 (At the end of this giter loop, all maps will be rescaled with per scan scale factors) */
	for(int scan = 0; scan < UniqueScans; scan++)
	  ScanScale[0][scan].scale = 1.0;

	double Lsum = 0.0;/* original sum of log(A+By+Ryy + E * resvar) excluding cases with perr->end */
	double Lcnt = 0.0;/* original count of number of sample intervals in Lsum */
	double errsum = 0.0; /* original sum of (Cx-y)^2/(A+By+Ryy + E * resvar) */
	double Ftheta = FP[0] * 0.01 * Xtheta - 1.0 + 1.0/GsitesPerMap;
	double Hlog2pi = 0.5*log(2.0*M_PI);/* subtract from log(Xtheta) If SDDEBUG==1 to match LLsd in logLR() */

	// Sxsum[scan] : sum of Cx for intervals from specific scan */
	// Sxysum[scan] : sum of Cxy/(A+By+Ryy +E*resvar) for intervals from specific scan */
	// Sxxsum[scan] : sum of Cxx/(A+By+Ryy + E*resvar) for intervals from specific scan */
	for(int scan = 0; scan < UniqueScans; scan++)
	  Sxysum[scan] = Sxxsum[scan] = Sxsum[scan] = 0.0;
	for(int tid = 0; tid < numthreads; tid++){/* NOTE: this initialization cannot be performed inside the parallel loop, if the #pragma parallel is commented out */
	  Tarray1[tid] = Tarray2[tid] = Tarray3[tid] = 0.0;
	  for(int scan = 0; scan < UniqueScans; scan++)
	    Txy[tid][scan] = Txx[tid][scan] = Tx[tid][scan] = 0.0;
	}

	double *MXlen = NULL;
	if(REFDEBUG>=3){/* keep track of total x intervals for each molecule (before Scan Scaling) */
	  MXlen = new double[nummaps];
	  for(int m = 0; m < nummaps; m++)
	    MXlen[m] = 0.0;
	}

	// accumulate per map changes in predicted logLL to help with debugging
	double *LsumM = 0, *LcntM = 0, *errsumM = 0;
	double *SxysumM = 0, *SxxsumM = 0, *SxsumM = 0;
	if(REFDEBUG>=3 && ((!WITH_RESBIAS && giter== -1) || (WITH_RESBIAS && giter== -1))){
	  LsumM = new double[nummaps*6];
	  LcntM = &LsumM[nummaps];
	  errsumM = &LsumM[nummaps*2];
	  SxysumM = &LsumM[nummaps*3];
	  SxxsumM = &LsumM[nummaps*4];
	  SxsumM = &LsumM[nummaps*5];
	  for(int m = 0; m < nummaps; m++)
	    LsumM[m] = LcntM[m] = errsumM[m] = SxysumM[m] = SxxsumM[m] = SxsumM[m] = 0.0;
	}

	if(VERB>=2 && ((!WITH_RESBIAS && giter== -1) || (WITH_RESBIAS && giter== -1)))
	  qsort(alignment, numaligns, sizeof(Calign*), (intcmp*)CalignMapidInc);/* sort alignments in ascending order of mapid2 */

        if(VERB>=2 && ((!WITH_RESBIAS && giter== -1) || (WITH_RESBIAS && giter== -1))){/* sort errors[] in order of mapid,L */
	  numthreads = 1;
	  qsort(errors,numerrors,sizeof(Cinterval),(intcmp*)ErrorIdInc);
	}

	// NOTE : non-deterministic with gcc 4.6, even if Tarray*[] are sorted by value, unless -fno-unsafe-math-optimizations is used
	#pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	{
	  int tid = 0;
          #ifdef _OPENMP
	  tid = omp_get_thread_num ();
          #endif
	  
	  double myLsum = 0.0;
	  double myLcnt = 0.0;
	  double myerrsum = 0.0;
	  double *mySxysum = Txy[tid];
	  double *mySxxsum = Txx[tid];
	  double *mySxsum = Tx[tid];

#if !USE_MIC
          #pragma omp for schedule(static,64)
#endif
	  for(int i = 0; i < numerrors; i++){
	    if(USE_MIC && !(((i / 64) % numthreads) == tid)) // NOTE : simulates #pragma omp for schedule(static,64)
	      continue;

	    Cinterval *perr = &errors[i];
	    double y = perr->y;
	    double x = C*perr->x;
	    int mapid = perr->mapid;
	    if(DEBUG>=2){/* check that C * perr->x is same as X[perr->R]-X[perr->L] */
	      double *X = Gmap[mapid]->site[0];
	      double xorig = X[perr->R] - X[perr->L];
	      if(!(fabs(x - xorig) < 1e-6)){
		printf("errors[%d]:mapid=%d,L=%d,R=%d:C*x=%0.6f,X[perr->R]-X[perr->L]=%0.6f,C=%0.12f\n",
		       i,mapid,perr->L,perr->R,x,xorig,C);
		fflush(stdout);
		assert(fabs(x - xorig) < 1e-6);
	      }
	    }
	    if(DEBUG>=2) assert(0 <= mapid && mapid < totalmaps);
	    int scan = Gmap[mapid]->UniqueScanId;
	    if(DEBUG>=2) assert(0 <= scan && scan < UniqueScans);

	    mySxsum[scan] += x;/* Frate * x also applies to Send() */
	    if(REFDEBUG>=3 && ((!WITH_RESBIAS && giter== -1) || (WITH_RESBIAS && giter== -1)))
	      SxsumM[mapid] += x;

	    if(REFDEBUG>=3){
	      #pragma omp critical
	      {
	        MXlen[mapid] += x;
	        if(SDDEBUG && ((!WITH_RESBIAS && giter == -1 && mapid== 1) || (WITH_RESBIAS && giter== -1 && mapid== 43))){
		  FLOAT *X = Gmap[mapid]->site[0];
		  printf("    mapid=%d,L=%d,R=%d,end=%d:C*x=%0.6f (sum=%0.6f), y=%0.6f, X[R]-X[L]=%0.6f,X[L]=%0.8f,X[R]=%0.8f,X[]=%p\n", 
			 mapid, perr->L, perr->R,perr->end,x,MXlen[mapid],y, X[perr->R] - X[perr->L], X[perr->L], X[perr->R],X);
		  fflush(stdout);
		}
              }
            }

	    if(ENDFIX>=3 && perr->end && y >= x){
	      if(REFDEBUG>=3 && SDDEBUG && ((!WITH_RESBIAS && giter == -1 && mapid== 1) || (WITH_RESBIAS && giter== -1 && mapid== 43))){
	        double Skm = 1.003146247333;/* must match value for mapid in last line, from previous log with per map display */
		double nXtheta = 3.7476542544;
		int m = mapid;
		//		int scan = Gmap[m]->UniqueScanId;

	        double LLm = LsumM[m] + errsumM[m];
	        double Xtotm = SxsumM[m];
		double Frate = Ftheta/Xtheta;
		double LLsd = -0.5*LLm + LcntM[m]*(log(Xtheta) - Hlog2pi);
		double logLLm = LLsd - Frate*Xtotm;

		double nXtotm = Xtotm * Skm;
		double nLLm = LLm + (Skm*Skm-1.0) * SxxsumM[m] - 2.0*(Skm - 1.0)*SxysumM[m];
		double nFrate = Ftheta/nXtheta;
		double nLLsd = -0.5*nLLm + LcntM[m]*(log(nXtheta) - Hlog2pi);
		double nlogLLm = nLLsd - nFrate*nXtotm;
		
		printf("    mapid=%d,L=%d,R=%d,end=%d:x=%0.6f->%0.6f(Xcum=%0.6f),y=%0.6f:LLcum=%0.6f->%0.6f(delta=%0.6f), LLsd=%0.6f->%0.6f: Fterm=%0.6f->%0.6f\n",
		       mapid,perr->L,perr->R,perr->end,x,x*Skm,SxsumM[mapid],y,logLLm, nlogLLm, nlogLLm-logLLm, LLsd, nLLsd, -Frate*x, -nFrate*x*Skm);
		fflush(stdout);
	      }
	      continue;
	    }
	    double err = x - y;
	    if(RESBIAS_MAXERR2 >= 2 && err * err >= perr->maxerr2)
	      continue;

	    double var = A + B * y;
	    if(QUADRATIC_VARIANCE)
	      var += R * y*y;
	    if(RES_VARIANCE)
	      var += E * perr->resvar;
	    if(DEBUG>=2) assert(var > 0.0);
	    if(!(ENDFIX>=2 && perr->end)){
	      myLsum += log(var);
	      myLcnt += 1.0;
	      if(REFDEBUG>=3 && ((!WITH_RESBIAS && giter == -1)||(WITH_RESBIAS && giter== -1))){
	        LsumM[mapid] += log(var);
		LcntM[mapid] += 1.0;
              }	      
	    }
	    double Ivar = 1.0/var;
	    myerrsum += err*err*Ivar;
	    if(REFDEBUG>=3 && ((!WITH_RESBIAS && giter == -1)||(WITH_RESBIAS && giter== -1)))
	      errsumM[mapid] += err*err*Ivar;

	    Ivar *= x;

	    mySxysum[scan] += y*Ivar;
	    mySxxsum[scan] += x*Ivar;
	    if(REFDEBUG>=3 && SDDEBUG && ((!WITH_RESBIAS && giter == -1)||(WITH_RESBIAS && giter== -1))){
	      SxysumM[mapid] += y*Ivar;
	      SxxsumM[mapid] += x*Ivar;
	      if((!WITH_RESBIAS && mapid== -1) || (WITH_RESBIAS && mapid== -1)){
	        double Skm = 1.003146247333;/* must match value for mapid in last line, from previous log with per map display */
		double nXtheta = 3.7476542544;
		int m = mapid;
		//		int scan = Gmap[m]->UniqueScanId;

	        double LLm = LsumM[m] + errsumM[m];
	        double Xtotm = SxsumM[m];
		double Frate = Ftheta/Xtheta;
		double LLsd = -0.5*LLm + LcntM[m]*(log(Xtheta) - Hlog2pi);
		double logLLm = LLsd - Frate*Xtotm;

		double nXtotm = Xtotm * Skm;
		double nLLm = LLm + (Skm*Skm-1.0) * SxxsumM[m] - 2.0*(Skm - 1.0)*SxysumM[m];
		double nFrate = Ftheta/nXtheta;
		double nLLsd = -0.5*nLLm + LcntM[m]*(log(nXtheta) - Hlog2pi);
		double nlogLLm = nLLsd - nFrate*nXtotm;
		
		printf("    mapid=%d,L=%d,R=%d,end=%d:x=%0.6f->%0.6f(Xcum=%0.6f),y=%0.6f,var=%0.8f:Lcum=%0.6f->%0.6f(delta=%0.6f), LLsd=%0.6f->%0.6f:\n\t Gterm=%0.6f->%0.6f,PenErr=%0.8f->%0.8f,Fterm=%0.6f->%0.6f\n",
		       mapid,perr->L,perr->R,perr->end,x,x*Skm, SxsumM[mapid], y, var, logLLm, nlogLLm, nlogLLm-logLLm, LLsd, nLLsd,
		       (ENDFIX>=2 && perr->end) ? 0.0 : -0.5*log(var)+log(Xtheta)-Hlog2pi, (ENDFIX>=2 && perr->end) ? 0.0 : -0.5*log(var)+log(nXtheta)-Hlog2pi,
		       -0.5*err*err/var, -0.5*(err*err/var + (Skm*Skm-1.0) * x*Ivar - 2.0*(Skm - 1.0)*y*Ivar), -Frate*x, -nFrate*x*Skm);
		fflush(stdout);
	      }
            }
	    if(DEBUG>=2 && ENDFIX < 3 && ((mySxxsum[scan] <= 0.0 && mySxsum[scan] != 0.0) || x < 0.0 || x*Ivar < 0.0)){
	      #pragma omp critical
	      {
		printf("tid=%d,scan=%d,mid=%d:x=%0.6f,y=%0.6f,var=%0.6f:mySxxsum[scan]=%0.6f(delta=%0.6f),mySxsum[scan]=%0.6f(delta=%0.6f)\n",
		       tid,scan,mapid,x,y,var,mySxxsum[scan],x*Ivar,mySxsum[scan],x);
		fflush(stdout);
		assert(0);
	      }
	    }
	    if(DEBUG>=2) assert(x >= 0.0);
	  } // omp for

	  Tarray1[tid] = myLsum;
	  Tarray2[tid] = myLcnt;
	  Tarray3[tid] = myerrsum;
	}// omp parallel	  

	qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
	qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);
	qsort(Tarray3, numthreads, sizeof(double), (intcmp *)DoubleInc);
	for(int tid = 0; tid < numthreads; tid++){
	  Lsum += Tarray1[tid];
	  Lcnt += Tarray2[tid];
	  errsum += Tarray3[tid];
	}
	double Xtot = 0.0;
	for(int scan = 0; scan < UniqueScans; scan++){
	  for(int tid = 0; tid < numthreads; tid++){
	    Tarray1[tid] = Txy[tid][scan];
	    Tarray2[tid] = Txx[tid][scan];
	    Tarray3[tid] = Tx[tid][scan];
	  }
	  if(!(SCAN_FRATE_FIX && DEBUG>=2 && ENDFIX < 3)){/* sort to maximum FP precision of sum */
	    qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);
	    qsort(Tarray3, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  }
	  for(int tid = 0; tid < numthreads; tid++){
	    Sxysum[scan] += Tarray1[tid];
	    Sxxsum[scan] += Tarray2[tid];
	    Sxsum[scan] += Tarray3[tid];
	    if(SCAN_FRATE_FIX && DEBUG>=2 && ENDFIX < 3 && Sxxsum[scan] <= 0.0 && Sxsum[scan] != 0.0){
	      printf("tid=%d,scan=%d:Sxxsum[scan]=%0.6f(Txx[tid][scan]=%0.6f,Tarray2[tid]=%0.6f),Sxsum[scan]=%0.6f(Tx[tid][scan]=%0.6f,Tarray3[tid]=%0.6f)\n",
		     tid,scan,Sxxsum[scan],Txx[tid][scan],Tarray2[tid],Sxsum[scan],Tx[tid][scan],Tarray3[tid]);
	      fflush(stdout);
	      assert(0);
	    }
	  }
	  if(!SCAN_FRATE_FIX)
	    Sxsum[scan] = 0.0;
	  if(SCAN_FRATE_FIX && DEBUG>=2 && ENDFIX < 3 && Sxxsum[scan] <= 0.0 && Sxsum[scan] != 0.0){
	    printf("scan=%d:Sxxsum[scan]=%0.6f,Sxsum[scan]=%0.6f\n",
		   scan,Sxxsum[scan],Sxsum[scan]);
	    fflush(stdout);
	    assert(0);
	  }
	  Xtot += Sxsum[scan];
	}

	if(VERB>=2){
	  printf("giter=%d:Lsum=%0.6f,errsum=%0.6f,Lcnt=%0.1f,Xtot=%0.6f,C=%0.8f\n",giter,Lsum,errsum,Lcnt,Xtot,C);
	  fflush(stdout);
	}

	double LL = Lsum + errsum;
	double nXtheta = Xtheta;/* updated value of Xtheta  = Xtheta + sum(scan) (ScanScale[0][scan].scale - 1) * ThetaDelta[scan] */

	double origLL = LL;
	double origXtheta = Xtheta;
	double origXtot = Xtot;

	if(REFDEBUG>=3){/* check that sum of MXlen[0..nummaps-1] == origXtot */
	  double MXtot = 0.0;
	  for(int m = 0; m < nummaps; m++)
	    MXtot += MXlen[m];
	  if(!(fabs(MXtot - origXtot) < tcnt * 1e-6)){
	    printf("giter=%d:    MXtot=%0.6f (should match origXtot=%0.6f)\n",giter,MXtot,origXtot);
	    fflush(stdout);
	    assert(fabs(MXtot - origXtot) < tcnt * 1e-6);
          }
        }

	for(int iter = 0; iter < ScanCorrection; iter++){
	  for(int k = 0; k < UniqueScans; k++){
	    CscanCorrection *p = &ScanScale[0][k];

	    /* re-estimate ScanScale[0][scan].scale */
	    if(ThetaDelta[k] <= 0.0 || fabs(Lcnt*ThetaDelta[k]/nXtheta) > max(fabs(Sxxsum[k]),fabs(Sxysum[k])) || p->mols < ScanCorrectMinMaps){
	      if(VERB>=2 && ((!WITH_RESBIAS && giter== -1)||(WITH_RESBIAS && giter== -1)) && fabs(Sxysum[k])+fabs(Sxxsum[k])+fabs(Sxsum[k]) > 0.0){
		printf("iter=%d,%d,k=%d:mols=%d/%d,Lcnt=%0.1f,nXtheta=%0.6f,ThetaDelta=%0.6f, XYsum=%0.6f,XXsum=%0.6f,Xsum=%0.6f : skipping due to insuffient aligned data\n",
	          giter,iter, k, p->mols,ScanCorrectMinMaps,Lcnt, nXtheta, ThetaDelta[k], Sxysum[k],Sxxsum[k],Sxsum[k]);
		fflush(stdout);
	      }
	      continue;/* insufficient aligned data for scan k */
	    }

	    double Sk = ScanScale[0][k].scale;
	    LL -= (Sk*Sk-1.0) * Sxxsum[k] - 2.0 * (Sk - 1.0) * Sxysum[k];

	    /* Express LL as function of Sk and compute the first 2 derivatives (relative) to Sk */
	    double LLk = LL - 2.0*Lcnt*(SDDEBUG ? log(nXtheta)-Hlog2pi : log(nXtheta)) + (Sk*Sk-1.0) * Sxxsum[k] - 2.0 * (Sk - 1.0) * Sxysum[k] + 2.0 * (Ftheta/nXtheta) * Xtot;
	    double LL1k = -Lcnt*ThetaDelta[k]/nXtheta + Sk * Sxxsum[k] - Sxysum[k] + (Ftheta/nXtheta) * Sxsum[k] - Ftheta * Xtot * ThetaDelta[k]/(nXtheta*nXtheta) ;
	    double LL2k = -Lcnt*ThetaDelta[k]*ThetaDelta[k]/(nXtheta*nXtheta) + Sxxsum[k] - 2.0 * Ftheta * (Sxsum[k] - Xtot*ThetaDelta[k]/nXtheta) * ThetaDelta[k]/(nXtheta*nXtheta);

	    double maxdelta = 0.50;
	    double deltaSk = (LL2k > 0.0) ? min(maxdelta,fabs(LL1k/LL2k)) : maxdelta;
	    deltaSk = copysign(deltaSk,-LL1k);
	    if(fabs(LL1k) < 1e-100)
	      deltaSk = 0.0;
	    if(Sk + deltaSk > 1.50)
	      deltaSk = 1.50 - Sk;
	    else if(Sk + deltaSk < 0.70)
	      deltaSk = 0.70 - Sk;

	    /* check if we overshot the minima */
	    double nSk = Sk + deltaSk;
	    double nXtot = Xtot + deltaSk * Sxsum[k];
	    double nnXtheta = nXtheta + ThetaDelta[k] * deltaSk;
	    double nLLk = LL - 2.0*Lcnt*(SDDEBUG ? log(nnXtheta)-Hlog2pi:log(nnXtheta)) + (nSk*nSk - 1.0) * Sxxsum[k] - 2.0 * (nSk - 1.0) * Sxysum[k] + 2.0 * (Ftheta/nnXtheta) * nXtot;
	    double origdeltaSk = deltaSk;
	    for(int cnt = 0; nLLk > LLk && cnt <= 100; cnt++){
	      if((VERB>=2 && ((!WITH_RESBIAS && giter== -1)||(WITH_RESBIAS && giter== -1)) && fabs(deltaSk) >= 1e-6) || BIAS_TRACE>=2){
		printf("iter=%d,%d,k=%d:LL=%0.6f -> %0.6f(delta=%0.6f),LL1=%0.6f,LL2=%0.6f:Sk=%0.6f -> %0.6f(delta=%0.6f) : backtracking\n",
		       giter, iter, k, -0.5*LLk, -0.5*nLLk,-0.5*(nLLk-LLk), -0.5*LL1k, -0.5*LL2k, Sk, nSk, deltaSk);
		fflush(stdout);
	      }
	      if(cnt >= 100 || deltaSk < 1e-6){
		deltaSk = 0.0;
		cnt = 100;
	      } else
		deltaSk *= 0.5;
	      nSk = Sk + deltaSk;
	      nXtot = Xtot + deltaSk * Sxsum[k];
	      nnXtheta = nXtheta + ThetaDelta[k] * deltaSk;

	      nLLk = LL - 2.0*Lcnt*(SDDEBUG ? log(nnXtheta)-Hlog2pi:log(nnXtheta)) + (nSk*nSk-1.0) * Sxxsum[k] - 2.0 * (nSk - 1.0) * Sxysum[k] + 2.0 * (Ftheta/nnXtheta) * nXtot;
	    }

	    if((VERB>=2 && SDDEBUG && ((!WITH_RESBIAS && giter== -1)||(WITH_RESBIAS && giter== -1)) && fabs(deltaSk) >= 1e-6) || BIAS_TRACE){
	      double LLsd = LL - 2.0*Lcnt*(log(nXtheta)-Hlog2pi) + (Sk*Sk-1.0) * Sxxsum[k] - 2.0 * (Sk - 1.0) * Sxysum[k];
	      double nLLsd = LL - 2.0*Lcnt*(log(nnXtheta)-Hlog2pi) + (nSk*nSk-1.0) * Sxxsum[k] - 2.0 * (nSk - 1.0) * Sxysum[k];
	      printf("iter=%d,%d,k=%d:LL=%0.6f->%0.6f(delta=%0.6f),LL1=%0.6f,LL2=%0.6f,LLsd=%0.6f->%0.6f(delta=%0.6f):\n\t Sk=%0.6f->%0.6f->%0.6f(delta=%0.6f) nXtheta=%0.6f->%0.6f,ThetaDelta=%0.6f, XYsum=%0.6f,XXsum=%0.6f,Xsum=%0.6f\n",
	              giter, iter, k, -0.5*LLk, -0.5*nLLk, -0.5*(nLLk-LLk), -0.5*LL1k, -0.5*LL2k, -0.5*LLsd, -0.5*nLLsd, -0.5*(nLLsd-LLsd),
		      Sk, Sk+origdeltaSk, nSk, deltaSk, nXtheta, nnXtheta, ThetaDelta[k], Sxysum[k],Sxxsum[k],Sxsum[k]);
	      fflush(stdout);
	    }
	    
	    /* update ScanScale[0][scan].scale, nXtheta, Xtot, LL */
	    ScanScale[0][k].scale = Sk = nSk;
	    nXtheta = nnXtheta;
	    Xtot = nXtot;
	    LL += (Sk*Sk-1.0) * Sxxsum[k] - 2.0 * (Sk - 1.0) * Sxysum[k];
          }
        }

	if(VERB/* HERE >=2 */){
	  double LLsd = -0.5*origLL + Lcnt*(log(Xtheta)-Hlog2pi);
	  double logLL = LLsd - (Ftheta/Xtheta)*origXtot;
	  double nLLsd = -0.5*LL + Lcnt*(log(nXtheta)-Hlog2pi);
	  double nlogLL =  nLLsd - (Ftheta/nXtheta)*Xtot;
	  printf("    After ScanScale update LL= %0.6f -> %0.6f (delta= %0.6f), LLsd= %0.6f -> %0.6f (delta=%0.6f),Lcnt=%0.6f, Xtot=%0.6f->%0.6f, Frate=%0.7f->%0.6f\n",
	          logLL, nlogLL, nlogLL-logLL, LLsd, nLLsd, nLLsd - LLsd, Lcnt, origXtot, Xtot, (Ftheta/Xtheta), (Ftheta/nXtheta));
	  //		 -0.5*origLL + Lcnt*(log(Xtheta)-Hlog2pi) - (Ftheta/Xtheta)*origXtot , -0.5*LL + Lcnt*(log(nXtheta)-Hlog2pi) - (Ftheta/nXtheta)*Xtot,
	  //		 -0.5*(LL-origLL) + Lcnt*log(nXtheta/Xtheta) - (Ftheta/nXtheta)*Xtot + (Ftheta/Xtheta)*origXtot, 
	  //		 -0.5*origLL + Lcnt*(log(Xtheta)-Hlog2pi), -0.5*LL + Lcnt*(log(nXtheta)-Hlog2pi), -0.5*(LL-origLL) + Lcnt*log(nXtheta/Xtheta), Lcnt, origXtot, Xtot,
	  //		 (Ftheta/Xtheta), (Ftheta/nXtheta));
	  printf("\t Xtheta=%0.10f->%0.10f, Ftheta=%0.8f,Hlog2pi=%0.8f,origLL=%0.8f,LL=%0.8f\n", origXtheta, nXtheta, Ftheta, Hlog2pi, origLL, LL);
	  
	  if(REFDEBUG>=3 && ((!WITH_RESBIAS && giter== -1)||(WITH_RESBIAS && giter== -1))){
	    double logLLmSum = 0.0, nlogLLmSum = 0.0;
	    double LLsdSum = 0.0, nLLsdSum = 0.0;
	    for(int m = 0; m < nummaps; m++)
	      if(SxsumM[m] > 0.0){
	        double LLm = LsumM[m] + errsumM[m];
	        double Xtotm = SxsumM[m];
		int scan = Gmap[m]->UniqueScanId;
		double Skm = ScanScale[0][scan].scale;
		double LLsd = -0.5*LLm + LcntM[m]*(log(Xtheta)-Hlog2pi);
		double logLLm = LLsd - (Ftheta/Xtheta)*Xtotm;

		double nXtotm = Xtotm * Skm;
		double nLLm = LLm + (Skm*Skm-1.0) * SxxsumM[m] - 2.0*(Skm - 1.0)*SxysumM[m];
		double nLLsd = -0.5*nLLm + LcntM[m]*(log(nXtheta)-Hlog2pi);
		double nlogLLm = nLLsd - (Ftheta/nXtheta)*nXtotm;
		
		logLLmSum += logLLm;
		nlogLLmSum += nlogLLm;
		LLsdSum += LLsd;
		nLLsdSum += nLLsd;
		printf("      mapid=%d: LL=%0.6f->%0.6f(delta= %0.6f),cum=%0.6f->%0.6f(delta=%0.6f), LLsd=%0.6f->%0.6f(delta=%0.6f,cum=%0.6f->%0.6f)\n\t Lcnt=%0.6f, Xtot=%0.6f->%0.6f\n",
	            m, logLLm, nlogLLm, nlogLLm-logLLm, logLLmSum, nlogLLmSum, nlogLLmSum-logLLmSum, LLsd, nLLsd, nLLsd-LLsd, LLsdSum, nLLsdSum, LcntM[m], Xtotm, nXtotm);
              }
          }
	  fflush(stdout);
	}

        if(REFDEBUG>=3){/* check that MXlen[] * ScanScale[].scale sum up to Xtot */
	  double nMXtot = 0.0;
	  for(int m = 0; m < nummaps; m++){
	    int scan = Gmap[m]->UniqueScanId;
	    nMXtot += MXlen[m] * ScanScale[0][scan].scale;
	  }
	  if(!(fabs(nMXtot - Xtot) < tcnt * 1e-6)){
	    printf("giter=%d:  After rescaling: nMXtot=%0.6f (should match Xtot=%0.6f)\n",giter,nMXtot,Xtot);
	    fflush(stdout);
	    assert(fabs(nMXtot - Xtot) < tcnt * 1e-6);
	  }
	}

	/* compute per scan bppSD values */
	for(int scan = 0; scan < UniqueScans; scan++)
	  Sscalesum[scan] = Sscalesumsq[scan] = Sscalewtsum[scan] = 0.0;
	
	// NOTE ScanScale[0][scan].scale NOT required since scaleSD computed is a normalized SD (fraction)
	for(int i = 0; i < nummaps; i++){
	  int scan = Gmap[i]->UniqueScanId;
	  double incscale = Gmap[i]->incscale;
	  double wt = Gmap[i]->incwt;
	  if(DEBUG>=2) assert(isfinite(wt));
	  if(DEBUG>=2) assert(isfinite(incscale));
	  Sscalesum[scan] += incscale * wt;
	  Sscalesumsq[scan] += incscale*incscale * wt;
	  Sscalewtsum[scan] += wt;
        }
	for(int scan = 0; scan < UniqueScans; scan++){
	  double scaleSD = 0.0;
	  if(Sscalewtsum[scan] > 0.0 && Sscalesum[scan] > 0.0){
	    Sscalesum[scan] /= Sscalewtsum[scan];
	    Sscalesumsq[scan] /= Sscalewtsum[scan];
	    scaleSD = sqrt(max(0.0,Sscalesumsq[scan] - Sscalesum[scan]*Sscalesum[scan])) / Sscalesum[scan];
          }
	  CscanCorrection *p = &ScanScale[0][scan];
	  if(p->mols <= 1)
	    scaleSD = 1.0;
	  else
	    scaleSD *= sqrt((double) p->mols / (double)(p->mols - 1));// approximate Sample size normalization

	  if(DEBUG) assert(isfinite(scaleSD));

	  p->scaleSD = scaleSD;
        }

	int ScaleUndo = 0;

	for(int scan = 0; scan < UniqueScans; scan++)
	  ScanScale[0][scan].cumscale *= ScanScale[0][scan].scale;

	if(VERB){
	  printf("    Rescaling all map site[] and rawsite[] values by Scan Scaling factors: Xtheta= %0.10f->%0.10f, FP= %0.8f->%0.8f,ResBins[0]=%d,%d\n",
		 Xtheta,nXtheta,FP[0],FP[0]*Xtheta/nXtheta,ResBins[0],origResBins[0]);
	  fflush(stdout);
	}

	/*  NOTE : applied to all maps including -subset maps and split maps */

	double Xscale = nXtheta/Xtheta;
	double InvXscale = 1.0/Xscale;
	FP[0] *= InvXscale;
	if(XmapCount[0] > 0){/* correct XmapLength[0] so score_init() computes new Xtheta */
	  if(VERB>=2){
	    double sXtheta = ((XmapLength[0] * PixelLen) / origPixelLen) / ((double)XmapSites[0]) - resKB2 * 0.5;
	    double snXtheta = (((XmapLength[0] * Xscale) * PixelLen)/origPixelLen) / ((double)XmapSites[0]) - resKB2 * 0.5;
	    printf("Predicted score_init(): Xtheta = %0.10f -> %0.10f (XmapLength[0]=%0.6f->%0.6f,XmapSites[0]=%lld,PixelLen=%0.12f,origPixelLen=%0.12f,resKB2=%0.6f)\n", 
		   sXtheta, snXtheta, XmapLength[0], XmapLength[0]*Xscale, XmapSites[0], PixelLen, origPixelLen,resKB2);
	    fflush(stdout);
	  }
	  XmapLength[0] *= Xscale;
	}
	Xtheta = nXtheta;

	if(REFDEBUG_STRICT < 2){
	  if(FP[0] < MINFP)
	    FP[0] = MINFP;
	  else if(FP[0] > MAXFP)
	    FP[0] = MAXFP;
	}
	
	int origcolors = colors;
	if(usecolor)
	  colors = 2;

	// NOTE : if minSNRestimate, ScanScale[0][scan].cumscale will be applied if site[] is ever recomputed from origsite[] after minSNR[] changes */

	#pragma omp parallel for num_threads(numthreads) schedule(dynamic,256) if(numthreads > 1)
	for(int i= 0; i < nummaps; i++){
	  Cmap *pmap = Gmap[i];
	  int scan = pmap->UniqueScanId;
	  FLOAT C = ScanScale[0][scan].scale;
	  for(int c = 0; c < colors; c++){
	    FLOAT *X = pmap->site[c];
	    int M = pmap->numsite[c];
	    for(int j= M+1; j > 0; j--)
	      X[j] *= C;
	  }
	  if(BIAS_TRACE && pmap->id == BIAS_TRACE_ID){
	    #pragma omp critical
	    {
	      printf("Rescaled sites for map id=%lld,scan=%d,scale=%0.10f\n",pmap->id,scan,C);
	      for(int c = 0; c < colors; c++){
		FLOAT *X = pmap->site[c];
		int M = pmap->numsite[c];
		for(int j= 1; j <= M+1; j++)
		  printf("site[%d][%d]= %0.8f\n",c,j,X[j]);
	      }
	      fflush(stdout);
	    }
	  }
	} // parallel for(i= 0 .. totalmaps-1)
	
        double finalLcnt = Lcnt;
        double Xsum = Xtot;
        double finalLL = LL;

	if(maxresbias > mres * 0.5){/* also rescale rawsite[]. NOTE : applied to all maps including -subset maps (if -ScanScaling) and split maps */

	  if(DEBUG) assert(rawsitemaps >= totalmaps);

	  #pragma omp parallel for num_threads(numthreads) schedule(dynamic,256) if(numthreads > 1)
	  for(int i= 0; i < totalmaps; i++){
	    Cmap *pmap = Gmap[i];
	    int scan = pmap->UniqueScanId;
	    FLOAT C = ScanScale[0][scan].scale;
	    for(int c = 0; c < colors; c++){
	      FLOAT *X = pmap->rawsite[c];
	      int M = pmap->numsite[c];
	      for(int j= M+1; j > 0; j--)
		X[j] *= C;
	    }
	    if(BIAS_TRACE && pmap->id == BIAS_TRACE_ID){
	      #pragma omp critical
	      {
		printf("Rescaled rawsites for map id=%lld,scan=%d,scale=%0.10f\n",pmap->id,scan,C);
		for(int c = 0; c < colors; c++){
		  FLOAT *X = pmap->rawsite[c];
		  int M = pmap->numsite[c];
		  for(int j= 1; j <= M+1; j++)
		    printf("rawsite[%d][%d]= %0.8f\n",c,j,X[j]);
		}
		fflush(stdout);
	      }
	    }
	  }

	  if(DEBUG/* >=2 */)
	    for(int c = 0; c < colors; c++)
	      assert(resbiasX[c][ResBins[c]] <= maxresbias);

	  /* also scale resbias[c][] values */
	  for(int c = 0; c < colors; c++){
	    for(int Bin = 0; Bin <= ResBins[c]; Bin++){
	      resbias[c][Bin] *= Xscale;
	      resbiasX[c][Bin] *= Xscale;
	    }
	  }
	  maxresbias *= Xscale;
	  if(maxresbias <= mres * 0.5)
	    maxresbias = mres * 0.5 + 1e-6;/* Fudge : should never happen */

	  if(VERB>=2){
	    printf("maxresbias=%0.6f,ResBins[0]=%d,resbiasX[0][ResBins[0]]= %0.6f\n",maxresbias,ResBins[0],resbiasX[0][ResBins[0]]);
	    fflush(stdout);
	  }
	  if(DEBUG/* >=2 */)
	    for(int c = 0; c < colors; c++)
	      assert(resbiasX[c][ResBins[c]] <= maxresbias);

	  colors = origcolors;/* revert to colors == 1 early */

	  /* NOTE : per-scan rescaling makes the -resbias correction slightly incorrect : redo it */
	  /* NOTE : no need to handle -subset maps or split maps since they will not be re-aligned or output (based on site[]) : _q.cmap has already been output for all maps, if this is the final iteration */
	  if(DEBUG) assert(ResBins[0] > 0);
	  BiasCorrect(Gmap, 0, nummaps, 0);

	  /* NOTE: Due non-linear sizing changes caused by -resbias: LL may get worse, especially for giter > 0 : recompute LL to check */
	  Lsum = errsum = 0.0;
	  finalLcnt = 0.0;
	  Xsum = 0.0;
	  for(int tid = 0; tid < numthreads; tid++)/* NOTE: this initialization cannot be performed inside the parallel loop, if the #pragma parallel is commented out */
	    Tarray1[tid] = Tarray2[tid] = Tarray3[tid] = Tarray4[tid] = 0.0;

	  // accumulate per map changes in predicted logLL to help with debugging
	  double *finalLsumM = 0, *finalLcntM = 0, *finalerrsumM = 0;
	  double *finalSxysumM = 0, *finalSxxsumM = 0, *finalSxsumM = 0;
	  if(REFDEBUG>=3 && ((!WITH_RESBIAS && giter== -1) || (WITH_RESBIAS && giter== -1))){
	    finalLsumM = new double[nummaps*6];
	    finalLcntM = &LsumM[nummaps];
	    finalerrsumM = &LsumM[nummaps*2];
	    finalSxysumM = &LsumM[nummaps*3];
	    finalSxxsumM = &LsumM[nummaps*4];
	    finalSxsumM = &LsumM[nummaps*5];
	    for(int m = 0; m < nummaps; m++)
	      finalLsumM[m] = finalLcntM[m] = finalerrsumM[m] = finalSxysumM[m] = finalSxxsumM[m] = finalSxsumM[m] = 0.0;
	  }

	  // NOTE : non-deterministic with gcc 4.6, even if Tarray*[] are sorted by value, unless -fno-unsafe-math-optimizations is used
	  #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
	  {
	    int tid = 0;
            #ifdef _OPENMP
	    tid = omp_get_thread_num ();
            #endif
	  
	    double myLsum = 0.0;
	    double myLcnt = 0.0;
	    double myerrsum = 0.0;
	    double myXsum = 0.0;

#if !USE_MIC
            #pragma omp for schedule(static,64)
#endif
	    for(int i = 0; i < numerrors; i++){
	      if(USE_MIC && !(((i / 64) % numthreads) == tid)) // NOTE : simulates #pragma omp for schedule(static,64)
		continue;

	      Cinterval *perr = &errors[i];
	      double y = perr->y;

	      int mapid = perr->mapid;
	      if(DEBUG>=2) assert(0 <= mapid && mapid < nummaps);
	      double *X = Gmap[mapid]->site[0];
	      double x = X[perr->R] - X[perr->L];

	      myXsum += x;
	      if(REFDEBUG>=3 && ((!WITH_RESBIAS && giter== -1) || (WITH_RESBIAS && giter== -1)))
		finalSxsumM[mapid] += x;

	      if(ENDFIX>=3 && perr->end && y >= x){
	        if(REFDEBUG>=3 && SDDEBUG && ((!WITH_RESBIAS && giter == -1 && mapid== 1) || (WITH_RESBIAS && giter== -1 && mapid== 20))){
		  int m = mapid;
		//		int scan = Gmap[m]->UniqueScanId;

		  double LLm = finalLsumM[m] + finalerrsumM[m];
		  double Xtotm = finalSxsumM[m];
		  double Frate = Ftheta/Xtheta;
		  double LLsd = -0.5*LLm + finalLcntM[m]*(log(Xtheta) - Hlog2pi);
		  double logLLm = LLsd - Frate*Xtotm;
		
		  printf("    mapid=%d,L=%d,R=%d,end=%d:x->%0.6f(cum=%0.6f),y=%0.6f:LLcum->%0.6f, LLsd->%0.6f: Fterm->%0.6f\n",
	            mapid,perr->L,perr->R,perr->end,x,finalSxsumM[mapid],y,logLLm, LLsd, -Frate*x);
		  fflush(stdout);
	        }
		continue;
	      }
	      double err = y-x;
	      if(RESBIAS_MAXERR2 >= 2 && err * err >= perr->maxerr2)
		continue;

	      double var = A + B * y;
	      if(QUADRATIC_VARIANCE)
		var += R * y*y;
	      if(RES_VARIANCE)
		var += E * perr->resvar;
	      if(DEBUG>=2) assert(var > 0.0);
	      if(!(ENDFIX>=2 && perr->end)){
		myLsum += log(var);
		myLcnt += 1.0;
		if(REFDEBUG>=3 && ((!WITH_RESBIAS && giter == -1)||(WITH_RESBIAS && giter== -1))){
	          finalLsumM[mapid] += log(var);
		  LcntM[mapid] += 1.0;
	        }	      
	      }
	      double Ivar = 1.0/var;
	      myerrsum += err*err*Ivar;
	      if(REFDEBUG>=3 && ((!WITH_RESBIAS && giter == -1)||(WITH_RESBIAS && giter== -1)))
		finalerrsumM[mapid] += err*err*Ivar;

	      Ivar *= x;
	      if(REFDEBUG>=3 && SDDEBUG && ((!WITH_RESBIAS && giter == -1)||(WITH_RESBIAS && giter== -1))){
	        finalSxysumM[mapid] += y*Ivar;
	        finalSxxsumM[mapid] += x*Ivar;
		if((!WITH_RESBIAS && mapid== -1) || (WITH_RESBIAS && mapid== 20)){
	          int m = mapid;

		  double LLm = finalLsumM[m] + finalerrsumM[m];
		  double Xtotm = finalSxsumM[m];
		  double Frate = Ftheta/Xtheta;
		  double LLsd = -0.5*LLm + finalLcntM[m]*(log(Xtheta) - Hlog2pi);
		  double logLLm = LLsd - Frate*Xtotm;

		  printf("    mapid=%d,L=%d,R=%d,end=%d:x=->%0.6f(cum=%0.6f),y=%0.6f,var=%0.8f:Lcum->%0.6f, LLsd->%0.6f:\n\t Gterm->%0.6f,PenErr->%0.8f,Fterm->%0.6f\n",
		       mapid,perr->L,perr->R,perr->end,x, SxsumM[mapid], y, var, logLLm, LLsd, 
		       (ENDFIX>=2 && perr->end) ? 0.0 : -0.5*log(var)+log(Xtheta)-Hlog2pi, -0.5*err*err/var, -Frate*x);
		  fflush(stdout);
	        }
	      }
	    } // omp for

	    Tarray1[tid] = myLsum;
	    Tarray2[tid] = myLcnt;
	    Tarray3[tid] = myerrsum;
	    Tarray4[tid] = myXsum;
	  }  // omp parallel	  

	  qsort(Tarray1, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray2, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray3, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  qsort(Tarray4, numthreads, sizeof(double), (intcmp *)DoubleInc);
	  for(int tid = 0; tid < numthreads; tid++){
	    Lsum += Tarray1[tid];
	    finalLcnt += Tarray2[tid];
	    errsum += Tarray3[tid];
	    Xsum += Tarray4[tid];
	  }

	  finalLL = Lsum + errsum;

	  double LLsd = -0.5*origLL + Lcnt*(log(origXtheta)-Hlog2pi);
	  double logLL = LLsd - (Ftheta/origXtheta)*origXtot;
	  double finalLLsd = -0.5*finalLL + finalLcnt*(log(Xtheta)-Hlog2pi);
	  double finallogLL = finalLLsd - (Ftheta/Xtheta)*Xsum;
	  if(VERB){
	    printf("    After recomputing -resbias : LL = %0.6f -> %0.6f (delta= %0.6f), LLsd = %0.6f -> %0.6f(delta=%0.6f),Lcnt=%0.8f->%0.8f\n",
		   logLL,finallogLL, finallogLL-logLL, LLsd, finalLLsd, finalLLsd - LLsd, Lcnt, finalLcnt);
	    if(REFDEBUG>=3 && (WITH_RESBIAS && giter==-1)){
	      double logLLmSum = 0.0, nlogLLmSum = 0.0;
	      double LLsdSum = 0.0, nLLsdSum = 0.0;
	      for(int m = 0; m < nummaps; m++)
		if(finalSxsumM[m] > 0.0){
	          double LLm = LsumM[m] + errsumM[m];
		  double Xtotm = SxsumM[m];
		  double LLsd = -0.5*LLm + LcntM[m]*(log(origXtheta)-Hlog2pi);
		  double logLLm = LLsd - (Ftheta/origXtheta)*Xtotm;

		  double nLLm = finalLsumM[m] + finalerrsumM[m];
		  double nXtotm = finalSxsumM[m];
		  double nLLsd = -0.5*nLLm + finalLcntM[m]*(log(Xtheta)-Hlog2pi);
		  double nlogLLm = nLLsd - (Ftheta/Xtheta)*nXtotm;
		  
		  logLLmSum += logLLm;
		  nlogLLmSum += nlogLLm;
		  LLsdSum += LLsd;
		  nLLsdSum += nLLsd;
		  printf("      mapid=%d: LL=%0.6f->%0.6f(delta= %0.6f),cum=%0.6f->%0.6f(delta=%0.6f), LLsd=%0.6f->%0.6f(delta=%0.6f,cum=%0.6f->%0.6f)\n\t Lcnt=%0.6f, Xtot=%0.6f->%0.6f\n",
			 m, logLLm, nlogLLm, nlogLLm-logLLm, logLLmSum, nlogLLmSum, nlogLLmSum-logLLmSum, LLsd, nLLsd, nLLsd-LLsd, LLsdSum, nLLsdSum, LcntM[m], Xtotm, nXtotm);
		}
	    }
	    fflush(stdout);
	  }

	  if(finallogLL < logLL - 1e-6 && !(giter == RefRepeats-1 && giter2==RefRepeats2-1)){// NEW12 : avoid doing this if new resbias code can correct this in next iteration
	    if(VERB){
	      printf("   Undoing Rescaling of map site[] and rawsite[] values by Scan Scaling factors\n");
	      fflush(stdout);
	    }
	    /*  NOTE : applied to all maps including -subset maps and split maps */

	    for(int scan = 0; scan < UniqueScans; scan++)
	      ScanScale[0][scan].cumscale /= ScanScale[0][scan].scale;
	    double Xscale = nXtheta/origXtheta;
	    double InvXscale = 1.0/Xscale;
	    FP[0] *= Xscale;
	    if(XmapCount[0] > 0)/* correct XmapLength[0] so score_init() computes new Xtheta */
	      XmapLength[0] *= InvXscale;
	    Xtheta = origXtheta;
	    if(REFDEBUG_STRICT < 2){
	      if(FP[0] < MINFP)
		FP[0] = MINFP;
	      else if(FP[0] > MAXFP)
		FP[0] = MAXFP;
	    }

	    int origcolors = colors;
	    if(usecolor)
	      colors = 2;

            #pragma omp parallel for num_threads(numthreads) schedule(dynamic,256) if(numthreads > 1)
	    for(int i= 0; i < totalmaps; i++){
	      Cmap *pmap = Gmap[i];
	      int scan = pmap->UniqueScanId;
	      FLOAT C = 1.0/ScanScale[0][scan].scale;
	      for(int c = 0; c < colors; c++){
		FLOAT *X = pmap->site[c];
		int M = pmap->numsite[c];
		for(int j= M+1; j > 0; j--)
		  X[j] *= C;
	      }
	      if(BIAS_TRACE && pmap->id == BIAS_TRACE_ID){
	        #pragma omp critical
		{
		  printf("After undoing rescaling of sites for map id=%lld,scan=%d,C=%0.12f\n",pmap->id,scan,C);
		  for(int c = 0; c < colors; c++){
		    FLOAT *X = pmap->site[c];
		    int M = pmap->numsite[c];
		    for(int j= 1; j <= M+1; j++)
		      printf("site[%d][%d]= %0.8f\n",c,j,X[j]);
		  }
		  fflush(stdout);
		}
	      }
	    }

	    if(maxresbias > mres * 0.5){/* also rescale rawsite[]. NOTE : applied to all maps including -subset maps (if -ScanScaling) and split maps */
	      if(DEBUG) assert(rawsitemaps >= totalmaps);

	      if(VERB>=2){
		printf("Before Undo:maxresbias=%0.6f,ResBins[0]=%d,resbiasX[0][ResBins[0]]= %0.6f\n",maxresbias,ResBins[0],resbiasX[0][ResBins[0]]);
		fflush(stdout);
	      }

              #pragma omp parallel for num_threads(numthreads) schedule(dynamic,256) if(numthreads > 1)
	      for(int i= 0; i < totalmaps; i++){
		Cmap *pmap = Gmap[i];
		int scan = pmap->UniqueScanId;
		FLOAT C = 1.0/ScanScale[0][scan].scale;
		for(int c = 0; c < colors; c++){
		  FLOAT *X = pmap->rawsite[c];
		  int M = pmap->numsite[c];
		  for(int j= M+1; j > 0; j--)
		    X[j] *= C;
		}
		if(BIAS_TRACE && pmap->id == BIAS_TRACE_ID){
	          #pragma omp critical
		  {
		    printf("After undoing rescaling rawsites for map id=%lld,scan=%d,scale=%0.10f\n",pmap->id,scan,C);
		    for(int c = 0; c < colors; c++){
		      FLOAT *X = pmap->rawsite[c];
		      int M = pmap->numsite[c];
		      for(int j= 1; j <= M+1; j++)
			printf("rawsite[%d][%d]= %0.8f\n",c,j,X[j]);
		    }
		    fflush(stdout);
		  }
		}
	      }

	      /* also scale resbias[c][] values */
	      for(int c = 0; c < colors; c++){
		for(int Bin = 0; Bin <= ResBins[c]; Bin++){
		  resbias[c][Bin] *= InvXscale;
		  resbiasX[c][Bin] *= InvXscale;
		}
	      }
	      maxresbias *= InvXscale;
	      if(maxresbias <= mres * 0.5)
		maxresbias = mres * 0.5 + 1e-6;/* Fudge : should never happen */
	      if(VERB>=2){
		printf("After Undo:maxresbias=%0.6f,ResBins[0]=%d,resbiasX[0][ResBins[0]]= %0.6f\n",maxresbias,ResBins[0],resbiasX[0][ResBins[0]]);
		fflush(stdout);
	      }
	      if(DEBUG/* >=2 */)
		for(int c = 0; c < colors; c++)
		  assert(resbiasX[c][ResBins[c]] <= maxresbias);

	      colors = origcolors;

	      /* NOTE : per-scan rescaling makes the -resbias correction slightly incorrect : redo it */
	      if(DEBUG) assert(ResBins[0] > 0);
	      /* NOTE : no need to handle -subset maps or split maps since they will not be re-aligned or output (based on site[]) : _q.cmap has already been output for all maps, if this is the final iteration */
	      BiasCorrect(Gmap, 0, nummaps, 0);
	    } // if(maxresbias > mres * 0.5)
	    
	    colors = origcolors;// in case !(maxresbias > mres * 0.5)

            /* restore original  values for LL,nXtheta,Xtot */
	    LL = origLL;
            nXtheta = Xtheta = origXtheta;
            Xtot = origXtot;
	    ScaleUndo = 1;
	  }// if(finallogLL < logLL - 1e-6)
        }// if(maxresbias > mres * 0.5)

	colors = origcolors;// in case !(maxresbias > mres * 0.5)

	if(DEBUG>=2) assert(colors==1);

	if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	  if(DEBUG) assert(logLRarray);
	  (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	  double LRsum = 0.0;
	  double LRsdsum = 0.0;
	  lcnt= 0;
	  double *origLRarray = new double[nummaps];
	  double *origSDarray = new double[nummaps];
	  double *origXlen = new double[nummaps];
	  for(int mid = 0; mid < nummaps; mid++){
	    origLRarray[mid] = logLRarray[mid];
	    origSDarray[mid] = logSDarray[mid];
	    origXlen[mid] = Xlen[mid];
	    Xlen[mid] = -1.0;
	  }
	  double ntotXlen = 0.0;
	  for(size_t i = 0; i < numaligns; i++){
	    Calign *align = alignment[i];
	    if(!align || align->numpairs <= 1)
	      continue;
	    int mid = align->mapid2;
	    if(DEBUG>=2)assert(!Gmap[mid]->origmap);
	    if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	      if(DEBUG) assert(BestRefExt==0.0);
	      if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	    }
	    int rid = align->mapid1;
	    if(DEBUG>=2){
	      int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	      assert(origgoodalign);
	      int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	      assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	    }
	    FLOAT *X = Gmap[mid]->site[0];
	    int M = Gmap[mid]->numsite[0];
	    FLOAT *Y = refmap[rid]->site[0];
	    int N = refmap[rid]->numsite[0];
	    double LRsd = 0.0;
	    double XL = 0.0;
	    double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
			      /* ((!WITH_RESBIAS && giter == -1 && mid== 1)||(WITH_RESBIAS && giter== -1 && mid== 20)) ? 1 : 0*/ 0, SDDEBUG ? &LRsd : 0, SDDEBUG ? &XL : 0);
	    logLRarray[mid] = LR;
	    logSDarray[mid] = LRsd;
	    Xlen[mid] = XL;
	    if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	      continue;
	    LRsum += LR;
	    lcnt++;
	    if(SDDEBUG){
	      LRsdsum += LRsd;
	      ntotXlen += XL;
	    }
	  }
	  double LLsd = -0.5*origLL + Lcnt*(log(origXtheta)-Hlog2pi);
	  double logLL = LLsd - (Ftheta/origXtheta)*origXtot;
	  double nLLsd = -0.5*LL + Lcnt*(log(Xtheta)-Hlog2pi);
	  double nlogLL =  nLLsd - (Ftheta/Xtheta)*Xtot;

	  double finalLLsd = -0.5*finalLL + finalLcnt*(log(Xtheta)-Hlog2pi);
	  double finallogLL = finalLLsd - (Ftheta/Xtheta)*Xsum;
	  if(SDDEBUG){
	    printf("After ScanCorrection:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd=%0.6f -> %0.6f, Xtot=%0.6f->%0.6f),UniqueScans=%d\n",
		   (unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt, LRsdsum/lcnt, totXlen, ntotXlen,UniqueScans);
	    if(maxresbias > mres * 0.5)
	      printf("    Predicted: LL= %0.6f -> %0.6f -> %0.6f (delta= %0.6f), LLsd= %0.6f -> %0.6f -> %0.6f (delta=%0.6f),Lcnt=%0.6f->%0.6f, Xtot=%0.6f->%0.6f->%0.6f\n",
		     logLL/lcnt, nlogLL/lcnt, finallogLL/lcnt, (finallogLL-logLL)/lcnt, LLsd/lcnt, nLLsd/lcnt, finalLLsd/lcnt, (finalLLsd - LLsd)/lcnt, Lcnt, finalLcnt, origXtot, Xtot,Xsum);
	    else
	      printf("    Predicted: LL= %0.6f -> %0.6f (delta= %0.6f), LLsd= %0.6f -> %0.6f (delta=%0.6f), Lcnt=%0.6f, Xtot=%0.6f->%0.6f\n",
		     logLL/lcnt, nlogLL/lcnt, (nlogLL-logLL)/lcnt, LLsd/lcnt, nLLsd/lcnt, (nLLsd - LLsd)/lcnt, Lcnt, origXtot, Xtot);
	    printf("    Originally: LL= %0.6f -> %0.6f (delta= %0.6f), LLsd= %0.6f -> %0.6f (delta=%0.6f),Lcnt=%0.6f, Xtot=%0.6f->%0.6f, Frate=%0.7f->%0.6f\n",
		   logLL, nlogLL, nlogLL-logLL, LLsd, nLLsd, nLLsd - LLsd, Lcnt, origXtot, Xtot, (Ftheta/origXtheta), (Ftheta/Xtheta));
	    printf("\t Xtheta=%0.10f->%0.10f, Ftheta=%0.8f,Hlog2pi=%0.8f,origLL=%0.8f,LL=%0.8f\n", origXtheta, Xtheta, Ftheta, Hlog2pi, origLL, LL);
          } else
	    printf("After ScanCorrection:lcnt=%llu:score=%0.6f -> %0.6f,UniqueScans=%d\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt,UniqueScans);
	  fflush(stdout);

	  if(DEBUG && (!(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt) || 
		       (SDDEBUG && !(fabs(ntotXlen - Xtot) < lcnt * 1e-6)) || 
		       (SDDEBUG && !(fabs(totXlen - origXtot) < lcnt * 1e-6)) ||
	               (SDDEBUG && !(fabs(logLRsdsum - LLsd) < 1e-6*lcnt)) ||
	               (SDDEBUG && !(fabs(LRsdsum - nLLsd) < 1e-6*lcnt)) || (DEBUG>=2 && WITH_RESBIAS && giter== -1)))  {
	    /*	    if(maxresbias > mres * 0.5 && !(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt)){
	      printf("WARNING:logLR is worse after ScanCorrection (can happen due to -resbias)\n");
	      fflush(stdout);
	      }*/
	    if(SDDEBUG && maxresbias > mres * 0.5 && !(fabs(LRsdsum - nLLsd) < 1e-6*lcnt)) {
	      printf("WARNING:LRsd=%0.6f does not match value predicted during Scan Correction of %0.6f (can happen due to -resbias)\n", LRsdsum, nLLsd);
	      fflush(stdout);
	    }
	    if(SDDEBUG && maxresbias > mres * 0.5 && !(fabs(ntotXlen - Xtot) < lcnt * 1e-6)){
	      printf("WARNING:ntotXlen=%0.6f not as predicted during Scan Correction of Xtot=%0.6f (can happen due to -resbias)\n", ntotXlen, Xtot);
	      fflush(stdout);
	    }
	    if(!(maxresbias > mres * 0.5) || !(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt) || 
	       (SDDEBUG && !(fabs(totXlen - origXtot) < lcnt * 1e-6)) || (SDDEBUG && !(fabs(logLRsdsum - LLsd) < 1e-6*lcnt)) || (DEBUG>=2 && WITH_RESBIAS && giter== -1)){
	      if(VERB){
	        double *scan1 = new double[UniqueScans];
	        double *scan2 = new double[UniqueScans];
	        double *scan3 = new double[UniqueScans];
	        double *scan4 = new double[UniqueScans];
		for(int scan = 0; scan < UniqueScans; scan++)
		  scan1[scan] = scan2[scan] = scan3[scan] = scan4[scan] = 0.0;
		double sum1 = 0.0,sum2 = 0.0, sum3 = 0.0, sum4 = 0.0;
		double Xsum1 = 0.0, Xsum2 = 0.0, Xsum3 = 0.0, Xsum4 = 0.0;
		for(size_t i = 0; i < numaligns; i++){
		  Calign *align = alignment[i];
		  if(!align || align->numpairs <= 1)
		    continue;
		  int mid = align->mapid2;
		  if(DEBUG>=2)assert(!Gmap[mid]->origmap);
		  if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		    if(DEBUG) assert(BestRefExt==0.0);
		    continue;
		  }
		  if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		    continue;
		  sum1 += origLRarray[mid];
		  sum2 += logLRarray[mid];
		  sum3 += origSDarray[mid];
		  sum4 += logSDarray[mid];
		  int scan = Gmap[mid]->UniqueScanId;		  
		  Xsum1 += origXlen[mid];
		  Xsum2 += Xlen[mid];
	          if(REFDEBUG>=3){
		    Xsum3 += MXlen[mid];
		    Xsum4 += MXlen[mid] * ScanScale[0][scan].scale;
		    printf("mid=%4d,id=%8lld,scan=%3d:logLRarray[mid]=%0.6f->%0.6f (delta=%9.6f,cum=%0.6f->%0.6f), LLsd=%9.6f->%9.6f(delta=%9.6f,cum=%0.6f->%0.6f)\n",
			   mid,Gmap[mid]->id,scan,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid],sum1, sum2,
			   origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4);
		    printf("\t Xlen=%0.6f->%0.6f,cum=%0.6f->%0.6f(MXlen=%0.6f->%0.6f,cum=%0.6f->%0.6f),Scale=%0.12f\n",origXlen[mid],Xlen[mid],Xsum1,Xsum2,
			   MXlen[mid], MXlen[mid] * ScanScale[0][scan].scale, Xsum3, Xsum4, ScanScale[0][scan].scale);
		  } else
		    printf("mid=%4d,id=%8lld,scan=%3d:logLRarray[mid]=%0.6f->%0.6f (delta=%9.6f,cum=%0.6f->%0.6f), LLsd=%9.6f->%9.6f(delta=%9.6f,cum=%0.6f->%0.6f)\n\t Xlen=%0.6f->%0.6f,Scale=%0.12f\n",
			   mid,Gmap[mid]->id,scan,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid],sum1, sum2,
			   origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4,origXlen[mid],Xlen[mid], ScanScale[0][scan].scale);

		  scan1[scan] += origLRarray[mid];
		  scan2[scan] += logLRarray[mid];
		  scan3[scan] += origSDarray[mid];
		  scan4[scan] += logSDarray[mid];
		}
		for(int k = 0; k < UniqueScans; k++)
		  if(fabs(scan1[k]-scan2[k]) >= 1e-6)
		    printf("scan=%d: logLR=%0.6f -> %0.6f (delta=%0.6f), LLsd=%0.6f->%0.6f(delta=%0.6f)\n",
			   k, scan1[k],scan2[k],scan2[k]-scan1[k],scan3[k],scan4[k],scan4[k]-scan3[k]);
		fflush(stdout);
		delete [] scan1;
		delete [] scan2;
		delete [] scan3;
		delete [] scan4;
	      }

	      if(!(maxresbias > mres * 0.5)){
	        if(SDDEBUG) assert(fabs(ntotXlen - Xtot) < lcnt * 1e-6);
		if(SDDEBUG) assert(fabs(LRsdsum - nLLsd) < 1e-6*lcnt);
              }
	      assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	      if(SDDEBUG) assert(fabs(totXlen - origXtot) < lcnt * 1e-6);
	      if(SDDEBUG) assert(fabs(logLRsdsum - LLsd) < 1e-6*lcnt);

	      /*	      if(WITH_RESBIAS && giter==0){
		printf("Debug exit\n");
		fflush(stdout); 
		exit(1);
		}*/
            }
	  }
	  if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	  logLRsum = LRsum;
	  if(SDDEBUG){
	    logLRsdsum = LRsdsum;
	    totXlen = ntotXlen;
	  }
	  delete [] origLRarray;
	  delete [] origSDarray;
	  delete [] origXlen;
	  score_free(0,numrefmaps);
	}

	if(DEBUG>=2) assert(colors==1);

        if(1 /* HERE giter == RefRepeats-1*/ && !ScaleUndo){
	  /*  NOTE : applied to all maps including -subset maps and split maps */

	  /* Normalize ScanScale[0][scan].cumscale so average value weighted by Molecule Length Sum is 1.0 and do reverse correction on PixelLen, res, resSD,
	     (without changing maps or anything else, since these two changes cancel each other) */
	  for(int scan = 0; scan < UniqueScans; scan++)
	    ThetaDelta[scan] = 0.0;

	  for(int m = 0; m < totalmaps; m++){
	    Cmap *pmap = Gmap[m];
	    int M = pmap->numsite[0];
	    double *X = pmap->site[0];
	    int scan = pmap->UniqueScanId;
	    if(DEBUG) assert(0 <= scan && scan < UniqueScans);
	    ThetaDelta[scan] += X[M+1];
	  }
	  double wtsum = 0.0, ScaleSum = 0.0;
	  for(int scan = 0; scan < UniqueScans; scan++){
	    wtsum += ThetaDelta[scan];
	    ScaleSum += ScanScale[0][scan].cumscale * ThetaDelta[scan];
	  }  
	  if(ScaleSum > 0.0){
  	    double C = wtsum / ScaleSum;
	    for(int scan = 0; scan < UniqueScans; scan++)
	      ScanScale[0][scan].cumscale *= C;
	    if(VERB){
	      printf("Rescaling Scan Scaling factors by %0.10f, bpp=%0.6f->%0.6f,wall time=%0.6f\n",C,PixelLen*1000.0, PixelLen*1000.0/C,wtime());
	      fflush(stdout);
	    }
	    PixelLen /= C;
	    if(XmapCount[0] > 0)/* correct XmapLength[0] so score_init() computes same Xtheta */
	      XmapLength[0] *= C;
	    res[0] *= C;
	    resSD[0] *= C;
	    if(REFDEBUG_STRICT < 2){
	      res[0] = max(res[0],MinRes);
	      res[0] = min(res[0],MaxRes);
	      resSD[0] = max(resSD[0],MinResSD);
	      resSD[0] = min(resSD[0],MaxResSD);
	    }
          }

	  if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	    if(DEBUG) assert(logLRarray);
	    (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	    double LRsum = 0.0;
	    double LRsdsum = 0.0;
	    lcnt= 0;
	    double *origLRarray = new double[nummaps];
	    double *origSDarray = new double[nummaps];
	    double *origXlen = new double[nummaps];
	    for(int mid = 0; mid < nummaps; mid++){
	      origLRarray[mid] = logLRarray[mid];
	      origSDarray[mid] = logSDarray[mid];
	      origXlen[mid] = Xlen[mid];
	      Xlen[mid] = -1.0;
	    }
	    double ntotXlen = 0.0;
	    for(size_t i = 0; i < numaligns; i++){
	      Calign *align = alignment[i];
	      if(!align || align->numpairs <= 1)
		continue;
	      int mid = align->mapid2;
	      if(DEBUG>=2)assert(!Gmap[mid]->origmap);
	      if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		if(DEBUG) assert(BestRefExt==0.0);
		if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
		continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	      }
	      int rid = align->mapid1;
	      if(DEBUG>=2){
		int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
		assert(origgoodalign);
		int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
		assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	      }
	      FLOAT *X = Gmap[mid]->site[0];
	      int M = Gmap[mid]->numsite[0];
	      FLOAT *Y = refmap[rid]->site[0];
	      int N = refmap[rid]->numsite[0];
	      double LRsd = 0.0;
	      double XL = 0.0;
	      double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,
				/* ((!WITH_RESBIAS && giter == -1 && mid== 1)||(WITH_RESBIAS && giter== -1 && mid== 43)) ? 1 : 0 */ 0, SDDEBUG ? &LRsd : 0, SDDEBUG ? &XL : 0);
	      logLRarray[mid] = LR;
	      logSDarray[mid] = LRsd;
	      Xlen[mid] = XL;
	      if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		continue;
	      LRsum += LR;
	      lcnt++;
	      if(SDDEBUG){
		LRsdsum += LRsd;
		ntotXlen += XL;
	      }
	    }
	    if(SDDEBUG)
	      printf("After Normalizing ScanCorrection:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd=%0.6f -> %0.6f,Xtot=%0.6f->%0.6f),UniqueScans=%d\n",
		     (unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt, LRsdsum/lcnt, totXlen, ntotXlen,UniqueScans);
	    else
	      printf("After Normalizing ScanCorrection:lcnt=%llu:score=%0.6f -> %0.6f,UniqueScans=%d\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt,UniqueScans);
	    fflush(stdout);

	    if(DEBUG && (!(fabs(LRsum - logLRsum) < (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt) || (SDDEBUG && !(fabs(ntotXlen - totXlen) < lcnt * 1e-6)) ||
			 (SDDEBUG && !(fabs(logLRsdsum - LRsdsum) < 1e-6*lcnt)))){
	      if(VERB){
		double sum1 = 0.0,sum2 = 0.0, sum3 = 0.0, sum4 = 0.0;
		double Xsum1 = 0.0, Xsum2 = 0.0, Xsum3 = 0.0, Xsum4 = 0.0;
		for(size_t i = 0; i < numaligns; i++){
		  Calign *align = alignment[i];
		  if(!align || align->numpairs <= 1)
		    continue;
		  int mid = align->mapid2;
		  if(DEBUG>=2)assert(!Gmap[mid]->origmap);
		  if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
		    if(DEBUG) assert(BestRefExt==0.0);
		    continue;
		  }
		  if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		    continue;
		  sum1 += origLRarray[mid];
		  sum2 += logLRarray[mid];
		  sum3 += origSDarray[mid];
		  sum4 += logSDarray[mid];
		  int scan = Gmap[mid]->UniqueScanId;		  
		  Xsum1 += origXlen[mid];
		  Xsum2 += Xlen[mid];
	          if(REFDEBUG>=3){
		    Xsum3 += MXlen[mid];
		    Xsum4 += MXlen[mid] * ScanScale[0][scan].scale;
		    printf("mid=%4d,id=%8lld,scan=%3d:logLRarray[mid]=%0.6f->%0.6f (delta=%9.6f,cum=%0.6f->%0.6f), LLsd=%9.6f->%9.6f(delta=%9.6f,cum=%0.6f->%0.6f)\n",
			   mid,Gmap[mid]->id,scan,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid],sum1, sum2,
			   origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4);
		    printf("\t Xlen=%0.6f->%0.6f,cum=%0.6f->%0.6f(MXlen=%0.6f->%0.6f,cum=%0.6f->%0.6f),Scale=%0.12f\n",origXlen[mid],Xlen[mid],Xsum1,Xsum2,
			   MXlen[mid], MXlen[mid] * ScanScale[0][scan].scale, Xsum3, Xsum4, ScanScale[0][scan].scale);
		  } else
		    printf("mid=%4d,id=%8lld,scan=%3d:logLRarray[mid]=%0.6f->%0.6f (delta=%9.6f,cum=%0.6f->%0.6f), LLsd=%9.6f->%9.6f(delta=%9.6f,cum=%0.6f->%0.6f)\n\t Xlen=%0.6f->%0.6f,Scale=%0.12f\n",
			   mid,Gmap[mid]->id,scan,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid],sum1, sum2,
			   origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4,origXlen[mid],Xlen[mid], ScanScale[0][scan].scale);
		}
		fflush(stdout);
	      }

	      assert(fabs(LRsum - logLRsum) < (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	      if(SDDEBUG) assert(fabs(totXlen - ntotXlen) < lcnt * 1e-6);
	      if(SDDEBUG) assert(fabs(logLRsdsum - LRsdsum) < 1e-6*lcnt);
	    }

	    if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	    logLRsum = LRsum;
	    if(SDDEBUG){
	      logLRsdsum = LRsdsum;
	      totXlen = ntotXlen;
	    }
	    delete [] origLRarray;
	    delete [] origSDarray;
	    delete [] origXlen;
	    score_free(0,numrefmaps);
	  }// if(REFDEBUG ...) 
	}// if(!ScaleUndo)

	if(VERB && giter == RefRepeats-1){
	  char filename[PATH_MAX];
	  if(giter2 == RefRepeats2-1)
	    sprintf(filename,"%s.scan",output_prefix);	      
	  else
	    sprintf(filename,"%s.scan%d",output_prefix,giter2+1);	      
	  if(!checkFile(filename)){
	    printf("Generating %s (Scan Scaling file)\n",filename);
	    fflush(stdout);

	    FILE *fp;
	    if((fp = fopen(filename,"w"))==NULL){
              int eno = errno;
	      char *err = strerror(eno);
	      printf("failed to open file %s for writing .scan file:errno=%d:%s\n",filename,eno,err);
	      fflush(stdout);exit(1);
            }

	    /* write out commandline */
	    printversion(fp);

	    fprintf(fp,"# Label Channels:\t%d\n", colors);
	    fprintf(fp,"Scan\tRunIndex\tScanNumber\tScaling   \tTotalMols\tTotalAvgLen\tAlignedMols\tAlignedAvgLen\tAligned%%\tEndoutlier%%\tbpp   \tbppSD   \n");

	    for(int k = 0; k < UniqueScans; k++){
	      CscanCorrection *p = &ScanScale[0][k];
		fprintf(fp,"%3d \t%4d    \t%4d      \t%10.8f\t%6d   \t%8.3f   \t%6d    \t%8.3f     \t%7.3f%%\t%7.3f%%\t%6.2f\t%6.2f\n",
		       k, p->RunIndex+1, p->ScanNumber, p->cumscale, p->totmols,p->totlen/max(1,p->totmols), p->mols, p->len/max(1,p->mols), 100.0*p->mappedlen/max(0.001,p->totlen),
			p->mols <= 0 ? 0.0 : (1.0 - p->mappedlen/max(0.001,p->len))*100.0,p->cumscale*PixelLen*1000.0,p->mols <= 1 ? 0.0 : p->scaleSD*p->cumscale*PixelLen*1000.0);
            }
	    fclose(fp);
	  }
        }

	if(REFDEBUG>=3){
	  delete [] MXlen;
	  MXlen = NULL;
	}
	if(REFDEBUG>=3){
	  delete [] LsumM;
	  LsumM = NULL;
	}
      }/* if(ScanCorrection && UniqueScans > 1) */
    }/* if(numerrors > 0) */

    if(DEBUG) assert(colors==1);

    if(RESDATA && numresdata > 0){/* optimize res and resSD */
      int numthreads = 1;
      #ifdef _OPENMP
      numthreads = MaxThreads; // WAS omp_get_max_threads();
      //      numthreads = min(numthreads,MaxThreads);
      if(numthreads > numresdata/256)
	numthreads = max(1,numresdata/256);
      #endif

      if(RESDATA_FIX){  /* resdata[] should be updated to reflect -resbias and X scaling C : simply update values from Gmap[]->site[][] */
        #pragma omp parallel for schedule(static,256) num_threads(numthreads) if(numthreads > 1)
	for(int i = 0; i < numresdata; i++){
	  Cresdata *pres = &resdata[i];
	  Calign *align = pres->align;
	  int mapid = align->mapid2;
	  Cmap *Xmap = Gmap[mapid];
	  FLOAT *X = Xmap->site[0];	  
	  int M = Xmap->numsite[0];
	  double escale = ScaleDeltaBPP ? 1.0 : (align->numpairs > 0 && align->scaleID) ? ScaleFactor[align->scaleID] : 1.0;
	  if(pres->n)
	    pres->x = escale * (align->orientation ? X[M+1-(pres->J-pres->m)] - X[M+1-pres->J] : X[pres->J] - X[pres->J - pres->m]);
	  if(pres->Ip && pres->n1)
	    pres->x1 = escale * (align->orientation ? X[M+1-(pres->J1-pres->m1)] - X[M+1-pres->J1] : X[pres->J1] - X[pres->J1 - pres->m1]);
	}
      }

      double bestRes = res[0];
      double bestResSD = resSD[0];
      double bestLL = resLL(resdata,numresdata, numthreads, Tarray1, 0);
      double origLL = bestLL;

      if(VERB>=2){
	printf("res=%0.4f,resSD=%0.4f:LL=%0.6f: numresdata = %d\n",res[0],resSD[0],bestLL, numresdata);
	fflush(stdout);
      }

      /* perform goldenmean search on res[0] in range bestRes - 0.5 .. bestRes + 0.5 */
      double phi = (1.0 + sqrt(5.0))*0.5;
      double resphi = 2.0 - phi;

      double Low = max(MinRes,bestRes - 0.500);
      double High = min(MaxRes,bestRes + 0.500);
      double Mid = bestRes;
      while(max(High - Mid, Mid - Low) > 0.0001){
	double Lsum;
	if(High - Mid > Mid - Low){
	  res[0] = Mid + resphi * (High - Low);
	  Lsum = resLL(resdata,numresdata,numthreads,Tarray1, 0);

	  if(Lsum > bestLL){
	    bestLL = Lsum;
	    Low = Mid;
	    Mid = res[0];
	  } else
	    High = res[0];
	} else {
	  res[0] = Mid - resphi * (High - Low);
	  Lsum = resLL(resdata,numresdata,numthreads,Tarray1, 0);

	  if(Lsum > bestLL){
	    bestLL = Lsum;
	    High = Mid;
	    Mid = res[0];
	  } else 
	    Low = res[0];
	}
	if(VERB>=2){
	  printf("res=%0.4f,resSD=%0.4f:LL=%0.6f (best:res=%0.4f,resSD=%0.4f,LL=%0.6f), res:Low=%0.4f,Mid=%0.4f,High=%0.4f\n",res[0],resSD[0],Lsum, Mid, bestResSD, bestLL,Low,Mid,High);
	  fflush(stdout);
	}
      }
      if(VERB){
	printf("  res= %0.6f -> %0.6f (score= %0.6f -> %0.6f, lcnt=%lu),wall time=%0.6f\n",bestRes,Mid,origLL/max((size_t)1,lcnt), bestLL/max((size_t)1,lcnt),lcnt,wtime());
	fflush(stdout);
      }
      bestRes = res[0] = Mid;
      
      resKB = res[0] * PixelLen;/* in case res changed */

      if(DEBUG>=2) assert(colors==1);

      if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	if(DEBUG) assert(logLRarray);

	(void)resLL(resdata,numresdata, numthreads, Tarray1, 0);

	(void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	double LRsum = 0.0;
	double LRsdsum = 0.0;
	lcnt= 0;
	for(size_t i = 0; i < numaligns; i++){
	  Calign *align = alignment[i];
	  if(!align || align->numpairs <= 1)
	    continue;
	  int mid = align->mapid2;
	  if(DEBUG>=2)assert(!Gmap[mid]->origmap);
	  if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	    if(DEBUG) assert(BestRefExt==0.0);
	    if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	    continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	  }
	  int rid = align->mapid1;
	  if(DEBUG>=2){
	    int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	    assert(origgoodalign);
	    int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	    assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	  }
	  FLOAT *X = Gmap[mid]->site[0];
	  int M = Gmap[mid]->numsite[0];
	  FLOAT *Y = refmap[rid]->site[0];
	  int N = refmap[rid]->numsite[0];
	  double LRsd = 0.0;
	  double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1,0,SDDEBUG ? &LRsd : 0,0);
	  logLRarray[mid] = LR;
	  logSDarray[mid] = LRsd;
	  if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	    continue;
	  LRsum += LR;
	  lcnt++;
	  if(SDDEBUG)
	    LRsdsum += LRsd;
	}
	if(SDDEBUG)
	  printf("After updating res:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd=%0.6f -> %0.6f)\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt, LRsdsum/lcnt);
	else
	  printf("After updating res:lcnt=%llu:score=%0.6f -> %0.6f\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	fflush(stdout);
	if(DEBUG) assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	logLRsum = LRsum;
	if(SDDEBUG)
	  logLRsdsum = LRsdsum;
	score_free(0,numrefmaps);
      }

      /* perform goldenmean search on resSD */
      origLL = bestLL;
      Low = max(MinResSD,bestResSD - 0.100);
      High = min(MaxResSD,bestResSD + 0.100);
      Mid = bestResSD;

      while(max(High - Mid, Mid - Low) > 0.0001){
	double Lsum;
	if(High - Mid > Mid - Low){
	  resSD[0] = Mid + resphi * (High - Low);
	  Lsum = resLL(resdata,numresdata,numthreads,Tarray1,0);

	  if(Lsum > bestLL){
	    bestLL = Lsum;
	    Low = Mid;
	    Mid = resSD[0];
	  } else
	    High = resSD[0];
	} else {
	  resSD[0] = Mid - resphi * (High - Low);
	  Lsum = resLL(resdata,numresdata,numthreads,Tarray1,0);

	  if(Lsum > bestLL){
	    bestLL = Lsum;
	    High = Mid;
	    Mid = resSD[0];
	  } else 
	    Low = resSD[0];
	}
	if(VERB>=2){
	  printf("res=%0.4f,resSD=%0.4f:LL=%0.6f (best:res=%0.4f,resSD=%0.4f,LL=%0.6f), resSD:Low=%0.4f,Mid=%0.4f,High=%0.4f\n",res[0],resSD[0],Lsum, bestRes, Mid,bestLL,Low,Mid,High);
	  fflush(stdout);
	}
      }
      if(VERB){
	printf("  resSD= %0.6f -> %0.6f (score= %0.6f -> %0.6f, lcnt=%lu),wall time=%0.6f\n",bestResSD,Mid,origLL/max((size_t)1,lcnt), bestLL/max((size_t)1,lcnt),lcnt,wtime());
	fflush(stdout);
      }
      bestResSD = resSD[0] = Mid;

      IresSD = 1.0/(resSD[0] * PixelLen * sqrt(2.0));/* in case resSD changed */

      if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	if(DEBUG) assert(logLRarray);
	
	(void)resLL(resdata,numresdata, numthreads, Tarray1, 0);

	(void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	double LRsum = 0.0;
	double LRsdsum = 0.0;
	lcnt= 0;
	for(size_t i = 0; i < numaligns; i++){
	  Calign *align = alignment[i];
	  if(!align || align->numpairs <= 1)
	    continue;
	  int mid = align->mapid2;
	  if(DEBUG>=2)assert(!Gmap[mid]->origmap);
	  if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	    if(DEBUG) assert(BestRefExt==0.0);
	    if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	    continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	  }
	  int rid = align->mapid1;
	  if(DEBUG>=2){
	    int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	    assert(origgoodalign);
	    int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	    assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	  }
	  FLOAT *X = Gmap[mid]->site[0];
	  int M = Gmap[mid]->numsite[0];
	  FLOAT *Y = refmap[rid]->site[0];
	  int N = refmap[rid]->numsite[0];
	  double LRsd = 0.0;
	  double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1, 0, SDDEBUG ? &LRsd : 0,0);
	  logLRarray[mid] = LR;
	  logSDarray[mid] = LRsd;
	  if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	    continue;
	  LRsum += LR;
	  lcnt++;
	  if(SDDEBUG)
	    LRsdsum += LRsd;
	}
	if(SDDEBUG)
	  printf("After updating resSD:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd=%0.6f -> %0.6f)\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt, LRsdsum/lcnt);
	else
	  printf("After updating resSD:lcnt=%llu:score=%0.6f -> %0.6f\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	fflush(stdout);
	if(DEBUG) assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
	if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	logLRsum = LRsum;
	if(SDDEBUG)
	  logLRsdsum = LRsdsum;
	score_free(0,numrefmaps);
      }
    } // if(RESDATA ...)

    if(DEBUG>=2) assert(colors==1);

    if(minSNRestimate && goodcnt > 0){
      
      int orignumthreads = numthreads;

      #ifdef _OPENMP
      numthreads = MaxThreads; // WAS omp_get_max_threads();
      //      numthreads = omp_get_max_threads();
      //      numthreads = min(numthreads,MaxThreads);
      if(numthreads > goodcnt)
        numthreads = max(1,goodcnt);
      #endif

      double origSNR = minSNR[0];
      double origLL = SNRtotLL(origSNR,numthreads,numaligns,alignment,Narray, /* (fabs(origSNR - 4.8) < 0.01) ? 1 : 0 */ 0, maxmapid, Sarray);
      double bestLL = origLL;

      double phi = (1.0 + sqrt(5.0))*0.5;
      double resphi = 2.0 - phi;

      double Low = minSNR[0];
      double High = (SNRstep > 0.0) ? min(Low + 2.0 * SNRstep, SNRmax) : SNRmax;
      double MidL = minSNR[0];
      double MidH = minSNR[0];

      if(VERB>=2){
        printf("minSNR= %0.3f(LL=%0.6f), Low= %0.3f, High= %0.3f\n",MidL,bestLL,Low,High);
	fflush(stdout);
      }

      if(1){
	for(double Mid = Low + 0.01; Mid <= High + 1e-6; Mid += 0.01){
	  double LL = SNRtotLL(Mid,numthreads,numaligns,alignment,Narray, /* (fabs(Mid - 4.8) < 0.01) ? 1 : 0 */ 0, maxmapid, Sarray);
	  if(LL > bestLL - 1e-6){
	    if(LL > bestLL + 1e-6){
	      bestLL = LL;
	      MidL = MidH = Mid;
	    } else
	      MidH = Mid;
	  }
	  if(VERB>=2){
	    printf("minSNR= %0.3f (LL=%0.6f): Low= %0.3f, Mid=%0.3f..%0.3f (LL=%0.6f), High= %0.3f\n", Mid, LL, Low, MidL, MidH, bestLL, High);
	    fflush(stdout);
	    //	    exit(1);
	  }
	}
	//	exit(1);
      }

      while(max(High - MidH, MidL - Low) > 0.001){
	double minSNR,LL;
        if(High - MidH > MidL - Low){
	  minSNR = MidH + resphi * (High - Low - (MidH-MidL));
	  LL = SNRtotLL(minSNR,numthreads,numaligns,alignment,Narray, 0, maxmapid, Sarray);
	  if(LL > bestLL + 1e-6){
            bestLL = LL;
            Low = MidH;
	    MidL = MidH = minSNR;
	  } else if(LL < bestLL - 1e-6)
	    High = minSNR;
	  else /* tied with previous best : extend peak range MidL..MidH */
	    MidH = minSNR;
        } else {
          minSNR = MidL - resphi * (High - Low - (MidH-MidL));
	  LL = SNRtotLL(minSNR,numthreads,numaligns,alignment,Narray, 0, maxmapid, Sarray);
	  if(LL > bestLL + 1e-6){
            bestLL = LL;
	    High = MidL;
	    MidL = MidH = minSNR;
          } else if(LL < bestLL - 1e-6)
	    Low = minSNR;
	  else /* tried with previous best : extend peak range MidL .. MidH */
	    MidL = minSNR;
        }
        if(VERB>=2){
          printf("minSNR= %0.3f (LL=%0.6f): Low= %0.3f, Mid=%0.3f..%0.3f (LL=%0.6f), High= %0.3f\n", minSNR, LL, Low, MidL, MidH, bestLL, High);
	  fflush(stdout);
        }
      }

      double Mid = 0.99 * MidL + 0.01 * MidH;
      if(VERB){
        printf("  minSNR[0]= %0.3f -> %0.3f (%0.3f..%0.3f): LL=%0.6f -> %0.6f\n",origSNR,Mid,MidL,MidH,origLL,bestLL);
	fflush(stdout);
      }
      if(bestLL >= origLL - 1e-9){
        if(1/* giter < RefRepeats - 2 || giter2 < RefRepeats2 - 1*/){
	  double SNR_UB = (giter < RefRepeats - 2) ? Mid + (origSNR - Mid) * MINSNR_BT : Mid;/* fade change */

    	  double bt = 0.0;
	  if(MidL <= origSNR + 0.009){/* backtrack (reduce) if we are stuck at origSNR */
	    if(giter2  < RefRepeats2 - 3 || RefRepeats2 == 1)
	      bt = (giter < RefRepeats - 4) ? 0.201 : (giter < RefRepeats - 3) ? 0.101 : (giter < RefRepeats - 2) ? 0.051 : 0.0;
	    else if(giter2 < RefRepeats - 1)
	      bt = (giter < RefRepeats - 3) ? 0.101 : (giter < RefRepeats - 2) ? 0.051 : 0.0;
	  }

	  minSNR[0] = min(max(SNRmin, Mid - bt), SNR_UB);

	  double LL = SNRtotLL(minSNR[0],numthreads,numaligns,alignment,Narray, 0, maxmapid, Sarray);
  	  if(VERB && fabs(minSNR[0] - Mid) > 0.001){
	    printf("\tBacktracking minSNR[0]=%0.3f -> %0.3f: LL= %0.6f -> %0.6f\n", Mid, minSNR[0], bestLL, LL);
	    fflush(stdout);
          }

	  // make sure we are no worse than before (in case LL is multimodal)
	  while(!(LL >= origLL - 1e-6)){
	    minSNR[0] = 0.5*(minSNR[0] + Mid);
	    LL = SNRtotLL(minSNR[0],numthreads,numaligns,alignment,Narray, 0, maxmapid, Sarray);
	    if(VERB){
	      printf("\tBacktracking minSNR[0]=%0.3f -> %0.3f: LL= %0.6f -> %0.6f\n", Mid, minSNR[0], bestLL, LL);
	      fflush(stdout);
            }
          }
        } else
	  minSNR[0] = Mid;

	if(REFDEBUG && (numrefmaps==1 || (BestRef && !BestRefPV && !BestRefExt && BestRefOutlier > 999.0))){/* check if logLRsum has improved */
	  if(DEBUG) assert(logLRarray);

	  (void)score_init(refmap,0,numrefmaps,nummaps,RKmax);      
	  double LRsum = 0.0;
	  double LRsdsum = 0.0;
	  lcnt= 0;
	  double *origLRarray = new double[nummaps];
	  double *origSDarray = new double[nummaps];
	  for(int mid = 0; mid < nummaps; mid++){
	    origLRarray[mid] = logLRarray[mid];
	    origSDarray[mid] = logSDarray[mid];
          }


	  for(size_t i = 0; i < numaligns; i++){
	    Calign *align = alignment[i];
	    if(!align || align->numpairs <= 1)
	      continue;
	    int mid = align->mapid2;
	    if(DEBUG>=2)assert(!Gmap[mid]->origmap);
	    if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	      if(DEBUG) assert(BestRefExt==0.0);
	      if(DEBUG) assert(numrefmaps > 1 && !BestRefPV);
	      continue;/* skip alignment unless it is with the reference with the best alignment score with Xmap */
	    }
	    int rid = align->mapid1;
	    if(DEBUG>=2){
	      int origgoodalign = AlignedThreshold(align, refmap[rid]->site[0], startScoreThreshold, startLogPvThreshold);
	      assert(origgoodalign);
	      int goodalign = (origgoodalign && align->score > ScoreThreshold && align->logPV > LogPvThreshold) ? 1 : 0;
	      assert((MapRate > 0.0 && !(align->score > ScoreThreshold)) == (!goodalign));
	    }
	    FLOAT *X = Gmap[mid]->site[0];
	    int M = Gmap[mid]->numsite[0];
	    FLOAT *Y = refmap[rid]->site[0];
	    int N = refmap[rid]->numsite[0];
	    double LRsd = 0.0;
	    double LR = logLR(mid,rid,X,Y,M,N,align,align->sites1[0], align->sites2[0], align->sitesK1[0], align->sites2[align->numpairs-1], align->Lij1,align->Rij1,align->Lij2,align->Rij2,1, 
			      /* (Gmap[mid]->id == MAP_TRACE && refmap[rid]->id == REF_TRACE) ? 1 : */0, SDDEBUG ? &LRsd : 0,0, minSNR[0]);

	    if(VERB>=2 && Gmap[mid]->id == MAP_TRACE){
	      printf("mapid=%d,id=%lld:M=%d:\n",mid,Gmap[mid]->id,M);
	      for(int j = 0; j <= M+1; j++)
		printf("    X[J=%d] = %0.6f, SNR=%0.3f, X[M+1]-[M+1-J] = %0.6f\n",j,X[j], (1 <= j && j <= M) ? Gmap[mid]->SNR[0][j] : -1.0, X[M+1]-X[M+1-j]);
	      fflush(stdout);
            }

	    logLRarray[mid] = LR;
	    logSDarray[mid] = LRsd;
	    if(MapRate > 0.0 && !(align->score > ScoreThreshold))
	      continue;
	    LRsum += LR;
	    lcnt++;
	    if(SDDEBUG)
	      LRsdsum += LRsd;
          }
	  if(SDDEBUG)
	    printf("After updating minSNR:lcnt=%llu:score=%0.6f -> %0.6f(logLRsd=%0.6f -> %0.6f)\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt, logLRsdsum/lcnt, LRsdsum/lcnt);
	  else
	    printf("After updating minSNR:lcnt=%llu:score=%0.6f -> %0.6f\n",(unsigned long long)lcnt,logLRsum/lcnt,LRsum/lcnt);
	  fflush(stdout);
	  if((DEBUG && !(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt)) || (VERB>=2 && giter==0)){
	    double sum1 = 0.0,sum2 = 0.0, sum3 = 0.0, sum4 = 0.0;
	    for(size_t i = 0; i < numaligns; i++){
	      Calign *align = alignment[i];
	      if(!align || align->numpairs <= 1)
	        continue;
	      int mid = align->mapid2;
	      if(DEBUG>=2) assert(!Gmap[mid]->origmap);
	      if(BestRef && Gmap[mid]->align->mapid1 != align->mapid1){
	        if(DEBUG) assert(BestRefExt==0.0);
	          continue;
              }
	      if(MapRate > 0.0 && !(align->score > ScoreThreshold))
		continue;
	      sum1 += origLRarray[mid];
	      sum2 += logLRarray[mid];
	      sum3 += origSDarray[mid];
	      sum4 += logSDarray[mid];
	      printf("i=%lu/%lu:mid=%d,id=%lld:logLRarray[mid]=%0.6f -> %0.6f (delta=%0.6f,cum=%0.6f -> %0.6f), LLsd=%0.6f -> %0.6f(delta=%0.6f,cum=%0.6f -> %0.6f)\n",
	                  i,numaligns,mid,Gmap[mid]->id,origLRarray[mid],logLRarray[mid], logLRarray[mid]-origLRarray[mid],sum1, sum2,
	                  origSDarray[mid],logSDarray[mid],logSDarray[mid]-origSDarray[mid],sum3,sum4);
            }
	    fflush(stdout);
	    if(DEBUG) assert(LRsum > logLRsum - (USE_RFLOAT ? 1e-4 : 1e-6)*lcnt);
          }
	  if(DEBUG && MapRate <= 0.0) assert(lcnt == tcnt);
	  logLRsum = LRsum;
	  if(SDDEBUG)
	    logLRsdsum = LRsdsum;
	  delete [] origLRarray;
	  delete [] origSDarray;

	  score_free(0,numrefmaps);
        } // if(REFDEBUG ...

	if(minSNR[0] != origSNR){
#ifdef _OPENMP
	  numthreads = MaxThreads; // WAS omp_get_max_threads();
	  //	  numthreads = min(numthreads,MaxThreads);
	  numthreads = max(1,min(numthreads, totalmaps/1024));
#endif

	  /* Apply minSNR[0] to all molecules */
	  mapcorrectApply(Gmap, 0, totalmaps, maxmaps, MapSNR, 1, numthreads);
	  if(ResBins[0] > 0){
	    if(DEBUG>=2)
	      for(int c = 0; c < colors; c++)
		assert(resbiasX[c][ResBins[c]] <= maxresbias);
	    BiasCorrect(Gmap, 0, totalmaps, 1);
	    if(DEBUG>=2)
	      for(int c = 0; c < colors; c++)
		assert(resbiasX[c][ResBins[c]] <= maxresbias);
	  }
	  if(VERB>=2){
	    for(int mid = 0; mid < nummaps; mid++){
	      Cmap *pmap = Gmap[mid];
	      if(pmap->id== MAP_TRACE){
		int M = pmap->numsite[0];
		FLOAT *X = pmap->site[0];
		printf("mapid=%d,id=%lld:M=%d:After calling mapcorrectApply & BiasCorrect:\n",mid,Gmap[mid]->id,M);
		for(int j = 0; j <= M+1; j++)
		  printf("    X[%d] = %0.6f, SNR=%0.3f, X[M+1]-X[M+1-J]=%0.6f\n",j,X[j], (1 <= j && j <= M) ? Gmap[mid]->SNR[0][j] : -1.0, X[M+1]-X[M+1-j]);
		fflush(stdout);
              }
            }
          }
        }
      } else {
	if(VERB){
	  printf("\nRestoring minSNR[0]=%0.3f -> %0.3f: LL= %0.6f -> %0.6f\n", Mid, minSNR[0], bestLL, origLL);
	  fflush(stdout);
	}
      }
      numthreads = orignumthreads;

    } // if(minSNRestimate)

    if(DEBUG) assert(colors==1);

    if(0 && MapScale && giter < RefRepeats-1){
      double y2sum = 0.0, xysum = 0.0;
      for(int i = 0; i < nummaps; i++){
	Cmap *pmap = Gmap[i];
	y2sum += pmap->y2sum;
	xysum += pmap->xysum;
      }
      double CscaleInv = (xysum <= 0.0) ? 1.0 : xysum / y2sum;

      if(VERB/* HERE >=2 */){
	printf("  Rescaling map site[] (and rawsite[]) values by per map scaling factors (excluding average scaling= %0.8f):wtime=%0.6f\n",1.0/CscaleInv,wtime());
	fflush(stdout);
      }
      
      // NOTE : if minSNRestimate, Gmap[i]->cumscale will be re-applied if site[] is ever recomputed from origsite after minSNR[] changes */

      int origcolors = colors;
      if(usecolor)
	colors = 2;

      int cnt = 0;

      #pragma omp parallel num_threads(numthreads) if(numthreads > 1)
      {
        int mycnt = 0;

        #pragma omp for schedule(dynamic,256)
	for(int i = 0; i < nummaps; i++){
	  Cmap *pmap = Gmap[i];

	  if(Gmap[i]->incwt <= 0.0 /* || C == 1.0 */)
	    continue;
	
	  mycnt++;
	  double C = pmap->incscale;
	  C *= CscaleInv;
	  Gmap[i]->cumscale *= C;

	  for(int c = 0; c < colors; c++){
	    FLOAT *X = pmap->site[c];
	    int M = pmap->numsite[c];
	    for(int j= M+1; j > 0; j--)
	      X[j] *= C;
	  }
	  if(maxresbias > mres * 0.5){/* also rescale rawsite[] */
	    for(int c = 0; c < colors; c++){
	      FLOAT *X = pmap->rawsite[c];
	      int M = pmap->numsite[c];
	      for(int j= M+1; j > 0; j--)
		X[j] *= C;
	    }
	  }
	} // omp for i = 0 .. nummaps-1

	#pragma omp atomic
	cnt += mycnt;

      }// omp parallel 

      if(VERB){
	printf("MapScale : Rescaled %d maps: wtime= %0.6f\n",cnt,wtime());
	fflush(stdout);
      }

      colors = origcolors;
    }

    /* save updated parameter values */
#pragma novector
    if(VERB>=2){
      printf("Saving Error parameters for giter=%d:\n",giter+1);
      fflush(stdout);
    }

    for(int c = 0; c < (usecolor ? MAXCOLOR : colors); c++){
      parameters[giter+1].res[c] = res[c];
      parameters[giter+1].resSD[c] = resSD[c];

      parameters[giter+1].FP[c] = FP[c];
      parameters[giter+1].FN[c] = FN[c];
      parameters[giter+1].SF[c] = SF[c];
      parameters[giter+1].SD[c] = SD[c];
      if(QUADRATIC_VARIANCE)
	parameters[giter+1].SR[c] = SR[c];
      if(RES_VARIANCE)
	parameters[giter+1].SE[c] = SE[c];
      parameters[giter+1].minSNR[c] = minSNR[c];

      if(DEBUG) assert(ResBins[c] <= RESBINS);
      parameters[giter+1].ResBins[c] = ResBins[c];
      for(int Bin = 0; Bin <= ResBins[c]; Bin++){
	parameters[giter+1].resbias[c][Bin] = resbias[c][Bin];
	parameters[giter+1].resbiasX[c][Bin] = resbiasX[c][Bin];
	if(VERB>=2){
	  printf("Bin=%d:size=%6.3f kb, bias= %7.4f\n",Bin, parameters[giter+1].resbiasX[c][Bin], parameters[giter+1].resbias[c][Bin]);
	  fflush(stdout);
	}
	if(DEBUG>=2 && !(maxresbias >= resbiasX[c][Bin] - 1e-6)){
	  printf("giter=%d:c=%d,Bin=%d:maxresbias=%0.6f,resbiasX[c][Bin]=%0.6f\n",
		 giter,c,Bin,maxresbias,resbiasX[c][Bin]);
	  for(int g = 0; g <= giter+1; g++)
	    printf("giter=%d:c=%d:ResBins[c]=%d,resbiasX[c][ResBins[c]]=%0.6f\n",
		   g,c,parameters[giter].ResBins[c],parameters[giter].resbiasX[c][parameters[giter].ResBins[c]]);
	  fflush(stdout);
	  assert(maxresbias >= resbiasX[c][Bin] - 1e-6);	
	}
      }
      if(DEBUG>=2 && (c==0 || usecolor) && ResBins[c] > 0 && !(maxresbias >= resbiasX[c][ResBins[c]] - 1e-6)){
	printf("giter=%d:c=%d:ResBins[c]=%d,maxresbias=%0.6f,resbiasX[c][ResBins[c]]=%0.6f\n",
	       giter,c,ResBins[c],maxresbias,resbiasX[c][ResBins[c]]);
	fflush(stdout);
	assert(maxresbias >= resbiasX[c][ResBins[c]] - 1e-6);
      }
      for(int Bin = ResBins[c] + 1; Bin <= origResBins[c]; Bin++){
	parameters[giter+1].resbias[c][Bin] = resbias[c][ResBins[c]];
	parameters[giter+1].resbiasX[c][Bin] = min(maxresbias,resbiasX[c][ResBins[c]]);
	if(VERB>=2){
	  printf("Bin=%d:size=%6.3f kb, bias= %7.4f\n",Bin, parameters[giter+1].resbiasX[c][Bin], parameters[giter+1].resbias[c][Bin]);
	  fflush(stdout);
	}
      }
    }
    parameters[giter+1].SF[2] = MA_SF;
    parameters[giter+1].SD[2] = MA_SD;
    parameters[giter+1].MA_mean = MA_mean;

    parameters[giter+1].PixelLen = PixelLen;
    parameters[giter+1].PixelLenSD = PixelLenSD;
    parameters[giter+1].mres = mres; // NOTE : mres does not change during autonoize
    parameters[giter+1].mresSD = mresSD; // NOTE : mresSD does not change during autonoise

    parameters[giter+1].mapcnt = 0;
    parameters[giter+1].logLR = 0.0;
    parameters[giter+1].ATmapcnt = 0;
    parameters[giter+1].ATlogLR = 0.0;
    parameters[giter+1].sitecnt = 0;
    parameters[giter+1].sumX = 0.0;
    parameters[giter+1].totlen = 0.0;
    parameters[giter+1].outlierRate = parameters[giter+1].EndoutlierRate = 0.0;
    for(int c = 0; c < (usecolor ? MAXCOLOR : colors); c++)
      parameters[giter+1].LabelDensity[c] = parameters[giter+1].LabelDensityX[c] = 0.0;

    parameters[giter+1].maxresbias = maxresbias;

    if(giter < RefRepeats-1){ /* check if parameters changed significantly */
      double maxerr = 0.0;
      if(FPorig > 0.0 && fabs(FP[0] - FPorig)/FPorig > maxerr)
	maxerr = fabs(FP[0]-FPorig)/FPorig;
      if(FNorig > 0.0 && fabs(FN[0] - FNorig)/FNorig > maxerr)
	maxerr = fabs(FN[0]-FNorig)/FNorig;
      if(SForig > 0.0 && fabs(SF[0] - SForig)/SForig > maxerr)
	maxerr = fabs(SF[0] - SForig)/SForig;
      if(fabs(SDorig) > 0.0 && fabs(SD[0] - SDorig)/fabs(SDorig) > maxerr)
	maxerr = fabs(SD[0] - SDorig)/fabs(SDorig);
      if(SRorig > 0.0 && fabs(SR[0] - SRorig)/SRorig > maxerr)
	maxerr = fabs(SR[0] - SRorig)/SRorig;
      if(SEorig > 0.0 && fabs(SE[0] - SEorig)/SEorig > maxerr)
	maxerr = fabs(SE[0] - SEorig)/SEorig;
      if(fabs(PixelLen - startPixelLen)/startPixelLen > maxerr)
	maxerr = fabs(PixelLen - startPixelLen)/startPixelLen;
      
      if(maxerr < RefRepeatErr){
	if(VERB){
	  printf("max relative parameter change = %0.7f : skipping remaining iterations (relerr=%0.7f)\n", maxerr,RefRepeatErr);
	  fflush(stdout);
	}
	RefRepeats = giter+2;
      }
    }// if(giter < RefRepeats-1)

    if(DEBUG>=2) assert(colors==1);

    score_free(0,numrefmaps);
  }// for giter = 0 .. RefRepeats -1

 Lreturn:

  if(VERB/* HERE HERE >=2 */){
    static long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
    getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
    printf("After giter=%d/%d(giter2=%d/%d) loop: VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb\n",  giter,RefRepeats,giter2,RefRepeats2,VmSize * 1e-9, VmRSS * 1e-9, VmHWM * 1e-9, VmSwap * 1e-9);
    fflush(stdout);
  }

  delete [] scaleIDcnt; scaleIDcnt = 0;

  delete [] RKmax;
  delete [] RKmem;

  delete [] Tarray1;
  delete [] Tarray2;
  delete [] Tarray3;
  delete [] Tarray4;
  delete [] Tarray5;
  delete [] Tarray6;
  
  delete [] Narray;
  delete [] Sarray;

  if(HashFP){
    hash_close(HashFP, pSNRtotLL ? 0 : 1);

    numhashpairs1 = numhashpairs2 = 0;
    NumPair1 = NumPair2 = 0;
    nexthash1 = hashpairs1;
    refid1 = refidend1 = -1;
    nexthash2 = hashpairs2;
    refid2 = refidend2 = -1;
    HashFP = NULL;
  }

  if(VERB>=2){
    printf("Refine=%d,NoStat=%d,pSNRtotLL=%p\n",Refine,NoStat,pSNRtotLL);
    fflush(stdout);
  }

  if(!Refine && !NoStat && pSNRtotLL == NULL){
    /* output parameter values after each iteration in .err file and final values of bias and parameters in .errbias & .errbin files. Also final mapping rate values in .maprate */
    output_err(output_prefix,parameters,RefRepeats,MappingRatePV,CoverageMult,(int)floor(max(0.0, startLogPvThreshold) + 0.5), MAX_PV);

    if(ScanCorrection && UniqueScans > 1 && giter2 == RefRepeats2 - 1){/* save rawsite[] as <prefix>_rescaled.bnx (without -bpp or -resbias correction) */
      char basename[PATH_MAX];
      sprintf(basename,"%s_rescaled",output_prefix);

      int mapcorrect = 0;// remember if mapcorrectApply() needs to be called

      if(MapScale && origMapScale) {/* reset map scaling factors */
	for(int mid = 0; mid < nummaps; mid++)
	  Gmap[mid]->cumscale = 1.0;
	mapcorrect = 1;
      }

      if(MaxEnd > 0.0 || MaxInterval > 0.0)
	mapcorrect = 1;

      double origminSNR = minSNR[0];
      if(ScanCorrectMinSNR >= 0.0 && ScanCorrectMinSNR < minSNR[0]){ /* NEW12: undo effect of -minSNR, so it can be used as input to subsequent autoNoise with -minSNRestimate : -minSNR will always be applied again on BNX input */

	if(VERB){
	  printf("Changing minSNR[0] = %0.6f -> %0.6f : startmaps= %d, totalmaps= %d\n",minSNR[0],ScanCorrectMinSNR, startmaps, totalmaps);
	  fflush(stdout);
	}
	minSNR[0] = ScanCorrectMinSNR;

	mapcorrect = 1;
      }
      if(ScanCorrectMinLen >= 0.0 && ScanCorrectMinLen < MinLen){/* NEW145 : reduce */
	if(VERB){
	  printf("Changing minlen = %0.2f -> %0.2f kb : startmaps= %d, totalmaps= %d\n",MinLen, ScanCorrectMinLen, startmaps,totalmaps);
	  fflush(stdout);
	}
	MinLen = ScanCorrectMinLen;
      }

      if(mapcorrect){/* re-apply mapcorrect since molecules have been rescaled OR minSNR changed */
#ifdef _OPENMP
	  numthreads = MaxThreads; // WAS omp_get_max_threads();
	  //	  numthreads = min(numthreads,MaxThreads);
	  numthreads = max(1,min(numthreads, totalmaps/1024));
#endif
        mapcorrectApply(Gmap,0,totalmaps,maxmaps,MapSNR, 1, numthreads);
	if(ResBins[0] > 0){
	  if(DEBUG>=2)
	    for(int c = 0; c < colors; c++)
	      assert(resbiasX[c][ResBins[c]] <= maxresbias);
	  BiasCorrect(Gmap, 0, totalmaps, 1);
	  if(DEBUG>=2)
	    for(int c = 0; c < colors; c++)
	      assert(resbiasX[c][ResBins[c]] <= maxresbias);
	}
	if(BIAS_TRACE){
	  for(int mid = 0; mid < nummaps; mid++){
	    Cmap *pmap = Gmap[mid];
	    if(pmap->id== BIAS_TRACE){
	      int M = pmap->numsite[0];
	      FLOAT *X = pmap->site[0];
	      printf("mapid=%d,id=%lld:M=%d:After calling mapcorrectApply & BiasCorrect:\n",mid,Gmap[mid]->id,M);
	      for(int j = 0; j <= M+1; j++)
		printf("    X[%d] = %0.6f, SNR=%0.3f, X[M+1]-X[M+1-J]=%0.6f\n",j,X[j], (1 <= j && j <= M) ? Gmap[mid]->SNR[0][j] : -1.0, X[M+1]-X[M+1-j]);
	      fflush(stdout);
	    }
	  }
	}
      }

      Cmap **goodmaps = new Cmap*[totalmaps];
      int numgoodmaps = totalmaps;
      for(int i = 0; i < totalmaps; i++)
	goodmaps[i] = Gmap[i];

      if(DEBUG>=2){
	for(int j = 0; j < numgoodmaps; j++){
	  Cmap *pmap = goodmaps[j];
	  int M = pmap->numsite[0];
	  if(pmap->id == 7392735LL || 
	     pmap->id == 3966327LL ||
	     pmap->id == 2842262LL ||
	     pmap->id == 465098LL ||
	     pmap->id == 4597094LL){
	    printf("map with id= %lld : len= %0.4f kb, j= %d/%d\n",pmap->id,pmap->site[0][M+1],j,numgoodmaps);
	    fflush(stdout);
	  }
	}
      }

      if(MinSites > 0 || MaxSites || MinSiteDensity > 0.0 || MaxSiteDensity > 0.0 || MaxEndSiteDensity > 0.0){/* re-apply -minsites -maxsites or -minSiteDensity or -maxSiteDensity filter */
	int cnt = 0,cntEnd = 0;
	double maxDensity = MaxSiteDensity * 0.01;
	double minDensity = MinSiteDensity * 0.01;
	double maxEndDensity = MaxEndSiteDensity * 0.01;

	for(int i = 0; i < numgoodmaps; i++){
	  Cmap *pmap = goodmaps[i];
	  int M = pmap->numsite[0];
	  FLOAT *X = pmap->site[0];
	  if(M < MinSites || (MaxSites && M > MaxSites) || (MaxSiteDensity > 0.0 && M > maxDensity * X[M+1]) || (MinSiteDensity > 0.0 && M < minDensity * X[M+1]))
	    continue;
	  if(MaxEndSiteDensity > 0.0){
	    int minsites = max(2,MinSites);
	    int maxsites = M+1-minsites;
	    int J = minsites;
	    for(; J <= maxsites; J++)
	      if((X[J] >= MaxEndSiteDensityLength && J > maxEndDensity * X[J]) || 
		 (X[M+1]-X[J] >= MaxEndSiteDensityLength && M+1-J > maxEndDensity * (X[M+1] - X[J])))
		break;
	    if(J <= maxsites){
	      cntEnd++;
	      continue;
	    }
	  }
	  goodmaps[cnt++] = pmap;
	}
	if(cnt < numgoodmaps){
	  printf("Reduced number of maps from %d to %d due to MinSites=%d, MaxSites=%d, MinSiteDensity=%0.1f,MaxSiteDensity=%0.1f/100kb (after autoNoise)\n",
		 numgoodmaps,cnt,MinSites,MaxSites,MinSiteDensity,MaxSiteDensity);
          if(cntEnd > 0)
	    printf("\t Includes %d maps filtered out due to -MaxEndSiteDensity %0.1f %0.3f\n",cntEnd,MaxEndSiteDensity,MaxEndSiteDensityLength);
	  fflush(stdout);
	}
	numgoodmaps = cnt;
      }

      if(MinLen > 0.0 || MaxLen > 0.0){   /* re-apply MinLen and MaxLen filters */
	int cnt = 0;
	for(int i = 0; i < numgoodmaps; i++){
	  Cmap *pmap = goodmaps[i];
	  double len = pmap->site[0][pmap->numsite[0]+1];	  
	  if(len < MinLen || (MaxLen > 0.0 && len > MaxLen))
	    continue;
	  goodmaps[cnt++] = pmap;
	}
	if(cnt < numgoodmaps){
	  printf("Reduced number of maps from %d to %d due to MinLen= %0.2f, MaxLen= %0.2f\n", numgoodmaps,cnt,MinLen,MaxLen);
	  fflush(stdout);
	}
	numgoodmaps = cnt;
      }

      if(ScanFilter > 0){/* Apply -ScanFilter */
	/* first compute average MappingRateKB, EndoutlierFraction and bppSD over all scans */
	double cumLen = 0.0, cumTotlen = 0.0, cumMappedlen = 0.0, cumBppsdMlen = 0.0;
	for(int scan = 0; scan < UniqueScans; scan++){
	  CscanCorrection *p = &ScanScale[0][scan];

	  if(p->mols < ScanFilter)
	     continue;
	  cumLen += p->len;
	  cumTotlen += p->totlen;
	  cumMappedlen += p->mappedlen;
	  cumBppsdMlen += p->scaleSD * p->cumscale*PixelLen*1000.0 * p->mappedlen;
	  if(DEBUG && !(isfinite(cumBppsdMlen))){
	    printf("scan=%d: scaleSD= %0.6f, cumscale= %0.8f, PixelLen= %0.8f, mappedlen= %0.4f:cumBppsdMlen = %0.6e\n",scan,p->scaleSD,p->cumscale,PixelLen, p->mappedlen, cumBppsdMlen);
	    fflush(stdout);
	    //	    assert(isfinite(cumBppsdMlen));
	  }
	}
	double AvMappedKB = cumMappedlen / max(0.001, cumTotlen);
	double AvEndoutlier = 1.0 - cumMappedlen / max(0.001, cumLen);
	double AvBppSD = cumBppsdMlen / max(0.001, cumMappedlen);

	int scnt = 0;/* count of scans that will be filtered out */
	int ncnt= 0, mcnt=0, bcnt = 0, ecnt= 0;

	if(VERB){
	  for(int scan = 0; scan < UniqueScans; scan++){
	    CscanCorrection *p = &ScanScale[0][scan];
	    if(p->mols <= 0){
	      ncnt++;
	      continue;
	    }
	    if(p->mols < ScanFilter){
	      scnt++;
	      continue;
	    }
	    double MappedKB = p->mappedlen/max(0.001,p->totlen);
	    if(MappedKB < AvMappedKB * ScanFilterRm){
	      mcnt++;
	      continue;
	    }

	    double BppSD = p->scaleSD * p->cumscale * PixelLen * 1000.0;
	    if(BppSD > AvBppSD * ScanFilterRb){
	      bcnt++;
	      continue;
	    }

	    double Endoutlier = 1.0 - p->mappedlen/max(0.001,p->len);
	    if(Endoutlier > AvEndoutlier * ScanFilterRe){
	      ecnt++;
	      continue;
	    }
	  }
	  
	  if(VERB){
	    printf("Filtered out %d/%d scans (or cohorts) due to -ScanFilter %d %0.2f %0.2f %0.2f. Previously filtered (or empty) =%d/%d scans\n",
		   scnt+mcnt+bcnt+ecnt, UniqueScans-ncnt, ScanFilter,ScanFilterRm,ScanFilterRb,ScanFilterRe,ncnt,UniqueScans);
	    printf("\t scans filtered by cause:  Low Mols= %d, Low AlignedKB%%= %d, High bppSD= %d, High Endoutlier%%= %d\n",scnt,mcnt,bcnt,ecnt);
	    fflush(stdout);
	  }

	  ncnt= 0, mcnt=0, bcnt = 0, ecnt= 0;
	}

	int cnt = 0;
	for(int i = 0; i < numgoodmaps; i++){
	  Cmap *pmap = goodmaps[i];
	  int scan = pmap->UniqueScanId;
	  CscanCorrection *p = &ScanScale[0][scan];
	  if(p->mols < ScanFilter){
	    ncnt++;
	    continue;
	  }

	  double MappedKB = p->mappedlen/max(0.001,p->totlen);
	  if(MappedKB < AvMappedKB * ScanFilterRm){
	    mcnt++;
	    continue;
	  }

	  double BppSD = p->scaleSD * p->cumscale * PixelLen * 1000.0;
	  if(BppSD > AvBppSD * ScanFilterRb){
	    bcnt++;
	    continue;
	  }

	  double Endoutlier = 1.0 - p->mappedlen/max(0.001,p->len);
	  if(Endoutlier > AvEndoutlier * ScanFilterRe){
	    ecnt++;
	    continue;
	  }

	  goodmaps[cnt++] = pmap;
	}
	if(cnt < numgoodmaps){
	  printf("Reduced number of maps from %d to %d due to -ScanFilter %d %0.2f %0.2f %0.2f : Avg Aligned= %0.3f%%, Endoutlier= %0.3f%% bppSD= %0.2f\n", 
		 numgoodmaps,cnt,ScanFilter,ScanFilterRm,ScanFilterRb,ScanFilterRe,AvMappedKB * 100.0, AvEndoutlier * 100.0, AvBppSD);
	  printf("\t maps removed by cause:  Low Mols= %d, Low AlignedKB%%= %d, High bppSD= %d, High Endoutlier%%= %d\n", ncnt,mcnt,bcnt,ecnt);
	  fflush(stdout);
	}
	numgoodmaps = cnt;
      }

      if(DEBUG>=2){
	for(int j = 0; j < numgoodmaps; j++){
	  Cmap *pmap = goodmaps[j];
	  int M = pmap->numsite[0];
	  if(pmap->id == 7392735LL || 
	     pmap->id == 3966327LL ||
	     pmap->id == 2842262LL ||
	     pmap->id == 465098LL ||
	     pmap->id == 4597094LL){
	    printf("map with id= %lld : len= %0.4f kb, j= %d/%d\n",pmap->id,pmap->site[0][M+1],j,numgoodmaps);
	    fflush(stdout);
	  }
	}
      }

      if(MaxCoverageAN > 0.0){/* apply coverage based filter to reduce coverage to specified level */
	/* first determine reference size */
	double reflen = 0.0;
	for(int i = 0; i < numrefmaps; i++){
	  Cmap *pmap = refmap[i];
	  int N = pmap->numsite[0];
	  reflen += pmap->site[0][N+1];
	}
	
	double targetlen = reflen * MaxCoverageAN;/* target kb size of output molecules (based on scaled site[] not unscaled rawsite[]) */

	/* sort goodmaps[0..numgoodmaps] in descending order of map length */
	qsort(goodmaps, numgoodmaps, sizeof(Cmap *), (intcmp*)CmapSizeDec);
	
	double totlen = 0.0, nMinLen = MinLen;
	int i = 0;
	for(; i < numgoodmaps; i++){
	  Cmap *pmap = goodmaps[i];
	  int M = pmap->numsite[0];
	  totlen += pmap->site[0][M+1];
	  if(totlen >= targetlen){
	    nMinLen = pmap->site[0][M+1];
	    i++;
	    break;
	  }
	}
	double cumlen = totlen;
	for(int j = i; j < numgoodmaps; j++){
	  Cmap *pmap = goodmaps[j];
	  int M = pmap->numsite[0];
	  cumlen += pmap->site[0][M+1];
	}
	
	// Randomize order of remaining maps here, so final output maps are randomized
	srand(RandSeed);
	for(int i = 0; i < numgoodmaps; i++)
	  goodmaps[i]->paired = rand();
	qsort(goodmaps,i,sizeof(Cmap *),(intcmp*)CmapPairedInc);

	if(i < numgoodmaps){/* total coverage exceeds MaxCoverageAN */
	  if(nMinLen > MaxCoverageLenAN){/* need to reduce new MinLen to MaxCoverageLenAN */
	    nMinLen = MaxCoverageLenAN;
	    for(; i < numgoodmaps; i++){
	      Cmap *pmap = goodmaps[i];
	      int M = pmap->numsite[0];
	      if(pmap->site[0][M+1] < MaxCoverageLenAN)
		break;
	      totlen += pmap->site[0][M+1];
	    }
	  } 

	  if(VERB){
	    printf("Increased -minlen from %0.2f to %0.2f kb reducing total maps length to %0.2f kb (coverage= %0.2fx -> %0.2fx, ref = %0.2f kb), num maps = %d -> %d\n",
		   MinLen, nMinLen, totlen, cumlen / reflen, totlen / reflen, reflen, numgoodmaps, i);
	    fflush(stdout);
	  }
	  numgoodmaps = i;

	  if(totlen > targetlen + nMinLen){/* need to randomly sub-sample to reduce total lenth to targetlen */

	    /* need to randomize larger set of maps */
	    for(int i = 0; i < numgoodmaps; i++)
	      goodmaps[i]->paired = rand();
	    qsort(goodmaps,numgoodmaps,sizeof(Cmap *),(intcmp*)CmapPairedInc);

	    double ntotlen = 0;
	    int i = 0;
	    for(; i < numgoodmaps; i++){
	      Cmap *pmap = goodmaps[i];
	      int M = pmap->numsite[0];
	      ntotlen += pmap->site[0][M+1];
	      if(ntotlen >= targetlen){
		i++;
		break;
	      }
	    }
	    if(VERB){
	      printf("Randomly subsampled maps reducing total maps length to %0.2f kb (coverage= %0.2fx, ref= %0.2f kb), nummaps = %d -> %d\n",
		     ntotlen, ntotlen / reflen, reflen, numgoodmaps, i);
	      fflush(stdout);
	    }
	    if(DEBUG>=2){
	      for(int j = i; j < numgoodmaps; j++){
		Cmap *pmap = goodmaps[j];
		int M = pmap->numsite[0];
		if(pmap->id == 7392735LL || 
		   pmap->id == 3966327LL ||
		   pmap->id == 2842262LL ||
		   pmap->id == 465098LL ||
		   pmap->id == 4597094LL){
		  printf("map with id= %lld removed : len= %0.4f kb, j= %d, numgoodmaps= %d -> %d\n",pmap->id,pmap->site[0][M+1],j,numgoodmaps,i);
		  fflush(stdout);
		}
	      }
	    }

	    numgoodmaps = i;
	  }
	}
      }

      if(DEBUG>=2){
	for(int j = 0; j < numgoodmaps; j++){
	  Cmap *pmap = goodmaps[j];
	  int M = pmap->numsite[0];
	  if(pmap->id == 7392735LL || 
	     pmap->id == 3966327LL ||
	     pmap->id == 2842262LL ||
	     pmap->id == 465098LL ||
	     pmap->id == 4597094LL){
	    printf("map with id= %lld : len= %0.4f kb, j= %d/%d\n",pmap->id,pmap->site[0][M+1],j,numgoodmaps);
	    fflush(stdout);
	  }
	}
      }

      if(usecolor)
	colors = 2;
      if(usecolor==2){
	for(int i = 0; i < numgoodmaps; i++)
	  goodmaps[i]->colorswap(usecolor);
	char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
      }
      output_bnx(basename,goodmaps,0,numgoodmaps-1,1/*raw*/, NULL, NULL, -1);

      if(usecolor==2){
	for(int i = 0; i < numgoodmaps; i++)
	  goodmaps[i]->colorswap(usecolor);
	char *tmp = Nickase[0]; Nickase[0] = Nickase[1]; Nickase[1] = tmp;
      }
      if(usecolor)
	colors = 1;

      if(ScanCorrectMinSNR >= 0.0 && minSNR[0] != origminSNR && XmapStatWrite){/* revert to original minSNR : needed so subsequent -XmapStateWrite outputs correct values */
	if(VERB){
	  printf("Changing minSNR[0] = %0.6f -> %0.6f : numgoodmaps= %d\n",minSNR[0],origminSNR,numgoodmaps);
	  fflush(stdout);
	}
	minSNR[0] = origminSNR;

	mapcorrectApply(Gmap,0,totalmaps, maxmaps, MapSNR, 1, numthreads);
	if(ResBins[0] > 0)// re-allocate rawsite[] and re-do Bias adjustment
	  BiasCorrect(Gmap, 0, totalmaps, 1);
      }

      delete[] goodmaps; goodmaps = NULL;
    }
  }

  if(extendSplit){
    delete [] &SplitBinCnt[-MAX_KB_BINS];
    delete [] coverage;
    delete [] endoutlierLi;
    if(EXTSPLIT_RANGE)
      delete [] endoutlierStartL;
    if(extsplitOutlier > 0.0)
      delete [] outlierLB;
    if(extsplitExtOnly) {
      if(VERB>=2){
	printf("Freeing extsplitExtOnly = %p -> NULL\n",extsplitExtOnly);
	fflush(stdout);
      }
      free(extsplitExtOnly);
      extsplitExtOnly = NULL;
    }
  }
  if(EXTSPLIT_DELBIN){
    endoutlierLm -= MAX_KB_BINS;
    endoutlierRm -= MAX_KB_BINS;
    endoutlierLim -= MAX_KB_BINS;
    endoutlierRim -= MAX_KB_BINS;
    outlierLBm -= MAX_KB_BINS;
    outlierRBm -= MAX_KB_BINS;
  }
  delete [] endoutlierLm;
  delete [] endoutlierRm;
  delete [] endoutlierLim;
  delete [] endoutlierRim;
  delete [] outlierLBm;
  delete [] outlierRBm;

  delete rs_heap; rs_heap = NULL;

  delete [] hashmatch1; hashmatch1 = 0;
  refid1 = refid2 = -1;

  delete [] hashmatch2; hashmatch2 = 0;
  delete [] hashpairs1; hashpairs1 = 0;
  delete [] hashpairs2; hashpairs2 = 0;
  numhashpairs1 = numhashpairs2 = maxhashpairs1 = maxhashpairs2 = 0;

  delete [] YidListMem; YidListMem = NULL;
  delete [] phashListMem; phashListMem = NULL;
  YidList1 = YidList2 = XidList1 = XidList2 = 0;
  phashList1 = phashList2 = 0;
  NumPair1 = NumPair2 = MaxPair = 0;
  refidend1 = refidend2 = -1;

  delete [] SizeToBin[0]; SizeToBin[0] = NULL;

  //  delete [] origmapid; origmapid = NULL;
  delete [] numalign_start;
  delete [] numalign_end;
  delete [] orignummaps;
  numalign_start = numalign_end = 0;
  orignummaps = 0;

  delete [] parameters;

  delete [] logLRarray; logLRarray = NULL;
  delete [] logSDarray; logSDarray = NULL;
  delete [] Xlen; Xlen = NULL;
  delete [] errors; errors = NULL; maxerrors = 0;
  delete [] resdata; resdata = NULL; maxresdata = 0;
    
  if(ScanCorrection){
    delete [] ThetaDelta;
    for(int t = 0; t < numthreads; t++)
      delete [] Txy[t];
    delete [] Txy;
  }

  if(EXTSPLIT_FORK && extendSplit && Refine && child_pid != NULL && numchild > 0){/* This is the parent job : wait for all child jobs to complete */
    int status;
    pid_t pid;
    if(VERB){
      printf("Waiting for %d child jobs to complete:wall time= %0.6f\n", numchild, wtime());
      fflush(stdout);
    }
    for(int F = 0; F < numchild; F++){
      while((pid = waitpid(child_pid[F], &status, 0)) == 0){
	printf("Waiting for child %d/%d (pid= %d): sleeping 1 second after interrupt\n",F,numchild,child_pid[F]);
	fflush(stdout);
	sleep(1);
      }

      if(pid < 0){
	int myerrno = errno;
	fprintf(stderr,"Error waiting for child %d/%d (pid= %d): %s\n",F,numchild,child_pid[F],strerror(myerrno));
	fflush(stderr);exit(1);
      }
      if(WIFEXITED(status) && WEXITSTATUS(status) != 0){
	printf("Non-zero exit status %d from child %d/%d (pid= %d)\n",WEXITSTATUS(status),F,numchild,child_pid[F]);
	fflush(stdout);exit(1);
      }
      if(WIFSIGNALED(status)){
	printf("Child %d/%d (pid= %d) killed with signal %d\n",F,numchild,child_pid[F], WTERMSIG(status));
	fflush(stdout);exit(1);
      }
    }

    if(VERB){
      printf("%d forked jobs terminated: wall time= %0.6f\n",numchild,wtime());
      fflush(stdout);
    }
    delete child_pid; child_pid = NULL;
    numchild = 0;
  }

  if(VERB/* HERE HERE >=2 */){
    long long VmSize = 0, VmRSS = 0, VmSwap = 0, VmHWM = 0;
    getmem(VmSize,VmRSS,VmSwap,&VmHWM);	    
    printf("End of refalign_allpairs(): VmSize= %0.4f, VmRSS= %0.4f, VmHWM= %0.4f, VmSwap= %0.4f Gb\n",  VmSize * 1e-9, VmRSS * 1e-9, VmHWM * 1e-9, VmSwap * 1e-9);
    fflush(stdout);
  }

  /* restore original thresholds in case they were changed by -MapRate and RefRepeats2 > 1 */
  ScoreThreshold = origScoreThreshold;
  LogPvThreshold = origLogPvThreshold;
}
	     
