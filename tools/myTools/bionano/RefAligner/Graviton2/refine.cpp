#define __REFINE_CPP__

#include <stdlib.h>
#include <stdio.h>
#include <float.h>

#ifdef WIN32
#define copysign _copysign
#endif

#include "constants.h"
#include "globals.h"
#include "parameters.h"
#include "Ccontig.h"
#include "timers.h"

#include "probeval.h"

using namespace probeval;

#define VALIGN  (USE_MIC ? 64 : 32)

double probeval::aNaN = nan("NaN");

#define FVERB 0 // display each SNP or Hap Indel change even with -FastSnps or -FastIndel 

int DELTA_XU, DELTA_YU;// initialized at start of qprobeval() and mprobeval()

/* To Do : 
Regular Refinement (eg RefineB):
   1. Avoid recomputing LP when "switched RANGE=6 to 6 .. " does NOT actually chanage any parameters
  


Haplotype Refinement:
   0. Limit phase inversion checks to 2 times, except (possibly) for Final check (Refinement only resumed after first check) (DONE)
   
   1a. Start with iter = 5 if Hap Indels are already present : active intervals are not reduced until iter >= HMIN_ITER. (DONE)
   1b. Avoid cleaning map1,map2 after every iteration, after the first 11 iterations : it will be done anyway before Hreposition (DONE)
   1c. Avoid rechecking hprobeval after spreading HapDelta[],Delta[]. (DONE)

   2a. Turn off switching off RANGE_Y and OutlierType, outlierLambda when Gradually restoring HapIndelPvalue, to stabilize refinement sooner. (Already DONE)
   2b During HINDEL_ANNEAL use larger steps (eg in multiples of 0.01, see HINDEL_ANNEAL) (DONE)
   3a. During HINDEL_ANNEAL Don't reset active intervals unless an Indel is deleted (and then only around region of Indel deleted) : This assumes no change in SNP Pvalue (Already DONE, except first change)
   3a2. Always activate intervals if an Indel is deleted (Already done : added printf) or when neighboring HapDelta are merged. (DONE)

   4b2. After reseting intervals, start with even iter value (so SNPs are check along with Indels) DONE for phase-reversals, filtering, Deres
   4c. Only activate intervals around each phase reversal (with window +- 300kb ?) DONE
   4d. When Deres'ing sites, activate only regions with merged sites ? DONE

   4e. Avoid deleting indels after every iteration : see -HapIndelSkip, increase from 2 to 5 after reaching target Pvalue ? Adjusted -HapIndelSkip from 2 to 5 (DONE)
   4f. When filtering SNPs/Indels activate only regions with merged sites ? DONE

   5. Speed up misc places where full hprobeval is being used by using increment hprobeval.   
   6. split mprobevalwinResize() into two ranges if extendonly was used.
 
For Extension Refinement:
   1. Reduce frequency of calling reposition() : see comment in code next to call

 */

// #define EXTENSION_TRIM extTrim /* At start of extension split refinement Trim back initial extension region by extendSplitFN + extendSplitFP labels */

#define HAPMINCOV_ENDFIX 1 /* force -endoutlier to -endoutlierFinal when computing alignments for -HapMinCov : this avoids creating spurious alignments in endoutlier regions */
#define HAPMINCOV_FIX 1 /* exlude unlabeled ends for coverage computation (for non-endoutliers : endoutliers are not included anyway) */

#define HAPFILTER_FIX 2 /* fixes for -HapFilter :
			   >= 1 : After Filtering Indels and SNPs re-try deleting HapIndels and rerun repositionH()
			   >= 2 : Avoid Filtering SNPs in middle of HapIndel : rely on Filtering of the entire HapIndel
			*/
#define HAPINDELDELETE_FIX 1 /* fix deletion of large HapIndels by also modifying SNPs within HapIndel to match Allele1 or Allele2 */

#define QUALITY2_FIX 1 /* include mis-resolved intervals in reference when estimating MolSd ExpSd MolCov ChiSq */ 

#define GLOBAL_FALLBACK 0 // triggers strange drop in LP during map1,map2 cleanup (iter <= HMIN_ITER+11) /* Before Hap UpdateMap, set globalfallback = 1 to force each map to compute some alignment : slightly slower, but only for Hap UpdateMap  */

#define MERGE_NORESIZE 0 /* WAS 1 */ /* Merge labels in AddDelete even if resize==0, provided at least 1 label was added/deleted */

#define MAX_DELTA_ITER HapMaxDeltaIter // Maximum number of interations in a row with only sizing changing (no HapIndel or SNP changes) before termination is forced
#define MAX_SWITCH_ITER HapMaxSwitchIter // Maximum number of HapIndel iterations before Switch options must be turned off and transition to 2nd phase with more stringent Pvalue is started

#define PHASE_DIST 300.0 // for each phase reversal activate intervals that overlap reversal point +- PHASE_DIST kb 

#define DEBUG_CONVERGE 0 // debug slow convergence by displaying verbose active region and SNP/indel updates after iter >= DEBUG_CONVERGE

#define TIME_VERBOSE 1 // (RELEASE ? 0 : 1)

#define FAST_SNPS_STARTUP FastSnpsStartup /* (HMIN_ITER/2) */ /* adjust startiter : If SNPs/Indels are already present start with this iteration instead of 0 */

#define FAST_SNPS FastSnps /* WAS37 2 */ // Don't apply FAST_HPROBEVAL >= 4 until iter >= FAST_SNPS + startiter
#define FAST_INDEL FastIndel /* WAS50 1 */ // Don't apply FAST_HPROBEVAL >= 5 until iter >= HMIN_ITER + FAST_INDEL * 2
#define FAST_SNP_HSETMAP 0 /* check hsetmap() in fastHapSite() : rarely provides a benefit and takes 90% of time of fastHapSite() */

#define INDEL_REVERSE HMIN_ITER /* WAS 0 */ /* TRY HMIN_ITER or HMIN_ITER+2 */ /* Try each new HapIndel in opposite orientation, provided iter <= INDEL_REVERSE */

#define HINDEL_ANNEAL_FAST 1 /* skip HINDEL_ANNEAL for HapIndelPvalue if there are no Indels (and for HapSitePvalue if there are no SNPs) left  */

#define LEFTEXT_FIX 1 /* when adding new labels left of current first label, prefer labels nearest first label */

#define SNP_TRACE 0 // only used for verbose debugging of SNP calls
#define ITER_ID 86 // Only used for debugging SNP calls
#define SITE_ID -1 // 287 // Only used for debugging SNP calls
#define SNP_ID 1 // HapSite value to debug (0..3) : Only used for debugging SNP calls

#define SNP_SCAN_FIX 1 /* WAS6 0 */ /* use slightly more agressive lookahead rule for SNPs (vs Indels) */

#define SNP_DELAY (HapSiteResDelay > 0.0 ? HapSiteResL : 0) /* Delay adding SNPs within SNP_DELTA_KB of other site during first SNP_ITER iterations of Haplotyping
							       1 : Only delay if nearby site is on same Allele
							       2 : Delay even for nearby sites on opposite Allele */
#define SNP_ITER HapSiteResN
#define SNP_DELTA_KB HapSiteResDelay

#define SITEMAP_ADJUST 2.0 // If called from Assembler, adjust sitemap[] by up to 2.0 * draftSD * res[0] * PixelLen to minimise labels that don't map to a consensus label

#define FILTER_FIRST (!HapFilterLast) /* Run coverage based Filter before rres/cres based Deres during haplotyping */
#define MERGE_SNPS HapMergeSNPs /* Merge nearby SNPs on opposite Alleles into a regular site */

#define SETLIMIT_CLEANUP 1 /* TRY 2 */ /* do minimal cleanup of map[] and mapK[] in setlimit() to make sure alignments are not crossed due to deleted (unmapped) labels in Hcuts[] 
					  1 : Don't actually update map[],mapK[]
					  2 : Update map[],mapK[] */
#define CORRECTMAP_CLEANUP 1 /* do minimal cleanup of map[] and mapK[] in correctmapH() to make sure alignments are not crossed due to deleted (unmapped) labels in Hcuts[] */

#define FAST_HPROBEVAL HapFast /* avoid calling full hprobeval() during Haplotype refinement, at risk of occasional LR errors
				  If FAST_HPROBEVAL >= 2, avoid global realignments.
				  If FAST_HPROBEVAL >= 3, skip some additional alternate configuration checks (when SNP is added inside a Het Indel)
				  If FAST_HPROBEVAL >= 4, Try to combine all SNP changes into single step, but back off to verifying one change at a time if that does not provide an improvement.
				  If FAST_HPROBEVAL >= 5, Try to combine all HapDelta & Delta changes into a single step, but back off to verifying one change at a time if that does not provide an improvement.
                               */
// #define CRES_FIX cresFix /* When merging labels due to -rres or -cres also try just deleting one of the two labels */

#define CRES_CUMULATIVE 0 /* WAS25 1 */ /* recheck nearby labels that were previosly checked when cres range is increased */


#define DELTA_SCAN_FIX 1 /* fix handling of DELTA_SCAN when neighboring regions have different Initial_Delta[IN][0] values (so indices are not comparable) */

#define DELTA_FIX 1 /* Fix subtle bug in interval size refinement : skip test points that are within 1e-8 of current interval value (see DELTA_FIX3 to avoid this) */
#define DELTA_FIX2 0 // HERE TRY 1 /* Fix another possible bug in interval size refinement */
#define DELTA_FIX3 1 /* A possible improvement to interval size refinement to avoid sample points same as current interval value (or within 1e-8) */
#define DELTA_FIX4 MULTIMODE_FIX2 // HERE TRY 1 /* Introduce assymetry in MULTIMODE_MP to avoid subsequent selection of test point being ambiguous */
#define DELTA_FIX5 0 /* HERE TRY 1 */ /* Avoid including last sample value Ydist[Q][Ycnt[Q]-1] if it does not differ from previously sampled value (lastval) by at least
					      max(MULTIMODE_DELTA_MIN, MULTIMODE_DELTA*lastval) */
#define CRES_CNT_FIX 1 /* fix how cres counts molecule alignments : previously was ignoring molecules that aligned only with the right label */

#define MULTIMODE_FIX2 1 /* WAS5 0 */  /* make Goldenmean search more robust (less likely to get stuck in local maxima) */
#define MULTIMODE_FIX3 2 /* WAS5 0 */ /* 1 : Use more robust finer grain Goldmean search to implement MPscan (instead of adding a fixed % ladder of sizes around the sample range)
					 2 : Use even more robust Goldenmean search by adding points at Low,High and at regular intervals expanding out */
#define MULTIMODE_FIX4 1 /* WAS5 0 */ /* 1 : Use peakLP[] instead of maxLP[] when computing conflictLP[] (inside Goldenmean loop)
					 2 : Leave Goldenmean range unchanged if interval will NOT be changed (due to singlechange) : HERE HERE : NOT CORRECTLY IMPLEMENTED since
					     further range expansion is triggered by MULTIMODE_FIX2 >= 2 ! */
#define MULTIMODE_FIX5 0 /* HERE HERE 1 */ /* WAS5 0 */ /* limit additional equidistant points to 1 when MPscan==0 : based on Xchange[Q-1,Q+1] and conflictLP[Q] (if not backtracking) : ASSERTION FAILURE */

#define HAP_INDEL_SKIP_FIX 1 /* Don't skip HapIndel merge if we just adjusted the HapIndelPvalue */
#define SNP_SKIP_LIMIT 3 /* Don't skip HapSite iterations more than this many times in a row */

#define LPDROP_FIX 1  /* fix in check for LP drop caused by Switch options : updated LPhwm to include improvements due to indel iteration */
#define SWITCH_FIX 1 /* Before UpdateMap during Haplotyping, use the Switch options for the Indel iteration (to avoid changes), 
			instead of reverting to pre-Haplotyping values (NOTE : if -SwitchFade is used SWITCH_FIX is forced to 1) */

#define SITECNT_FIX 0 /* Moved to build_contig() in refalign.cpp (init ? 0 : 1) */ /* fix sitecnt[] to reflect molecules remaining */

#define SPLIT_FIX SplitRev /* TEST 0 , 1,2 or 3 */ /* New experimental version of Contig Split (see output_draft.cpp) */

#define SPEEDCHECK 1 // (RELEASE ? 0 : 1) /* WAS 0 */ /* more verbose mprobeval() timing display (but not as verbose as SVERB) */

#define SCANFIX 1 /* fix error in mprobevalwin() */

#define MPROBEVAL (Mprobeval ? 2 : 0) /* use mprobeval() in AddDelete() (If 2 also use it for SizesEstimate) */

// int MDEBUG = 1;
// int MDEBUG_M = -1;
// int MDEBUG_ST = -1;

#define MDEBUG_DEL 0 /* enable MDEBUG for site deletion */
#define MDEBUG_ADD 0 /* enable MDEBUG for site addition */
#define MDEBUG_DELTA 0 /* enable MDEBUG for site interval changes */

#define MDEBUG_ERR 0.1 /* 0.001 */ /* IF MDEBUG: exit if LP error ever exceeds MDEBUG_ERR */
#define LP_DROP 0.11  /* ignore errors in mprobeval if true LP drops by this amount or more and mLP drops as well (by any amount) */
#define MDEBUG_NEGERR 0 // HERE HERE 1 /* Only track errors where predicted LP is below true LP (the only type of error that can cause suboptimal results, ignoring runtime) NOT YET IMPLEMENTED for Haplotypeing */

static int nverb = 0;

/* see probeval.h for more details about the following variables */
MFLOAT probeval::logMaxScale;// log(MaxScale)
MFLOAT probeval::logMaxUR;// log(MaxUR)
double probeval::Smin;// smallest possible interval sizing error = sqrt(min(SF[0]^2, SF[0]^2 + SD[0]^3|SD[0]|/(4*SR[0]^2)))
double probeval::MaxFAG;// MaxFA/(Smin * RefPen * sqrt(0.5))
MFLOAT probeval::logMaxFAG;// log(MaxFAG)
double probeval::MaxFAG2;// MaxFA/RefPen
MFLOAT probeval::logMaxFAG2;// log(MaxFAG2)

#include "refine.h"

#ifndef NANOTIME
#ifdef WIN32
#define NANOTIME 0
#else
#define NANOTIME 1 /* Set to 1 for precise execution time display : only works on Linux and requires use of -lrt in Makefile */
#endif
#endif

#include <time.h>

static double mtime_init = 0.0;
static double wtime_init = 0.0;

double mtime()
{
#if NANOTIME >= 1
  struct timespec t;
  clock_gettime(CLOCK_PROCESS_CPUTIME_ID,&t);
  double time = t.tv_sec + (t.tv_nsec * 1.0e-9);
#else
  double time = 0.0;
#endif

  if(mtime_init <= 0.0)
    mtime_init = time;
  return time - mtime_init;
}

#ifdef WIN32
#include <ctime>
double wtime()
{
  time_t timer;
  struct tm y2k;
  double seconds;

  y2k.tm_hour = 0;   y2k.tm_min = 0; y2k.tm_sec = 0;
  y2k.tm_year = 100; y2k.tm_mon = 0; y2k.tm_mday = 1;

  time(&timer);  /* get current time; same as: timer = time(NULL)  */
  seconds = difftime(timer,mktime(&y2k));
  return seconds;
}
#define IN VAR_IN
#else
#include <sys/time.h>

double wtime()
{
  struct timeval tv;
  if(gettimeofday(&tv,0))
    return -0.999999;
  double time = tv.tv_sec + tv.tv_usec*1e-6;

  if(wtime_init <= 0.0)
    wtime_init = time;
  return time - wtime_init;
}
#endif

long long probeval::VmSize = 0, probeval::VmRSS = 0, probeval::VmSwap = 0, probeval::VmHWM = 0, probeval::VmPeak = 0;

int probeval::global = 0;
int probeval::globalfallback = 0 /* WAS 1 */;/* In setlimit() if no previous alignment information is available fall back to :
				 0 : No alignment, causing qprobeval to return LRbias as the likelihood (similar for mprobeval, for all variants)
				 1 : global alignment, which can be much slower and also cause UpdateMap to fail since the missing alignment map scores better! */

lightweight_heap *probeval::heap = NULL;

static Ident Id("$Header: http://svn.bnm.local:81/svn/Informatics/RefAligner/branches/11442/refine.cpp 11643 2020-09-25 01:17:06Z tanantharaman $");

int NmaxLP = 0;/* allocation size for 2nd index of newLPdelta[][][] and newLPd[][] */
double **newLPd = 0;/**< newLPd[0..MD-1][I=0..N] : used to store per map mprobeval site deletion LP values (if VMEM_MINIMIZE, only newLPd[m=0..MD-1][I = DminM[m] .. DmaxM[m]] will be allocated) */
double *newLPd0 = 0;/* newLPd0[0..MD-1] : used to store per map values of newLPd[m][0] (which may not be allocated, if VMEM_MINIMIZE) */
int **newLPdPr = 0;/**< flag if newLPd value is low precision (due to drop in LP) : used for debugging */
int *DminM = 0, *DmaxM = 0;/**< DminM[0..MD-1],DmaxM[0..MD-1] limit the range of I index of newLPd[m][I] for which values were set in mprobeval (all other values equal newLPd0[m] */

double **newLPa = 0;/**< newLPa[0..MD-1][t=0..MaxAddcnt-1] : used to store per map mprobeval site addition LP values */
int **newLPaPr = 0;/**< flag if newLPa value is low precision (due to drop in LP) : used for debugging */
int MaxAddcnt = 0;/* allocation size for newLPa[][],newLPaPR[][] */
int *TminM = 0, *TmaxM = 0;/**< TminM[0..MD-1],TmaxM[0..MD-1] limit the range of t index of newLPa[] for which values were set in mprobeval() */

int *Dcum = 0;/* Dcum[I=0..N] = sum(t = 0..I-1) D[I] */
double **newLPdelta = 0;/**< newLPdelta[m=0..MD-1][Dcum[I=0..N] + (d=0..D[I]-1)] : used to store per map mprobeval site interval change LP values */
int MaxDelta = 0;/* allocation size for newLPdeltaMem[] : maximum values of sum(I=1..N-1) D[I] */
int *AminM = 0, *AmaxM= 0; /**< AminM[0..MD-1],AmaxM[0..MD-1] limit the range of I index of newLPdelta for which return values were set in mprobeval() */
double *newLPdeltaMem = 0;/* single block of memory for 2nd index of newLPdelta[][] (NOT used if VMEM_MINIMIZE) */

class Caddloc {
public:
  double loc;/* If i < 0 : projected location of unaligned site (and ends) X[m][J] in Hcuts[] (i = -2 for protected sites corresponding to Hcuts[Lfrozen] etc)
		       For repositionH, value of -3 or -4 is used to distinguish between map1[] and map2[] as the source of unaligned site (reduced by 2 for protected sites Hcuts[Lfrozen] etc)
		If i >= 0 : original locations of aligned sites in Hcuts[i] (see i) */
  int i;/* If i >= 0 : original location in Hcuts[i] with m == Hdel[i] (or HapSite[i]) (J undefined) : 
	   typically Hdel[i]==0 (OR HapSite[i] != 0) unless these are markers for Hcuts[Lfrozen] etc corresponding to consensus ends etc */
  int m;
  int J;
};

static int doubleInc(double *p1, double *p2)
{
  double v1 = *p1, v2 = *p2;
  return (v1 > v2) ? 1 : (v1 < v2) ? -1 : 0;
}

static int doubleDec(double *p1, double *p2)
{
  double v1 = *p1, v2 = *p2;
  return (v1 < v2) ? 1 : (v1 > v2) ? -1 : 0;
}

static int CaddlocInc(Caddloc *p1, Caddloc *p2)
{
  double v1 = p1->loc, v2 = p2->loc;
  return (v1 > v2) ? 1 : (v1 < v2) ? -1 : 0;
}

typedef int intcmp (const void *,const void *);


/** sort Cydist::val in increasing order */
int Cydistinc(register Cydist *p1, register Cydist *p2)
{
  register double id1 = p1->val;
  register double id2 = p2->val;
  
  return (id1 > id2) ? 1 : (id1 < id2) ? -1 : 0;
}

static int updateVerb = 0;
#define KTRACE -1 // (CMapID == 409 ? 1200 : 1570)

void UpdateMap(int n, int N, double *Y,
	       int MD, int *MX, double **X, 
	       double *Hcuts,/**< Hcuts[0..n+1] */
	       int *Hdel,/**< Hdel[0..n+1] */
	       int **map, /**< map[m=0..MD-1][j=0..MX[m]+1] is index in Hcuts[0..n+1] of X[m][j] (will be updated based on nmap), 
				      map[MD][j=0..n+1] is index in Y[0..N+1] of Hcuts[j] (NOTE: map[][] is same as pcontig->sitemap[][]) */
	       int **mapK, /**< mapK[m=0..MD-1][j=0..MX[m]+1] is K index offset in Hcuts[0..n+1] of X[m][j] (will be updated based on nmapK) */
	       Csetlimit *limit, /* limit[m=0..MD-1] will have the ileft and imin fields reset to -1, if map[m] or mapK[m] are changed */
	       int **nmap, /**< nmap[m=0..MD-1][j=0..MX[m]+1] is new index in Y[0..N+1] of X[m][j], 
				       nmap[MD][j=0..N+1] is new index in Hcuts[0..n+1] of Y[j] */
	       int **nmapK, /**< nmapK[m=0..MD-1][j=0..MX[m]+1] is new K index offset in Y[0..N+1] of X[m][j]
					However nmapK[0] == Lij, mapK[MX[m]+1] == Rij (-ve if ends are outliers unless OUTLIER_FIX >= 1) */
	       double *mapWT,/**< mapWT[m=0..MD-1] : If != 0 mapWT[m] is the map weight used when updating fragcnt[], sitecnt[], sitecntFN[] etc
				When pcontig != 0 this is the product of TBmapWT (depending on -TB -BestRefWT) and -LRbias based mapWT[] = LR[m]/(LR[m]+LRbias) */
	       Ccontig *pcontig, /**< pointer to complete contig : If != 0 the fragcnt[],sitecnt[],sitecntFN[] values are updated based on the new mapping (eg Hcuts[] == pcontig->site[]) */
	       int FillMap
	       // HERE HERE TBmapWT /* Used when pcontig == 0 to skip maps with TBmapWT[m] == 0.0, to speed up UpdateMap */
	       )
{
  if(KTRACE>=0 && pcontig)  updateVerb = 1;

  if(VERB && updateVerb){
    printf("Starting UpdateMap:MD=%d,KTRACE=%d,n=%d,N=%d\n",MD,KTRACE,n,N);
    fflush(stdout);
  }

  int numthreads = 1;
  #ifdef _OPENMP
  numthreads = MaxThreads; // WAS omp_get_max_threads();
  numthreads = min(numthreads,RefineThreads);
  if(DEBUG) assert(numthreads >= 1);
  #endif

  int block = 1;
  while(block < 16 && MD > numthreads * block * 8)
    block *= 2;

  if(DEBUG>=1+RELEASE){	/* check map[m][J],mapK[m][J] for consistency */
    #pragma omp parallel for num_threads(numthreads) schedule(static,block)
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      int lastJ = -1, lasti = -1, lastk = -1;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
	  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	  fflush(stdout);
	  assert(0 <= k && k < i);
	}
	int I = map[MD][i];
	if(I < 0)
	  continue;
	if(lasti >= 0 && !(i-k > lasti)){
	  #pragma omp critical
	  {
	    printf("\nmap:m=%d,M=%d:J=%d,i=%d,k=%d,map[MD][i]=I=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,M,i,k,I,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[m][j];
		if(i < 0)
		  continue;
		int k = mapK[m][j];
		printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=k=%d,map[MD][i]=I=%d,map[MD][k]=K=%d\n",j,i,k,I,map[MD][k]);
	      }
	    }
	    fflush(stdout);
	    assert(I >= 0 && i-k > lasti);
	  }
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }
  }

  int *nmapMD = nmap[MD];
  float *sitecnt = 0;
  float *sitecntFN = 0;
  float *sitecntN1[MAX_CHIM] = {NULL};
  float *fragcnt = 0;
  float *fragcntT = 0;
  float *sitecntN2 = 0;
  float *sitecntN3 = 0;
  float *sitecntN4 = 0;
  float *sitecntN5 = 0;
  float *sitecntN6 = 0;

  float *fragSd = 0;
  float *expSd = 0;
  float *fragBias = 0;
  float *fragCov = 0;
  float *fragChiSq = 0;

  double *wtSum = 0, *varSum = 0, *meanSum = 0, *varySum = 0;

  float *fragcntTnorm = 0;
  float *sitecntFNnorm = 0;
  if(DEBUG) assert(nmapMD[-1] == -1);
  if(pcontig){
    sitecnt = pcontig->sitecnt[0];
    sitecntFN = pcontig->sitecntFN[0];
    for(int t = 0; t < mCNT; t++)
      sitecntN1[t] = pcontig->sitecntN1[0][t];
    fragcnt = pcontig->fragcnt[0];
    fragcntT = pcontig->fragcntT[0];
    if(DEBUG) assert(fragcntT != 0);
    fragcntTnorm = pcontig->fragcntTnorm[0];
    if(DEBUG && CovNorm) assert(fragcntTnorm != 0);
    if(TrimNorm >= 0){
      sitecntFNnorm = pcontig->sitecntFNnorm[0];
      sitecntN2 = pcontig->sitecntN2[0];
      sitecntN3 = pcontig->sitecntN3[0];
      sitecntN4 = pcontig->sitecntN4[0];
      sitecntN5 = pcontig->sitecntN5[0];
      sitecntN6 = pcontig->sitecntN6[0];

      fragSd = pcontig->fragSd[0];
      expSd = pcontig->expSd[0];
      fragBias = pcontig->fragBias[0];
      fragCov = pcontig->fragCov[0];
      fragChiSq = pcontig->fragChiSq[0];

      if(OutlierQuality >= 2){
	wtSum = new double[(n+2)*4];
	varSum = &wtSum[n+2];
	meanSum = &wtSum[(n+2)*2];
	varySum = &wtSum[(n+2)*3];
      }
      
      if(DEBUG){
	assert(sitecntFNnorm != 0);
	assert(sitecntN2 != 0);
	assert(sitecntN3 != 0);
	assert(sitecntN4 != 0);
	assert(sitecntN5 != 0);
	assert(sitecntN6 != 0);
	assert(fragSd != 0);
	assert(expSd != 0);
	assert(fragBias != 0);
	assert(fragCov != 0);
	assert(fragChiSq != 0);
      }
    }

    fragcnt[0] = 0;
    fragcntT[0] = 0;
    fragcnt[n+1] = 0;
    fragcntT[n+1] = 0.0;
    for(register int k = 1; k <= n; k++){
      fragcntT[k] = fragcnt[k] = sitecnt[k] = sitecntFN[k] = 0.0;
      for(int t = 0; t < mCNT; t++)
	sitecntN1[t][k] = 0.0;
    }
    if(CovNorm)
      for(register int k = 0; k <= n+1; k++)
	fragcntTnorm[k] = 0.0;
    if(TrimNorm >= 0){
      for(register int k = 0; k <= n+1; k++){
        sitecntFNnorm[k] = sitecntN2[k] = sitecntN3[k] = sitecntN4[k] = sitecntN5[k] = sitecntN6[k] =           fragSd[k] = expSd[k] = fragCov[k] = fragBias[k] = fragChiSq[k] = 0.0f;
        if(OutlierQuality >= 2)
	  wtSum[k] = varSum[k] = meanSum[k] = varySum[k] = 0.0;
      }
    }
  }

  int maxM = 0;
  for(int m = 0; m < MD; m++)
    maxM = max(maxM,MX[m]);

  int nthreads = max(1,min(numthreads,MD));
  size_t mapMMsiz = (size_t)(maxM+2) * (size_t)nthreads;
  int *mapMM = new int[mapMMsiz * 2ul];
  int *mapKMM = &mapMM[mapMMsiz];

  int LoopCnt = 0;  
  #pragma omp parallel num_threads(nthreads) if(!pcontig)
  {
    int myLoopCnt = 0;
    int tid = 0;
    #ifdef _OPENMP
    tid = omp_get_thread_num ();
    #endif

    #pragma omp for schedule(static,16)
    for(int m= 0;m < MD; m++){
      if(OMP_DEBUG) myLoopCnt++;

      if(SETLIMIT_CACHE)
	limit[m].ileft = -1;

      if(VERB>=2 && pcontig){
	printf("m=%d/%d: id=%lld, mapWT[m]= %0.6e\n",m,MD,gmap[pcontig->contig[m].mapid]->id,mapWT[m]);
        fflush(stdout);
      }

      // HERE HERE      if(TBmapWT[m] <= 0.0 && !pcontig) continue;

      if(DEBUG && !isfinite(mapWT[m])){
	#pragma omp critical
	{
	  printf("m=%d/%d: mapWT[m]= %0.6e\n",m,MD,mapWT[m]);
	  fflush(stdout);
	  assert(isfinite(mapWT[m]));
	}
      }
      float wt = mapWT[m];

      int M = MX[m];
      int *mapM = &mapMM[(maxM+2)*tid];// scratch memory for map[m]; // NOTE : reduce use of global memory
      int *mapKM = &mapKMM[(maxM+2)*tid];//scratch memory for mapK[m];// NOTE : reduce use of global memory
      int *nmapM = nmap[m];
      int *nmapKM = nmapK[m];
      double *Xm = X[m];

      int JL= -1,iL = -1, iR = -1; //JR
    
      int Mcnt = 0; /* how many sites in X[m] are aligned with Y[] */

      int lastJ = -1, lasti = -1, lastk = -1;

      for(int J = 0; J <= M+1; J++){
	int I = nmapM[J];
	if(DEBUG && !(I >= -1 && I <= N+1)){
          #pragma omp critical
	  {
	    printf("UpdateMap:m=%d/%d:J=%d,M=%d,N=%d,nmap[m][J]=I=%d\n",m,MD,J,M,N,nmap[m][J]);
	    fflush(stdout);
	    assert(I >= -1 && I <= N+1);
	  }
	}
	int i = nmapMD[I];
	if(DEBUG) assert(i >= -1 && i <= n+1);
	if(DEBUG && 1 <= i && i <= n && Hdel[i]){
          #pragma omp critical
	  {
	    printf("UpdateMap:m=%d/%d:M=%d,N=%d,n=%d:J=%d,nmap[m][J]=I=%d,nmapMD[I]=i=%d,Hdel[i]=%d\n",
		   m,MD,M,N,n,J,I,i,Hdel[i]);
	    fflush(stdout);
	    assert(!Hdel[i]);
	  }
	}
	int k = mapKM[J] = 0, K = 0;
	if(J >= 1 && J <= M){
	  K = (i >= 0) ? nmapKM[J] : 0;
	  if(DEBUG && i>=0) assert(K >= 0 && K <= KMAX && K <= I);
	  k = nmapMD[I-K];
	  if(DEBUG) assert(-1 <= k && k <= n+1);
	  if(DEBUG/* HERE >=2 */ && i >= 0 && !(map[MD][k] == I-K)){
	    printf("m=%d/%d:J=%d,nmapM[J]=I=%d,nmapMD[I]=i=%d,nmapKM[J]=K=%d,nmapMD[I-K]=k=%d: map[MD][k]=%d (expected I-K)\n",
		   m,MD,J,I,i,K,k,map[MD][k]);
	    fflush(stdout);
	    assert(map[MD][k] == I-K);
	  }
	  if(DEBUG && 1 <= i && i <= n && Hdel[k]){
            #pragma omp critical
	    {
	      printf("UpdateMap:m=%d/%d:M=%d,N=%d,n=%d:J=%d,nmapK[m][J]=K=%d,nmapMD[I-K]=k=%d,Hdel[k]=%d\n",
		     m,MD,M,N,n,J,K,k,Hdel[k]);
	      fflush(stdout);	    
	      assert(!Hdel[k]);
	    }
	  }
	  if((MDEBUG_SETLIMIT>=2 && m==MDEBUG_M) || (VERB>=2 && stage >=2 && (m==728 || m==9244))){
            #pragma omp critical
            {
	      printf("m=%d,mapWT[m]=%0.3f:J=%d,X[J]=%0.3f,nmap[m][J]=I=%d,nmapK[m][J]=K=%d,nmap[MD][I]=i=%d,nmap[MD][I-K]=i-k=%d, map[m][J]=%d -> %d",
		     m,mapWT[m],J,X[m][J],I,K,i,k, map[m][J], i);
	      if(map[m][J] >= 0){
		int oldi = map[m][J];
		printf(",Hcuts[%d]=%0.3f,Hdel[%d]=%d", oldi,Hcuts[oldi], oldi, Hdel[oldi]);
		if(!Hdel[oldi]){
		  int oldI = map[MD][oldi];
		  printf(",Y[%d]=%0.3f",oldI,Y[oldI]);
		}
	      }
	      if(i >= 0)
		printf(",Hcuts[i]=%0.3f,Hdel[i]=%d",Hcuts[i],Hdel[i]);
	      printf("\n");
	      fflush(stdout);
	    }
	  }
	  if(i >= 0){
	    if(DEBUG) assert(i <= n+1);
	    if(DEBUG) assert(k >= 0 && k <= i);
	    if(DEBUG && i > n) assert(K==0 && k == i);
	    if(DEBUG && i <= 0) assert(K==0 && k == i);
	    if(DEBUG && i > 0 && i <= n) assert(k > 0);
	    if(VERB>=2 && updateVerb && gmap[pcontig->contig[m].mapid]->id == 1131303LL){
	      printf("UpdateMap:m=%d,MD=%d:J=%d,M=%d,nmapM[J]=I=%d,nmapMD[I]=i=%d,nmapKM[J]=K=%d,nmapMD[I-K]=k=%d:map[m][J]=%d->%d(i),mapK[m][J]=%d(i-k),Hdel[i]=%d,Hdel[k]=%d,n=%d\n",
		     m,MD,J,M,I,i,K,k,map[m][J],i,i-k,Hdel[i],Hdel[k],n);
	      fflush(stdout);
	    }
	    mapKM[J] = k = i-k;
	  }  else if(VERB>=2 && updateVerb && gmap[pcontig->contig[m].mapid]->id == 1131303LL){
	    printf("UpdateMap:m=%d,MD=%d:J=%d,M=%d,nmapM[J]=I=%d,nmapMD[I]=i=%d:map[m][J]=%d(%d)->%d(i),n=%d\n",
		   m,MD,J,M,I,i,map[m][J],mapM[J],i,n);
	    fflush(stdout);
	  }
	}
	if(DEBUG && 1 <= J && J <= M && i >= 0 && Hdel[i] ){
	  printf("UpdateMap:m=%d,MD=%d:J=%d,M=%d,nmap[m][J]=I=%d,nmap[MD][I]=i=%d,n=%d,Hdel[i]=%d: map[m][J]= %d -> %d\n",
	      m,MD,J,M,nmap[m][J],nmap[MD][I], n, Hdel[i], map[m][J], i);
	  fflush(stdout);
	  assert(!Hdel[i]);
	}
	if(VERB>=3 && m==462 && J==1){
	  printf("UpdateMap:m=%d,MD=%d:J=%d,M=%d,nmap[m][J]=I=%d,nmap[MD][I]=i=%d,n=%d,Hdel[i]=%d: mapM[J]= %d -> %d (Hdel[mapM[J]]=%d, mapM=%p)\n",
	      m,MD,J,M,nmap[m][J],nmap[MD][I], n, (i < 0) ? -1 : Hdel[i], map[m][J], i, (mapM[J] < 0) ? -1 : Hdel[mapM[J]], map[m]);
	  fflush(stdout);
	}
	if(VERB>=2 && m==9 && J >= 1){
	  if(i >= 0)
	    printf("\nmap:m=%d,J=%d,nmap[m][J]=I=%d,nmapK[m][J]=K=%d:nmap[MD][I]=i=%d,nmap[MD][I-K]=i-k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d:map[m][J]= %d -> %d\n",
		   m,J,I,K, i, i-k ,lastJ,lasti,lastk,Hdel[i],Hdel[i-k], map[m][J], i);
	  else
	    printf("\nmap:m=%d,J=%d,nmap[m][J]=I=%d,nmapK[m][J]=K=%d:nmap[MD][I]=i=%d:lastJ=%d,lasti=%d,lastk=%d: map[m][J]= %d -> %d\n",
		   m,J,I,K, i, lastJ,lasti,lastk,map[m][J], i);
	  fflush(stdout);
	}

	mapM[J] = i;

	if(DEBUG>=3 && i >= 0){
	  if(lasti >= 0 && !(i-k > lasti)){
	    printf("\nmap:m=%d,J=%d,I=%d,K=%d:i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,I,(1 <= J) ? nmapKM[J] : -1, i, k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int I = nmapM[J];
		if(I < 0)
		  continue;
		int i = nmapMD[I];
		if(DEBUG) assert(i >= 0);
		int K = nmapKM[J];
		if(DEBUG) assert(0 <= K && K <= KMAX && K <= I);
		int k = nmapMD[I-K];
		printf("\t J=%d:nmap[m][J]=I=%d,nmap[MD][I]=i=%d,nmapK[m][J]=K=%d,nmap[MD][I-K]=i-k=%d\n",J,I,i,K,k);
	      }
	    }
	    assert(i-k > lasti);
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
        }

	if(i >= 0)
	  Mcnt++;

	if(sitecnt && wt > 0.001f && i >= 0){
	  register int k = mapKM[J];
	  if(k==0)
	    sitecnt[i] += wt;
	  else {
	    /* increment the entire range */
	    for(register int t = i-k; t <= i; t++)
	      sitecnt[t] += wt;
	  }
	  if(JL < 0){
	    iL = i-k;// WAS90 i;
	    JL = J;
	  }
	  iR = i;
	  //	JR = J;
	}
      }
      if(VERB && updateVerb && iL <= KTRACE && KTRACE <= iR/*  && gmap[pcontig->contig[m].mapid]->id == 1131303LL */){
	if(TrimNorm >= 0)
	  printf("UpdateMap:m=%d/%d(id=%lld): %d sites in X[] align with Y[]: sitecnt[%d ... %d] incremented by mapWT[m]=%0.3f(sitecnt[k=%d]=%0.3f,sitecntFN[k]=N1=%0.3f,N2=%0.3f,N3=%0.3f)\n",
             m,MD,gmap[pcontig->contig[m].mapid]->id,Mcnt,iL,iR,mapWT[m],KTRACE,sitecnt[KTRACE],sitecntFN[KTRACE],sitecntN2[KTRACE],sitecntN3[KTRACE]);
	else
	  printf("UpdateMap:m=%d/%d(id=%lld): %d sites in X[] align with Y[]: sitecnt[%d ... %d] incremented by mapWT[m]=%0.3f(sitecnt[k=%d]=%0.3f,sitecntFN[k]=%0.3f)\n",
             m,MD,gmap[pcontig->contig[m].mapid]->id,Mcnt,iL,iR,mapWT[m],KTRACE,sitecnt[KTRACE],sitecntFN[KTRACE]);
	fflush(stdout);
      }
      if(DEBUG>=2 && Mcnt <= 0){
	printf("WARNING in UpdateMap:m=%d no longer aligned with reference according to nmap[] (leaving map[] unchanged)\n",m);
	fflush(stdout);
      }
      if(1 /* NEW WAS Mcnt > 0 */){/* save mapM[] and mapKM[] to global memory */
	for(int J = 0; J <= M; J++){
	  if(VERB>=2 && updateVerb && (m==728 || m==9244)){
	    #pragma omp critical
	    {
	      printf("UpdateMap:m=%d,MD=%d:J=%d,M=%d,mapM[J]=%d,mapKM[J]=%d:map[m][J]=%d -> %d, mapK[m][J]=%d -> %d\n",
		     m,MD,J,M,mapM[J],mapKM[J],map[m][J],mapM[J],mapK[m][J], mapKM[J]);
	      fflush(stdout);
	    }
	  }
	  map[m][J] = mapM[J];
	  mapK[m][J] = mapKM[J];
	}
	mapM = map[m];
	mapKM = mapK[m];
      }

      if(DEBUG>=3){/* make sure map[] and mapK[] are consistent */
	int lastJ = -1, lasti = -1, lastk = -1, i, k;
	for(int J = 1; J <= M; J++){
	  if((i=map[m][J]) > 0){
	    k = mapK[m][J];
	    assert(0 <= k && k < i);
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("\nm=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d\n",m,J,i,k,lastJ,lasti,lastk);
	      if(VERB){
		for(int j = 1; j <= M; j++){
		  int i = map[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK[m][j];
		  printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d\n",j,i,k);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }

      if(FillMap && !pcontig && Mcnt > 0){
	/* Locate first and last aligned sites */
	int JL,JR, iL= -1, iR = -1;
	for(JL = 1; JL <= M; JL++)
	  if((iL = mapM[JL]) > 0){
	    iL -= mapKM[JL];// NEW
	    break;
	  }
	for(JR = M; JR >= 1; JR--)
	  if((iR = mapM[JR]) > 0)
	    break;
	if(DEBUG) assert(1 <= JL && JL <= JR && JR <= M);
	if(DEBUG && !(1 <= iL && iL <= iR && iR <= n)){
          #pragma omp critical
	  {
	    printf("m=%d/%d:JL=%d,iL=%d,JR=%d,iR=%d,M=%d\n",m,MD,JL,iL,JR,iR,M);
	    fflush(stdout);
	    assert(1 <= iL && iL <= iR && iR <= n);
	  }
	}

	if(VERB>=2 && updateVerb && (m==728 || m==9244)){
	  #pragma omp critical
	  {
	    printf("\nm=%d:JL=%d,X[JL]=%0.3f,JR=%d,X[JR]=%0.3f,iL=%d,Hcuts[iL]=%0.3f,iR=%d,Hcuts[iR]=%0.3f,M=%d,n=%d\n\n",
		   m,JL,Xm[JL],JR,Xm[JR],iL,Hcuts[iL],iR,Hcuts[iR],M,n);
	    fflush(stdout);
	  }
	}

	int i = iR;
	int ip = i;
	for(int J = JR+1;J <= M; J++){
	  /* locate site Hcuts[i] that best matches Xm[J] */
	  double delta = Hcuts[iR] + Xm[J] - Xm[JR];
	  if(DEBUG) assert(delta > Hcuts[iR]);
	  while(i < n && Hcuts[i] < delta)
	    i++;
	  if(fabs(delta-Hcuts[i]) > fabs(delta-Hcuts[i-1]))
	    i--;

	  /* check if Xm[J-1] is closer (or as close) to Hcuts[i] */
	  if(fabs(delta-Hcuts[i]) >= fabs(Hcuts[iR]-Hcuts[i] - (Xm[JR] - Xm[J-1])) - 1e-6)
	    continue;

	  /* check if Xm[J+1] is closer to Hcuts[i] */
	  if(J < M && fabs(delta-Hcuts[i]) > fabs(Hcuts[iR]-Hcuts[i] - (Xm[JR] - Xm[J+1])) + 1e-6)
	    continue;

	  if(VERB>=2 && updateVerb && (m==728 || m==9244)){
	    #pragma omp critical
	    {
	      printf("m=%d:J=%d,X[J]=%0.6f,map[m][J] -> i=%d, Hcuts[i]=%0.6f, delta=%0.6f (err at Hcuts[i-1,i,i+1]:%0.6f,%0.6f,%0.6f, at Xm[J-1,J,J+1]:%0.6f,%0.6f,%0.6f)\n", 
		     m, J, Xm[J], i, Hcuts[i], delta, Hcuts[i-1]-delta, Hcuts[i]-delta, Hcuts[i+1]-delta,
		     Hcuts[iR]-Hcuts[i] - (Xm[JR] - Xm[J-1]), Hcuts[iR]-Hcuts[i] - (Xm[JR] - Xm[J]), Hcuts[iR]-Hcuts[i] - (Xm[JR] - Xm[J+1]));
	      fflush(stdout);
	    }
	  }
	  map[m][J] = max(ip+1, i);// NEW
	  if(DEBUG) assert(mapK[m][J] == 0);
	  if((ip = map[m][J]) >= n)// NEW
            break;
	}

	i = ip = iL;
	for(int J = JL-1; J >= 1; J--){
	  /* locate site Hcuts[i] that best matches Xm[J] */
	  double delta = Hcuts[iL]-(Xm[JL] - Xm[J]);
	  while(i > 1 && Hcuts[i] > delta)
	    i--;
	  if(fabs(delta-Hcuts[i]) > fabs(delta-Hcuts[i+1]))
	    i++;

	  /* check if Xm[J-1] is closer to Hcuts[i] */
	  if(J > 1 && fabs(delta-Hcuts[i]) > fabs(Hcuts[iL]-Hcuts[i] - (Xm[JL] - Xm[J-1])) + 1e-6)
	    continue;

	  /* check if Xm[J+1] is closer (or as close) to Hcuts[i] */
	  if(fabs(delta-Hcuts[i]) >= fabs(Hcuts[iL]-Hcuts[i] - (Xm[JL] - Xm[J+1])) - 1e-6)
	    continue;

	  if(VERB>=2 && updateVerb && (m==728 || m==9244)){
	    #pragma omp critical
	    {
	      printf("m=%d:J=%d,X[J]=%0.3f,map[m][J] ->%d, Hcuts[%d]=%0.3f\n", m, J, Xm[J], i,i,Hcuts[i]);
	      fflush(stdout);
	    }
	  }
	  map[m][J] = min(ip/* WAS iL */-1, i);// NEW
	  if(DEBUG) assert(mapK[m][J] == 0);
	  if((ip = map[m][J]) <= 1)// NEW
	    break;
	}

	if(DEBUG){/* check that no 2 consecutive sites Xm[J,J+1] are mapped to the same site Hcuts[i] */
	  for(register int J = 1; J < M; J++){
	    if(!(map[m][J] != map[m][J+1] || map[m][J] == -1)){
	      printf("m=%d:JL=%d,X[JL]=%0.3f,JR=%d,X[JR]=%0.3f,iL=%d,Hcuts[iL]=%0.3f,iR=%d,Hcuts[iR]=%0.3f,M=%d,n=%d\n",
		     m,JL,Xm[JL],JR,Xm[JR],iL,Hcuts[iL],iR,Hcuts[iR],M,n);
	      for(int j = 1; j <= M; j++){
                int i = map[m][j];
		printf("\t J=%d:map[m][J]=i=%d, Hcuts[i]= %0.4f, Xm[J]= %0.4f\n", j, i, (0 <= i && i <= n+1) ? Hcuts[i] : -1.0, Xm[j]);
              }
	      printf("m=%d:J=%d,map[m][J]=%d,map[m][J+1]=%d\n",m,J,map[m][J],map[m][J+1]);
	      fflush(stdout);

	      assert(map[m][J] != map[m][J+1] || map[m][J] == -1);
	    }
	  }
	}

	if(DEBUG>=3){/* make sure map[] and mapK[] are consistent */
	  int lastJ = -1, lasti = -1, lastk = -1, i, k;
	  for(int J = 1; J <= M; J++){
	    if((i=map[m][J]) > 0){
	      k = mapK[m][J];
	      assert(0 <= k && k < i);
	      if(lasti >= 0 && !(i-k > lasti)){
		printf("\nm=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d\n",m,J,i,k,lastJ,lasti,lastk);
		if(VERB){
		  for(int j = 1; j <= M; j++){
		    int i = map[m][j];
		    if(i < 0)
		      continue;
		    int k = mapK[m][j];
		    printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d\n",j,i,k);
		  }
		}
		fflush(stdout);
		assert(i-k > lasti);
	      }
	      lasti = i;
	      lastk = k;
	      lastJ = J;
	    }
	  }
	}
      }

      if(fragcnt && Mcnt > 0 && wt > 0.001f){
	double *Hcuts = pcontig->site[0];
	int Lij = (nmapKM[0] < 0) ? -1-nmapKM[0] : nmapKM[0];
	int Rij = abs(nmapKM[M+1]);
	if(DEBUG && !(Lij >= 0 && Lij <= Rij && Rij <= N+1)){
	  printf("m=%d/%d:mapid=%d,id=%lld:M=%d,N=%d,n=%d:Lij=%d(nmapK[m][0]=%d),Rij=%d(nmapK[m][M+1]=%d)\n",
		 m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,Lij,nmapK[m][0],Rij,nmapK[m][M+1]);
	  for(int J=0;J <= M+1; J++)
	    printf("  J=%d:nmap[m][j]=%d,nmapK[m][j]=%d\n",J,nmap[m][J],nmapK[m][J]);
	  fflush(stdout);
	  assert(Lij >= 0 && Lij <= Rij && Rij <= N+1);
	}

	int mIL[MAX_CHIM];
	int mKL[MAX_CHIM];
	int mIR[MAX_CHIM];
	int mKR[MAX_CHIM];

	double YR0 = -1.0, YL0 = -1.0;
	int jL, IL = -1, KL= -1, JL = -1, lcnt = 0, IL0 = -1, KL0= -1, JL0= -1;
	for(jL = 1; jL <= M; jL++){
	  if(nmapM[jL] < 0)
	    continue;
	  IL = nmapM[JL=jL];
	  int i = nmapMD[IL];
	  if(DEBUG && i >= 0) assert(!Hdel[i]);
	  KL = (!FRAGCNT_FIX2 || i >= 0) ? nmapKM[JL] : 0;
	  if(DEBUG>=2 && FRAGCNT_FIX2 && i >= 0){
	    int k = nmapMD[IL-KL];
	    assert(!Hdel[k]);
	  }
	  if(!lcnt){
	    IL0 = IL;
	    KL0 = KL;
	    JL0 = JL;
	    YL0 = Yc(Y,IL0,KL0);
	  }
	  if(++lcnt > COVERAGE_TRIM && (TRIM_FIX ? (Y[IL-KL] - YL0) : (Xm[JL] - Xm[JL0])) >= COVERAGE_TRIM_LEN)
	    break;
	}
	/* HERE HERE HERE : need to track where COVERAGE_TRIM'th label of Xm aligned on Y and N1 should be incremented starting at next label of Y (or COVERAGE_TRIM_LEN after YL0) regardless of whether
	   that label aligned to Y, provided there are labels further right that do align */

	if(DEBUG && jL <= M) assert(lcnt > COVERAGE_TRIM && (TRIM_FIX ? (Y[IL-KL] - YL0) : (Xm[JL] - Xm[JL0])) >= COVERAGE_TRIM_LEN);
	
	if(mCNT > 0){/* multiple versions of COVERAGE_TRIM_LEN */
	  if(DEBUG/* HERE >=2 */) assert(COVERAGE_TRIM_LEN == mCOVERAGE_TRIM_LEN[0]);
	  mIL[0] = IL;
	  mKL[0] = KL;
	  int origjL = jL;

	  for(int t = 1; t < mCNT; t++){
	    for(; jL <= M; jL++){
	      if(nmapM[jL] < 0)
		continue;
	      IL = nmapM[JL=jL];
	      KL = nmapKM[JL];
	      if((TRIM_FIX ? (Y[IL-KL] - YL0) : (Xm[JL] - Xm[JL0])) >= mCOVERAGE_TRIM_LEN[t])
		break;
	    }
	    mIL[t] = IL;
	    mKL[t] = KL;
	  }

	  /* restore original values based on COVERAGE_TRIM_LEN */
	  IL = mIL[0];
	  KL = mKL[0];
	  jL = origjL;
	}

	int jR, IR = -1, KR = 0, JR = -1, rcnt = 0, IR0 = -1, KR0 = 0, JR0 = -1;
	for(jR = M; jR >= 1; jR--){
	  if(nmapM[jR] < 0)
	    continue;
	  IR = nmapM[JR=jR];
	  int i = nmapMD[IR];
	  if(DEBUG>=2 && i >= 0) assert(!Hdel[i]);
	  KR = (!FRAGCNT_FIX2 || i >= 0) ? nmapKM[JR] : 0;
	  if(DEBUG>=2 && FRAGCNT_FIX2 && i >= 0){
	    int k = nmapMD[IR-KR];
	    assert(!Hdel[k]);
	  }
	  if(!rcnt){
	    IR0 = IR;
	    KR0 = KR;
	    JR0 = JR;
	    YR0 = ChimQualityFix ? Yc(Y,IR0,KR0) : Y[IR0];
	  }
	  if(++rcnt > COVERAGE_TRIM && (TRIM_FIX ? (YR0 - Y[IR]) : (Xm[JR0] - Xm[JR])) >= COVERAGE_TRIM_LEN)
	    break;
	}
	if(DEBUG && jR >= 1) assert(rcnt > COVERAGE_TRIM && (TRIM_FIX ? (YR0 - Y[IR]) : (Xm[JR0] - Xm[JR])) >= COVERAGE_TRIM_LEN);

	if(DEBUG && !(M >= JR0)){
	  printf("m=%d,M=%d,N=%d,n=%d: JR0=%d, IR0=%d, JR=%d, IR=%d, KR0=%d,KR=%d\n",
		 m,M,N,n,JR0,IR0,JR,IR,KR0,KR);
	  fflush(stdout);
	  assert(M >= JR0);
	}

	if(mCNT > 0){/* multi versions of COVERAGE_TRIM_LEN */
	  mIR[0] = IR;
	  mKR[0] = KR;
	  int origjR = jR;

	  for(int t = 1; t < mCNT; t++){
	    for(; jR >= 1; jR--){
	      if(nmapM[jR] < 0)
		continue;
	      IR = nmapM[JR=jR];
	      KR = nmapKM[JR];
	      if((TRIM_FIX ? (YR0 - Y[IR]) : (Xm[JR0] - Xm[JR])) >= mCOVERAGE_TRIM_LEN[t])
		break;
	    }
	    mIR[t] = IR;
	    mKR[t] = KR;
	  }
	  /* restore original IR,KR,jR */
	  IR = mIR[0];
	  KR = mKR[0];
	  jR = origjR;
	}

	if(VERB>=3 && m==154){
	  #pragma omp critical
	  {
	    printf("m=%d:rcnt=%d,IR0=%d,KR0=%d,JR0=%d,IR=%d,KR=%d,JR=%d,Y[IR0]=%0.3f,Y[IR0-KR0]=%0.3f,Y[IR]=%0.3f,Y[IR-KR]=%0.3f,COVERAGE_TRIM=%d,COVERAGE_TRIM_LEN=%0.3f(jL=%d,jR=%d)\n",
		   m,rcnt,IR0,KR0,JR0,IR,KR,JR,Y[IR0],Y[IR0-KR0],Y[IR],Y[IR-KR],COVERAGE_TRIM,COVERAGE_TRIM_LEN,jL,jR);
	    printf("\t JL0=%d,JL=%d\n",JL0,JL);
	    fflush(stdout);
	  }
	}

	/* compute number of left/right endoutlier unaligned sites (required to support TrimNormEnd > 0) */
	int LeftEnd = (PoutlierEnd > 0.0 && Lij >= IL0 - KL0) ? JL0 - 1 : 0;
	int RightEnd = (PoutlierEnd > 0.0 && Rij  <=  IR0) ? M -  JR0 : 0;
	int origLij = Lij, origRij = Rij;

	Lij = nmapMD[Lij];
	Rij = nmapMD[Rij];
	if(DEBUG && !(Lij >= 0 && Lij <= Rij && Rij <= n+1 && (Lij <= 0 || !Hdel[Lij]) && (Rij >= n+1 || !Hdel[Rij]))){
	  printf("m=%d/%d:mapid=%d,id=%lld:M=%d,N=%d,n=%d:Lij=%d(nmap[MD][nmapK[m][0]]=%d),Rij=%d(nmap[MD][nmapK[m][M+1]]=%d),Hdel[Lij]=%d,Hdel[Rij]=%d\n",
		 m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,Lij,nmap[MD][nmapK[m][0]],Rij,nmap[MD][nmapK[m][M+1]],Hdel[Lij],Hdel[Rij]);
	  fflush(stdout);
	  assert(Lij >= 0 && Lij <= Rij && Rij <= n+1);
	  if(0 < Lij) assert(!Hdel[Lij]);// NEW69
	  if(Rij <= n) assert(!Hdel[Rij]);// NEW69
	}

	int iL0 = nmapMD[IL0];
	int kL0 = nmapMD[IL0-KL0];
	int iR0 = nmapMD[IR0];
	int kR0 = nmapMD[IR0-KR0];
	if(DEBUG && !(IL >= 1 && IR <= N)){/* map has no aligned sites! */
	  printf("m=%d/%d:IL0=%d,IL=%d,IR=%d,IR0=%d,N=%d\n",m,MD,IL0,IL,IR,IR0,N);
	  fflush(stdout);
	  assert(IL >= 1 && IR <= N);
	}
	int iL = nmapMD[TRIM_FIX ? IL-KL : IL];
	int iR = nmapMD[TRIM_FIX ? IR : IR-KR];
	if(DEBUG) assert(0 < kL0 && kL0 <= iL0 && iL0 <= n);
	if(DEBUG) assert(0 < kR0 && kR0 <= iR0 && iR0 <= n);

	if(!FRAGCNT_FIX)
	  for(int k = Lij; FRAGCOV_FIX ? (k < Rij) : (k <= Rij); k++) 
	    fragcnt[k] += wt;
	else if(lcnt > 0 && rcnt > 0){/* only go from nmapMD[IL0-KL0] to nmapMD[IR0] (excluding unaligned ends)*/
	  if(DEBUG) assert(!Hdel[kL0] && !Hdel[iR0]);
	  for(int k = kL0; FRAGCOV_FIX ? (k < iR0) : (k <= iR0); k++)
	    fragcnt[k] += wt;
	}

	double yL = Yc(Hcuts,iL0,iL0-kL0);
	double yR = Yc(Hcuts,iR0,iR0-kR0);

	int startLij = Lij, startRij = Rij;

	double locL0 = min(Hcuts[kL0], max(0.0, yL - Xm[JL0]));
	double locR0 = max(Hcuts[iR0], min(Hcuts[n+1], yR + (Xm[M+1] - Xm[JR0])));

#if FRAGCOV_FIX <= 1
	for(int k = Lij = kL0; --k >= 0;){
          if(VERB>=2 && m==16){
            printf("k=%d,Lij=%d:locL0= %0.4f,Hcuts[k]=%0.4f\n",k,Lij,locL0,Hcuts[k]);
	    fflush(stdout);
          }
	  if(Hcuts[k] < locL0) // WAS if(yL - Hcuts[k] > Xm[JL0])
	    break;
	  Lij = k;
	}
	if(DEBUG && !(locL0 <= Hcuts[Lij])){
	  printf("m=%d,M=%d,N=%d,n=%d:iL0=%d,kL0=%d,Hcuts[kL0,iL0]=%0.4f,%0.4f,yL=%0.4f,locL0=%0.4f,JL0=%d,Xm[JL0]=%0.4f,Lij=%d->%d,Hcuts[Lij]=%0.4f\n",
		 m,M,N,n,iL0,kL0,Hcuts[kL0],Hcuts[iL0],yL,locL0,JL0,Xm[JL0],origLij,Lij,Hcuts[Lij]);
	  printf("\t IL0=%d,KL0=%d,origLij=%d,JL0=%d:Xm[JL0]= %0.4f, Y[origLij,IL0-KL0,IL0]= %0.4f,%0.4f,%0.4f\n",
		 IL0,KL0,origLij,JL0,Xm[JL0],Y[origLij],Y[IL0-KL0],Y[IL0]);
	  fflush(stdout);
	  assert(locL0 <= Hcuts[Lij]);
	}
	if(DEBUG) assert(Lij <= kL0);

	for(int k = Rij = iR0; ++k <= n+1; ){
	  if(Hcuts[k] > locR0) // WAS if(Hcuts[k] - yR > Xm[M+1] - Xm[JR0])
	    break;
	  Rij = k;
	}
	if(DEBUG && !(Hcuts[Rij] <= locR0)){
	  printf("m=%d,M=%d,N=%d,n=%d:kR0=%d,iR0=%d,Hcuts[kR0,iR0]=%0.4f,%0.4f,yR=%0.4f,locR0=%0.4f,JR0=%d,Xm[JR0]=%0.4f,Rij=%d->%d,Hcuts[Rij]=%0.4f\n",
		 m,M,N,n,kR0,iR0,Hcuts[kR0],Hcuts[iR0],yR,locR0,JR0,Xm[JR0],origRij,Rij,Hcuts[Rij]);
	  fflush(stdout);
	  assert(Hcuts[Rij] <= locR0);
	}
	if(DEBUG) assert(kR0 <= Rij);

	// NOTE : unlike startLij,startRij, the final Lij, Rij may not be a real site : Hdel[Lij] or Hdel[Rij] may be 1 
#endif
	for(int k = (FRAGCOV_FIX ? startLij : Lij); FRAGCOV_FIX ? (k < startRij) : (k <= Rij); k++) 
	  fragcntT[k] += wt;
	if(CovNorm){
	  float Xlen = Xm[M+1];
	  for(int k = (FRAGCOV_FIX ? startLij : Lij); FRAGCOV_FIX ? (k < startRij) : (k <= Rij); k++){ 
	    fragcntTnorm[k] += wt*Xlen;
	    if(DEBUG>=2) assert(isfinite(fragcntTnorm[k]));
	  }
	}
	if(VERB && updateVerb && Lij <= KTRACE && KTRACE <= Rij){
	  printf("\t id=%lld:M=%d,N=%d,n=%d:wt=%0.3f,fragcnt[%d..%d]+=wt (%0.3f..%0.3f,IL0=%d,KL0=%d,JL0=%d,IR0=%d,KR0=%d,JR0=%d),lcnt=%d,rcnt=%d,IL=%d,KL=%d,JL=%d,IR=%d,KR=%d,JR=%d,COVERAGE_TRIM=%d\n",
		 gmap[pcontig->contig[m].mapid]->id,M,N,n,wt,FRAGCNT_FIX ? kL0 : Lij, (FRAGCNT_FIX ? iR0 : Rij) - (FRAGCOV_FIX ? 1 : 0),
		 Hcuts[FRAGCNT_FIX ? kL0 : Lij],Hcuts[(FRAGCNT_FIX ? iR0 : Rij) - (FRAGCOV_FIX ? 1 : 0)],IL0,KL0,JL0,IR0,KR0,JR0,lcnt,rcnt,IL,KL,JL,IR,KR,JR,COVERAGE_TRIM);
	  printf("\t    fragcntT[%d..%d]+=wt(%0.3f..%0.3f), sitecntFN[%d..%d]+=wt (fragcnt[%d]=%0.2f,fragcntT[%d]=%0.2f,sitecnt[%d]=%0.2f,sitecntFN[%d]=%0.2f),End=%d,%d,Lij=%d,Rij=%d, jL=%d,jR=%d,Hcuts[iL-kL=%d,iR=%d]=%0.3f,%0.3f\n",
		 (FRAGCOV_FIX ? startLij : Lij),(FRAGCOV_FIX ? startRij-1 : Rij), Hcuts[(FRAGCOV_FIX ? startLij : Lij)],Hcuts[(FRAGCOV_FIX ? startRij-1 : Rij)], 
	         nmapMD[IL], nmapMD[IR-KR], KTRACE,fragcnt[KTRACE],KTRACE,fragcntT[KTRACE],KTRACE,sitecnt[KTRACE],KTRACE,sitecntFN[KTRACE],LeftEnd,RightEnd,origLij,origRij,jL,jR,iL,iR,Hcuts[iL],Hcuts[iR]);
	  fflush(stdout);
	}

	if(jL > M || jR <= 0)
	  continue;// molecule does not have sufficient alignment (COVERAGE_TRIM,COVERAGE_TRIM_LEN) anywhere, so no effect on N1,N2,N3,N4,N5

	int LijN = Lij, RijN = Rij;
	int LijN2 = Lij, RijN2 = Rij;
	if(TrimNorm >= 0){
	  // based on sites in molecule m projected on to Hcuts[] locations based on overlap
	  double locL,locR;
	  if(ChimQualityFix){
	    if(DEBUG>=2){
	      locL = min(Hcuts[kL0], max(0.0, yL - Xm[JL0]));
	      locR = max(Hcuts[iR0], min(Hcuts[n+1], yR + (Xm[M+1] - Xm[JR0])));
	      if(DEBUG) assert(fabs(locL - locL0) < 1e-10);
	      if(DEBUG) assert(fabs(locR - locR0) < 1e-10);

	      /* compute largest site range (LijN..RijN) that lies within locL .. locR */
	      LijN = kL0;
	      while(LijN >= 1 && Hcuts[LijN-1] >= locL)
		LijN--;

	      if(DEBUG && !(LijN == Lij)){
		printf("m=%d,M=%d,N=%d,n=%d: JL0= %d, Xm[JL0]= %0.4f, kL0= %d, iL0= %d, Hcuts[kL0,iL0]= %0.4f,%0.4f, yL= %0.4f, locL= %0.4f, Lij= %d, LijN= %d, Hcuts[Lij]= %0.4f, Hcuts[LijN]= %0.4f\n",
		       m,M,N,n,JL0,Xm[JL0],kL0,iL0,Hcuts[kL0],Hcuts[iL0], yL, locL, Lij, LijN, Hcuts[Lij], Hcuts[LijN]);
		assert(LijN == Lij);
	      }

	      RijN = iR0;
	      while(RijN <= n && Hcuts[RijN+1] <= locR)
		RijN++;
	      if(DEBUG && !(RijN == Rij)){
		printf("m=%d,M=%d,N=%d,n=%d:JR0= %d, Xm[JR0]= %0.4f, Xm[M+1]= %0.4f, kR0= %d, iR0= %d, Hcuts[kR0,iR0]= %0.4f,%0.4f, yR= %0.4f, locR= %0.4f, Rij= %d, RijN= %d, Hcuts[Rij]= %0.4f, Hcuts[RijN]= %0.4f\n",
		       m,M,N,n,JR0,Xm[JR0],Xm[M+1],kR0,iR0,Hcuts[kR0],Hcuts[iR0],yR,locR, Rij,RijN,Hcuts[Rij],Hcuts[RijN]);
		fflush(stdout);
		assert(RijN == Rij);
	      }
	    } else {
	      locL = locL0;
	      locR = locR0;
	      LijN = Lij;
	      RijN = Rij;
	    }
	  } else {// ! ChimQualityFix
	    locL = Hcuts[kL0] - (Xm[JL0]-Xm[1]);
	    locR = Hcuts[iR0] + (Xm[M]-Xm[JR0]);
	    if(DEBUG) assert(1 <= JL0 && locL <= Hcuts[kL0]);
	    if(DEBUG && !(M >= JR0 && locR >= Hcuts[iR0])){
	      printf("m=%d,M=%d,N=%d,n=%d: JR0=%d, iR0=%d, locR= %0.8f, Hcuts[iR0]= %0.8f, Xm[M]= %0.8f, Xm[JR0]= %0.8f\n",
		     m,M,N,n,JR0,iR0,locR,Hcuts[iR0], Xm[M], Xm[JR0]);
	      fflush(stdout);
	      assert(M >= JR0 && locR >= Hcuts[iR0]);
	    }

	    /* compute largest site range (LijN..RijN) that lies within locL .. locR */
	    LijN = kL0;// WAS iL0 - kL0
	    while(LijN > 1 && Hcuts[LijN - 1] >= locL)
	      LijN--;

	    RijN = iR0;
	    while(RijN < n && Hcuts[RijN+1] <= locR)
	      RijN++;
	  }

	  if(DEBUG && !(JL >= JL0)){
            #pragma omp critical
	    {
	      printf("m=%d/%d:M=%d,N=%d,n=%d:JL0=%d,JL=%d,JR=%d,JR0=%d\n",m,MD,M,N,n,JL0,JL,JR,JR0);
	      fflush(stdout);
	      assert(JL >= JL0);
	    }
	  }
	  if(DEBUG) assert(JR <= JR0);

	  double locL2 = locL, locR2 = locR;
	  if(ChimQualityFix){ // locL2 >= locL + COVERAGE_TRIM_LEN && crossing COVERAGE_TRIM real sites in Hcuts (weighted by likelihood of resolving relative to previous real site)
	    int i;
	    if(DEBUG && !(Hcuts[LijN] >= locL - 1e-10)){
	      printf("m=%d:JL0= %d, Xm[JL0]= %0.4f, iL0=%d, kL0= %d, yL= %0.10f, locL= %0.10f, LijN= %d, Hcuts[LijN]= %0.10f, Lij= %d, Hcuts[Lij]= %0.10f\n",
		     m, JL0, Xm[JL0], iL0, kL0, yL, locL, LijN, Hcuts[LijN], Lij, Hcuts[Lij]);
	      fflush(stdout);
	      assert(Hcuts[LijN] >= locL - 1e-10);
	    }
	    locL2 = locL + COVERAGE_TRIM_LEN;

	    i = max(1,LijN);
	    double lastH = Hcuts[i] - 100.0;// first label overlapped should always be counted
	    for(double cnt= 0.1; i <= n; i++)
	      if(!Hdel[i]){
		double delY = Hcuts[i] - lastH;
		if(DEBUG>=2) assert(delY > 0.0);
		if((cnt += Pr(delY, resKB, IresSD)) >= COVERAGE_TRIM)
		  break;
		lastH = Hcuts[i];
	      }
	    locL2 = max(locL2, Hcuts[i]);

	    if(DEBUG && !(locL2 <= Hcuts[iL] + 0.001)){// NOTE : this can fail since sites on Hcuts[] that typically fail to resolve, may have resolved
              #pragma omp critical
	      {
	        printf("m=%d/%d:M=%d,N=%d,n=%d:Lij=%d,JL0=%d,IL0=%d,KL0=%d,iL0=%d,Xm[JL0]=%0.3f,Xm[1]=%0.3f,Hcuts[kL0]=%0.3f,locL=%0.3f,locL2=%0.3f,iL=%d,Hcuts[iL]=%0.3f\n",
		  m,MD,M,N,n,Lij,JL0,IL0,KL,iL0,Xm[JL0],Xm[1],Hcuts[kL0],locL,locL2,iL,Hcuts[iL]);
		printf("\t JL=%d,IL=%d,KL=%d:Xm[JL]=%0.3f,Y[IL-KL]=%0.3f,Y[IL0-KL0]=%0.3f,lcnt=%d\n",JL,IL,KL,Xm[JL],Y[IL-KL],Y[IL0-KL0],lcnt);
		printf("\t JR=%d,IR=%d,KR=%d,JR0=%d,IR0=%d,KR0=%d:Xm[JR]=%0.3f,Xm[JR0]=%0.3f,Xm[M]=%0.3f,Y[IR0]=%0.3f,Y[IR]=%0.3f,rnct=%d\n",JR,IR,KR,JR0,IR0,KR0,Xm[JR],Xm[JR0],Xm[M],Y[IR0],Y[IR],rcnt);
		printf("\t COVERAGE_TRIM=%d,COVERAGE_TRIM_LEN=%0.3f\n",COVERAGE_TRIM,COVERAGE_TRIM_LEN);
		fflush(stdout);
		//		assert(locL2 <= Hcuts[iL] + 0.001);
	      }
	    }
	    locL2 = min(locL2, Hcuts[iL]);

	    if(DEBUG && !(Hcuts[RijN] <= locR + 1e-10)){
	      printf("m=%d:JR0= %d, Xm[JR0]= %0.4f, iR0=%d, kR0= %d, yR= %0.10f, locR= %0.10f, RijN= %d, Hcuts[RijN]= %0.10f, Rij= %d, Hcuts[Rij]= %0.10f\n",
		     m, JR0, Xm[JR0], iR0, kR0, yR, locR, RijN, Hcuts[RijN], Rij, Hcuts[Rij]);
	      fflush(stdout);
	      assert(Hcuts[RijN] <= locR + 1e-10);
	    }
	    locR2 = locR - COVERAGE_TRIM_LEN;

	    i = min(RijN,n);
	    lastH = Hcuts[i]+100.0;// first label overlapped should always be counted
	    for(double cnt = 0.1; i > 0; i--)
              if(!Hdel[i]){
		double delY = lastH - Hcuts[i];
		if(DEBUG>=2 && !(delY > 0.0)){
		  #pragma omp critical
		  {
		    printf("m=%d,M=%d,N=%d,n=%d: RijN=%d,i=%d,Hcuts[i]=%0.4f,lastH=%0.4f,delY= %0.4e\n",  m,M,N,n,RijN,i,Hcuts[i],lastH,delY);
		    printf("    (locR= %0.4f, JR0=%d,Xm[JR0]=%0.4f,kR0=%d,iR0=%d,Hcuts[kR0,iR0]=%0.4f,%0.4f,Hcuts[n+1]=%0.4f,Xm[M+1]=%0.4f)\n",
			   locR, JR0, Xm[JR0],kR0,iR0,Hcuts[kR0],Hcuts[iR0], Hcuts[n+1], Xm[M+1]);
		    double nlastH = Hcuts[min(RijN,n)] + 100.0;
		    for(int t = RijN; t > 0 && t >= i; t--){
		      if(!Hdel[t]){
			printf("\t t=%d:Hcuts[t]=%0.4f, nlastH=%0.4f (del=%0.4f)\n",t, Hcuts[t],nlastH, nlastH-Hcuts[t]);
			nlastH = Hcuts[t];
		      }
		    }
		    fflush(stdout);
		    assert(delY > 0.0);
		  }
		}
		if((cnt += Pr(delY, resKB, IresSD)) >= COVERAGE_TRIM)
		  break;
		lastH = Hcuts[i];
	      }
	    locR2 = min(locR2, Hcuts[i]);

	    if(DEBUG>=2 && !(locR2 >= Hcuts[iR] - 0.001)){// NOTE : this can fail since sites on Hcuts[] that typically fail to resolve, may have resolved
              #pragma omp critical
	      {
	        printf("WARNING:m=%d/%d:M=%d,N=%d,n=%d:Rij=%d,RijN=%d,JR0=%d,IR0=%d,KR0=%d,iR0=%d,kR0=%d,Xm[JR0]=%0.4f,Xm[M+1]=%0.4f,Hcuts[iR0]=%0.4f,locR0=%0.4f,locR=%0.4f,locR2=%0.4f,iR=%d,Hcuts[iR]=%0.4f\n",
		       m,MD,M,N,n,Rij,RijN,JR0,IR0,KR,iR0,kR0,Xm[JR0],Xm[M+1],Hcuts[iR0],locR0,locR,locR2,iR,Hcuts[iR]);
		printf("\t IR0=%d,KR0=%d,Y[IR0]=%0.4f,Y[IR0-KR0]=%0.4f,IR=%d,KR=%d,JR=%d,Y[IR]=%0.4f,Y[IR-KR]=%0.4f,Xm[JR]=%0.4f\n",
		       IR0,KR0,Y[IR0],Y[IR0-KR0],IR,KR,JR,Y[IR],Y[IR-KR],Xm[JR]);
		printf("\t i=%d,Hcuts[i]=%0.4f,COVERAGE_TRIM=%d,COVERAGE_TRIM_LEN=%0.4f\n",i,Hcuts[i],COVERAGE_TRIM,COVERAGE_TRIM_LEN);
		double nlastH = Hcuts[min(RijN,n)] + 100.0;
		double cnt = 0.1;
		for(int t = RijN; t >= i; t--){
		  if(Hdel[t])
		    continue;
		  double delY = nlastH - Hcuts[t];
		  cnt += Pr(delY, resKB,IresSD);
		  printf("\t t=%d:Hcuts[t]=%0.4f,nlastH=%0.4f,delY=%0.4f,Pr(delY)=%0.6f, cnt= %0.6f\n",t,Hcuts[t],nlastH,delY,Pr(delY,resKB,IresSD),cnt);
		  if(cnt >= COVERAGE_TRIM)
		    break;
		  nlastH = Hcuts[t];
		}
		for(int t = JR0; t >= JR; t--){
		  int I = nmapM[t];
		  if(I < 0)
		    continue;
		  int K = nmapKM[t];
		  int i = nmapMD[I];
		  int k = nmapMD[I-K];
		  printf("\t J=%d:I=%d,I-K=%d,Y[I]=%0.4f,Y[I-K]=%0.4f,i=%d,k=%d,Hcuts[i]=%0.4f,Hcuts[k]=%0.4f\n",
			 t,I,I-K,Y[I],Y[I-K],i,k,Hcuts[i],Hcuts[k]);
		}

		fflush(stdout);
		//		assert(locR2 >= Hcuts[iR] - 0.001);
	      }
	    }

	    locR2 = max(locR2, Hcuts[iR]);

	    /* locate largest site range (LijN2 .. RijN2) that lies within locL2 .. locR2 */
	    LijN2 = LijN;
	    while(LijN2 < n && Hcuts[LijN2] <= locL2)
	      LijN2++;
	    RijN2 = RijN;
	    while(RijN2 > 1 && Hcuts[RijN2] >= locR2)
	      RijN2--;
	    if(DEBUG>=2 && !(LijN2 <= iL && iR <= RijN2)){// NOTE : this could fail due to rounding : just force LijN2 <= iL && iR <= RijN2
	      printf("WARNING: m=%d,M=%d,N=%d,n=%d:Hcuts[n+1]=%0.4f,Xm[M+1]=%0.4f:JL0=%d,JL=%d,JR=%d,JR0=%d,Xm[JL0,JL,JR,JR0]=%0.4f,%0.4f,%0.4f,%0.4f\n",
		     m,M,N,n,Hcuts[n+1],Xm[M+1],JL0,JL,JR,JR0,Xm[JL0],Xm[JL],Xm[JR],Xm[JR0]);
	      printf("\t locL=%0.4f,locL2=%0.4f, iL=%d,Hcuts[iL]=%0.4f, LijN=%d,LijN2=%d, Hcuts[LijN,LijN2]=%0.4f,%0.4f\n",
		locL, locL2, iL, Hcuts[iL], LijN, LijN2, Hcuts[LijN], Hcuts[LijN2]);
	      printf("\t  locR2=%0.4f,locR=%0.4f, iR=%d,Hcuts[iR]=%0.4f, RijN2=%d,RijN=%d, Hcuts[RijN2,RijN]=%0.4f,%0.4f, kR0=%d,iR0=%d,Hcuts[kR0,iR0]=%0.4f,%0.4f\n",
		     locR2, locR, iR, Hcuts[iR], RijN2, RijN, Hcuts[RijN2], Hcuts[RijN], kR0, iR0, Hcuts[kR0], Hcuts[iR0]);
	      fflush(stdout);
	      // if(DEBUG>=1+RELEASE) assert(LijN2 <= iL && iR <= RijN2);
	    }
	    LijN2 = min(iL,LijN2);
	    RijN2 = max(iR,RijN2);
	  } else {
	    for(int L = min(M,1+COVERAGE_TRIM); L <= JL; L++){
	      locL2 = (L <= JL0) ? (Hcuts[kL0] - (Xm[JL0]-Xm[L])) : (Hcuts[iL] - (Hcuts[iL]-Hcuts[kL0]) * (Xm[JL]-Xm[L])/(Xm[JL]-Xm[JL0]));
	      if(locL2 - locL >= COVERAGE_TRIM_LEN)
		break;
	    }
	    for(int R = max(1,M-COVERAGE_TRIM); R >= JR; R--){
	      locR2 = (R >= JR0) ? (Hcuts[iR0] + (Xm[M]-Xm[R])) : (Hcuts[iR] + (Hcuts[iR0]-Hcuts[iR])*(Xm[R]-Xm[JR])/(Xm[JR0]-Xm[JR]));
	      if(locR - locR2 >= COVERAGE_TRIM_LEN)
		break;
	    }

	    /* locate smallest site range (LijN2 .. RijN2) that lies outside locL2 .. locR2 */
	    LijN2 = LijN;
	    while(LijN2 < n && Hcuts[LijN2+1] < locL2)
	      LijN2++;
	    RijN2 = RijN;
	    while(RijN2 > 1 && Hcuts[RijN2-1] > locR2)
	      RijN2--;

	    if(DEBUG && !(locL2 <= Hcuts[iL] + 0.001)){
              #pragma omp critical
	      {
	        printf("m=%d/%d:M=%d,N=%d,n=%d:Lij=%d,JL0=%d,IL0=%d,KL0=%d,iL0=%d,Xm[JL0]=%0.4f,Xm[1]=%0.4f,Hcuts[kL0]=%0.4f,locL=%0.4f,locL2=%0.4f,iL=%d,Hcuts[iL]=%0.4f\n",
		  m,MD,M,N,n,Lij,JL0,IL0,KL,iL0,Xm[JL0],Xm[1],Hcuts[kL0],locL,locL2,iL,Hcuts[iL]);
		printf("\t JL=%d,IL=%d,KL=%d:Xm[JL]=%0.4f,Y[IL-KL]=%0.4f,Y[IL0-KL0]=%0.4f,lcnt=%d\n",JL,IL,KL,Xm[JL],Y[IL-KL],Y[IL0-KL0],lcnt);
		printf("\t JR=%d,IR=%d,KR=%d,JR0=%d,IR0=%d,KR0=%d:Xm[JR]=%0.4f,Xm[JR0]=%0.4f,Xm[M]=%0.4f,Y[IR0]=%0.4f,Y[IR]=%0.4f,rnct=%d\n",JR,IR,KR,JR0,IR0,KR0,Xm[JR],Xm[JR0],Xm[M],Y[IR0],Y[IR],rcnt);
		printf("\t COVERAGE_TRIM=%d,COVERAGE_TRIM_LEN=%0.4f\n",COVERAGE_TRIM,COVERAGE_TRIM_LEN);
		fflush(stdout);
		assert(locL2 <= Hcuts[iL] + 0.001);
	      }
	    }
	    if(DEBUG) assert(locR2 >= Hcuts[iR] - 0.001);
	  }

	  if(TrimNormChim >= 0){  /* further narrow the range LijN2..RijN2 to not extend beyond Hcuts[kL0 .. iR0] by more than TrimNormChim real sites (to suppress counting chimeric molecules)  */
	    int LijN3 = kL0;
	    int RijN3 = iR0;
	    double locL3,locR3;
	    if(ChimQualityFix){
	      if(DEBUG) assert(!Hdel[LijN3]);
	      double lastH = Hcuts[LijN3];
	      for(double cnt = 1.1; --LijN3 > 1;)
		if(!Hdel[LijN3 - 1]){
		  double delY = lastH - Hcuts[LijN3-1];
		  if((cnt += Pr(delY, resKB, IresSD)) > TrimNormChim)
		    break;
		  lastH = Hcuts[LijN3-1];
		}

	      if(DEBUG) assert(LijN3 <= iL0);

	      lastH = Hcuts[RijN3];
	      for(double cnt = 1.1; ++RijN3 < n; )
		if(!Hdel[RijN3 + 1]){
		  double delY = Hcuts[RijN3+1] - lastH;
		  if((cnt += Pr(delY, resKB, IresSD)) > TrimNormChim)
		    break;
		  lastH = Hcuts[RijN3+1];
		}

	      if(DEBUG) assert(iR0 <= RijN3);

	      if(VERB && updateVerb && (max(LijN2,LijN3) <= KTRACE && KTRACE <= min(RijN2,RijN3))){
		printf("m=%d/%d,M=%d,n=%d:JL0=%d,iL0=%d,kL0=%d,Hcuts[kL0]=%0.3f,Xm[JL0]=%0.3f,Xm[1]=%0.3f,JR0=%d,iR0=%d,Hcuts[iR0]=%0.3f,Xm[JR0]=%0.3f,Xm[M]=%0.3f:\n",
		       m,MD,M,n,JL0,iL0,kL0,Hcuts[kL0],Xm[JL0],Xm[1],JR0,iR0,Hcuts[iR0],Xm[JR0],Xm[M]);
		printf("\t LijN=%d,RijN=%d,LijN2=%d,RijN2=%d,LijN3=%d,RijN3=%d:locL=%0.3f,locL2=%0.3f,locR2=%0.3f,locR=%0.3f,Hcuts[LijN3,RijN3]=%0.3f,%0.3f\n",
		       LijN,RijN,LijN2,RijN2,LijN3,RijN3,locL,locL2,locR2,locR,Hcuts[LijN3],Hcuts[RijN3]);
		fflush(stdout);
	      }

	    } else {
	      locL3 = Hcuts[kL0] - (Xm[JL0] - Xm[max(1, JL0 - TrimNormChim)]);
	      locR3 = Hcuts[iR0] + (Xm[min(M, JR0 + TrimNormChim)] - Xm[JR0]);
	      if(TrimNormChim > 0){
		while(LijN3 > 1 && Hcuts[LijN3-1] >= locL3)
		  LijN3--;
		while(RijN3 < n && Hcuts[RijN3+1] <= locR3)
		  RijN3++;
	      }

	      if(VERB && updateVerb && (max(LijN2,LijN3) <= KTRACE && KTRACE <= min(RijN2,RijN3))){
		printf("m=%d/%d,M=%d,n=%d:JL0=%d,iL0=%d,kL0=%d,Hcuts[kL0]=%0.3f,Xm[JL0]=%0.3f,Xm[1]=%0.3f,JR0=%d,iR0=%d,Hcuts[iR0]=%0.3f,Xm[JR0]=%0.3f,Xm[M]=%0.3f:\n",
		       m,MD,M,n,JL0,iL0,kL0,Hcuts[kL0],Xm[JL0],Xm[1],JR0,iR0,Hcuts[iR0],Xm[JR0],Xm[M]);
		printf("\t LijN=%d,RijN=%d,LijN2=%d,RijN2=%d,LijN3=%d,RijN3=%d:locL=%0.3f,locL2=%0.3f,locR2=%0.3f,locR=%0.3f(locL3=%0.3f,locR3=%0.3f)\n",
		       LijN,RijN,LijN2,RijN2,LijN3,RijN3,locL,locL2,locR2,locR,locL3,locR3);
		fflush(stdout);
	      }
	    }

	    /* intersect ranges LijN2..RijN2 with LijN3..RijN3 */
	    LijN2 = max(LijN2,LijN3);
	    RijN2 = min(RijN2,RijN3);
	  }
	  if(DEBUG) assert(0 <= LijN2 && RijN2 <= n+1);
	  if(DEBUG && !(LijN2 <= iL && iR <= RijN2)){
	    printf("m=%d/%d:mapid=%d,id=%lld:M=%d,N=%d,n=%d:wt=%0.3f,sitecntFNnorm[%d..%d]+=wt(%0.3f..%0.3f) (LijN=%d,RijN=%d,COVERAGE_TRIM_LEN=%0.1f)\n\tfragcnt[%d..%d]+=wt(%0.3f..%0.3f),fragcntT[%d..%d]+=wt(%0.3f..%0.3f), sitecntFN[%d..%d]+=wt\n",
		   m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,wt,LijN2,RijN2,Hcuts[LijN2],Hcuts[RijN2],LijN,RijN,COVERAGE_TRIM_LEN,
		   kL0,iR0,Hcuts[kL0],Hcuts[iR0],Lij,Rij,Hcuts[Lij],Hcuts[Rij], iL, iR);
	    printf("\t Hcuts[iL=%d]=%0.3f,Hcuts[iR=%d]=%0.3f,Hcuts[kL0=%d]=%0.3f,Hcuts[iR0=%d]=%0.8f,locL=%0.3f,locR=%0.3f,locL2=%0.3f,locR2=%0.3f,Hcuts[LijN2=%d]=%0.3f,Hcuts[RijN2=%d]=%0.3f\n",
		   iL,Hcuts[iL],iR,Hcuts[iR],kL0,Hcuts[kL0],iR0,Hcuts[iR0],locL,locR,locL2,locR2,LijN2,Hcuts[LijN2],RijN2,Hcuts[RijN2]);
	    fflush(stdout);
	    assert(LijN2 <= iL && iR <= RijN2);/* sitecntFNnorm update range (LijN2..RijN2) should be superset of sitecntFN update range (iL..iR) */
	  }

	  if(DEBUG>=2) assert(TrimNormFP <= COVERAGE_TRIM);
	  int LijN3 = iL - 1;// sitecntFNnorm[] will NOT be incremented between LijN3 and iL
	  int RijN3 = iR + 1;// sitecntFNnorm[] will NOT be incremented between iR and RijN3

	  if(TrimNormFP >= 0){/* widen range LijN3 .. RijN3 so that no more than TrimNormFP real aligned sites are included in Hcuts[iL0 .. LijN3] OR Hcuts[RijN3 .. kR0] */
	    int lcnt = 0,j;
	    for(j = JL0; j < JL; j++){
	      if(nmapM[j] < 0)
		continue;
	      if(++lcnt > TrimNormFP){
		int IL = nmapM[j];
		LijN3 = nmapMD[IL] - 1;
		break;
	      }
	    }
	    if(DEBUG) assert(lcnt >= TrimNormFP);
	    if(DEBUG) assert(LijN3 < iL);

	    lcnt = 0;
	    for(j = JR0; j > JR; j--){
	      if(nmapM[j] < 0)
		continue;
	      if(++lcnt > TrimNormFP){
		int IR = nmapM[j];
		RijN3 = nmapMD[IR] + 1;
		break;
	      }
	    }
	    if(DEBUG) assert(lcnt >= TrimNormFP);
	    if(DEBUG) assert(RijN3 > iR);
	  }

	  if(ChimQualityFix){
	    /* determine where fragile site ends can fall on Hcuts[] :
	       1. To satisfy COVERAGE_TRIM and COVERAGE_TRIM_LEN : Between 0 (WAS kL0)  .. iR for left end AND between iL .. n+1 (WAS iR0) for right end.
	       2. To satisfy FragileQualityFN and FragileQualityFP : Between LijF2..LijF3 for left end AND between RijF3..RijF2 for right end.
	       3. To satisfy FragileQualityEnd : within FragileQualityEnd kb of locL for left end AND within FragileQualityEnd kb of locR for right end (or the nearest real label, if greater)
	    */

	    int LijF2 = kL0;
	    int RijF2 = iR0;
	    /* widen interval LijF2 .. RijF2 as much as possible without extending beyond Hcuts[kL0 .. iR0] by more than FragileQualityFN real sites (not counting unresolvable sites) on each end */
	    double lastH = Hcuts[LijF2];
	    for(double cnt = 1.1; --LijF2 > 1;)
	      if(!Hdel[LijF2 - 1]){
		double delY = lastH - Hcuts[LijF2-1];
		if((cnt += Pr(delY, resKB, IresSD)) > FragileQualityFN)
		  break;
		lastH = Hcuts[LijF2-1];
	      }

	    lastH = Hcuts[RijF2];
	    for(double cnt = 1.1; ++RijF2 < n; )
	      if(!Hdel[RijF2 + 1]){
		double delY = Hcuts[RijF2+1] - lastH;
		if((cnt += Pr(delY, resKB, IresSD)) > FragileQualityFN)
		  break;
		lastH = Hcuts[RijF2+1];
	      }

	    int LijF3 = iL - 1;
	    int RijF3 = iR + 1;

	    /* widen range LijF3 .. RijF3 so there are no more than FragileQualityFP real aligned sites are included in Hcuts[iL0 .. LijF3] OR Hcuts[RijF3 .. kR0] */
	    int lcnt = 0,j;
	    for(j = JL0; j < JL; j++){
	      if(nmapM[j] < 0)
		continue;
	      if(++lcnt > FragileQualityFP){
		int IL = nmapM[j];
		LijF3 = nmapMD[IL] - 1;
		break;
	      }
	    }
	    if(DEBUG) assert(lcnt >= FragileQualityFP);
	    if(DEBUG) assert(LijF3 < iL);

	    lcnt = 0;
	    for(j = JR0; j > JR; j--){
	      if(nmapM[j] < 0)
		continue;
	      if(++lcnt > FragileQualityFP){
		int IR = nmapM[j];
		RijF3 = nmapMD[IR] + 1;
		break;
	      }
	    }
	    if(DEBUG) assert(lcnt >= FragileQualityFP);
	    if(DEBUG) assert(RijF3 > iR);

	    if(VERB && updateVerb && Lij <= KTRACE && KTRACE <= Rij){
	      printf("\t id=%lld:wt=%0.3f,N1[iL=%d,iR=%d] += wt, N2[LijN2=%d,LijN3=%d] += wt, N3[RijN3=%d,RijN2=%d] += wt, LijF2=%d,LijF3=%d,RijF3=%d,RijF2=%d,locL=%0.3f,locR=%0.3f\n",
		     gmap[pcontig->contig[m].mapid]->id, wt, iL,iR,LijN2,LijN3,RijN3,RijN2,LijF2,LijF3,RijF3,RijF2,locL,locR);
	      fflush(stdout);
	    }

	    double locL2 = locL, locL3 = locL, locR2 = locR, locR3 = locR;
	    /* locate nearest site locL2 left of locL  */
	    for(int i = kL0; i > 0; i--){
              if(Hcuts[i] < locL){
                locL2 = Hcuts[i];
		/* locate nearest real site locL3 right of locL */
	        for(int j = i+1; j <= kL0; j++){
                  if(Hcuts[j] > locL){
                    locL3 = Hcuts[j];
		    break;
                  }
                }
		break;
              }
            }

	    /* locate nearest site locR3 right of locR */
	    for(int i = iR0; i <= n; i++){
              if(Hcuts[i] > locR){
                locR3 = Hcuts[i];
		/* locate nearest real site locR2 left of locR */
		for(int j = i-1;j >= iR0; j--){
                  if(Hcuts[j] < locR){
                    locR2 = Hcuts[j];
		    break;
                  }
                }
		break;
              }
            }
	    locL2 = min(locL2, locL - FragileQualityEnd);
	    locL3 = max(locL3, locL + FragileQualityEnd);
	    locR2 = min(locR2, locR - FragileQualityEnd);
	    locR3 = max(locR3, locR + FragileQualityEnd);

	    /* increment N1 from iL to iR
	       increment N2 from LijN2 to LijN3 
	       increment N3 from RijN3 to RijN2
	       increment N4 from max(LijF2,0) to min(LijF3,iR), but only within FragileQualityEnd kb of locL (between locL2 and locL3)
	       increment N5 from max(RijF3,iL) to min(RijF2,n+1), but only within FragileQualityEnd kb of locR (between locR2 and locR3)
	       increment N6[k] if outlier bridges Hcuts[k..k+1] 
	     
	       sitecntFNnorm[k] = N1[k] + N2[k] + N3[k]

	       where:
	         N1[k] == sitecntFN[k]
	         N2[k] == sitecntN2k]
	         N3[k] == sitecntN3[k]
	         N4[k] == sitecntN4[k]
	         N5[k] == sitecntN5[k]
		 N6[k] == sitecntN6[k]

	       NOTE : sitecntFN[k] and sitecntFNnorm[k] are computed later
	    */

	    //	    if(!(TrimNormEnd > 0 && max(LeftEnd,RightEnd) >= TrimNormEnd)){
	    if(VERB>=2 && LijF2 <= KTRACE && KTRACE <= RijF2){
	      printf("m=%d(id=%lld):wt=%0.3f:LijN2=%d,LijN3=%d(%0.1f..%0.1f),iL=%d,iR=%d(%0.1f..%0.1f),RijN3=%d,RijN2=%d(%0.1f..%0.1f)\n\t LijF2=%d,LijF3=%d(%0.1f..%0.1f),RijF3=%d,RijF2=%d(%0.1f..%0.1f),locL=%0.3f(%0.1f..%0.1f),locR=%0.3f(%0.1f..%0.1f)\n",
		     m, gmap[pcontig->contig[m].mapid]->id, wt, LijN2,LijN3,Hcuts[LijN2],Hcuts[LijN3],iL,iR,Hcuts[iL],Hcuts[iR],RijN3,RijN2,Hcuts[RijN3],Hcuts[RijN2],LijF2,LijF3,Hcuts[max(LijF2,0)],Hcuts[min(LijF3,iR)],RijF3,RijF2,Hcuts[max(RijF3,iL)],Hcuts[min(RijF2,n+1)],locL,locL2,locL3,locR,locR2,locR3);
	      printf("\t kL0=%d,iR0=%d,Lij=%d(%0.3f),Rij=%d(%0.3f),startLij=%d(%0.3f),startRij=%d(%0.3f),LIJ=%d(%0.3f),RIJ=%d(%0.3f),yL=%0.3f,Xm[JL0=%d]=%0.3f,yR=%0.3f,Xm[JR0=%d]=%0.3f,Xm[M+1=%d]=%0.3f\n",
		     kL0,iR0,Lij,Hcuts[Lij],Rij,Hcuts[Rij],startLij,Hcuts[startLij],startRij,Hcuts[startRij],origLij,Y[origLij],origRij,Y[origRij],yL,JL0,Xm[JL0],yR,JR0,Xm[JR0],M+1,Xm[M+1]);
	      fflush(stdout);
	    }
	    for(int k = LijN2; k <= LijN3; k++){
	      sitecntN2[k] += wt;
	      if(VERB && updateVerb && k==KTRACE){
		printf("m=%d/%d:mapid=%d,id=%lld:M=%d,N=%d,n=%d:wt=%0.3f,sitecntN2[%d..%d]+=wt(%0.3f..%0.3f) (sitecntN2[%d]=%0.3f,LijN=%d,RijN=%d,COVERAGE_TRIM_LEN=%0.1f)\n",
		       m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,wt,LijN2,LijN3,Hcuts[LijN2],Hcuts[LijN3],k,sitecntN2[k],LijN,RijN,COVERAGE_TRIM_LEN);
		fflush(stdout);
	      }
	    }
	    for(int k = RijN3; k <= RijN2; k++){
	      sitecntN3[k] += wt;
	      if(VERB && updateVerb && k==KTRACE){
		printf("m=%d/%d:mapid=%d,id=%lld:M=%d,N=%d,n=%d:wt=%0.3f,sitecntN3[%d..%d]+=wt(%0.3f..%0.3f) (sitecntN3[%d]=%0.3f,LijN=%d,RijN=%d,COVERAGE_TRIM_LEN=%0.1f)\n",
		       m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,wt,RijN3,RijN2,Hcuts[RijN3],Hcuts[RijN2],k,sitecntN3[k],LijN,RijN,COVERAGE_TRIM_LEN);
		fflush(stdout);
	      }
	    }
	    if(FragileQualityEnd > 0.0){
              for(int k = max(LijF2,0 /* WAS kL0 */); k <= min(LijF3,iR); k++)
		if(locL2 <= Hcuts[k] && Hcuts[k] <= locL3 /* WAS fabs(Hcuts[k] - locL) <= FragileQualityEnd */){
		  sitecntN4[k] += wt;
		}
	      for(int k = max(RijF3,iL); k <= min(RijF2,n+1/* WAS iR0 */); k++)
		if(locR2 <= Hcuts[k] && Hcuts[k] <= locR3 /* WAS fabs(Hcuts[k] - locR) <= FragileQualityEnd */){
		  sitecntN5[k] += wt;
		}
	    }

	    if(OutlierQuality){/* update sitecntN6[],wtSum[],varSum[],varySum[],meanSum[] over molecule m's alignment range (IL0,KL0,JL0) ... (IR0,KR0,JR0) */
	      int *poutlier = pcontig->outlier[0][m];
#if 0 // OLD code
	      for(int j = JL0; j < JR0; j++){
		if(!(poutlier[j] & 1))
		  continue;
		int Ileft = nmapM[j];
		if(DEBUG && !(Ileft > 0 && Ileft < N)){
		  printf("m=%d,M=%d,N=%d,n=%d:j=%d,outlier[j]=%d,nmapM[j]=ileft=%d\n",m,M,N,n,j,poutlier[j],Ileft);
		  for(int t = 1; t <= M; t++)
		    printf("\t t=%d:Xm[t]=%0.4f, outlier[t]=%d, nmapM[t]=%d\n",t, Xm[t], poutlier[t], nmapM[t]);
		  fflush(stdout);
		  assert(Ileft > 0 && Ileft < N);// start of outlier must be aligned 
		}
		
		// locate right end of outlier
		int k = j+1;
		for(; k <= JR0; k++)
		  if(!(poutlier[k] & 1))
		    break;
		if(DEBUG && !(k <= JR0 && !(poutlier[k]&1))){
		  printf("m=%d,M=%d,N=%d,n=%d:j=%d,outlier[j]=%d,nmapM[j]=ileft=%d\n",m,M,N,n,j,poutlier[j],Ileft);
		  for(int t = 1; t <= M; t++)
		    printf("\t t=%d:Xm[t]=%0.4f, outlier[t]=%d, nmapM[t]=%d\n",t, Xm[t], poutlier[t], nmapM[t]);
		  printf(" k=%d,outlier[k]=%d,JL0=%d,JR0=%d\n",k,poutlier[k],JL0,JR0);
		  fflush(stdout);
		  assert(k <= JR0 && !(poutlier[k]&1));
		}
		int Iright = nmapM[k];
		if(DEBUG) assert(Iright > Ileft && Iright <= N);
		Iright -= nmapKM[k];

		int ileft = nmapMD[Ileft];
		int iright = nmapMD[Iright];
		if(DEBUG) assert(0 < ileft && ileft < iright && iright <= n);

		if(VERB>=3 && ileft < iright){
		  printf("m=%d/%d:mapid=%d,id=%lld:M=%d,N=%d,n=%d:wt=%0.3f,sitecntN6[%d..%d] += wt(%0.3f..%0.3f)\n",
			 m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,wt,ileft,iright-1, Hcuts[ileft],Hcuts[iright]);
		  fflush(stdout);
		}

		for(int t = ileft; t < iright; t++)
		  sitecntN6[t] += wt;

		j = k - 1;
	      }
#else // NEW code (see also ChiSq code in HaplotypeR)
              int iL,kL,JL, i = -1, k = -1, J;

	      for(iL = iL0, kL = kL0, JL = JL0; JL < JR0; JL = J, iL = i, kL = k){
		int I,K;
		/* locate next aligned labels (J,i,k) after (JL,iL,kL) */
		for(J = JL; ++J <= JR0;){
		  if((I = nmapM[J]) <= 0)
		    continue;

		  K = nmapKM[J];
		  if(DEBUG) assert(0 <= K && 1 <= I-K && I <= N);
		  i = nmapMD[I];
		  k = nmapMD[I-K];
		  if(DEBUG) assert(1 <= k && k <= i && i <= iR0);
		  if(DEBUG) assert(!Hdel[i]);
		  if(DEBUG && FRAGCNT_FIX2) assert(!Hdel[k]);
		  break;
		}
		if(DEBUG) assert(J <= JR0);

		/* Xm[JL .. J] maps to Hcuts[(kL,iL) .. (k,i)] && Hdel[kL,iL,k,i] == 0 */
		int ileft = iL;
		int iright = k;
		if(DEBUG) assert(0 < ileft && ileft <= iright && iright <= n);
		
		int outlier = poutlier[JL];
		for(int j = JL + 1; j < J; j++)
		  outlier |= poutlier[j];

		if(outlier & 1){
		  int origileft = ileft;
		  for(int t = ileft+1; t <= iright; t++){
		    if(Hdel[t]) 
		      continue;
		    sitecntN6[ileft] += wt;
		    if(VERB && updateVerb && ileft==KTRACE){
		      printf("m=%d/%d:mapid=%d,id=%lld:M=%d,N=%d,n=%d:wt=%0.3f,sitecntN6[%d..%d]+=wt(%0.3f..%0.3f) (sitecntN6[%d]=%0.3f)\n",
			     m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,wt,origileft,iright-1,Hcuts[origileft],Hcuts[iright],ileft,sitecntN6[ileft]);
		      fflush(stdout);
		    }
		    ileft = t;
		  }
		} else if(OutlierQuality >= 2){
		  double x = Xm[J] - Xm[JL];
		  double yleft = Yc(Hcuts,iL,iL-kL);
		  double yright = Yc(Hcuts,i,i-k);
		  double y = yright - yleft;
		  double vary = SF[0]*SF[0] + y * SD[0] * fabs(SD[0]);
		  if(QUADRATIC_VARIANCE)
		    vary += y * y * SR[0] * SR[0];
		  if(RES_VARIANCE){
		    double resR = Hcuts[i] - Hcuts[k];
		    double resL = Hcuts[iL] - Hcuts[kL];
		    double resvar = resL*resL + resR*resR;
		    vary += SE[0]*SE[0] * resvar;
		  }
		  
		  double Y3 = QUALITY2_FIX ? y : Hcuts[iright] - Hcuts[ileft];
		  double InvY3 = 1.0/Y3;
		  double scale = x * InvY3;
		  double scaleY = y * InvY3;
		  double scaleV = vary * InvY3;

		  if(QUALITY2_FIX && kL < iL){/* left mis-resolved interval : treat as matching 50% of mis-resolved interval at left end of Y */
		    double wt1 = wt*0.5;

		    double y2scale = (Hcuts[ileft] - yleft)/(Hcuts[iL]-Hcuts[kL]);

		    int left = kL;
		    for(int t = left+1; t <= iL; t++){
		      if(Hdel[t])
			continue;
		      double y2 = y2scale * (Hcuts[t] - Hcuts[left]);

		      double x1 = scale * y2;
		      double y1 = scaleY * y2;
		      double v1 = scaleV * y2;
		      double err = x1 - y1;

		      wtSum[left] += wt1;
		      varSum[left] += wt1 * err * err;
		      meanSum[left] += wt1 * err;
		      varySum[left] += wt1 * v1;

		      if(VERB/* HERE HERE >=2 */ && updateVerb && left== KTRACE){
			printf("\tm=%d(id=%lld):wt/2=%0.6f,J=%d..%d,i=%d..%d,k=%d..%d:left=%d,t=%d:y=%0.4f/%0.4f,x=%0.4f/%0.4f,err= %0.6f(sd=%0.6f): wtSum[left]= %0.6f, varSum[left]= %0.6f (exp= %0.6f), meanSum[left]= %0.6f\n",
			       m,gmap[pcontig->contig[m].mapid]->id,wt1,JL,J,iL,i,kL,k,left,t,y1,y,x1,x,err,sqrt(v1),wtSum[left],varSum[left],varySum[left],meanSum[left]);
			fflush(stdout);
		      }

		      left = t;
		    }
		  }

		  for(int t = ileft + 1; t <= iright; t++){
		    if(Hdel[t])
		      continue;
		    double y2 = Hcuts[t] - Hcuts[ileft];

		    double x1 = scale * y2;
		    double y1 = scaleY * y2;
		    double v1 = scaleV * y2;
		    double err = x1 - y1;
		    wtSum[ileft] += wt;
		    varSum[ileft] += wt * err * err;
		    meanSum[ileft] += wt * err;
		    varySum[ileft] += wt * v1;

		    if(VERB/* HERE HERE >=2 */ && updateVerb && ileft== KTRACE){
		      printf("\tm=%d(id=%lld):wt=%0.6f,J=%d..%d,i=%d..%d,k=%d..%d:left=%d,t=%d:y=%0.4f/%0.4f,x=%0.4f/%0.4f,err= %0.6f(sd=%0.6f): wtSum[left]= %0.6f, varSum[left]= %0.6f (exp= %0.6f), meanSum[left]= %0.6f\n",
			     m,gmap[pcontig->contig[m].mapid]->id,wt,JL,J,iL,i,kL,k,ileft,t,y1,y,x1,x,err,sqrt(v1),wtSum[ileft],varSum[ileft],varySum[ileft],meanSum[ileft]);
		      fflush(stdout);
		    }

		    ileft = t;
		  }

		  if(QUALITY2_FIX && k < i){/* right mis-resolved interval : treat as matching 50% of mis-resolved interval at right end of Y */
		    double wt1 = wt*0.5;

		    double y2scale = (yright - Hcuts[k])/(Hcuts[i]-Hcuts[k]);
		    
		    int left = k;
		    for(int t = left+1; t <= i; t++){
		      if(Hdel[t])
			continue;
		      double y2 = y2scale * (Hcuts[t] - Hcuts[left]);

		      double x1 = scale * y2;
		      double y1 = scaleY * y2;
		      double v1 = scaleV * y2;
		      double err = x1 - y1;

		      wtSum[left] += wt1;
		      varSum[left] += wt1 * err * err;
		      meanSum[left] += wt1 * err;
		      varySum[left] += wt1 * v1;

		      if(VERB/* HERE HERE >=2 */ && updateVerb && left== KTRACE){
			printf("\tm=%d(id=%lld):wt/2=%0.6f,J=%d..%d,i=%d..%d,k=%d..%d:left=%d,t=%d:y=%0.4f/%0.4f,x=%0.4f/%0.4f,err= %0.6f(sd=%0.6f): wtSum[left]= %0.6f, varSum[left]= %0.6f (exp= %0.6f), meanSum[left]= %0.6f\n",
			       m,gmap[pcontig->contig[m].mapid]->id,wt1,JL,J,iL,i,kL,k,left,t,y1,y,x1,x,err,sqrt(v1),wtSum[left],varSum[left],varySum[left],meanSum[left]);
			fflush(stdout);
		      }
		    }
		  }
		} // if(OutlierQuality >= 2)
	      }// for(iL = iL0, kL = kL0, JL = JL0; JL < JR0; JL = J, iL = i, kL = k)
#endif // NEW code
	    } // if(OutlierQuality)
	    if(KTRACE > 0 && LijF2 <= KTRACE && KTRACE <= RijF2){
	      if(OutlierQuality >= 2)
		printf("m=%d/%d,id=%lld:k=%d:LijF2=%d,RijF2=%d:fragcnt[k]= %0.2f, fragcntT[k]= %0.2f: N2[k]= %0.2f, N3[k]= %0.2f, N4[k]= %0.2f, N5[k]= %0.2f, N6[k]= %0.2f, wtSum[k]= %0.6f, varSum[k]= %0.6f, meanSum[k]= %0.4f\n", 
		       m,MD,gmap[pcontig->contig[m].mapid]->id,KTRACE, LijF2,RijF2,fragcnt[KTRACE],fragcntT[KTRACE], sitecntN2[KTRACE], sitecntN3[KTRACE], sitecntN4[KTRACE], sitecntN5[KTRACE], sitecntN6[KTRACE],wtSum[KTRACE],varSum[KTRACE],meanSum[KTRACE]);
	      else
		printf("m=%d/%d,id=%lld:k=%d:LijF2=%d,RijF2=%d:fragcnt[k]= %0.2f, fragcntT[k]= %0.2f: N2[k]= %0.2f, N3[k]= %0.2f, N4[k]= %0.2f, N5[k]= %0.2f, N6[k]= %0.2f\n", 
		       m,MD,gmap[pcontig->contig[m].mapid]->id,KTRACE, LijF2,RijF2,fragcnt[KTRACE],fragcntT[KTRACE], sitecntN2[KTRACE], sitecntN3[KTRACE], sitecntN4[KTRACE], sitecntN5[KTRACE], sitecntN6[KTRACE]);
	      fflush(stdout);
	    }

	  } else {
	    for(int k = LijN2; k <= RijN2; k++){
	      sitecntFNnorm[k] += wt;
	      if(DEBUG>=2) assert(isfinite(sitecntFNnorm[k]) && sitecntFNnorm[k] >= 0.0f);
	      if(VERB && updateVerb && k==KTRACE){
		printf("m=%d/%d:mapid=%d,id=%lld:M=%d,N=%d,n=%d:wt=%0.3f,sitecntFNnorm[%d..%d]+=wt(%0.3f..%0.3f) (sitecntFNnorm[%d]=%0.3f,LijN=%d,RijN=%d,COVERAGE_TRIM_LEN=%0.1f)\n\tfragcnt[%d..%d]+=wt(%0.3f..%0.3f),fragcntT[%d..%d]+=wt(%0.3f..%0.3f), sitecntFN[%d..%d]+=wt\n",
		       m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,wt,LijN2,RijN2,Hcuts[LijN2],Hcuts[RijN2],k,sitecntFNnorm[k],LijN,RijN,COVERAGE_TRIM_LEN,
		       kL0,iR0,Hcuts[kL0],Hcuts[iR0],Lij,Rij,Hcuts[Lij],Hcuts[Rij], iL, iR);
		fflush(stdout);
	      }
	    }
	  }
	}

	if(DEBUG && iL <= iR) assert(lcnt > COVERAGE_TRIM && rcnt > COVERAGE_TRIM);

	if(lcnt > COVERAGE_TRIM && rcnt > COVERAGE_TRIM && IL-KL <= IR && !(TrimNormEnd > 0 && max(LeftEnd,RightEnd) >= TrimNormEnd)){
	  if(TrimOutlier && pcontig->outlier[0]){
	    if(VERB/* >=2 && IL <= KTRACE && KTRACE <= IR*/ && updateVerb){
	      printf("Scanning sitecntFN[%d..%d],Hcuts[]=%0.3f..%0.3f for outliers:m=%d,M=%d,JL0=%d,IL0=%d,KL0=%d,JL=%d,IL=%d,KL=%d,JR=%d,IR=%d,KR=%d,JR0=%d,IR0=%d,KR0=%d\n",
		     iL,iR, Hcuts[iL],Hcuts[iR],m,M,JL0,IL0,KL0,JL,IL,KL,JR,IR,KR,JR0,IR0,KR0);
	      fflush(stdout);
	    }

	    int *poutlier = pcontig->outlier[0][m];

	    /* break molecule alignment into regions without outliers and handle each region as a seperate molecule alignment */
	    int origJR0 = JR0;
	    for(int j = JL0; j <= origJR0; j++){
	      if(nmapM[j] < 0)
		continue;
	      /* check for outlier starting with interval Xm[j..j+1] */
	      
	      if((poutlier[j]&1) 
		 || j == origJR0){/* treat region Xm[JL0 .. j] as a seperate aligned molecule and update sitecntFN[] with it */
		JR0 = j;
		IR0 = nmapM[j];
		KR0 = nmapKM[j];
		if(DEBUG) assert(0 <= KR0 && 1 <= IR0 -KR0 && IR0 <= N);

		int jnext = j;
		if(jnext < origJR0){/* verify outlier size and misaligned labels (see TrimOutlierKB and TrimOutlierLabels) */
		  int iR0 = nmapMD[IR0];
		  int kR0 = nmapMD[IR0-KR0];
		  if(DEBUG) assert(1 <= kR0 && kR0 <= iR0 && iR0 <= n);
		  if(DEBUG) assert(!Hdel[iR0]);

		  /* locate next aligned site with poutlier[jnext] == 0 */
		  if(DEBUG) assert(poutlier[jnext]&1);
		  while(++jnext < origJR0){
		    if(nmapM[jnext] < 0)
		      continue;
		    if((poutlier[jnext]&1)==0)
		      break;
		  }
		  int Inext = nmapM[jnext];
		  int Knext = nmapKM[jnext];
		  if(DEBUG) assert(0 <= Knext && 1 <= Inext-Knext && Inext <= N);
		  int inext = nmapMD[Inext];
		  int knext = nmapMD[Inext-Knext];
		  if(DEBUG) assert(1 <= knext && knext <= inext && inext <= n);
		  if(DEBUG) assert(!Hdel[inext]);

		  double x = Xm[jnext] - Xm[JR0];
		  double y = Yc(Hcuts,inext,inext-knext) - Yc(Hcuts,iR0,iR0-kR0);
		  if(fabs(x-y) < TrimOutlierKB && (Inext-Knext-iR0 + jnext-j - 2) < TrimOutlierLabels){/* ignore this outlier */
		    JL0 = jnext;
		    IL0 = Inext;
		    KL0 = Knext;
		    continue;
		  }
		}

		if(JR0 - JL0 >= COVERAGE_TRIM * 2 && (TRIM_FIX ? (Y[IR0] - Y[IL0-KL0]) : (Xm[JR0] - Xm[JL0])) >= COVERAGE_TRIM_LEN*2.0){
		  lcnt = 0;
		  JL = JL0; IL = IL0; KL = KL0;
		  for(int J = JL0 + 1; J < JR0; J++){
		    if(nmapM[J] < 0)
		      continue;
		    IL = nmapM[JL = J];
		    KL = nmapKM[JL];
		    if(++lcnt > COVERAGE_TRIM && (TRIM_FIX ? (Y[IL-KL] - Y[IL0-KL0]) : (Xm[JL] - Xm[JL0])) >= COVERAGE_TRIM_LEN)
		      break;
		  }
		  rcnt = 0;
		  JR = JR0; IR = IR0; KR = KR0;
		  for(int J = JR0; --J > JL0;){
		    if(nmapM[J] < 0)
		      continue;
		    IR = nmapM[JR = J];
		    int i = nmapMD[IR];
		    if(DEBUG>=2 && i >= 0) assert(!Hdel[i]);
		    KR = (!FRAGCNT_FIX2 || i >= 0) ? nmapKM[JR] : 0;
		    if(DEBUG>=2 && FRAGCNT_FIX2 && i >= 0){
		      int k = nmapMD[IR-KR];
		      assert(!Hdel[k]);
		    }
		    if(++rcnt > COVERAGE_TRIM && (TRIM_FIX ? (Y[IR0] - Y[IR]) : (Xm[JR0] - Xm[JR])) >= COVERAGE_TRIM_LEN)
		      break;
		  }
		  if(VERB>=3 && updateVerb){
		    printf("\t\t m=%d:j=%d,JL0=%d,IL0=%d,KL0=%d,JL=%d,IL=%d,KL=%d,JR=%d,IR=%d,KR=%d,JR0=%d,IR0=%d,KR0=%d\n",
			   m,j,JL0,IL0,KL0,JL,IL,KL,JR,IR,KR,JR0,IR0,KR0);
		    fflush(stdout);
		  }
		  if(lcnt > COVERAGE_TRIM && rcnt > COVERAGE_TRIM && IL-KL <= IR){
		    int iL = nmapMD[TRIM_FIX ? IL-KL : IL];
		    int iR = nmapMD[TRIM_FIX ? IR : IR-KR];
		    if(DEBUG) assert(IL-KL >= 1 && IL-KL <= IR && IR <= N);
		    for(register int k = iL; k <= iR; k++){
		      sitecntFN[k] += wt;
		      if(VERB && TrimNorm >= 0 && updateVerb && k==KTRACE){
			printf("m=%d,mapid=%d,id=%lld:M=%d,N=%d,n=%d:wt=%0.3f,sitecntFN[%d..%d]+=wt(%0.3f..%0.3f),sitecntFN[k=%d]=%0.3f,sitecntFNnorm[%d..%d]+=wt(%0.3f..%0.3f),sitecntFNnorm[k]=%0.3f,Lij=%d,%d,Rij=%d,%d\n", 
			       m,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n, wt, iL,iR, Hcuts[iL],Hcuts[iR],k, sitecntFN[k], LijN2, RijN2, Hcuts[LijN2], Hcuts[RijN2], sitecntFNnorm[k],Lij,LijN,Rij,RijN);
			fflush(stdout);
		      }
		    }
		    if(VERB/* >=2 */ && iL <= KTRACE && KTRACE <= iR && updateVerb){
		      printf("      sitecntFN[%d..%d] += wt = %0.4f,n=%d,Hcuts[]=%0.3f..%0.3f,outlier[JR0=%d]=%d\n", iL,iR, wt, n, Hcuts[iL],Hcuts[iR], JR0,poutlier[JR0]);
		      fflush(stdout);
		    }
		  }
		} else if(VERB>=3 && updateVerb){
		  printf("\t\t m=%d:j=%d,JL0=%d,IL0=%d,KL0=%d,JR0=%d,IR0=%d,KR0=%d,outlier[j]=%d\n",
			 m,j,JL0,IL0,KL0,JR0,IR0,KR0,poutlier[j]);
		  fflush(stdout);
		}
		if(DEBUG)/* verify that there were no outliers between JL0 and JR0 */
		  for(int J = JL0; J < JR0; J++)
		    assert(!(poutlier[J]&1));
#if 0 // OLD code
		if((poutlier[j]&1) && j < origJR0){/* skip ahead to first aligned site with poutlier[j] == 0 */
		  while(++j < origJR0){
		    if(nmapM[j] < 0)
		      continue;
		    if((poutlier[j]&1)==0)
		      break;
		  }
		  if(VERB>=3 && updateVerb){
		    printf("\t\t m=%d:skipped outlier region Xm[%d..%d]=%0.3f..%0.3f aligned with Y[%d..%d]=%0.3f..%0.3f\n",
			   m,JR0,j,Xm[JR0],Xm[j],IR0-KR0,nmapM[j],Y[IR0-KR0],Y[nmapM[j]]);
		    fflush(stdout);
		  }
		}
		if(DEBUG) assert((poutlier[j]&1)==0 && nmapM[j] >= 0);

		JL0 = j;
#else // NEW code
		JL0 = jnext;
#endif
		IL0 = nmapM[JL0];
		KL0 = nmapKM[JL0];
	      }/* if((poutlier[j]&1) || j==origJR0) */
	    }
	  } else {/* ! TrimOutlier */
	    if(DEBUG && !(IL-KL >= 1 && IL-KL <= IR && IR <= N)){ 
	      printf("m=%d:M=%d,N=%d:lcnt=%d,rcnt=%d,IL=%d,KL=%d,IR=%d\n",m,M,N,lcnt,rcnt,IL,KL,IR);
	      fflush(stdout);
	      assert(IL-KL >= 1 && IL-KL <= IR && IR <= N);
	    }
	    if((VERB>=2 || ERRPLOT>=2) && (Hcuts[nmapMD[IL]] <= 511.834 + 0.001 && Hcuts[nmapMD[IR-KR]] >= 533.508 - 0.001)){
	      printf("m=%d,mapid=%d,id=%lld:M=%d,N=%d,n=%d:Lij=%d,Rij=%d(Hcuts=%0.3f,%0.3f),JL=%d,JR=%d,IL0=%d(KL0=%d),IL=%d,IR=%d(KR=%d),IR0=%d(KR0=%d),iL0=%d,iL=%d,iR=%d,iR0=%d(Hcuts:%0.3f,%0.3f,%0.3f,%0.3f)\n",
		     m,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,Lij,Rij,Hcuts[Lij],Hcuts[Rij],JL,JR,IL0,KL0,IL,IR,KR,IR0,KR0,
		     iL0,nmapMD[IL],iR0,nmapMD[IR0-KR0], Hcuts[iL0],Hcuts[nmapMD[IL]],Hcuts[nmapMD[IR-KR]],Hcuts[iR0]);
	      fflush(stdout);
	    }
	    for(int k = iL; k <= iR; k++){
	      sitecntFN[k] += wt;
	      if(VERB && TrimNorm >= 0 && updateVerb && k==KTRACE){
		printf("m=%d,mapid=%d,id=%lld:M=%d,N=%d,n=%d:wt=%0.3f,sitecntFN[%d..%d]+=wt(%0.3f..%0.3f),sitecntFN[k=%d]=%0.3f,sitecntFNnorm[%d..%d]+=wt(%0.3f..%0.3f),sitecntFNnorm[k]=%0.3f,Lij=%d,%d,Rij=%d,%d\n", 
		       m,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n, wt, iL,iR, Hcuts[iL],Hcuts[iR],k, sitecntFN[k], LijN2, RijN2, Hcuts[LijN2], Hcuts[RijN2], sitecntFNnorm[k],Lij,LijN,Rij,RijN);
		fflush(stdout);
	      }
	    }
	    if(VERB/* >=2 */ && iL <= KTRACE && KTRACE <= iR && updateVerb){
	      printf("      sitecntFN[%d..%d] += wt = %0.4f,n=%d,Hcuts[]=%0.3f..%0.3f\n", iL,iR, wt, n, Hcuts[iL],Hcuts[iR]);
	      fflush(stdout);
	    }
	  }
	}
	if(VERB>=2 && Rij > n){
	  printf("m=%d/%d:mapid=%d,id=%lld:M=%d,N=%d,n=%d:nmapK[m][M+1]=%d,Rij=%d, fragcnt[0]=%0.1f,fragcnt[n]->%0.1f\n",
		 m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,nmapK[m][M+1],Rij, fragcnt[0], fragcnt[n]);
	  fflush(stdout);
	}
      }
    }
    if(OMP_DEBUG && myLoopCnt > 0){
      #pragma omp critical
      {
	LoopCnt += myLoopCnt;
      }
    }
  }
  if(OMP_DEBUG) assert(LoopCnt == MD);// verify OMP loop worked

  if(pcontig && TrimNorm >= 0 && ChimQualityFix)/* compute sitecntFNnorm[k=0..n+1] =  sitecntFN[k] + sitecntN2[k] + sitecntN3[k] */
    for(int k = 0; k <= n+1; k++)
      sitecntFNnorm[k] = sitecntFN[k] + sitecntN2[k] + sitecntN3[k];

  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      int lastJ = -1, lasti = -1, lastk = -1;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
	  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	  fflush(stdout);
	  assert(0 <= k && k < i);
	}
	if(lasti >= 0 && !(i-k > lasti)){
	  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	  if(VERB){
	    for(int j = 1; j <= M; j++){
	      int i = map[m][j];
	      if(i < 0)
		continue;
	      int k = mapK[m][j];
	      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d\n",j,i,k);
	    }
	  }
	  fflush(stdout);
	  assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }
  }

  delete [] mapMM;

  if(pcontig && TrimNorm >= 0){
    double origTrimNormMinCov = TrimNormMinCov;
    if(!TrimNormMinCov)
      TrimNormMinCov = 9999.0;

    // FIX : suppress ChimQuality score until COVERAGE_TRIM_LEN past the first label or before last label
    int left = 0, right = n+1;

    while(left < n && Hdel[left+1])
      left++;
    int firstsite = left;
    while(left < n && !(!Hdel[left+1] && Hcuts[left+1] - Hcuts[firstsite] >= COVERAGE_TRIM_LEN))
      left++;

    while(right > 1 && Hdel[right-1])
      right--;
    int lastsite = right;
    while(right > 1 && !(!Hdel[right-1] && Hcuts[lastsite] - Hcuts[right-1] >= COVERAGE_TRIM_LEN))
      right--;

    int left1 = left, right1 = right;

    /*  skip ends until (sitecntFNnorm[k] >= TrimNormMin OR fragcntT[k] >= TrimNormMinCov) */
    while(left < n && (sitecntFN[left+1] <= 0.0 || (SPLIT_FIX>=2 && sitecntFNnorm[left+1] < TrimNormMin && (FRAGCOV_FIX ? max(fragcnt[left],fragcnt[left+1]) : fragcnt[left+1]) < TrimNormMinCov)))
      left++;
    while(right > 1 && (sitecntFN[right-1] <= 0.0 || (SPLIT_FIX>=2 && sitecntFNnorm[right-1] < TrimNormMin && (FRAGCOV_FIX ? max(fragcnt[right-2],fragcnt[right-1]) : fragcnt[right-1]) < TrimNormMinCov)))
      right--;

    // FIX2 : don't apply TrimNormMin suppression of quality score until fragcntT[k] /* WAS74 sitecntFNnorm[k] */ >= TrimNormMinEnd */
    int left2 = left, right2 = right;
    while(left2 < n && (sitecntFN[left2+1] <= 0.0 || (SPLIT_FIX>=2 && fragcntT[left2+1] < TrimNormMinEnd)))
      left2++;
    while(right2 > 1 && (sitecntFN[right2-1] <= 0.0 || (SPLIT_FIX>=2 && fragcntT[right2-1] < TrimNormMinEnd)))
      right2--;

    if(VERB && updateVerb){
      printf("sitecntFN:skipping QC at ends until left=%d(firstsite=%d,left1=%d,left2=%d) and after right=%d(lastsite=%d,right1=%d,right2=%d) (TrimNorm=%0.1f,TrimNormMin=%0.1f,%0.1f,%0.1f)_,CovTrimLen=%0.3f kb\n",
	     left,firstsite,left1,left2,right,lastsite,right1,right2,TrimNorm,TrimNormMin,TrimNormMinCov,TrimNormMinEnd,COVERAGE_TRIM_LEN);
      fflush(stdout);
    }
    if(TrimNormLen > 0.0){/* smooth normalization value sitecntFNnorm[k] by replacing with largest original value within TrimNormLen kb */
      if(VERB && updateVerb){
	printf("sitecntFNnorm: taking largest value within %0.3f kb\n",TrimNormLen);
	fflush(stdout);
      }
      float *orignorm = new float[n+1];
      for(int k = 1; k <= n; k++)
	orignorm[k] = sitecntFNnorm[k];

      for(int k = 1; k <= n; k++){
	float norm = orignorm[k];
	double HcutsK = Hcuts[k];
	for(int t = k; --t >= 1;){
	  if(Hdel[t])
	    continue;
	  if(HcutsK - Hcuts[t] > TrimNormLen)
	    break;
	  norm = max(norm, orignorm[t]);
	}
	for(int t = k; ++t <= n;){
	  if(Hdel[t])
	    continue;
	  if(Hcuts[t] - HcutsK > TrimNormLen)
	    break;
	  norm = max(norm, orignorm[t]);
	}
	sitecntFNnorm[k] = norm;
      }
      delete [] orignorm;
    }

    float *N1 = NULL;
    if(TrimNormMinRel < 1.0){
      N1 = new float[n+1];
      for(int k = 1; k <= n; k++)
	N1[k] = sitecntFN[k];
    }

    for(int k = 1; k <= n; k++){
      float cov = sitecntFN[k];
      float covL = sitecntN2[k];
      float covR = sitecntN3[k];
      float norm = sitecntFNnorm[k];// cov + covL + covR

      float fragileL = sitecntN4[k];
      float fragileR = sitecntN5[k];
      float Cnorm = FRAGCOV_FIX ? max(fragcnt[max(0,k-1)],fragcnt[k]) : fragcnt[k];

      /* OutlierQuality scores only defined if Hdel[k] == 0 */
      int nk = k+1;
      while(nk <= n && !Hdel[nk])
	nk++;
      float OutlierQ = sitecntN6[k];

      double wtQ = 0.0, biasQ = 0.0, VaryQ = 0.0, VarQ = 0.0, pvQ = 1.0;
      int nQ;

      if(OutlierQuality >= 2){
	wtQ = max(0.001, wtSum[k]);
	biasQ = meanSum[k] / wtQ;
	// double	yQ = Hcuts[nk] - Hcuts[k] + biasQ;
	VaryQ = max(1e-6, varySum[k] / wtQ); // (SF[0]*SF[0] + yQ * SD[0] * fabs(SD[0]) + yQ * yQ * SR[0] * SR[0]);
	VarQ = max(1e-6, varSum[k] / wtQ);
	nQ = max(1.0, floor(wtQ - 0.5));
	extern double ChiSqPvalue(int n, double chisq);
	pvQ = ChiSqPvalue(nQ, VarQ * nQ / VaryQ);
      }

      float TrimNormMink = TrimNormMin;
      float leftN1 = 0.0, rightN1 = 0.0;
      if(TrimNormMinRel < 1.0){
	for(int t = max(left,left2); t < k; t++)
	  leftN1 = max(leftN1,N1[t]);
	for(int t = min(right,right2); t > k; t--)
	  rightN1 = max(rightN1,N1[t]);
	TrimNormMink = min(TrimNormMink, min(leftN1,rightN1) * (float)TrimNormMinRel);
      }

      if(DEBUG>=2) assert(isfinite(cov) && cov >= 0.0f);
      sitecntFN[k] = (k <= left || k >= right) ? END_CHIMQUAL : (SPLIT_FIX && k >= left2 && k <= right2 && cov < TrimNormMink && Cnorm < TrimNormMinCov) ? 0.0f : 
	(norm + TrimNorm < 0.1f) ? 100.0f : 100.0f * (cov + TrimNorm) / (norm + TrimNorm);

      sitecntN2[k] = (k <= left || k >= right) ? END_CHIMQUAL : (SPLIT_FIX && k >= left2 && k <= right2 && cov < TrimNormMink && Cnorm < TrimNormMinCov) ? (covL+covR < 0.1f ? 50.0f : 100.0f * covL/(covL+covR)) : 
	(norm + TrimNorm < 0.1f) ? 0.0f : 100.0f * covL / (norm + TrimNorm);
      sitecntN3[k] = (k <= left || k >= right) ? END_CHIMQUAL : (SPLIT_FIX && k >= left2 && k <= right2 && cov < TrimNormMink && Cnorm < TrimNormMinCov) ? (covL+covR < 0.1f ? 50.0f : 100.0f * covR/(covL+covR)) : 
	(norm + TrimNorm < 0.1f) ? 0.0f : 100.0f * covR / (norm + TrimNorm);

      sitecntFNnorm[k] = (k <= left || k >= right) ? END_CHIMQUAL : (SPLIT_FIX && cov < TrimNormMink && Cnorm < TrimNormMinCov) ? covL+covR : norm + TrimNorm;

      double fragcntTk = FRAGCOV_FIX ? max(fragcntT[k],fragcntT[max(0,k-1)]) : fragcntT[k];

      if((DEBUG>=1+RELEASE && !(isfinite(norm) && norm >= 0.0f && isfinite(fragcntTk) && fragcntTk >= 0.0 && (Cnorm < 0.9f || fragcntTk > 0.0f))) || 
	 (VERB>=2 && updateVerb) || (DEBUG && sitecntFN[k] > 100.001f) /* || (VERB && CMapID==1316)*/){
	printf("k=%4d,n=%d:Hcuts[k]=%9.3f,Hdel[k]=%d:cov=%0.2f,norm=%0.2f,fragcnt[k]=%0.2f,fragcntT[k]=%0.2f:sitecntFNnorm[k] -> %0.2f,sitecntFN[k] -> %0.2f\n",
	       k,n,Hcuts[k],Hdel[k],cov,norm,fragcnt[k],fragcntT[k],sitecntFNnorm[k],sitecntFN[k]);
	fflush(stdout);
	assert(isfinite(norm) && norm >= 0.0f);
	assert(sitecntFN[k] <= 100.001f);
	assert(isfinite(fragcntTk) && fragcntTk >= 0.0f);
	assert(Cnorm < 0.9f || fragcntTk > 0.0f);
      }

      sitecntN4[k] = (Cnorm < 0.9f) ? 0.0f : 100.0f * fragileL / fragcntTk;
      sitecntN5[k] = (Cnorm < 0.9f) ? 0.0f : 100.0f * fragileR / fragcntTk;

      if(OutlierQuality <= 1)
	sitecntN6[k] = (k <= 0 || k >= n) ? 0.0f : (Cnorm < 0.9f) ? 0.0f : 100.0f * OutlierQ / Cnorm;
      else {// OutlierQuality >= 2
	sitecntN6[k] = (k <= 0 || k >= n) ? 0.0f : 100.0f * OutlierQ / (OutlierQ + wtQ);
	fragSd[k] = (k <= 0 || k >= n) ? 0.0f : sqrt(VarQ);
	expSd[k] = (k <= 0 || k >= n) ? 0.0f : sqrt(VaryQ);
	fragBias[k] = (k <= 0 || k >= n) ? 0.0f : biasQ;
	fragCov[k] = (k <= 0 || k >= n) ? 0.0f : wtQ;
	fragChiSq[k] = (k <= 0 || k >= n) ? 1.0f : pvQ;
      }

      if(VERB && updateVerb && !Hdel[k]){
	if(TrimNormMinRel < 1.0)
	  printf("k=%d:Hcuts[k]=%0.4f:N1=%0.2f,N2=%0.2f,N3=%0.2f,(N123=%0.2f),N4=%0.2f,N5=%0.2f,N6=%0.2f,sitecnt[k]=%0.2f,fragcnt[k]=%0.2f,fragcntT[k]=%0.2f,Cnorm=%0.2f,fragcntTk=%0.2f:\n\t\t FNnorm=%0.2f, CQ=%0.2f,SL=%0.2f,SR=%0.2f,FL=%0.2f,FR=%0.2f,OutQ=%0.2f,leftN1=%0.2f,rightN1=%0.2f,minN1=%0.2f\n",
		 k,Hcuts[k],cov,covL,covR,norm,fragileL,fragileR,OutlierQ,sitecnt[k],fragcnt[k],fragcntT[k],Cnorm, fragcntTk, 
		 sitecntFNnorm[k], sitecntFN[k], sitecntN2[k],sitecntN3[k],sitecntN4[k],sitecntN5[k], sitecntN6[k],leftN1,rightN1,TrimNormMink);
	else
	  printf("k=%d:Hcuts[k]=%0.4f:N1=%0.2f,N2=%0.2f,N3=%0.2f,(N123=%0.2f),N4=%0.2f,N5=%0.2f,N6=%0.2f,sitecnt[k]=%0.2f,fragcnt[k]=%0.2f,fragcntT[k]=%0.2f,Cnorm=%0.2f,fragcntTk=%0.2f:\n\t\t FNnorm=%0.2f, CQ=%0.2f,SL=%0.2f,SR=%0.2f,FL=%0.2f,FR=%0.2f,OutQ=%0.2f\n",
		 k,Hcuts[k],cov,covL,covR,norm,fragileL,fragileR,OutlierQ,sitecnt[k],fragcnt[k],fragcntT[k],Cnorm, fragcntTk, 
		 sitecntFNnorm[k], sitecntFN[k], sitecntN2[k],sitecntN3[k],sitecntN4[k],sitecntN5[k], sitecntN6[k]);
	
	if(OutlierQuality >= 2)
	  printf("\t fragSd= %0.6f (expSd= %0.6f, ChiSqPv= %0.8f), fragBias= %0.6f, fragCov= %0.6f\n",fragSd[k], expSd[k], fragChiSq[k], fragBias[k], fragCov[k]);

	fflush(stdout);
      }
      
      if(DEBUG) assert(isfinite(sitecntFN[k]) && -1.0 <= sitecntFN[k] && sitecntFN[k] <= 100.001f);
      if(DEBUG) assert(isfinite(sitecntN2[k]) && -1.0 <= sitecntN2[k] && sitecntN2[k] <= 100.001f);
      if(DEBUG) assert(isfinite(sitecntN3[k]) && -1.0 <= sitecntN3[k] && sitecntN3[k] <= 100.001f);
      if(DEBUG) assert(isfinite(sitecntFNnorm[k]) && -1.0 <= sitecntFNnorm[k]);
      if(DEBUG && !(isfinite(sitecntN4[k]) && 0.0 <= sitecntN4[k])){
	printf("k=%d:Hdel[k]=%d,Hcuts[k]=%0.4f:N1=%0.2f,N2=%0.2f,N3=%0.2f,(N123=%0.2f),N4=%0.2f,N5=%0.2f,N6=%0.2f,fragcnt=%0.2f,fragcntT=%0.2f: Norm=%0.2f, CQ=%0.2f,SL=%0.2f,SR=%0.2f,FL=%0.2f,FR=%0.2f,OutQ=%0.2f\n",
	       k,Hdel[k],Hcuts[k],cov,covL,covR,norm,fragileL,fragileR,OutlierQ,Cnorm, fragcntTk,sitecntFNnorm[k], sitecntFN[k], sitecntN2[k],sitecntN3[k],sitecntN4[k],sitecntN5[k], sitecntN6[k]);
	fflush(stdout);
	assert(isfinite(sitecntN4[k]) && 0.0 <= sitecntN4[k]);
      }
      if(DEBUG) assert(isfinite(sitecntN5[k]) && 0.0 <= sitecntN5[k]);
      if(DEBUG) assert(isfinite(sitecntN6[k]) && 0.0 <= sitecntN6[k] && sitecntN6[k] <= 100.001f);
    }
    
    delete [] N1;

    if(VERB>=3){
      for(int k = 1; k <= n; k++){
	if(Hdel[k])
	  continue;
	printf("k=%4d,n=%d:Hcuts[k]=%9.3f,Hdel[k]=%d:fragcnt=%0.2f,sitecnt=%0.2f\n",k,n,Hcuts[k],Hdel[k],fragcnt[k],sitecnt[k]);
      }
      fflush(stdout);
    }
    TrimNormMinCov = origTrimNormMinCov;
  }

  if(wtSum)
    delete [] wtSum;
}

/** returns number of sites in current consensus map H[0..N+1] */
static int setmap(register int n, register double *Hcuts,/**< Hcuts[0..n+1] : complete consensus sites */
		  register int *Hdel, /**< Hdel[0..n+1] : currently deleted consensus sites */
		  register double *H, /**< H[0..N+1] : current consensus sites (subset of Hcuts[0..n+1]) */
		  register int *mapM, /**< mapM[j=0..n+1] will be index of Hcuts[j] in H[0..N+1] (or -1 if not aligned) */
		  register int *nmapM) /**< nmapM[j=0..N+1] will be index of site H[j] in Hcuts[0..n+1] */
{
  register int N = 0;
  H[0] = 0.0;
  mapM[0] = nmapM[0] = 0;
  for(register int i = 1; i <= n; i++){
    if(Hdel[i]){
      mapM[i] = -1;
      continue;
    }
    H[++N] = Hcuts[i];
    mapM[i] = N;
    nmapM[N] = i;
  }
  H[N+1] = Hcuts[n+1];
  mapM[n+1] = N+1;
  nmapM[N+1] = n+1;

  return N;
}
		  

/** compute inverse of erfc() function */
double erfcInv(register double x)
{
  if(DEBUG)
    assert(x >= 0.0 && x <= 1.0);
  if(x <= 0.0)
    return 100.0;
  if(x >= 1.0)
    return 0.0;
  register double res = 1.0e-7;
  register double ubnd = 99.999999;/* upper bound guess of answer */
  register double lbnd = 0.0;/* lower bound guess of answer */
  
  /* compute approximate answer for erfInv(1.0-x) : see wikipedia*/
  if(x < 1.0e-10){
    ubnd = 100.0;
    if(erfc(ubnd) >= x)
      return ubnd;
    lbnd = 4.57; /* erfcInv(1.0e-10) - 0.01; */
    assert(erfc(ubnd) < x);
    assert(erfc(lbnd) > x);
  } else {
    register double y = 1.0-x;
    register double Ly2 = log(1.0-y*y);
    register double aInv = (1.0/0.147);/* see wikipedia */
    register double  b = 2.0*aInv/M_PI;
    register double  c = b + Ly2*0.5;
    register double val = sqrt(sqrt(c*c-Ly2*aInv)-c);
  
    ubnd = val + 0.01;
    lbnd = val - 0.01;
    if(DEBUG){
      assert(erfc(ubnd) < x);
      if(!(erfc(lbnd) > x)){
	printf("erfcInv:x=%0.17e,val=%0.17e,erfc(val)=%0.17e,lbnd=%0.17e,erfc(lbnd)=%0.17e\n",
	       x,val,erfc(val),lbnd,erfc(lbnd));
	assert(erfc(lbnd) > x);
      }
    }
  } 

  register int cnt;
  for(cnt=0; cnt < 1000 && ubnd - lbnd > res; cnt++){
    register double mid = (lbnd+ubnd)*0.5;
    register double val = erfc(mid);
    if(val > x)
      lbnd = mid;
    else if(val < x)
      ubnd = mid;
    else return mid;
  }
  if(DEBUG)
    assert(cnt < 1000);
  return (lbnd+ubnd)*0.5;
}

double zscore(register double pvalue)
{
  return sqrt(2.0)*(pvalue < 0.5 ? erfcInv(2.0*pvalue) : -erfcInv(2.0*(1.0-pvalue)));
}

/* Huber Norm, for z > 0.0
   PHuber(z,delta) = z*z/2                                 IF z <= delta
   delta*z - delta*delta/2               IF z >= delta
*/
#if 0
static double PHuber(register double z, register double delta)
{
  if(DEBUG/*>=2*/) assert(z >= 0.0);
  return (z <= delta) ? z*z*0.5 : delta*z - delta*delta*0.5;
}
#endif

/* Huber Norm for all values of z :
   Huber(z,delta) = PHuber(|z|,delta)
*/
/*
  static double Huber(register double z, register double delta)
  {
  return PHuber(abs(z),delta);
  }
*/

/** Huber modified Gaussian Normalization factor 
    NHuber(delta) = sqrt(2/M_PI)*exp(-delta*delta/2)/delta + erf(delta/sqrt(2)) */
static double NHuber(register double delta)
{
  return sqrt(2.0/M_PI)*exp(-delta*delta*0.5)/delta + erf(delta*sqrt(0.5));
}

/* Huber modified Gaussian density, for z >= 0.0 :
   HGauss(z,delta) = exp(-PHuber(z,delta))/(NHuber(delta)*sqrt(2*MPI)),
*/
/*static double HGauss(register double z, register double delta)
  {
  return exp(-PHuber(z,delta)) / (NHuber(delta)*sqrt(2.0*M_PI));
  }*/

/** Huber modified Gaussian (HGauss) integral between z and Inf, for z >= 0.0 :
    HuberErf(z) = 0.5  - 0.5*erf(z/sqrt(2))/NHuber(delta))                       IF 0 <= z <= delta
    exp(delta*delta/2 - delta*z)/(delta*NHuber(delta)*sqrt(2*PI))  IF z >= delta
    NOTE : HuberErf(0) = 0.5 :
*/
static double HuberErf(register double z, register double delta)
{
  if(DEBUG/* >=2 */) assert(z >= 0.0);
  register double N = NHuber(delta);
  if(z <= delta)
    return 0.5 - 0.5*erf(z/sqrt(2.0))/N;
  return exp(delta*(delta*0.5 - z))/(delta*sqrt(2.0*M_PI)*N);
}

/** inverse of pvalue = HuberErf(z,delta) function (for 0 <= pvalue <= 0.5) :
    z = sqrt(2) * erfcInv(1 - 2 * NHuber(delta)*(0.5-pvalue))                IF z <= delta
    z = 0.5*delta - log(pvalue*delta*NHuber(delta)*sqrt(2*PI)) / delta       IF z >= delta
*/
static double HuberErfInv(register double pvalue, register double delta)
{
  if(DEBUG/*>= 2 */) assert(0 <= pvalue && pvalue <= 0.5);
  register double N = NHuber(delta);
  register double z1 = 0.5*delta - log(pvalue * delta * N * sqrt(2.0*M_PI))/delta;
  register double p2 = 1.0 - 2.0*N*(0.5-pvalue);
  register double z2 = p2 >= 0.0 ? sqrt(2.0)*erfcInv(p2) : 1.0e+100;
  if(DEBUG/* >=2 */ && (z1 > delta && z2 < delta)){
    printf("HuberErfInv(pvalue=%0.17f,delta=%0.4f):N-1=%0.17f,z1=%0.8f,z2=%0.8f,HuberErf(z1)=%0.12e,HuberErf(z2)=%0.12e\n",
	   pvalue,delta,N-1.0,z1,z2,HuberErf(z1,delta),HuberErf(z2,delta));
    fflush(stdout);
    assert(!(z1 > delta && z2 < delta));
  }

  if(z1 >= delta)
    return z1;

  if(z2 <= delta)
    return z2;

  printf("HuberErfInv(pvalue=%0.8f,delta=%0.8f):N=%0.8f,z1=%0.8f,z2=%0.8f : Formula Failed\n",
	 pvalue,delta,N,z1,z2);
  fflush(stdout);
  assert(z1 >= delta || z2 <= delta);
  return 0.0;
}

/* HuberErfInv(pvalue,delta) generalized to 0 <= pvalue <= 1 */
double Hscore(register double pvalue, register double delta)
{
  return (pvalue <= 0.5) ? HuberErfInv(pvalue,delta) : -HuberErfInv(1.0-pvalue,delta);
}

/* apply global value of SKIP_DIST to suppress some sites during add/delete by setting the corresponding skip[i] to 1 */
static void skip_sites(int n, int *skip, int *Hdel, double *Hcuts)
{
  if(!SKIP_DIST_FIX) /* first reset skip[] values from 1 to 0 */
    for(int i = 1; i <= n; i++)
      if(skip[i]==1)
	skip[i] = 0;

  if(SKIP_DIST > 0.0){
    if(SKIP_DIST_FIX) /* first reset skip[] values from 1 to 0 */
      for(int i = 1; i <= n; i++)
	if(skip[i]==1)
	  skip[i] = 0;

    double mindist = SKIP_DIST + 1e-6;

    int j = 1;
    for(; j <= n; j++)
      if(!skip[j])
	break;

    int cnt = 0, tcnt = j - 1;

    for(int i=j+1; i <= n; i++){
      if(skip[i])
	continue;

      tcnt++;

      if(!Hdel[i]){// always advance j at a real site
	if(SKIP_DIST_FIX && Hdel[j] && Hcuts[i] <= Hcuts[j] + 1e-6){
	  if(VERB>=2){
	    printf("skip_sites:skipping site %d (Hcuts[%d,%d]=%0.6f,%0.6f) as duplicate site\n",j, j, i, Hcuts[j], Hcuts[i]);
	    fflush(stdout);
	  }
	  skip[j] = 1;
	  cnt++;
	}

	j = i;
	continue;
      }

      if(SKIP_DIST_FIX && Hcuts[i] <= Hcuts[j] + 1e-6){
	if(VERB>=2){
	  printf("skip_sites:skipping site %d (Hcuts[%d,%d]=%0.6f,%0.6f) as duplicate site\n",i, j, i, Hcuts[j], Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 1;
	cnt++;
	continue;
      }

      if(i < n && Hcuts[i+1]-Hcuts[j] <= mindist){
	if(VERB>=2){
	  printf("skip_sites:skipping site %d as too close to site %d or %d (Hcuts[%d,%d,%d]=%0.6f,%0.6f,%0.6f)\n",i, j, i+1, j, i, i+1, Hcuts[j], Hcuts[i],Hcuts[i+1]);
	  fflush(stdout);
	}
	skip[i] = 1;
	cnt++;
	continue;
      }
      j = i;
    }
    if(VERB){
      printf("Suppressed %d consensus sites out of %d remaining sites (n=%d): mindist=%0.3f kb\n",cnt,tcnt,n, mindist);
      fflush(stdout);
    }
  }
}

extern int *nodeorder;/* see Assembler_graph.cpp */

/* init = 0 : initialize consensus based on picking all sites with sitecnt >= 2 (typically used when called from refalign() of RefAligner)
   init = 1 : initialize consensus using same heuristic as in Assembler_output (typically used when called from graph_components() of Assembler)
*/

static int origDELTA_Y= -1, origDELTA_X= -1, origRANGE_Y = -1, origRANGE = -1, origOutlierType = -1;
static double origOutlierLambda = -1.0, gorigPoutlier = -1.0, gorigPoutlierEnd = -1.0, origLRbias = -1.0, origSF = -1.0, origSR = -1.0, origViterbi = -1.0;

static int OldMap = 0;
static int RefineA = 0;
static int origLfrozen = 0, origRfrozen = 0;
//static int Lfrozeni=0, Rfrozeni=0;/* If > 0 : If extend >= 2 && extendonly : region of Hcuts[Lfrozeni..Rfrozeni] and Hdel[] that will NOT be modified during refinement
//				              If extend <= 1               : region outside of Hcuts[Lfrozeni..Rfrozeni] will NOT be refined during refinement */

static int Lendi = 0, Rendi = 0;/* If > 0 : extension regions Hcuts[0..Lendi] and Hcuts[Rendi .. n+1] will NOT be modified during refinement (to reduce runtime) */

/* wrapper function to refine a map that is already haplotyped */
void refineHap(Ccontig *pcontig, int **map1, int **mapK1, int **map2, int **mapK2, int& Lfrozen, int&Rfrozen)
{
  /*  SF[0] = 0.123604025;
  SD[0] = 0.0117997146;
  SR[0] = 0.0384546924;
  SE[0] = 0.246662524;*/

  //  printf("DEBUG exit\n");fflush(stdout);exit(1);

  Lendi = Rendi = 0;
  //  ZERO_MINKB = 0.001;
  if(MPROBEVAL_FIX)
    minKB = ZERO_MINKB ? ZERO_MINKB/* WAS45 0.001 * PixelLen */ : rres * 0.500;/* score_init() will now compute the same value, when called before mprobeval() */
  delete heap;/* in case it was previously allocated */
  heap = new lightweight_heap(0,0);

  int n = pcontig->numsite[0];
  double *Hcuts = pcontig->site[0];
  int *&HapSite = pcontig->HapSite[0];
  double *&HapDelta = pcontig->HapDelta[0];
  
  if(DEBUG && !(HapSite[0]==0 && HapSite[n+1] == 0)){
    printf("n=%d,HapSite[0]=%d,HapSite[n+1]=%d\n",n,HapSite[0],HapSite[n+1]);
    fflush(stdout);
    assert(HapSite[0]==0 && HapSite[n+1] == 0);
  }

  /* save parameter values that may be locally modified so they can be restored on return*/
  int startDELTA_X = DELTA_X;
  int startDELTA_Y = DELTA_Y;
  int startRANGE = RANGE;
  int startOutlierType = OutlierType;
  double startOutlierLambda = outlierLambda;
  int startPoutlierEndCnt = PoutlierEndCnt;
  
  int origPoutlierEndCnt = PoutlierEndCnt;// NEW7
  double origPoutlierRefine[16];
  double origPoutlierEndRefine[16];
  for(int i = 0; i < PoutlierEndCnt; i++){
    origPoutlierRefine[i] = PoutlierRefine[i];
    origPoutlierEndRefine[i] = PoutlierEndRefine[i];
  }

  if(MPROBEVAL < 2){
    printf("refineHap requires -Mprobeval > 0.0\n");
    exit(1);
  }
  if(!QUICKUPDATE){
    printf("refineHap does not support QUICKUPDATE==0\n");
    exit(1);
  }

  if(DEBUG) assert(FAST_RESIZE==1);

  OldMap = 0;
  RefineA = 0;

  /* save original Lfrozen,Rfrozen values before being modified based on region to be refined. Note that Lfrozen,Rfrozen are parameters passed by reference. */
  origLfrozen = Lfrozen;
  origRfrozen = Rfrozen;
  if(DEBUG) assert(Rfrozen >= Lfrozen);

  if(extend >= 2 && extendonly){
    printf("refineHap : extension only refinement not yet supported (extend=%d,extendonly=%d)\n",extend,extendonly);
    fflush(stdout);exit(1);
  }

  int MD = pcontig->nummaps;
  if(DEBUG) assert(MD >= 2);

  /* allocate and initialize setlimit() cache : will be reset whenever map[],mapK[] is updated (typically in UpdateMap()) */
  Csetlimit *limit1 = new Csetlimit[MD*2];
  Csetlimit *limit2 = &limit1[MD];
  if(SETLIMIT_CACHE)
    for(int m = 0; m < MD; m++)
      limit1[m].ileft = limit2[m].ileft = -1;

  RANGE = RefineRange;
  if(deltaXRef)
    DELTA_X = deltaXRef;
  if(deltaYRef)
    DELTA_Y = deltaYRef;
  if(outlierLambdaRef)
    outlierLambda = outlierLambdaRef;

  if(VERB){
    printf("Changing deltaX = %d -> %d, deltaY = %d -> %d, RANGE = %d -> %d, outlierLambda = %0.3e -> %0.3e\n", 
	   startDELTA_X, DELTA_X, startDELTA_Y, DELTA_Y, startRANGE, RANGE, startOutlierLambda, outlierLambda);
    fflush(stdout);
  }

  if(DEBUG) assert(deltaExtXRef >= DELTA_X);
  if(DEBUG) assert(deltaExtYRef >= DELTA_Y);

  RANGE_Y = RANGE_Y1;/* in case RANGE or RANGE_Y1 depends on command line parameters etc */

  /* save key parameter values in global space */
  origDELTA_Y = DELTA_Y;
  origDELTA_X = DELTA_X;
  origRANGE_Y = RANGE_Y;
  origRANGE = RANGE;
  origOutlierType = OutlierType;
  origOutlierLambda = outlierLambda;
  origLRbias = LRbias;
  origSF = SF[0];
  origSR = SR[0];
  origViterbi = HAP_VITERBI_WT;


  PoutlierEndRefine[0] = PoutlierEndRefine[PoutlierEndCnt-1];
  PoutlierRefine[0] = PoutlierRefine[PoutlierEndCnt-1];
  PoutlierEndCnt = 0;

  int *MX = new int[MD];
  for(int k = 0; k < MD; k++)
    MX[k] = pcontig->contig[k].numsite[0];
  double **X = pcontig->X[0];/* query maps X[k=0..MD-1][j=0..MX[k]+1] */

  if(DEBUG>=2 && !MultiMatches){/* check for duplicate maps with SAME orientation*/
    for(int m = 1; m < MD; m++){
      for(int t = 0; t < m; t++){
	if(pcontig->contig[m].mapid == pcontig->contig[t].mapid && pcontig->flip[m] == pcontig->flip[t]){
	  printf("WARNING:duplicate maps:t=%d,mapid=%d,id=%lld,flip=%d,mapWT= %0.6f; m=%d,mapid=%d,id=%lld,flip=%d,mapWT= %0.6f\n",
		 t,pcontig->contig[t].mapid,gmap[pcontig->contig[t].mapid]->id,pcontig->flip[t],pcontig->mapWT[t],
		 m,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,pcontig->flip[m],pcontig->mapWT[m]);
	  // int M1 = MX[m], M2 = MX[t], L1 = n+1,R1 = 0,L2= n+1,R2 = 0;
	  //	  for(int J = 1; J <= M1; J++)
	  fflush(stdout);
	  assert(pcontig->contig[m].mapid != pcontig->contig[t].mapid || pcontig->flip[m] != pcontig->flip[t]);
	}
      }
    }
  }

  if(OUTLIER_TYPE==0 && Poutlier > 0.0 && !(outlierLambda < 100.0)){
    if(VERB){
      printf("WARNING: refinement with OUTLIER_TYPE=%d will converge poorly without outlierLambda <= 100.0\n",OUTLIER_TYPE);
      fflush(stdout);
    }
  }

  pcontig->delXinit();

  /* allocate pcontig->outlier[0] */
  int **outlier = new int*[MD];
  for(int k = 0; k < MD; k++){
    outlier[k] = new int[MX[k]+2];/* outlier[k][j=0..MX[k]] will flag the interval X[k][j..j+1] as part of an outlier in the final qprobeval used to compute nmap,nmapK */
    for(int j = 0; j <= MX[k]+1; j++)
      outlier[k][j] = 0;
  }
  pcontig->outlier[0] = outlier;

  if(DEBUG) assert(pcontig->mapWT);

  double *TBmapWT = new double[MD];
  for(int m = 0; m < MD;m++)
    TBmapWT[m] = pcontig->mapWT[m];

  /* initialize and compute skip[] : same code as in repositionH */
  int *skip = new int[n+2];
  int skipcnt = 0;
  float *sitecnt = pcontig->sitecnt[0];
  for(int i = 0; i <= n+1; i++){
    skip[i] = (!HapSite[i] && !sitecnt[i]) ? 2 : 0;
    if(VERB>=2){
      printf("i=%d/%d:Hcuts[i]= %0.3f, HapSite[i]= %d, sitecnt[i] = %0.2f : skip[i] -> %d\n",i,n,Hcuts[i],HapSite[i],sitecnt[i],skip[i]);
      fflush(stdout);
    }
  }

  if(SKIP_DIST_FIX){// Use method in skip_sites() that can handle more than 2 coincident labels in a row
    if(1 /* HERE SKIP_DIST <= 0.0 */){/* If SKIP_DIST > 0.0, skip_sites() will take care of coincident labels, if SKIP_DIST_FIX >= 1 */
      int j = 1;
      for(; j <= n; j++)
	if(!skip[j])
	  break;

      for(int i=j+1; i <= n; i++){
	if(VERB>=3 && j >= 19900 && i <= 20050){
	  printf("j=%d,i=%d,n=%d:Hcuts[j,i]= %0.6f,%0.6f, HapSite[j,i]= %d,%d, skip[j,i]= %d,%d, Hcuts[i]-Hcuts[j]= %0.6e, (Hcuts[i] <= Hcuts[j])=%d\n",
		 j,i,n,Hcuts[j],Hcuts[i],HapSite[j],HapSite[i],skip[j],skip[i], Hcuts[i]-Hcuts[j], (Hcuts[i] <= Hcuts[j]) ? 1 : 0);
	  fflush(stdout);
	}
	if(skip[i])
	  continue;

	if(HapSite[i]){// always advance j at a real site
	  if(Hcuts[i] <= Hcuts[j] + 1e-6 && !HapSite[j]){
	    if(VERB>=2){
	      printf("refineHap:skipping site %d (Hcuts[%d,%d]=%0.4f,%0.4f) as duplicate site\n",j, j, i, Hcuts[j], Hcuts[i]);
	      fflush(stdout);
	    }
	    skip[j] = 1;
	    skipcnt++;
	  }

	  j = i;
	  continue;
	}

	if(Hcuts[i] <= Hcuts[j] + 1e-6){
	  if(VERB>=2){
	    printf("refineHap:skipping site %d (Hcuts[%d,%d]=%0.4f,%0.4f) as duplicate site\n",i, j, i, Hcuts[j], Hcuts[i]);
	    fflush(stdout);
	  }
	  skip[i] = 1;
	  skipcnt++;
	  continue;
	}

	j = i;
      }
    }

  } else {// SKIP_DIST_FIX == 0 : older algorithm, does not correctly handle 3 or more coincident labels

    for(int i = 2; i <= n; i++){
      if(DEBUG/* HERE >=2 */ && !(Hcuts[i] >= Hcuts[i-1] && (Hcuts[i] > Hcuts[i-1] || !(HapSite[i] & HapSite[i-1])))){
	printf("HaploTypeR:i=%d,n=%d:Hcuts[i-1]=%0.6f,Hcuts[i]=%0.6f,HapSite[i-1]=%d,HapSite[i]=%d\n",i,n,Hcuts[i-1],Hcuts[i],HapSite[i-1],HapSite[i]);
	fflush(stdout);
	assert(Hcuts[i] >= Hcuts[i-1] && (Hcuts[i] > Hcuts[i-1] || !(HapSite[i] & HapSite[i-1])));
      }
      if(Hcuts[i] <= Hcuts[i-1] && !skip[i] && !skip[i-1]){
	if(DEBUG) assert(!(HapSite[i] & HapSite[i-1]));
	if(!HapSite[i])
	  skip[i] = 1;
	else if(!HapSite[i-1])
	  skip[i-1] = 1;
	if(skip[i] || skip[i-1]){
	  skipcnt++;
	  if(VERB>=2){
	    printf("refineHap:skipping site %d (Hcuts[%d,%d]]=%0.4f,%0.4f) as duplicate site\n",!HapSite[i] ? i : i-1, i-1,i,Hcuts[i-1],Hcuts[i]);
	    fflush(stdout);
	  }
	}
      }
    }
  }
  if(VERB /* >=2 */){
    printf("refineHap: n=%d: skipping %d duplicate sites\n",n,skipcnt);
    fflush(stdout);
  }
  
  int *Hdel = new int[n+2];
  Hdel[0] = Hdel[n+1] = 1;
  for(int i = 1; i <= n; i++)
    Hdel[i] = HapSite[i] ? 0 : 1;
  skip_sites(n,skip,Hdel,Hcuts);

  if(extend && Refine >= 2){
    if(extend <= 1 && Rfrozen > Lfrozen){ /* permanantly block any changes to sites in the extension region */
      if(VERB)
	skipcnt = 0;
      for(int i = 0; i < Lfrozen; i++){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.3f in extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
	if(DEBUG && !Hdel[i]){
	  printf("pcontig->id=%lld:i=%d,Lfrozen=%d,Rfrozen=%d,n=%d:Hdel[i]=%d,HapSite[i]=%d,Hcuts[i]=%0.8f,Hcuts[Lfrozen]=%0.8f,Hcuts[Rfrozen]=%0.8f,Hcuts[n+1]=%0.8f\n",
		 pcontig->id,i,Lfrozen,Rfrozen,n,Hdel[i],HapSite[i],Hcuts[i],Hcuts[Lfrozen],Hcuts[Rfrozen],Hcuts[n+1]);
	  fflush(stdout);
	  assert(Hdel[i]);
	}
      }
      for(int i = Rfrozen; ++i <= n; ){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.3f in extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
	if(DEBUG) assert(Hdel[i]);
      }
      if(VERB/* >=2 */ && skipcnt){
	printf("n=%d: Blocking %d sites in extension region due to -extend %d (Lfrozen=%d,Rfrozen=%d,n=%d)\n",n,skipcnt,extend,Lfrozen,Rfrozen,n);
	fflush(stdout);
      }
    }
  }

  if(pcontig->LP)
    delete [] pcontig->LP;
  if(pcontig->logPV)
    delete [] pcontig->logPV;
  pcontig->LP = new double[MD];
  pcontig->logPV = new double[MD];

  if(VERB/* >=2*/){
    if(extend <= 1){
      printf("Initial length=%0.3f, unextended range = %0.3f ... %0.3f,n=%d\n", pcontig->right - pcontig->left, pcontig->left, pcontig->right, n);
      if(extend <= 1 && Rfrozen > 0){
	printf("    extension regions outside of Hcuts[%d..%d] = %0.3f .. %0.3f will not be modified\n",
	       Lfrozen, Rfrozen, Hcuts[Lfrozen], Hcuts[Rfrozen]);
	fflush(stdout);
	if(DEBUG) assert(Rfrozen > Lfrozen);
      }
    }
    if(VERB>=2)
       for(int i = 1; i <= n; i++)
	 printf("i=%d:Hcuts[i]=%0.3f,Hdel[i]=%d,skip[i]=%d,sitecnt[i]=%0.3f\n",i,Hcuts[i],Hdel[i],skip[i],pcontig->sitecnt[0][i]);
    fflush(stdout);
  }

  SKIP_DIST = skip_dist;
  LP_SKIP = skip_score;

  double origbiasWT = biasWT;
  double origPRbiasWT = PRbiasWT;
  double origLRbias = LRbias;
  double origPoutlierEnd = gorigPoutlierEnd = PoutlierEnd;
  double origPoutlier = gorigPoutlier = Poutlier;
  double origSite_Pen = Site_Pen;
  double origFN = FN[0];

  //  double origSF = SF[0];
  //  double origSR = SR[0];

#if 1 // NEW 4
  if(Refine>=2){
    double startPoutlierEnd = PoutlierEnd;
    double startPoutlier = Poutlier;

    gorigPoutlierEnd = PoutlierEnd = PoutlierEndRefine[0];
    gorigPoutlier = Poutlier = PoutlierRefine[0];
    if(!OUTLIERREF_FIX)
      gorigPoutlier = Poutlier = min(origPoutlier,Poutlier);

    if(VERB/* >=2*/){
      if(startPoutlierEnd != PoutlierEnd)
	printf("Changing PoutlierEnd = %0.3e -> %0.3e\n",startPoutlierEnd, PoutlierEnd);
      if(startPoutlier != Poutlier)
	printf("Changing Poutlier = %0.3e -> %0.3e\n",startPoutlier,Poutlier);
      fflush(stdout);
    }
  }    
#endif

  biasWT = biasWTrefine;
  PRbiasWT = PRbiasWTrefine;

  if((FN_Refine > 1.0 || FNmin > 0.0) && max(origFN * FN_Refine, FNmin) > FN[0]){
    if(VERB/* HERE >=2 */){
      printf("During Refinement: FN[0]= %0.6f -> %0.6f (FN_Refine=%0.6f,%0.6f,%0.6f,%0.6f)\n",FN[0], max(origFN * FN_Refine, FNmin),FN_Refine,FN_Ext,FNmin,FNminExt);
      fflush(stdout);
    }

    FN[0] = max(origFN * FN_Refine, FNmin);
  }
  if(MinSF_Refine > origSF){
    if(VERB/* HERE >=2 */){
      printf("During Refinement: SF[0]= %0.6f -> %0.6f (%0.6f during initial refinement)\n",origSF,MinSF_Refine,max(MinSF_Refine,MinSF_Ext));
      fflush(stdout);
    }
    
    SF[0] = MinSF_Refine;
  }
  if(MinSR_Refine > origSR){
    if(VERB/* HERE >=2 */){
      printf("During Refinement: SR[0]= %0.6f -> %0.6f (%0.6f during initial refinement)\n",origSR,MinSR_Refine,max(MinSR_Refine,MinSR_Ext));
      fflush(stdout);
    }
    
    SR[0] = MinSR_Refine;
  }

  if(VERB && Refine>=2 && PoutlierEndCnt <= 0){
    printf("biasWT= %0.6f\n",biasWT);
    printf("PRbiasWT= %0.6f\n",PRbiasWT);
    printf("LRbias= %0.6e\n",LRbias);
    printf("skip_dist= %0.3f\n",SKIP_DIST);
    printf("skip_score= %0.3f\n", LP_SKIP);
    printf("Site_Pen= %0.3f\n",Site_Pen);
    printf("FN[0]= %0.6f (FN_Refine=%0.6f,%0.6f,%0.6f,%0.6f)\n",FN[0],FN_Refine,FN_Ext,FNmin,FNminExt);
    printf("SF[0]= %0.6f (MinSF_Refine= %0.6f, %0.6f)\n",SF[0], MinSF_Refine, MinSF_Ext);
    printf("SR[0]= %0.6f (MinSR_Refine= %0.6f, %0.6f)\n",SR[0], MinSR_Refine, MinSR_Ext);
    printf("Poutlier= %0.3e\n",Poutlier);
    printf("PoutlierEnd= %0.3e (PoutlierEndCnt=%d)\n",PoutlierEnd, PoutlierEndCnt);
    fflush(stdout);
  }

  int N = 0;
  for(int i = 0; i <= n + 1; i++)
    N += HapSite[i] & 1;

  /* allocate mprobeval() per map results (Used in HaploTypeR() for Allele1) */
  MaxAddcnt = 0;
  NmaxLP = (N * 5)/4;
  MaxDelta = 0;
  try {
    /* allocate initial memory for newLPd[] */
    DminM = new int[MD*6];
    DmaxM = &DminM[MD];
    TminM = &DminM[MD*2];
    TmaxM = &DminM[MD*3];
    AminM = &DminM[MD*4];
    AmaxM = &DminM[MD*5];
    newLPd = new double*[MD];newLPd[0] = NULL;
    if(VMEM_MINIMIZE) newLPd0 = new double[MD]; // NEW8
    size_t siz = ((size_t)MD)*(NmaxLP + 2ul);
    if(MDEBUG){
      newLPdPr = new int*[MD];
      newLPdPr[0] = new int[siz];
      for(long long m = 1; m < MD; m++)
	newLPdPr[m] = newLPdPr[0] + m * (NmaxLP + 2ul);
    }
    if(!VMEM_MINIMIZE) {
      newLPd[0] = new double[siz];
      for(long long m = 1; m < MD; m++)
	newLPd[m] = newLPd[0] + m * (NmaxLP + 2ul);
    }
  } catch (exception& e){
    cout << e.what() << endl;
    printf("refineHap(): exception thrown while allocating newLPd[]:MaxAddcnt=%d,n=%d,NmaxLP=%d,MaxDelta=%d,MD=%d,N=%d\n",MaxAddcnt,n,NmaxLP,MaxDelta,MD,N);
    fflush(stdout);
    assert(0);
  }

  try {    /* allocate initial memory for newLPa[] */
    newLPa = new double*[MD];
    if(MDEBUG) newLPaPr = new int*[MD];
    newLPa[0] = NULL;
    if(MDEBUG) newLPaPr[0] = NULL;
  } catch (exception& e){
    cout << e.what() << endl;
    printf("refineHap(): exception thrown while allocating newLPa[]:MaxAddcnt=%d,n=%d,MaxDelta=%d,MD=%d,N=%d\n",MaxAddcnt,n,MaxDelta,MD,N);
    fflush(stdout);
    assert(0);
  }

  try {    /* allocate initial memory for newLPdelta[] */
    newLPdelta = new double*[MD];
    Dcum = new int[NmaxLP+2];
    newLPdeltaMem = 0;
  } catch (exception& e){
    cout << e.what() << endl;
    printf("refineHap(): exception thrown while allocating newLPdelta[]:MaxAddcnt=%d,n=%d,MaxDelta=%d,NmaxLP=%d,MD=%d,N=%d\n",MaxAddcnt,n,MaxDelta,NmaxLP,MD,N);
    fflush(stdout);
    assert(0);
  }

  if(VERB/* >=2 */){
    printf("Initial newLPdelta=%p..%p(MD=%d)\n",newLPdelta,&newLPdelta[MD-1],MD);
    fflush(stdout);
  }

  if(VERB/* >=2 */){
    printf("Initial MaxAddcnt=%d,n=%d,MaxDelta=%d,MD=%d,N=%d\n",MaxAddcnt,n,MaxDelta,MD,N);
    fflush(stdout);
  }

#if 0 // not needed since HaploTypeR() calls it anyway before each hprobeval and mprobeval
  score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
#endif

  /* record how much real and virtual memory we have used so far */
  getmem(VmSize, VmRSS, VmSwap);
  if(VERB){
    printf("VmSize=%lld,VmRSS=%lld, VmSwap=%lld\n",VmSize,VmRSS,VmSwap);
    fflush(stdout);
  }

  global = 0;

  if(DEBUG) assert(biasWTrefine == biasWT);
  if(DEBUG) assert(PRbiasWTrefine == PRbiasWT);
  if(DEBUG) assert(origLRbias == LRbias);
  if(DEBUG) assert(LRbias >= 0.0);
  if(DEBUG) assert(origSF == SF[0]);
  if(DEBUG) assert(origSR == SR[0]);
  if(DEBUG) assert(origViterbi == HAP_VITERBI_WT);
  if(DEBUG) assert(SKIP_DIST == skip_dist);
  if(DEBUG) assert(LP_SKIP == skip_score);
  if(DEBUG && ANNEAL_SITE_PEN) assert(Site_Pen == origSite_Pen);
  DELTA_X = origDELTA_X;
  DELTA_Y = origDELTA_Y;
  RANGE_Y = origRANGE_Y;

  pcontig->Hdel[0] = Hdel;
  
  if(DEBUG) assert(OutlierType == origOutlierType);

  double LPhap = HaploTypeR(n, Hcuts, HapSite, HapDelta, 0, 0, MD, MX, X, map1, map2, mapK1, mapK2, limit1, limit2, TBmapWT, pcontig, skip, Lfrozen, Rfrozen);
  if(VERB/* HERE >=2 */){
    printf("HaploTypeR returned LP=%0.6f\n",LPhap);
    fflush(stdout);
  }

  if(pcontig->HapSite[0] == NULL){/* HaploType refinement failed to produce separate Alleles : this should rarely happen since we started with 2 Alleles */
    if(VERB){
      printf("HaploTypeR failed to produce 2 Alleles!\n");
      fflush(stdout);
    }
    // Just use map1,mapK1 since both map1 and map2 should be the same by now
    
    if(PoutlierEnd < PoutlierEndFinal){
      if(VERB){
	printf("Before Final UpdateMap(): PoutlierEnd = %0.3e->%0.3e, RANGE_Y=%d\n", PoutlierEnd,PoutlierEndFinal,RANGE_Y2);
	fflush(stdout);
      }
      PoutlierEnd = PoutlierEndFinal;

      //      score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd, Poutlier OR biasWT*/
    }
    
    if(biasWTrefine != biasWT){
      if(VERB){
	printf("Restored biasWT= %0.6f -> %0.6f for final UpdateMap()\n",biasWT,biasWTrefine);
	fflush(stdout);
      }
      biasWT = biasWTrefine;
      //      score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd, Poutlier OR biasWT */
    }

    // NOTE : HaploTypeR[] will have updated pcontig->Hdel[0][i=1..n] to final value of !HapSite[i] IFF HaploType refinement failed 

    if(SETLIMIT_CACHE)
      for(int m = 0; m < MD; m++)
	limit1[m].ileft = -1;

    double *Y = new double[n+2];/* Consensus map Y[i=0..N+1] */
    double *mapWT = new double[MD];
    int **nmap = new int*[MD+1];
    for(int k = 0; k < MD; k++)
      nmap[k] = new int[MX[k]+2];/* nmap[k][j=0..MX[k]+1] will be the new index of site X[k][j] on Hcuts[0..n+1] (or -1 if not aligned) */
    nmap[MD] = new int[n+3];/* nmap[MD][j=0..N+1] will be index of site Y[j] in Hcuts[0..n+1], nmap[MD][-1] == -1 for convinience */
    *(nmap[MD])++ = -1;

    int **nmapK = new int*[MD];
    for(int k = 0; k < MD; k++)
      nmapK[k] = new int[MX[k]+2]; /* nmapK[k][j=0..MX[k]+1] will be the new K index offset of site X[k][j] on Hcuts[0..n+1] (only valid if nmap[k][j] >= 0) */

    double *bestLPA = new double[MD];

    //  RANGE_Y = RANGE_Y2;
    int N = setmap(n,Hcuts,Hdel,Y,map1[MD],nmap[MD]);/* compute Y[] and nmap1[MD][0..N+1] and map1[MD][0..n+1] */
    score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
    //    rverb = 1;
    double LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map1,mapK1,limit1,nmap,nmapK,TBmapWT,bestLPA,mapWT,
			  0,0.0,0.0,pcontig->logPV,pcontig->outlier[0],pcontig);
    //    rverb = 0;

    if(VERB){
      printf("Before Final UpdateMap: LP=%0.6f,N=%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f, pcontig->outlier[0]=%p,CMapID=%lld,MD=%d\n",LP,N,Y[1],Y[N],Y[N+1],pcontig->outlier[0],CMapID,MD);
      fflush(stdout);
    }

    /* merge TBmapWT[] with mapWT[] */
    for(int m = 0; m < MD; m++){
      double origPmapWT = pcontig->mapWT[m];
      if(HapMapWT >= 3)
	pcontig->mapWT[m] = 1.0;
      else if(HapMapWT >= 2)
	pcontig->mapWT[m] = mapWT[m];
      else
	pcontig->mapWT[m] = mapWT[m] * TBmapWT[m];
      if((VERB>=2 && gmap[pcontig->contig[m].mapid]->id == 1666611LL) || (DEBUG && !(isfinite(mapWT[m]) && isfinite(TBmapWT[m]) && isfinite(pcontig->mapWT[m])))){
	printf("m=%d/%d:id=%lld:TBmapWT[m] = %0.6f, mapWT[m] = %0.6f, pcontig->mapWT[m] = %0.6f -> %0.6f\n",
	       m, MD, gmap[pcontig->contig[m].mapid]->id, TBmapWT[m], mapWT[m], origPmapWT, pcontig->mapWT[m]);
	fflush(stdout);
	if(DEBUG) assert(isfinite(mapWT[m]) && isfinite(TBmapWT[m]) && !isfinite(pcontig->mapWT[m]));
      }
      mapWT[m] = pcontig->mapWT[m];
    }

    //    updateVerb = (CMapID == 15) ? 1 : 0;
    UpdateMap(n, N, Y, MD, MX, X, Hcuts, Hdel, map1, mapK1, limit1, nmap, nmapK, mapWT, pcontig, FILL_MAP);
    updateVerb = 0;

    if(DEBUG>=2){/* check that map1[m] and mapK1[m] only map to sites i with Hdel[i] == 0 */
      for(int m = 0; m < MD; m++){
	int M = MX[m];
	for(int J = 1; J <= M; J++){
	  int i = map1[m][J];
	  if(i >= 0){
	    assert(Hdel[i] == 0);
	    int k = mapK1[m][J];
	    assert(k >= 0 && i-k > 0 && Hdel[i-k] == 0);
	  }
	}
      }
    }

    /* copy map1 and mapK1 to pcontig->sitemap[0] and pcontig->sitemapL[0] */
    for(int m = 0; m < MD; m++){
      int M = MX[m];
      for(int J = 0; J <= M+1; J++){
	int I = map1[m][J];
	int K = mapK1[m][J];
	if(DEBUG && I >= 0 && !(0 <= K && K <= I && 0 <= I-K && I <= n+1)){
	  printf("m=%d:M=%d,J=%d,I=%d,K=%d\n",m,M,J,I,K);
	  fflush(stdout);
	  assert(0 <= K && K <= I);
	  assert(0 <= I-K && I <= n+1);
	}
	pcontig->sitemap[0][m][J] = I;
	pcontig->sitemapL[0][m][J] = K;
      }
    }

    delete [] bestLPA;
    for(int k = 0; k < MD; k++){
      delete [] nmap[k];
      delete [] nmapK[k];
    }
    delete [] nmapK;
    delete [] &nmap[MD][-1];
    delete [] nmap;

    delete [] mapWT;
    delete [] Y;

    PoutlierEnd = origPoutlierEnd;
    score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd & Poutlier or biasWT */
  }

  if(VERB>=2){
    printf("MD=%d, pcontig->nummaps=%d\n",MD,pcontig->nummaps);
    fflush(stdout);
  }

  /* convert pcontig->sitemapL[][] into absolute values rather than offsets from pcontig->sitemap[i=0..MD-1][] */
  for(int m = 0; m < MD; m++){
    int M = pcontig->contig[m].numsite[0];
    if(DEBUG) assert(M == MX[m]);
    for(int J = 0; J <= M+1; J++){
      int I = pcontig->sitemap[0][m][J];
      int K = pcontig->sitemapL[0][m][J];
      if(I < 0){
	pcontig->sitemapL[0][m][J] = -1;
	continue;
      }
      if(DEBUG && !(0 <= K && K <= I && 0 <= I-K && I <= n+1)){
	printf("m=%d:M=%d,J=%d,I=%d,K=%d,n=%d\n",m,M,J,I,K,n);
	fflush(stdout);
	assert(0 <= K && K <= I);
	assert(0 <= I-K && I <= n+1);
      }
      pcontig->sitemapL[0][m][J] = I - K;
    }
  }

  /* free all memory */
  delete [] DminM;
  DminM = DmaxM = TminM = TmaxM = AminM = AmaxM = 0;

  delete [] Dcum;
  delete [] newLPdelta;
  //  delete [] newLPdeltaMem;
  if(newLPdeltaMem){
    free(newLPdeltaMem);
    newLPdeltaMem = 0;
  }
  MaxDelta = 0;

  if(VMEM_MINIMIZE){
    DoubleAllocations_free();

    std::vector<double *>().swap(DoubleAllocations);
    std::vector<CdoubleAllocation *>().swap(SwappedAllocations);
  }

  if(!VMEM_MINIMIZE){
    if(MDEBUG && newLPaPr[0]) { delete [] newLPaPr[0]; newLPaPr[0] = 0;}
    if(newLPa[0]) { free(newLPa[0]); newLPa[0] = 0;}
  }

  if(MDEBUG) delete [] newLPaPr;
  delete [] newLPa;
  MaxAddcnt = 0;

  if(!VMEM_MINIMIZE){// NEW8
    if(MDEBUG) delete [] newLPdPr[0];
    delete [] newLPd[0];
  }
  if(MDEBUG) delete [] newLPdPr;
  delete [] newLPd;
  newLPd = NULL;
  delete [] newLPd0;// NEW8
  newLPd0 = NULL;

  delete [] skip;
  delete [] TBmapWT;
  score_free();

  delete [] MX;

  delete heap;
  heap = NULL;

  delete [] limit1;
  //  delete [] limit2;

  pcontig->delXfree();

  biasWT = origbiasWT;
  PRbiasWT = origPRbiasWT;
  LRbias = origLRbias;
  Poutlier = origPoutlier;
  PoutlierEnd = origPoutlierEnd;
  FN[0] = origFN;
  SF[0] = origSF;
  SR[0] = origSR;
  origViterbi = HAP_VITERBI_WT;
  
  PoutlierEndCnt = origPoutlierEndCnt;// NEW7
  for(int i = 0; i < PoutlierEndCnt; i++){
    PoutlierRefine[i] = origPoutlierRefine[i];
    PoutlierEndRefine[i] = origPoutlierEndRefine[i];
  }

  DELTA_X = startDELTA_X;
  DELTA_Y = startDELTA_Y;
  RANGE = startRANGE;
  outlierLambda = startOutlierLambda;
  OutlierType = startOutlierType;
  PoutlierEndCnt = startPoutlierEndCnt;


  return;
}

/* Correct map[] by removing mappings to labels Hcuts[i] that are no longer present (map[MD][i] == -1).
   These are typically labels that were removed since the last call to cleanmap(), or were present when refine() was called, reflecting locations of unaligned labels.
   
*/
static void cleanmap(int n, 
		     int MD, /* number of maps */
		     int *MX, /* MX[m] is number of sites of map m */
		     int **map, /* map[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts1[0..n+1] of X[m][j], 
				    map[MD][j=0..n+1] is index in Y[0..N+1] of Hcuts[j] */
		     int **mapK, /* mapK[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts[0..n+1] of X[m][j] */ 
		     int numthreads
		     )
{
  int LoopCnt = 0;

  int block = 1;
  while(block < 16 && MD > numthreads * block)
    block *= 2;

  #pragma omp parallel num_threads(numthreads) if(numthreads>1)
  {
    int myLoopCnt = 0;
    #pragma omp for schedule(static,block)
    for(int m = 0; m < MD; m++){
      if(OMP_DEBUG) myLoopCnt++;
      int M = MX[m];

      /* Correct map[m][J],mapK[m][J] to remove mappings to labels Hcuts[i] that are no longer present (map[MD][i] == -1) */
      int lasti = -1;// NEW4
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	int k = mapK[m][J];
	if(DEBUG) assert(0 <= k && k < i);
	k = i - k;
	while(i > k && i > lasti+1/*NEW4*/ && map[MD][i] < 0)
	  i--;
	if(map[MD][i] < 0){/* remove mapping of label J */
	  map[m][J] = -1;
	  continue;
	}
	while(k < i && (map[MD][k] < 0 || k <= lasti))
	  k++;
	if(DEBUG) assert(map[MD][k] >= 0);
	if(k <= lasti){// NEW4 : fix error by unmapping J : not clear how this happened */
	  map[m][J] = -1;
	  continue;
	}

	map[m][J] = i;
	mapK[m][J] = i-k;

	lasti = i;
      }
    }
    if(OMP_DEBUG && myLoopCnt > 0){
      #pragma omp critical
      {
        LoopCnt += myLoopCnt;
      }
    }
  }
  if(OMP_DEBUG) assert(LoopCnt == MD);  
}

 int stage = 0;/* for debugging */

/** Main refinement function.
    - If init==1 : Perform signal processing on Ccontig.site to identify new sites (init == 1 IFF called from Assembler for refinement A)
    - Use aligned maps to edit the current Ccontig.
    - Test edit likelihood with qprobeval() before and after changes.
    - Call AddDelete() and SizesEstimate() to update sites and interval sizes respectively */
void refine(Ccontig *pcontig, int init, int& Lfrozen, int& Rfrozen)
{
  int origRefine = Refine;
  //  Refine = 1;

  printf("At start of refine(): Refine=%d,init=%d, Lfrozen=%d, Rfrozen=%d\n",Refine,init,Lfrozen,Rfrozen);
  printf("RefineStep= %0.4f %0.4f %0.4f %0.4f %0.4f %0.4f, RefineStepCnt= %d, RefineFix= %d\n",
      RefineStep1,RefineStep2,RefineStep3,RefineStep4,RefineStep5,RefineStep6,RefineStepCnt,RefineFix);
  fflush(stdout);
  //  exit(1);

  START(refine);
  Lendi = Rendi = 0;

  if(init)
   rres = max(rres, 0.001);

  //  ZERO_MINKB =  init ? 0.0 : 0.001;// use commandline parameter -ZERO_MINKB
  if(MPROBEVAL_FIX)
    minKB = ZERO_MINKB ? ZERO_MINKB /* WAS45 0.001 * PixelLen */ : rres * 0.500;/* score_init() will now compute the same value, when called before mprobeval() */

  delete heap;/* in case it was previously allocated */
  heap = new lightweight_heap(0,0);

  int n = pcontig->numsite[0];
  double *Hcuts = pcontig->site[0];/* all sites Hcuts[i=0..n+1] */

  if(VERB/* HERE HERE >=2*/){
    printf("refine:Lfrozen=%d,Rfrozen=%d,n=%d,Hcuts[Lfrozen,Rfrozen,n+1]= %0.3f,%0.3f,%0.3f:PoutlierEndCnt=%d\n",Lfrozen,Rfrozen,n,Hcuts[Lfrozen],Hcuts[Rfrozen],Hcuts[n+1],PoutlierEndCnt);
    fflush(stdout);
  }

#if 0 // debug floating point expf approxation in use
  int steps = 8600000;
  float delta = 86.0f;
  delta /= steps;
  double maxerr = 0.0;
  float maxf = 0.0;
  for(int i = 0; i < steps; i++){
    float f = i * delta;
    float e1 = expF(f);
    double e2 = exp(f);
    double err = fabs(e1/e2 - 1.0);
    if(err > 1e-5){
      printf("f= %0.8f : expF(f)= %0.8e, exp(f)= %0.8e : err = %0.8f (maxerr = %0.8f)\n",	     f, e1,e2,err,maxerr);
      fflush(stdout);
    }
    if(err > maxerr){
      maxerr = err;
      maxf = f;
    }
    
    if(f != 0){
      f = -f;
      float e1 = expF(f);
      double e2 = exp(f);
      double err = fabs(e1/e2 - 1.0);
      if(err > 1e-5){
	printf("f= %0.8f : expF(f)= %0.8e, exp(f)= %0.8e : err = %0.8f (maxerr = %0.8f)\n",	     f, e1,e2,err,maxerr);
	fflush(stdout);
      }
      if(err > maxerr){
	maxerr = err;
	maxf = f;
      }
    }
  }
  printf("Tested expF over -86.96 to 86.96 at intervals of %0.5f : maxerr = %0.3e at f= %0.8f\n", delta, maxerr, maxf);
  fflush(stdout);

  exit(1);
#endif

  /* save parameter values that may be locally modified so they can be restored on return*/
  int startRefine = Refine;// NEW7

  int startDELTA_X = DELTA_X;
  int startDELTA_Y = DELTA_Y;
  int startRANGE = RANGE;
  int startOutlierType = OutlierType;
  double startOutlierLambda = outlierLambda;
  int startPoutlierEndCnt = PoutlierEndCnt;
  
  int origPoutlierEndCnt = PoutlierEndCnt;// NEW7
  double origPoutlierRefine[16];
  double origPoutlierEndRefine[16];
  for(int i = 0; i < PoutlierEndCnt; i++){
    origPoutlierRefine[i] = PoutlierRefine[i];
    origPoutlierEndRefine[i] = PoutlierEndRefine[i];
  }

  if(MPROBEVAL < 2){
    printf("refine() requires -Mprobeval > 0.0\n");
    exit(1);
  }
  if(!QUICKUPDATE){
    printf("refine() no longer supports QUICKUPDATE==0\n");
    exit(1);
  }

  if(DEBUG) assert(FAST_RESIZE==1);

  OldMap = 1; /* WAS (init == 1 ? 1 : 0) */ // prefer using map[] over nmap[] in first call to SizesEstimate(), until first successful UpdateMap
  RefineA = (init == 1 ? 1 : 0);

  /* save original Lfrozen,Rfrozen values before being modified based on region to be refined. Note that Lfrozen,Rfrozen are parameters passed by reference. */
  origLfrozen = Lfrozen;
  origRfrozen = Rfrozen;
  if(DEBUG) assert(Rfrozen >= Lfrozen);

  if(extend >= 2 && extendonly && EndLen > 0.0){
    // moved Lfrozen..Rfrozen adjustment code to refalign.cpp before calling refine(), so we can support -extsplit extensions of only one side of a contig
    if(Rfrozen <= Lfrozen){
      if(VERB && Refine && extendonly){
	printf("Entire original contig will be refined:origLfrozen=%d(%0.3f),origRfrozen=%d(%0.3f),Lfrozen=%d(%0.3f),Rfrozen=%d(%0.3f)\n",
	       origLfrozen,Hcuts[origLfrozen],origRfrozen,Hcuts[origRfrozen],Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[Rfrozen]);
	fflush(stdout);
      }
    }
  }

  /* export Lfrozen,Rfrozen as globals so SizesEstimate() has access to these values (blocks any sizes changes in this region Hcuts[Lfrozen..Rfrozen] IF extendonly && Rfrozen > Lfrozen) */
  //  Lfrozeni = Lfrozen;
  //  Rfrozeni = Rfrozen;
  // NOTE : Lfrozen,Rfrozen are now passed as args to SizesEstimate() since they may be increased during initial refinement and decreased during final refinement 

  int *Hdel = new int[n+2];/* Hdel[i=0..n+1] : 1 IFF Hcuts[i] is currently deleted (classified as false positive) */
  float *sitecnt = pcontig->sitecnt[0];

  int MD = pcontig->nummaps;

  if(!pcontig->mapWT){
    pcontig->mapWT = new double[MD];
    for(int m = 0; m < MD; m++)
      pcontig->mapWT[m] = 1.0;
  }
  
  /* compute initial consensus map by classifying which sites in Hcuts[0..n+1] are to be deleted */
  if(init == 1){/* use heuristic from Assembler_output */
    double *smoothcnt = new double[n+2];
    register double reskb = max(minKB, res[0] * PixelLen);
    register double sd = draftSD * reskb;
    register double W = 6.0*sd;/* window half width */
    register double Ivar = 1.0/(2.0*sd*sd);
    
    if(DEBUG) assert(reskb > 0.0);
    if(DEBUG) assert(sd > 0.0);

    smoothcnt[0] = smoothcnt[n+1] = 0.0;
    register int left = 1, right = 1;/* left and right end of window */
    for(register int i = 1; i <= n; i++){
      /* move ahead left end of window until it is W to the left of Hcuts[i] */
      while(Hcuts[left] < Hcuts[i] - W)
	left++;

      /* move ahead right end of window until it is W to the right of Hcuts[i] */
      while(right <= n && Hcuts[right] < Hcuts[i] + W)
	right++;
    
      /* now smooth over window left ... right-1 */
      register double sum = 0.0;
      for(register int k = left; k < right; k++){
	register double err = Hcuts[i] - Hcuts[k];
	sum += sitecnt[k] * exp(-err*err*Ivar);
      }
      smoothcnt[i] = sum;
    }

    /* locate local peaks in smoothcnt[1..n] */
    register int *peak = new int[n+2];
    peak[0] = peak[n+1] = 0;
    for(register int i = 1; i <= n; i++){
      /* scan forward to first site that differs */
      for(right = i+1; right <= n+1;right++){
	if(Hcuts[right] - Hcuts[i] > sd)
	  break;
	if(fabs(smoothcnt[right] - smoothcnt[i]) >= 0.0001)
	  break;
      }
      /*scan backward to first site that differs */
      for(left = i; --left >= 0; ){
	if(Hcuts[i] - Hcuts[left] > sd)
	  break;
	if(fabs(smoothcnt[left] - smoothcnt[i]) >= 0.0001)
	  break;
      }

      if(left < 0 || right > n+1 || smoothcnt[i] <= 0.0)
	peak[i] = 0;
      else
	peak[i] = ((Hcuts[right] - Hcuts[i] > sd || smoothcnt[i] > smoothcnt[right]) && 
		   (Hcuts[i] - Hcuts[left] > sd || smoothcnt[i] > smoothcnt[left])) ? 1 : 0;
    }

    /* remove peaks that are within res of a larger peak */
    for(register int i = 1; i <= n; i++){
      if(peak[i]){
	/* scan left */
	for(register int k = i; --k >= 1;){
	  if(Hcuts[i] - Hcuts[k] > reskb)
	    break;
	  if(peak[k] && smoothcnt[k] > smoothcnt[i]){
	    peak[i] = -1;
	    break;
	  }
	}
	if(peak[i] < 0)
	  continue;
	/* scan right */
	for(register int k = i; ++k <= n; ){
	  if(Hcuts[k] - Hcuts[i] > reskb)
	    break;
	  if(peak[k] && smoothcnt[k] >= smoothcnt[i]){/* priority to the rightmost peak with the same value */
	    peak[i] = -1;
	    break;
	  }
	}
      }
    }
  
    if(VERB>=2){
      printf("n=%d,res=%0.3f,sd=%0.3f:\n",n,reskb,sd);
      register int k;
      for(k = 1; k <= n; k++)
	if(VERB>=2 || sitecnt[k] > 0.001)
	  printf("k=%d:site[k]=%0.3f,sitecnt[k]=%0.1f,fragcnt[k-1]=%0.1f,smoothcnt[k]=%0.4f,peak[k]=%d%c\n",
		 k,Hcuts[k],pcontig->sitecnt[0][k],pcontig->fragcnt[0][k-1],smoothcnt[k],peak[k],(peak[k]>0 && smoothcnt[k] > pcontig->fragcnt[0][k-1]*draftTP) ? '!':' ');
      printf("k=%d:site[k]=%0.3f,fragcnt[k-1]=%0.1f\n",
	     k,Hcuts[k],pcontig->fragcnt[0][k-1]);
      fflush(stdout);
    }

    for(register int i=0;i <= n+1; i++){
      Hdel[i] = (peak[i]>0 && smoothcnt[i] > pcontig->fragcnt[0][i-1]*draftTP) ? 0 : 1;
      if(DEBUG && i>0 && Hcuts[i] <= Hcuts[i-1])
	assert(Hdel[i-1] || Hdel[i]);
    }

    if(VERB>=2){    /* determinate what fraction of labels on molecule align with a consensus label (Hdel[i] == 0) */
      double totcnt = 0.0, TPcnt = 0.0;
      for(int m = 0; m < MD; m++){
	int M = pcontig->contig[m].numsite[0];
	double wt = pcontig->mapWT[m];
	int *mapM = pcontig->sitemap[0][m];

	for(int J = 1; J <= M; J++){
	  int i = mapM[J];
	  if(i <= 0)
	    continue;
	  totcnt += wt;
	  if(!Hdel[i])
	    TPcnt += wt;
	}
      }
      printf("LabelCnt = %0.1f, TPcnt = %0.1f : FP= %0.1f%%\n",	     totcnt, TPcnt, (totcnt - TPcnt) * 100.0 / max(1.0, totcnt));
      fflush(stdout);
    }

    if(SITEMAP_ADJUST > 0.0 ){    /* adjust pcontig->sitemap[0][m] for labels mapped to Hdel[i]==1 if there is another nearby label k with Hdel[k]==0 provided |Hcuts[i] - Hcuts[k]| <= SITE_ADJUST * sd */
      double msd = SITEMAP_ADJUST * sd;
      double totcnt = 0.0, TPcnt = 0.0;
      for(int m = 0; m < MD; m++){
	int M = pcontig->contig[m].numsite[0];
	double wt = pcontig->mapWT[m];
	int *mapM = pcontig->sitemap[0][m];

	for(int J = 1; J <= M; J++){
	  int i = mapM[J];
	  if(i <= 0)
	    continue;
	  totcnt += wt;
	  if(!Hdel[i])
	    TPcnt += wt;
	  else {/* check if there is nearby label k with Hdel[k]==0 */
	    double LB = Hcuts[i] - msd, UB = Hcuts[i] + msd;
	    int L = i-1, R = i+1;
	    int iLB = (J==1) ? 1 : mapM[J-1] + 1;
	    int iUB = (J==M) ? n : mapM[J+1] - 1;

	    while((iLB <= L && LB <= Hcuts[L]) || (R <= iUB && Hcuts[R] <= UB)){
	      if(L < iLB){
		if(Hdel[R]==0){
		  if(DEBUG) assert(R <= iUB);
		  mapM[J] = R;
		  break;
		}
		R++;
		continue;
	      }
	      if(R >= iUB){
		if(Hdel[L]==0){
		  if(DEBUG) assert(iLB <= L);
		  mapM[J] = L;
		  break;
		}
		L--;
		continue;
	      }
	      if(Hcuts[i] - Hcuts[L] < Hcuts[R] - Hcuts[i]){
		if(Hdel[L]==0){
		  if(DEBUG) assert(iLB <= L);
		  mapM[J] = L;
		  break;
		}
		L--;
		continue;
	      } else {
		if(Hdel[R]==0){
		  if(DEBUG) assert(R <= iUB);
		  mapM[J] = R;
		  break;
		}
		R++;
		continue;
	      }
	    }
	    i = mapM[J];
	    if(!Hdel[i])
	      TPcnt += wt;
	  }
	}
      }
      if(VERB){
	printf("After adjust sitemap[]: LabelCnt = %0.1f, TPcnt = %0.1f : FP= %0.1f%%\n",	     totcnt, TPcnt, (totcnt - TPcnt) * 100.0 / max(1.0, totcnt));
	fflush(stdout);
      }
    }

    if(DEBUG) assert(Hdel[0]==1 && Hdel[n+1]==1);
    delete [] peak;
    delete [] smoothcnt;
  } else if(init==0){/* initialize Hdel[i] = (sitecnt[i] >= 2 ? 0 : 1) */

    Hdel[0] = Hdel[n+1] = 1;
    for(register int i=1; i <= n; i++){
      Hdel[i] = (sitecnt[i] >= 1.9999f ? 0 : 1);
      if(DEBUG && !(Hcuts[i] >= Hcuts[i-1])){
	printf("i=%d,n=%d:Hcuts[i-1,i] = %0.9f, %0.9f, sitecnt[i-1,i]= %0.4f, %0.4f\n",i,n,Hcuts[i-1],Hcuts[i], sitecnt[i-1], sitecnt[i]);
	fflush(stdout);
	assert(Hcuts[i] >= Hcuts[i-1]);
      }
      if(DEBUG && Hcuts[i] <= Hcuts[i-1])
	assert(Hdel[i-1] || Hdel[i]);
    }
    if(VERB>=2){
      printf("Initial consensus map:n=%d\n",n);
      for(register int i=0; i <= n+1; i++)
	printf("i=%d:Hcuts[i]=%0.6f,Hdel[i]=%d\n",i,Hcuts[i],Hdel[i]);
      fflush(stdout);
    }

    // NOTE : use splitFiltFN,splitFiltFP instead if extendSplitFN,extendSplitFP if splitFiltFP,FP >= 0
    int SplitFN = (splitFiltFN >= 0 ? splitFiltFN : extendSplitFN);
    int SplitFP = (splitFiltFP >= 0 ? splitFiltFP : extendSplitFP);
    double FNlen = (splitFiltFNlen > 0.0 ? splitFiltFNlen : extendSplitFNlen);// NEW52
    if(extTrim && Refine>=2 && extendonly && extendSplit && (SplitFN + SplitFP > 0 || FNlen > 0.0)){
      if(pcontig->MaskL & (END_NOEXT | END_NOEXT2)){
	if(DEBUG) assert(Hcuts[Lfrozen] <= 0.0);
	int cnt = 0, icenter = 0;
	for(int i = n; i > Rfrozen/* NEW98 */; i--){
	  if(Hdel[i])
	    continue;

	  if(cnt == SplitFP)
	    icenter = i;

	  if(cnt >= SplitFN + SplitFP && Hcuts[icenter] - Hcuts[i] > FNlen)
	    break;

	  cnt++;
	  Hdel[i] = 1;
	  if(VERB/* HERE HERE >=2 */){
	    printf("Trimming back Hcuts[%d] = %0.3f : cnt=%d, SplitFN=%d, SplitFP=%d,FNlen= %0.3f\n",i,Hcuts[i],cnt,SplitFN,SplitFP, FNlen);
	    fflush(stdout);
	  }
	}
      }

      if(pcontig->MaskR & (END_NOEXT | END_NOEXT2)){
	if(DEBUG) assert(Hcuts[Rfrozen] >= Hcuts[n+1]);
	int cnt = 0, icenter = 0;
	for(int i = 1; i < Lfrozen/* NEW98 */; i++){
	  if(Hdel[i])
	    continue;

	  if(cnt == SplitFP)
	    icenter = i;

	  if(cnt >= SplitFN + SplitFP && Hcuts[i] - Hcuts[icenter] > FNlen)
	    break;
	  
	  cnt++;
	  Hdel[i] = 1;
	  if(VERB/* HERE HERE >=2 */){
	    printf("Trimming back Hcuts[%d] = %0.3f : cnt=%d, extendSplitFN=%d, extendSplitFP=%d\n",i,Hcuts[i],cnt,extendSplitFN,extendSplitFP);
	    fflush(stdout);
	  }
	}
      }
    }

  } else {
    printf("refine(): init=%d value not supported\n",init);
    exit(1);
  }

  if(DEBUG) assert(MD >= 2 || Refine <= 1);
  if(MD < 2 && (Refine >= 2 /* || MD <= 0 *//* NEW70 */)){/* refinement is not possible with less than 2 maps, (Is this really needed with MD==1 ?), unless there is 1 map and Refine == 1 */
    printf("WARNING: refinement not possible with less than 2 maps (number of maps=%d)\n",MD);

    /* generate fake coverage profile */
    int cutcnt= 0;
    pcontig->fragcnt[0][0] = 2;
    for(register int i=1;i<=n;i++){
      pcontig->sitecntFN[0][i] = 2;
      pcontig->fragcnt[0][i] = (Refine <= 1 ? MD : 2);// NEW70
      if(Hdel[i]){/* false cut */
	pcontig->sitecnt[0][i] = 0;
      } else {/* true cut */
	if(pcontig->sitecnt[0][i] <= 0)
	  pcontig->sitecnt[0][i] = 1;
	cutcnt++;
      }
    }
    printf("consensus map unchanged with N=%d,length=%0.3f\n",cutcnt,Hcuts[n+1]);
    fflush(stdout);

    pcontig->Hdel[0] = Hdel;
    STOP(refine);
    
    Refine = origRefine;
    return;
  }

  RANGE = RefineRange;
  if(deltaXRef)
    DELTA_X = deltaXRef;
  if(deltaYRef)
    DELTA_Y = deltaYRef;
  if(outlierLambdaRef)
    outlierLambda = outlierLambdaRef;

  if(VERB){
    printf("Changing deltaX = %d -> %d, deltaY = %d -> %d, RANGE = %d -> %d, outlierLambda = %0.3e -> %0.3e\n", 
	   startDELTA_X, DELTA_X, startDELTA_Y, DELTA_Y, startRANGE, RANGE, startOutlierLambda, outlierLambda);
    fflush(stdout);
  }
  if(DEBUG) assert(deltaExtXRef >= DELTA_X);
  if(DEBUG) assert(deltaExtYRef >= DELTA_Y);

  RANGE_Y = RANGE_Y1;/* in case RANGE or RANGE_Y1 depends on command line parameters etc */

  /* save key parameter values in global space */
  origDELTA_Y = DELTA_Y;
  origDELTA_X = DELTA_X;
  origRANGE_Y = RANGE_Y;
  origRANGE = RANGE;
  origOutlierType = OutlierType;
  origOutlierLambda = outlierLambda;
  origLRbias = LRbias;
  origSF = SF[0];
  origSR = SR[0];
  origViterbi = HAP_VITERBI_WT;

  int *MX = new int[MD];
  for(int k = 0; k < MD; k++)
    MX[k] = pcontig->contig[k].numsite[0];
  double **X = pcontig->X[0];/* query maps X[k=0..MD-1][j=0..MX[k]+1] */
  
  if(DEBUG){
    for(int i=1; i <= n; i++){
      if(DEBUG && !(sitecnt[i] >= 0.0f && sitecnt[i] <= max(2,MD) + 1e-6f)){
	printf("i=%d,n=%d:sitecnt[i]=%0.2f,MD=%d\n",
	       i,n,sitecnt[i],MD);
	fflush(stdout);
	assert(sitecnt[i] >= 0.0f && sitecnt[i] <= max(2,MD) + 1e-6f);
      }
    }
  }

  pcontig->delXinit();

  if(OUTLIER_TYPE==0 && Poutlier > 0.0 && !(outlierLambda < 100.0)){
    if(VERB){
      printf("WARNING: refinement with OUTLIER_TYPE=%d will converge poorly without outlierLambda <= 100.0\n",OUTLIER_TYPE);
      fflush(stdout);
    }
  }

  // need to update sitecnt[] based on pcontig->sitemap[0][m = 0..MD-1][j=0..MX[m]+1] since original sitecnt[] does not reflect deleted maps due to -MaxCov
  float *origsitecnt = sitecnt;
  if(SITECNT_FIX){
    origsitecnt = new float[n+1];
    memcpy(origsitecnt,sitecnt,(n+1)*sizeof(float));
    memset(sitecnt, 0, (n+1)*sizeof(float)); 
  }

  double *Y = new double[n+2];/* Consensus map Y[i=0..N+1] */

  int **map = new int*[MD+1];
  for(int m = 0; m < MD; m++){
    map[m] = pcontig->sitemap[0][m];/* map[m][j=0..MX[m]+1] is location of site X[m][j] on Hcuts[0..n+1] (or -1 if not aligned) */
    if(DEBUG){
      assert(map[m][0] <= 0 || origsitecnt[map[m][0]] == 0);
      if(!(map[m][1] == -1 || (map[m][1] >= 1 && map[m][1] <= n))){
	printf("m=%d,MD=%d:numsite=%d,n=%d,map[m][1]=%d,MX[m]=%d,init=%d\n",m,MD,pcontig->numsite[0],n,pcontig->sitemap[0][m][1],MX[m],init);
	for(int j = 0; j <= MX[m]+1; j++)
	  printf("  j=%d:map[m][j]=%d, origsitecnt=%0.1f\n",j,map[m][j], origsitecnt[map[m][j]]);

	fflush(stdout);
	assert(map[m][1] == -1 || (map[m][1] >= 1 && map[m][1] <= n));
      }
      for(int J = 2; J <= MX[m]; J++){
	if(DEBUG && !(map[m][J] == -1 || (map[m][J] > map[m][J-1] && map[m][J] <= n))){
	  printf("m=%d(id=%lld),MD=%d:J=%d,MX[m]=%d:map[m][J]=%d,map[m][J-1]=%d,n=%d,X[m][J]=%0.4f,X[m][J-1]=%0.4f,X[m][M+1]=%0.4f\n",
		 m,gmap[pcontig->contig[m].mapid]->id,MD,J,MX[m],map[m][J],map[m][J-1],n,X[m][J],X[m][J-1],X[m][MX[m]+1]);
	  fflush(stdout);
	  assert(map[m][J] == -1 || (map[m][J] > map[m][J-1] && map[m][J] <= n));
	}
      }
      if(DEBUG && !(map[m][MX[m]+1] == -1 || map[m][MX[m]+1] == n+1 || origsitecnt[map[m][MX[m]+1]] == 0)){
	printf("m=%d,MD=%d:MX[m]=%d:map[m][MX[m]+1]=%d,origsitecnt[%d]=%0.1f,n=%d\n",
	       m,MD,MX[m],map[m][MX[m]+1],map[m][MX[m]+1],origsitecnt[map[m][MX[m]+1]],n);
	fflush(stdout);
	assert(map[m][MX[m]+1] == -1 || map[m][MX[m]+1] == n+1 || origsitecnt[map[m][MX[m]+1]] == 0);
      }
    }
    if(VERB>=2){
      int i;
      printf("m=%d/%d:mapid=%d(id=%lld):MD=%d:n=%d\n",
	     m,MD,pcontig->contig[m].mapid, gmap[pcontig->contig[m].mapid]->id,MX[m],n);
      for(int J = 1; J <= MX[m]; J++)
	if((i = map[m][J]) >= 0)
	  printf("   J=%d:Hcuts[%d]=%0.3f,X[%d]=%0.3f, Hdel=%d,origsitecnt=%0.1f\n",
		 J,i,Hcuts[i], J, X[m][J], Hdel[i],origsitecnt[i]);
      fflush(stdout);
    }
    if(SITECNT_FIX){
      for(int J = 1; J <= MX[m]; J++){
	int i = map[m][J];
	if(i >= 0){
	  if(DEBUG) assert(i <= n);
	  sitecnt[i] += 1.0f;
	  if(VERB>=3){
	    printf("m=%d:J=%d/%d,map[m][J]=i=%d,sitecnt[i]= %0.2f\n",m,J,MX[m],i,sitecnt[i]);
	    fflush(stdout);
	  }
	}
      }
      for(int i = 1; i <= n; i++)
	if(origsitecnt[i] >= 1.999f)
	  sitecnt[i] = max(origsitecnt[i],sitecnt[i]);
    }
  }
  if(SITECNT_FIX){
    if(DEBUG>=2){
      for(int i = 1; i <= n; i++){
	if(VERB>=2){
	  printf("i=%d/%d:Hcuts[i]=%0.3f:origsitecnt[i]= %0.3f, sitecnt[i]= %0.3f\n",i, n, Hcuts[i], origsitecnt[i], sitecnt[i]);
	  fflush(stdout);
	}
	if(origsitecnt[i] >= 1.999f)
	  assert(sitecnt[i] >= 1.999f);
	else {
	  assert(sitecnt[i] <= origsitecnt[i]);
	}
      }
    }
    delete [] origsitecnt;
    origsitecnt = NULL;
  }

  map[MD] = new int[n+3];/* map[MD][j=0..n+1] will be location of site Hcuts[j] in Y[0..N+1] (or -1 if not aligned), map[MD][-1] == -1 for convenience */
  *(map[MD])++ = -1;

  int **mapK = new int*[MD];  
  for(int k = 0; k < MD; k++){
    mapK[k] = new int[MX[k]+3];
    *mapK[k]++ = -1;
    for(int j=0; j <= MX[k]+1; j++)
      mapK[k][j] = 0; /* mapK[k][j=0..MX[k]+1] is the K index offset of site X[k][j] on Hcuts[0..n+1] (only valid if map[k][j] >= 0) */
  }

  int **outlier = new int*[MD];
  for(int k = 0; k < MD; k++){
    outlier[k] = new int[MX[k]+2];/* outlier[k][j=0..MX[k]] will flag the interval X[k][j..j+1] as part of an outlier in the final qprobeval used to compute nmap,nmapK */
    for(int j = 0; j <= MX[k]+1; j++)
      outlier[k][j] = 0;
  }
  pcontig->outlier[0] = outlier;

  int **nmap = new int*[MD+1];
  for(int k = 0; k < MD; k++)
    nmap[k] = new int[MX[k]+2];/* nmap[k][j=0..MX[k]+1] will be the new index of site X[k][j] on Hcuts[0..n+1] (or -1 if not aligned) */
  nmap[MD] = new int[n+3];/* nmap[MD][j=0..N+1] will be index of site Y[j] in Hcuts[0..n+1], nmap[MD][-1] == -1 for convinience */
  *(nmap[MD])++ = -1;
  int **nmapK = new int*[MD];
  for(int k = 0; k < MD; k++)
    nmapK[k] = new int[MX[k]+2]; /* nmapK[k][j=0..MX[k]+1] will be the new K index offset of site X[k][j] on Hcuts[0..n+1] (only valid if nmap[k][j] >= 0) */

  double *bestLPA = new double[MD];
  double *newLPA = new double[MD];
  double *mapWT = new double[MD];
  double *TBmapWT = new double[MD];
  for(int m = 0; m < MD;m++){
    TBmapWT[m] = pcontig->mapWT[m];
    if(VERB>=2 || (DEBUG && !isfinite(TBmapWT[m]))){
      printf("m=%d/%d:TBmapWT[m]= %0.6e\n",m, MD, TBmapWT[m]);
      fflush(stdout);
      assert(isfinite(TBmapWT[m]));
    }
  }

  /* allocate and initialize setlimit() cache : will be reset whenever map[],mapK[] is updated (typically in UpdateMap()) */
  Csetlimit *limit = new Csetlimit[MD];
  if(SETLIMIT_CACHE)
    for(int m = 0; m < MD; m++)
      limit[m].ileft = -1;

  int N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      int lastJ = -1, lasti = -1, lastk = -1;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
	  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	  fflush(stdout);
	  assert(0 <= k && k < i);
	}
	if(lasti >= 0 && !(i-k > lasti)){
	  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	  if(VERB){
	    for(int j = 1; j <= M; j++){
	      int i = map[m][j];
	      if(i < 0)
		continue;
	      int k = mapK[m][j];
	      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	    }
	  }
	  fflush(stdout);
	  assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }
  }

  if(1){/* NEW306 : make sure minKB is no larger than smallest interval in Y[1..N] */
    for(int I = 1; I < N; I++){
      if(Y[I+1]-Y[I] < minKB){
	if(VERB){
	  printf("Refine:I=%d,Y[I+1]-Y[I]= %0.6f : reducing minKB= %0.6f to %0.6f\n",
		 I,Y[I+1]-Y[I],minKB,Y[I+1]-Y[I]);
	  fflush(stdout);
	}
	minKB = Y[I+1] - Y[I];
	if(ZERO_MINKB)
	  ZERO_MINKB = minKB;
	else 
	  rres = 2.0 * minKB;
      }
    }
  }

  if(VERB>=3){
    printf("At start of refine N=%d:\n",N);
    for(int I = 1; I <= N; I++)
      printf("I=%d/%d:Y[I]=%0.4f,Y[I+1]-Y[I]=%0.4f\n",I,N,Y[I],Y[I+1]-Y[I]);
    fflush(stdout);
  }

  /* make sure no real cuts are closer than minKB */
  for(int I = 1; I < N; I++){
    if(VERB>=2){
      printf("Initial Y[I=%d]=%0.6f,minKB=%0.6f\n",I,Y[I],minKB);
      fflush(stdout);
    }
    if(Y[I+1]-Y[I] < minKB){
      if(VERB>=2){
	printf("Initial Y[I=%d]=%0.6f,Y[I+1]=%0.6f,delta=%0.6f:minKB=%0.6f:removing Y[I+1],N=%d->%d\n",
	       I,Y[I],Y[I+1],Y[I+1]-Y[I],minKB,N,N-1);
	fflush(stdout);
      }
      int i = nmap[MD][I+1];
      if(DEBUG) assert(i >= 1 && i <= n);
      if(DEBUG) assert(!Hdel[i]);
      Hdel[i] = 1;
      I--;
      N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
    }
  }

  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      int lastJ = -1, lasti = -1, lastk = -1, cnt = 0;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	cnt++;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
	  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	  fflush(stdout);
	  assert(0 <= k && k < i);
	}
	if(lasti >= 0 && !(i-k > lasti)){
	  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	  if(VERB){
	    for(int j = 1; j <= M; j++){
	      int i = map[m][j];
	      if(i < 0)
		continue;
	      int k = mapK[m][j];
	      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	    }
	  }
	  fflush(stdout);
	  assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }

      if(VERB>=2 && cnt <= 0){
	printf("WARNING in refine(init=%d): No aligned sites in initial map[m][] for m=%d(id=%lld)\n",init,m, gmap[pcontig->contig[m].mapid]->id);
	fflush(stdout);
      }
    }
  }

  int numthreads = 1;
  #ifdef _OPENMP
  numthreads = MaxThreads; // WAS omp_get_max_threads();
  if(RefineThreads > 0)
    numthreads = min(numthreads,RefineThreads);
  if(DEBUG) assert(numthreads >= 1);
  #endif

  if(!FILL_MAP)
    cleanmap(n,MD,MX,map,mapK,numthreads);

  double Lend= -1.0, Rend= -1.0;/* used if (extend && extendonly && EndTrimCov > 0.0) */

  if(extend){/* check that EXTEND is large enough AND initialize Lendi,Rendi */
    if(VERB>=2){
      printf("Extend=%d,EXTEND=%d\n",Extend,EXTEND);
      fflush(stdout);
    }

    double *leftend = new double[MD*2];
    double *rightend = &leftend[MD];

    for(int m = 0; m < MD; m++){
      int M = MX[m];
      leftend[m] = pcontig->right;
      rightend[m] = pcontig->left;

      /* locate leftmost aligned site */
      int i,I;
      for(int J = 1; J <= M; J++){
	if((i=map[m][J]) >= 1 && (I = map[MD][i]) >= 1){
	  if(VERB>=3 && gmap[pcontig->contig[m].mapid]->id == 1492840LL){
	    printf("m=%d(id=%lld):left most alignment at X[m][J=%d]=%0.3f with Hcuts[i=%d]=%0.3f\n",
		   m,gmap[pcontig->contig[m].mapid]->id,J,X[m][J],i,Hcuts[i]);
	    fflush(stdout);
	  }
	  leftend[m] = Y[I] - X[m][J];
	  if(J - I > Extend){
	    int origExtend = Extend;
	    Extend = J-I;
	    if(Extend > EXTEND){
	      if(PoutlierEnd <= 0.0 && PoutlierEndCnt <= 0){
		printf("WARNING: m=%d(id=%lld) extends too far to the left : Increase EXTEND in refine.h to %d or more or use -endoutlier OR -endoutlierRef\n",
		       m,gmap[pcontig->contig[m].mapid]->id,J-I);
		printf("  Using -endoutlier 1e-100\n");
		fflush(stdout);
		PoutlierEnd = 1e-100;
	      }
	      Extend = min(Extend,EXTEND);
	    }
	    if(VERB>=2){
	      printf("m=%d(id=%lld):left most alignment at X[m][J=%d]=%0.3f with Y[I=%d]=%0.3f: Increasing Extend from %d to %d\n",
		     m,gmap[pcontig->contig[m].mapid]->id,J,X[m][J],I,Y[I],origExtend,Extend);
	      fflush(stdout);
	    }
	  }
	  break;
	}
      }

      /* locate rightmost aligned site */
      for(int J = M; J >= 1; J--){
	if((i=map[m][J]) >= 1 && (I = map[MD][i]) >= 1){
	  rightend[m] = Y[I] + X[m][M+1] - X[m][J];
	  if((M-J) - (N-I) > Extend){
	    int origExtend = Extend;
	    Extend = (M-J) - (N-I);
	    if(Extend > EXTEND){
	      if(PoutlierEnd <= 0.0 && PoutlierEndCnt <= 0){
		printf("WARNING: m=%d(id=%lld) extends too far to the right : Increase EXTEND in refine.h to %d or more or use -endoutlierRef\n",
		       m,gmap[pcontig->contig[m].mapid]->id,(M-J)-(N-I));
		printf("  Using -endoutlier 1e-100\n");
		fflush(stdout);
		PoutlierEnd = 1e-100;
	      }
	      Extend = min(Extend,EXTEND);
	    }
	    if(VERB>=2){
	      printf("m=%d(id=%lld): right most alignment at X[m][J=%d]= %0.3f with Y[I=%d]= %0.3f : Increasing Extend from %d to %d\n",
		     m,gmap[pcontig->contig[m].mapid]->id,J,X[m][J],I,Y[I],origExtend,Extend);
	      fflush(stdout);
	    }
	  }
	  break;
	}
      }
    }
    
    if(extend >= 2 /* WAS extend && extendonly */ && EndTrimCov > 0.0){/* compute Lend, Rend (will determine Lendi,Rendi later) */
      qsort(leftend, MD, sizeof(double), (intcmp*)doubleInc);
      qsort(rightend,MD, sizeof(double), (intcmp*)doubleDec);

      int EndTrimCovI = ceil(EndTrimCov);
      
      Lend = min(pcontig->left/* WAS7 Y[1] */,leftend[min(MD,EndTrimCovI)-1]);
      Rend = max(pcontig->right/* WAS7 Y[N] */,rightend[min(MD,EndTrimCovI)-1]);
      Lend = max(0.0, Lend - 50.0);
      Rend = min(Hcuts[n+1], Rend + 50.0);

      if(MaxExtend > 0.0){
	Lend = max(Lend, pcontig->left/* WAS7 Y[1] */ - MaxExtend);
	Rend = min(Rend, pcontig->right/* WAS7 Y[N] */ + MaxExtend);
      }

      if(Rfrozen > 0){
	Lend = min(Lend, Hcuts[Lfrozen]);
	Rend = max(Rend, Hcuts[Rfrozen]);
      }

      if(VERB/* HERE HERE >=2 */){
	printf("Setting Lend,Rend due to -EndTrim %0.2f -maxExtend %0.3f (Lend=%0.3f,Rend=%0.3f,n=%d,Hcuts[n+1]=%0.3f,Y[1]=%0.3f,Y[N]=%0.3f,left=%0.3f,right=%0.3f)\n",
	       EndTrimCov,MaxExtend,Lend,Rend,n,Hcuts[n+1],Y[1],Y[N],pcontig->left,pcontig->right);
	if(VERB>=2){
	  for(int i = 0; i <= EndTrimCovI; i++)
	    printf("leftend[%d]= %0.3f\n", i,leftend[i]);
	  for(int i = 0; i <= EndTrimCovI; i++)
	    printf("rightend[%d]= %0.3f\n", i,rightend[i]);
	}

	if(extendSplit && Rfrozen > 0)
	  printf("\t extendSplit=%0.2f: Hcuts[Lfrozen=%d]= %0.3f, Hcuts[Rfrozen=%d]= %0.3f\n",extendSplit, Lfrozen, Hcuts[Lfrozen], Rfrozen, Hcuts[Rfrozen]);
	
	fflush(stdout);
      }
    }

    delete [] leftend;
  }

  /* initialize set of sites Hcuts[i] that are almost certainly false positives and don't need to be checked for adding to consensus */
  int *skip = new int[n+2];
  int skipcnt = 0, skipcnt2 = 0;
  skip[0] = skip[n+1] = 0;
  for(int i = 1; i <= n; i++) {
    skip[i] = (Hdel[i] && (!sitecnt[i] /*|| (sitecnt[i] < 2 && smoothcnt[i] < 2.0)*/)) ? 2 : 0; /* map ends, no sites present */    
    skipcnt2 += (skip[i] ? 1 : 0);
    if(VERB>=2 && skip[i]){
      printf("refine:skipping site %d (%0.3f) as map end\n",i,Hcuts[i]);
      fflush(stdout);
    }
  }

  if(SKIP_DIST_FIX){// Use method in skip_sites() that can handle more than 2 coincident labels in a row
    if(1){/* If SKIP_DIST > 0.0, skip_sites() will take care of coincident labels, if SKIP_DIST_FIX >= 1 */
      int j = 1;
      for(; j <= n; j++)
	if(!skip[j])
	  break;

      for(int i=j+1; i <= n; i++){
	if(skip[i])
	  continue;

	if(!Hdel[i]){// always advance j at a real site
	  if(Hcuts[i] <= Hcuts[j] + 1e-6 && Hdel[j]){
            if(VERB>=2){
	      printf("refine:skipping site %d (Hcuts[%d,%d]=%0.6f,%0.6f) as duplicate site\n",j, j, i, Hcuts[j], Hcuts[i]);
	      fflush(stdout);
	    }
	    skip[j] = 1;
	    skipcnt++;
	  }

	  j = i;
	  continue;
	}

	if(Hcuts[i] <= Hcuts[j] + 1e-6){
	  if(VERB>=2){
	    printf("refine:skipping site %d (Hcuts[%d,%d]=%0.4f,%0.4f) as duplicate site\n",i, j, i, Hcuts[j], Hcuts[i]);
	    fflush(stdout);
	  }
	  skip[i] = 1;
	  skipcnt++;
	  continue;
        }

	j = i;
      }
    }
    
  } else {// SKIP_DIST_FIX == 0 : older algorithm, does not correctly handle 3 or more coincident labels

    for(int i=2;i<=n;i++){
      if(Hcuts[i] <= Hcuts[i-1] && !skip[i] && !skip[i-1]){
	if(DEBUG) assert(Hdel[i] || Hdel[i-1]);
	if(Hdel[i])
	  skip[i] = 1;
	else
	  skip[i-1] = 1;
	skipcnt++;
	if(VERB>=2){
	  printf("refine:skipping site %d (%0.3f,%0.3f) as duplicate site\n",Hdel[i] ? i : i-1, Hcuts[i-1],Hcuts[i]);
	  fflush(stdout);
	}
      }
    }
  }
  if(VERB /* >=2 */){
    printf("n=%d: skipping %d duplicate sites and %d sites with no support\n",n,skipcnt,skipcnt2);
    fflush(stdout);
  }
  skip[0] = skip[n+1] = 0;

  if((RefineEndOutlierThreshold < 2 && RefineEndOutlierWt == 0.0) || (extendonly && Refine >= 3)){/* suppress adding sites from maps with TBmapWT <= 0.0 (suppressed with -Erefine N 0.0 or -refine 3) */
    skipcnt = 0;
    for(int m = 0; m < MD; m++){
      int M = MX[m],i;
      if(TBmapWT[m] > 0.0){
	if(VERB>=3){
	  for(int J = 1; J <= M; J++)
	    if((i = map[m][J]) >= 1)
	      printf("%s Hcuts[%d]= %0.3f from map m=%d(id=%lld),J=%d,M=%d:TBmapWT=%0.6f\n",skip[i] ? "Skipping" : "Keeping", i,Hcuts[i],m,gmap[pcontig->contig[m].mapid]->id,J,M,TBmapWT[m]);

	  fflush(stdout);
	}
	continue;
      }
      
      for(int J = 1; J <= M; J++)
	if((i = map[m][J]) >= 1 && sitecnt[i] == 1){
	  if(DEBUG) assert(Hdel[i]);
	  if(VERB>=2 && !skip[i]){
	    printf("Blocking Hcuts[%d]= %0.3f due to map m=%d(id=%lld) being suppressed by -Erefine %d 0.0\n",i,Hcuts[i], m, gmap[pcontig->contig[m].mapid]->id, RefineEndOutlierThreshold);
	    fflush(stdout);
	  }
	  skip[i] = 2;
	  skipcnt++;
	}
    }
    if(VERB){
      printf("n=%d: Blocking %d sites due to maps supressed with -Erefine %d 0.0 OR -extendonly -refine 3\n",n, skipcnt, RefineEndOutlierThreshold);
      fflush(stdout);
    }
  }

  if(extend >= 2 /* WAS extend && extendonly  */ && EndTrimCov > 0.0 && MaxExtend > 0.0){/* compute Lendi, Rendi */
    for(Lendi = 0; Lendi < n; Lendi++)
      if(Hcuts[Lendi] > Lend)
	break;
    if(Lendi > 0)
      Lendi--;
    while(Lendi > 0 && skip[Lendi] >= 2)
      Lendi--;

    for(Rendi = n+1; Rendi > 0; Rendi--)
      if(Hcuts[Rendi] < Rend)
	break;
    if(Rendi <= n)
      Rendi++;
    while(Rendi <= n && skip[Rendi] >= 2)
      Rendi++;

    if(VERB/* HERE HERE >=2 */){
      printf("Setting Lendi=%d(%0.3f),Rendi=%d(%0.3f) due to -EndTrim %0.2f -maxExtend %0.3f (Lend=%0.3f,Rend=%0.3f,n=%d,Hcuts[n+1]=%0.3f,Y[1]=%0.3f,Y[N]=%0.3f)\n",
	     Lendi,Hcuts[Lendi],Rendi,Hcuts[Rendi],EndTrimCov,MaxExtend,Lend,Rend,n,Hcuts[n+1],Y[1],Y[N]);
      fflush(stdout);
    }
    if(DEBUG) assert(Rendi > 0 && Rendi > Lendi);
    
    if(extendonly && Lendi >= Lfrozen && Rendi <= Rfrozen && Refine >= 2){/* NEW7 : no region left to optimize */
      printf("Setting Lendi=%d(%0.3f),Rendi=%d(%0.3f) due to -EndTrim %0.2f -maxExtend %0.3f (Lend=%0.3f,Rend=%0.3f,n=%d,Hcuts[n+1]=%0.3f,Y[1]=%0.3f,Y[N]=%0.3f)\n",
	     Lendi,Hcuts[Lendi],Rendi,Hcuts[Rendi],EndTrimCov,MaxExtend,Lend,Rend,n,Hcuts[n+1],Y[1],Y[N]);
      printf("No region left to modify : Changing -refine %d to -refine 1\n",Refine);
      fflush(stdout);

      Refine = 1;
    }
  }

  if(VERB/* HERE HERE >=2 */){
    printf("extend=%d,extendonly=%d,Refine=%d,Lfrozen=%d,Rfrozen=%d,Hcuts[Lfrozen,Rfrozen]=%0.3f,%0.3f,Lendi=%d,Rendi=%d\n",
	   extend,extendonly,Refine,Lfrozen,Rfrozen,Hcuts[Lfrozen],Hcuts[Rfrozen],Lendi,Rendi);
    if(VERB>=2)
      for(int i = Lfrozen; i <= Rfrozen; i++)
	printf("i=%d:Hcuts[i]= %0.4f, Hdel[i]=%d\n",i,Hcuts[i],Hdel[i]);
    fflush(stdout);
  }

  if(extend && Refine >= 2){
    if(extendonly){
      if(Rfrozen > Lfrozen){/* permanantly block any changes to sites in the non-extension region */
	if(DEBUG) assert(extend >= 2);
	int L = Lfrozen,R = Rfrozen;
	if(VERB)
	  skipcnt = 0;
#if 0 // WAS excluding regions outside the first and last site in this region ???
	for(; L < Rfrozen;L++)
	  if(!Hdel[L])
	    break;
	for(; R > L;R--)
	  if(!Hdel[R])
	    break;
#endif
	for(int i = L; i <= R; i++){
	  if(VERB)
	    skipcnt += (skip[i] ? 0 : 1);
	  if(VERB>=2 && !skip[i]){
	    printf(" Blocking Hcuts[%d]=%0.3f in non-extension region\n",i,Hcuts[i]);
	    fflush(stdout);
	  }
	  skip[i] = 2;
	}
	if(VERB/* >=2 */ && skipcnt){
	  printf("n=%d: Blocked %d sites in non-extension region due to -extonly (Lfrozen=%d,%0.3f, Rfrozen=%d,%0.3f)\n",n,skipcnt,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[Rfrozen]);
	  fflush(stdout);
	}
      }
      if(Rendi > Lendi){/* permanantly block any changes to sites outside of Hcuts[Lendi .. Rendi] */
	int origskipcnt = skipcnt;
	for(int i = 0; i < Lendi; i++){
	  if(VERB)
	    skipcnt += (skip[i] ? 0 : 1);
	  if(VERB>=2 && !skip[i]){
	    printf(" Blocking Hcuts[%d]=%0.3f in left extension region due to -EndTrim %0.2f -maxExtend %0.3f\n",i,Hcuts[i],EndTrimCov,MaxExtend);
	    fflush(stdout);
	  }
	  skip[i] = 2;
	  if(DEBUG) assert(Hdel[i]);
	}
	for(int i = Rendi; ++i <= n; ){
	  if(VERB)
	    skipcnt += (skip[i] ? 0 : 1);
	  if(VERB>=2 && !skip[i]){
	    printf(" Blocking Hcuts[%d]=%0.3f in right extension region due to -EndTrim %0.2f -maxExtend %0.3f\n",i,Hcuts[i],EndTrimCov,MaxExtend);
	    fflush(stdout);
	  }
	  skip[i] = 2;
	  if(DEBUG) assert(Hdel[i]);
	}
	if(VERB/* >=2 */ && skipcnt > origskipcnt){
	  printf("n=%d: Blocking %d sites in extension region due to -EndTrim %0.2f -maxExtend %0.3f\n",n,skipcnt-origskipcnt,EndTrimCov,MaxExtend);
	  fflush(stdout);
	}
      }
    }
    if(extend <= 1 && Rfrozen > Lfrozen){ /* permanantly block any changes to sites in the extension region */
      if(VERB)
	skipcnt = 0;
      for(int i = 0; i < Lfrozen; i++){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.3f in extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
	if(DEBUG) assert(Hdel[i]);
      }
      for(int i = Rfrozen; ++i <= n; ){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.3f in extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
	if(DEBUG) assert(Hdel[i]);
      }
      if(VERB/* >=2 */ && skipcnt){
	printf("n=%d: Blocking %d sites in extension region due to -extend %d (Lfrozen=%d(%0.3f),Rfrozen=%d(%0.3f),n=%d)\n",n,skipcnt,extend,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[Rfrozen],n);
	fflush(stdout);
      }
    }
  }
  if(NODELETE)/* block deleting initially existing sites (used for debugging only) */
    for(register int i = 1; i <= n; i++)
      if(!Hdel[i])
	skip[i] = 2;

  if(VERB>=2){
    for(int i = 1; i <= n; i++)
      if(skip[i])
	printf("i=%d:skip[i]=%d,Hdel[i]=%d,Hcuts[i]=%0.3f\n",i,skip[i],Hdel[i],Hcuts[i]);
    fflush(stdout);
  }

  if(VERB>=2){
    printf("Original potential add sites:\n");
    for(int m = 0; m < MD; m++){
      int M = MX[m],i;
      for(int J = 1; J <= M; J++)
	if((i = map[m][J]) >= 1 && Hdel[i])
	  printf("%s Hcuts[%d]= %0.3f from map m=%d(id=%lld),J=%d,M=%d\n",skip[i] ? "Skipping" : "Keeping", i,Hcuts[i],m,gmap[pcontig->contig[m].mapid]->id,J,M);
    }
    fflush(stdout);
  }

  if(pcontig->LP)
    delete [] pcontig->LP;
  if(pcontig->logPV)
    delete [] pcontig->logPV;
  pcontig->LP = new double[MD];
  pcontig->logPV = new double[MD];
  if(pcontig->sitemapL[0]){
    for(int m = 0; m < MD; m++)
      if(pcontig->sitemapL[0][m])
	delete [] &pcontig->sitemapL[0][m][-1];
    delete [] pcontig->sitemapL[0];
  }
  pcontig->sitemapL[0] = mapK;

  if(VERB/* >=2*/){
    if(extend){
      if(Refine && extendonly && Rfrozen > Lfrozen)
	printf("Initial length=%0.3f, unextended range = %0.3f ... %0.3f (Hcuts[%d..%d] = %0.3f .. %0.3f will not be modified) n=%d,N=%d\n", 
	       Y[N+1], pcontig->left, pcontig->right, Lfrozen, Rfrozen, Hcuts[Lfrozen], Hcuts[Rfrozen], n, N);
      else
	printf("Initial length=%0.3f, unextended range = %0.3f ... %0.3f,n=%d,N=%d\n", Y[N+1], pcontig->left, pcontig->right, n, N);
      if(extend <= 1 && Rfrozen > 0){
	printf("    extension regions outside of Hcuts[%d..%d] = %0.3f .. %0.3f will not be modified\n",
	       Lfrozen, Rfrozen, Hcuts[Lfrozen], Hcuts[Rfrozen]);
	fflush(stdout);
	if(DEBUG) assert(Rfrozen > Lfrozen);
      }
      if(extend >= 2 /* WAS extendonly */ && Rendi > 0){
	printf("    extension regions outside of Hcuts[%d..%d] = %0.3f .. %0.3f will not be modified (due to -EndTrim %0.2f and/or -maxExtend %0.2f)\n",
	       Lendi, Rendi, Hcuts[Lendi], Hcuts[Rendi], EndTrimCov, MaxExtend);
	fflush(stdout);
	if(DEBUG) assert(Rendi > Lendi);
      }
    }
    if(VERB>=2)
       for(int i = 1; i <= n; i++)
	 printf("i=%d:Hcuts[i]=%0.3f,Hdel[i]=%d,skip[i]=%d,sitecnt[i]=%0.3f\n",i,Hcuts[i],Hdel[i],skip[i],pcontig->sitecnt[0][i]);
    fflush(stdout);
  }

  SKIP_DIST = skip_dist;
  LP_SKIP = skip_score;

  double origbiasWT = biasWT;
  double origPRbiasWT = PRbiasWT;
  double origLRbias = LRbias;
  double origPoutlierEnd = gorigPoutlierEnd = PoutlierEnd;/* NOTE : this value is not used during refinement if PoutlierEndCnt > 0 */
  double origPoutlier = gorigPoutlier = Poutlier;/* NOTE : this value is not used during refinement if PoutlierEndCnt > 0 */
  double origSite_Pen = Site_Pen;
  double origFN = FN[0];

  //  double origSF = SF[0];
  //  double origSR = SR[0];

  biasWT = biasWTrefine;
  PRbiasWT = PRbiasWTrefine;

  if((FN_Refine > 1.0 || FNmin > 0.0) && max(origFN*FN_Refine, FNmin) > FN[0]){
    if(VERB/* HERE >=2 */){
      printf("During Refinement: FN[0]= %0.6f -> %0.6f (FN_Refine=%0.6f,%0.6f,%0.6f,%0.6f)\n",FN[0], max(origFN * FN_Refine,  FNmin), FN_Refine, FN_Ext, FNmin, FNminExt);
      fflush(stdout);
    }

    FN[0] = max(origFN*FN_Refine, FNmin);
  }
  if(MinSF_Refine > origSF){
    if(VERB/* HERE >=2 */){
      printf("During Refinement: SF[0]= %0.6f -> %0.6f (%0.6f during initial refinement)\n",origSF,MinSF_Refine,max(MinSF_Refine,MinSF_Ext));
      fflush(stdout);
    }
    
    SF[0] = MinSF_Refine;
  }
  if(MinSR_Refine > origSR){
    if(VERB/* HERE >=2 */){
      printf("During Refinement: SR[0]= %0.6f -> %0.6f (%0.6f during initial refinement)\n",origSR,MinSR_Refine,max(MinSR_Refine,MinSR_Ext));
      fflush(stdout);
    }
    
    SR[0] = MinSR_Refine;
  }

  if(VERB && Refine>=2 /* HERE && PoutlierEndCnt <= 0 */){
    printf("biasWT= %0.6f\n",biasWT);
    printf("PRbiasWT= %0.6f\n",PRbiasWT);
    printf("LRbias= %0.6e\n",LRbias);
    printf("SKIP_DIST= %0.3f\n",SKIP_DIST);
    printf("LP_SKIP= %0.4e\n", LP_SKIP);
    printf("Site_Pen= %0.3f\n",Site_Pen);
    printf("FN[0]= %0.6f (FN_Refine=%0.6f,%0.6f,%0.6f,%0.6f)\n",FN[0],FN_Refine,FN_Ext,FNmin,FNminExt);
    printf("SF[0]= %0.6f (MinSF_Refine= %0.6f, %0.6f)\n",SF[0], MinSF_Refine, MinSF_Ext);
    printf("SR[0]= %0.6f (MinSR_Refine= %0.6f, %0.6f)\n",SR[0], MinSR_Refine, MinSR_Ext);
    printf("Poutlier= %0.3e\n",Poutlier);
    printf("PoutlierEnd= %0.3e\n",PoutlierEnd);
    printf("\t Lfrozen=%d(%0.3f),Rfrozen=%d(%0.3f),n=%d(%0.3f)\n",Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[Rfrozen],n,Hcuts[n]);
    fflush(stdout);
  }
  double restoreFN = FN[0];
  double restoreSF = SF[0];
  double restoreSR = SR[0];

  /* adjust parameters for initial refinement */
  if(Refine >= 2 && PoutlierEndCnt > 0 && !(extend <= 1 && PoutlierEndCnt <= 1) && (HapSitePvalue <= 0.0 || !refineDefer)){
    //LRbias = max(1.0e-300, PoutlierEndRefine[0]*PoutlierEndRefine[0]);// NOTE : this may be dangerous, since it enlarges the LP jump when RANGE_Y is changed
    if(origLRbias > max(1e-300,PoutlierEndRefine[0])){
      LRbias = max(1e-300, PoutlierEndRefine[0]);
      if(VERB){
	printf("Changing LRbias=%0.6e -> %0.6e (during -endoutlierRef initial refinement)\n",origLRbias,LRbias);
	fflush(stdout);
      }
    }
    if(biasWT > 0.0 && biasWTrefineType < 2){
      biasWT = 0.0;
      if(VERB){
	printf("Changing biasWT=%0.6f -> 0 (during -endoutlierRef initial refinement)\n", biasWTrefine);
	fflush(stdout);
      }
    }
    
    if(SKIP_DIST < skip_dist_Ext){
      SKIP_DIST = skip_dist_Ext;
      if(VERB){
	printf("Changing SKIP_DIST=%0.3f -> %0.3f (during -endoutlierRef initial refinement)\n", skip_dist,SKIP_DIST);
	fflush(stdout);
      }
    }

    if(LP_SKIP > skip_score_Ext){
      LP_SKIP = skip_score_Ext;
      if(VERB){
	printf("Changing LP_SKIP=%0.4e -> %0.4e (during -endoutlierRef initial refinement)\n", skip_score,LP_SKIP);
	fflush(stdout);
      }
    }

    if(ANNEAL_SITE_PEN && Site_Pen > Site_Pen_Ext){
      if(VERB){
	printf("Changing Site_Pen=%0.3f -> %0.3f (during -endoutlierRef initial refinement)\n", Site_Pen, Site_Pen_Ext);
	fflush(stdout);
      }
      Site_Pen = Site_Pen_Ext;
    }
    if((FN_Ext/* NEW57 */ > 1.0 || FNminExt > 0.0) && max(FN_Ext*origFN, FNminExt) > FN[0]){
      if(VERB){
	printf("Changing FN[0]=%0.6f -> %0.6f (during -endoutlierRef initial refinement)\n", FN[0], max(FN_Ext*origFN, FNminExt));
	fflush(stdout);
      }
      FN[0] = max(FN_Ext*origFN, FNminExt);
    }
    if(MinSF_Ext > SF[0]){
      if(VERB){
	printf("Changing SF[0]= %0.6f -> %0.6f (during -endoutlierRef initial refinement)\n", SF[0], MinSF_Ext);
	fflush(stdout);
      }
      SF[0] = MinSF_Ext;
    }
    if(MinSR_Ext > SR[0]){
      if(VERB){
	printf("Changing SR[0]= %0.6f -> %0.6f (during -endoutlierRef initial refinement)\n", SR[0], MinSR_Ext);
	fflush(stdout);
      }
      SR[0] = MinSR_Ext;
    }

    if(extend >= 2 && extendonly && EndLen2 < EndLen){
      if(DEBUG>=1+RELEASE) assert(Rfrozen >= Lfrozen);
      if(Rfrozen > Lfrozen){/* expand frozen range to include all of unextended range (minus EndLen2 at each end) */
	if(!(pcontig->MaskL & (END_NOEXT | END_NOEXT2)))
	  while(Lfrozen > 2 && Hcuts[Lfrozen-1] >= pcontig->Y1 + EndLen2 /* WAS105 pcontig->left + EndLen2 + Y[1] */)
	    Lfrozen--;

	if(!(pcontig->MaskR & (END_NOEXT | END_NOEXT2)))
	  while(Rfrozen < n-1 && Hcuts[Rfrozen+1] <= pcontig->YN - EndLen2 /* WAS105 pcontig->right - (EndLen2 + Y[N+1]-Y[N])*/)
	    Rfrozen++;

	if(DEBUG) assert(Lfrozen < Rfrozen);
      } else {/*  set Hcuts[Lfrozen .. Rfrozen] to correspond to pcontig->Y1 + EndLen2 .. pcontig->YN - EndLen2 */
	if(!(pcontig->MaskL & (END_NOEXT | END_NOEXT2))){
	  Lfrozen = 1;
	  while(Lfrozen < Rfrozen && Hcuts[Lfrozen] < pcontig->Y1 + EndLen2 /* WAS105 pcontig->left + EndLen2 + Y[1] */)
	    Lfrozen++;
	}

	if(!(pcontig->MaskR & (END_NOEXT | END_NOEXT2))){
	  Rfrozen = n;
	  while(Lfrozen < Rfrozen && Hcuts[Rfrozen] > pcontig->YN - EndLen2 /* WAS105 pcontig->right - (EndLen2 + Y[N+1]-Y[N]) */)
	    Rfrozen--;
	}
      }
      if(VERB){
	printf("Hcuts[%d..%d] = %0.3f .. %0.3f will not be modified during -endoutlierRef initial refinement\n",Lfrozen,Rfrozen,Hcuts[Lfrozen],Hcuts[Rfrozen]);
	if(VERB/* HERE >=2 */)
	  printf("\t pcontig->left= %0.3f(Y1=%0.3f), pcontig->right= %0.3f(YN=%0.3f), EndLen2= %0.3f, Lfrozen=%d(%0.3f), Rfrozen=%d(%0.3f), n=%d\n",
		 pcontig->left,pcontig->Y1,pcontig->right,pcontig->YN,EndLen2,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[Rfrozen],n);
	fflush(stdout);
      }
      if(DEBUG) assert(Lfrozen <= Rfrozen);
    }
  }  

  skip_sites(n,skip,Hdel,Hcuts);

  if(VERB>=2){
    if(PoutlierEndCnt > 0)
      printf("Refine=%d,PoutlierEndCnt=%d,PoutlierEndRefine= %0.3e .. %0.3e, PoutlierRefine= %0.3e .. %0.3e, Poutlier=%0.3e,PoutlierEnd=%0.3e\n",
	     Refine,PoutlierEndCnt,PoutlierEndRefine[0],PoutlierEndRefine[PoutlierEndCnt-1], PoutlierRefine[0],PoutlierRefine[PoutlierEndCnt-1],Poutlier,PoutlierEnd);
    else
      printf("Refine=%d,PoutlierEndCnt=%d\n",   Refine,PoutlierEndCnt);
    printf("\t Lfrozen=%d,Rfrozen=%d\n",Lfrozen,Rfrozen);
    fflush(stdout);
  }
  int PoutlierEndIndex = 0;
  if(Refine>=2 && PoutlierEndCnt > 0){ /* set PoutlierEnd to PoutlierEndRefine[0] */
    double startPoutlierEnd = PoutlierEnd;
    double startPoutlier = Poutlier;
    gorigPoutlierEnd = PoutlierEnd = PoutlierEndRefine[0];
    gorigPoutlier = Poutlier = PoutlierRefine[0];
    if(!OUTLIERREF_FIX)
      gorigPoutlier = Poutlier = min(origPoutlier,Poutlier);
    if(VERB/* >=2*/){
      if(startPoutlierEnd != PoutlierEnd)
	printf("Changing PoutlierEnd = %0.3e -> %0.3e\n",startPoutlierEnd, PoutlierEnd);
      if(startPoutlier != Poutlier)
	printf("Changing Poutlier = %0.3e -> %0.3e\n",startPoutlier,Poutlier);
      fflush(stdout);
    }

    PoutlierEndIndex = 1;

  } else {
    if(VERB){
      printf("Changing PoutlierEndCnt = %d -> 0\n",PoutlierEndCnt);
      fflush(stdout);
    }
    PoutlierEndIndex = PoutlierEndCnt = 0;
    PoutlierEndRefine[0] = PoutlierEnd;
    PoutlierRefine[0] = Poutlier;
  }

  /* allocate mprobeval() per map results */
  MaxAddcnt = 0;
  NmaxLP = (N * 5)/4;
  MaxDelta = 0;
  size_t siz = ((size_t)MD) * (NmaxLP + 2ul);

  size_t tot = MD * (6 * sizeof(int) + sizeof(double*) + (MDEBUG ? sizeof(int*):0)) + siz * ((VMEM_MINIMIZE ? 0 : sizeof(double)) + (MDEBUG ? sizeof(int):0));
  if(VERB>=2){
    printf("refine(): Before allocating %lu bytes for newLPd[]:\n",tot);
    dumpmemmap();
    fflush(stdout);
  }

  try {
    /* allocate initial memory for newLPd[] */
    DminM = new int[MD*6];
    DmaxM = &DminM[MD];
    TminM = &DminM[MD*2];
    TmaxM = &DminM[MD*3];
    AminM = &DminM[MD*4];
    AmaxM = &DminM[MD*5];
    newLPd = new double*[max(1,MD)]; newLPd[0] = NULL;
    if(VMEM_MINIMIZE) newLPd0 = new double[MD];// NEW8
    if(MDEBUG) {
      newLPdPr = new int*[MD];
      newLPdPr[0] = new int[siz];
      for(long long m = 1; m < MD; m++)
	newLPdPr[m] = newLPdPr[0] + m*(NmaxLP+2);
    }
    if(!VMEM_MINIMIZE){// NEW8
      newLPd[0] = new double[siz];
      for(long long m = 1; m < MD; m++)
	newLPd[m] = newLPd[0] + m*(NmaxLP+2);
    }
  } catch (exception& e){
    cout << e.what() << endl;
    printf("refine(): exception thrown while allocating newLPd[]:MaxAddcnt=%d,n=%d,NmaxLP=%d,MaxDelta=%d,MD=%d,N=%d (%lu total bytes)\n",
	   MaxAddcnt,n,NmaxLP,MaxDelta,MD,N, tot);
    fflush(stdout);
    assert(0);
  }
  if(VERB>=2){
    printf("refine(): After allocating %lu bytes for newLPd[]:\n",tot);
    dumpmemmap();
    fflush(stdout);
  }

  try {    /* allocate initial memory for newLPa[] */
    newLPa = new double*[max(1,MD)];
    if(MDEBUG) newLPaPr = new int*[max(1,MD)];
    newLPa[0] = 0;
    if(MDEBUG) newLPaPr[0] = 0;
  } catch (exception& e){
    cout << e.what() << endl;
    printf("refine(): exception thrown while allocating newLPa[]:MaxAddcnt=%d,n=%d,MaxDelta=%d,MD=%d,N=%d\n",MaxAddcnt,n,MaxDelta,MD,N);
    fflush(stdout);
    assert(0);
  }

  tot = MD * sizeof(double*)  + (NmaxLP+2)*sizeof(int);
  if(VERB>=2){
    printf("refine(): Before allocating %lu bytes for newLPdelta[]:\n",tot);
    dumpmemmap();
    fflush(stdout);
  }

  try {    /* allocate initial memory for newLPdelta[] */
    newLPdelta = new double*[MD];
    Dcum = new int[NmaxLP+2];
    newLPdeltaMem = 0;
  } catch (exception& e){
    cout << e.what() << endl;
    printf("refine(): exception thrown while allocating newLPdelta[]:MaxAddcnt=%d,n=%d,MaxDelta=%d,NmaxLP=%d,MD=%d,N=%d\n",MaxAddcnt,n,MaxDelta,NmaxLP,MD,N);
    fflush(stdout);
    assert(0);
  }

  if(VERB>=2){
    printf("refine(): After allocating %lu bytes for newLPdelta[]:\n",tot);
    dumpmemmap();
    fflush(stdout);
  }

  if(VERB/* >=2 */){
    printf("Initial newLPdelta=%p..%p(MD=%d)\n",newLPdelta,&newLPdelta[MD-1],MD);
    //    printf("\t Lfrozen=%d,Rfrozen=%d\n",Lfrozen,Rfrozen);
    fflush(stdout);
  }

  if(VERB/* >=2 */){
    printf("Initial MaxAddcnt=%d,n=%d,MaxDelta=%d,MD=%d,N=%d\n",MaxAddcnt,n,MaxDelta,MD,N);
    fflush(stdout);
  }

  score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */

  /* record how much real and virtual memory we have used so far */
  getmem(VmSize, VmRSS, VmSwap);
  if(VERB){
    printf("VmSize=%lld,VmRSS=%lld, VmSwap=%lld\n",VmSize,VmRSS,VmSwap);
    fflush(stdout);
  }

  double mt0 = mtime();
  double wt0 = wtime();

  global = 0;
  //  rverb = 1;
  //  tverb = 3;
  

  double LPstart = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
  //  tverb = 0;
  //  rverb = 0;

#if 0
    printf("Calling Initial qprobeval for incremental computation around interval Y[6023..6024]= %0.3f..%0.3f (left=%0.3f,right=%0.3f)\n",Y[6023],Y[6024],pcontig->left,pcontig->right);
    fflush(stdout);

    double *testLPA = new double[MD];

    rverb = 2;
    double LP2 = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,testLPA,mapWT,bestLPA,Y[6023],Y[6024],0,0,pcontig);
    rverb =0;

    delete [] testLPA;
#endif

  if(VERB>=3){

    int Q = 155;
    const int DQ = 2;
    double deltaQ[DQ] = {10.728, 84.744};


    double *testLPA = new double[MD];
    double *fixY = new double[N+2];
    double *fixYdel = new double[N+2];
    double *fixHcuts = new double[n+2];
    double *fixHcutsDel = new double[n+2];
    
    double origval = Y[Q+1] - Y[Q];

    fixY[0] = fixYdel[0] = 0.0;
    for(int I=1; I <= N+1; I++){
      fixY[I] = Y[I];
      fixYdel[I] = Y[I]-Y[I-1];
    }

    fixHcuts[0] = fixHcutsDel[0] = 0.0;
    for(int i = 1; i <= n+1; i++){
      fixHcuts[i] = Hcuts[i];
      fixHcutsDel[i] = Hcuts[i] - Hcuts[i-1];
    }

    int q0 = nmap[MD][Q];
    int q1 = nmap[MD][Q+1];
    /*	fixHcuts[q0..q1] corresponds to fixY[Q..Q+1] */

    for(int t = 0; t < DQ; t++){
      double val = deltaQ[t];
      double ratio = val/origval;

      fixYdel[Q+1] = val;
      for(int q = q0+1; q <= q1; q++)
	fixHcutsDel[q] *= ratio;

      double cum = 0.0;
      fixY[0] = cum;
      for(int I = 1; I <= N+1; I++){
	cum += fixYdel[I];
	fixY[I] = cum;
      }
      fixHcuts[0] = cum = 0.0;
      for(int q = 1; q <= n+1; q++){
	cum += fixHcutsDel[q];
	fixHcuts[q] = cum;
      }
      if(DEBUG) assert(fabs(fixHcuts[q0] - fixY[Q]) < 1e-8);
      if(DEBUG) assert(fabs(fixHcuts[q1] - fixY[Q+1]) < 1e-8);

      score_init(N,fixY,MD,MX,X);

      rverb = 1;
      double LP1 = qprobeval(n,fixHcuts,N,fixY,MD,MX,X,0,0,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,bestLPA,Y[Q],Y[Q+1],0,0,pcontig);
      rverb = 0;

      printf("Q=%d,t=%d,Y[Q..Q+1]=%0.4f -> %0.4f : LP=%0.8f -> %0.8f (delta=%0.8f)\n",Q,t,origval,val, LPstart,LP1,LP1-LPstart);
      fflush(stdout);

      /* restore original value of fixYdel[Q+1] and fixHcutsDel[q0+1..q1] */
      fixYdel[Q+1] = origval;
      for(int q = q0+1; q <= q1; q++)
	fixHcutsDel[q] = Hcuts[q] - Hcuts[q-1];
    }
  }


  if(VERB){
    double mt1 = mtime(), wt1 = wtime();

    printf("Original LP=%0.10f,N=%d,MD=%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f(global=%d),PoutlierEnd=%e: CPU= %0.6f, wall= %0.6f (cum wall= %0.6f)\n",LPstart,N,MD,Y[1],Y[N],Y[N+1],global,PoutlierEnd,mt1-mt0,wt1-wt0,wt1);

    //    printf("\t Lfrozen=%d,Rfrozen=%d\n",Lfrozen,Rfrozen);

    if(VERB>=3){
      double cum = 0.0;
      for(int m = 0; m < MD; m++){
	cum += bestLPA[m];
	printf(" bestLPA[%d]= %0.10f (cum= %0.10f)\n",m,bestLPA[m],cum);
      }
    }

    //    fflush(stdout);    exit(1);

    /*    printf("Switch RANGE_Y=%d to 0\n",RANGE_Y);
	  fflush(stdout);
	  RANGE_Y = 0;
	  double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  printf("Original nLP=%0.10f\n",nLP);
	  fflush(stdout);
	  exit(1);*/

    if(LVERB>=2){
      int origDELTA_X = DELTA_X;
      int origDELTA_Y = DELTA_Y;
      for(int delta = 2; delta <= 12; delta++){
	DELTA_X = DELTA_Y = delta;
	score_init(N,Y,MD,MX,X);
	double LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	printf("delta=%d:Original LP=%0.6f,N=%d,MD=%d,Y[N+1]=%0.3f(global=%d)\n",delta,LP,N,MD,Y[N+1],global);
	fflush(stdout);
      }
      DELTA_X = origDELTA_X;
      DELTA_Y = origDELTA_Y;
      score_init(N,Y,MD,MX,X);
      (void) qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    }
    if(VERB>=2){
      for(register int m=0; m < MD; m++){
	int IL=0,KL=0,JL=0, IR=0,KR=0,JR=0;
	for(register int j = 1; j <= MX[m]; j++)
	  if((IL = map[m][j]) >= 1){
	    KL = mapK[m][j];
	    JL = j;
	    break;
	  }
	for(register int j = MX[m]; j >= 1; j--)
	  if((IR = map[m][j]) >= 1){
	    KR = mapK[m][j];
	    JR = j;
	    break;
	  }
	printf("m=%d:old alignment:IL=%d,KL=%d,JL=%d(H[IL]=%0.3f),  IR=%d,KR=%d,JR=%d(H[IR]=%0.3f):",
	       m,IL,KL,JL,Hcuts[IL], IR,KR,JR, Hcuts[IR]);

	IL = KL = JL = IR = KR = JR = 0;
	for(register int j = 1; j <= MX[m]; j++)
	  if((IL = nmap[m][j]) >= 1){
	    IL = nmap[MD][IL];
	    KL = nmapK[m][j];
	    JL = j;
	    break;
	  }
	for(register int j = MX[m]; j >= 1; j--)
	  if((IR = nmap[m][j]) >= 1){
	    IR = nmap[MD][IR];
	    KR = nmapK[m][j];
	    JR = j;
	    break;
	  }
	if(IL > 0 && IR > 0)
	  printf("  new alignment:IL=%d,KL=%d,JL=%d(H[IL]=%0.3f),  IR=%d,KR=%d,JR=%d(H[IR]=%0.3f)\n",
		 IL,KL,JL,Hcuts[IL],IR,KR,JR,Hcuts[IR]);
	else
	  printf("  new alignment:IL=%d,KL=%d,JL=%d,  IR=%d,KR=%d,JR=%d\n",
		 IL,KL,JL,IR,KR,JR);
      }
    }

    fflush(stdout);
  }

  //  if(rverb) exit(1);

  if(global){
    UpdateMap(n, N, Y, MD, MX, X, Hcuts, Hdel, map,mapK,limit,nmap,nmapK, mapWT, 0, FILL_MAP);
    global = 0;
    LPstart = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    if(VERB>=2){
      printf("updated LP=%0.6f,N=%d,MD=%d,Y[N+1]=%0.3f(global=%d)\n",LPstart,N,MD,Y[N+1],global);
      fflush(stdout);
    }
  }

  double LPend = LPstart;

  if(MultiMode)
    TrimFactor = 0.0;
  if(TrimFactor != 0.0){
    printf("TrimFactor= %0.6e: values other than 0.0 no longer supported\n",TrimFactor);
    exit(1);
  }
  if(DEBUG) assert(INIT_TRIM==0.0 && INIT2_TRIM==0.0 && EARLY_MINTRIM==0.0);
  double trimfactor = INIT_TRIM;
  

  if(Refine>=2 && (extend>=2 || PoutlierEndCnt > 0) && (HapSitePvalue <= 0.0 || !refineDefer)){  /* first try adding/deleting cuts without changing sizes */

    do { /* iterate add/delete for PoutlierEnd over all PoutlierEndRefine[0..PoutlierEndCnt-1] (with no resizing until PoutlierEndRefine[PoutlierEndCnt-1])*/
      /* NOTE : If PoutlierCnt > 0, current PoutlierEnd == PoutlierEndRefine[PoutlierEndIndex-1] */
      int resize =  (PoutlierEndIndex >= PoutlierEndCnt || PoutlierEnd == PoutlierEndRefine[PoutlierEndCnt-1]) ? 1 : 0;

      if(VERB/* HERE HERE >=2 */){
	printf("PoutlierEndIndex= %d/%d: resize=%d (Lfrozen=%d, %0.3f, Rfrozen=%d, %0.3f)\n",PoutlierEndIndex,PoutlierEndCnt, resize,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[Rfrozen]);
	fflush(stdout);
      }

      if(/* WAS21 extend <= 1 && */ resize){
	/* restore parameters for final refinement stage(s) */
	if(biasWTrefine > biasWT && biasWTrefineType){
	  if(VERB){
	    printf("Restoring biasWT= %0.3f -> %0.3f\n", biasWT, biasWTrefine);
	    fflush(stdout);
	  }
	  biasWT = biasWTrefine;
	  //	  score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd, Poutlier OR biasWT */	  
	}
	if(origLRbias != LRbias){
	  if(VERB){
	    printf("Restoring LRbias=%0.6e -> %0.6e\n",LRbias,origLRbias);
	    fflush(stdout);
	  }
	  LRbias = origLRbias;
	}

	if(SKIP_DIST != skip_dist){
	  if(VERB){
	    printf("Restoring SKIP_DIST=%0.3f -> %0.3f\n", SKIP_DIST, skip_dist);
	    fflush(stdout);
	  }
	  SKIP_DIST = skip_dist;
	  skip_sites(n,skip,Hdel,Hcuts);
	}
	if(LP_SKIP != skip_score){
	  if(VERB){
	    printf("Restoring LP_SKIP=%0.4e -> %0.4e\n", LP_SKIP, skip_score);
	    fflush(stdout);
	  }
	  LP_SKIP = skip_score;
	}

	if(ANNEAL_SITE_PEN && Site_Pen != origSite_Pen){
	  Site_Pen = origSite_Pen;
	  if(VERB){
	    printf("Restoring Site_Pen= 0 -> %0.3f\n", Site_Pen);
	    fflush(stdout);
	  }
	}
	if(FN[0] != restoreFN){
	  if(VERB){
	    printf("Restoring FN[0]= %0.6f -> %0.6f\n", FN[0], restoreFN);
	    fflush(stdout);
	  }
	  FN[0] = restoreFN;
	}
	if(SF[0] != restoreSF){
	  if(VERB){
	    printf("Restoring SF[0]= %0.6f -> %0.6f\n", SF[0], restoreSF);
	    fflush(stdout);
	  }
	  SF[0] = restoreSF;
	}
	if(SR[0] != restoreSR){
	  if(VERB){
	    printf("Restoring SR[0]= %0.6f -> %0.6f\n", SR[0], restoreSR);
	    fflush(stdout);
	  }
	  SR[0] = restoreSR;
	}

	if(extend >= 2 && extendonly && EndLen2 < EndLen && Lfrozen < Rfrozen){/* reduce frozen range to correspond to pcontig->Y1 + EndLen .. pcontig->YN - EndLen */
	  if(Lfrozen > 0 && !(pcontig->MaskL & (END_NOEXT | END_NOEXT2)))
	    while(Lfrozen <= Rfrozen && Hcuts[Lfrozen] < pcontig->Y1 + EndLen /* WAS105 pcontig->left + EndLen + Y[1]*/)
	      Lfrozen++;

	  if(Rfrozen <= n && !(pcontig->MaskR & (END_NOEXT | END_NOEXT2)))
	    while(Lfrozen <= Rfrozen && Hcuts[Rfrozen] > pcontig->YN - EndLen /* WAS105 pcontig->right - (EndLen + Y[N+1]-Y[N])*/)
	      Rfrozen--;

	  if(Lfrozen > Rfrozen)
	    Lfrozen = Rfrozen = 0;

	  if(VERB){
	    if(Rfrozen <= 0)
	      printf("All of original region %0.3f .. %0.3f will be modified during during final refinement (EndLen= %0.3f)\n",pcontig->left,pcontig->right,EndLen);
	    else {
	      printf("Hcuts[%d..%d] = %0.3f .. %0.3f will not be modified during final refinement: n=%d,Hcuts[n+1]=%0.3f\n",
		     Lfrozen,Rfrozen,Hcuts[Lfrozen],Hcuts[Rfrozen],n,Hcuts[n+1]);
	      if(VERB/* HERE HERE >=2 */)
		printf("\t pcontig->left= %0.3f(Y1=%0.3f), pcontig->right= %0.3f(YN=%0.3f), EndLen= %0.3f,EndLen2= %0.3f,N=%d,Y[1,N,N+1]=%0.3f,%0.3f,%0.3f, MaskL=%lu,MaskR=%lu\n",
		       pcontig->left,pcontig->Y1,pcontig->right,pcontig->YN,EndLen,EndLen2,N,Y[1],Y[N],Y[N+1],pcontig->MaskL,pcontig->MaskR);
	    }
	    fflush(stdout);
	  }
	}

	score_init(N,Y,MD,MX,X);	  // needed due to change in biasWT  with PRbiasWT > 0

	double origLPstart = LPstart;
	//	rverb = 1;
	LPstart = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	//	rverb = 0;
	if(VERB){
	  printf("After restoring parameters for final refinement stages:LP=%0.6f -> %0.6f (Lfrozen=%d(%0.3f),Rfrozen=%d(%0.3f))\n",origLPstart, LPstart, Lfrozen, Hcuts[Lfrozen],Rfrozen,Hcuts[Rfrozen]);
	  fflush(stdout);
	}
      }

      LPend = AddDelete(LPstart,TBmapWT,bestLPA,newLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,pcontig,trimfactor, resize,MultiMode,skip,Lfrozen,Rfrozen, 1);

      if(VERB/* >=2 */){
	printf("PoutlierEndIndex=%d/%d:AddDelete() returned LP=%0.6f(delta=%0.6f):cum time = %0.6f, wall time=%0.6f\n",PoutlierEndIndex,PoutlierEndCnt,LPend,LPend-LPstart,mtime(),wtime());
	fflush(stdout);
      }
      LPstart = LPend;

      if(DEBUG>=2){// check if any sites with skip[i] have been added */
	for(int i = 1; i <= n; i++){
	  if(!Hdel[i] && skip[i]==1){
	    printf("i=%d/%d:Hdel[i]=%d,skip[i]=%d,Hcuts[i]= %0.3f\n",i,n,Hdel[i],skip[i],Hcuts[i]);
	    fflush(stdout);
	    assert(Hdel[i] || skip[i] != 1);
	  }
	}
      }

#if 0 // DEBUG CODE
	printf("Repeating AddDelete: wtime= %0.6f\n", wtime());
	fflush(stdout);

	LPend = AddDelete(LPstart,TBmapWT,bestLPA,newLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,pcontig,trimfactor, resize,MultiMode,skip,Lfrozen,Rfrozen, 1);

	printf("After repeating AddDelete: LP = %0.8f -> %0.8f (delta = %0.8f): wtime= %0.6f\n",LPstart,LPend,LPend-LPstart,wtime());
	fflush(stdout);
	exit(1);
#endif

      if(DEBUG){
	int newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	assert(newN == N);

	if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	  for(int m = 0; m < MD; m++){
	    int M = MX[m];

	    int lastJ = -1, lasti = -1, lastk = -1;
	    for(int J = 1; J <= M; J++){
	      int i = map[m][J];
	      if(i < 0)
		continue;
	      int k = mapK[m][J];
	      if(DEBUG &&  !(0 <= k && k < i)){
		printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
		fflush(stdout);
		assert(0 <= k && k < i);
	      }
	      if(lasti >= 0 && !(i-k > lasti)){
		printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
		if(VERB){
		  for(int j = 1; j <= M; j++){
		    int i = map[m][j];
		    if(i < 0)
		      continue;
		    int k = mapK[m][j];
		    printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		  }
		}
		fflush(stdout);
		assert(i-k > lasti);
	      }
	      lasti = i;
	      lastk = k;
	      lastJ = J;
	    }
	  }
	}
      }

      if(PoutlierEndIndex < PoutlierEndCnt){
	double startPoutlier = Poutlier;
	double startPoutlierEnd = PoutlierEnd;
	gorigPoutlierEnd = PoutlierEnd = PoutlierEndRefine[PoutlierEndIndex];
	gorigPoutlier = Poutlier = PoutlierRefine[PoutlierEndIndex];
	if(!OUTLIERREF_FIX)
	  gorigPoutlier = min(Poutlier,origPoutlier);
	if(VERB/* >=2 */){
	  if(startPoutlierEnd != PoutlierEnd)
	    printf("Changing PoutlierEnd = %0.3e -> %0.3e\n",startPoutlierEnd, PoutlierEnd);
	  if(startPoutlier != Poutlier)
	    printf("Changing Poutlier = %0.3e -> %0.3e\n",startPoutlier,Poutlier);
	  fflush(stdout);
	}
	score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd & Poutlier */
	//	score_init(N,Y,MD,MX,X);

	double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	if(VERB/* >=2 */){
	  printf(" LP=%0.6f -> %0.6f\n", LPstart, nLP);
	  fflush(stdout);
	}
	LPstart = LPend = nLP;
      }
    } while (++PoutlierEndIndex <= PoutlierEndCnt);

  } /* if(Refine >= 2 && (extend >= 2 || PoutlierEndCnt > 0)) */

  /* restore parameters for final refinement stage(s) (was already done previously if Refine>=2 && extend <= 1 && PoutlierEndCnt > 0) */
  double origPoutlierEnd2 = PoutlierEnd;
  //  double origPoutlier2 = Poutlier;
  if(PoutlierEndCnt > 0 && (PoutlierEndRefine[PoutlierEndCnt-1] != PoutlierEnd || PoutlierRefine[PoutlierEndCnt-1] != Poutlier)){
    double startPoutlier = Poutlier;
    double startPoutlierEnd = PoutlierEnd;
    gorigPoutlierEnd = PoutlierEnd = PoutlierEndRefine[PoutlierEndCnt-1];
    gorigPoutlier = Poutlier = PoutlierRefine[PoutlierEndCnt-1];
    if(VERB/* >=2 */){
      if(startPoutlierEnd != PoutlierEnd)
	printf("Changing PoutlierEnd = %0.3e -> %0.3e\n",startPoutlierEnd, PoutlierEnd);
      if(startPoutlier != Poutlier)
	printf("Changing Poutlier = %0.3e -> %0.3e\n",startPoutlier,Poutlier);
      fflush(stdout);
    }
  }
  if(!OUTLIERREF_FIX && Poutlier != origPoutlier){
    if(VERB/* >=2 */){
      printf("Restoring Poutlier = %0.3e -> %0.3e\n", Poutlier, origPoutlier);	
      fflush(stdout);
    }
    gorigPoutlier = Poutlier = origPoutlier;
  }
  
  score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd & Poutlier */

  if(biasWTrefine != biasWT && biasWTrefineType){
    if(VERB){
      printf("Restoring biasWT= %0.3f -> %0.3f\n", biasWT, biasWTrefine);
      fflush(stdout);
    }
    biasWT = biasWTrefine;
    //    score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd, Poutlier OR biasWT */	  
  }
  if(DEBUG && !(origLRbias >= 0.0)){
    printf("origLRbias=%0.6e,LRbias=%0.6e\n",origLRbias,LRbias);
    fflush(stdout);
    assert(origLRbias >= 0.0);
  }
  if(origLRbias != LRbias){
    if(VERB){
      printf("Restoring LRbias=%0.6e -> %0.6e\n",LRbias,origLRbias);	
      fflush(stdout);
    }
    LRbias = origLRbias;
  }
  if(DEBUG) assert(LRbias >= 0.0);

  if(SKIP_DIST != skip_dist){
    if(VERB){
      printf("Restoring SKIP_DIST=%0.3f -> %0.3f\n", SKIP_DIST, skip_dist);
      fflush(stdout);
    }
    SKIP_DIST = skip_dist;
    skip_sites(n,skip,Hdel,Hcuts);
  }
  if(LP_SKIP != skip_score){
    if(VERB){
      printf("Restoring LP_SKIP=%0.4e -> %0.4e\n", LP_SKIP, skip_score);
      fflush(stdout);
    }
    LP_SKIP = skip_score;
  }
  if(ANNEAL_SITE_PEN && Site_Pen != origSite_Pen){
    Site_Pen = origSite_Pen;
    if(VERB){
      printf("Restoring Site_Pen= 0 -> %0.3f\n", Site_Pen);
      fflush(stdout);
    }
  }
  if(FN[0] != restoreFN){
    if(VERB){
      printf("Restoring FN[0]= %0.6f -> %0.6f\n", FN[0], restoreFN);
      fflush(stdout);
    }
    FN[0] = restoreFN;
  }
  if(SF[0] != restoreSF){
    if(VERB){
      printf("Restoring SF[0]= %0.6f -> %0.6f\n", SF[0], restoreSF);
      fflush(stdout);
    }
    SF[0] = restoreSF;
  }
  if(SR[0] != restoreSR){
    if(VERB){
      printf("Restoring SR[0]= %0.6f -> %0.6f\n", SR[0], restoreSR);
      fflush(stdout);
    }
    SR[0] = restoreSR;
  }

  if(extend >= 2 && extendonly && EndLen2 < EndLen && Lfrozen < Rfrozen){/* reduce frozen range to correspond to pcontig->Y1 + EndLen .. pcontig->YN - EndLen */
    if(Lfrozen > 0 && !(pcontig->MaskL & (END_NOEXT | END_NOEXT2)))
      while(Lfrozen <= Rfrozen && Hcuts[Lfrozen] < pcontig->Y1 + EndLen /* WAS105 pcontig->left + EndLen + Y[1] */)
	Lfrozen++;

    if(Rfrozen <= n && !(pcontig->MaskR & (END_NOEXT | END_NOEXT2)))
      while(Lfrozen <= Rfrozen && Hcuts[Rfrozen] > pcontig->YN - EndLen /* WAS105 pcontig->right - (EndLen + Y[N+1]-Y[N]) */)
	Rfrozen--;

    if(Lfrozen > Rfrozen)
      Lfrozen = Rfrozen = 0;

    if(VERB){
      if(Rfrozen <= 0)
	printf("All of original region %0.3f .. %0.3f will be modified during during final refinement (EndLen= %0.3f)\n",pcontig->left,pcontig->right,EndLen);
      else
	printf("Hcuts[%d..%d] = %0.3f .. %0.3f will not be modified during final refinement\n",Lfrozen,Rfrozen,Hcuts[Lfrozen],Hcuts[Rfrozen]);
      if(VERB/* HERE HERE >=2 */)
	printf("\t pcontig->left= %0.3f(Y1=%0.3f), pcontig->right= %0.3f(YN=%0.3f), EndLen= %0.3f, MaskL=%lu,MaskR=%lu\n",
	       pcontig->left,pcontig->Y1,pcontig->right,pcontig->YN,EndLen,pcontig->MaskL,pcontig->MaskR);
      fflush(stdout);
    }
  }

  score_init(N,Y,MD,MX,X);	  // due to changes in FN[0] OR biasWT */

  DELTA_X = origDELTA_X;
  DELTA_Y = origDELTA_Y;
  RANGE_Y = origRANGE_Y;
  
  if(Refine >= 2 && (!(extend <= 1 && PoutlierEndCnt > 0) || PoutlierEnd != origPoutlierEnd2 || TBcnt > 0)){/* need to recompute LPstart */
    score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
    double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    if(VERB/* >=2*/){
      printf("After Restoring parameters and setting DELTA_X=%d,DELTA_Y=%d,RANGE_Y=%d : LP=%0.6f -> %0.6f\n",DELTA_X, DELTA_Y, RANGE_Y, LPstart, nLP);
      fflush(stdout);
    }
    LPstart = nLP;
  }

  int failed = 0;
  int mapupdated = 0;
  LPend = LPstart;

  if(Refine >= 2 && (!(extend <= 1 && PoutlierEndCnt > 0) || PoutlierEnd != origPoutlierEnd2) && (HapSitePvalue <= 0.0 || !refineDefer)){/* need to recompute AddDelete() */
    double LP = AddDelete(LPstart,TBmapWT,bestLPA,newLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,pcontig,trimfactor,1/*resize*/,MultiMode,skip,Lfrozen,Rfrozen,1);
    if(VERB/* >=2 */){
      printf("Final AddDelete() returned LP=%0.6f(delta=%0.6f):cum time = %0.6f, wall time=%0.6f\n",LP, LP-LPend, mtime(), wtime());
      fflush(stdout);
    }
    if(DEBUG>=2){// check if any sites with skip[i] have been added */
      for(int i = 1; i <= n; i++){
	if(!Hdel[i] && skip[i]==1){
	  printf("i=%d/%d:Hdel[i]=%d,skip[i]=%d,Hcuts[i]= %0.3f\n",i,n,Hdel[i],skip[i],Hcuts[i]);
	  fflush(stdout);
	  assert(Hdel[i] || skip[i] != 1);
	}
      }
    }

    if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
      (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
      for(int m = 0; m < MD; m++){
	int M = MX[m];

	int lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  int i = map[m][J];
	  if(i < 0)
	    continue;
	  int k = mapK[m][J];
	  if(DEBUG &&  !(0 <= k && k < i)){
	    printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
	  }
	  if(lasti >= 0 && !(i-k > lasti)){
	    printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[m][j];
		if(i < 0)
		  continue;
		int k = mapK[m][j];
		printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	      }
	    }
	    fflush(stdout);
	    assert(i-k > lasti);
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
	}
      }
    }

    LPend = LP;
  }

  if(Refine >= 2 && TBcnt > 0 && (HapSitePvalue <= 0.0 || !refineDefer)){/* continue refinement with add/delete AND resizing to handle -TB */
    double LogTBmult = TBmult > 0.0 ? -log(TBmult)/log(10.0) : 0.0;
    double LogPv = LogPvThresholdTB[0];
    
    int myTBcnt = TBcnt;

    for(int TBindex = 0; TBindex < myTBcnt;){
      if(TBmult > 0.0){
	if(LogPv > LogPvThresholdTB[myTBcnt-1] - 1e-6){
	  myTBcnt = TBindex + 1;
	  break;
	}
	double origLogPv = LogPv;
	LogPv += LogTBmult;
	if(LogPv > LogPvThresholdTB[myTBcnt-1] + 1e-6 && origLogPv <= LogPvThresholdTB[myTBcnt-1] - 1e-6)
	  LogPv = LogPvThresholdTB[myTBcnt-1];
      } else {
	if(++TBindex >= myTBcnt){
	  break;
	}
	LogPv = LogPvThresholdTB[TBindex];
      }
    }
    if(myTBcnt < TBcnt){
      printf("Reducing number of TB iterations from %d to %d\n", TBcnt, myTBcnt);
      fflush(stdout);
    }

    LogPv = LogPvThresholdTB[0];

    for(int TBindex = 0; TBindex < myTBcnt;){
	
      /* update TBmapWT[] */
      double LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,pcontig->logPV,pcontig->outlier[0],pcontig);
      double PVTB = pow(0.1,LogPv);
      double origWTsum = 0.0, WTsum = 0.0;
      for(int m = 0; m < MD; m++){
	double PVm = pow(0.1,pcontig->logPV[m]);
	double origTBmapWT;
	origWTsum += origTBmapWT = TBmapWT[m];
	if(VERB>=2 && gmap[pcontig->contig[m].mapid]->id == 606895LL){
	  printf("m=%2d:(id=%lld):TB=%0.2f,logPV[m]=%0.2f:TBmapWT[m]=%0.8f -> %0.8f, mapWT[m]= %0.6f\n",
		 m, gmap[pcontig->contig[m].mapid]->id, LogPv, pcontig->logPV[m], TBmapWT[m], PVTB/(PVTB+PVm),pcontig->mapWT[m]);
	  fflush(stdout);
	}
	WTsum += TBmapWT[m] = (origTBmapWT <= 0.0) ? 0.0 : pcontig->mapWT[m] * PVTB/(PVTB + PVm);
	if(DEBUG>=1+RELEASE/* HERE >=2 */ && !isfinite(TBmapWT[m])){
	  printf("m=%d/%d:TBmapWT[m]= %0.8e -> %0.8e: pcontig->mapWT[m]= %0.8e, logPV[m]= %0.8e, PVm= %0.8e, LogPv= %0.8f, PVTB= %0.8e\n",
		 m,MD,origTBmapWT, TBmapWT[m],pcontig->mapWT[m], pcontig->logPV[m],PVm,LogPv, PVTB);
	  fflush(stdout);
	  assert(isfinite(TBmapWT[m]));
	}
      }
      double LP2 = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
      if(VERB){
	printf("TB=%0.2f:WTsum= %0.3f -> %0.3f,MD=%d,LP=%9.6f,qLP=%11.6f -> %11.6f\n", LogPv, origWTsum, WTsum, MD, LPend, LP, LP2);
	fflush(stdout);
      }
      LPend = LP2;

      /* repeat refinement with new TBmapWT[] */
      double LPend2 = AddDelete(LPend,TBmapWT,bestLPA,newLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,pcontig,trimfactor,1/*resize*/,MultiMode,skip,Lfrozen,Rfrozen,
				(TBindex == myTBcnt-1 ? 0 : 1));

      if(VERB/* >=2 */){
	printf("TB=%0.2f (%d/%d):AddDelete() changed LP=%11.6f -> %11.6f(delta=%0.6f):cum time=%0.6f, wall time=%0.6f\n", LogPv, TBindex, myTBcnt, LPend, LPend2, LPend2-LPend, mtime(), wtime());
	fflush(stdout);
      }

      if(DEBUG>=2){// check if any sites with skip[i] have been added */
	for(int i = 1; i <= n; i++){
	  if(!Hdel[i] && skip[i]==1){
	    printf("i=%d/%d:Hdel[i]=%d,skip[i]=%d,Hcuts[i]= %0.3f\n",i,n,Hdel[i],skip[i],Hcuts[i]);
	    fflush(stdout);
	    assert(Hdel[i] || skip[i] != 1);
	  }
	}
      }

      LPend = LPend2;

      /* update TBindex, LogPv */
      if(TBmult > 0.0){
	if(LogPv > LogPvThresholdTB[myTBcnt-1] - 1e-6)
	  break;
	double origLogPv = LogPv;
	LogPv += LogTBmult;
	if(LogPv > LogPvThresholdTB[myTBcnt-1] + 1e-6 && origLogPv <= LogPvThresholdTB[myTBcnt-1] - 1e-6)
	  LogPv = LogPvThresholdTB[myTBcnt-1];
      } else {
	if(++TBindex >= myTBcnt)
	  break;
	LogPv = LogPvThresholdTB[TBindex];
      }
    }
  }

  // HERE HERE : check just deleting one of the two sites, if that scores better (see similar code during haplotyping)
  if(REMOVE_CLOSE_SITES && Refine >= 2 && rres > 0.0 && (HapSitePvalue <= 0.0 || !rresDefer)){/* remove consensus sites closer than rres*PixelLen (OR closer than cres if there are not at least 3 maps with both sites) */
    double mergeKB = rres * 0.500;

    int origN = N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */

    if(VERB){
      printf("Merging all sites closer than mergeKB=%0.3f kb: LP=%0.6f (Y[1,N,N+1]= %0.3f,%0.3f,%0.3f)\n",mergeKB, LPend,Y[1],Y[N],Y[N+1]);
      fflush(stdout);
    }

    if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
      for(int m = 0; m < MD; m++){
	int M = MX[m];

	int lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  int i = map[m][J];
	  if(i < 0)
	    continue;
	  int k = mapK[m][J];
	  if(DEBUG &&  !(0 <= k && k < i)){
	    printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
	  }
	  if(lasti >= 0 && !(i-k > lasti)){
	    printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[m][j];
		if(i < 0)
		  continue;
		int k = mapK[m][j];
		printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	      }
	    }
	    fflush(stdout);
	    assert(i-k > lasti);
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
	}
      }
    }

    if(VERB>=2){/* list sites closer than 10 bp ! */
      for(int I = 1; I < N; I++)
	if(Y[I+1]-Y[I] <= 0.01)
	  printf("  k=%d:Y[k]=%0.6f,Y[k+1]=%0.6f,delta=%0.6f (!)\n",I,Y[I],Y[I+1],Y[I+1]-Y[I]);
      fflush(stdout);
    }

    double *origHcuts = new double[n+2];
    for(int i=0;i<=n+1;i++)
      origHcuts[i] = Hcuts[i];

    int progress = 1;

    double mt, wt;
    if(TIME_VERBOSE){
      mt = mtime();
      wt = wtime();
    }

    //    int cnt = 0;

    while(progress){
      progress = 0;

      /* locate smallest remaining interval */
      int smallK = -1;
      double smallKB = mergeKB * 100.0;
      for(int k = 1; k < N; k++){
	if(Y[k+1]-Y[k] < smallKB){
	  smallK = k;
	  smallKB = Y[k+1]-Y[k];
	}
      }
      if(VERB>=2 && smallK > 0){
	printf("Next smallest interval is k=%d:Y[k]=%0.6f,Y[k+1]=%0.6f (delta=%0.6f),mergeKB=%0.4f\n",
	       smallK, Y[smallK],Y[smallK+1],Y[smallK+1]-Y[smallK],mergeKB);
	fflush(stdout);
      }

      if(smallKB <= mergeKB){
	progress = 1;
	
	int I = smallK;
	int iL = nmap[MD][I];
	int iR = nmap[MD][I+1];
	if(DEBUG) assert(iL >= 1 && iR >= iL && iR <= n);
	if(DEBUG) assert(!Hdel[iL]);
	if(DEBUG) assert(!Hdel[iR]);
	
	for(int i = iL; i < iR; i++)
	  Hcuts[i] = 0.5*(Hcuts[i] + Hcuts[iR]);
	Hdel[iR] = 1;

	double LPnew;

	int newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */	
	score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	//	tverb = 1;
	if(MERGE_FAST < 2)
	  LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
	else {
	  LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,bestLPA,Hcuts[iL-1],Hcuts[iR],0,0,pcontig); 
	  memcpy(bestLPA,newLPA,MD*sizeof(double));
	}
	//	tverb = 0;

	if(VERB){
	  if(TIME_VERBOSE){
	    double mt1 = mtime(), wt1 = wtime();
	    printf("Merging Hcuts[%d]=%0.4f,Hcuts[%d]=%0.4f into %0.4f (gap= %0.4f): LP = %0.9f -> %0.9f,N=%d: CPU time= %0.6f, wall= %0.6f (cum wall time= %0.6f)\n",
		   iL,origHcuts[iL],iR,origHcuts[iR],Hcuts[iL], origHcuts[iR]-origHcuts[iL], LPend, LPnew, newN, mt1-mt,wt1-wt,wt1);
	    mt = mt1;
	    wt = wt1;
	  } else
	    printf("Merging Hcuts[%d]=%0.4f,Hcuts[%d]=%0.4f into %0.4f (gap= %0.4f): LP = %0.9f -> %0.9f,N=%d\n",
		   iL,origHcuts[iL],iR,origHcuts[iR],Hcuts[iL],origHcuts[iR]-origHcuts[iL], LPend, LPnew, newN);
	  fflush(stdout);

	  for(register int i = 0; i <= n+1; i++)
	    origHcuts[i] = Hcuts[i];
	}

	N = newN;
	LPend = LPnew;

	if(DEBUG>=2){  /* make sure no real cuts are closer than minKB */
	  int NN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	  assert(NN==N);
	  for(int I = 1; I < N; I++)
	    if(DEBUG && (!(Y[I+1]-Y[I] >= mergeKB - 2e-9) /* ||(360 <= I && I <= 380)*/) ){
	      printf("After Merging:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, mergeKB=%0.6f,minKB=%0.6f\n",
		     I,Y[I],Y[I+1], Y[I+1]-Y[I], mergeKB,minKB);
	      fflush(stdout);
	      assert(Y[I+1]-Y[I] >= minKB - 2e-9);
	    }
	  assert(Y[1] >= Y[0]);
	  assert(Y[N+1] >= Y[N]);
	}
      }
    }
    if(VERB>=2){
      for(int I = 1; I < N; I++)
	printf("  I=%d:Y[I]=%0.4f,Y[I+1]=%0.4f,delta=%0.6f %c\n",I,Y[I],Y[I+1],Y[I+1]-Y[I],Y[I+1]-Y[I] <= mergeKB ? '!' : ' ');
      fflush(stdout);
    }

    if(MERGE_FAST>=2){/* do full qprobeval */
      N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      double LPnew =  qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
      if(DEBUG && fabs(LPnew - LPend) > 1e-4){
	double mt1 = mtime(), wt1 = wtime();
	printf("WARNING: After Merging Hcuts[]: LP = %0.10f -> %0.10f (err= %0.10f): CPU time= %0.6f, wall= %0.6f (cum wall time=%0.6f)\n", LPend, LPnew, LPend-LPnew, mt1-mt, wt1-wt,wt1);
	fflush(stdout);
	if(DEBUG>=1+RELEASE) assert(fabs(LPnew-LPend) <= 1.0);
	mt = mt1;
	wt = wt1;
      }
      LPend = LPnew;
    }

    if(origN != N && (cresRefine>=1 || HapSitePvalue > 0.0)){   /* update Sizing only */
      // HERE HERE : consider setting RefineMinRange1 = RefineMinRange2 AND RefineMaxRange1 = RefineMaxRange2 to speed up refinement

      /* avoid creating new intervals smaller than mergeKB */
      double origZERO_MINKB = ZERO_MINKB;
      ZERO_MINKB = 0.0;
      minKB = ZERO_MINKB ? ZERO_MINKB /* WAS45 0.001 * PixelLen */ : rres * 0.500;/* score_init() will now compute the same value, when called before mprobeval() */

      double LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1):n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);

      if(DEBUG){  /* make sure no real cuts are closer than minKB */
	int NN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	assert(NN==N);
	for(int I = 1; I < N; I++)
	  if(DEBUG && (!(Y[I+1]-Y[I] >= mergeKB - 2e-9) /* ||(360 <= I && I <= 380) */) ){
	    printf("After SizesEstimate:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, mergeKB=%0.6f,minKB=%0.6f\n",
		   I,Y[I],Y[I+1], Y[I+1]-Y[I], mergeKB,minKB);
	    fflush(stdout);
	    assert(Y[I+1]-Y[I] >= mergeKB - 2e-9);
	  }
	assert(Y[1] >= Y[0]);
	assert(Y[N+1] >= Y[N]);
      }
      if(VERB){
	printf("Final LP after removing %d nearby sites = %0.6f -> %0.6f (minKB=%0.6f)\n", origN-N, LPend, LP,minKB);
	fflush(stdout);
      }
      LPend = LP;

      ZERO_MINKB = origZERO_MINKB;
    }
    if(VERB && origN != N){
      printf("Removed %d nearby sites (minKB= %0.6f)\n",origN-N,minKB);
      fflush(stdout);
    }

    int origNN = origN;// NEW7

    if(cres > 0.0 && !HapSitePvalue){
      int origN = N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      double LP =  qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 

      memcpy(origHcuts,Hcuts,(n+2)*sizeof(double));

      int iterations = (int)floor((cres - rres) / 0.40 + 0.5);
      double res_delta = (cres - rres) * 0.500 / max(1,iterations) - 1e-8;
      res_delta = max(0.100, res_delta);// NEW14

      double prev_cresKB = CRES_CUMULATIVE ? 0.0 : rres * 0.500;

      for(double cresKB = prev_cresKB + res_delta; cresKB <= cres * 0.5; prev_cresKB = (CRES_CUMULATIVE ? 0.0 : cresKB), cresKB += res_delta){

	if(VERB){
	  if(TIME_VERBOSE){
	    double mt1 = mtime(), wt1 = wtime();
	    printf("Checking all sites within %0.3f .. %0.3f kb (cres=%0.3f kb, MaxLPdrop= %0.3f): LP=%0.6f(qLP=%0.6f),minKB=%0.6f (Y[1,N,N+1]=%0.3f,%0.3f,%0.3f): cum wall time= %0.6f\n", 
		   prev_cresKB,cresKB, cres * 0.5, cresMaxLPdrop, LPend,LP,minKB,Y[1],Y[N],Y[N+1],wt1);	    
	    mt = mt1;
	    wt = wt1;
	  } else
	    printf("Checking all sites within %0.3f .. %0.3f kb (cres=%0.3f kb, MaxLPdrop= %0.3f): LP=%0.6f(qLP=%0.6f),minKB=%0.6f (Y[1,N,N+1]=%0.3f,%0.3f,%0.3f)\n", 
		   prev_cresKB, cresKB, cres * 0.5, cresMaxLPdrop, LPend,LP,minKB,Y[1],Y[N],Y[N+1]);
	  fflush(stdout);
	}

	if(DEBUG>=2){
	  for(register int I = 1; I < N; I++)
	    if(DEBUG && (!(Y[I+1]-Y[I] >= mergeKB - 2e-9) || (360 <= I && I <= 380))){
	      printf("I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, mergeKB=%0.6f,minKB=%0.6f\n",
		     I,Y[I],Y[I+1], Y[I+1]-Y[I], mergeKB,minKB);
	      fflush(stdout);
	      assert(Y[I+1]-Y[I] >= mergeKB - 2e-9);
	    }
	  assert(Y[1] >= Y[0]);
	  assert(Y[N+1] >= Y[N]);
	}

	/* first check 2 consecutive sites closer than cresKB */
	for(int I = 1; I < N; I++){
	  if(VERB>=2){
	    printf("I=%d:Y[I]= %0.4f, Y[I+1]=%0.4f, delta=%0.4f\n",I,Y[I],Y[I+1],Y[I+1]-Y[I]);
	    fflush(stdout);
	  }

	  if(Y[I+1] - Y[I] > cresKB)
	    continue;

	  if(!CRES_CUMULATIVE && Y[I+1] - Y[I] <= prev_cresKB)
	    continue;

	  /* NOTE : Previously skipped if NOT separated by at least cresKB from neighboring sites */
	  /* 
	     if(I > 1 && Y[I] - Y[I-1] <= cresKB)
	     continue;
	     if(I+1 < N && Y[I+2] - Y[I+1] <= cresKB)
	     continue; */
      
	  int iL = nmap[MD][I];
	  int iR = nmap[MD][I+1];
	  if(DEBUG) assert(iL >= 1 && iR >= iL && iR <= n);
	  if(DEBUG) assert(!Hdel[iL]);
	  if(DEBUG) assert(!Hdel[iR]);
	  if(skip[iL] || skip[iR]){// skip frozen regions with skip[i] == 2
	    if(VERB>=2){
	      printf("\t skipping check due to skip[iL=%d]= %d, skip[iR=%d]= %d (Frozen region)\n",iL,skip[iL],iR,skip[iR]);
	      fflush(stdout);
	    }
	    continue;
	  }

	  /* count number of molecules that have separate sites aligned to Y[I] and Y[I+1] */
	  int cnt = 0, ccnt = 0, bcnt = 0;
	  // HERE HERE : multithread ?
	  for(int m = 0; m < MD; m++){
	    int M = MX[m];
	    int J = 1;
	    for(; J <= M; J++){
	      if(DEBUG>=2) assert(nmap[m][J] == -1 || (1 <= nmap[m][J] && nmap[m][J] <= N && nmapK[m][J] >= 0 && nmapK[m][J] <= KMAX && nmap[m][J] > nmapK[m][J]));
	      if(nmap[m][J] >= I)
		break;
	    }
	    int J1 = J;
	    int left = (J <= M && nmap[m][J] >= I && nmap[m][J] - nmapK[m][J] <= I) ? J : 0;
	    if(!CRES_CNT_FIX)
	      J++;
	    for(; J <= M; J++){
	      if(DEBUG>=2) assert(nmap[m][J] == -1 || (1 <= nmap[m][J] && nmap[m][J] <= N && nmapK[m][J] >= 0 && nmapK[m][J] <= KMAX && nmap[m][J] > nmapK[m][J]));
	      if(nmap[m][J] >= I+1)
		break;
	    }
	    int J2 = J;
	    int right = (J <= M && nmap[m][J] >= I+1 && nmap[m][J] - nmapK[m][J] <= I+1) ? J : 0;
	    int both = (J <= M && nmap[m][J] >= I+1 && nmap[m][J] - nmapK[m][J] <= I) ? J : 0;
	    if(both){
	      if(DEBUG && CRES_CNT_FIX) assert(left || right);
	      bcnt++;
	    }
	    if(left && right && (!CRES_CNT_FIX || left != right))
	      cnt++;
	    if(left || right){
	      ccnt++;

	      if(VERB>=3){
		printf(" I=%d,N=%d,M=%d:m=%d/%d,left=%d(J1=%d),right=%d(J2=%d),both=%d:nmap[m][J1]=%d,nmapK[m][J1]=%d,nmap[m][J2]=%d,nmapK[m][J2]=%d:cnt=%d/%d/%d,WT= %0.6f,TB=%0.6f\n",
		       I,N,M,m,MD,left,J1,right,J2, both, nmap[m][J1],nmapK[m][J1],nmap[m][J2],nmapK[m][J2],cnt,ccnt,bcnt,mapWT[m],TBmapWT[m]);
		fflush(stdout);
	      }
	    }
	  }
	  int ccntF = (int) floor(ccnt * cresF + 0.5);
	  if(VERB>=2){
	    printf("\t mol cnt=%d/%d+%d : cresN=%d,cresF= %0.2f : skipping check\n",
		   cnt,ccnt,bcnt,cresN,cresF);
	    fflush(stdout);
	  }
	  if(cnt < max(cresN, ccntF)){

	    /* save original Hcuts[iL .. iR] */
	    memcpy(&origHcuts[iL],&Hcuts[iL],(iR-iL)*sizeof(double));// HERE HERE : redundant ???

	    int bestChange = cresFix ? -1 : 3;/* 0 or -1 means no change, 1 means delete Hcuts[iL], 2 means delete Hcuts[iR], 3 means merge Hcuts[iL,iR] : All cases except 0 will require nmap[] to be recomputed */
	    double bestLP = LPend - 10000.0;
	    double LPnew;
	    int newN;

	    if(cresFix){// NEW42
	      /* First try to just remove left label Hcuts[iL] */
	      if(DEBUG) assert(Hdel[iL] == 0);
	      Hdel[iL] = 1;
	      
	      newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */	
	      score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	      LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,bestLPA,Hcuts[iL-1],Hcuts[iR],0,0,pcontig); 
	      if(LPnew > bestLP){
		bestChange = 1;
		bestLP = LPnew;
	      }
	      if(VERB/* HERE HERE >=2 */){
		printf("Testing Deleting Hcuts[%d]=%0.4f, keeping Hcuts[%d]=%0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP= %0.6f -> %0.6f(delta= %0.6f),N=%d\n",
		       iL,origHcuts[iL],iR,origHcuts[iR],origHcuts[iR]-origHcuts[iL],cnt,ccnt,bcnt,LPend,LPnew,LPnew-LPend,newN);
		fflush(stdout);
	      }
	      Hdel[iL] = 0;

	      /* Next try to just remove right label Hcuts[iR] */
	      if(DEBUG) assert(Hdel[iR] == 0);
	      Hdel[iR] = 1;

	      newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */	
	      score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	      LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,bestLPA,Hcuts[iL-1],Hcuts[iR],0,0,pcontig); 
	      if(LPnew > bestLP){
		bestChange = 2;
		bestLP = LPnew;
	      }
	      if(VERB/* HERE HERE >=2 */){
		printf("Testing keeping Hcuts[%d]=%0.4f, deleting Hcuts[%d]=%0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP= %0.6f -> %0.6f(delta= %0.6f),N=%d\n",
		       iL,origHcuts[iL],iR,origHcuts[iR],origHcuts[iR]-origHcuts[iL],cnt,ccnt,bcnt,LPend,LPnew,LPnew-LPend,newN);
		fflush(stdout);
	      }
	      Hdel[iR] = 0;

	      /* Finally try merging both sites */
	      for(int i = iL; i < iR; i++)
		Hcuts[i] = 0.5*(Hcuts[i] + Hcuts[iR]);
	      Hdel[iR] = 1;
	      
	      newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */	
	      score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	      LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,bestLPA,Hcuts[iL-1],Hcuts[iR],0,0,pcontig); 
	      if(LPnew > bestLP){
		bestChange = 3;
		bestLP = LPnew;
	      }
	      if(VERB/* HERE HERE >=2 */){
		printf("Testing Merging Hcuts[%d]=%0.4f, Hcuts[%d]=%0.4f into %0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP= %0.6f -> %0.6f(delta= %0.6f),N=%d\n",
		       iL,origHcuts[iL],iR,origHcuts[iR],Hcuts[iL], origHcuts[iR]-origHcuts[iL],cnt,ccnt,bcnt,LPend,LPnew,LPnew-LPend,newN);
		fflush(stdout);
	      }

	      if(bestChange > 0 && cresMaxLPdrop >= 0.0 && bestLP < LPend - cresMaxLPdrop){// NEW12
		if(VERB/* HERE HERE >=2 */){
		  printf("skipping Merging labels due to -cresMaxLPdrop %0.3f (best delta = %0.6f)\n",cresMaxLPdrop, bestLP - LPend);
		  fflush(stdout);
		}
		bestChange = -1;
		bestLP = LPend;
	      }

	      /* HERE HERE : postpone actually merging labels until all merges have been determined based on original nmap[] values : 
		 This avoids having to repeatedly update nmap[] values which is expensive. However there is a risk of incorrectly handling nearby merges (this is not being handled
	         optimally already since merges are checked from left to right within the same cres range). Consider doing the pending merges (and hence nmap[] updates) anytime the next merge
		 is close to a pending merge. Consider first sorting all possible merges (within current cres range) from smallest to largest, instead of doing them left to right.
	      */

	      /* update Hcuts[] to match bestChange */
	      if(bestChange < 3){
		memcpy(&Hcuts[iL],&origHcuts[iL],(iR-iL)*sizeof(double));
		Hdel[iL] = Hdel[iR] = 0;
	      }
	      if(bestChange == 1)
		Hdel[iL] = 1;
	      if(bestChange == 2)
		Hdel[iR] = 1;
	      
	      if(DEBUG) assert(bestChange != 0);

	      if(bestChange){
		newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */	
		score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
		
		if(bestChange > 0)
		  /* NOTE: see comment with haplotype version stating that nmap[] needs to be updated for all maps to the right of the point of change to reflect label deletions in Y
		     It may be possible to do a one sided incremental updating (saving around half the molecule alignments for molecules left of point of label deletion */
		  LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
		else /* NEW75 : no need to update nmap */
		  LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,bestLPA,Hcuts[iL-1],Hcuts[iR],0,0,pcontig);		  
	      } 

	    } else {// !cresFix 

	      for(int i = iL; i < iR; i++)
		Hcuts[i] = 0.5*(Hcuts[i] + Hcuts[iR]);
	      Hdel[iR] = 1;

	      newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */	
	      score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */

	      /* NOTE: see comment with haplotype version stating that nmap[] needs to be updated for all maps to the right of the point of change to reflect label deletions in Y
		 It may be possible to do a one sided incremental updating (saving around half the molecule alignments for molecules left of point of label deletion */
	      LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 

	    }// !cresFix

	    if(VERB){
	      if(TIME_VERBOSE){
		double mt1 = mtime(),wt1 = wtime();
		
		if(bestChange >= 3)
		  printf("Merging Hcuts[%d]=%0.4f,Hcuts[%d]=%0.4f into %0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP = %0.9f -> %0.9f,N=%d: CPU time= %0.6f, wall= %0.6f (cum wall time= %0.6f)\n",
			 iL,origHcuts[iL],iR,origHcuts[iR],Hcuts[iL], origHcuts[iR]-origHcuts[iL], cnt, ccnt, bcnt, LPend, LPnew, newN,mt1-mt,wt1-wt,wt1);
		else if(bestChange == 1)
		  printf("Deleted Hcuts[%d]=%0.4f, keeping Hcuts[%d]=%0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP = %0.9f -> %0.9f,N=%d: CPU time= %0.6f, wall= %0.6f (cum wall time= %0.6f)\n",
			 iL,origHcuts[iL],iR,origHcuts[iR], origHcuts[iR]-origHcuts[iL], cnt, ccnt, bcnt, LPend, LPnew, newN,mt1-mt,wt1-wt,wt1);
		else if(bestChange == 2)
		  printf("Keeping Hcuts[%d]=%0.4f, deleting Hcuts[%d]=%0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP = %0.9f -> %0.9f,N=%d: CPU time= %0.6f, wall= %0.6f (cum wall time= %0.6f)\n",
			 iL,origHcuts[iL],iR,origHcuts[iR], origHcuts[iR]-origHcuts[iL], cnt, ccnt, bcnt, LPend, LPnew, newN,mt1-mt,wt1-wt,wt1);
		else if(bestChange <= 0)
		  printf("NOT merging Hcuts[%d]=%0.4f, Hcuts[%d]=%0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP = %0.9f -> %0.9f,N=%d: CPU time= %0.6f, wall= %0.6f (cum wall time= %0.6f)\n",
			 iL,origHcuts[iL],iR,origHcuts[iR], origHcuts[iR]-origHcuts[iL], cnt, ccnt, bcnt, LPend, LPnew, newN,mt1-mt,wt1-wt,wt1);
		mt = mt1;
		wt = wt1;
	      } else {		
		if(bestChange >= 3)
		  printf("Merging Hcuts[%d]=%0.4f,Hcuts[%d]=%0.4f into %0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP = %0.9f -> %0.9f,N=%d\n",
			 iL,origHcuts[iL],iR,origHcuts[iR],Hcuts[iL], origHcuts[iR]-origHcuts[iL], cnt, ccnt, bcnt, LPend, LPnew, newN);
		else if(bestChange == 1)
		  printf("Deleted Hcuts[%d]=%0.4f, keeping Hcuts[%d]=%0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP = %0.9f -> %0.9f,N=%d\n",
			 iL,origHcuts[iL],iR,origHcuts[iR], origHcuts[iR]-origHcuts[iL], cnt, ccnt, bcnt, LPend, LPnew, newN);
		else if(bestChange == 2)
		  printf("Keeping Hcuts[%d]=%0.4f, deleting Hcuts[%d]=%0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP = %0.9f -> %0.9f,N=%d\n",
			 iL,origHcuts[iL],iR,origHcuts[iR], origHcuts[iR]-origHcuts[iL], cnt, ccnt, bcnt, LPend, LPnew, newN);
		else if(bestChange <= 0)
		  printf("Not merging Hcuts[%d]=%0.4f, Hcuts[%d]=%0.4f (gap= %0.5f, mol cnt=%d/%d+%d): LP = %0.9f -> %0.9f,N=%d\n",
			 iL,origHcuts[iL],iR,origHcuts[iR], origHcuts[iR]-origHcuts[iL], cnt, ccnt, bcnt, LPend, LPnew, newN);
	      }
	      fflush(stdout);
	    }

	    /* update origHcuts[] */
	    memcpy(origHcuts,Hcuts,(n+2)*sizeof(double));// HERE HERE memcpy(&origHcuts[iL],&Hcuts[iL], (iR-iL)*sizeof(double));

	    N = newN;
	    LPend = LPnew;

	    if(DEBUG>=2){
	      for(int I = 1; I < N; I++)
		if(DEBUG && (!(Y[I+1]-Y[I] >= mergeKB - 2e-9) || (360 <= I && I==380))){
		  printf("I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, mergeKB=%0.6f,minKB=%0.6f\n",
			 I,Y[I],Y[I+1], Y[I+1]-Y[I], mergeKB, minKB);
		  fflush(stdout);
		  assert(Y[I+1]-Y[I] >= mergeKB - 2e-9);
		}
	      assert(Y[1] >= Y[0]);
	      assert(Y[N+1] >= Y[N]);
	    }

	    if(bestChange >= 1){
	      I--;
	      // NOTE : Y[I+1] is now the newly merged/shifted site that will be compared with Y[I+2] in the next iteration 
	    }
	  } else if(VERB>=2){
	    printf("NOT merging Hcuts[%d]=%0.4f,Hcuts[%d]=%0.4f (gap= %0.5f) : mol cnt=%d/%d/%d, cresN=%d,cresF=%0.3f\n", 
		   iL, origHcuts[iL],iR,origHcuts[iR], origHcuts[iR] - origHcuts[iL], cnt, ccnt, bcnt, cresN,cresF);
	    fflush(stdout);
	  }
	}

	if(MERGE_FAST>=2){/* do full qprobeval */
	  N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	  double LPnew =  qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
	  if(DEBUG>=1+RELEASE && fabs(LPnew - LPend) > 1e-10){
	    double mt1 = mtime(), wt1 = wtime();
	    printf("WARNING: After Merging Hcuts[]: LP = %0.10f -> %0.10f (err= %0.10f): CPU time= %0.6f, wall= %0.6f (cum wall time=%0.6f)\n", LPend, LPnew, LPend-LPnew, mt1-mt, wt1-wt,wt1);
	    fflush(stdout);
	    if(DEBUG>=1+RELEASE) assert(fabs(LPnew-LPend) <= 1e-3);
	    mt = mt1;
	    wt = wt1;
	  }
	  LPend = LPnew;
	}

	if(origN != N && cresRefine>=1){   /* update Sizing only */
	  // HERE HERE : consider setting RefineMinRange1 = RefineMinRange2 AND RefineMaxRange1 = RefineMaxRange2 to speed up refinement

	  double origZERO_MINKB = ZERO_MINKB;
	  ZERO_MINKB = 0.0;
	  minKB = ZERO_MINKB ? ZERO_MINKB /* WAS45 0.001 * PixelLen */ : rres * 0.500;/* score_init() will now compute the same value, when called before mprobeval() */

	  if(DEBUG>=2){
	    for(int I = 1; I < N; I++)
	      if(DEBUG && (!(Y[I+1]-Y[I] >= minKB - 2e-9) || (360 <= I && I <= 380))){
		printf("Before Calling SizesEstimate:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
		       I,Y[I],Y[I+1], Y[I+1]-Y[I], minKB);
		fflush(stdout);
		assert(Y[I+1]-Y[I] >= minKB - 2e-9);
	      }
	    assert(Y[1] >= Y[0]);
	    assert(Y[N+1] >= Y[N]);
	  }

	  double LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
      
	  if(DEBUG){  /* make sure no real cuts are closer than minKB */
	    int NN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	    assert(NN==N);
	    for(int I = 1; I < N; I++)
	      if(DEBUG && !(Y[I+1]-Y[I] >= mergeKB - 2e-9)){
		printf("After SizesEstimate:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, mergeKB=%0.6f,minKB=%0.6f\n",
		       I,Y[I],Y[I+1], Y[I+1]-Y[I], mergeKB, minKB);
		fflush(stdout);
		assert(Y[I+1]-Y[I] >= mergeKB - 2e-9);
	      }
	    assert(Y[1] >= Y[0]);
	    assert(Y[N+1] >= Y[N]);
	  }
	  if(VERB){
	    printf("After removing %d nearby site pairs due to -cres %0.2f (and optimizing sizes): LP= %0.6f -> %0.6f : cum wall time= %0.6f\n", origN-N, cres, LPend, LP, wtime());
	    fflush(stdout);
	  }
	  LPend = LP;
	  origN = N;

#if 0 // DEBUG code : check if calling SizesEstimate again makes a difference : if it is large, SizesEstimate() is failing to converge correctly */
	  double LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
	  if(VERB){
	    printf("After calling SizesEstimate() again (1) : LP= %0.6f -> %0.6f : cum wall time= %0.6f\n", LPend, LP, wtime());
	    fflush(stdout);
	  }
	  LPend = LP;

	  LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
	  if(VERB){
	    printf("After calling SizesEstimate() again (2) : LP= %0.6f -> %0.6f : cum wall time= %0.6f\n", LPend, LP, wtime());
	    fflush(stdout);
	  }
	  LPend = LP;

	  LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
	  if(VERB){
	    printf("After calling SizesEstimate() again (3) : LP= %0.6f -> %0.6f : cum wall time= %0.6f\n", LPend, LP, wtime());
	    fflush(stdout);
	  }
	  LPend = LP;
#endif
	  ZERO_MINKB = origZERO_MINKB;
	} // if(origN != N && cresRefine >= 1)
      } // for (cresKB = )

      /* next check any 3 consecutive sites closer than cres */
      /* HERE */

      if(origNN != N && cresRefine >= 0){   /* update Sizing only : previously only used if -cresRefine 0 */

	double origZERO_MINKB = ZERO_MINKB;
	ZERO_MINKB = 0.0;
	minKB = ZERO_MINKB ? ZERO_MINKB /* WAS45 0.001 * PixelLen */ : rres * 0.500;/* score_init() will now compute the same value, when called before mprobeval() */

	if(DEBUG>=2){
	  for(int I = 1; I < N; I++)
	    if(DEBUG && (!(Y[I+1]-Y[I] >= minKB - 2e-9) || (360 <= I && I <= 380))){
	      printf("Before Calling SizesEstimate:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
		     I,Y[I],Y[I+1], Y[I+1]-Y[I], minKB);
	      fflush(stdout);
	      assert(Y[I+1]-Y[I] >= minKB - 2e-9);
	    }
	  assert(Y[1] >= Y[0]);
	  assert(Y[N+1] >= Y[N]);
	}

	double LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
      
	if(DEBUG){  /* make sure no real cuts are closer than minKB */
	  int NN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	  assert(NN==N);
	  for(int I = 1; I < N; I++)
	    if(DEBUG && !(Y[I+1]-Y[I] >= mergeKB - 2e-9)){
	      printf("After SizesEstimate:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, mergeKB=%0.6f,minKB=%0.6f\n",
		     I,Y[I],Y[I+1], Y[I+1]-Y[I], mergeKB, minKB);
	      fflush(stdout);
	      assert(Y[I+1]-Y[I] >= mergeKB - 2e-9);
	    }
	  assert(Y[1] >= Y[0]);
	  assert(Y[N+1] >= Y[N]);
	}
	if(VERB){
	  printf("After removing %d nearby site pairs due to -cres %0.2f: LP= %0.6f -> %0.6f : cum wall time= %0.6f\n", origN-N, cres, LPend, LP, wtime());
	  fflush(stdout);
	}
	LPend = LP;
	origN = N;

#if 1
	// Do one extra call to SizesEstimate since label deres can cause major disruption
	LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
	if(VERB){
	  printf("After calling SizesEstimate() again (1) : LP= %0.6f -> %0.6f : cum wall time= %0.6f\n", LPend, LP, wtime());
	  fflush(stdout);
	}
	LPend = LP;
#endif

#if 0 /* check if calling SizesEstimate again makes a difference : if it is large, SizesEstimate() is failing to converge correctly */
	LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
	if(VERB){
	  printf("After calling SizesEstimate() again (2) : LP= %0.6f -> %0.6f : cum wall time= %0.6f\n", LPend, LP, wtime());
	  fflush(stdout);
	}
	LPend = LP;

	LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
	if(VERB){
	  printf("After calling SizesEstimate() again (3) : LP= %0.6f -> %0.6f : cum wall time= %0.6f\n", LPend, LP, wtime());
	  fflush(stdout);
	}
	LPend = LP;
#endif
	ZERO_MINKB = origZERO_MINKB;
      }
    }

    delete [] origHcuts;
  }

  if(ERRPLOT){
    rverb = 1;
    double LP;
    LP = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,1,failed,mapupdated,Lfrozen,Rfrozen); 

    if(0 /* ERRPLOT >= 2*/){
      double newsize = 6.637*500.0/531.0;
      double oldsize = Hcuts[365]-Hcuts[362];
      printf("Changing interval Hcuts[362..365]=%0.3f..%0.3f from size=%0.3f to %0.3f, original LP=%0.6f\n",
	     Hcuts[362],Hcuts[365],oldsize,newsize,LP);
      fflush(stdout);

      register double delta = newsize - oldsize;
      for(register int k = 365; k <= n+1; k++)
	Hcuts[k] += delta;
      N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
      double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
      LP = SizesEstimate(qLP,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,1,failed,mapupdated,Lfrozen,Rfrozen); 

      printf("After changing interval Hcuts[362..365] New qLP=%0.6f,LP=%0.6f\n",qLP,LP);
      fflush(stdout);
    }
    
    rverb = 0;
    LP = LPend;

    if(VERB>=2){
      N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
      if(LVERB>=2)
	rverb = 1;
      LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
      rverb = 0;
      if(VERB>=2){
	printf("Before testing deletion: LP=%0.6f(LPend=%0.6f)\n",LP,LPend);
	fflush(stdout);
      }

      for(register int I= 1; I <= N; I++){
	register int i = nmap[MD][I];
	if(i >= 1){
	  if(Hdel[i])
	    break;
	  if(VERB>=2){
	    printf("deleting Y[%d]=%0.6f,Hcuts[%d]=%0.6f:",I,Y[I], i,Hcuts[i]);
	    fflush(stdout);
	  }

	  if(LVERB>=2 && (I==119 || I==121)){
	    rverb = 1;
	    printf("\n");
	    fflush(stdout);
	  }

	  Hdel[i] = 1;
	  N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	  score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	  register double LPnew = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 

	  if(VERB>=2){
	    printf("LP=%0.10f -> %0.10f,N=%d\n", LP, LPnew, N);
	    fflush(stdout);
	  }

	  int IR = 121;
	  int iR = nmap[MD][IR];
	  if(LVERB>=2 && I==119 && iR >= 1 && Hdel[iR] == 0){
	    if(VERB>=2){
	      printf("Also deleting Y[%d]=%0.6f,Hcuts[%d]=%0.6f:\n",IR,Y[IR], iR, Hcuts[iR]);
	      fflush(stdout);
	    }
	    Hdel[iR] = 1;
	    N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	    score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	    double LPnew2 = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
	    if(VERB>=2){
	      printf("LP=%0.10f -> %0.10f,N=%d\n", LP,LPnew2, N);
	      fflush(stdout);
	    }
	    Hdel[iR] = 0;
	  }

	  rverb = 0;

	  
	  Hdel[i] = 0;
	  N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	  score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	}
      }
    }

    N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
    score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */

    LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);       
    if(VERB>=2){
      printf("final LP=%0.6f,N=%d\n",LP,N);
      fflush(stdout);
    }
  }

  // New way to pass final map information to output_draft() : this preserves the full sitecnt[] information (useful for debugging -contigsplit) and simplifies haplotype output */
  pcontig->Hdel[0] = Hdel;
  pcontig->HapSite[0] = NULL;

  if(Refine>=2 && HapSitePvalue > 0.0){
    int nN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
    //    rverb = 1;
    double LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,pcontig->logPV/* HERE 0 */,pcontig->outlier[0]/* HERE 0 */,pcontig);
    //    rverb = 0;

    /* NOTE: -Erefine is disabled before calling HaploType, but -PoutlierEndFinal, biasWTrefine is not disabled until Final UpdateMap */

    if((RefineEndOutlierThreshold < 2 && RefineEndOutlierWt < 1.0 && RefineEndOutlierType==0) || (extendonly && Refine >= 3)){/* recompute TBmapWT[] without -Erefine or -extonly -refine 3 */
      if(DEBUG) assert(pcontig->origmapWT != NULL);
      double origWTsum = 0.0, WTsum1 = 0.0, WTsum = 0.0;
      if(Refine >= 2 && TBcnt > 0){
	double LogPv = LogPvThresholdTB[TBcnt-1];
	double PVTB = pow(0.1,LogPv);
	for(int m = 0; m < MD; m++){
	  double PVm = pow(0.1,pcontig->logPV[m]);
	  origWTsum += TBmapWT[m];
	  WTsum1 += pcontig->origmapWT[m];
	  WTsum += TBmapWT[m] = pcontig->origmapWT[m] * PVTB/(PVTB + PVm);
	}
      } else {
	for(int m = 0; m < MD; m++){
	  origWTsum += TBmapWT[m];
	  WTsum += TBmapWT[m] = pcontig->origmapWT[m];
	}
      }

      double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,pcontig->logPV,pcontig->outlier[0],pcontig);
      if(VERB){
	printf("Terminated use of -Erefine %d %0.3f (OR -refine 3): LP=%0.6f -> %0.6f (WTsum= %0.3f -> %0.3f -> %0.3f, MD=%d):cum wall time=%0.6f\n", 
	       RefineEndOutlierThreshold,RefineEndOutlierWt, LP, nLP, origWTsum, WTsum1, WTsum,MD,wtime());
	fflush(stdout);
      }
      LP = nLP;
    }

    if(OutlierType != origOutlierType){
      OutlierType = origOutlierType;
      double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,pcontig->logPV,pcontig->outlier[0],pcontig);
      if(VERB){
	printf("Restored -outlierType %d: LP=%0.6f -> %0.6f\n", OutlierType, LP, nLP);
	fflush(stdout);
      }
      LP = nLP;
    }

    if(VERB){
      printf("Before Calling HaploType(): LP=%0.6f,N=%d,Poutlier=%0.3e,PoutlierEnd=%0.3e\n",LP,nN,Poutlier,PoutlierEnd);
      if(VERB>=3){
	for(int I = 1; I <= N; I++)
	  printf("I=%d/%d:Y[I]=%0.4f,Y[I+1]-Y[I]=%0.4f\n",I,N,Y[I],Y[I+1]-Y[I]);
	fflush(stdout);
      }
      fflush(stdout);
    }
    if(DEBUG>=2){
      for(int m = 0; m < MD; m++){
	int M = MX[m];

	/* check map[m][J],mapK[m][J] for consistency */
	int lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  int i = map[m][J];
	  if(i < 0)
	    continue;
	  int k = mapK[m][J];
	  if(DEBUG &&  !(0 <= k && k < i)){
	    printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
	  }
	  if(lasti >= 0 && !(i-k > lasti)){
	    printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[m][j];
		if(i < 0)
		  continue;
		int k = mapK[m][j];
		printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	      }
	    }
	    fflush(stdout);
	    assert(i-k > lasti);
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
	}
      }
    }
    double LPhap = HaploType(n, Hcuts, Hdel, 0, 0, MD, MX, X, map, mapK, TBmapWT, pcontig, skip, Lfrozen, Rfrozen);/* HaploTypes will be in pcontig->HaploType[0..1] (if found) */
    
    if(VERB){
      printf("After calling HaploType() : LP = %0.6f -> %0.6f\n",LP,LPhap);
      if(VERB>=2){
	printf("pcontig=%p,pcontig->HapDelta[0]=%p,n=%d\n",pcontig,pcontig->HapDelta[0],n);
	fflush(stdout);
      }
      fflush(stdout);
    }
    /* NOTE : final UpdateMap() for each allele (followed by output_draft) is completed in HaploType
       Then final UpdateMap() for Hmap or single Cmap is called below */

  } 

  if(pcontig->HapSite[0] == NULL){/* non-haplotype refinement OR haplotype refinement failed to produce seperate Alleles */

    if(VERB>=2){
      int nN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      //      rverb = 1;
      score_init(nN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */

      if(VERB>=3){
	printf("After non-haplotype return: nN=%d,n=%d\n",nN,n);
	for(int k = 1; k <= n; k++)
	  if(!Hdel[k])
	    printf("Hcuts[%d]= %0.3f\n",k, Hcuts[k]);
	for(int I = 1; I <= nN; I++)
	  printf("Y[%d]= %0.3f\n",I,Y[I]);
	fflush(stdout);
      }

      //    rverb = (CMapID == 9992 ? 1 : 0);
    
      double LP = qprobeval(n,Hcuts,nN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,pcontig->logPV,pcontig->outlier[0],pcontig);
      rverb = 0;

      if(VERB){
	printf("After return from HaploType : LP=%0.6f,N=%d->%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f: MD=%d\n",LP,N,nN,Y[1],Y[nN],Y[nN+1],MD);
	//      printf("Before Final UpdateMap: LP=%0.6f,N=%d->%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f:pcontig->outlier[0]=%p,CMapID=%lld\n",LP,N,nN,Y[1],Y[nN],Y[nN+1],pcontig->outlier[0],CMapID);
	fflush(stdout);
      }
    }

    rverb = (LVERB >=2 ? 1 : 0);

    if(PoutlierEnd < PoutlierEndFinal){
      if(VERB){
	printf("Before Final UpdateMap(): PoutlierEnd = %0.3e->%0.3e, RANGE_Y=%d\n", PoutlierEnd,PoutlierEndFinal,RANGE_Y2);
	fflush(stdout);
      }
      PoutlierEnd = PoutlierEndFinal;

      //      score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd, Poutlier OR biasWT*/
    }
    
    if(biasWTrefine != biasWT){
      if(VERB){
	printf("Restored biasWT= %0.6f -> %0.6f for final UpdateMap()\n",biasWT,biasWTrefine);
	fflush(stdout);
      }
      biasWT = biasWTrefine;
      //      score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd, Poutlier OR biasWT */
    }

    //  RANGE_Y = RANGE_Y2;
    int nN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
    score_init(nN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */

    if(VERB>=2){
      printf("After non-haplotype return: n=%d\n",n);
      for(int k = 1; k <= n; k++)
	if(!Hdel[k])
	  printf("Hcuts[%d]= %0.3f\n",k, Hcuts[k]);
      for(int I = 1; I <= nN; I++)
	printf("Y[%d]= %0.3f\n",I,Y[I]);
      fflush(stdout);
    }

    //    rverb = (CMapID == 9992 ? 1 : 0);
    
    double LP = qprobeval(n,Hcuts,nN,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,pcontig->logPV,pcontig->outlier[0],pcontig);
    rverb = 0;

    if(VERB){
      printf("Before Final UpdateMap: LP=%0.6f,N=%d->%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f: MD=%d\n",LP,N,nN,Y[1],Y[nN],Y[nN+1],MD);
      //      printf("Before Final UpdateMap: LP=%0.6f,N=%d->%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f:pcontig->outlier[0]=%p,CMapID=%lld\n",LP,N,nN,Y[1],Y[nN],Y[nN+1],pcontig->outlier[0],CMapID);
      fflush(stdout);
    }
    //    rverb = 0;

    N = nN;

    if((RefineEndOutlierThreshold < 2 && RefineEndOutlierWt < 1.0 && RefineEndOutlierType==0) || (extendonly && Refine>=3)){/* recompute TBmapWT[] without -Erefine (or -extonly -refine 3) */
      if(DEBUG) assert(pcontig->origmapWT != NULL);
      double origWTsum = 0.0, WTsum1 = 0.0, WTsum = 0.0;
      if(Refine >= 2 && TBcnt > 0){
	double LogPv = LogPvThresholdTB[TBcnt-1];
	double PVTB = pow(0.1,LogPv);
	for(int m = 0; m < MD; m++){
	  double PVm = pow(0.1,pcontig->logPV[m]);
	  if(VERB>=2 && gmap[pcontig->contig[m].mapid]->id == 606895LL){
	    printf("m=%d,id=%lld:logPV=%0.2f,TB=%0.2f:TBmapWT[m] = %0.6f -> %0.6f -> %0.6f, mapWT[m]=%0.6f\n",
		   m, gmap[pcontig->contig[m].mapid]->id, pcontig->logPV[m],LogPv,TBmapWT[m],pcontig->origmapWT[m], pcontig->origmapWT[m] * PVTB/(PVTB+PVm),mapWT[m]);
	    fflush(stdout);
	  }
	  origWTsum += TBmapWT[m];
	  WTsum1 += pcontig->origmapWT[m];
	  WTsum += TBmapWT[m] = pcontig->origmapWT[m] * PVTB/(PVTB + PVm);
	}
      } else {
	for(int m = 0; m < MD; m++){
	  if(VERB>=2 && gmap[pcontig->contig[m].mapid]->id == 1666611LL){
	    printf("m=%d,id=%lld:TBmapWT[m] = %0.6f -> %0.6f,mapWT[m]=%0.6f\n",m, gmap[pcontig->contig[m].mapid]->id, TBmapWT[m],pcontig->origmapWT[m], mapWT[m]);
	    fflush(stdout);
	  }
	  origWTsum += TBmapWT[m];
	  WTsum += TBmapWT[m] = pcontig->origmapWT[m];
	}
      }
      double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,pcontig->logPV,pcontig->outlier[0],pcontig);
      if(VERB){
	if(Refine >= 2 && TBcnt > 0)
	  printf("Terminated use of -Erefine %d %0.3f (or -refine 3) with -TB %0.2f : LP=%0.6f -> %0.6f (WTsum= %0.3f -> %0.3f -> %0.3f, MD=%d):cum wall time= %0.6f\n", 
		 RefineEndOutlierThreshold,RefineEndOutlierWt, LogPvThresholdTB[TBcnt-1], LP, nLP, origWTsum, WTsum1, WTsum,MD,wtime());
	else
	  printf("Terminated use of -Erefine %d %0.3f (or -refine 3) : LP=%0.6f -> %0.6f (WTsum= %0.3f -> %0.3f, MD=%d):cum wall time= %0.6f\n", 
		 RefineEndOutlierThreshold,RefineEndOutlierWt, LP, nLP, origWTsum, WTsum,MD,wtime());
	fflush(stdout);
      }
      LP = nLP;
    }

    /* merge TBmapWT[] with mapWT[] */
    for(int m = 0; m < MD; m++){
      double origPmapWT = pcontig->mapWT[m];
      if(HapMapWT >= 3)
	pcontig->mapWT[m] = 1.0;
      else if(HapMapWT >= 2)
	pcontig->mapWT[m] = mapWT[m];
      else
	pcontig->mapWT[m] = mapWT[m] * TBmapWT[m];

      if((VERB>=2 && gmap[pcontig->contig[m].mapid]->id == 1666611LL) || (DEBUG && !(isfinite(mapWT[m]) && isfinite(TBmapWT[m]) && isfinite(pcontig->mapWT[m])))){
	printf("m=%d/%d:id=%lld:TBmapWT[m] = %0.6f, mapWT[m] = %0.6f, pcontig->mapWT[m] = %0.6f -> %0.6f (HapMapWT=%d)\n",
	       m, MD, gmap[pcontig->contig[m].mapid]->id, TBmapWT[m], mapWT[m], origPmapWT, pcontig->mapWT[m],HapMapWT);
	fflush(stdout);
	if(DEBUG) assert(isfinite(mapWT[m]) && isfinite(TBmapWT[m]) && isfinite(pcontig->mapWT[m]));
      }

      mapWT[m] = pcontig->mapWT[m];
    }

    /* update pcontig->fragcnt coverage profile */

    //    updateVerb = (CMapID == 3603) ? 1 : 0;
    UpdateMap(n, N, Y, MD, MX, X, Hcuts, Hdel, map, mapK, limit,nmap, nmapK, mapWT, pcontig, FILL_MAP);
    updateVerb = 0;

    if(DEBUG>=2){/* check that map[m] and mapK[m] only map to sites i with Hdel[i] == 0 */
      for(int m = 0; m < MD; m++){
	int M = MX[m];
	for(int J = 1; J <= M; J++){
	  int i = map[m][J];
	  if(i >= 0){
	    assert(Hdel[i] == 0);
	    int k = mapK[m][J];
	    assert(k >= 0 && i-k > 0 && Hdel[i-k] == 0);
	  }
	}
      }
    }

    if(LVERB>=2){
      rverb = 1;
      printf("After Final UpdateMap():\n");
      int nN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      double LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
      if(VERB>=2){
	printf("After Final UpdateMap: LP=%0.6f,N=%d\n",LP,nN);
	printf("final LP=%0.6f,N=%d\n",LP,nN);
	fflush(stdout);
      }
      rverb = 0;
    }

    if(VERB>=2){
      int nN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      double LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,0,0,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);

      printf("After Final UpdateMap():LP=%0.6f,N=%d\n",LP,nN);
      for(register int m = 0; m < MD; m++){
	printf("m=%d:mapid=%d,id=%lld:M=%d,N=%d,WT=%0.6f,LP=%0.3f\n",m,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,MX[m],N, mapWT[m], bestLPA[m]);
	for(register int J = 0; J <= MX[m]+1; J++){
	  register int I = nmap[m][J];
	  if(I<0)
	    continue;
	  register int K = nmapK[m][J];
	  printf("  I=%d,K=%d,J=%d:Y[I-K]=%0.3f,Y[I]=%0.3f,X[J]=%0.3f\n",I,K,J, Y[I-K],Y[I],X[m][J]);
	}
      }
      fflush(stdout);
    }

    if(VERB>=2 || LVERB){
      printf("Final Consensus:n=%d,COVERAGE_TRIM=%d,COVERAGE_TRIM_LEN=%0.1f,TrimNorm=%0.1f\n",n,COVERAGE_TRIM,COVERAGE_TRIM_LEN,TrimNorm);
      register int k;
      if(CovNorm){
	if(TrimNorm>=0){
	  for(k=1; k <= n; k++)
	    printf("k=%d:Hdel[k]=%d,site[k]=%0.3f,sitecnt[k]=%0.1f,sitecntFN[k]=%0.1f(norm=%0.1f),fragcnt[k-1]=%0.1f,fragcntT[k-1]=%0.1f,fragcntTnorm[k-1]=%0.3f kb\n",
		   k,Hdel[k],pcontig->site[0][k],pcontig->sitecnt[0][k],pcontig->sitecntFN[0][k],pcontig->sitecntFNnorm[0][k],
		   pcontig->fragcnt[0][k-1],pcontig->fragcntT[0][k-1],pcontig->fragcntTnorm[0][k-1]/max(0.001f,pcontig->fragcntT[0][k-1]));
	} else {
	  for(k=1; k <= n; k++)
	    printf("k=%d:Hdel[k]=%d,site[k]=%0.3f,sitecnt[k]=%0.1f,sitecntFN[k]=%0.1f,fragcnt[k-1]=%0.1f,fragcntT[k-1]=%0.1f,fragcntTnorm[k-1]=%0.3f kb\n",
		   k,Hdel[k],pcontig->site[0][k],pcontig->sitecnt[0][k],pcontig->sitecntFN[0][k],pcontig->fragcnt[0][k-1],pcontig->fragcntT[0][k-1],pcontig->fragcntTnorm[0][k-1]/max(0.001f,pcontig->fragcntT[0][k-1]));
	}
      } else {
	if(TrimNorm>=0){
	  for(k=1; k <= n; k++)
	    printf("k=%d:Hdel[k]=%d,site[k]=%0.3f,sitecnt[k]=%0.1f,sitecntFN[k]=%0.1f(norm=%0.1f),fragcnt[k-1]=%0.1f,fragcntT[k-1]=%0.1f\n",
		   k,Hdel[k],pcontig->site[0][k],pcontig->sitecnt[0][k],pcontig->sitecntFN[0][k],pcontig->sitecntFNnorm[0][k],pcontig->fragcnt[0][k-1],pcontig->fragcntT[0][k-1]);
	} else {
	  for(k=1; k <= n; k++)
	    printf("k=%d:Hdel[k]=%d,site[k]=%0.3f,sitecnt[k]=%0.1f,sitecntFN[k]=%0.1f,fragcnt[k-1]=%0.1f,fragcntT[k-1]=%0.1f\n",
		   k,Hdel[k],pcontig->site[0][k],pcontig->sitecnt[0][k],pcontig->sitecntFN[0][k],pcontig->fragcnt[0][k-1],pcontig->fragcntT[0][k-1]);
	}
      }
      if(DEBUG) assert(k==n+1);
      if(CovNorm)
	printf("k=%d:site[k]=%0.3f,fragcnt[k-1]=%0.1f,fragcntT[k-1]=%0.1f,fragcntTnorm[k-1]=%0.3f kb\n",
	       k,pcontig->site[0][k],pcontig->fragcnt[0][k-1],pcontig->fragcntT[0][k-1],pcontig->fragcntTnorm[0][k-1]/max(0.001f,pcontig->fragcntT[0][k-1]));
      else
	printf("k=%d:site[k]=%0.3f,fragcnt[k-1]=%0.1f,fragcntT[k-1]=%0.1f\n",
	       k,pcontig->site[0][k],pcontig->fragcnt[0][k-1],pcontig->fragcntT[0][k-1]);
      fflush(stdout);
      if(LVERB>=2){
	char buf[PATH_MAX];
	while(COVERAGE_TRIM < 5){
	  sprintf(buf,"prefixTRIM%d",COVERAGE_TRIM);
	  output_draft(pcontig,(long long)0,buf,Lfrozen,Rfrozen,0);
	  COVERAGE_TRIM++;
	  UpdateMap(n,N,Y, MD,MX,X,Hcuts,Hdel, map,mapK,limit,nmap,nmapK,mapWT,pcontig,FILL_MAP);

	  printf("\nFinal Consensus:n=%d,COVERAGE_TRIM=%d\n",n,COVERAGE_TRIM);
	  for(k=1; k <= n; k++)
	    printf("k=%d:Hdel[k]=%d,site[k]=%0.3f,sitecnt[k]=%0.1f,sitecntFN[k]=%0.1f,fragcnt[k-1]=%0.1f\n",
		   k,Hdel[k],pcontig->site[0][k],pcontig->sitecnt[0][k],pcontig->sitecntFN[0][k],pcontig->fragcnt[0][k-1]);
	  if(DEBUG) assert(k==n+1);
	  printf("k=%d:site[k]=%0.3f,fragcnt[k-1]=%0.1f\n",
		 k,pcontig->site[0][k],pcontig->fragcnt[0][k-1]);
	  fflush(stdout);
	}
      }
    }
  
    if(ERRPLOT>=2){
      printf("Huber Norm Gaussian Normalization factors as a function of transition point (delta):\n");
      for(double d = 0.5;d <= 4.001; d += 0.01){
	//      register double Norm = sqrt(2.0/M_PI)*exp(-d*d*0.5)/d + erf(d/sqrt(2.0));
	printf("delta=%0.3f: Normalization=%0.8f\n",d,NHuber(d));
      }
      fflush(stdout);
    }

    PoutlierEnd = origPoutlierEnd;/* undo effect of PoutlierEnd2 */
    score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd & Poutlier */
  }

  /* convert pcontig->sitemapL[][] into absolute values rather than offsets from pcontig->sitemap[i=0..MD-1][] */
  for(int k = 0; k < MD; k++)
    for(int j = 0; j <= MX[k]+1; j++)
      pcontig->sitemapL[0][k][j] = pcontig->sitemap[0][k][j] - pcontig->sitemapL[0][k][j];

  /* free all memory */
  delete [] DminM;
  DminM = DmaxM = TminM = TmaxM = AminM = AmaxM = 0;

  delete [] Dcum;
  delete [] newLPdelta;
  //  delete [] newLPdeltaMem;
  if(newLPdeltaMem){
    free(newLPdeltaMem);
    newLPdeltaMem = 0;
  }
  MaxDelta = 0;

  if(VMEM_MINIMIZE){
    DoubleAllocations_free();

    std::vector<double *>().swap(DoubleAllocations);
    std::vector<CdoubleAllocation *>().swap(SwappedAllocations);
  }

  if(!VMEM_MINIMIZE){
    if(MDEBUG && newLPaPr[0]) { delete [] newLPaPr[0]; newLPaPr[0] = 0;}
    if(newLPa[0]) { free(newLPa[0]); newLPa[0] = 0;}
  }

  if(MDEBUG) delete [] newLPaPr;
  delete [] newLPa;
  MaxAddcnt = 0;

  if(!VMEM_MINIMIZE){// NEW8
    if(MDEBUG) delete [] newLPdPr[0];
    delete [] newLPd[0];
  }
  if(MDEBUG) delete [] newLPdPr;
  delete [] newLPd;
  newLPd = 0;
  delete [] newLPd0;// NEW8
  newLPd0 = NULL;

  delete [] skip;
  delete [] TBmapWT;
  delete [] bestLPA;
  delete [] mapWT;
  delete [] newLPA;
  score_free();

  for(int k = 0; k < MD; k++){
    delete [] nmap[k];
    delete [] nmapK[k];// NEW
  }
  delete [] nmapK;
  delete [] &nmap[MD][-1];

  delete [] &map[MD][-1];
  delete [] map;
  delete [] limit;
  delete [] nmap;
  delete [] Y;
  delete [] MX;
#if 0 // New method pass Hdel back as contig->Hdel[0] 
  delete [] Hdel;
#endif

  delete heap;
  heap = NULL;

  pcontig->delXfree();

  biasWT = origbiasWT;
  PRbiasWT = origPRbiasWT;
  LRbias = origLRbias;
  Poutlier = origPoutlier;
  PoutlierEnd = origPoutlierEnd;
  FN[0] = origFN;
  SF[0] = origSF;
  SR[0] = origSR;
  HAP_VITERBI_WT = origViterbi;

  PoutlierEndCnt = origPoutlierEndCnt;// NEW7
  for(int i = 0; i < PoutlierEndCnt; i++){
    PoutlierRefine[i] = origPoutlierRefine[i];
    PoutlierEndRefine[i] = origPoutlierEndRefine[i];
  }

  Refine = startRefine;// NEW7
  
  DELTA_X = startDELTA_X;
  DELTA_Y = startDELTA_Y;
  RANGE = startRANGE;
  outlierLambda = startOutlierLambda;
  OutlierType = startOutlierType;
  PoutlierEndCnt = startPoutlierEndCnt;

  if(VERB>=2){
    printf("End of refine(): pcontig=%p,pcontig->HapDelta[0]=%p,n=%d\n",pcontig,pcontig->HapDelta[0],n);
    for(int i = 1; i < n; i++)
      if(pcontig->HapDelta[0][i])
	printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
    fflush(stdout);
  }

  STOP(refine);

  Refine = origRefine;
  return;
}

/** compute dynamic programming alignment bounds */
extern int setlimit(int m,/**< map id of map X (for debugging) */
		    int n, double *Hcuts, /**< sites in complete consensus Hcuts[0..n+1] : labels Hcuts[i] that are no longer present (mapMD[i] == -1) may NOT be in order */
		    int N, double *Y,/**< sites in consensus Y[0..N+1] */
		    int M, double *X,/**< sites in query map X[0..M+1] */
		    int *map,/**< mapping from query map X[J] to rightmost consensus site Hcuts[map[J]] */
		    int *mapK,/**< mapping from query map X[J] to leftmost consensus site Hcuts[map[J]-mapK[J]] */
		    Csetlimit *plimit,
		    int *mapMD,/**< mapping from Hcuts[i] to Y[I] */
		    int *nmapMD, /**< mapping from Y[I] to Hcuts[i] */
		    double Ymin, double Ymax,/**< If >= 0.0 : If X does not overlap this range +- RANGE*Xlambda, return 0 (without computing results) */
		    int &IMIN,
		    int &IMAX,
		    int *Jmin,
		    int *Jmax,
		    int *Imin,
		    int *Imax,
		    double * &JXmin,
		    double * &JXmax,
		    int * &Jmid,
		    int &IMIN1,
		    int &IMAX1,
		    Ccontig *pcontig, /**< pointer to complete contig information for debugging */
		    int force /* Only used with SETLIMIT_CACHE : If > 0, update cache values but never return 0 (cache hit) after updating cache values */
		    )
{
  /*  if(SETLIMIT_CACHE && Ymin >= 0.0 && plimit->ileft >= 0 && !force){
    double Yleft = Hcuts[plimit->ileft] - plimit->Xleft;
    double Yright = Hcuts[plimit->iright] + plimit->Xright;
    if(max(Yleft,Ymin) > min(Yright,Ymax) + 1e-6)
      return 0;
      }*/

  if(DEBUG>=2){
    for(register int I= 1; I <= N; I++){
      Jmin[I] = M+1;
      Jmid[I] = -1;
      Jmax[I] = 0;
      if(FIX_RANGE_Y && RANGE_Y == 0)
	JXmin[I] = JXmax[I] = -1e100;
    }
    for(register int J= 1; J <= M; J++){
      Imin[J] = N+1;
      Imax[J] = 0;
    }
  }

  if(GLOBAL || N <= 0){
    IMIN = 1;
    IMAX = N;
    for(int I= 1; I <= N; I++){
      Jmin[I] = 1;
      Jmax[I] = M;
      Jmid[I] = -1;
      if(FIX_RANGE_Y && RANGE_Y == 0){
	JXmin[I] = 0.0;
	JXmax[I] = X[M+1];
      }
    }
    for(int J= 1; J <= M; J++){
      Imin[J] = 1;
      Imax[J] = N;
    }

    IMIN1 = IMIN;
    IMAX1 = IMAX;

    if(DEBUG && N > 0) assert(IMIN <= IMAX);
    return 1;
  }
  
  double Ltheta = LOCAL_RANGE ? max(1.0,X[M]-X[1])/max(1,M-1) : Xtheta;

  double Ynorm = 1.0/Y[N+1];
  double Hnorm = 1.0/Hcuts[n+1];
  double Xrange = RANGE * Ltheta;/* used when FIX_RANGE_Y && RANGE_Y==0 as maximum alignment adjustment in kb */
  double Xrange2 = Xrange; /* used when FIX_RANGE_Y && RANGE_Y==0 as maximum alignment adjustment in kb during alignment extrapolation : should reflect both RANGE and max(DELTA_X,deltaExtXRef) */
  if(RefineXRange)
    //    Xrange2 += max(DELTA_X,deltaExtXRef) * Ltheta;
    Xrange2 = max(Xrange, max(DELTA_X,deltaExtXRef) * Ltheta);// WAS8 += max(DELTA_X,deltaExtXRef) * Ltheta

  if(MDEBUG_SETLIMIT && MDEBUG_M==m)
    printf("\n");

  if(DEBUG) IMIN = 1;
  IMAX = 0;
  int RI = 0, LI = N+1, RJ = 0, LJ = M+1;

  if(VERB>=3 && m==212 && 63 <= M && 4563 <= n && rverb){
    printf("\t setlimit:m=%d:map[J=63]= %d, mapK[J=63]= %d, mapMD[4563] = %d\n",m, map[63], mapK[63], mapMD[4563]);
    fflush(stdout);
  }

  if(DEBUG>=3){/* make sure map[] and mapK[] are consistent (with local cleanup) */
    int lastJ = -1, lasti = -1, lastk = -1, i, k, I, cnt = 0;
    for(int J = 1; J <= M; J++){
      if((i= map[J]) > 0 && (I = mapMD[i]) > 0){
	cnt++;
	k = mapK[J];
	assert(0 <= k && k < i);
	int origk = k;
	if(k > 0 && mapMD[i-k] <= 0)/* locally "clean up" mapK */
	  k = 0;
	if(lasti >= 0 && !(i-k > lasti)){
	  #pragma omp critical
	  {
	    printf("\nm=%d,J=%d,i=%d,k=%d->%d,I=%d:lastJ=%d,lasti=%d,lastk=%d\n",m,J,i,origk,k,I,lastJ,lasti,lastk);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[j];
		if(i < 0)
		  continue;
		int k = mapK[j];
		printf("\t j=%d:map[j]=i=%d(I=%d),mapK[j]=k=%d(I-K=%d)\n",j,i,mapMD[i],k,mapMD[i-k]);
	      }
	    }
	    fflush(stdout);
	    assert(i-k > lasti);
	  }
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }

    if(0 && MDEBUG_SETLIMIT && MDEBUG_M == m && cnt <= 0){
      printf("WARNING in setlimit: No aligned sites in map[m][] to consensus sites for m=%d(id=%lld)\n",m,gmap[pcontig->contig[m].mapid]->id);
      for(int J = 1; J <= M; J++){
	int i = map[J];
	int I = (i > 0) ? mapMD[i] : -1;
	printf("J=%d/%d:map[m][J]=i=%d,n=%d,map[MD][i]=I=%d,N=%d:Hcuts[i]= %0.4f\n",J,M,i,n,I,N,Hcuts[i]);
      }
      fflush(stdout);exit(1);
    }
  }

  if(SETLIMIT_CLEANUP >= 2){
    int lastJ = -1, lasti = -1, lastk = -1, i, k;    
    for(int J = 1; J <= M; J++){
      if((i = map[J]) > 0){
	k = mapK[J];
	assert(0 <= k && k < i);
	if(lasti >= 0 && !(i-k > lasti)){
	  if(mapMD[lasti] <= 0){/* fix lasti,lastk */
	    while(lastk > 0 && !(i-k > lasti) && mapMD[lasti] <= 0){
	      lastk--;
	      lasti--;
	    }
	    if(!(i-k > lasti))
	      map[lastJ] = -1;
	    else {
	      map[lastJ] = lasti;
	      mapK[lastJ] = lastk;
	    }
	  } else {/* fix i,k */
	    while(k > 0 && !(i-k > lasti) && mapMD[i-k] <= 0)
	      k--;
	    if(!(i-k > lasti)){
	      map[J] = -1;
	      continue;/* skip J : don't update lasti,lastk,lastJ */
	    } else
	      mapK[J] = k;
	  }
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }

    if(DEBUG>=3){/* make sure map[] and mapK[] are consistent (without local clean up) */
      int lastJ = -1, lasti = -1, lastk = -1, i, k;
      for(int J = 1; J <= M; J++){
	if((i=map[J]) > 0){
	  k = mapK[J];
	  assert(0 <= k && k < i);
	  if(lasti >= 0 && !(i-k > lasti)){
#pragma omp critical
	    {
	      printf("\nm=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d\n",m,J,i,k,lastJ,lasti,lastk);
	      if(VERB){
		for(int j = 1; j <= M; j++){
		  int i = map[j];
		  if(i < 0)
		    continue;
		  int k = mapK[j];
		  printf("\t j=%d:map[j]=i=%d(I=%d),mapK[j]=k=%d(I-K=%d)\n",j,i,mapMD[i],k,mapMD[i-k]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
	}
      }
    }
  }

  int lastR = -1;

  for(int J = 1; J <= M; J++){
    int right = map[J];
    if(right < 0)
      continue;
    if(DEBUG) assert(mapK[J] >= 0);
    int left = right - mapK[J];
    if(MDEBUG_SETLIMIT>=3 && MDEBUG_M==m)
      printf("   m=%d,N=%d,M=%d:J=%d,map[J]=%d,mapK[J]=%d,left=%d,right=%d,Hcuts[left..right]=%0.3f..%0.3f,Hcuts[left-1]=%0.3f,Hcuts[right+1]=%0.3f\n",
	     m,N,M,J,map[J],mapK[J],left,right,Hcuts[left],Hcuts[right],Hcuts[left-1],Hcuts[right+1]);
    if(DEBUG && !(1 <= left && left <= right && right <= n)){
      printf("m=%d,N=%d,M=%d:J=%d,map[J]=%d,mapK[J]=%d,left=%d,right=%d,n=%d\n",
	     m,N,M,J,map[J],mapK[J],left,right,n);
      fflush(stdout);
      assert(1 <= left && left <= right && right <= n);
    }
    int R = 0, L = N+1;/* range of sites in Y[] that are aligned to site X[J] (If none, R < L ) */
    int Ri = 0, Li = n+1;/* corresponding sites in Hcuts[] that are aligned with X[J] */

    for(int i = left; i <= right; i++){
      int I = mapMD[i];
      if(MDEBUG_SETLIMIT>=3 && MDEBUG_M==m /*&& N==MDEBUG_N+1*/)
	printf("    m=%d,J=%d,left=%d,right=%d:i=%d:mapMD[i]=%d,L=%d,R=%d,Li=%d,Ri=%d\n",
	       m,J,left,right,i,mapMD[i],L,R,Li,Ri);
      if(I>=0 && (!SETLIMIT_CLEANUP || I > lastR)){
	if(LRANGE_FIX <= 1){
	  if(!force && Ymin>=0.0){/* check overlap of X[J] with Y[I] : see if it includes the range Ymin-LRANGE*Ltheta .. Ymax + LRANGE*Ltheta */
	    if(DEBUG>=2 && !(Ymax >= Ymin && Ymax <= Y[N+1])){
	      printf("setlimit:m=%d,N=%d,M=%d:J=%d,I=%d:Ymin=%0.6f,Ymax=%0.6f,Y[N+1]=%0.6f\n",
		     m,N,M,J,I,Ymin,Ymax,Y[N+1]);
	      fflush(stdout);
	      assert(Ymax>=Ymin && Ymax <= Y[N+1]);
	    }
	    if(LRANGE_FIX){
	      double Yleft = Y[max(0,I-LRANGE)] - X[J];
	      double Yright = Y[min(N+1,I+LRANGE)] + X[M+1]-X[J];
	      /* NOTE : it is possible that Ymin == Ymax */
	      if(max(Yleft,Ymin) > min(Yright,Ymax) + 1e-6)
		return 0;
	    } else {
	      double Yleft = Y[I] - X[J];
	      double Yright = Yleft + X[M+1];
	      if(max(Yleft,Ymin-LRANGE*Ltheta) > min(Yright,Ymax+LRANGE*Ltheta) + 1e-6)
		return 0;
	    }
	    Ymin = -1.0;/* only check once */
	  }
	}
	if(LRANGE_FIX >= 2){
	  RI = max(RI,I);
	  LI = min(LI,I);
	  RJ = max(RJ,J);
	  LJ = min(LJ,J);
	}

	if(DEBUG && !(I>= 1 && I <= N)){
	  printf("setlimit:m=%d,N=%d,M=%d:J=%d,map[J]=%d,mapK[J]=%d,left=%d,right=%d\n",
		 m,N,M,J,map[J],mapK[J],left,right);
	  printf("i=%d:n=%d:mapMD[i]=I=%d\n",i,n,mapMD[i]);
	  fflush(stdout);
	  assert(I >= 1 && I <= N);
	}
	if(I > R){
	  R = I;
	  Ri = i;
	}
	if(I < L){
	  L = I;
	  Li = i;
	}
      } else if(EXTRAPOLATE) { /* locate nearest sites to Hcuts[i] in Y[] : 
				  this happens later even if !EXTRAPOLATE, but only if none of the sites Hcuts[i=left..right] have an exact match in Y[] */

	/* NOTE : this introduces a weak dependency on Hcuts[], which is not kept up to date with changes in Y[] in SizesEstimate.
	   This dependency is minimized by using normalized positions of Y[] and Hcuts[] normalized by Y[N+1] and Hcuts[n+1] */
	/* locate nearest site to left of Hcuts[i] */
	int l=N,r=N;
	for(I = 1; I < N; I++){
	  if(Y[I]*Ynorm > Hcuts[i]*Hnorm){
	    l = r = I;
	    break;
	  }
	  if(Y[I]*Ynorm < Hcuts[i]*Hnorm && Hcuts[i]*Hnorm < Y[I+1]*Ynorm){
	    l = I;
	    r = I+1;
	    break;
	  }
	}
	if(DEBUG) assert(1 <= l && l <= r && r <= N);
	if(DEBUG>=2 && l < r)  assert(Y[l]*Ynorm < Hcuts[i]*Hnorm && Hcuts[i]*Hnorm < Y[r]*Ynorm);	   
	R = max(R,r);
	L = min(L,l);
      }
    }

    if(R < L)
      continue;

    if(SETLIMIT_CLEANUP){
      if(DEBUG) assert(L > lastR);
      lastR = R;
    }

    if((MDEBUG_SETLIMIT && MDEBUG_M==m /*&& N==MDEBUG_N+1*/)  || (VERB>=2 && M==40 && m==14)){
      printf("m=%d:X[%d]=%0.3f maps to Hcuts[%d..%d]=%0.3f..%0.3f to Y[%d..%d]=%0.3f..%0.3f, N=%d\n",
	     m,J,X[J],Li,Ri,Hcuts[Li],Hcuts[Ri],L,R,Y[L],Y[R],N);

      if(MDEBUG_SETLIMIT>=3)
	for(register int i = 1; i <= n; i++){
	  register int I = mapMD[i];
	  if(I >= 0)
	    printf("  Hcuts[%d]=%0.3f maps to Y[%d]=%0.3f\n",i,Hcuts[i],I,Y[I]);
	}

      fflush(stdout);
    }
    
    if(DEBUG) assert(1 <= L && L <= R && R <= N);
      
    if(DEBUG>=3){
      int lasti = -1;
      for(register int i=IMIN; i <= IMAX;i++)
	if(Jmid[i] > 0){
	  assert(1 <= Jmid[i] && Jmid[i] <= M);
	  if(lasti >= 0 && !(Jmid[i] >= Jmid[lasti])){
#pragma omp critical
	    {
	      printf("m=%d:X[%d]=%0.3f maps to Hcuts[%d..%d]=%0.3f..%0.3f to Y[%d..%d]=%0.3f..%0.3f, N=%d\n",
		     m,J,X[J],Li,Ri,Hcuts[Li],Hcuts[Ri],L,R,Y[L],Y[R],N);
	      printf("m=%d,N=%d,M=%d,n=%d:IMIN=%d,IMAX=%d,L=%d,R=%d,J=%d:i=%d,Jmid[i]=%d,lasti=%d,Jmid[lasti]=%d\n",
		     m,N,M,n,IMIN,IMAX,L,R,J,i,Jmid[i],lasti,Jmid[lasti]);
	      printf("RANGE_Y=%d\n",RANGE_Y);
	      fflush(stdout);
	      assert(Jmid[i] >= Jmid[lasti]);
	    }
	  }
	  lasti = i;
	}
    }

    /* X[J] maps to Hcuts[Li..Ri] and hence to Y[L] .. Y[R] : use this to expand range of IMIN,IMAX,Jmin[],Jmax[] */
    if(IMAX <= 0){
      IMIN = L; 
      IMAX = R;
      for(int I = L; I <= R; I++){
	Jmin[I] = M+1;
	Jmax[I] = 0;
	Jmid[I] = -1;
	if(FIX_RANGE_Y && RANGE_Y == 0)
	  JXmin[I] = JXmax[I] = -1e100;
      }
    } else {
      if(L < IMIN){
	for(int I = L; I < IMIN; I++){
	  Jmin[I] = M+1;
	  Jmax[I] = 0;
	  Jmid[I] = -1;
	  if(FIX_RANGE_Y && RANGE_Y == 0)
	    JXmin[I] = JXmax[I] = -1e100;
	}
	IMIN = L;
      }
      if(R > IMAX){
	for(int I = IMAX; ++I <= R;){
	  Jmin[I] = M+1;
	  Jmax[I] = 0;
	  Jmid[I] = -1;
	  if(FIX_RANGE_Y && RANGE_Y == 0)
	    JXmin[I] = JXmax[I] = -1e100;
	}
	IMAX = R;
      }
    }

    if(DEBUG>=3){
      int lasti = -1;
      for(register int i=IMIN; i <= IMAX;i++)
	if(Jmid[i] > 0){
	  assert(1 <= Jmid[i] && Jmid[i] <= M);
	  if(lasti >= 0 && !(Jmid[i] >= Jmid[lasti])){
#pragma omp critical
	    {
	      printf("m=%d:X[%d]=%0.3f maps to Hcuts[%d..%d]=%0.3f..%0.3f to Y[%d..%d]=%0.3f..%0.3f, N=%d\n",
		     m,J,X[J],Li,Ri,Hcuts[Li],Hcuts[Ri],L,R,Y[L],Y[R],N);
	      printf("m=%d,N=%d,M=%d,n=%d:IMIN=%d,IMAX=%d,L=%d,R=%d,J=%d:i=%d,Jmid[i]=%d,lasti=%d,Jmid[lasti]=%d\n",
		     m,N,M,n,IMIN,IMAX,L,R,J,i,Jmid[i],lasti,Jmid[lasti]);
	      printf("RANGE_Y=%d\n",RANGE_Y);
	      if(VERB){
		for(int j = 1; j <= M; j++){
		  int i = map[j];
		  if(i < 0)
		    continue;
		  int k = mapK[j];
		  printf("\t j=%d:map[j]=i=%d(I=%d),mapK[j]=k=%d(I-K=%d)\n",j,i,mapMD[i],k,mapMD[i-k]);
		}
	      }
	      fflush(stdout);
	      assert(Jmid[i] >= Jmid[lasti]);
	    }
	  }
	  lasti = i;
	}
    }

    if(FIX_RANGE_Y && RANGE_Y == 0){    /* Use distance rather than site counts */
      for(int I = L; I <= R; I++){
	if(Jmid[I] < 0){/* There should only be a single X[J] that maps to Y[I] : if not, use leftmost X[J] only */
	  JXmin[I] = X[J] - Xrange;
	  JXmax[I] = X[J] + Xrange;
	  Jmid[I] = J;
	}

	if((MDEBUG_SETLIMIT>=2 && MDEBUG_M==m) /* ||(DEBUG && m==12753)*/){
	  printf("    m=%d:J=%d,I=%d(L=%d,R=%d),X[J]=%0.3f:Y[I]=%0.3f,Y[L]=%0.3f,Y[R]=%0.3f,JXmin[I]=%0.6e,JXmax[I]=%0.6e,Xrange=%0.3f,Jmid[I]=%d\n",
		 m,J,I,L,R,X[J],Y[I],Y[L],Y[R],JXmin[I],JXmax[I],Xrange,Jmid[I]);
	  fflush(stdout);
	}
      }
    } else {
      for(int I = L; I <= R; I++){
	if(Jmid[I] < 0)/* There should only be a single X[J] that maps to Y[I] : if not, use leftmost X[J] only */
	  Jmid[I] = J;
	Jmin[I] = min(Jmin[I],max(1,J - RANGE));
	Jmax[I] = max(Jmax[I],min(M,J + RANGE));
      }
    }

    if(DEBUG>=3){
      int lasti = -1;
      for(register int i=IMIN; i <= IMAX;i++)
	if(Jmid[i] > 0){
	  assert(1 <= Jmid[i] && Jmid[i] <= M);
	  if(lasti >= 0 && !(Jmid[i] >= Jmid[lasti])){
#pragma omp critical
	    {
	      printf("m=%d:X[%d]=%0.3f maps to Hcuts[%d..%d]=%0.3f..%0.3f to Y[%d..%d]=%0.3f..%0.3f, N=%d\n",
		     m,J,X[J],Li,Ri,Hcuts[Li],Hcuts[Ri],L,R,Y[L],Y[R],N);
	      printf("m=%d,N=%d,M=%d,n=%d:IMIN=%d,IMAX=%d,L=%d,R=%d,J=%d:i=%d,Jmid[i]=%d,lasti=%d,Jmid[lasti]=%d\n",
		     m,N,M,n,IMIN,IMAX,L,R,J,i,Jmid[i],lasti,Jmid[lasti]);
	      printf("RANGE_Y=%d\n",RANGE_Y);
	      for(int t = IMIN; t <= IMAX; t++)
		if(Jmid[t])
		  printf("t=%d:Jmid[t]=%d\n",t,Jmid[t]);
	      fflush(stdout);
	      assert(Jmid[i] >= Jmid[lasti]);
	    }
	  }
	  lasti = i;
	}
    }
  }

  if((MDEBUG_SETLIMIT && MDEBUG_M ==m /* && N==MDEBUG_N+1*/) || (VERB>=2 && M==40 && m==14 /*&& N==144 && n==4203*/)){
    printf("Initial alignment bounds:m=%d,N=%d,M=%d, IMIN=%d,IMAX=%d,X[M+1]=%0.3f,Y[N+1]=%0.3f,RANGE_Y=%d:\n",m,N,M,IMIN,IMAX,X[M+1],Y[N+1],RANGE_Y);
    if(MDEBUG_SETLIMIT >= 2 /*||(DEBUG && m==12753)*/ || (VERB>=2  && M==40 && m==14 /*&& N==144 && n==4203*/)){
      for(int i=IMIN; i <= IMAX;i++)
	if(FIX_RANGE_Y && RANGE_Y == 0){
	  if(Jmid[i] >= 0){
	    int JR = Jmid[i];
	    int iR = map[JR];
	    int kR = mapK[JR];
	    if(iR >= 0)
	      printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,JXmin[I]=%0.6e,JXmax[I]=%0.6e,Jmid[I]=J=%d,X[J]=%0.4f,Y[I]=%0.4f(i=%d,k=%d,Hcuts[i-k,k]=%0.4f,%0.4f)\n",
		     i,Jmin[i],Jmax[i],JXmin[i],JXmax[i],Jmid[i],X[JR],Y[i],iR,kR, Hcuts[iR-kR], Hcuts[kR]);
	    else
	      printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,JXmin[I]=%0.6e,JXmax[I]=%0.6e,Jmid[I]=J=%d,X[J]=%0.4f,Y[I]=%0.4f(i=%d,k=%d)\n",
		     i,Jmin[i],Jmax[i],JXmin[i],JXmax[i],Jmid[i],X[JR],Y[i],iR,kR);
	  }
	} else
	  printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,Jmid[I]=%d\n",i,Jmin[i],Jmax[i],Jmid[i]);
    }
    fflush(stdout);
  }

  if(DEBUG>=1+RELEASE){
    int lasti = -1;
    for(int i=IMIN; i <= IMAX;i++)
      if(Jmid[i] > 0){
	assert(1 <= Jmid[i] && Jmid[i] <= M);
	if(FIX_RANGE_Y && RANGE_Y==0){
	  assert(JXmin[i] < JXmax[i]);
	} else {
	  assert(Jmin[i] <= Jmax[i]);
	  assert(Jmin[i] >= 1 && Jmax[i] <= M);
	}
	if(lasti >= 0 && !(Jmid[i] >= Jmid[lasti])){
          #pragma omp critical
	  {
	    printf("m=%d,N=%d,M=%d,n=%d:IMIN=%d,IMAX=%d:I=%d,Jmid[I]=%d,lastI=%d,Jmid[lastI]=%d\n",
		   m,N,M,n,IMIN,IMAX,i,Jmid[i],lasti,Jmid[lasti]);
	    printf("RANGE_Y=%d\n",RANGE_Y);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[j];
		if(i < 0)
		  continue;
		int k = mapK[j];
		printf("\t j=%d:map[j]=i=%d(I=%d),mapK[j]=k=%d(I-K=%d)\n",j,i,mapMD[i],k,mapMD[i-k]);
	      }
	    }
	    fflush(stdout);
	    assert(Jmid[i] >= Jmid[lasti]);
	  }
	}
	lasti = i;
      }
  }

  if(DEBUG && IMIN <= IMAX) assert(Jmid[IMIN] > 0 && Jmid[IMAX] > 0);

  if(FIX_RANGE_Y && RANGE_Y==0 && IMIN > IMAX){
    /* Infers alignments between X and Y from alignment between X and H and assuming H locations correspond to Y location.
       NOTE : This is risky since H locations may be garbled if called from HaploType. To suppress, remove alignments from X to H that do not also map to Y.
       It may help to make HaploType spread out the HapDelta[] and Delta[] values before calling hprobeval()
    */
    for(int I = 1; I <= N; I++){
      Jmin[I] = M+1;
      Jmax[I] = 0;
      Jmid[I] = -1;
      JXmin[I] = JXmax[I] = -1e100;
    }
    int JR = M+1,JL = -1,iR= -1,iL= -1;
    IMIN = N+1;
    IMAX = 0;
    for(int I = N; I >= 1; I--){
      /* check for nearest site X[JL] left of X[JR] that is aligned with Hcuts[iL] <= Y[I] */
      for(JL = JR; --JL >= 1; )
	if((iL = map[JL]) >= 0){
	  if(Hcuts[iL] <= Y[I])
	    break;
	  JR = JL;
	  iR = iL;/* ignores mapK[JL] > 0 */
	}
      register double XI;
      if(JL <= 0){/* extrapolate left of Hcuts[iR] and X[JR] */
	if(DEBUG && !(JR <= M)){
	  if(VERB>=2 && M==40 && m==195 && N==365){
	    printf("WARNING: m=%d(id=%lld): Cannot find any alignment with Hcuts[] : M=%d\n",m,gmap[pcontig->contig[m].mapid]->id, M);
	    for(int j = 1; j <= M; j++)
	      if((iL = map[j]) >= 0)
		printf("map[%d]= i = %d, Hcuts[i]= %0.4f\n",j,map[j], Hcuts[iL]);
	    fflush(stdout);
	  }

	  IMIN = N+1;
	  IMAX = 0;
	  break;
	}
	XI = X[JR] - (Hcuts[iR] - Y[I]);
      } else if(JR > M){/* extrapolate right of Hcuts[iL] and X[JL] */
	if(DEBUG) assert(JL >= 1);
	XI = X[JL] + (Y[I] - Hcuts[iL]);
      } else {/* interpolate location of Y[I] between Hcuts[iL] and Hcuts[iR] */
	if(DEBUG) assert(Hcuts[iL] <= Y[I] && Y[I] <= Hcuts[iR] && Hcuts[iL] < Hcuts[iR]);
	XI = X[JL] + (Y[I] - Hcuts[iL])*(X[JR]-X[JL])/(Hcuts[iR]-Hcuts[iL]);
      }
      JXmin[I] = XI - Xrange;
      JXmax[I] = XI + Xrange;
      if(JXmin[I] < X[M+1] && JXmax[I] > 0.0){
	if((MDEBUG_SETLIMIT>=2 && MDEBUG_M==m /*&& N==MDEBUG_N+1*/) || (VERB>=2 && M==40 && m==195 && N==365)){	
	  if(JL <= 0)
	    printf("m=%d:I=%d:Y[I]=%0.3f,JR=%d,iR=%d,Hcuts[iR]=%0.3f,M=%d,X[JR]=%0.3f,XI=%0.3f,X[M+1]=%0.3f,JXmin[I]=%0.3f,JXmax[I]=%0.3f\n",
		   m,I,Y[I],JR,iR,Hcuts[iR],M,X[JR],XI,X[M+1],JXmin[I],JXmax[I]);
	  else if(JR > M)
	    printf("m=%d:I=%d:Y[I]=%0.3f,JL=%d,iL=%d,Hcuts[iL]=%0.3f,M=%d,X[JL]=%0.3f,XI=%0.3f,X[M+1]=%0.3f,JXmin[I]=%0.3f,JXmax[I]=%0.3f\n",
		   m,I,Y[I],JL,iL,Hcuts[iL],M,X[JL],XI,X[M+1],JXmin[I],JXmax[I]);
	  else
	    printf("m=%d:I=%d:Y[I]=%0.3f,JL=%d,JR=%d,iL=%d,iR=%d,Hcuts[iL..iR]=%0.3f..%0.3f,M=%d,X[JL..JR]=%0.3f..%0.3f,XI=%0.3f,X[M+1]=%0.3f,JXmin[I]=%0.3f,JXmax[I]=%0.3f\n",
		   m,I,Y[I],JL,JR,iL,iR,Hcuts[iL],Hcuts[iR],M,X[JL],X[JR],XI,X[M+1],JXmin[I],JXmax[I]);
	}
	IMIN = min(I,IMIN);
	IMAX = max(I,IMAX);
      }
    }
  }

  if(VERB>=1+RELEASE /* HERE HERE >=2 */ && IMIN==1 && IMAX==N && N >= 100 && N >= 2 * M){
    printf("\nWARNING: setlimit initial alignment is global for m=%d(id=%lld),M=%d:N=%d,IMIN=%d,IMAX=%d\n",m,gmap[pcontig->contig[m].mapid]->id,M,N,IMIN,IMAX);
    fflush(stdout);
    //    assert(!(IMIN==1 && IMAX==N));
  }

  if(IMIN > IMAX){/* no alignment found : can happen due to initial consensus being poor quality */
    if(!globalfallback){
      if(VERB>=2 || MDEBUG>=2){
	printf("WARNING: setlimit failed to find alignment range for m=%d: falling back to LRbias=%0.6e,outlierEnd=%0.6e\n",m,LRbias,PoutlierEnd);
	fflush(stdout);
      }
      return 1;
    }
    IMIN = 1;
    IMAX = N;
    for(int I= IMIN; I <= IMAX; I++){
      Jmin[I] = 1;
      Jmax[I] = M;
      Jmid[I] = (M+1)/2;
      if(FIX_RANGE_Y && RANGE_Y == 0){
	JXmin[I] = 0.0;
	JXmax[I] = X[M+1];
      }
    }
    for(int J= 1; J <= M; J++){
      Imin[J] = 1;
      Imax[J] = N;
    }
    IMIN1 = IMIN;
    IMAX1 = IMAX;
    if((VERB>=1+RELEASE /* HERE HERE >=2 */ && N >= 100) || MDEBUG){
      printf("\nWARNING: setlimit failed to find alignment range for m=%d(id=%lld),M=%d:N=%d,IMIN=%d,IMAX=%d: using global alignment\n",m,gmap[pcontig->contig[m].mapid]->id,M,N,IMIN,IMAX);
      fflush(stdout);
      // assert(0);
    }
    if(DEBUG && N > 0 && !(IMIN <= IMAX)){
      printf("m=%d(id=%lld):N=%d,IMIN=%d,IMAX=%d\n",m,gmap[pcontig->contig[m].mapid]->id,N,IMIN,IMAX);
      fflush(stdout);
      assert(IMIN <= IMAX);
    }
    return 1;
  }

  if(DEBUG && FIX_RANGE_Y && RANGE_Y==0){
    if(DEBUG) assert(!EXTRAPOLATE);
    for(int I = IMIN; I <= IMAX;I++)
      if(Jmin[I] <= Jmax[I]){
	if(DEBUG) assert(JXmin[I] > LARGE_NEGATIVE);
	if(DEBUG) assert(JXmax[I] > LARGE_NEGATIVE);
	assert(JXmin[I] <= JXmax[I]);
      }
  }

  if(DEBUG) assert(IMIN <= IMAX);
  IMIN1 = IMIN;
  IMAX1 = IMAX;

  if(EXTRAPOLATE){
    /* enforce monotonic restrictions IMIN .. IMAX :
       1. Jmin[I=IMAX..IMIN] is a non-increasing function as I decreases.
       2. Jmax[I=IMIN..IMAX] is a non-decreasing function as I increases.
    */
    for(register int I = IMAX; --I >= IMIN;)
      Jmin[I] = min(Jmin[I],Jmin[I+1]);
    for(register int I = IMIN; ++I <= IMAX;)
      Jmax[I] = max(Jmax[I],Jmax[I-1]);

    if(MDEBUG_SETLIMIT>=2 && MDEBUG_M==m /* && N==MDEBUG_N+1*/){
      printf("Alignment bounds after monotonic restrictions:m=%d,N=%d,M=%d, IMIN=%d,IMAX=%d:\n",m,N,M,IMIN,IMAX);
      for(register int i=IMIN; i <= IMAX;i++)
	printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d\n",i,Jmin[i],Jmax[i]);
      fflush(stdout);
    }
    if(DEBUG)
      for(register int i=IMIN; i <= IMAX;i++)
	if(Jmin[i] <= Jmax[i])
	  assert(Jmin[i] >= 1 && Jmax[i] <= M);
  }

  if(!EXTRAPOLATE){/* use basic extrapolation of missing alignments from nearest aligments (to handle outliers in previous alignment) */
    /* extrapolate from (IMIN,Jmax[IMIN]): for(I=IMIN-1 .. 1)
       IF RANGE_Y > 0:
         IF !FIX_RANGE_Y
           Jmax[I] =  min(M, Jmax[IMIN] - (IMIN-I) + max(0,RANGE_Y-RANGE))
           if ( Jmax[I] > 0 ) 
             Jmin[I] = max(1, Jmin[IMIN] - (IMIN-I))
         ELSE // NEW
	    decrease Jmax[I] (from Jmid[I+1]) while Y[IMIN]-Y[I] >= X[Jmid[IMIN]] - X[Jmax[I]-1]
	    Jmin[I] = Jmax[I] - 1
	    Jmid[I] = Jmin[I] or Jmax[I], whichever minimizes fabs((Y[IMIN]-Y[I]) - (X[Jmid[IMIN]] - X[Jmid[I]]))

	    Jmin[I] = min(Jmin[I+1], Jmin[I] - max(RANGE_Y,DELTA_X,deltaExtXRef))
	    Jmax[I] = min(Jmax[I+1], Jmax[I] + max(RANGE_Y,DELTA_X,deltaExtXRef))
         ENDIF
       ELSE IF !FIX_RANGE_Y // IF !FIX_RANGE_Y && RANGE_Y==0
         if Y[IMIN]-Y[I] <= X[Jmax[IMIN]]-X[0] : 
            decrease Jmin[I] (from Jmin[I+1]) while Y[IMIN]-Y[I] >= X[Jmin[IMIN]] - X[Jmin[I]].
            increase Jmax[I] (from Jmin[I]) while Y[IMIN]-Y[I] <= X[Jmax[IMIN]] - X[Jmax[I]]
       ELSE  // IF FIX_RANGE_Y && RANGE_Y==0
	 only update JXmin[],JXmax[] based on distances and Xrange,Xrange2
       ENDIF

       Finally set IMIN to smallest I value where updated Jmin[I] <= Jmax[I]. */

    if(DEBUG && !(FIX_RANGE_Y && RANGE_Y==0) && !(Jmid[IMIN] > 0 && Jmid[IMAX] > 0)){
      printf("m=%d:IMIN=%d,IMAX=%d,N=%d,M=%d (FIX_RANGE_Y=%d, RANGE_Y=%d)\n",m,IMIN,IMAX,N,M,FIX_RANGE_Y,RANGE_Y);
      for(int I = IMIN; I <= IMAX; I++)
	printf("\t I=%d:Jmin[I]=%d,Jmax[I]=%d,Jmid[I]=%d,JXmin[I]= %0.4f, JXmax[I]= %0.4f\n", I,Jmin[I],Jmax[I],Jmid[I],JXmin[I],JXmax[I]);
      fflush(stdout);
      assert(Jmid[IMIN] > 0 && Jmid[IMAX] > 0);
    }

    if(Jmid[IMIN] > 0 && Jmid[IMAX] > 0){  /* otherwise FIX_RANGE_Y && RANGE_Y==0 and the best possible extrapolation has already been done */
  
      if(DEBUG>=2 && !(FIX_RANGE_Y && RANGE_Y==0)) assert(Jmid[IMIN] > 0 && Jmid[IMAX] > 0);

      int I = IMIN;
      int JR = -1,JL = -1,iR= -1,kR = -1,iL= -1, kL = -1;
      if(FIX_RANGE_Y && RANGE_Y == 0){
	if(MDEBUG_SETLIMIT>=2 && MDEBUG_M==m){
	  printf("Extrapolating Alignment bounds by setting JXmin[] and JXmax[] using Xrange= %0.3f, Xrange2= %0.3f (RANGE=%d, Ltheta=%0.3f, DELTA_X=%d,%d)\n",
		 Xrange, Xrange2, RANGE,Ltheta, DELTA_X,deltaExtXRef);
	  fflush(stdout);
	}
	JR = Jmid[IMIN];
	if(DEBUG) assert(JR >= 1 && JR <= M);
	iR = map[JR];
	if(DEBUG) assert(iR >= 1 && iR <= n);
	kR = mapK[JR];
	if(DEBUG) assert(0 <= kR && kR < iR);

	if(RefineXRange>=2 && IMIN1 < IMAX1){/* expand JXmin[],JXmax[] range for IMIN1,IMAX1 so the effect of deleting those labels (one at a time) is better predicted by mprobeval */
	  int L,R;/* Locate nearest alignment L < IMAX1, s.t. Jmid[L] > 0, and nearest alignment R > IMIN1 s.t. Jmid[R] > 0 */
	  for(L = IMAX - 1; L >= IMIN; L--)
	    if(Jmid[L] > 0)
	      break;
	  if(DEBUG && !(L >= IMIN)){
	    #pragma omp critical
	    {
	      printf("m=%d:IMIN=%d,IMAX=%d,L=%d:\n",m,IMIN,IMAX,L);
	      for(int I = IMIN; I <= IMAX; I++)
		printf("I=%d:Jmid[I]=%d,JXmin[I]=%0.7e,JXmax[I]=%0.7e\n",I,Jmid[I],JXmin[I],JXmax[I]);
	      fflush(stdout);
	      assert(L >= IMIN);
	    }
	  }
	  for(R = IMIN + 1; R <= IMAX; R++)
	    if(Jmid[R] > 0)
	      break;
	  if(DEBUG) assert(R <= IMAX);

	  if(DEBUG>=2) assert(JR == Jmid[IMIN]);
	  if(DEBUG>=2) assert(Jmid[R] > 0);
	  JXmin[IMIN] = X[JR] - Xrange2;
	  JXmax[IMIN] = min(JXmax[R] - 0.001, X[JR] + Xrange2);

	  int JL = Jmid[IMAX];
	  if(DEBUG>=2) assert(Jmid[L] > 0);
	  JXmin[IMAX] = max(JXmin[L] + 0.001, X[JL] - Xrange2);
	  JXmax[IMAX] = X[JL] + Xrange2;

	  if((MDEBUG_SETLIMIT>=2 && MDEBUG_M==m) || (VERB>=2 && m==13 && IMIN1==1 && IMAX1==17)){
	    printf("m=%d:IMIN1=%d,IMAX1=%d,L=%d,R=%d,JX[IMIN1]=%0.3f,%0.3f,JX[IMAX1]=%0.3f,%0.3f,Jmid[L]=%d(JX=%0.3f,%0.3f),Jmid[R]=%d(JX=%0.3f,%0.3f)\n",
		   m,IMIN1,IMAX1,L,R,JXmin[IMIN1],JXmax[IMIN1],JXmin[IMAX1],JXmax[IMAX1],Jmid[L],JXmin[L],JXmax[L],Jmid[R],JXmin[R],JXmax[R]);
	    fflush(stdout);
	  }
	}

	if((MDEBUG_SETLIMIT>=2 && MDEBUG_M==m) || (VERB>=2 && M==37 && m==321 && N==144 && n==4203)){
	  printf("IMIN=%d:JR=Jmid[IMIN]=%d,iR=map[JR]=%d,kR=%d,Y[IMIN]=%0.4f,N=%d,Y[N+1]=%0.4f,X[JR]=%0.4f,Hcuts[iR-kR,iR]=%0.4f,%0.4f,M=%d,X[M+1]=%0.4f\n",
		 IMIN,JR,iR,kR,Y[IMIN],N,Y[N+1],X[JR],Hcuts[iR-kR],Hcuts[iR],M,X[M+1]);
	  fflush(stdout);
	}
      }
      while(I > 1){
	if(RANGE_Y){
	  I--;
	  if(!FIX_RANGE_Y){
	    Jmax[I] = min(Jmax[IMIN],Jmax[IMIN] - (IMIN-I) + max(0,RANGE_Y-RANGE));
	    if(Jmax[I] <= 0){
	      I++;
	      break;
	    }
	    Jmin[I] = max(1, Jmin[IMIN] - (IMIN-I));
	    if(DEBUG) assert(Jmax[I] >= Jmin[I]);
	  } else {// NEW
	    if(DEBUG && !(Jmid[I+1] > 0)){
	      #pragma omp critical
	      {
		printf("m=%d:IMIN=%d,I=%d:Jmid[IMIN]=%d,Jmid[I+1]=%d\n",m,IMIN,I,Jmid[IMIN],Jmid[I+1]);
		fflush(stdout);
		assert(Jmid[I+1] > 0);
	      }
	    }
	    if(Jmid[I+1] <= 1){/* taper off */
	      int T = I+1;
	      for(;I >= 1; I--){
		Jmin[I] = Jmid[I] = 1;
	        Jmax[I] = max(1, Jmax[T] - (T-I));

		if(Jmax[I] <= 1 || I <= 1)
		  break;
	      }
	      break;
	    } 
	    for(Jmax[I] = Jmid[I+1]; Jmax[I] > 1; Jmax[I]--)
	      if(Y[IMIN]-Y[I] < X[Jmid[IMIN]] - X[Jmax[I]-1])
		break;
	    Jmin[I] = max(1,Jmax[I] - 1);

	    if(fabs(Y[IMIN]-Y[I] - X[Jmid[IMIN]] + X[Jmin[I]]) < fabs(Y[IMIN]-Y[I] - X[Jmin[IMIN]] + X[Jmax[I]]))
	      Jmid[I] = Jmin[I];
	    else
	      Jmid[I] = Jmax[I];
	    
	    Jmax[I] = min(Jmax[I+1], Jmax[I] + max(max(RANGE_Y, DELTA_X), deltaExtXRef));
	    Jmin[I] = min(Jmin[I+1], max(1, Jmin[I] - max(max(RANGE_Y, DELTA_X), deltaExtXRef)));
	    if(DEBUG) assert(Jmax[I] >= Jmin[I]);
	  }
	} else if(!FIX_RANGE_Y){
	  if(Y[IMIN] - Y[I-1] > X[Jmax[IMIN]]-X[0])
	    break;
	  I--;
	  for(Jmin[I] = Jmin[I+1]; Jmin[I] > 1; Jmin[I]--)
	    if(Y[IMIN]-Y[I] < X[Jmin[IMIN]] - X[Jmin[I]])
	      break;
	  for(Jmax[I] = Jmin[I]; Jmax[I] < Jmax[I+1]; Jmax[I]++)
	    if(Y[IMIN]-Y[I] > X[Jmax[IMIN]] - X[Jmax[I]])
	      break;
	} else /* FIX_RANGE_Y && RANGE_Y==0 */ {/* only update JXmin[],JXmax[] based on distances */
	  I--;

	  int origJR = JR;
	  int origiR = iR;
	  int origkR = kR;

	  double XI;

	  if(Hcuts[iR] <= Y[I]){/* can happen if Y[I] is very close to Y[I+1] */
	    XI = X[JR];
	  } else {

	    /* check for nearest site X[JL] left of X[JR] that is aligned with Hcuts[iL-kL .. iL] <= Y[I] */
	    for(JL = JR; --JL >= 1; )
	      if((iL = map[JL]) >= 0){
		kL = mapK[JL];
		if(DEBUG) assert(0 <= kL && kL < iL);

		if(Hcuts[iL] <= Y[I])
		  break;

		JR = JL;
		iR = iL;
		kR = kL;
	      }

	    if(JL >= 1){/* interpolate location of Y[I] between Hcuts[iL] and Hcuts[iR] */
	      if((DEBUG && !(Hcuts[iL] <= Y[I] && Y[I] <= Hcuts[iR] && Hcuts[iL] < Hcuts[iR])) /* ||(m==321 && N==144 && M==37 && n==4203)*/){
#pragma omp critical
		{
		  printf("m=%d,N=%d,M=%d,n=%d:iL=%d,kL=%d,iR=%d->%d,kR=%d->%d,I=%d:Hcuts[iL]=%0.4f,Hcuts[iR-kR]=%0.4f,Hcuts[iR]=%0.4f,Y[I]=%0.4f,Y[I+1]=%0.4f,Hcuts[n+1]=%0.4f,Y[N+1]=%0.4f:JL=%d,JR=%d->%d,IMIN=%d\n",
			 m,N,M,n,iL,kL,origiR, iR, origkR, kR,I,Hcuts[iL],Hcuts[iR-kR],Hcuts[iR],Y[I],Y[I+1],Hcuts[n+1],Y[N+1],JL,origJR,JR,IMIN);
		  fflush(stdout);
		  assert(Hcuts[iL] <= Y[I] && Y[I] <= Hcuts[iR] && Hcuts[iL] < Hcuts[iR]);
		}
	      }
	      XI = X[JL] + (Y[I] - Hcuts[iL])*(X[JR]-X[JL])/(Hcuts[iR] - Hcuts[iL]);
	    } else /* extrapolate left of Hcuts[iR-kR] and X[JR] */
	      XI = X[JR] - (Hcuts[iR] - Y[I]);
	  }
	
	  JXmax[I] = min(JXmax[I+1] - 0.001, XI + Xrange2);
	  if(JXmax[I] < 0.0){
	    I++;
	    break;
	  }
	  JXmin[I] = XI - Xrange2;
	  Jmid[I] = -1;
	  if((DEBUG && !(JXmin[I] <= JXmax[I])) || (MDEBUG_SETLIMIT>=2 && MDEBUG_M==m) || (VERB>=2 && M==40 && m==195 && N==365)){
	    if(JL >= 1)
	      printf("m=%d,I=%d,IMIN=%d:XI=%0.3f,JXmin[I]=%0.3f,JXmax[I]=%0.3f,JL=%d,JR=%d,iL=%d,iR=%d,Y[I]=%0.3f,Hcuts[iL]=%0.3f,Hcuts[iR]=%0.3f,X[JL]=%0.3f,X[JR]=%0.3f\n",
		     m,I,IMIN,XI,JXmin[I],JXmax[I],JL,JR,iL,iR,Y[I],Hcuts[iL],Hcuts[iR],X[JL],X[JR]);
	    else
	      printf("m=%d,I=%d,IMIN=%d:XI=%0.3f,JXmin[I]=%0.3f,JXmax[I]=%0.3f,JR=%d,iR=%d,Y[I]=%0.3f,Hcuts[iR]=%0.3f,X[JR]=%0.3f\n",
		     m,I,IMIN,XI,JXmin[I],JXmax[I],JR,iR,Y[I],Hcuts[iR],X[JR]);
	    fflush(stdout);
	    assert(JXmin[I] <= JXmax[I]);
	  }
	}

	if(DEBUG && !(FIX_RANGE_Y && RANGE_Y==0) && !(Jmin[I] <= Jmax[I] && Jmin[I] >= 1 && Jmax[I] <= M)){
	  printf("m=%d:I=%d,IMIN=%d,IMAX=%d,Jmin[I]=%d,Jmax[I]=%d,M=%d,Jmid[I]=%d\n",
		 m,I,IMIN,IMAX,Jmin[I],Jmax[I],M,Jmid[I]);
	  for(register int i=IMIN; i <= IMAX; i++)
	    printf(" i=%d:Jmin[i]=%d,Jmax[i]=%d\n",i,Jmin[i],Jmax[i]);
	  fflush(stdout);
	  assert(Jmin[I] <= Jmax[I] && Jmin[I] >= 1 && Jmax[I] <= M);
	}
      }
      IMIN = I;

      /* extrapolate from (IMAX,Jmin[IMAX]) : for(I=IMAX+1..N) 
	 IF RANGE_Y > 0:
	   IF !FIX_RANGE_Y
	     set Jmin[I] = max(1, Jmin[IMAX] + (I-IMAX) - max(0,RANGE_Y-RANGE))
	     if( Jmin[I] <= M)
	       set Jmax[I] = min(M, Jmax[IMAX] + (I-IMAX))
	   ELSE // NEW
             increase Jmin[I] (from Jmid[I-1]) while Y[I]-Y[IMAX] >= X[Jmin[I]+1] - X[Jmid[IMAX]]
	     Jmax[I] = Jmin[I] + 1
             Jmid[I] = Jmin[I] or Jmax[I], whichever minimizes fabs((Y[I]-Y[IMAX]) - (X[Jmid[I]] - X[Jmid[IMAX]]))

	     Jmin[I] = max(Jmin[I-1], Jmin[I] - max(RANGE_Y,DELTA_X,deltaExtXRef))
	     Jmax[I] = max(Jmax[I-1], Jmax[I] + max(RANGE_Y,DELTA_X,deltaExtXRef))
	   ENDIF
	 ELSE IF !FIX_RANGE_Y

	 if Y[I]-Y[IMAX] <= X[M] - X[Jmin[IMAX]] :
             increase Jmax[I] (from Jmax[I-1]) while Y[I]-Y[IMAX] >= X[Jmax[I]] - X[Jmax[IMAX]]
             decrease Jmin[I] (from Jmax[I]) while Y[I]-Y[IMAX] <= X[Jmin[I]] - X[Jmin[IMAX]]

	 ELSE // IF FIX_RANGE_Y && RANGE_Y==0
	 
	     only update JXmin[],JXmax[] based on distances and Xrange,Xrange2

	 ENDIF

	 Finally set IMAX to largest I value with updated Jmin[I] <= Jmax[I]. */

      I = IMAX;
      if(MDEBUG_SETLIMIT>=2 && MDEBUG_M==m && (N==MDEBUG_N+1 || N==MDEBUG_N)){
	printf("IMAX=%d,Y[IMAX]=%0.3f,X[Jmin[IMAX]=%d]=%0.3f,X[Jmax[IMAX]=%d]=%0.3f\n",
	       IMAX,Y[IMAX],Jmin[IMAX],X[Jmin[IMAX]],Jmax[IMAX],X[Jmax[IMAX]]);
	fflush(stdout);
      }
      if(FIX_RANGE_Y && RANGE_Y == 0){
	JL = Jmid[IMAX];
	if(DEBUG) assert(JL >= 1 && JL <= M);
	iL = map[JL];
	if(DEBUG) assert(iL >= 1 && iL <= n);
	if(MDEBUG_SETLIMIT>=2 && MDEBUG_M==m){
	  printf("IMAX=%d:JL=Jmid[IMAX]=%d,iL=map[JL]=%d,Y[IMAX]=%0.3f,N=%d,Y[N+1]=%0.3f,X[JL]=%0.3f,Hcuts[iL]=%0.3f,M=%d,X[M+1]=%0.3f\n",IMAX,JL,iL,Y[IMAX],N,Y[N+1],X[JL],Hcuts[iL],M,X[M+1]);
	  fflush(stdout);
	}
      }
      while(I < N){
	if(RANGE_Y){
	  I++;
	  if(!FIX_RANGE_Y){
	    Jmin[I] = max(Jmin[IMAX], Jmin[IMAX] + (I-IMAX) - max(0,RANGE_Y-RANGE));
	    if(Jmin[I] > M){
	      I--;
	      break;
	    }
	    Jmax[I] = min(M, Jmax[IMAX] + (I-IMAX));
	    if(DEBUG) assert(Jmax[I] >= Jmin[I]);
	  } else {// NEW
	    if(DEBUG) assert(Jmid[I-1] > 0);
	    if(Jmid[I-1] >= M){/* taper off */
	      int T = I-1;
	      for(;I <= N; I++){
		Jmax[I] = Jmid[I] = M;
		Jmin[I] = min(M, Jmin[T] + (I-T));

		if(Jmin[I] >= M || I >= N)
		  break;
	      }
	      break;
	    }

	    for(Jmin[I] = Jmid[I-1]; Jmin[I] < M; Jmin[I]++)
	      if(Y[I]-Y[IMAX] < X[Jmin[I]+1] - X[Jmid[IMAX]])
		break;
	    Jmax[I] = min(M, Jmin[I] + 1);

	    if(fabs(Y[I]-Y[IMAX] - X[Jmin[I]] + X[Jmid[IMAX]]) < fabs(Y[I]-Y[IMAX] - X[Jmax[I]] + X[Jmid[IMAX]]))
	      Jmid[I] = Jmin[I];
	    else
	      Jmid[I] = Jmax[I];

	    Jmin[I] = max(Jmin[I-1], Jmin[I] - max(max(RANGE_Y,DELTA_X),deltaExtXRef));
	    Jmax[I] = max(Jmax[I-1], min(M, Jmax[I] + max(max(RANGE_Y,DELTA_X),deltaExtXRef)));
	    if(DEBUG && !(Jmax[I] >= Jmin[I])){
	      printf("m=%d:IMAX=%d,I=%d:Jmin[I-1]=%d,Jmax[I-1]=%d:Jmid[I]=%d,Jmin[I]=%d,Jmax[I]=%d,M=%d,RANGE_Y=%d,DELTA_X=%d,deltaExtXRef=%d\n",
		     m,IMAX,I,Jmin[I-1],Jmax[I-1],Jmid[I],Jmin[I],Jmax[I],M,RANGE_Y,DELTA_X,deltaExtXRef);
	      fflush(stdout);
	      assert(Jmax[I] >= Jmin[I]);
	    }
	  }
	} else if(!FIX_RANGE_Y) {
	  if(MDEBUG_SETLIMIT>=2 && MDEBUG_M==m && (N==MDEBUG_N+1 || N==MDEBUG_N)){
	    printf("IMAX=%d,I=%d,N=%d,Y[I+1]=%0.3f,Y[IMAX]=%0.3f,X[M+1]=%0.3f,X[M]=%0.3f,X[Jmin[IMAX]]=%0.3f\n",
		   IMAX,I,N,Y[I+1],Y[IMAX],X[M+1],X[M],X[Jmin[IMAX]]);
	    fflush(stdout);
	  }
	  if(Y[I+1]-Y[IMAX] > X[M+1] - X[Jmin[IMAX]])
	    break;
	  I++;
	  for(Jmax[I] = Jmax[I-1]; Jmax[I] < M; Jmax[I]++)
	    if(Y[I]-Y[IMAX] < X[Jmax[I]] - X[Jmax[IMAX]])
	      break;
	  for(Jmin[I] = M; Jmin[I] > Jmin[I-1]; Jmin[I]--)
	    if(Y[I]-Y[IMAX] > X[Jmin[I]] - X[Jmin[IMAX]])
	      break;
	} else {/* FIX_RANGE_Y && RANGE_Y==0 : only update JXmin[],JXmax[] based on distances */
	  I++;

	  double XI;

	  if(Hcuts[iL] >= Y[I]){/* can happen if Y[I] is very close to Y[I-1] */
	    XI = X[JL];
	  } else {
	    /* check for a site X[JR] right of X[JL] that is aligned with Hcuts[iR] >= Y[I] */
	    for(JR = JL; ++JR <= M;)
	      if((iR=map[JR]) >= 0){
		if(Hcuts[iR] >= Y[I])
		  break;
		/* ignore mapK[JL] > 0 */
		JL = JR;
		iL = iR; 
	      }
	    if(JR <= M){/* interpolate location of Y[I] between Hcuts[iL] and Hcuts[iR] */
	      if(DEBUG) assert(Hcuts[iL] <= Y[I] && Y[I] <= Hcuts[iR] && Hcuts[iL] < Hcuts[iR]);
	      XI = X[JL] + (Y[I] - Hcuts[iL])*(X[JR]-X[JL])/(Hcuts[iR]-Hcuts[iL]);
	    } else /* extrapolate right of Hcuts[iL] and X[JL] */
	      XI = X[JL] + (Y[I] - Hcuts[iL]);
	  }

	  JXmin[I] = max(JXmin[I-1] + 0.001, XI - Xrange2);// NOTE : Xrange2 only applies in extension direction to accomodate large outlier
	  if(JXmin[I] > X[M+1]){
	    I--;
	    break;
	  }
	  JXmax[I] = XI + Xrange2;
	  Jmid[I] = -1;
	  if((DEBUG && !(JXmin[I] <= JXmax[I])) || (MDEBUG_SETLIMIT>=2 && MDEBUG_M==m)){
	    if(JR <= M)
	      printf("m=%d,I=%d,IMAX=%d:XI=%0.3f,JXmin[I]=%0.3f,JXmax[I]=%0.3f,JL=%d,JR=%d,iL=%d,iR=%d,Y[I]=%0.3f,Hcuts[iL]=%0.3f,Hcuts[iR]=%0.3f,X[JL]=%0.3f,X[JR]=%0.3f\n",
		     m,I,IMAX,XI,JXmin[I],JXmax[I],JL,JR,iL,iR,Y[I],Hcuts[iL],Hcuts[iR],X[JL],X[JR]);
	    else
	      printf("m=%d,I=%d,IMAX=%d:XI=%0.3f,JXmin[I]=%0.3f,JXmax[I]=%0.3f,JL=%d,iL=%d,Y[I]=%0.3f,Hcuts[iL]=%0.3f,X[JL]=%0.3f\n",
		     m,I,IMAX,XI,JXmin[I],JXmax[I],JL,iL,Y[I],Hcuts[iL],X[JL]);
	    fflush(stdout);
	    assert(JXmin[I] <= JXmax[I]);
	  }
	}

	if(DEBUG && !(FIX_RANGE_Y && RANGE_Y==0) && !(Jmin[I] <= Jmax[I] && Jmin[I] >= 1 && Jmax[I] <= M)){
	  printf("m=%d:I=%d,IMIN=%d,IMAX=%d,Jmin[I]=%d,Jmax[I]=%d,M=%d,Jmid[I]=%d\n",
		 m,I,IMIN,IMAX,Jmin[I],Jmax[I],M,Jmid[I]);
	  for(register int i=IMIN; i <= IMAX; i++)
	    printf(" i=%d:Jmin[i]=%d,Jmax[i]=%d\n",i,Jmin[i],Jmax[i]);
	  fflush(stdout);
	  assert(Jmin[I] <= Jmax[I] && Jmin[I] >= 1 && Jmax[I] <= M);
	}
      }
      IMAX = I;
      
      if(VERB>=2 && MDEBUG_SETLIMIT>=2 && MDEBUG_M==m){
	printf("After End extrapolation of alignment bounds:m=%d,N=%d,M=%d, IMIN=%d,IMIN1=%d,IMAX1=%d,IMAX=%d:\n",m,N,M,IMIN,IMIN1,IMAX1,IMAX);
	for(register int i=IMIN; i <= IMAX;i++)
	  if(FIX_RANGE_Y && RANGE_Y==0)
	     printf("   I=%d:Jmid[I]=%d,JXmin[I]=%0.3f,JXmax[I]=%0.3f\n",i,Jmid[i],JXmin[i],JXmax[i]);	    
	  else
	     printf("   I=%d:Jmid[I]=%d,Jmin[I]=%d,Jmax[I]=%d\n",i,Jmid[i],Jmin[i],Jmax[i]);
      }

      /* For each missing internal alignment I (Jmid[I] < 0) :
	 Locate nearest left alignment L < I s.t. Jmid[L] > 0, and nearest right alignment R > I s.t. Jmid[R] > 0

	 IF RANGE_Y:
	   IF !FIX_RANGE_Y
             set Jmin[I] = max(Jmin[L], min(Jmin[L] + (I-L) - max(0,RANGE_Y-RANGE), Jmin[R] - (R-I)))
	     set Jmax[I] = min(Jmax[R], max(Jmax[L] + (I-L), Jmax[R] - (R-I) + max(0,RANGE_Y-RANGE)))
	   ELSE // NEW
	     XI = X[Jmid[L]] + (Y[I] - Y[L])*(X[Jmid[R]]-X[Jmid[L]])/(Y[R]-Y[L])
	     Increase Jmin[I] from Jmid[L] while X[Jmin[I]+1] <= XI
	     Jmax[I] = Jmin[I] + 1
	     Jmid[I] = Jmin[I] or Jmax[I], whichever minimizes fabs(XI - X[Jmid[I]])

	     Jmin[I] = max(Jmin[I-1], Jmin[I] - RANGE)
	     Jmax[I] = max(Jmax[I-1], Jmax[I] + RANGE)
           ENDIF
	 ELSE if FIX_RANGE_Y==0: // IF !FIX_RANGE_Y && RANGE_Y==0

         Set Jmin[I] = Jmin[R], Jmax[I] = Jmax[L]
         Decrease Jmin[I] as long as Jmin[I] > Jmin[L] && (Y[I]-Y[L] <= X[Jmin[I]] - X[Jmin[L]] OR Y[R]-Y[I] >= X[Jmin[R]]-X[Jmin[I]])
         Increase Jmax[I] as long as Jmax[I] < Jmax[R] && (Y[I]-Y[L] >= X[Jmax[I]] - X[Jmax[L]] OR Y[R]-Y[I] <= X[Jmax[R]]-X[Jmax[I]])

	 ELSE // IF FIX_RANGE_Y && RANGE_Y==0

	    only update JXmin[],JXmax[] based on distances
	 
	 ENDIF
      */
      for(int I = IMIN1 + 1; I < IMAX1; I++){
	if(Jmid[I] > 0)
	  continue;
	int L,R;      /* Locate nearest left alignment L < I s.t. Jmid[L] > 0, and nearest right alignment R > I s.t. Jmid[R] > 0 */
	for(L=I-1; L >= IMIN1; L--)
	  if(Jmid[L] > 0)
	    break;
	if(DEBUG && !(L >= IMIN1 && Jmid[L] > 0)){
	  printf("m=%d:IMIN=%d,IMAX=%d,IMIN1=%d,IMAX1=%d:I=%d,L=%d,Jmid[L]=%d\n",
		 m,IMIN,IMAX,IMIN1,IMAX1,I,L,Jmid[L]);
	  fflush(stdout);
	  assert(L >= IMIN1 && Jmid[L] > 0);
	}

	for(R=I+1; R <= IMAX1; R++)
	  if(Jmid[R] > 0)
	    break;
	if(DEBUG) assert(R <= IMAX1 && Jmid[R] > 0);

	if(RANGE_Y){
	  if(!FIX_RANGE_Y){
	    Jmin[I] = min(Jmin[L] + (I-L) - max(0,RANGE_Y-RANGE), Jmin[R] - (R-I));
	    Jmax[I] = max(Jmax[L] + (I-L), Jmax[R] - (R-I) + max(0,RANGE_Y-RANGE));
	    Jmin[I] = max(Jmin[I],Jmin[L]);
	    Jmax[I] = min(Jmax[I],Jmax[R]);
	  } else {// NEW
	    if(DEBUG) assert(Y[R] > Y[L]);// if this fails revert to !FIX_RANGE_Y code
	    double XL = X[Jmid[L]];
	    double XR = X[Jmid[R]];
	    double XI = XL + (Y[I] - Y[L])*(XR - XL)/(Y[R]-Y[L]);
	    for(Jmin[I] = Jmid[L]; Jmin[I] < Jmid[R]; Jmin[I]++)
	      if(X[Jmin[I]+1] > XI)
		break;
	    Jmax[I] = Jmin[I] + 1;

	    int JmidI;
	    if(fabs(XI - X[Jmin[I]]) < fabs(XI - X[Jmax[I]]))
	      JmidI = Jmin[I];
	    else
	      JmidI = Jmax[I];
	    
	    Jmin[I] = max(Jmin[L], JmidI - RANGE);
	    if(DEBUG) assert(Jmin[I] <= Jmin[R]);
	    Jmax[I] = min(Jmax[R], JmidI + RANGE);
	    if(DEBUG) assert(Jmax[I] >= Jmax[L]);
	    if(MDEBUG_SETLIMIT >=2 && MDEBUG_M==m){
	      printf("m=%d:I=%d,L=%d,R=%d,Jmid[L,R]=%d,%d:Y[L]= %0.4f, Y[I]= %0.4f, Y[R]= %0.4f, XL= %0.4f, XR= %0.4f, XI= %0.4f:JmidI=%d,Jmin[I]=%d,Jmax[I]=%d,RANGE=%d\n",
		     m,I,L,R,Jmid[L],Jmid[R],Y[L],Y[I],Y[R],XL,XR,XI,JmidI,Jmin[I],Jmax[I],RANGE);
	      fflush(stdout);
	    }
	  }
	} else if(!FIX_RANGE_Y){
	  for(Jmin[I] = Jmin[R]; Jmin[I] > 1; Jmin[I]--)
	    if(!(Y[I]-Y[L] <= X[Jmin[I]] - X[Jmin[L]] || Y[R]-Y[I] >= X[Jmin[R]] - X[Jmin[I]]))
	      break;
	  for(Jmax[I] = Jmax[L]; Jmax[I] < M; Jmax[I]++)
	    if(!(Y[I]-Y[L] >= X[Jmax[I]] - X[Jmax[L]] || Y[R]-Y[I] <= X[Jmax[R]] - X[Jmax[I]]))
	      break;
	  Jmin[I] = max(Jmin[I],Jmin[L]);
	  Jmax[I] = min(Jmax[I],Jmax[R]);
	} else {/* only update JXmin[],JXmax[] based on distances */
	  /* first locate smallest range Hcuts[iL..iR] that includes Y[I] and is aligned with X[JL..JR] */
	  int JL = Jmid[L], JR = Jmid[R];
	  if(DEBUG && !(1 <= JL && JL <= JR && JR <= M)){
            #pragma omp critical
	    {
	      printf("m=%d,M=%d,N=%d,n=%d:L=%d,Jmid[L]=JL=%d,R=%d,Jmid[R]=JR=%d\n",m,M,N,n,L,JL,R,JR);
	      printf("IMIN1=%d,IMAX1=%d,I=%d\n",IMIN1,IMAX1,I);
	      if(FIX_RANGE_Y && RANGE_Y == 0)
		for(register int i = IMIN1; i <= IMAX1; i++)
		  printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,JXmin[I]=%0.6e,JXmax[I]=%0.6e,Jmid[I]=%d\n",i,Jmin[i],Jmax[i],JXmin[i],JXmax[i],Jmid[i]);
	      fflush(stdout);
	      assert(1 <= JL && JL <= JR && JR <= M);
	    }
	  }
	  int left = map[JL]-mapK[JL], right = map[JR];
	  if(DEBUG) assert(1 <= left && left <= right && right <= n);
	  int iR = 0, iL = n+1;
	  for(int i = left; i <= right; i++){
	    if(mapMD[i] >= 0){
	      iL = min(i,iL);
	      iR = max(i,iR);
	    }
	  }
	  if(DEBUG && !(1 <= iL && iL <= iR && iR <= n)){
	    #pragma omp critical
	    {
	      printf("m=%d,M=%d,N=%d,n=%d:L=%d,Jmid[L]=JL=%d,R=%d,Jmid[R]=JR=%d\n",m,M,N,n,L,JL,R,JR);
	      printf("IMIN1=%d,IMAX1=%d,I=%d\n",IMIN1,IMAX1,I);
	      if(FIX_RANGE_Y && RANGE_Y == 0)
		for(register int i = IMIN1; i <= IMAX1; i++)
		  printf("   I=%d:JXmin[I]=%0.6e,JXmax[I]=%0.6e,Jmid[I]=%d\n",i,JXmin[i],JXmax[i],Jmid[i]);
	      printf("map[JL]=%d,mapK[JL]=%d,map[JR]=%d,left=%d,right=%d,iL=%d,iR=%d\n",map[JL],mapK[JL],map[JR],left,right,iL,iR);
	      for(int i = left; i <= right; i++)
		if(mapMD[i] >= 0)
		  printf("i=%d:mapMD[i]=%d,Hcuts[i]=%0.3f,Y[mapMD[i]]=%0.3f\n",i,mapMD[i],Hcuts[i],Y[mapMD[i]]);
	      fflush(stdout);
	      assert(1 <= iL && iL <= iR && iR <= n);
	    }
	  }

	  for(int J = JL; ++J < JR;){
	    int i = map[J];
	    if(i >= 0){
	      if(Hcuts[i] > Y[I])
		break;
	      JL = J;
	      iL = i;
	    }
	  }
	  for(register int J = JR; --J > JL;){
	    int i = map[J];
	    if(i >= 0){
	      if(Hcuts[i] < Y[I])
		break;
	      JR = J;
	      iR = i;
	    }
	  }
	  if(DEBUG && !(JL < JR && iL < iR && Hcuts[iL] <= Y[I] && Y[I] <= Hcuts[iR])){
	    #pragma omp critical
	    {
	      printf("IMIN1=%d,IMAX1=%d,I=%d,L=%d,R=%d,Jmin[L]=%d,Jmid[L]=%d,Jmax[L]=%d,Jmin[R]=%d,Jmid[R]=%d,Jmax[R]=%d:\n",
		     IMIN1,IMAX1,I,L,R,Jmin[L],Jmid[L],Jmax[L],Jmin[R],Jmid[R],Jmax[R]);
	      printf("map[Jmid[L]]=%d,map[Jmid[R]]=%d\n",map[Jmid[L]],map[Jmid[R]]);

	      printf("m=%d:I=%d,Y[I]=%0.3f,L=%d,Y[L]=%0.3f,R=%d,Y[R]=%0.3f:Jmid[L]=%d,Jmid[R]=%d,JL=%d,JR=%d,iL=%d,iR=%d,Hcuts[iL]=%0.3f,Hcuts[iR]=%0.3f\n",
		     m,I,Y[I],L,Y[L],R,Y[R],Jmid[L],Jmid[R],JL,JR,iL,iR,Hcuts[iL],Hcuts[iR]);
	      printf("map[JL]=%d,mapK[JL]=%d,map[JR]=%d,mapK[JR]=%d,Hcuts[%d]=%0.3f,Hcuts[%d]=%0.3f\n",
		     map[JL],mapK[JL],map[JR],mapK[JR],iL-mapK[JL],Hcuts[iL-mapK[JL]],iR-mapK[JR],Hcuts[iR-mapK[JR]]);
	      printf("nmapMD[L]=%d,nmapMD[R]=%d\n",nmapMD[L],nmapMD[R]);
	      printf("mapMD[iL]=%d,mapMD[iR]=%d\n",mapMD[iL],mapMD[iR]);
	      fflush(stdout);
	      assert(JL < JR && iL < iR && Hcuts[iL] <= Y[I] && Y[I] <= Hcuts[iR]);
	    }
	  }

	  /* interpolate between Hcuts[iL] and Hcuts[iR] */
	  double XI = X[JL] + (Y[I] - Hcuts[iL])*(X[JR] - X[JL])/(Hcuts[iR]-Hcuts[iL]);
	  if(DEBUG) assert(L <= I-1);
	  JXmin[I] = max(JXmin[I-1] + 0.001, XI - Xrange2);// Xrange2 is only effective for large internal alignment intervals 
	  JXmax[I] = min(JXmax[R] - 0.001, XI + Xrange2);// Xrange2 is only effective for large internal alignment intervals

	  //	JXmin[I] = min(JXmin[L] + Y[I]-Y[L], JXmin[R] + Y[I]-Y[R]);
	  //	JXmax[I] = max(JXmax[L] + Y[I]-Y[L], JXmax[R] + Y[I]-Y[R]);
	  if((DEBUG && !(JXmin[I] <= JXmax[I])) || (MDEBUG_SETLIMIT>=2 && MDEBUG_M==m)){
	    printf("m=%d:I=%d,L=%d,R=%d,JL=%d,JR=%d,iL=%d,iR=%d:XI=%0.3f,JXmin[I]=%0.3f,JXmax[I]=%0.3f:Y[I]=%0.3f,Hcuts[iL]=%0.3f,Hcuts[iR]=%0.3f,X[JL]=%0.3f,X[JR]=%0.3f\n",
		   m,I,L,R,JL,JR,iL,iR,XI,JXmin[I],JXmax[I],Y[I],Hcuts[iL],Hcuts[iR],X[JL],X[JR]);
	    fflush(stdout);
	    assert(JXmin[I] <= JXmax[I]);
	  }
	}
	if(DEBUG && !(FIX_RANGE_Y && RANGE_Y==0) && !(1 <= Jmin[I] && Jmin[I] <= Jmax[I] && Jmax[I] <= M)){
	  #pragma omp critical
	  {
	    printf("m=%d:I=%d,IMIN=%d,IMAX=%d,Jmin[I]=%d,Jmax[I]=%d,M=%d,Jmid[I]=%d,L=%d,R=%d\n",
		   m,I,IMIN,IMAX,Jmin[I],Jmax[I],M,Jmid[I],L,R);
	    for(register int i=IMIN; i <= IMAX; i++)
	      printf(" i=%d:Jmin[i]=%d,Jmax[i]=%d,Y[i]=%0.3f\n",i,Jmin[i],Jmax[i],Y[i]);
	    for(register int j=Jmin[IMIN]; j <= Jmax[IMAX]; j++)
	      printf("X[%d]=%0.3f\n",j,X[j]);
	    fflush(stdout);
	    assert(1 <= Jmin[I] && Jmin[I] <= Jmax[I] && Jmax[I] <= M);
	  }
	}
      }
    } // if(!(FIX_RANGE_Y && RANGE_Y==0) && Jmid[IMIN] > 0 && Jmid[IMAX > 0)

    if(FIX_RANGE_Y && RANGE_Y==0){/* convert JXmin[],JXmax[] to Jmin[] and Jmax[] values */
      if(MDEBUG_SETLIMIT>=2 && MDEBUG_M==m){
	printf("After converting JXmin[],JXmax[] to Jmin[] and Jmax[] values:IMIN=%d,IMAX=%d\n",IMIN,IMAX);
        fflush(stdout);
      }
      for(int I = IMIN; I <= IMAX;I++){
	double Xleft = JXmin[I];
	double Xright = JXmax[I];
	if(Xleft > X[M+1] || Xright < 0.0){/* no alignment from Y[I] : can happen due to L1 < L and R1 > R above */
	  if(DEBUG && !(I < IMIN1 || I > IMAX1)){
	    printf("m=%d:IMIN1=%d,IMAX1=%d,IMIN=%d,IMAX=%d:I=%d,JXmin[I]=%0.3f,JXmax[I]=%0.3f,X[M+1]=%0.3f\n",
		   m,IMIN1,IMAX1,IMIN,IMAX,I,JXmin[I],JXmax[I],X[M+1]);
	    fflush(stdout);
	    assert(I < IMIN1 || I > IMAX1);
	  }
	  Jmin[I] = M+1;
	  Jmax[I] = 0;

	  if(I < IMIN1){
	    if(DEBUG) assert(I==IMIN);
	    IMIN++;
	  }
	  if(I > IMAX1){
	    for(register int i = I+1; i <= IMAX; i++){
	      if(DEBUG && !(JXmin[i] > X[M+1] || JXmax[i] < 0.0)){
		#pragma omp critical
		{
		  printf("m=%d,M=%d,N=%d,n=%d:i=%d,JXmin[i]=%0.3f,X[M+1]=%0.3f,JXmax[i]=%0.3f\n",
			 m,M,N,n,i,JXmin[i],X[M+1],JXmax[i]);
		  fflush(stdout);
		  assert(JXmin[i] > X[M+1] || JXmax[i] < 0.0);
		}
	      }
	      Jmin[i] = M+1;
	      Jmax[i] = 0;
	    }
	    IMAX = I;
	    break;
	  }
	  continue;
	}

	int Jleft;
	for(Jleft = M; Jleft > 1; Jleft --)
	  if(X[Jleft] <= Xleft)
	    break;
	int Jright;
	for(Jright = 1; Jright < M; Jright++)
	  if(X[Jright] >= Xright)
	    break;
	if((DEBUG && !(Jleft <= Jright)) || (MDEBUG_SETLIMIT>=2 && MDEBUG_M==m) /* ||(DEBUG && m==12753)*/){
	  printf("m=%d:I=%d(IMIN=%d,IMAX=%d),Xleft=%0.3f,Xright=%0.3f,Jleft=%d,Jright=%d,X[Jleft]=%0.3f,X[Jright]=%0.3f,M=%d,X[M+1]=%0.3f,Jmid[I]=%d\n",
		 m,I,IMIN,IMAX,Xleft,Xright,Jleft,Jright,X[Jleft],X[Jright],M,X[M+1],Jmid[I]);
	  fflush(stdout);
	  assert(Jleft <= Jright);
	}
	Jmin[I] = Jleft;
	Jmax[I] = Jright;
	if(DEBUG) assert(1 <= Jmin[I] && Jmin[I] <= Jmax[I] && Jmax[I] <= M);
      }
    }
  } else {/* EXTRAPOLATE >= 1 : extrapolate along entire current alignment bounds */
    for(register int I = IMIN; I <= IMAX; I++){
      /* extrapolate from (I,Jmin[I]) : 
	 For each IMIN <= i <= IMAX decrease Jmin[i] while Y[i]-Y[I] < X[Jmin[i]-1] - X[Jmin[I]).
	 If IMAX < N && Y[IMAX+1]-Y[I] < X[M] - X[Jmin[I]) : initialize Jmin[++IMAX] = M and repeat previous step at i = IMAX, then set Jmax[IMAX] = Jmin[IMAX] and extrapolate (see below);
      */
      register int J = Jmin[I];
      register int i;
      for(i = IMIN; i <= IMAX; i++){
	if(i==I)
	  continue;
	while(Jmin[i] > 1 && Y[i]-Y[I] < X[Jmin[i]-1] - X[J])
	  Jmin[i]--;
      }
      while(IMAX < N && Y[IMAX+1] - Y[I] < X[M] - X[J]){
	Jmin[i = ++IMAX] = M;
	while(Jmin[i] > 1 && Y[i]-Y[I] < X[Jmin[i]-1] - X[J])
	  Jmin[i]--;
	Jmax[i] = Jmin[i];
	while(Jmax[i] < M && Y[I]-Y[i] < X[J] - X[Jmax[i]+1])
	  Jmax[i]++;
      }

      /* extrapolate from (I,Jmax[I]) :
	 For each IMIN <= i <= IMAX increase Jmax[i] while Y[I]-Y[i] < X[Jmax[I]] - X[Jmax[i]+1]
	 If IMIN > 1 && Y[I] - Y[IMIN-1] < X[Jmax[I]] - X[1] : initialize Jmax[--IMIN] = 1 and repeat previous step at i = IMIN, then set Jmin[IMIN] = Jmax[IMIN] and extrapolate (see above)
      */
      J = Jmax[I];
      for(i = IMIN; i <= IMAX; i++){
	if(i==I)
	  continue;
	while(Jmax[i] < M && Y[I]-Y[i] < X[J] - X[Jmax[i]+1])
	  Jmax[i]++;
      }
      while(IMIN > 1 && Y[I] - Y[IMIN-1] < X[J]-X[1]){
	Jmax[i = --IMIN] = 1;
	while(Jmax[i] < M && Y[I]-Y[i] < X[J] - X[Jmax[i]+1])
	  Jmax[i]++;
	Jmin[i] = Jmax[i];
	while(Jmin[i] > 1 && Y[i]-Y[I] < X[Jmin[i]-1] - X[J])
	  Jmin[i]--;
      }
    }
  }

  if(RefineAlignExt){/* extend alignment range to first and last label of molecule (if possible) so -endoutlier penalty is not too dependent on how recently reposition was called */
    int deltaX = max(DELTA_X, deltaExtXRef);
    while(IMAX < N && Jmax[IMAX] < M){
      int I = ++IMAX;
      Jmin[I] = Jmax[I-1];
      Jmax[I] = min(M, Jmax[I-1] + deltaX);
    }
    while(IMIN > 1 && Jmin[IMIN] > 1){
      int I = --IMIN;
      Jmax[I] = Jmin[I+1];
      Jmin[I] = max(1, Jmin[I+1] - deltaX);
    }
  }

  if((MDEBUG_SETLIMIT>=2 && MDEBUG_M==m /* && N==MDEBUG_N+1*/)){
    printf("Extrapolated Alignment bounds:m=%d,N=%d,M=%d, IMIN=%d,IMAX=%d, RANGE_Y=%d,DELTA_X=%d,deltaExtXRef=%d:\n",m,N,M,IMIN,IMAX,RANGE_Y,DELTA_X,deltaExtXRef);
    for(register int i=IMIN; i <= IMAX;i++)
      if(FIX_RANGE_Y && RANGE_Y==0)
	printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,JXmin[I]=%0.3f,JXmax[I]=%0.3f,Y[I]=%0.3f,X[Jmin[I]]=%0.3f,X[Jmax[I]]=%0.3f\n",
	       i,Jmin[i],Jmax[i],JXmin[i],JXmax[i],Y[i],X[Jmin[i]],X[Jmax[i]]);
      else
	printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,Y[I]=%0.3f,X[Jmin[I]]=%0.3f,X[Jmax[I]]=%0.3f\n",i,Jmin[i],Jmax[i],Y[i],X[Jmin[i]],X[Jmax[i]]);
    fflush(stdout);
  }

  if(1 /* EXTRAPOLATE */){
    /* enforce monotonic restrictions IMIN .. IMAX (again) :
       1. Jmin[I=IMAX..IMIN] is a non-increasing function as I decreases.
       2. Jmax[I=IMIN..IMAX] is a non-decreasing function as I increase.
    */
    for(register int I = IMAX; --I >= IMIN;)
      Jmin[I] = min(Jmin[I],Jmin[I+1]);
    for(register int I = IMIN; ++I <= IMAX;)
      Jmax[I] = max(Jmax[I],Jmax[I-1]);

    if(DEBUG)
      for(register int i=IMIN; i <= IMAX;i++)
	if(Jmin[i] <= Jmax[i])
	  assert(Jmin[i] >= 1 && Jmax[i] <= M);

    if((MDEBUG_SETLIMIT && MDEBUG_M==m /*&& N==MDEBUG_N+1*/) || (MDEBUG_SETLIMIT >= 3 && gmap[pcontig->contig[m].mapid]->id == 101000278) /* ||(DEBUG && m==12753) */){
      printf("Final Alignment bounds (after monotonic restriction):m=%d,N=%d,M=%d, IMIN=%d,IMAX=%d:\n",m,N,M,IMIN,IMAX);
      for(register int i=IMIN; i <= IMAX;i++)
	if(FIX_RANGE_Y && RANGE_Y==0)
	  printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,JXmin[I]=%0.3f,JXmax[I]=%0.3f,Y[I]=%0.3f,X[Jmin[I]]=%0.3f,X[Jmax[I]]=%0.3f\n",
		 i,Jmin[i],Jmax[i],JXmin[i],JXmax[i],Y[i],X[Jmin[i]],X[Jmax[i]]);
	else
	  printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,Y[I]=%0.3f,X[Jmin[I]]=%0.3f,X[Jmax[I]]=%0.3f\n",i,Jmin[i],Jmax[i],Y[i],X[Jmin[i]],X[Jmax[i]]);
      fflush(stdout);
    }
  }

  if(VERB>=3 && m==212){
    double Yleft,Yright;
    if(DEBUG) assert(1 <= Jmax[IMIN] && Jmax[IMIN] <= M);
    if(DEBUG) assert(1 <= Jmin[IMAX] && Jmin[IMAX] <= M);
    Yleft = Y[max(0,IMIN-LRANGE)] - X[Jmax[IMIN]];
    Yright = Y[min(N+1,IMAX+LRANGE)] + X[M+1] - X[Jmin[IMAX]];
    printf("setlimit: IMIN=%d,IMAX=%d,X[Jmax[IMIN]=%d]= %0.3f,X[Jmin[IMAX]=%d]= %0.3f, X[M+1]=%0.3f: Yleft=%0.3f, Yright=%0.3f\n",
	   IMIN,IMAX,Jmax[IMIN],X[Jmax[IMIN]],Jmin[IMAX],X[Jmin[IMAX]],X[M+1],Yleft,Yright);
    fflush(stdout);
  }

  if(LRANGE_FIX >=2 && (SETLIMIT_CACHE || Ymin >= 0.0)){
    if(DEBUG) assert(1 <= Jmax[IMIN] && Jmax[IMIN] <= M);
    if(DEBUG) assert(1 <= Jmin[IMAX] && Jmin[IMAX] <= M);
    double Yleft = Y[max(0,IMIN-LRANGE)] - X[Jmax[IMIN]];
    double Yright = Y[min(N+1,IMAX+LRANGE)] + X[M+1] - X[Jmin[IMAX]];
    if(SETLIMIT_CACHE){
      plimit->Ileft = max(0,IMIN-LRANGE);
      plimit->Iright = min(N+1,IMAX+LRANGE);
      plimit->ileft = nmapMD[plimit->Ileft];
      plimit->iright = nmapMD[plimit->Iright];
      if(DEBUG) assert(0 <= plimit->ileft && plimit->ileft <= plimit->iright && plimit->iright <= n+1);
      plimit->Xleft = X[Jmax[IMIN]];
      plimit->Xright = X[M+1] - X[Jmin[IMAX]];
    }

    if(0 /* rverb */){
      printf("m=%d:Y[N+1]=%0.3f:Yleft=%0.3f,Yright=%0.3f,Ymin=%0.3f,Ymax=%0.3f,IMIN=%d,IMAX=%d,Jmax[IMIN]=%d,Jmin[IMAX]=%d,LRANGE=%d\n",
	     m,Y[N+1],Yleft,Yright,Ymin,Ymax,LI,RI,LJ,RJ,LRANGE);
      fflush(stdout);
    }
    if(!force && Ymin >= 0.0 && max(Yleft,Ymin) > min(Yright,Ymax) + 1e-6){
      if(VERB/* HERE >=2 */ && SETLIMIT_CACHE && (VERB>=2 || (rverb && m==MDEBUG_M))){
	printf("\t Skipping alignment of map m=%d: Ymin=%0.6f,Ymax=%0.6f,Yleft -> %0.6f,Yright -> %0.6f\n",m, Ymin, Ymax, Yleft, Yright);
	fflush(stdout);
      }
      if((MDEBUG_SETLIMIT>=2 && MDEBUG_M==m && N==MDEBUG_N) || (VERB>=2 && nverb && m==410)){
	printf("m=%d:Y[N+1]=%0.3f:Yleft=%0.3f,Yright=%0.3f,Ymin=%0.3f,Ymax=%0.3f,IMIN=%d,IMAX=%d,Jmax[IMIN]=%d,Jmin[IMAX]=%d: Skipping alignment of map m\n",
	       m,Y[N+1],Yleft,Yright,Ymin,Ymax,LI,RI,LJ,RJ);
	printf("  X[Jmax[IMIN]]=%0.3f,X[Jmin[IMAX]]=%0.3f,X[M+1]=%0.3f,Y[IMIN-LRANGE]=%0.3f,Y[IMAX+LRANGE]=%0.3f\n",
	       X[Jmax[IMIN]], X[Jmin[IMAX]], X[M+1], Y[max(0,IMIN-LRANGE)], Y[min(N+1,IMAX+LRANGE)]);
	printf("  Final Alignment bounds (after monotonic restriction):m=%d,N=%d,M=%d, IMIN=%d,IMAX=%d:\n",m,N,M,IMIN,IMAX);
	for(register int i=IMIN; i <= IMAX;i++)
	  if(FIX_RANGE_Y && RANGE_Y==0)
	    printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,JXmin[I]=%0.3f,JXmax[I]=%0.3f,Y[I]=%0.3f,X[Jmin[I]]=%0.3f,X[Jmax[I]]=%0.3f\n",
		   i,Jmin[i],Jmax[i],JXmin[i],JXmax[i],Y[i],X[Jmin[i]],X[Jmax[i]]);
	  else
	    printf("   I=%d:Jmin[I]=%d,Jmax[I]=%d,Y[I]=%0.3f,X[Jmin[I]]=%0.3f,X[Jmax[I]]=%0.3f\n",i,Jmin[i],Jmax[i],Y[i],X[Jmin[i]],X[Jmax[i]]);
	fflush(stdout);
      }
      return 0;
    }
  }
 
  if(DEBUG)
    for(int I = IMIN; I <= IMAX; I++)
      assert(1 <= Jmin[I] && Jmin[I] <= Jmax[I] && Jmax[I] <= M);

  /* compute Imin[1..M],Imax[1..M] */
  for(register int J = 1; J <= M; J++){
    Imin[J] = N+1;
    Imax[J] = 0;
  }
  for(register int I = IMIN; I <= IMAX; I++){
    for(register int J = Jmin[I]; J <= Jmax[I]; J++){
      Imin[J] = min(Imin[J],I);
      Imax[J] = max(Imax[J],I);
    }
  }    
  if(DEBUG>=2)
    for(int J = 1; J <= M; J++)
      for(int I = Imin[J]; I <= Imax[J]; I++){
        assert(IMIN <= I && I <= IMAX);
	assert(Jmin[I] <= J && J <= Jmax[I]);
      }

  if(DEBUG>=2) assert(IMIN <= IMAX);

  if(VERB>=2 && IMIN==1 && IMAX==N){
    printf("\nWARNING: setlimit Final alignment is global for m=%d(id=%lld):N=%d,IMIN=%d,IMAX=%d\n",m,gmap[pcontig->contig[m].mapid]->id,N,IMIN,IMAX);
    fflush(stdout);
    //    assert(!(IMIN==1 && IMAX==N));
  }

  return 1;
}

/** return kernel density of Ydist[0..cnt-1].val at mean, assuming a kernel standard variation of var */
static double KernelDensity(Cydist *Ydist, register int cnt, register double  mean, register double Ivar, double &Kmean)
{
  register double Wsum = 0.0, Msum = 0.0;
  register Cydist *p = Ydist;
  for(register int t = cnt; --t >= 0;p++){
    register double val = p->val;
    register double err = mean - val;
    register double wt = p->wt * exp(-err*err*Ivar);
    Wsum += wt;
    Msum += wt * val;
  }

  Kmean = (Wsum > 0.0) ? Msum / Wsum : mean;
  return Wsum;
}

/** compute the mode of the kernel density. Return the mode location (and KDmean = kernel weighted mean, and KDmax = kernel density at mode) */
/* NOTE : RES_VARIANCE ignored */
static double KDmode(Cydist *Ydist, register int cnt,register double *Y, register int Q, double &KDmean, double &KDmax)
{
  if(cnt <= 0)
    return Y[Q+1]-Y[Q];
  if(cnt==1)
    return Ydist[0].val;

  double Kmean;
  double y = Y[Q+1]-Y[Q];
  double var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
  if(QUADRATIC_VARIANCE){
    double ry = SR[0]*y;
    var += ry*ry;
  }
  double Ivar = 0.5/var;
  int maxt = -1;
  KDmax = -1.0e+300;
  for(register int t = 0; t < cnt; t++){
    register Cydist *p = &Ydist[t];
    if(p->val < minKB)
      continue;
    register double KD = KernelDensity(Ydist,cnt, p->val, Ivar, Kmean);
    if(KD > KDmax){
      KDmax = KD;
      KDmean = Kmean;
      maxt = t;
    }
  }
  if(!(KDmax > 0.0 && maxt >= 0 && maxt < cnt)) {
    if(VERB>=2){
      printf("KDmode():Q=%d:KDmax=%0.6f,maxt=%d,cnt=%d (failed due to no values >= minKB (=%0.3f)\n",Q,KDmax,maxt,cnt,minKB);
      fflush(stdout);
    }
    return Y[Q+1]-Y[Q];
  }

  double Xmid = Ydist[maxt].val;
  
  if(max(minKB,Ydist[0].val) < Ydist[cnt-1].val){  /* apply GoldenMean search to refine the location of the density peak */
    double phi = (1.0 + sqrt(5.0))*0.5;
    double resphi = 2.0 - phi;
    double Xlow = Xmid, Xhigh = Xmid;
    for(register int t = maxt; Xlow >= Xmid && --t >= 0;)
      Xlow = max(minKB,Ydist[t].val);
    for(register int t = maxt; Xhigh <= Xmid && ++t < cnt;)
      Xhigh = Ydist[t].val;
    if(DEBUG) assert(Xhigh > Xlow);
    if(Xlow >= Xmid)
      Xlow = Xmid - (Xhigh - Xmid)/phi;
    if(Xhigh <= Xmid)
      Xhigh = Xmid + (Xmid - Xlow)/phi;
    double X;
    while(max(Xhigh-Xmid,Xmid-Xlow) > 0.001){
      if(Xhigh - Xmid > Xmid - Xlow){
	X = Xmid + resphi*(Xhigh-Xmid);
	register double KD = KernelDensity(Ydist,cnt, X, Ivar, Kmean);
	if(VERB>=2){
	  printf("Xlow=%0.4f,Xmid=%0.4f,X=%0.4f,Xhigh=%0.4f:KDmid=%0.6f,KD=%0.6f\n",Xlow,Xmid,X,Xhigh,KDmax,KD);
	  fflush(stdout);
	}
	if(KD > KDmax){
	  KDmax = KD;
	  KDmean = Kmean;
	  Xlow = Xmid;
	  Xmid = X;
	} else
	  Xhigh = X;
      } else {
	X = Xmid - resphi*(Xmid-Xlow);
	register double KD = KernelDensity(Ydist,cnt, X, Ivar, Kmean);
	if(VERB>=2){
	  printf("Xlow=%0.4f,X=%0.4f,Xmid=%0.4f,Xhigh=%0.4f:KD=%0.6f,KDmid=%0.6f\n",Xlow,X,Xmid,Xhigh,KD,KDmax);
	  fflush(stdout);
	}
	if(KD > KDmax){
	  KDmax = KD;
	  KDmean = Kmean;
	  Xhigh = Xmid;
	  Xmid = X;
	} else
	  Xlow = X;
      }
    }
  }

  // return KDmean;
  return Xmid;
}

static double TrimmedMean(register Cydist *Ydist, register int cnt, double trimfactor,register double *Y, register int Q)
{
  qsort(Ydist,cnt,sizeof(Cydist),(intcmp *)Cydistinc);/* this is needed both by KERNEL_MEAN & subsequently in mprobevalwinResize() */

  if(KERNEL_MEAN){
    double KDmean,Kdensity;
    double mode = KDmode(Ydist,cnt,Y,Q,KDmean,Kdensity);
    if(VERB>=2){
      printf("TrimmedMean:Q=%d:Ycnt[Q]=%d(samples sorted),mode=%0.6f,KD=%0.6f,KDmean=%0.6f\n",Q,cnt,mode,Kdensity,KDmean);
      fflush(stdout);
    }
    return mode;
  }

  if(cnt <= 0)
    return Y[Q+1]-Y[Q];
  if(cnt==1)
    return Ydist[0].val;

  register int low = 0;
  register int high = cnt-1;

  //    qsort(Ydist,cnt,sizeof(Cydist),(intcmp *)Cydistinc);

  /* compute weighted average Ydist[low..high] */
  register double Ysum = 0.0, Wsum = 0.0;
  for(register int i = low; i <= high; i++){
    register double wt = Ydist[i].wt;
    Wsum += wt;
    Ysum += Ydist[i].val * wt;
  }
  if(DEBUG && !(Wsum > 0.0)){
    printf("\nTrimmedMean:cnt=%d,trimfactor=%0.3f,low=%d,high=%d:Wsum=%0.6e, Q=%d, Y[Q]=%0.6f,Y[Q+1]=%0.6f,",
	   cnt,trimfactor,low,high,Wsum, Q, Y[Q], Y[Q+1]);
    for(register int i=0;i<cnt;i++)
      printf("Ydist[%d]:val=%0.6f,wt=%0.6f\n",i,Ydist[i].val,Ydist[i].wt);
    fflush(stdout);
    assert(Wsum > 0.0);
  }
  return Ysum / Wsum;
}

static class Cerrplot {
public:
  int id,flip,I,K,J;
  double x,y;
  double wt;
  double norm;
} *errplot = 0;
static int maxerrplot = 0;
static int numerrplot = 0;

static void maxerralloc(int num,int numerrplot, int &maxerrplot, Cerrplot * &errplot)
{
  int newmax = num;
  if(newmax <= maxerrplot)
    return;
  if(newmax < maxerrplot * 2)
    newmax = maxerrplot * 2;
  if(newmax < 1024)
    newmax = 1024;

  if(maxerrplot <= 0)
    errplot = new Cerrplot[newmax];
  else {
    Cerrplot *origerrplot = errplot;
    errplot = new Cerrplot[newmax];
    for(register int i = 0; i < numerrplot; i++)
      errplot[i] = origerrplot[i];
    delete [] origerrplot;
  }
  maxerrplot = newmax;
}

static int CerrNormInc(register Cerrplot *p1, register Cerrplot *p2)
{
  return (p1->norm > p2->norm) ? 1 : (p1->norm < p2->norm) ? -1 : 0;
}

static double maxdrop = 0.0;/* largest drop in LP (large values are suspicious and should be investigated) */

/** Attempt to resize segments in map */
double SizesEstimate(double LP, /**< value for current Y[] */
		     double *TBmapWT, /**< If != 0 : TBmapWT[m] is a the -TB based weight for map m to be applied when summing up the total log(LR+LRbias) value */
		     double *bestLPA,/**< store improved value of per molecule LP here */
		     double *mapWT,/**< mapWT[m=0..MD-1] */
		     int n, double *Hcuts, int *Hdel,
		     int N, double *Y,/**< current and new consensus map */
		     int MD, /**< number of maps */
		     int *MX, double **DX, /**< DX[m=0..MD-1][j=0..MX[m]+1] : map sites */
		     int lc,/**< If left end of Y is a linear chromosome end */
		     int rc,/**< If right end of Y is a linear chromosome end */
		     int **map, /**< map[m=0..MD-1][j=0..MX[m]+1] is index in Y[0..n+1] of X[m][j], 
				   map[MD][j=0..n+1] is index in Y[0..N+1] of Hcuts[j] */
		     int **mapK, /**< mapK[m=0..MD-1][j=0..MX[m]+1] is K index offset in Hcuts[0..n+1] of X[m][j] */ 
		     Csetlimit *limit,
		     int **nmap, /**< nmap[m=0..MD-1][j=0..MX[m]+1] is index in Y[0..N+1] of X[m][j], 
				    nmap[MD][j=0..N+1] is index in Hcuts[0..n+1] of Y[j] */
		     int **nmapK, /**< nmapK[m=0..M-1][j=0..MX[m]+1] is K index offset in Y[0..N+1] of X[m][j]
				     However nmapK[0] == Lij, mapK[MX[m]+1] == Rij (-ve if ends are outliers) */
		     int imin, int imax, /**< Only interested in changes in the region Hcuts[imin] .. Hcuts[imax] */
		     Ccontig *pcontig, /**< pointer to complete contig information for debugging */
		     double trimfactor, /**< The trimmed mean parameters : smallest value 0 corresponds to normal mean
					  largest value 0.5 corresponds to median */
		     int oldmap, /**< If 1 use old mapping (map,mapK) instead of new mapping (nmap,nmapK) to compute draft consensus */
		     int nochange,/**< If 1 don't make any changes to Y[], Hcuts[] (even if LP improves)
		                   * If -1 make change to Y[], Hcuts[] (regardless of whether LP improves) */
		     int &failed, /**< Set to 1 IFF Y[] was not updated, 0 otherwise : 
				    NOTE : Even if Y[] was not updated, return value may be better than LP, if LP did not
				    reflect the latest update to map[],mapK[] */

		     int &mapupdated, /**< Set to 1 IFF UpdateMap() was called successfully */
		     int &Lfrozeni, int &Rfrozeni  /* reference to Lfrozen & Rfrozen from refine() */
		     )
{
  //  mapupdated = 0;//  delete after debugging UpdateMap assertion failure

  if(DEBUG){  /* make sure no real cuts are closer than minKB */
    for(register int I = 1; I < N; I++)
      if(DEBUG && (!(Y[I+1]-Y[I] >= minKB - 2e-9) /*||(360 <= I && I <= 380)*/)){
	printf("SizesEstimate Begin:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
	       I,Y[I],Y[I+1], Y[I+1]-Y[I], minKB);
	fflush(stdout);
	assert(Y[I+1]-Y[I] >= minKB - 2e-9);
      }
    assert(Y[1] >= Y[0]);
    assert(Y[N+1] >= Y[N]);

    if(DEBUG && !(RANGE_Y == RANGE_Y1)){
      printf("SizesEstimate Begin:RANGE_Y=%d,RANGE_Y1=%d\n",RANGE_Y,RANGE_Y1);
      fflush(stdout);
      assert(RANGE_Y == RANGE_Y1);
    }
  }

  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
    (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      int lastJ = -1, lasti = -1, lastk = -1, cnt = 0;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	cnt++;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
	  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	  fflush(stdout);
	  assert(0 <= k && k < i);
	}
	if(lasti >= 0 && !(i-k > lasti)){
	  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	  if(VERB){
	    for(int j = 1; j <= M; j++){
	      int i = map[m][j];
	      if(i < 0)
		continue;
	      int k = mapK[m][j];
	      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	    }
	  }
	  fflush(stdout);
	  assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
      if(DEBUG/* HERE >=2 */ && !(cnt > 0)){
	printf("WARNING in SizesEstimate: No aligned sites in initial map[m][] for m=%d(id=%lld)\n",m, gmap[pcontig->contig[m].mapid]->id);
	fflush(stdout);
	assert(cnt > 0);
      }
    }
  }

  if(VERB){
    printf("Estimating Sizes: N=%d,n=%d:LP=%0.6f (oldmap=%d,nochange=%d,imin=%d,imax=%d,MultiMode=%d):Y[1,N,N+1]=%0.3f,%0.3f,%0.3f\n",N,n,LP,oldmap,nochange,imin,imax,MultiMode,Y[1],Y[N],Y[N+1]);

    if(VERB>=2){
      long long VmSize,VmRSS,VmSwap;
      getmem(VmSize,VmRSS,VmSwap);
      printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmSwap= %0.4f Gb: wall time= %0.6f secs\n",VmSize*1e-6,VmRSS*1e-9,VmSwap*1e-9,wtime());
    }

    fflush(stdout);
  }

  double *newLPA = new double[MD];

  /* save nmap,nmapK,bestLPA */  
  int **orignmap = new int*[MD];
  int *orignmapMD = new int[N+2];
  int **orignmapK = new int*[MD];
  double *bestLPAorig = new double[MD];
  size_t orignmap_pool_size= 0;
  for(register int m = 0; m < MD; m++){
    orignmap_pool_size += MX[m]+2;
    orignmap_pool_size += MX[m]+2;
  }
  int *orignmap_pool = new int[orignmap_pool_size];
  
  for(int m = 0, offset=0; m < MD; m++){
    bestLPAorig[m] = bestLPA[m];
    orignmap[m] = &orignmap_pool[offset]; offset += MX[m]+2;
    orignmapK[m] = &orignmap_pool[offset]; offset += MX[m]+2;
    for(register int j = 0; j <= MX[m]+1; j++){
      orignmap[m][j] = nmap[m][j];
      orignmapK[m][j] = nmapK[m][j];
    }
  }
  for(register int I=0; I <= N+1; I++)
    orignmapMD[I] = nmap[MD][I];

  if(VERB>=2){
    printf("Allocated orignmap etc : orignmap_pool_size= %lu ints\n", orignmap_pool_size);
    if(VERB>=2){
      long long VmSize,VmRSS,VmSwap;
      getmem(VmSize,VmRSS,VmSwap);
      printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmSwap= %0.4f Gb: wall time= %0.6f secs\n",VmSize*1e-6,VmRSS*1e-9,VmSwap*1e-9,wtime());
    }
    fflush(stdout);
  }

  if(DEBUG>=2){
    /* verify LP, nmap,nmapK,bestLPA */
    score_init(N,Y,MD,MX,DX);
    //    rverb = 1;
    double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    //    rverb = 0;
    if(VERB>=2){
      printf("SizesEstimate(nochange=%d):initial verify qLP=%0.10f,orig=%0.10f(err=%0.10f),N=%d,n=%d\n",nochange,qLP,LP,LP-qLP,N,n);
      fflush(stdout);
    }
    if(DEBUG){
      if(!(fabs(LP-qLP) < 1e-8)){
	printf("SizesEstimate(nochange=%d):initial verify qLP=%0.10f,orig LP=%0.10f(err=%0.10f),N=%d,n=%d\n",nochange,qLP,LP,LP-qLP,N,n);
	fflush(stdout);
      }
      for(int m = 0; m < MD; m++){
	if(!(fabs(bestLPA[m] - bestLPAorig[m]) < 1e-8)){
	  printf("m=%d:bestLPA[m]= %0.10f, bestLPAorig[m]= %0.10f (delta= %0.10f)\n",m,bestLPA[m],bestLPAorig[m],bestLPA[m]-bestLPAorig[m]);
	  fflush(stdout);
	}
	assert(fabs(bestLPA[m] - bestLPAorig[m]) < 1e-8);
	for(int j = 0; j <= MX[m]+1; j++){
	  assert(nmap[m][j] == orignmap[m][j]);
	  if(DEBUG && nmap[m][j] >= 0 && !(nmapK[m][j] == orignmapK[m][j])){
	    printf("m=%d,j=%d:nmapK[m][j]=%d,orignmapK[m][j]=%d\n",m,j,nmapK[m][j],orignmapK[m][j]);
	    fflush(stdout);
	    assert(nmapK[m][j] == orignmapK[m][j]);
	  }
	}
      }
    }

    int newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
    assert(newN == N);
    score_init(N,Y,MD,MX,DX);
    qLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    if(VERB>=2){
      printf("SizesEstimate:After setmap(): verify qLP=%0.10f(orig=%0.10f)\n",qLP,LP);
      fflush(stdout);
    }
    if(DEBUG){
      assert(fabs(LP-qLP) < 1e-8);
      for(register int m = 0; m < MD; m++){
	assert(fabs(bestLPA[m] - bestLPAorig[m]) < 1e-8);
	for(register int j = 0; j <= MX[m]+1; j++){
	  assert(nmap[m][j] == orignmap[m][j]);
	  if(DEBUG && nmap[m][j] >= 0 && !(nmapK[m][j] == orignmapK[m][j])){
	    printf("m=%d,j=%d:nmapK[m][j]=%d,orignmapK[m][j]=%d\n",m,j,nmapK[m][j],orignmapK[m][j]);
	    fflush(stdout);
	    assert(nmapK[m][j] == orignmapK[m][j]);
	  }
	}
      }
    }
  }

  // reduce memory used by Ydist[I][0..Ycnt[I]-1], by precomputing largest Ycnt[I] (YcntMax[I] == local coverage) instead of using worst case value of MD
  int *YcntMax = new int[N+1];
  for(register int I = 0; I <= N; I++)
    YcntMax[I] = 0;

  for(int m = 0; m < MD; m++){
    int M = MX[m];
    
    double TBwt = TBmapWT[m];
    if(TBwt <= 0.0)
      continue;

    int *nmapM = nmap[m];
    int *nmapKM = nmapK[m];
    
    /* locate leftmost and rightmost aligned labels IL,IR */
    int IL=0,IR=N+1,I,K;
    if(oldmap){/* use old mapping instead of new mapping */
      for(int J = 1; J <= M; J++){
	int j = map[m][J];
	if(j < 0)
	  continue;
	I = map[MD][j];
	if(I < 0)
	  continue;
	int k = mapK[m][J];
	K = map[MD][j-k];
	IL = I-K;
	break;
      }
      for(int J = M; J >= 1; J--){
	int j = map[m][J];
	if(j < 0)
	  continue;
	I = map[MD][j];
	if(I < 0)
	  continue;
	IR = I;
	break;
      }
    } else {
      for(int J= 0; J <= M+1; J++){
	if((I = nmapM[J]) < 0)
	  continue;
	K = nmapKM[J];
	IL = I-K;
	break;
      }
      for(int J= M+1; J >= 0; J--){
	if((I = nmapM[J]) < 0)
	  continue;
	IR = I;
	break;
      }
    }
    for(int I = IL; I < IR; I++)
      YcntMax[I]++;
  }

  size_t Ydist_pool_size = 0;// WAS  (size_t)(N+1) * (size_t)MD;
  for(int I = 0; I <= N; I++)
    Ydist_pool_size += YcntMax[I];
  if(VERB>=2){
    printf("Allocating Ydist : N=%d, MD=%d,Ydist_pool_size=%lu (%lu bytes)\n",N,MD,Ydist_pool_size,(N+1)*(sizeof(int)+sizeof(Cydist*)) + Ydist_pool_size*sizeof(Cydist));
    fflush(stdout);
  }

  int *Ycnt;
  Cydist **Ydist, *Ydist_pool;
  try {
    Ycnt = new int[N+1];
    Ydist = new Cydist*[N+1];
    Ydist_pool = new Cydist[Ydist_pool_size];
  } catch (exception& e){
    cout << e.what() << endl;
    printf("SizesEstimate(): exception thrown while allocating Ycnt,Ydist:N=%d,MD=%d,Ydist_pool_size=%lu (%lu bytes)\n",N,MD,Ydist_pool_size,(N+1)*(sizeof(int) + sizeof(Cydist*)) + Ydist_pool_size*sizeof(Cydist));
    fflush(stdout);
    assert(0);
  }
  size_t YcntCum = 0;
  for(long long I=0; I <= N; I++){
    Ydist[I] = &Ydist_pool[YcntCum];
    YcntCum += YcntMax[I];
  }
  if(DEBUG) assert(YcntCum <= Ydist_pool_size);

  double *newY = new double[N+2];
  for(register int I = 0; I <= N; I++)
    Ycnt[I] = 0;

  /* Ydist[I][0..Ycnt[I]-1] is the set of sizes (and wts) whose trimmed mean is used to estimate newY[I] */
  if(VERB>=2){
    printf("Allocated Ydist : N=%d, MD=%d (%lu bytes)\n",N,MD,Ydist_pool_size*sizeof(Cydist));
    if(VERB>=2){
      long long VmSize,VmRSS,VmSwap;
      getmem(VmSize,VmRSS,VmSwap);
      printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmSwap= %0.4f Gb: wall time= %0.6f secs\n",VmSize*1e-6,VmRSS*1e-9,VmSwap*1e-9,wtime());
    }
    fflush(stdout);
  }

  if(VERB>=2 && rverb>=2){
    printf("SizesEstimate: initial consensus map: N=%d\n",N);
    for(register int I = 0; I <= N; I++)
      printf("I=%d:Y[I+1]-Y[I]=%0.6f\n",I,Y[I+1]-Y[I]);
    fflush(stdout);
  }
  if(DEBUG)
    for(register int I = 0; I <= N; I++){
      if(Y[I+1] < Y[I]){
	printf("SizesEstimate:I=%d,Y[I]=%0.6f,Y[I+1]=%0.6f,delta=%0.6e\n",
	       I,Y[I],Y[I+1], Y[I+1]-Y[I]);
	fflush(stdout);
	assert(Y[I+1] >= Y[I]);
      }
    }

  int maxM = 0;
  for(register int m = 0; m < MD; m++)
    maxM = max(maxM, MX[m]);
  int *Ilist = new int[maxM+2];
  int *Jlist = new int[maxM+2];
  int *Klist = new int[maxM+2];

  if(VERB>=2){
    printf("allocated Ilist,Jlist,Klist: maxM= %d\n",maxM);
    if(VERB>=2){
      long long VmSize,VmRSS,VmSwap;
      getmem(VmSize,VmRSS,VmSwap);
      printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmSwap= %0.4f Gb: wall time= %0.6f secs\n",VmSize*1e-6,VmRSS*1e-9,VmSwap*1e-9,wtime());
    }
    fflush(stdout);
  }

  /* accumulate Ycnt[] and Ydist[] as count and weighted distribution of x intervals over all MD maps (currently excluding map outliers) */
  double extendL = -1000.0, extendR = -1000.0;
  int mL = -1 ,mR = -1;
  for(int m = 0; m < MD; m++){
    int M = MX[m];
    
    double TBwt = TBmapWT[m];
    if(TBwt <= 0.0)
      continue;

    double *X = DX[m];
    int *nmapM = nmap[m];
    int *nmapKM = nmapK[m];

    /* assembled alignment lists */
    int U = 0;
    int I,J,K;

    for(J = 0; J <= M+1; J++){
      
      if(oldmap){/* use old mapping instead of new mapping */
	if(J <= 0 || J > M)/* mapping of ends should be ignored since they map to placeholder sites in Hcuts with sitecnt=0 */
	  continue;

	register int j = map[m][J];
	if(j < 0)
	  continue;
	if(DEBUG) assert(0 <= j && j <= n+1 );
	I = map[MD][j];
	if(I < 0)
	  continue;
	if(DEBUG) assert(0 <= I && I <= N+1);
	register int k = mapK[m][J];
	if(DEBUG) assert(0 <= k && k <= j);
	K = map[MD][j-k];
	if(DEBUG && !(0 <= K && K <= I)){
	  printf("m=%d/%d:mapid=%d(id=%lld):M=%d,N=%d,n=%d:J=%d,j=%d,I=%d,mapK[m][J]=k=%d,map[MD][j-k]=K=%d\n",
		 m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,J,j,I,k,K);
	  fflush(stdout);
	  assert(0 <= K && K <= I);
	}
	K = I-K;
	if(DEBUG) assert(0 <= K && K <= KMAX && K <= I);
	if(DEBUG && (!(lc || J > 0) || !(rc || J <= M))){
	  printf("m=%d/%d:mapid=%d(id=%lld):M=%d,N=%d,n=%d:lc=%d,rc=%d,oldmap=%d,J=%d,j=%d,I=%d,k=%d,K=%d\n",
		 m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,lc,rc,oldmap,J,j,I,k,K);
	  fflush(stdout);
	}
	if(DEBUG) assert(lc || J > 0);
	if(DEBUG) assert(rc || J <= M);
      } else {/* use new mapping (most recently updated by qprobeval) */
	if((I = nmapM[J]) < 0)
	  continue;
	if(DEBUG && !(0 <= I && I <= N+1)){
	  printf("m=%d,J=%d:nmap[m][J]=%d,I=%d,N=%d\n",m,J,nmap[m][J],I,N);
	  fflush(stdout);
	  assert(0 <= I && I <= N+1);
	}
	K = nmapKM[J];
	if(DEBUG) assert(K <= I);
	if(DEBUG) assert(0 <= K && K <= KMAX);
	if(DEBUG && (!(lc || J>0) || !(rc || J <= M))){
	  printf("m=%d/%d:mapid=%d(id=%lld):M=%d,N=%d,n=%d:lc=%d,rc=%d,J=%d(!),I=%d,K=%d\n",
		 m,MD,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,M,N,n,lc,rc,J,I,K);
	  fflush(stdout);
	  if(DEBUG) assert(lc || J > 0);
	  if(DEBUG) assert(rc || J <= M);
	}
      }

      if(DEBUG) assert(lc || J > 0);
      if(DEBUG) assert(rc || J <= M);
      Ilist[U] = I;
      Jlist[U] = J;
      Klist[U] = K;
      U++;
    }
    if(U>0){
      int H = Ilist[0];
      int D = Klist[0];
      int G = Jlist[0];
      if(EXTEND && !oldmap && nmapKM[0] >= 0){ /* check Left end extension */
	double y = Yc(Y,H,D);
	double x = X[G];
	if(x-y > extendL){
	  extendL = x-y;
	  mL = m;
	}
      }
      if(U > 1){
	if(LVERB >= 2 && rverb){
	    printf("m=%d,mapid=%d(id=%lld),flip=%d:U=%d:",
		   m,pcontig->contig[m].mapid,gmap[pcontig->contig[m].mapid]->id,pcontig->flip[m],U);
	    if(U > COVERAGE_TRIM*2)
	      printf("Y[%d]=%0.3f,Y[%d]=%0.3f,Y[%d]=%0.3f,Y[%d]=%0.3f",
		     Ilist[0],Y[Ilist[0]],
		     Ilist[COVERAGE_TRIM],Y[Ilist[COVERAGE_TRIM]],
		     Ilist[U-1-COVERAGE_TRIM]-Klist[U-1-COVERAGE_TRIM],Y[Ilist[U-1-COVERAGE_TRIM]-Klist[U-1-COVERAGE_TRIM]],
		     Ilist[U-1]-Klist[U-1],Y[Ilist[U-1]-Klist[U-1]]);
	  printf("\n");
	  fflush(stdout);
	}
	for(int T=1; T < U; T++, H = I, D = K, G = J){
	  I = Ilist[T];
	  K = Klist[T];
	  J = Jlist[T];
	  if(CENTERED_MEAN && (T <= CENTERED_MEAN || T >= U-CENTERED_MEAN))
	    continue;/* avoid using N outermost aligned intervals for sizing (N == CENTERED_MEAN) */
	  double y = Yc(Y,I,K) - Yc(Y,H,D);
	  double x = X[J] - X[G];
	  double wt = 1.0;
	  if(MEDIAN_SKIPOUTLIER && !oldmap && Poutlier > 0.0 && OUTLIER(x,y)){
	    double LR = FA(x,y,J-G,I-K-H,J,I,K,D,N,VARtab[K*N+I],VARtab[D*N+H],FBiasWTm[J-G],LogFpPow[J-G-1],LogFnPow[I-K-H-1], PrBiasWT[I-K]-PrBiasWT[H], PRtab[I-K-H-1][I-K].Pr,Y,0, OUTLIER_TYPE, OUTLIER_OLD(outlierMaxBC));
	    wt = LR*(1.0-Poutlier)/(Poutlier + LR*(1.0-Poutlier));
	    wt = max(0.001,wt);
	  }
	  if(ERRPLOT>=2 && rverb){
	    double var = SF[0]*SF[0] + fabs(SD[0])*SD[0]*y;
	    if(QUADRATIC_VARIANCE)
	      var += SR[0]*SR[0]*y*y;
	    if(RES_VARIANCE){
	      double resR = Y[I] - Y[I-K];
	      double resL = Y[H] - Y[H-D];
	      double resvar = resL*resL + resR*resR;
	      var += SE[0]*SE[0] * resvar;
	    }
	    double err = x-y;
	    if(numerrplot >= maxerrplot)
	      maxerralloc(numerrplot+1,numerrplot, maxerrplot, errplot);
	    register Cerrplot *perr = &errplot[numerrplot++];
	    perr->id = gmap[pcontig->contig[m].mapid]->id;
	    perr->flip = pcontig->flip[m];
	    perr->I = I;
	    perr->K = K;
	    perr->J = J;
	    perr->x = x;
	    perr->y = y;
	    perr->wt = wt * TBwt;
	    perr->norm = err/sqrt(var);
	  }

	  double InvY = 1.0/y;
	  double xBy = x * InvY;
	  for(int Q = H; Q < I-K; Q++){/* process Y[Q..Q+1] */
	    if(DEBUG) assert(Ycnt[Q] < YcntMax[Q]);
	    Cydist *p = &Ydist[Q][Ycnt[Q]++];
	    double yQ = Y[Q+1]-Y[Q];
	    double Xscale = yQ*xBy;
	    p->val = Xscale;
	    p->wt = (WEIGHTED_MEAN >= trimfactor) ? wt : 1.0;
	    if(MEAN_FIX)
	      p->wt *= (yQ * InvY);
	    p->wt *= TBwt;
	    if(ERRPLOT && rverb && (Q==155/* (Q>=116 && Q<=118) *//* (U > COVERAGE_TRIM*2 && Y[Ilist[COVERAGE_TRIM]] <= 511.834 + 0.001  && Y[Ilist[U-1-COVERAGE_TRIM]-Klist[U-1-COVERAGE_TRIM]] >= 533.508 - 0.001)  */
				    /* || m==20 || (Q == 2 || Q==13)*/)){
	      double pwt = p->wt;/* TrimmedMean() may reorder Ydist[Q][] and hence the pointer p will become invalid */
	      double mean = TrimmedMean(Ydist[Q],Ycnt[Q],trimfactor,Y,Q);
	      printf("m=%d/%d,id=%lld,flip=%d,L=%d,R=%d,T=%d/%d:H=%d,D=%d,G=%d,I=%d,K=%d,J=%d,M=%d:X[G]=%0.3f,X[J]=%0.3f,x=%0.3f,Y[H-D]=%0.3f,Y[H]=%0.3f,Y[I-K]=%0.3f,Y[I]=%0.3f,y=%0.3f:Q=%d,wt=%0.4f,%0.4f,Y[Q..Q+1]=%0.3f,X[Q..Q+1]=%0.3f(cnt=%d,mean=%0.6f)\n",
		     m,MD,gmap[pcontig->contig[m].mapid]->id,pcontig->flip[m],pcontig->contig[m].trimL[0],pcontig->contig[m].trimR[0],T,U,H,D,G,I,K,J,M,X[G],X[J],x,Y[H-D],Y[H],Y[I-K],Y[I],y,Q,wt,pwt,yQ,Xscale,Ycnt[Q],mean);
	      fflush(stdout);
   	    }
	  }
	  if(DEBUG) assert(0 <= G && G < J && J <= M+1);
	}
      }
      /* check right end extension */
      if(DEBUG) assert(H == Ilist[U-1]);
      if(DEBUG) assert(D == Klist[U-1]);
      if(DEBUG) assert(G == Jlist[U-1]);
      if(EXTEND && !oldmap && nmapKM[M+1] >= 0){
	register double y = Y[N+1] - Yc(Y,H,D);
	register double x = X[M+1] - X[G];
	if(x-y > extendR){
	  extendR = x - y;
	  mR = m;
	}
      }
    }
  }
  
  if(ERRPLOT>=2 && rverb){
    qsort(errplot,numerrplot,sizeof(Cerrplot),(intcmp*) CerrNormInc);
    printf("Errplot : %d sizing errors sorted in ascending order of normalized error:\n",numerrplot);
    printf("%9s %6s %4s %3s %1s %2s %6s %6s %8s %10s %10s %10s %10s %10s %10s\n","QQ","ID","flip","I","K","J","x","y","wt","Actual","Gaussian", "Huber1.0", "Huber2.0", "Huber3.0", "Huber4.0");
    register double wtsum = 0.0;
    for(register int i=0; i < numerrplot; i++)
      wtsum += errplot[i].wt;

    wtsum = 1.0/wtsum;
    register double wtcum = 0.0;
    for(register int i=0; i < numerrplot; i++){
      register Cerrplot *perr = &errplot[i];
      register double QQ = (wtcum+0.5*perr->wt)*wtsum;
      printf("%9.7f %6d %4d %3d %1d %2d %6.3f %6.3f %8.6f %10.6f %10.6f %10.6f %10.6f %10.6f %10.6f\n",
	     QQ,perr->id,perr->flip,perr->I,perr->K,perr->J,perr->x,perr->y,perr->wt,perr->norm,
	     zscore(1.0-QQ),Hscore(1.0-QQ,1.0),Hscore(1.0-QQ,2.0),Hscore(1.0-QQ,3.0),Hscore(1.0-QQ,4.0));
      wtcum += perr->wt;
    }
    fflush(stdout);

    delete [] errplot;
    errplot = 0;
    numerrplot = maxerrplot = 0;
  }

  newY[0] = 0.0;

  /* determine range Y[LfrozenI..RfrozenI] that includes frozen range Hcuts[Lfrozeni..Rfrozeni] */  
  int LfrozenI = map[MD][Lfrozeni],RfrozenI = map[MD][Rfrozeni];
  if(extendonly && Refine && Rfrozeni > Lfrozeni){
    /* NOTE : there may be no actual site in Y[] at Hcuts[Lfrozeni] or Hcuts[Rfrozeni] : if so the frozen range is shrunk to the nearest site in Y[] */
    if(LfrozenI < 0)
      for(register int I = 1; I <= N; I++){
	register int i = nmap[MD][I];
	if(DEBUG) assert(i >= 1 && i <= n);
	if(i >= Lfrozeni){
	  LfrozenI = I;
	  break;
	}
      }
    if(RfrozenI < 0)
      for(register int I = N; I >= 1; I--){
	register int i = nmap[MD][I];
	if(DEBUG) assert(i >= 1 && i <= n);
	if(i <= Rfrozeni){
	  RfrozenI = I;
	  break;
	}
      }
    if(LfrozenI < 0 || RfrozenI < 0 || RfrozenI < LfrozenI)
      LfrozenI = RfrozenI = (1+N)/2;/* no frozen range */
    if((DEBUG && extend <= 1 && !(LfrozenI <= 1 && RfrozenI >= N)) || VERB/* HERE >=2 */){
      printf("SizesEstimate:Hcuts[Lfrozeni=%d,Rfrozeni=%d]= %0.3f,%0.3f, n=%d:N=%d,Y[LfrozenI=%d,RfrozenI=%d]= %0.3f,%0.3f, extend=%d,extendonly=%d(cum wall= %0.6f)\n",
	     Lfrozeni,Rfrozeni,Hcuts[Lfrozeni],Hcuts[Rfrozeni],n,N,LfrozenI,RfrozenI,Y[LfrozenI],Y[RfrozenI],extend,extendonly,wtime());
      fflush(stdout);
      if(DEBUG && extend <= 1) 
        assert(LfrozenI <= 1 && RfrozenI >= N);
    }
  }

  /* expand range of interest imin..imax, if needed to align with Y[] sites locations */
  int Imin = map[MD][imin], Imax = map[MD][imax];
  if(Imin < 0)
    for(Imin = 0; Imin <= N+1; Imin++){
      register int i = nmap[MD][Imin];
      if(DEBUG) assert(i >= 0 && i <= n+1);
      if(i >= imin)
	break;
    }
  if(Imax < 0)
    for(Imax = N+1; Imax >= 0; Imax--){
      register int i = nmap[MD][Imax];
      if(DEBUG) assert(i >= 0 && i<=n+1);
      if(i <= imax)
	break;
    }

  for(register int I=0; I <= N; I++){
    if((extendonly && Refine && Rfrozeni > Lfrozeni && I >= LfrozenI && I+1 <= RfrozenI) || I < Imin || I > Imax){ /* Y[I..I+1] is in frozen range Y[LfrozenI .. RfrozenI] or outside the range Y[Imin..Imax] */
      if(DEBUG && !(Y[I+1]-Y[I] >= ((I==0||I==N) ? 0.0 : minKB - 2e-9))){
	printf("SizesEstimate during newY update:I=%d:Ycnt[I]=%d,Y[I+1]=%0.6f,Y[I]=%0.6f,delta=%0.6f,minKB=%0.6f\n",
	       I,Ycnt[I],Y[I+1],Y[I],Y[I+1]-Y[I],minKB);
	fflush(stdout);
	assert(Y[I+1]-Y[I] >= ((I==0||I==N) ? 0.0 : minKB - 2e-9));
      }
      newY[I+1] = newY[I] + (Y[I+1]-Y[I]);
    } else if(Ycnt[I] > 0){
      register double delta = TrimmedMean(Ydist[I],Ycnt[I],trimfactor,Y,I);
      if(DEBUG && (!(delta >= 0.0) || (VERB && rverb && I==N))){
	printf("I=%d,N=%d:Ycnt[I]=%d,trimfactor=%0.4f:TrimmedMean = %0.6e\n",
	       I,N,Ycnt[I],trimfactor,delta);
	fflush(stdout);
	assert(delta >= 0.0);
      }
      if(I!=0 && I!=N){
	delta = max(delta,minKB);
	if(DEBUG) assert(delta >= minKB);
      }
      /* check if BLOCK_RESIZE causes the problem with sizing and if it can be relaxed when coverage is high so there are actual alignment pairs spanning this interval 
	 ((trimfactor > WEIGHTED_MEAN) && (there are multiple i for which Ydist[I][i].wt >= 1) */
      if(BLOCK_RESIZE > 0.0 /* HERE && Y[I+1]-Y[I] < BLOCK_RESIZE * resKB && delta > Y[I+1]-Y[I]*/){
	int resolved = 0;
	double sum = 0.0;
	for(register int t = 0; t < Ycnt[I]; t++)
	  if(!MEAN_FIX || Ydist[I][t].wt >= 0.99){
	    resolved++;
	    sum += Ydist[I][t].val;
	  }
	if(ERRPLOT && VERB && rverb){
	  if(Y[I+1] - Y[I] < BLOCK_RESIZE * resKB && delta > Y[I+1]-Y[I] &&/*HERE*/ resolved < BLOCK_RESOLVE){
	    if(I+1 < N && I > 1)
	      printf("I=%d,N=%d:Ycnt[I]=%d,Y[I-1]=%0.3f,Y[I]=%0.3f,Y[I+1]=%0.3f,Y[I+2]=%0.3f blocked increasing Y[I..I+1] from %0.3f to %0.3f (resolved site pairs=%d, mean=%0.3f)\n",
		     I,N,Ycnt[I],Y[I-1],Y[I],Y[I+1],Y[I+2],Y[I+1]-Y[I], delta, resolved, sum/(max(1,resolved)));
	    else
	      printf("I=%d,N=%d:Ycnt[I]=%d,Y[I]=%0.3f,Y[I+1]=%0.3f, blocked increasing Y[I..I+1] from %0.3f to %0.3f (resolved site pairs=%d, mean=%0.3f)\n",
		     I,N,Ycnt[I],Y[I],Y[I+1], Y[I+1]-Y[I], delta, resolved, sum/(max(1,resolved)));
	  } else {
	    if(I+1 < N && I > 1)
	      printf("I=%d,N=%d:Ycnt[I]=%d,Y[I-1]=%0.3f,Y[I]=%0.3f,Y[I+1]=%0.3f,Y[I+2]=%0.3f: changing Y[I..I+1] from %0.3f to %0.3f (resolved site pairs=%d, mean=%0.3f)\n",
		     I,N,Ycnt[I],Y[I-1],Y[I],Y[I+1],Y[I+2],Y[I+1]-Y[I], delta, resolved, sum/(max(1,resolved)));
	    else
	      printf("I=%d,N=%d:Ycnt[I]=%d,Y[I]=%0.3f,Y[I+1]=%0.3f: changing Y[I..I+1] from %0.3f to %0.3f (resolved site pairs=%d, mean=%0.3f)\n",
		     I,N,Ycnt[I],Y[I],Y[I+1], Y[I+1]-Y[I], delta, resolved, sum/(max(1,resolved)));
	  }
	  fflush(stdout);
	}
	if((Y[I+1]-Y[I] < BLOCK_RESIZE * resKB && delta > Y[I+1]-Y[I])){/* HERE */
	  if(resolved >= BLOCK_RESOLVE){
	    double mean = sum/resolved;
	    if(DEBUG>=2 && !isfinite(mean)){
	      printf("I=%d,N=%d:Ycnt[I]=%d,Y[I]=%0.3f,Y[I+1]=%0.3f, resolved site pairs=%d,mean=%0.3f\n",
		     I,N,Ycnt[I],Y[I],Y[I+1],resolved,mean);
	      fflush(stdout);
	      assert(isfinite(mean));
	    }
	    mean = max(mean,minKB);
	    /*	    if(DEBUG && !(mean >= minKB)){
	      printf("I=%d,N=%d:Ycnt[I]=%d,Y[I]=%0.3f,Y[I+1]=%0.3f, resolved site pairs=%d,mean=%0.3f\n",
		     I,N,Ycnt[I],Y[I],Y[I+1],resolved,mean);
	      for(register int t = 0; t < Ycnt[I]; t++)
		if(!MEAN_FIX || Ydist[I][t].wt >= 0.99)
		  printf("   t=%d/%d:val=%0.3f\n",t,Ycnt[I],Ydist[I][t].val);
	      fflush(stdout);
	      assert(mean >= minKB);
	      }*/
	    if(delta > mean)
	      delta = mean;
	  } else /* no change allowed */
	    delta = Y[I+1]-Y[I];
	}
      }
      if(VERB && (VERB>=2 || rverb)){
	printf("I=%d,N=%d:Ycnt[I]=%d,Y[I..I+1]=%0.6f->%0.6f\n",I,N,Ycnt[I],Y[I+1]-Y[I],delta);
	fflush(stdout);
      }
      if(DEBUG>=2) assert(isfinite(delta));
      newY[I+1] = newY[I] + delta; 
    } else {/* Ycnt[I] <= 0 */
      if(VERB && rverb && I==N){
	printf("I=%d,N=%d:Ycnt[I]=%d,Y[I+1]=%0.6f,Y[I]=%0.6f,extendL=%0.6f(mL=%d),extendR=%0.6f(mR=%d)\n",I,N,Ycnt[I],Y[I+1],Y[I],extendL,mL,extendR,mR);
	fflush(stdout);
      }
      if(DEBUG && !(Y[I+1]-Y[I] >= ((I==0||I==N) ? 0.0 : minKB - 2e-9))){
	printf("SizesEstimate during newY update:I=%d:Ycnt[I]=%d,Y[I+1]=%0.6f,Y[I]=%0.6f,delta=%0.6f,minKB=%0.6f\n",
	       I,Ycnt[I],Y[I+1],Y[I],Y[I+1]-Y[I],minKB);
	fflush(stdout);
	assert(Y[I+1]-Y[I] >= ((I==0||I==N) ? 0.0 : minKB - 2e-9));
      }
      newY[I+1] = newY[I] + max(Y[I+1]-Y[I],((I==0 || I==N) ? 0.0 : minKB));
      if(EXTEND && extend >= 2 && I==0 && extendL > -1000.0 && Imin <= 0){
	if(Y[1]+extendL < MININTERVAL)
	  extendL = -(Y[1]-MININTERVAL);
	newY[1] += extendL;
	if(DEBUG) assert(newY[1] >= newY[0] + MININTERVAL - 2e-9);
      }
      if(EXTEND && extend >= 2 && I==N && extendR > -1000.0 && Imax >= N+1){
	if(Y[I+1]+extendR < Y[I]+MININTERVAL)
	  extendR = -(Y[I+1]-Y[I]-MININTERVAL);
	newY[I+1] += extendR;
	if(DEBUG && !(newY[I+1] >= newY[I] + MININTERVAL - 2e-9)){ 
	  printf("I=%d,N=%d:Ycnt[I]=%d,Y[I+1]=%0.6f,Y[I]=%0.6f,extendL=%0.6f(mL=%d),extendR=%0.6f(mR=%d)\n",I,N,Ycnt[I],Y[I+1],Y[I],extendL,mL,extendR,mR);
	  fflush(stdout);
	  assert(newY[I+1] >= newY[I] + MININTERVAL - 2e-9);
	}
      }
    }
    if(VERB>=2 && rverb && 5 <= I && I<=15){
      if(fabs(newY[I+1]-Y[I+1]) > newY[I+1] * 0.01 + 0.01)
	printf("Y[%d]=%0.6f -> %0.6f !\n", I+1, Y[I+1], newY[I+1]);
      else
	printf("Y[%d]=%0.6f -> %0.6f\n", I+1, Y[I+1], newY[I+1]);
      fflush(stdout);
    }
  }

  if(DEBUG){  /* make sure no real cuts are closer than minKB */
    for(register int I = 1; I < N; I++)
      if(DEBUG && (!(newY[I+1]-newY[I] >= minKB - 2e-9) /*||(360 <= I && I <= 380)*/)){
	printf("SizesEstimate End:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
	       I,newY[I],newY[I+1], newY[I+1]-newY[I], minKB);
	fflush(stdout);
	assert(newY[I+1]-newY[I] >= minKB - 2e-9);
      }
    assert(newY[1] >= newY[0]);
    if(DEBUG && !(newY[N+1] >= newY[N])){
      printf("SizesEstimate End:N=%d,newY[N]=%0.6f,newY[N+1]=%0.6f\n",
	     N,newY[N],newY[N+1]);
      fflush(stdout);
      assert(newY[N+1] >= newY[N]);
    }
  }

  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
    (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      int lastJ = -1, lasti = -1, lastk = -1, cnt = 0;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	cnt++;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
	  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	  fflush(stdout);
	  assert(0 <= k && k < i);
	}
	if(lasti >= 0 && !(i-k > lasti)){
	  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	  if(VERB){
	    for(int j = 1; j <= M; j++){
	      int i = map[m][j];
	      if(i < 0)
		continue;
	      int k = mapK[m][j];
	      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	    }
	  }
	  fflush(stdout);
	  assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
      if(DEBUG/* HERE >=2 */ && !(cnt > 0)){
	printf("WARNING in SizesEstimate: No aligned sites in initial map[m][] for m=%d(id=%lld)\n",m, gmap[pcontig->contig[m].mapid]->id);
	fflush(stdout);
	assert(cnt > 0);
      }
    }
  }

  int origrverb = rverb;
  rverb = 0;

  if(DEBUG>=2){
    /* verify nmap,nmapK,bestLPA based on original backup */
    score_init(N,Y,MD,MX,DX);
    double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    if(VERB>=2){
      printf("SizesEstimate: 2nd verify qLP=%0.6f(orig=%0.6f)\n",qLP,LP);
      fflush(stdout);
    }
    if(DEBUG){
      assert(fabs(LP-qLP) < 1e-8);
      for(register int m = 0; m < MD; m++){
	assert(fabs(bestLPA[m] - bestLPAorig[m]) < 1e-8);
	for(register int j = 0; j <= MX[m]+1; j++){
	  assert(nmap[m][j] == orignmap[m][j]);
	  if(DEBUG && nmap[m][j] >= 0 && !(nmapK[m][j] == orignmapK[m][j])){
	    printf("m=%d,j=%d:nmapK[m][j]=%d,orignmapK[m][j]=%d\n",m,j,nmapK[m][j],orignmapK[m][j]);
	    fflush(stdout);
	    assert(nmapK[m][j] == orignmapK[m][j]);
	  }
	}
      }
    }
  }

  double newLP = LP;
  if(!(MultiMode && nochange <= 0)){
    /* call qprobeval(n,Hcuts) to check if newY is better than Y */
    score_init(N,newY,MD,MX,DX);/* precompute likelihood scoring constants/terms */  
    newLP = qprobeval(n,Hcuts,N,newY,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    if(VERB>=2){
      printf("  For newY[]: newLP=%0.10f (for Y[] LP=%0.10f)\n",newLP,LP);
      fflush(stdout);
    }
    
    rverb = 0;
    
    if(DEBUG && LP - newLP > maxdrop){
      if(VERB>=2 || ERRPLOT){
	printf("\nLP=%0.6f -> %0.6f : maxdrop = %0.6f -> %0.6f\n",LP, newLP, maxdrop, LP-newLP);
	fflush(stdout);
      }
      maxdrop = LP - newLP;
    }
  }

  int prevDELTA_X = DELTA_X;
  int prevDELTA_Y = DELTA_Y;
  int prevRANGE = RANGE;
  int prevRANGE_Y = RANGE_Y;
  int prevOutlierType = OutlierType;
  double prevOutlierLambda = outlierLambda;
  double prevPoutlier = Poutlier;
  double prevPoutlierEnd = PoutlierEnd;
  double prevLRbias = LRbias;
  double prevSF = SF[0];
  double prevSR = SR[0];

  if(MultiMode && (newLP < LP - MULTIMODAL_TRIGGER || (nochange <= 0))){
    int *MMforce = 0;
    MMforce = new int[N+1];
    for(register int I = 0; I <= N; I++)
      MMforce[I] = (I >= Imin && I < Imax) ? 1 : 0;/* saved copy for current call to SizesEstimate() */

    if(VERB>=2){    /* display details of current consensus map */
      printf("SizeUpdate:LP=%0.6f->%0.6f,MD=%d,N=%d,Y[N+1]=%0.3f,trimfactor=%0.2f,extendL=%0.3f(mL=%d),extendR=%0.3f(mR=%d)\n",
	     LP,newLP,MD,N,Y[N+1],trimfactor,extendL,mL,extendR,mR);
      if(VERB>=2){
	printf("Proposed change in Y: N=%d\n",N);
	register double cum = 0.0;
	for(register int i = 0; i <= N; i++){
	  double delta = (newY[i+1]-newY[i])-(Y[i+1]-Y[i]);
	  cum += delta;
	  printf("Y[%d] = %0.3f, Y[%d]-Y[%d] = %0.3f -> %0.3f (delta = %0.3f, cum=%0.3f)\n", i, Y[i], i+1,i, Y[i+1]-Y[i], newY[i+1]-newY[i], delta,cum);
	}
	if(VERB>=3){
	  printf("original Hcuts & Hdel:n=%d\n",n);
	  for(register int i = 0; i <= n+1; i++)
	    printf("i=%d:Hcuts[i]=%0.3f,Hdel[i]=%d\n",i,Hcuts[i],Hdel[i]);
	}
      }
      printf("Starting MultiMode LR optimization: LP=%0.6f, newLP=%0.6f, MMforce=%d,Imin=%d,Imax=%d\n", LP, newLP, MultiMode ? 1 : 0,Imin,Imax);
      fflush(stdout);
    }

    register double *fixY = new double[N+2];
    register double *fixYdel = new double[N+2];
    fixY[0] = fixYdel[0] = 0.0;
    for(register int I=1; I <= N+1; I++)
      fixYdel[I] = Y[I]-Y[I-1];

    /* adjust end intervals of fixY[],fixYdel[] based on newY[] */
    if(!lc && Imin <= 0)
      fixYdel[1] = newY[1];
    if(!rc && Imax >= N+1)
      fixYdel[N+1] = newY[N+1]-newY[N];

    if(1){
      register double cum = fixYdel[0];
      register double shift = fixYdel[1] - Y[1];
      for(register int I = 1; I <= N+1; I++){
	cum += fixYdel[I];
	fixY[I] = cum;
	if(DEBUG && I<=N && fabs(fixY[I]-Y[I]-shift) >= Y[I]*2e-9 + 2e-9){
	  printf("I=%d,N=%d:Y[I]=%0.10f,fixY[I]-shift=%0.10f(fixY[I]=%0.10f,shift=%0.10f,Y[1]=%0.10f,newY[1]=%0.10f)\n",I,N,Y[I],fixY[I]-shift,fixY[I],shift,Y[1],newY[1]);
	  fflush(stdout);
	  assert(fabs(fixY[I]-Y[I]-shift) < Y[I]*2e-9 + 2e-9);
	}
      }
    }

    // customize OutlierType=0,outlierLambda,Poutlier,PoutlierEnd,LRbias,RANGE= origRANGE along with DELTA_X,RANGE_Y to improve performance/speed of mprobeval() for resizing intervals
    double qLP = LP;
    double qLPstart = qLP;
    if(RANGE_UPDATE)
      RANGE = origRANGE;/* small value for speed */
    if(outlierLambdaSwitch)
      outlierLambda = outlierLambdaSize;
    if(OutlierTypeSwitch){
      OutlierType = OutlierTypeSize;
      if(OUTLIER_TYPE != OutlierType){
	printf("WARNING:OutlierTypeSwitch not working because OUTLIER_TYPE in RGentigScore.h is a compile time constant of %d\n",OUTLIER_TYPE);
	fflush(stdout);
	OutlierType = OUTLIER_TYPE;
      }
    }
    RANGE_Y = RANGE_Y1;
    if(PoutlierSwitch)
      Poutlier = PoutlierSize;
    if(PoutlierEndSwitch)
      PoutlierEnd = PoutlierEndSize;
    if(LRbiasSwitch)
      LRbias = LRbiasSize;
    if(MinSFSwitch)
      SF[0] = max(MinSFSize, SF[0]);
    if(MinSRSwitch)
      SR[0] = max(MinSRSize, SR[0]);

    /* reset nmap,nmapK,bestLPA based on new fixY[] (and possibly changed DELTA_X,DELTA_Y,RANGE_Y) */
    score_init(N,fixY,MD,MX,DX);
    qLP = qprobeval(n,Hcuts,N,fixY,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    if(VERB){
      printf("switched RANGE=%d to %d, RANGE_Y=%d to %d, OutlierType=%d to %d,outlier=%0.2e->%0.2e,endoutlier=%0.2e->%0.2e,Lambda=%0.2e->%0.2e,LRbias=%0.2e->%0.2e,SF=%0.3f->%0.3f,SR=%0.4f->%0.4f: LP=%0.10f -> %0.10f: cum wall= %0.6f\n",
	     prevRANGE, RANGE, prevRANGE_Y, RANGE_Y, prevOutlierType, OUTLIER_TYPE, prevPoutlier, Poutlier, prevPoutlierEnd, PoutlierEnd, prevOutlierLambda, outlierLambda, 
	     prevLRbias, LRbias, prevSF,SF[0],prevSR,SR[0],qLPstart, qLP, wtime());
      fflush(stdout);
    }
    qLPstart = qLP;

    /* secondary save of nmap,nmapK,bestLPA corresponding to initial fixY[] (same as Y[] but with updated end intervals from newY[]) */
    int **orig2nmap = new int*[MD]; 
    int *orig2nmapMD = new int[N+2];
    int **orig2nmapK = new int*[MD];
    double *bestLPAorig2 = new double[MD];
    size_t orig2nmap_pool_size = 0;
    int *orig2nmap_pool;
    for(register int m = 0; m < MD; m++){
      orig2nmap_pool_size += MX[m]+2;
      orig2nmap_pool_size += MX[m]+2;
    }
    orig2nmap_pool = new int[orig2nmap_pool_size];
    size_t offset = 0;
    for(int m = 0; m < MD; m++){
      bestLPAorig2[m] = bestLPA[m];
      orig2nmap[m] = &orig2nmap_pool[offset]; offset += MX[m]+2;
      orig2nmapK[m] = &orig2nmap_pool[offset]; offset += MX[m]+2;
      for(register int j = 0; j <= MX[m]+1; j++){
	orig2nmap[m][j] = nmap[m][j];
	orig2nmapK[m][j] = nmapK[m][j];
      }
    }
    for(register int I=0; I <= N+1; I++)
      orig2nmapMD[I] = nmap[MD][I];

    double start = mtime(), wstart = wtime();
    if(nochange <= 0){

      if(DEBUG>=2){  /* make sure no real cuts are closer than minKB */
	for(register int I = 1; I < N; I++)
	  if(DEBUG && (!(newY[I+1]-newY[I] >= minKB - 2e-9) /* ||(360 <= I && I <= 380) */)){
	    printf("SizesEstimate Before mprobevalwinResize:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
		   I,newY[I],newY[I+1], newY[I+1]-newY[I], minKB);
	    fflush(stdout);
	    assert(newY[I+1]-newY[I] >= minKB - 2e-9);
	  }
	assert(newY[1] >= newY[0]);
	if(DEBUG && !(newY[N+1] >= newY[N])){
	  printf("SizesEstimate End:N=%d,newY[N]=%0.6f,newY[N+1]=%0.6f\n",
		 N,newY[N],newY[N+1]);
	  fflush(stdout);
	  assert(newY[N+1] >= newY[N]);
	}
      }

      //      tverb = 1 + stage;// NOTE : applies to first mprobeval() call only

      (void)mprobevalwinResize(n,Hcuts,qLPstart,bestLPA,newLPA,mapWT,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,Ycnt,Ydist,newY,Imin,Imax,MMforce,fixY,fixYdel,pcontig,nochange,LfrozenI,RfrozenI,trimfactor,Lfrozeni,Rfrozeni);
      if(VERB){
	double wt = wtime();
	printf("mprobevalwinResize:time=%0.6f,wall time=%0.6f (cum wall= %0.6f)\n",mtime()-start, wt-wstart,wt);
	fflush(stdout);
      }

      if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	(void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	for(int m = 0; m < MD; m++){
	  int M = MX[m];

	  int lastJ = -1, lasti = -1, lastk = -1;
	  for(int J = 1; J <= M; J++){
	    int i = map[m][J];
	    if(i < 0)
	      continue;
	    int k = mapK[m][J];
	    if(DEBUG &&  !(0 <= k && k < i)){
	      printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	      fflush(stdout);
	      assert(0 <= k && k < i);
	    }
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	      if(VERB){
		for(int j = 1; j <= M; j++){
		  int i = map[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK[m][j];
		  printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }

      register double cum = fixYdel[0];
      if(DEBUG) assert(fabs(fixY[0] - cum) <= 2e-9);
      for(register int I = 1; I <= N+1; I++){
	cum += fixYdel[I];
	if(DEBUG) assert(fabs(fixY[I]-cum) <= 2e-9);

	if(VERB>=3 && I >= N-600){/* display last 600 labels */
	  printf("\tfixY[%d]= %0.6f\n", I, fixY[I]);
	  fflush(stdout);
	}
      }

      /* verify improvment to qLP due to changes made in fixY */
      score_init(N,fixY,MD,MX,DX);
      double nLP = qprobeval(n,Hcuts,N,fixY,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
      if(DEBUG) assert(isfinite(nLP));

      if(nLP > qLP){ /* update qLP and 2nd save of nmap,nmapK, bestLPA */
	if(VERB){
	  printf("  After Multimodal optimization of Y[] : Overall change in LP from %0.8f to %0.8f (delta= %0.8f): cum wall time= %0.6f\n",qLP,nLP,nLP-qLP,wtime());
	  //	  printf("\t Y[1]=%0.3f,Y[2]=%0.3f,Y[N+1=%d]=%0.3f\n",fixY[1],fixY[2],N+1,fixY[N+1]);
	  fflush(stdout);
	}
	qLP = nLP;
	for(register int m = 0; m < MD; m++){
	  bestLPAorig2[m] = bestLPA[m];
	  for(register int j = 0; j <= MX[m]+1; j++){
	    orig2nmap[m][j] = nmap[m][j];
	    orig2nmapK[m][j] = nmapK[m][j];
	  }
	}
	for(register int I=0; I <= N+1; I++)
	  orig2nmapMD[I] = nmap[MD][I];

	if(DEBUG>=2){  /* make sure no real cuts are closer than minKB */
	  for(register int I = 1; I < N; I++)
	    if(DEBUG && (!(fixY[I+1]-fixY[I] >= minKB - 2e-9) /* || (360 <= I && I <= 380)*/)){
	      printf("After mprobevalwinResize:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
		     I,fixY[I],fixY[I+1], fixY[I+1]-fixY[I], minKB);
	      fflush(stdout);
	      assert(fixY[I+1]-fixY[I] >= minKB - 2e-9);
	    }
	  assert(fixY[1] >= fixY[0]);
	  if(DEBUG && !(fixY[N+1] >= fixY[N])){
	    printf("N=%d,fixY[N]=%0.6f,fixY[N+1]=%0.6f\n",
		   N,fixY[N],fixY[N+1]);
	    fflush(stdout);
	    assert(fixY[N+1] >= fixY[N]);
	  }
	}

      } else {  /* restore nmap,nmapK, bestLPA from 2nd save*/
	if(VERB && nLP < qLP - 1e-8){
	  printf("WARNING:Overall change in LP from %0.8f to %0.8f (undoing Multimodal optimization of Y[]): cum wall time= %0.6f\n",qLP,nLP, wtime());
	  fflush(stdout);
	}
	fixY[0] = fixYdel[0] = 0.0;
	for(register int I=1; I <= N+1; I++)
	  fixYdel[I] = Y[I]-Y[I-1];
	fixYdel[1] = newY[1];/* since newY[1] may be different from Y[1] */
	fixYdel[N+1] = newY[N+1]-newY[N];/* since newY[N+1]-newY[N] may be different from Y[N+1]-Y[N] */
	register double cum = fixYdel[0];
	for(register int I = 1; I <= N+1; I++){
	  cum += fixYdel[I];
	  fixY[I] = cum;
	}

	for(register int m = 0; m < MD; m++){
	  bestLPA[m] = bestLPAorig2[m];
	  for(register int j = 0; j <= MX[m]+1; j++){
	    nmap[m][j] = orig2nmap[m][j];
	    nmapK[m][j] = orig2nmapK[m][j];
	  }
	}
	for(register int I=0; I <= N+1; I++)
	  assert(orig2nmapMD[I] == nmap[MD][I]);
	if(DEBUG){/* verify reversal of LP */
	  score_init(N,fixY,MD,MX,DX);
	  double fixLP = qprobeval(n,Hcuts,N,fixY,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  if(!(fabs(fixLP - qLP) < 1e-8)){
	    printf("WARNING: could not restore qLP=%0.6f (changed to %0.6f)\n",qLP, fixLP);
	    fflush(stdout);
	    assert(fabs(fixLP-qLP) < 1e-6);
	  }
	  qLP = fixLP;
	}
      }
    }

    if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
      (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
      for(int m = 0; m < MD; m++){
	int M = MX[m];

	int lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  int i = map[m][J];
	  if(i < 0)
	    continue;
	  int k = mapK[m][J];
	  if(DEBUG &&  !(0 <= k && k < i)){
	    printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
	  }
	  if(lasti >= 0 && !(i-k > lasti)){
	    printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[m][j];
		if(i < 0)
		  continue;
		int k = mapK[m][j];
		printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	      }
	    }
	    fflush(stdout);
	    assert(i-k > lasti);
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
	}
      }
    }

    if(DELTA_X != prevDELTA_X || DELTA_Y != prevDELTA_Y || RANGE_Y != prevRANGE_Y || RANGE != prevRANGE || OutlierType != prevOutlierType || outlierLambda != prevOutlierLambda
       || Poutlier != prevPoutlier || PoutlierEnd != prevPoutlierEnd || LRbias != prevLRbias || SF[0] != prevSF || SR[0] != prevSR){
      DELTA_X = prevDELTA_X;
      DELTA_Y = prevDELTA_Y;
      RANGE = prevRANGE;
      RANGE_Y = prevRANGE_Y;
      OutlierType = prevOutlierType;
      outlierLambda = prevOutlierLambda;
      Poutlier = prevPoutlier;
      PoutlierEnd = prevPoutlierEnd;
      LRbias = prevLRbias;
      SF[0] = prevSF;
      SR[0] = prevSR;

      score_init(N,fixY,MD,MX,DX);/* precompute likelihood scoring constants/terms */  
      double testLP = qprobeval(n,Hcuts,N,fixY,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
      if(VERB){
	printf("After Multimodal optimization & restoring DELTA=%d,%d,RANGE=%d,RANGE_Y=%d,OutlierType=%d,Lambda=%0.2e,outlier=%0.2e,endoutlier=%0.2e,LRbias=%0.2e,SF=%0.3f,SR=%0.4f: qLP=%0.10f (delta = %0.10f): cum wall time= %0.6f\n",
	       DELTA_X,DELTA_Y,RANGE,RANGE_Y,OUTLIER_TYPE,outlierLambda, Poutlier,PoutlierEnd,LRbias,SF[0],SR[0],testLP, testLP - LP, wtime());
	if(testLP < LP - 1e-8)
	  printf("WARNING: could not confirm Multimodal LP=%0.8f after restoring DELTA,RANGE_Y (dropped to %0.8f, original LP=%0.8f)\n", 
		 LP, testLP, newLP);
	fflush(stdout);
      }
      newLP = testLP;
    } else {
      if(VERB){
	printf("After Multimodal optimization of Y[]: LP=%0.10f (delta = %0.10f) : cum wall time= %0.6f\n",qLP, qLP - LP, wtime());

	if(DEBUG>=2){
	  score_init(N,fixY,MD,MX,DX);
	  double nLP = qprobeval(n,Hcuts,N,fixY,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  if(VERB){
	    printf(" verifying nLP=%0.10f (was qLP=%0.10f)\n",nLP,qLP);
	    fflush(stdout);
	  }
	  assert(fabs(nLP-qLP) < 1e-8);
	  for(register int m = 0; m < MD; m++)
	    assert(fabs(bestLPA[m] - newLPA[m]) < 1e-8);
	}
	fflush(stdout);
      }
      newLP = qLP;
    }

    if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
      (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
      for(int m = 0; m < MD; m++){
	int M = MX[m];

	int lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  int i = map[m][J];
	  if(i < 0)
	    continue;
	  int k = mapK[m][J];
	  if(DEBUG &&  !(0 <= k && k < i)){
	    printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
	  }
	  if(lasti >= 0 && !(i-k > lasti)){
	    printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[m][j];
		if(i < 0)
		  continue;
		int k = mapK[m][j];
		printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	      }
	    }
	    fflush(stdout);
	    assert(i-k > lasti);
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
	}
      }
    }

    /* Update newY[] based on fixYdel[] */
    // HERE HERE : this should be redudant : just swap fixY and newY
    register double cum = fixYdel[0];
    newY[0] = cum;
    if(DEBUG) assert(fabs(newY[0] - fixY[0]) <= 2e-9);
    for(register int I = 1; I <= N+1; I++){
      cum += fixYdel[I];
      newY[I] = cum;
      if(DEBUG && !(fabs(newY[I] - fixY[I]) <= 2e-9)){
	printf("I=%d:fixY[I]=%0.10f,newY[I]=%0.10f,fixYdel[I]=%0.10f\n",I,fixY[I],newY[I],fixYdel[I]);
	fflush(stdout);
	assert(fabs(newY[I] - fixY[I]) <= 2e-9);
      }
    }

    if(DEBUG>=2){
      score_init(N,newY,MD,MX,DX);
      double nLP = qprobeval(n,Hcuts,N,newY,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig);
      if(VERB){
	printf("After updating newY[] based on fixY[]:LP=%0.10f (newLP=%0.10f,delta=%0.10f)\n",nLP,newLP,nLP-newLP);
	//	printf("\t Y[1]=%0.3f,Y[2]=%0.3f,Y[N+1=%d]=%0.3f\n",newY[1],newY[2],N+1,newY[N+1]);
	fflush(stdout);
      }
      assert(fabs(nLP-newLP) < 1e-8);
      for(register int m = 0; m < MD; m++)
	assert(fabs(bestLPA[m] - newLPA[m]) < 1e-8);
    }

    if(MMforce)
      delete [] MMforce;
    delete [] orig2nmap_pool;
//     for(register int m = 0; m < MD; m++){
//       delete [] orig2nmapK[m];
//       delete [] orig2nmap[m];
//     }
    delete [] orig2nmap;
    delete [] orig2nmapK;
    delete [] orig2nmapMD;
    delete [] bestLPAorig2;
    delete [] fixY;
    delete [] fixYdel;
  }/* MultiMode */

  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
    (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      int lastJ = -1, lasti = -1, lastk = -1, cnt = 0;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	cnt++;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
	  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	  fflush(stdout);
	  assert(0 <= k && k < i);
	}
	if(lasti >= 0 && !(i-k > lasti)){
	  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	  if(VERB){
	    for(int j = 1; j <= M; j++){
	      int i = map[m][j];
	      if(i < 0)
		continue;
	      int k = mapK[m][j];
	      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	    }
	  }
	  fflush(stdout);
	  assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
      if(DEBUG/* HERE >=2 */ && !(cnt > 0)){
	printf("WARNING in SizesEstimate: No aligned sites in initial map[m][] for m=%d(id=%lld)\n",m, gmap[pcontig->contig[m].mapid]->id);
	fflush(stdout);
	assert(cnt > 0);
      }
    }
  }

  /* validate changes newY[] & newLP (generated either by KDmeans or MultiMode) */
  if(nochange >= 0 && (newLP < LP + LP_MINDELTA || nochange > 0)){
    if(VERB){
      if(newLP < LP + LP_MINDELTA){
	if(origrverb || fabs(extendL) > 0.0005 || fabs(extendR) > 0.0005 )
	  printf("  SizeUpdate failed:LP=%0.10f->%0.10f,MD=%d,Y[N+1]=%0.3f,trimfactor=%0.2f,extendL=%0.3f(mL=%d),extendR=%0.3f(mR=%d)\n", 
		 LP,newLP,MD,Y[N+1],trimfactor,extendL,mL,extendR,mR);
	else
	  printf("  SizeUpdate failed:LP=%0.10f->%0.10f,MD=%d,Y[N+1]=%0.3f,trimfactor=%0.2f\n",LP,newLP,MD,Y[N+1],trimfactor);
      } else if(origrverb || fabs(extendL) > 0.0005 || fabs(extendR) > 0.0005 )
	printf("  After resizing Y:LP=%0.10f->%0.10f,MD=%d,Y[N+1]=%0.3f->%0.3f,trimfactor=%0.2f,extendL=%0.3f(mL=%d),extendR=%0.3f(mR=%d)(Y,Hcuts not changed)\n",
	       LP,newLP,MD,Y[N+1],newY[N+1],trimfactor,extendL,mL,extendR,mR);
      else
	printf("  After resizing Y:LP=%0.10f->%0.10f,MD=%d,Y[N+1]=%0.3f->%0.3f,trimfactor=%0.2f(Y,Hcuts not changed)\n",LP,newLP,MD,Y[N+1],newY[N+1],trimfactor);
      fflush(stdout);
    }
    /* keep Y[] unchanged AND restore bestLPA,nmap,nmapK */
    failed = 1;
    if(DEBUG){  /* make sure no real cuts are closer than minKB */
      for(register int I = 1; I < N; I++)
	if(DEBUG && (!(Y[I+1]-Y[I] >= minKB - 2e-9) /* ||(360<=I && I <= 380)*/) ){
	  printf("SizesEstimate Restore:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
		 I,Y[I],Y[I+1], Y[I+1]-Y[I], minKB);
	  fflush(stdout);
	  assert(Y[I+1]-Y[I] >= minKB - 2e-9);
	}
      assert(Y[1] >= Y[0]);
      assert(Y[N+1] >= Y[N]);
    }

    score_init(N,Y,MD,MX,DX);/* precompute likelihood scoring constants/terms */  
    double newLP2 = LP;
    if(NEW){
      /* restore bestLPA[],nmap[],nmapK[] from saved copy */
      for(register int m = 0; m < MD; m++){
	bestLPA[m] = bestLPAorig[m];
	for(register int j = 0; j <= MX[m]+1; j++){
	  nmap[m][j] = orignmap[m][j];
	  nmapK[m][j] = orignmapK[m][j];
	}
      }
      for(register int I=0; I <= N+1; I++)
	assert(orignmapMD[I] == nmap[MD][I]);
      if(DEBUG>=2){
	register double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	if(fabs(nLP - newLP2) >= 1e-8){
	  printf(" WARNING: failed to revert to original state after failed SizesEstimate:original LP=%0.10f, new LP=%0.10f\n",LP,nLP);
	  fflush(stdout);
	  assert(fabs(nLP - newLP2) < 1e-6);
	  newLP2 = nLP;
	}
      }
    } else
      newLP2 = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);

    if(DEBUG && fabs(newLP2-LP) >= 1e-8){/* this is most likely caused by UpdateMap() (see below) during the previous call to SizesEstimate() */
      if(newLP2 < LP){
	printf("  WARNING: failed to revert to original state in SizesEstimate: LP=%0.10f,newLP=%0.10f,newLP2=%0.10f (worse) ??\n",LP,newLP,newLP2);
      } else
	printf("  WARNING: failed to revert to original state in SizesEstimate: LP=%0.10f,newLP=%0.10f,newLP2=%0.10f\n",LP,newLP,newLP2);
    } else if(VERB>=2)
      printf("reverted to original state in SizesEstimate: LP=%0.10f,newLP=%0.10f,newLP2=%0.10f,N=%d,Y[N+1]=%0.3f,lc=%d,rc=%d\n",LP,newLP,newLP2,N,Y[N+1],lc,rc);
    fflush(stdout);

    if(!nochange)// If nochange, return the new score
      newLP = newLP2;// return the restored score

  } else {/* perform update of Y, Hcuts and pcontig->fragcnt[] */
    failed = 0;
    if(VERB){
      if(nochange < 0 && newLP < LP)
	printf("  After resizing Y,Hcuts:LP=%0.10f->%0.10f,MD=%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f->%0.3f,trimfactor=%0.2f,extendL=%0.3f(mL=%d),extendR=%0.3f(mR=%d)(forced even though LP got worse!)\n",
	       LP,newLP,MD,newY[1],newY[N],Y[N+1],newY[N+1],trimfactor,extendL,mL,extendR,mR);
      else
	printf("  After resizing Y,Hcuts:LP=%0.10f->%0.10f,MD=%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f->%0.3f,trimfactor=%0.2f,extendL=%0.3f(mL=%d),extendR=%0.3f(mR=%d):cum wall time= %0.6f\n",
	       LP,newLP,MD,newY[1],newY[N],Y[N+1],newY[N+1],trimfactor,extendL,mL,extendR,mR,wtime());
      //printf("After resizing Y,Hcuts:LP=%0.6f->%0.6f,MD=%d,Y[N+1]=%0.3f->%0.3f,trimfactor=%0.2f\n",LP,newLP,MD,Y[N+1],newY[N+1],trimfactor);
      fflush(stdout);
    }
    for(register int I=0;I<=N+1;I++)
      Y[I] = newY[I];

    if(DEBUG>=2){
      /* verify newLP, bestLPA with newY[] */
      score_init(N,newY,MD,MX,DX);
      double nLP = qprobeval(n,Hcuts,N,newY,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig);
      if(VERB){
	printf("SizesEstimate:With newY[] nLP=%0.10f (newLP=%0.10f),N=%d\n",nLP,newLP,N);
	//	printf("\t Y[1]=%0.3f,Y[2]=%0.3f,Y[N+1=%d]=%0.3f\n",newY[1],newY[2],N+1,newY[N+1]);
	fflush(stdout);
      }
      if(DEBUG){
	assert(fabs(newLP-nLP) < 1e-8);
	for(register int m = 0; m < MD; m++)
	  assert(fabs(bestLPA[m] - newLPA[m]) < 1e-8);
      }

      if(DEBUG>=2){
	/* verify newLP, bestLPA with Y[] */
	score_init(N,Y,MD,MX,DX);
	double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	if(VERB){
	  printf("SizesEstimate:With Y[] updated from newY[] qLP=%0.10f (newLP=%0.10f),N=%d\n",qLP,newLP,N);
	  //	  printf("\t Y[1]=%0.3f,Y[2]=%0.3f,Y[N+1=%d]=%0.3f\n",Y[1],Y[2],N+1,Y[N+1]);
	  fflush(stdout);
	}
	if(DEBUG){
	  assert(fabs(newLP-qLP) < 1e-8);
	  for(register int m = 0; m < MD; m++)
	    assert(fabs(bestLPA[m] - newLPA[m]) < 1e-8);
	}
      }
    }

    /* NOTE: updating Hcuts[] (without changing Y[] or map[],mapK[]) has a weak effect on LP (due to setlimit handling of unaligned sites) */
    register double *Hdelta = new double[n+1];
    for(register int k=0; k <= n; k++){
      Hdelta[k] = 0.0;
      if(DEBUG && !(Hcuts[k+1]>=Hcuts[k])){
	printf("\nSizesEstimate before updating Hcuts:k=%d,Hcuts[k]=%0.6f,Hcuts[k+1]=%0.6f\n",k,Hcuts[k],Hcuts[k+1]);
	fflush(stdout);
	assert(Hcuts[k+1]>=Hcuts[k]);
      }
    }
    for(register int I=0; I <= N; I++){
      register double y = Y[I+1]-Y[I];
      register int i = nmap[MD][I];
      if(DEBUG) assert(i>=0 && i < n+1);
      register int t = nmap[MD][I+1];
      if(DEBUG) assert(t > i && t <= n+1);
      register double h = Hcuts[t] - Hcuts[i];
      if(y >= 0.0 /* WAS y > 0.0 */){
	if(h > 0.0){
	  register double scale = y/h;
	  if(DEBUG && !(scale >= 0.0)){
	    printf("I=%d:Y[I]=%0.3f,Y[I+1]=%0.3f,y=%0.3f,t=%d,i=%d,Hcuts[t]=%0.3f,Hcuts[i]=%0.3f,h=%0.3f,scale=%0.3f\n",
		   I,Y[I],Y[I+1],y,t,i,Hcuts[t],Hcuts[i],h,scale);
	    fflush(stdout);
	    assert(scale >= 0.0);
	  }
	  for(register int k = i; k < t; k++){
	    Hdelta[k] = scale*(Hcuts[k+1]-Hcuts[k]);
	    if(I>0 && I < N)
	      pcontig->fragcnt[0][k] = Ycnt[I];
	    else
	      pcontig->fragcnt[0][k] = 1.0;
	  }
	} else {/* just divide up the difference equally across all intervals Hcuts[i .. t] */
	  if(DEBUG) assert(t>i);
	  register double delta = (y-h)/(t-i);
	  for(register int k = i; k < t; k++){
	    Hdelta[k] = delta;
	    if(I>0 && I < N)
	      pcontig->fragcnt[0][k] = Ycnt[I];
	    else
	      pcontig->fragcnt[0][k] = 1.0;
	  }
	}
      } else if(DEBUG){
	if(!(y==0.0)){
	  printf("\nSizesEstimate while updating Hcuts:I=%d,Y[I]=%0.8f,Y[I+1]=%0.8f,y=%0.8e\n",
		 I,Y[I],Y[I+1],y);
	  for(register int k=0;k<=N+1;k++)
	    printf("Y[%d]=%0.8f\n",k,Y[k]);
	  fflush(stdout);
	  assert(y==0.0);
	}
	if(!(h <= 1e-10)){
	  printf("\nSizesEstimate while updating Hcuts:I=%d,Y[I]=%0.11f,Y[I+1]=%0.11f,y=%0.6e, i=%d,t=%d,Hcuts[i]=%0.11f,Hcuts[t]=%0.11f,h=%0.11e\n",
		 I,Y[I],Y[I+1],y,i,t,Hcuts[i],Hcuts[t],h);
	  for(register int k = i; k <= t; k++)
	    printf("Hcuts[%d]= %0.11f\n",k,Hcuts[k]);
	  fflush(stdout);

	  assert(h <= 1e-10);
	}
      }
    }
    if(DEBUG>=2){
      for(int k=0; k <= n; k++)
	if(!(Hdelta[k] >= 0.0)){
	  printf("Hdelta[%d]=%0.3f:n=%d\n",k,Hdelta[k],n);
	  fflush(stdout);
	  assert(Hdelta[k] >= 0.0);
	}
    }

    for(register int k=0; k <= n; k++)
      Hcuts[k+1] = Hcuts[k] + Hdelta[k];

    int newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
    if(DEBUG) assert(newN == N);
    if(DEBUG>=2){
      for(register int I=0; I <= N+1; I++){
	if(!(fabs(Y[I]-newY[I]) < 1e-8)){
	  printf("WARNING:Failed to update Hcuts[] consistently with newY[]\n");
	  printf("I=%d,N=%d:newY[I-1,I,I+1]= %0.10f,%0.10f,%0.10f,Y[I-1,I,I+1]=%0.10f,%0.10f,%0.10f\n",
		 I,N,newY[I-1],newY[I],(I <= N) ? newY[I+1] : 0.0, Y[I-1],Y[I], (I <= N) ? Y[I+1] : 0.0);
	  fflush(stdout);
	  assert(fabs(Y[I]-newY[I]) < 1e-7);
	}
      }
      for(register int I=0; I <= N+1; I++)
	assert(orignmapMD[I] == nmap[MD][I]);
    }

    delete [] Hdelta;

    if(1){/* Updating Hcuts[] causes a slight change in LP due to changes in setlimit(), but usually the difference is under 1e-8 */
      /* update newLP, nmap,nmapK,bestLPA */
      score_init(N,Y,MD,MX,DX);
      double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig);
      if(VERB && (VERB>=2 || TIME_VERBOSE || fabs(qLP - newLP) > 1e-6)){
	if(qLP < newLP)
	  printf("  WARNING:SizesEstimate:after updating Hcuts[] newLP=%0.8f -> %0.8f(err=%0.8f, N=%d,original LP=%0.8f): cum wall time= %0.6f\n",newLP,qLP, qLP-newLP, N,LP,wtime());
	else
	  printf("  SizesEstimate:after updating Hcuts[] newLP=%0.8f -> %0.8f (err=%0.8f, N=%d,original LP=%0.8f): cum wall time= %0.6f\n",newLP,qLP,qLP-newLP, N,LP, wtime());
	//	printf("\t Hcuts[4]=%0.3f,Hcuts[5]=%0.3f,Hcuts[n+1=%d]=%0.3f\n",Hcuts[4],Hcuts[5],n+1,Hcuts[n+1]);
	fflush(stdout);
      }
      if(VERB>=2 && qLP < newLP - 1e-8){/* NOTE : see process2/dros_bbvci/trunk : Extension 3 of contig40 */
	for(register int m = 0; m < MD; m++){
	  if(fabs(newLPA[m]-bestLPA[m]) > 1e-8){
	    printf("  m=%d:bestLPA[m]=%0.10f -> %0.10f (err=%0.10f)\n",
		   m,bestLPA[m],newLPA[m],newLPA[m]-bestLPA[m]);
	    fflush(stdout);
	  }
	  bestLPA[m] = newLPA[m];
	}
      }

      memcpy(bestLPA,newLPA,MD*sizeof(double));// NEW4
      newLP = qLP;
    }

    if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
      (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
      for(int m = 0; m < MD; m++){
	int M = MX[m];

	int lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  int i = map[m][J];
	  if(i < 0)
	    continue;
	  int k = mapK[m][J];
	  if(DEBUG &&  !(0 <= k && k < i)){
	    printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
	  }
	  if(lasti >= 0 && !(i-k > lasti)){
	    printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[m][j];
		if(i < 0)
		  continue;
		int k = mapK[m][j];
		printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	      }
	    }
	    fflush(stdout);
	    assert(i-k > lasti);
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
	}
      }
    }

    if(DEBUG) assert(nochange <= 0);
    int cnt = 0;
    double newLPorig;

    /* backup nmap,nmapK,bestLPA */
    for(register int m = 0; m < MD; m++){
      bestLPAorig[m] = bestLPA[m];
      for(register int j = 0; j <= MX[m]+1; j++){
	orignmap[m][j] = nmap[m][j];
	orignmapK[m][j] = nmapK[m][j];
      }
    }

    /* NOTE : avoid updating map[],mapK[] while Oldmap is in use until first MultiMode optimization has completed */

    if(UPDATEMAP && (!OldMap || (MultiMode && nochange <= 0 /* && newLP < LP + 100.0 */)) /* && OldMap */){
      if(VERB>=2 && stage <= 1){
	stage = 2;
        tverb = 2;
	printf("stage = %d\n",stage);
	fflush(stdout);
      }

      /* save map,mapK */
      int **origmap = new int*[MD];
      int **origmapK = new int*[MD];
      size_t origmap_pool_size = 0;
      int *origmap_pool;
      for(register int m = 0; m < MD; m++){
	origmap_pool_size += MX[m]+2;
	origmap_pool_size += MX[m]+2;
      }
      origmap_pool = new int[origmap_pool_size];
      size_t offset = 0;
      for(int m = 0; m < MD; m++){
	origmap[m] = &origmap_pool[offset]; offset += MX[m]+2;
	origmapK[m] = &origmap_pool[offset]; offset += MX[m]+2;
	for(register int j = 0; j <= MX[m]+1; j++){
	  origmap[m][j] = map[m][j];
	  origmapK[m][j] = mapK[m][j];
	}
      }

      // restore original RANGE,RANGE_Y,DELTA_X,DELTA_Y, OutlierType, outlierLambda, Poutlier, PoutlierEnd and call qprobeval() before calling UpdateMap()
      if(DELTA_X != origDELTA_X || DELTA_Y != origDELTA_Y || RANGE != (RANGE_UPDATE ? RANGE_UPDATE : origRANGE) || RANGE_Y != origRANGE_Y || OutlierType != origOutlierType || 
	 outlierLambda != origOutlierLambda || Poutlier != gorigPoutlier || PoutlierEnd != gorigPoutlierEnd || LRbias != origLRbias || SF[0] != origSF || SR[0] != origSR /* || stage>=2 */) {
	DELTA_X = origDELTA_X;
	DELTA_Y = origDELTA_Y;

	RANGE = origRANGE;
	if(RANGE_UPDATE)
	  RANGE = RANGE_UPDATE;
	RANGE_Y = RANGE_Y1;
	OutlierType = origOutlierType;
	outlierLambda = origOutlierLambda;
	Poutlier = gorigPoutlier;
	PoutlierEnd = gorigPoutlierEnd;
	LRbias = origLRbias;
	SF[0] = origSF;
	SR[0] = origSR;

	score_init(N,Y,MD,MX,DX);/* precompute likelihood scoring constants/terms */  
	newLPorig = newLP;
	newLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	if(VERB){
	  printf("Changed to deltaX=%d,deltaY=%d,RANGE=%d,RANGE_Y=%d,OutlierType=%d,Lambda=%0.2e,outlier=%0.2e,endoutlier=%0.2e,LRbias=%0.2e,SF=%0.3f,SR=%0.5f before UpdateMap:LP=%0.8f -> %0.8f: cum wall time= %0.6f\n",
		 DELTA_X,DELTA_Y,RANGE, RANGE_Y, OutlierType, outlierLambda, Poutlier, PoutlierEnd, LRbias,SF[0],SR[0],newLPorig,newLP,wtime());
	  fflush(stdout);
	}
      }

      do { /* Update map,mapK using nmap,nmapK */
	newLPorig = newLP;

	UpdateMap(n, N, Y, MD,MX,DX,Hcuts,Hdel,map,mapK,limit,nmap,nmapK, mapWT, 0, FILL_MAP);
	newLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);

	// HERE HERE : check for partial updates : see HaploType

	if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	  (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	  for(int m = 0; m < MD; m++){
	    int M = MX[m];

	    int lastJ = -1, lasti = -1, lastk = -1;
	    for(int J = 1; J <= M; J++){
	      int i = map[m][J];
	      if(i < 0)
		continue;
	      int k = mapK[m][J];
	      if(DEBUG &&  !(0 <= k && k < i)){
		printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
		fflush(stdout);
		assert(0 <= k && k < i);
	      }
	      if(lasti >= 0 && !(i-k > lasti)){
		printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
		if(VERB){
		  for(int j = 1; j <= M; j++){
		    int i = map[m][j];
		    if(i < 0)
		      continue;
		    int k = mapK[m][j];
		    printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		  }
		}
		fflush(stdout);
		assert(i-k > lasti);
	      }
	      lasti = i;
	      lastk = k;
	      lastJ = J;
	    }
	  }
	}

	if(!SPEEDFIX ? (newLP <= newLPorig + LP_MINDELTA) : (newLP < newLPorig - LP_MINDELTA && newLP <= LP + LP_MINDELTA)){/* revert and terminate */
	  if(VERB){
	    printf("  Updated mapping: LP=%0.10f->%0.10f,N=%d,trimfactor=%0.2f (reverting to previous mapping) : cum wall time= %0.6f\n",newLPorig,newLP,N,trimfactor,wtime());
	    fflush(stdout);
	  }
	  /* restore map[],mapK[],nmap[],nmapK[],bestLPA[] from saved copy */
	  for(register int m = 0; m < MD; m++){
	    bestLPA[m] = bestLPAorig[m];
	    for(register int j = 0; j <= MX[m]+1; j++){
	      map[m][j] = origmap[m][j];
	      mapK[m][j] = origmapK[m][j];
	      nmap[m][j] = orignmap[m][j];
	      nmapK[m][j] = orignmapK[m][j];
	    }
	  }
	  if(DEBUG>=2){
	    newLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	    if(fabs(newLP - newLPorig) > 1e-8){
	      printf("  WARNING:Unable to restore state : LP=%0.10f (was %0.10f, delta=%0.10f)\n",newLP,newLPorig,newLP-newLPorig);
	      fflush(stdout);
	    }
	    for(register int m = 0; m < MD; m++)
	      bestLPA[m] = newLPA[m];
	  } else
	    newLP = newLPorig;
	  break;
	}

	mapupdated = 1;
	if(VERB){
	  if(OldMap)
	    printf("  Updated mapping: LP=%0.6f->%0.6f,N=%d,trimfactor=%0.2f:OldMap=%d->0: cum wall time= %0.6f\n",newLPorig,newLP,N,trimfactor,OldMap, wtime());
	  else
	    printf("  Updated mapping: LP=%0.6f->%0.6f,N=%d,trimfactor=%0.2f:OldMap=%d: cum wall time= %0.6f\n",newLPorig,newLP,N,trimfactor,OldMap, wtime());
	  fflush(stdout);
	}
	OldMap = 0;/* subsequent calls to SizesEstimate() will not use old map */

	/* backup map,mapK,nmap,nmapK,bestLPA for new best result */
	for(register int m = 0; m < MD; m++){
	  bestLPAorig[m] = bestLPA[m];
	  for(register int j = 0; j <= MX[m]+1; j++){
	    orignmap[m][j] = nmap[m][j];
	    orignmapK[m][j] = nmapK[m][j];
	    origmap[m][j] = map[m][j];
	    origmapK[m][j] = mapK[m][j];
	  }
	}
      } while (newLP > newLPorig + 0.001 && ++cnt < 50);

      if(DEBUG>=2){
	N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	if(DEBUG)
	  for(register int I=0; I <= N+1; I++)
	    assert(fabs(Y[I]-newY[I]) <= 1e-8);

	double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	if(fabs(nLP - newLP) > 1e-8){
	  printf("WARNING: After UpdateMap:LP=%0.10f (newLP=%0.10f)\n",nLP, newLP);
	  printf(" LP changed after setmap() after UpdateMap!!\n");
	  fflush(stdout);
	  assert(fabs(nLP-newLP) <= 1e-6);
	  newLP = nLP;
	}
      }
      
      if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	(void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	for(int m = 0; m < MD; m++){
	  int M = MX[m];

	  int lastJ = -1, lasti = -1, lastk = -1;
	  for(int J = 1; J <= M; J++){
	    int i = map[m][J];
	    if(i < 0)
	      continue;
	    int k = mapK[m][J];
	    if(DEBUG &&  !(0 <= k && k < i)){
	      printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	      fflush(stdout);
	      assert(0 <= k && k < i);
	    }
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	      if(VERB){
		for(int j = 1; j <= M; j++){
		  int i = map[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK[m][j];
		  printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }

      if(DELTA_X != prevDELTA_X || DELTA_Y != prevDELTA_Y || RANGE_Y != prevRANGE_Y || RANGE != prevRANGE || OutlierType != prevOutlierType || outlierLambda != prevOutlierLambda 
	 || Poutlier != prevPoutlier || PoutlierEnd != prevPoutlierEnd || LRbias != prevLRbias || SF[0] != prevSF || SR[0] != prevSR){
	DELTA_X = prevDELTA_X;
	DELTA_Y = prevDELTA_Y;
	RANGE = prevRANGE;
	RANGE_Y = prevRANGE_Y;
	OutlierType = prevOutlierType;
	outlierLambda = prevOutlierLambda;
	Poutlier = prevPoutlier;
	PoutlierEnd = prevPoutlierEnd;
	LRbias = prevLRbias;
	SF[0] = prevSF;
	SR[0] = prevSR;

	score_init(N,Y,MD,MX,DX);/* precompute likelihood scoring constants/terms */  
	int newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	double testLP = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	if(VERB){
	  printf("After UpdateMap restored DELTA=%d,%d,RANGE=%d,RANGE_Y=%d,OutlierType=%d,Lambda=%0.2e,outlier=%0.2e,outlierEnd=%0.2e,LRbias=%0.2e,SF=%0.3f,SR=%0.5f: qLP= %0.10f -> %0.10f, N=%d->%d: cum wall time= %0.6f\n",
		 DELTA_X,DELTA_Y,RANGE,RANGE_Y,OUTLIER_TYPE,outlierLambda, Poutlier,PoutlierEnd,LRbias,SF[0],SR[0],newLP, testLP, N, newN, wtime());
	  fflush(stdout);
	}
	newLP = testLP;
      }

      if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	(void ) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	for(int m = 0; m < MD; m++){
	  int M = MX[m];

	  int lastJ = -1, lasti = -1, lastk = -1;
	  for(int J = 1; J <= M; J++){
	    int i = map[m][J];
	    if(i < 0)
	      continue;
	    int k = mapK[m][J];
	    if(DEBUG &&  !(0 <= k && k < i)){
	      printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	      fflush(stdout);
	      assert(0 <= k && k < i);
	    }
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	      if(VERB){
		for(int j = 1; j <= M; j++){
		  int i = map[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK[m][j];
		  printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }

      if(VERB>=3){/* check effect of increasing RANGE on LP */
	int pRANGE = RANGE;
	int poutlierLambda = outlierLambda;
	int pOutlierType = OutlierType;
	int pRANGE_Y = RANGE_Y;

	RANGE = 1;

	printf("Checking effect of RANGE = %d to %d with RANGE_Y=RANGE, OutlierType=%d,outlierLambda=%0.3e: wall time=%0.6f\n",RANGE,30,OutlierType,outlierLambda,wtime());
	fflush(stdout);

	double pLP = newLP;

	for(; RANGE <= 30; RANGE++){
	  RANGE_Y = RANGE;

	  score_init(N,Y,MD,MX,DX);/* precompute likelihood scoring constants/terms */  
	  (void)setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	  rverb = (RANGE==4 || RANGE==30) ? 1 : 0;
	  double qLP2 = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  rverb = 0;

	  if(RANGE==1)
	    pLP = qLP2;

	  printf("RANGE=%d: LP=%0.10f (delta=%0.10f): wall time=%0.6f\n",RANGE,qLP2,qLP2-pLP,wtime());
	  fflush(stdout);

	  pLP = qLP2;
	}

	outlierLambda = 1e+30;
	OutlierType = 1;
	RANGE = 1;

	printf("Checking effect of RANGE = %d to %d with RANGE_Y=0,OutlierType=%d,outlierLambda=%0.3e: wall time=%0.6f\n",RANGE,30,OutlierType,outlierLambda,wtime());
	fflush(stdout);

	for(; RANGE <= 30; RANGE++){
	  RANGE_Y = 0;

	  score_init(N,Y,MD,MX,DX);/* precompute likelihood scoring constants/terms */  
	  (void)setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	  rverb = (RANGE==4 || RANGE==30) ? 1 : 0;
	  double qLP2 = qprobeval(n,Hcuts,N,Y,MD,MX,DX,lc,rc,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  rverb = 0;

	  if(RANGE==1)
	    pLP = qLP2;
	  printf("RANGE=%d: LP=%0.10f (delta=%0.10f): wall time=%0.6f\n",RANGE,qLP2,qLP2-pLP,wtime());
	  fflush(stdout);
	  pLP = qLP2;
	}

	RANGE = pRANGE;
	RANGE_Y = pRANGE_Y;
	outlierLambda = poutlierLambda;
	OutlierType = pOutlierType;
      }

      delete [] origmap_pool;
//       for(register int m = 0; m < MD; m++){
// 	delete [] origmapK[m];
// 	delete [] origmap[m];
//       }
      delete [] origmapK;
      delete [] origmap;
    } /* UPDATEMAP */
  }/* perform update of Y,Hcuts and pcontig->fragcnt[] */

  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
    (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      int lastJ = -1, lasti = -1, lastk = -1;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
	  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	  fflush(stdout);
	  assert(0 <= k && k < i);
	}
	if(lasti >= 0 && !(i-k > lasti)){
	  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	  if(VERB){
	    for(int j = 1; j <= M; j++){
	      int i = map[m][j];
	      if(i < 0)
		continue;
	      int k = mapK[m][j];
	      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	    }
	  }
	  fflush(stdout);
	  assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }
  }

  rverb = origrverb;

  delete [] Ilist;
  delete [] Jlist;
  delete [] Klist;
  delete [] newY;
  delete [] Ydist_pool;
//   for(register int I = 0; I <= N; I++)
//     delete [] Ydist[I];
  delete [] orignmap_pool;
//   for(register int m = 0; m < MD; m++){
//     delete [] orignmapK[m];
//     delete [] orignmap[m];
//   }
  delete [] bestLPAorig;
  delete [] orignmapK;
  delete [] orignmap;
  delete [] orignmapMD;
  delete [] newLPA;

  delete [] Ydist;
  delete [] Ycnt;
  delete [] YcntMax;

  return newLP;
}

/* A uniformly distributed random number on [0,1) */
/* 0.0 <= urandom() < 1.0 */
static double urandom(void)
{
  register double r = random();
  return r / 2147483648.0; /* 2^31 */
}

/* re-position deleted sites in Hcuts[] (unaligned sites in X[m][]) and update map/mapK (even for maps with TBmapWT[m] == 0.0)*/
static void reposition(int n, double *Hcuts, int *Hdel,	 
		       int N, register double *Y,
		       int MD, int *MX, double **X,
		       int **map, int **mapK, Csetlimit *limit, double *TBmapWT, int **nmap, int *skip, int &Lfrozen,int &Rfrozen, Ccontig *pcontig)
{
  if(SETLIMIT_CACHE)
    for(int m = 0; m < MD; m++)
      limit[m].ileft = -1;

  /* remember original location of Hcuts[Lendi,Rendi]*/
  double Lend = Hcuts[Lendi], Rend = Hcuts[Rendi];

  /* remember original location of Hcuts[Lfrozen,Rfrozen] */
  double left = Hcuts[Lfrozen], right = Hcuts[Rfrozen];
  double origleft = Hcuts[origLfrozen], origright = Hcuts[origRfrozen];
  if(VERB/* HERE >=2 */){
    printf("reposition:n=%d,Hcuts[n]=%0.6f,Hcuts[n+1]=%0.6f,N=%d,Y[1]=%0.4f,Y[N]=%0.4f,Y[N+1]=%0.4f,Hcuts[Lendi=%d]=%0.4f,Hcuts[Rendi=%d]=%0.4f: cum wall time= %0.6f\n",
	   n,Hcuts[n],Hcuts[n+1],N,Y[1],Y[N],Y[N+1], Lendi,Hcuts[Lendi], Rendi, Hcuts[Rendi], wtime());
    printf("\t Lfrozen=%d,Rfrozen=%d,left=Hcuts[Lfrozen]=%0.4f,right=Hcuts[Rfrozen]=%0.4f,origLfrozen=%d,origleft=%0.4f,origRfrozen=%d,origright=%0.4f\n",
	   Lfrozen,Rfrozen,left,right,origLfrozen,origleft,origRfrozen,origright);
    fflush(stdout);
  }

  /* If UpdateMap() was called these sites in Hcuts[] may no longer be aligned with any site in X[] : just collect a set of candidate locations in each real interval and assign as many of them to deleted locations in Hcuts[]
     as possible */
  /* count number of unaligned sites in all molecules X[] */
  int addcnt = 0;
  for(int m = 0; m < MD; m++){
    if(TBmapWT[m] <= 0.0)
      continue;
    int M = MX[m];
    int origcnt = addcnt;
    for(int J = 1; J <= M; J++){
      int i = map[m][J];
      if(i < 0 || map[MD][i] < 0)
	addcnt++;
    }
    if(addcnt - origcnt >= M)
      addcnt = origcnt;
    else
      addcnt += 2;  /* add space for ends of molecules */
    if(DEBUG) assert(addcnt >= 0);
    if(VERB>=3){
      printf("m=%d:M=%d,addcnt=%d\n",m,M,addcnt);
      fflush(stdout);
    }
  }

  int unaddcnt = addcnt;

  /* add aligned sites in Hcuts[] + space for left and right end of original consensus (in case they match one of Hcuts[origLfrozen, Lfrozen,Rfrozen, origRfrozen]) */
  addcnt += N+6;
  /* NOTE : Hcuts[n+1] may or may not be included in the above sites.  Hcuts[0] is never included and always==0.0 */

  if(DEBUG) assert(addcnt >= 0);

  if(addcnt > 0){
    int maxaddcnt = addcnt;
    Caddloc *addloc = new Caddloc[maxaddcnt];
    if(DEBUG>=2){/* check if map[MD] and nmap[MD] are consistent */
      int I,i;
      for(i = 1; i <= n; i++)
	if((I = map[MD][i]) >= 0){
	  assert(nmap[MD][I] == i);
	  assert(fabs(Hcuts[i] - Y[I]) < 1e-6);
	}
      for(I = 1; I <= N; I++)
	if((i = nmap[MD][I]) >= 0){
	  assert(map[MD][i] == I);
	  assert(fabs(Hcuts[i] - Y[I]) < 1e-6);
	}
    }
    if(DEBUG>=2){/* make sure map[] and mapK[] are consistent */
      int I;
      for(int m = 0; m < MD; m++){
	if(TBmapWT[m] <= 0.0)
	  continue;
	int M = MX[m];
	int lastJ = -1, lasti = -1, lastk = -1, i, k;
	for(int J = 1; J <= M; J++){
	  if((i=map[m][J]) > 0 && (I = map[MD][i]) >= 0){
	    k = mapK[m][J];
	    assert(0 <= k && k < i);
	    if(!Hdel[i]) assert(!Hdel[i-k]);
	    int K = map[MD][i-k];
  
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("m=%d,J=%d,i=%d,k=%d(I=%d,K=%d):lastJ=%d,lasti=%d,lastk=%d\n",m,J,i,k,I,I-K,lastJ,lasti,lastk);
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }
    }

    Caddloc *p = addloc;

    double minloc = 0.0;/* leftmost unaligned site or end : for debugging large -ve values */
    double maxloc = Y[N+1];/* rightmost unaligned site or end : for debugging large extensions of right end */

    for(int m = 0; m < MD; m++){
      if(TBmapWT[m] <= 0.0)
	continue;
      int M = MX[m];
      double *Xm = X[m];
      /* locate first aligned site */
      int R = 1, iR = -1, I;
      for(; R <= M; R++)
	if((iR = map[m][R]) >= 0 && (I = map[MD][iR]) >= 0)
	  break;
      if(R > M)
	continue;/* molecule m has no aligned sites (should be rare)  */
      if(DEBUG) assert(iR >= 0);
      int kR = mapK[m][R];
      if(DEBUG) assert(kR >= 0 && kR < iR);

      /* locate sites left of Xm[R] by extrapolation */
      double loc = Hcuts[iR-kR] - Xm[R];

      for(int J = 0; J < R; J++, p++){
	p->i = -1;/* unaligned */
	p->m = m;
	p->J = J;
	p->loc = loc + Xm[J]; 

	if(VERB>=2 && p->loc < minloc - 1.0){
	  printf("m=%d(id=%lld):iR=%d,kR=%d,R=%d,J=%d,M=%d:Hcuts[iR-kR]=%0.3f,Xm[R]=%0.3f,Xm[J]=%0.3f,Xm[1,M,M+1]=%0.3f,%0.3f,%0.3f:minloc=%0.3f -> %0.3f\n",
		 m,gmap[pcontig->contig[m].mapid]->id,iR,kR,R,J,M,Hcuts[iR-kR],Xm[R],Xm[J],Xm[1],Xm[M],Xm[M+1],minloc,min(minloc,p->loc));
	  if(p->loc < -1000.0)
	    for(int j = 1; j <= M; j++)
	      printf("\t Xm[%d]= %0.3f\n",j, Xm[j]);
	  fflush(stdout);
	}
	minloc = min(minloc,p->loc);
	
	map[m][J] = -1;/* in case this site has to be discarded from Hcuts[] */
	mapK[m][J] = 0;
      }

      int L = R, iL = iR;
      //      int kL = kR;
      for(; ++R <= M;){
	if((iR = map[m][R]) >= 0 && (I = map[MD][iR]) >= 0){
	  kR = mapK[m][R];
	  if(DEBUG) assert(kR >= 0 && kR < iR);

	  /* locate sites between L and R by interpolation */
	  double ratio = (Hcuts[iR-kR]-Hcuts[iL])/(Xm[R]-Xm[L]);
	  double loc = Hcuts[iL] - ratio*Xm[L];

	  for(int J = L+1; J < R; J++, p++){
	    p->i = -1;/* unaligned */
	    p->m = m;
	    p->J = J;
	    p->loc = loc + ratio * Xm[J];
	    if(DEBUG>=2) assert(minloc <= p->loc && p->loc <= maxloc);

	    map[m][J] = -1;/* in case this site has to be discarded from Hcuts[] */
	    mapK[m][J] = 0;
	  }

	  L = R;
	  iL = iR;
	  //	  kL = kR;
	}
      }
      /* locate sites right of X[m][L] by extrapolation */
      loc = Hcuts[iL] - Xm[L];
      for(int J = L; ++J <= M+1; p++){
	p->i = -1;/* unaligned */
	p->m = m;
	p->J = J;
	p->loc = loc + Xm[J];
	if(DEBUG && p->loc > maxloc){
	  if(VERB>=2 && p->loc > maxloc){
	    printf("m=%d:iL=%d,L=%d,J=%d:Hcuts[iL]=%0.3f,Xm[L]=%0.3f,X[J]=%0.3f:maxloc=%0.3f -> %0.3f\n",
		   m,iL,L,J,Hcuts[iL],Xm[L],Xm[J],maxloc,p->loc);
	    fflush(stdout);
	  }
	  maxloc = p->loc;
	}

	map[m][J] = -1;/* in case this site has to be discarded from Hcuts[] */
	mapK[m][J] = 0;
      }
      if(VERB>=3){
	printf("m=%d:M=%d,p-addloc=%ld\n",m,M,p-addloc);
	fflush(stdout);
      }
    }

    double shift = 0.0;

    int unaligned_cnt = p - addloc;

    if(VERB>=2 || (DEBUG && !(unaligned_cnt == unaddcnt))){
      printf("After collecting unaligned sites:addcnt=%d(unaddcnt=%d(MD=%d),N+6=%d):unaligned_cnt=%d, minloc=%0.3f,maxloc=%0.3f\n",
	     addcnt, unaddcnt,MD,N+6,unaligned_cnt,minloc,maxloc);
      fflush(stdout);
      assert(unaligned_cnt == unaddcnt);
    }

    /* add aligned sites in Hcuts[] */
    int icnt = 0;
#pragma novector
    for(int i = 1; i <= n; i++)
      if(!Hdel[i]){
	p->i = i;
	p->loc = Hcuts[i];
	if(DEBUG>=2) assert(minloc <= p->loc && p->loc <= maxloc);
	p->m = 0;/* Hdel[i] */
	p->J = -1;
	p++;

	if(DEBUG) icnt++;
	if(VERB>=3){
	  printf("i=%d:Hcuts[i]=%0.4f,icnt=%d,p-addloc=%ld\n",i,Hcuts[i],icnt,p-addloc);
	  fflush(stdout);
	}
      }
      
    if(DEBUG && !(p-addloc <= addcnt)){
      printf("reposition:addcnt=%d(unaddcnt=%d(MD=%d),N=%d):unaligned_cnt=%d,p-addloc=%ld,maxaddcnt=%d,icnt=%d\n",
	     addcnt,unaddcnt,MD,N,unaligned_cnt,p-addloc,maxaddcnt,icnt);
      int cnt = 0;
      for(int i = 1; i <= n; i++)
	if(!Hdel[i]){
	  cnt++;
	  printf("i=%d:Hcuts[i]=%0.4f,cnt=%d\n",i,Hcuts[i],cnt);
	}
      for(int I = 1; I <= N; I++)
	printf("I=%d:Y[I]=%0.4f\n",I,Y[I]);
      fflush(stdout);
      assert(p - addloc <= addcnt);
    }

    if(VERB/* HERE >=2 */){
      printf("unaligned_cnt=%d,addcnt=%d\n",unaligned_cnt,addcnt);
      if(VERB>=2)
	printf("\t minloc=%0.3f,maxloc=%0.3f\n",minloc,maxloc);
      fflush(stdout);
    }

    int frozen_cnt = 0;

    /* verify that Hcuts[Lfrozen,origLfrozen] have been included */
    if(Rfrozen > 0){
      double err = 1.0, loc = Hcuts[Lfrozen];
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("Lfrozen=%d: Adding Hcuts[Lfrozen]=%0.6f at addloc[%ld] (err=%0.3f)\n", Lfrozen, Hcuts[Lfrozen], p - addloc, err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	p->i = Lfrozen;/* unaligned */
	p->m = Hdel[Lfrozen];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >= 2*/){
	  printf("Lfrozen=%d: Hcuts[Lfrozen]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",Lfrozen,Hcuts[Lfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i != -2){
	  addloc[ierr].i = -2;// protect this site from deletion */
	  frozen_cnt++;
	}
      } else if(VERB/* HERE >= 2*/){
	printf("Lfrozen=%d: Hcuts[Lfrozen]=%0.6f is an existing site at addloc[%d]=%0.6f(i=%d)\n",Lfrozen,Hcuts[Lfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	fflush(stdout);
      }
    }

    if(origRfrozen > 0 && origLfrozen != Lfrozen){
      double err = 1.0, loc = Hcuts[origLfrozen];
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("origLfrozen=%d: Adding Hcuts[origLfrozen]=%0.6f at addloc[%ld] (err=%0.3f)\n", origLfrozen, Hcuts[origLfrozen], p - addloc, err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	p->i = origLfrozen;/* unaligned */
	p->m = Hdel[origLfrozen];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >= 2*/){
	  printf("origLfrozen=%d: Hcuts[origLfrozen]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",origLfrozen,Hcuts[origLfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i != -2){
	  addloc[ierr].i = -2;// protect this site from deletion */
	  frozen_cnt++;
	}
      } else if(VERB/* HERE >= 2*/){
	printf("origLfrozen=%d: Hcuts[origLfrozen]=%0.6f is an existing site at addloc[%d]=%0.6f (i=%d)\n",origLfrozen,Hcuts[origLfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	fflush(stdout);
      }
    }

    if(Rfrozen > Lfrozen){
      double err = 1.0, loc = Hcuts[Rfrozen];
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("Rfrozen=%d: Adding Hcuts[Rfrozen]=%0.6f at addloc[%ld] (err=%0.3f)\n",Rfrozen,Hcuts[Rfrozen],p - addloc,err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	p->i = Rfrozen;/* unaligned */
	p->m = Hdel[Rfrozen];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >= 2*/){
	  printf("Rfrozen=%d: Hcuts[Rfrozen]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",Rfrozen,Hcuts[Rfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i != -2){
	  addloc[ierr].i = -2;// protect this site from deletion */
	  frozen_cnt++;
	}
      } else if(VERB/* HERE >= 2*/){
	printf("Rfrozen=%d: Hcuts[Rfrozen]=%0.6f is an existing site at addloc[%d]=%0.6f(i=%d)\n",Rfrozen,Hcuts[Rfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	fflush(stdout);
      }
    }

    if(origRfrozen > origLfrozen && origRfrozen != Rfrozen){
      double err = 1.0, loc = Hcuts[origRfrozen];
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("origRfrozen=%d: Adding Hcuts[origRfrozen]=%0.6f at addloc[%ld] of locations (err=%0.3f)\n",origRfrozen,Hcuts[origRfrozen],p-addloc,err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	p->i = origRfrozen;/* unaligned */
	p->m = Hdel[origRfrozen];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >= 2*/){
	  printf("origRfrozen=%d: Hcuts[origRfrozen]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",origRfrozen,Hcuts[origRfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i != -2){
	  addloc[ierr].i = -2;// protect this site from deletion */
	  frozen_cnt++;
	}
      } else 	if(VERB/* HERE >= 2*/){
	printf("origRfrozen=%d: Hcuts[origRfrozen]=%0.6f is an existing site at addloc[%d]=%0.6f(i=%d)\n",origRfrozen,Hcuts[origRfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	fflush(stdout);
      }
    }

    /* verify that Hcuts[Lendi,Rendi] have been included */
    if(Rendi > 0){
      double err = 1.0, loc = Lend;
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("Lend=%0.6f: Adding Hcuts[Lendi=%d]=%0.6f as protected location at addloc[%ld] (err=%0.3f)\n",Lend, Lendi, Hcuts[Lendi], p - addloc, err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	p->i = Lendi;/* special case */
	p->m = Hdel[Lendi];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >=2 */){
	  printf("Lend=%0.6f: Hcuts[Lendi=%d]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",Lend,Lendi,Hcuts[Lendi],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i != -2){
	  addloc[ierr].i = -2;// protect this site from deletion */
	  frozen_cnt++;
	}
      } else 	if(VERB/* HERE >=2 */){
	printf("Lend=%0.6f: Hcuts[Lendi=%d]=%0.6f is an existing site at addloc[%d]=%0.6f(i=%d)\n",Lend,Lendi,Hcuts[Lendi],ierr,addloc[ierr].loc,addloc[ierr].i);
	fflush(stdout);
      }
    }

    if(Rendi > Lendi){
      double err = 1.0, loc = Rend;
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("Rend=%0.6f: Adding Hcuts[Rendi=%d]=%0.6f as protected location at addloc[%ld] (err=%0.3f)\n",Rend, Rendi, Hcuts[Rendi], p - addloc, err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	p->i = Rendi;/* special case */
	p->m = Hdel[Rendi];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >=2 */){
	  printf("Rend=%0.6f: Hcuts[Rendi=%d]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",Rend,Rendi,Hcuts[Rendi],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i != -2){
	  addloc[ierr].i = -2;// protect this site from deletion */
	  frozen_cnt++;
	}
      } else	if(VERB/* HERE >=2 */){
	printf("Rend=%0.6f: Hcuts[Rendi=%d]=%0.6f is an existing site at addloc[%d]=%0.6f(i=%d)\n",Rend,Rendi,Hcuts[Rendi],ierr,addloc[ierr].loc,addloc[ierr].i);
	fflush(stdout);
      }
    }

    if(DEBUG) assert(p <= &addloc[maxaddcnt]);
    addcnt = p - addloc;

    if(VERB>=3){
      printf("Initial list of locations addloc[0..%d]:\n",addcnt-1);
      for(int i = 0; i < addcnt; i++)
	printf("addloc[%d]: loc=%0.6f, i=%d, m=%d, J=%d\n",i,addloc[i].loc,addloc[i].i,addloc[i].m,addloc[i].J);
      fflush(stdout);
    }

    if(addcnt > n){/* randomly remove some unaligned sites */
      srandom(1);
      if(VERB){
	printf("Randomly ignoring %d out of %d unaligned sites (n=%d,addcnt=%d,frozen_cnt=%d):\n", addcnt-n, unaligned_cnt, n, addcnt,frozen_cnt);
	fflush(stdout);
      }
      int i,j;
      int delcnt = addcnt - n;
      int remcnt = unaligned_cnt - frozen_cnt;
      if(VERB>=3 || (DEBUG && !(delcnt <= remcnt))){
	printf("addcnt=%d,n=%d,unaligned_cnt=%d,frozen_cnt=%d,remcnt=%d,delcnt=%d:\n",
	       addcnt,n,unaligned_cnt,frozen_cnt,remcnt,delcnt);
	for(int i = 0; i < addcnt; i++)
	  printf("addloc[%d]:loc=%0.3f,i=%d,m=%d,J=%d\n",i,addloc[i].loc,addloc[i].i,addloc[i].m,addloc[i].J);
	fflush(stdout);
	if(DEBUG) assert(delcnt <= remcnt);
      }
      int protcnt = 0;/* count of protected sites copied */

      for(i = j = 0; i < addcnt; i++, remcnt--){
	if(addloc[i].i != -1){/* do NOT delete this site */
	  addloc[j++]  = addloc[i];
	  remcnt++;
	  if(addloc[i].i == -2)
	    protcnt++;
	  continue;
	}
	if(delcnt > 0){
	  if(DEBUG && !(remcnt > 0 && remcnt >= delcnt)){
	    printf("addcnt=%d,n=%d,unaligned_cnt=%d,frozen_cnt=%d:i=%d,j=%d,remcnt=%d,delcnt=%d,protcnt=%d\n",
		   addcnt,n,unaligned_cnt,frozen_cnt,i,j,remcnt,delcnt,protcnt);
	    fflush(stdout);
	    assert(remcnt > 0 && remcnt >= delcnt);
	  }
	  if(DEBUG) assert(addloc[i].i < 0);
	  double delprob = ((double)delcnt)/remcnt;
	  double r = urandom();
	  if(delcnt > 0 && (r < delprob || delcnt >= remcnt)){
	    delcnt--;
	    continue;
	  }
	}
	addloc[j++]  = addloc[i];
      }
      if(DEBUG) assert(protcnt == frozen_cnt);
      if(DEBUG) assert(remcnt == 0);
      if(DEBUG) assert(i==addcnt);
      if(DEBUG) assert(j==n);
      addcnt = j;
    } else if(VERB && addcnt < n){
      printf("%d padded sites in Hcuts (out of n=%d total sites):\n", n-addcnt,n);
      fflush(stdout);
    }

    if(DEBUG) assert(addcnt <= n);

    qsort(addloc,addcnt,sizeof(Caddloc),(intcmp *)CaddlocInc);
    if(VERB/* HERE >=2 */){
      printf("addcnt=%d,n=%d:addloc[0].loc=%0.3f,addloc[addcnt-1].loc=%0.3f\n",addcnt,n,addloc[0].loc,addloc[addcnt-1].loc);
      if(VERB>=2)
	printf("\t minloc=%0.3f,maxloc=%0.3f\n",minloc,maxloc); 
      fflush(stdout);
    }

    if(addloc[0].loc  < MININTERVAL){/* shift all sites right so addloc[0].loc (== Hcuts[1]) is >= MININTERVAL */
      if(VERB/* HERE >= 2*/){
	printf("addloc[0].loc = %0.6f : shifting all sites right by %0.6f (addloc[addcnt-1].loc=%0.6f)\n",addloc[0].loc, MININTERVAL-addloc[0].loc,addloc[addcnt-1].loc);
	fflush(stdout);
      }
      shift = MININTERVAL - addloc[0].loc;
      for(int t = 0; t < addcnt; t++)
	addloc[t].loc += shift;
      Hcuts[n+1] += shift;
      left += shift;
      right += shift;
      origleft += shift;
      origright += shift;
      Lend += shift;
      Rend += shift;
    }

    int *Hremap = new int[n+1];/* Hremap[i=1..n] remaps old aligned site Hcuts[i] to Hcuts[Hremap[i]] : used to update map[m][J],mapK[m][J] and Hdel[] */
    for(int i = 1; i <= n; i++)
      Hremap[i] = -1;/* unmapped */
    for(int i = 0; i < addcnt; i++){
      Caddloc *p = &addloc[i];
      if(p->i < 0 || Hdel[p->i])
	continue;
      if(DEBUG) assert(1 <= p->i && p->i <= n);
      Hremap[p->i] = i+1;
    }

    if(DEBUG>=2){
      for(int i = 1; i <= n; i++){
	if(Hdel[i])
	  assert(Hremap[i] == -1);
	else {
	  if(DEBUG && !(1 <= Hremap[i] && Hremap[i] <= addcnt)){
	    for(int I = 1; I <= n; I++)
	      if(!Hdel[I])
		printf("i=%d:Hdel[i]=%d,Hremap[i]=%d\n",I,Hdel[I],Hremap[I]);
	    for(int t = 0; t < addcnt; t++)
	      printf("addloc[%d]:loc=%0.3f,i=%d,m=%d,J=%d\n",t,addloc[t].loc,addloc[t].i,addloc[t].m,addloc[t].J);

	    printf("i=%d,n=%d:Hremap[i]=%d,addcnt=%d,Hdel[i]=%d\n",
		   i,n,Hremap[i],addcnt,Hdel[i]);
	    fflush(stdout);
	    assert(1 <= Hremap[i] && Hremap[i] <= addcnt);
	  }
	}
      }
    }

    /* remap map[m][J],mapK[m][J] based on Hremap[i] */
    for(int m = 0; m < MD; m++){
      // NOTE : maps with TBmapWT[m] <= 0.0, may later be restored to TBmapWT[m] > 0 and hence map[]/mapK[] need to be kept up to date
      //      if(TBmapWT[m] <= 0.0)
      //	continue;

      int M = MX[m], iR;
      int *mapM = map[m], *mapKM = mapK[m];
      for(int J = 1; J <= M; J++){
	if((iR = mapM[J]) >= 0){
	  int Rnew = Hremap[iR];
	  if(Rnew < 0){
	    if(DEBUG) assert(map[MD][iR] < 0);
	    if(DEBUG) assert(Hdel[iR]);
	    if(DEBUG) mapM[J] = -1;
	    continue;
	  }
	  if(DEBUG) assert(!Hdel[iR]);
	  int k = mapKM[J];
	  if(DEBUG) assert(k >= 0);
	  int iL = iR - k;

	  int Lnew = Hremap[iL];
	  /* NOTE : not all sites between Hcuts[iL] and Hcuts[iR] are real sites */
	  if(DEBUG && Hdel[iL]){
	    printf("m=%d,M=%d,J=%d:iR=%d,Hremap[iR]=%d,k=%d,iL=%d,n=%d,Hdel[iL]=%d,Hremap[iL]=%d\n",
		   m,M,J,iR,Hremap[iR],k,iL,n,Hdel[iL],Hremap[iL]);
	    fflush(stdout);
	    assert(!Hdel[iL]);
	  }
	  if(DEBUG) assert(Lnew >= 1 && Lnew <= Rnew);
	  mapM[J] = Rnew;
	  mapKM[J] = Rnew - Lnew;
	}
      }
    }

    /* Now map each site addloc[0..addcnt-1].loc to Hcuts[1..addcnt] and pad Hcuts[addcnt+1 .. n] (if needed) to all equal Hcuts[addcnt] and have Hdel[] == 1 */
    if(VERB/* HERE >=3 */){
      printf("addcnt=%d,n=%d:addloc[0].loc=%0.3f,addloc[addcnt-1].loc=%0.3f\n",addcnt,n,addloc[0].loc,addloc[addcnt-1].loc);
      fflush(stdout);
    }
    p = addloc;
#pragma novector
    for(int t = 0; t < addcnt; t++, p++){
      Hcuts[t+1] = p->loc;
      if(p->i < 0){/* unaligned site */
	Hdel[t+1] = 1;
	if(DEBUG) assert(map[p->m][p->J] < 0);/* set in above remap loop */
	map[p->m][p->J] = t+1;
	mapK[p->m][p->J] = 0;
      } else
	Hdel[t+1] = p->m;/* map[],mapK[] has already been remapped for real sites */
    }
    for(int t = addcnt+1; t <= n; t++){
      Hcuts[t] = Hcuts[addcnt];
      Hdel[t] = 1;
    }
    if(Hcuts[n] + MININTERVAL > Hcuts[n+1]){
      if(VERB){
	printf("Enlarging Hcuts[n+1]=%0.3f -> %0.3f, Hcuts[n]=%0.3f\n",Hcuts[n+1],Hcuts[n]+MININTERVAL, Hcuts[n]);
	fflush(stdout);
      }
      //	assert(Hcuts[n] < Hcuts[n+1] * 1.10 + 1.0);
      Hcuts[n+1] = Hcuts[n] + MININTERVAL;
    }

    if(DEBUG>=2){
      for(int i = 1; i <= n+1; i++){
	if(DEBUG && !(Hcuts[i] >= Hcuts[i-1])){
	  printf("i=%d:Hcuts[i-1]=%0.6f,Hcuts[i]=%0.6f\n",i,Hcuts[i-1],Hcuts[i]);
	  fflush(stdout);
	  assert(Hcuts[i] >= Hcuts[i-1]);
	}
      }
    }

    /* update map[MD],nmap[MD] */
    double *newY = new double[n+2];
    int newN = setmap(n,Hcuts,Hdel,newY,map[MD],nmap[MD]);
    if(DEBUG){
      assert(newN == N);
      for(int I = 1; I <= N; I++)
	assert(fabs(Y[I]+shift - newY[I]) < 1e-10);
      assert(newY[N+1] >= Y[N+1]+shift);
    }
    for(int I = 1; I <= N+1; I++)
      Y[I] = newY[I];

    if(DEBUG){
      for(int i = 1; i <= n+1; i++){
	if(DEBUG && !(Hcuts[i] >= Hcuts[i-1])){
	  printf("i=%d:Hcuts[i-1]=%0.6f,Hcuts[i]=%0.6f,n=%d\n",i,Hcuts[i-1],Hcuts[i],n);
	  fflush(stdout);
	  assert(Hcuts[i] >= Hcuts[i-1]);
	}
      }
    }
    if(VERB/* HERE >=2 */){
      printf("n=%d,Hcuts[n]=%0.6f,Hcuts[n+1]=%0.6f,N=%d,Y[1]=%0.4f,Y[N]=%0.4f,Y[N+1]=%0.4f\n",n,Hcuts[n],Hcuts[n+1],N,Y[1],Y[N],Y[N+1]);
      fflush(stdout);
    }

    delete [] newY;
    delete [] Hremap;

    if(DEBUG>=2 && !(Hcuts[n] <= Hcuts[n+1])){
      printf("n=%d:Hcuts[n]=%0.3f,Hcuts[n+1]=%0.3f\n",n,Hcuts[n],Hcuts[n+1]);
      fflush(stdout);
      assert(Hcuts[n] <= Hcuts[n+1]);
    }

    if(Rendi > 0){/* recompute Lendi, Rendi */
      int startLendi = Lendi, startRendi = Rendi;
      if(DEBUG) assert(Rendi >= Lendi);
      Lendi = 0; Rendi = n+1;
      for(int i = 0; i <= n+1; i++){
	if(fabs(Lend - Hcuts[i]) < fabs(Lend - Hcuts[Lendi]))
	  Lendi = i;
	if(fabs(Rend - Hcuts[i]) < fabs(Rend - Hcuts[Rendi]))
	  Rendi = i;
      }
      if(startLendi <= 0)
	Lendi = 0;// NEW22
      if(startRendi >= n+1)
	Rendi = n+1;// NEW22
      if(VERB/* HERE >=2 */ || (DEBUG && !(Rendi != 0 && Rendi > Lendi))){
	printf("Lendi=%d -> %d (%0.6f -> %0.6f), Rendi=%d -> %d (%0.6f -> %0.6f),n=%d,Hcuts[n+1]=%0.6f\n",
	       startLendi,Lendi,Lend,Hcuts[Lendi],startRendi,Rendi,Rend,Hcuts[Rendi],n,Hcuts[n+1]);
	fflush(stdout);

	if(DEBUG) assert(Rendi != 0 && Rendi > Lendi);
      }
    }
    if(Rfrozen > 0){ /* recompute Lfrozen, Rfrozen */
      int startLfrozen = Lfrozen, startRfrozen = Rfrozen;
      if(DEBUG) assert(Rfrozen >= Lfrozen);
      Lfrozen = Rfrozen = 0;
      for(int i = 0; i <= n+1; i++){
	if(fabs(left - Hcuts[i]) < fabs(left - Hcuts[Lfrozen]))
	  Lfrozen = i;
	if(fabs(right - Hcuts[i]) < fabs(right - Hcuts[Rfrozen]))
	  Rfrozen = i;
      }
      if(DEBUG && (!(Rfrozen != 0 && Rfrozen >= Lfrozen) || !(fabs(left-Hcuts[Lfrozen]) < 0.002 && fabs(right-Hcuts[Rfrozen]) < 0.002))){
	printf("Lfrozen=%d -> %d,Rfrozen=%d ->%d,left=%0.7f,right=%0.7f,Hcuts[Lfrozen]=%0.7f,Hcuts[Rfrozen]=%0.7f,n=%d:\n",
	       startLfrozen,Lfrozen,startRfrozen,Rfrozen,left,right,Hcuts[Lfrozen],Hcuts[Rfrozen],n);
	for(int i = 0; i <= n+1; i++)
	  printf("i=%d:Hcuts[i]=%0.6f,Hdel[i]=%d\n",i,Hcuts[i],Hdel[i]);
	fflush(stdout);
	assert(Rfrozen != 0 && Rfrozen >= Lfrozen);
	assert(fabs(left-Hcuts[Lfrozen]) < 0.002 && fabs(right-Hcuts[Rfrozen]) < 0.002);
      }
      if(startLfrozen <= 0)
	Lfrozen = 0;// NEW22
      if(startRfrozen >= n+1)
	Rfrozen = n+1;// NEW22
      if((VERB/* HERE >=2 */ /* && !(startLfrozen == Lfrozen && startRfrozen == Rfrozen)*/) || (DEBUG && !(Rfrozen != 0 && Rfrozen > Lfrozen))){
	printf("Lfrozen=%d -> %d,Rfrozen=%d ->%d,left=%0.7f,right=%0.7f,Hcuts[Lfrozen]=%0.7f,Hcuts[Rfrozen]=%0.7f,n=%d:\n",
	       startLfrozen,Lfrozen,startRfrozen,Rfrozen,left,right,Hcuts[Lfrozen],Hcuts[Rfrozen],n);
	fflush(stdout);
      }
      //      Lfrozeni = Lfrozen;
      //      Rfrozeni = Rfrozen;
    }
    if(origRfrozen > 0){ /* recompute origLfrozen, origRfrozen */
      int startRfrozen = origRfrozen;
      int startLfrozen = origLfrozen;

      if(DEBUG) assert(origRfrozen > 0 && origRfrozen >= origLfrozen);
      origLfrozen = origRfrozen = 0;
      for(int i = 0; i <= n+1; i++){
	if(fabs(origleft - Hcuts[i]) < fabs(origleft - Hcuts[origLfrozen]))
	  origLfrozen = i;
	if(fabs(origright - Hcuts[i]) < fabs(origright - Hcuts[origRfrozen]))
	  origRfrozen = i;
      }
      if(DEBUG && (!(origRfrozen != 0 && origRfrozen >= origLfrozen) || !(fabs(origleft-Hcuts[origLfrozen]) < 0.002 && fabs(origright-Hcuts[origRfrozen]) < 0.002))){
	printf("origLfrozen=%d -> %d,origRfrozen=%d ->%d,origleft=%0.7f,origright=%0.7f,Hcuts[origLfrozen]=%0.7f,Hcuts[origRfrozen]=%0.7f,n=%d:\n",
	       startLfrozen,origLfrozen,startRfrozen,origRfrozen,origleft,origright,Hcuts[origLfrozen],Hcuts[origRfrozen],n);
	for(int i = 0; i <= n+1; i++)
	  printf("i=%d:Hcuts[i]=%0.6f,Hdel[i]=%d\n",i,Hcuts[i],Hdel[i]);
	fflush(stdout);
	if(DEBUG) assert(origRfrozen > 0 && origRfrozen >= origLfrozen);
	if(DEBUG) assert(fabs(origleft-Hcuts[origLfrozen]) < 0.002 && fabs(origright-Hcuts[origRfrozen]) < 0.002);
      }
      if(startLfrozen <= 0)
	origLfrozen = 0;// NEW22
      if(startRfrozen >= n+1)
	origRfrozen = n+1;// NEW22
      if(VERB/* HERE >=2 */ && !(startLfrozen == origLfrozen && startRfrozen == origRfrozen)){
	printf("origLfrozen=%d -> %d,origRfrozen=%d ->%d,origleft=%0.7f,origright=%0.7f,Hcuts[origLfrozen]=%0.7f,Hcuts[origRfrozen]=%0.7f,n=%d:\n",
	       startLfrozen,origLfrozen,startRfrozen,origRfrozen,origleft,origright,Hcuts[origLfrozen],Hcuts[origRfrozen],n);
	fflush(stdout);
      }
    }

    if(VERB/* HERE >=2 */){
      printf("Re-positioned %d unaligned sites in Hcuts[]\n",addcnt);
      fflush(stdout);
    }

    delete [] addloc;

    if(DEBUG>=2){/* make sure map[] and mapK[] are consistent */
      for(int m = 0; m < MD; m++){
	if(TBmapWT[m] <= 0.0)
	  continue;
	int M = MX[m];
	int lastJ = -1, lasti = -1, lastk = -1, i, k;

	for(int J = 1; J <= M; J++){
	  if(TBmapWT[m] <= 0.0)
	    continue;
	  if((i = map[m][J]) > 0){
	    k = mapK[m][J];
	    assert(0 <= k && k < i);
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d\n",m,J,i,k,lastJ,lasti,lastk);
	      for(int j = 1; j <= M; j++){
		int ni,nk;
		if((ni = map[m][j]) > 0){
		  nk = mapK[m][j];
		  printf("m=%d:j=%d,M=%d:map[m][j]=i=%d,mapK[m][j]=k=%d,X[m][j]=%0.3f,Hcuts[i]=%0.3f,Hcuts[i-k]=%0.3f,map[MD][i]=%d,map[MD][i-k]=%d\n",
			 m,j,M,map[m][j],mapK[m][j],X[m][j],Hcuts[ni],Hcuts[ni-nk],map[MD][ni],map[MD][ni-nk]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }
    }
  }

  if(DEBUG>=2 && !(Hcuts[n] <= Hcuts[n+1])){
    printf("n=%d:Hcuts[n]=%0.3f,Hcuts[n+1]=%0.3f\n",n,Hcuts[n],Hcuts[n+1]);
    fflush(stdout);
    assert(Hcuts[n] <= Hcuts[n+1]);
  }

  /* recompute skip[] values */
  int skipcnt = 0;
  for(int i = 0; i <= n+1; i++)
    skip[i] = 0;

  if(SKIP_DIST_FIX){// Use method in skip_sites() that can handle more than 2 coincident labels in a row
    if(1 /* HERE SKIP_DIST <= 0.0 */){/* If SKIP_DIST > 0.0, skip_sites() will take care of coincident labels, if SKIP_DIST_FIX >= 1 */
      int j = 1;
      for(; j <= n; j++)
	if(!skip[j])
	  break;

      for(int i=j+1; i <= n; i++){
	if(!Hdel[i]){
	  if(Hdel[j] && Hcuts[i] <= Hcuts[j] + 1e-6){
	    if(VERB>=2){
	      printf("reposition:skipping site %d (Hcuts[%d,%d]=%0.4f,%0.4f) as duplicate site\n",j, j, i, Hcuts[j], Hcuts[i]);
	      fflush(stdout);
	    }
	    skip[j] = 1;
	    skipcnt++;
	  }

	  j = i;
	  continue;
	}

	if(Hcuts[i] <= Hcuts[j] + 1e-6){
	  if(VERB>=2){
	    printf("reposition:skipping site %d (Hcuts[%d,%d]=%0.4f,%0.4f) as duplicate site\n",i, j, i, Hcuts[j], Hcuts[i]);
	    fflush(stdout);
	  }
	  skip[i] = 1;
	  skipcnt++;
	  continue;
	}

	j = i;
      }
    }

  } else {// SKIP_DIST_FIX == 0 : older algorithm, does not correctly handle 3 or more coincident labels

    for(int i = 2; i <= n; i++){
      if(Hcuts[i] <= Hcuts[i-1] + 1e-6 && !skip[i] && !skip[i-1]){
	if(DEBUG) assert(Hdel[i] || Hdel[i-1]);
	if(Hdel[i])
	  skip[i] = 1;
	else
	  skip[i-1] = 1;
	skipcnt++;
	if(VERB>=2){
	  printf("reposition:skipping site %d (%0.3f,%0.3f) as duplicate site\n",Hdel[i] ? i : i-1, Hcuts[i-1],Hcuts[i]);
	  fflush(stdout);
	}
      }
    }
  }
  if(VERB /* >=2 */){
    printf("n=%d: skipping %d duplicate sites\n",n,skipcnt);
    fflush(stdout);
  }

  if((RefineEndOutlierThreshold < 2 && RefineEndOutlierWt == 0.0) || (extendonly && Refine >= 3)){/* suppress adding sites from maps supressed with -Erefine N 0.0 */
    skipcnt = 0;
    // float *sitecnt = pcontig->sitecnt[0];
    for(int m = 0; m < MD; m++){
      int M = MX[m],i;
      if(TBmapWT[m] > 0.0)
	continue;
      
      for(int J = 1; J <= M; J++)
	if((i = map[m][J]) >= 1 && Hdel[i]){
	  if(VERB>=2 && !skip[i]){
	    printf("Blocking Hcuts[%d]= %0.3f due to map m=%d(id=%lld) being suppressed by -Erefine %d 0.0\n",i,Hcuts[i], m, gmap[pcontig->contig[m].mapid]->id, RefineEndOutlierThreshold);
	    fflush(stdout);
	  }
	  skip[i] = 2;
	  skipcnt++;
	}
    }
    if(VERB){
      printf("n=%d: Blocking %d sites due to maps supressed with -Erefine %d 0.0\n",n, skipcnt, RefineEndOutlierThreshold);
      fflush(stdout);
    }
  }

  if(extend && Refine >= 2 && Rfrozen > Lfrozen){
    if(extendonly){/* permanantly block any changes to sites in the non-extension region */
      if(DEBUG) assert(extend >= 2);
      int L = Lfrozen, R = Rfrozen;
      if(VERB)
	skipcnt = 0;
#if 0 // WAS excluding regions outside the first and last site in this region ???
      for(; L < Rfrozen;L++)
	if(!Hdel[L])
	  break;
      for(; R > L;R--)
	if(!Hdel[R])
	  break;
#endif
      for(int i = L; i <= R; i++){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.3f in non-extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
      }
      if(VERB/* >=2 */ && skipcnt){
	printf("n=%d: Blocking %d sites in non-extension region due to -extendonly\n",n,skipcnt);
	fflush(stdout);
      }
      if(Rendi > 0){/* permanantly block any changes to sites outside of Hcuts[Lendi .. Rendi] */
	int origskipcnt = skipcnt;
	for(int i = 0; i < Lendi; i++){
	  if(VERB)
	    skipcnt += (skip[i] ? 0 : 1);
	  if(VERB>=2 && !skip[i]){
	    printf(" Blocking Hcuts[%d]=%0.3f in left extension region due to -EndTrim %0.2f -maxExtend %0.3f\n",i,Hcuts[i],EndTrimCov,MaxExtend);
	    fflush(stdout);
	  }
	  skip[i] = 2;
	  //	  if(DEBUG) assert(Hdel[i]);
	}
	for(int i = Rendi; ++i <= n; ){
	  if(VERB)
	    skipcnt += (skip[i] ? 0 : 1);
	  if(VERB>=2 && !skip[i]){
	    printf(" Blocking Hcuts[%d]=%0.3f in right extension region due to -EndTrim %0.2f -maxExtend %0.3f\n",i,Hcuts[i],EndTrimCov,MaxExtend);
	    fflush(stdout);
	  }
	  skip[i] = 2;
	  //	  if(DEBUG) assert(Hdel[i]);
	}
	if(VERB/* >=2 */ && skipcnt > origskipcnt){
	  printf("n=%d: Blocking %d sites in extension region due to -EndTrim %0.2f -maxExtend %0.3f\n",n,skipcnt-origskipcnt,EndTrimCov,MaxExtend);
	  fflush(stdout);
	}
      }
    }
    if(extend <= 1){ /* block any changes to sites in the extension region */
      if(VERB)
	skipcnt = 0;
      for(register int i = 0; i < Lfrozen; i++){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.3f in extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
	//	if(DEBUG) assert(Hdel[i]);
      }
      for(register int i = Rfrozen; ++i <= n; ){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.3f in extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
	//	if(DEBUG) assert(Hdel[i]);
      }
      if(VERB/* >=2 */ && skipcnt){
	printf("n=%d: Blocking %d sites in extension region due to -extend %d\n",n,skipcnt,extend);
	fflush(stdout);
      }
    }
  }
  skip_sites(n,skip,Hdel,Hcuts);

  if(DEBUG>=2 && !(Hcuts[n] <= Hcuts[n+1])){
    printf("n=%d:Hcuts[n]=%0.3f,Hcuts[n+1]=%0.3f\n",n,Hcuts[n],Hcuts[n+1]);
    fflush(stdout);
    assert(Hcuts[n] <= Hcuts[n+1]);
  }

  if(VERB>=2){
    printf("reposition():Potential add sites:\n");
    for(int i = 1; i <= n; i++)
      if(Hdel[i] && !skip[i])
	printf("Hcuts[%d]=%0.3f\n",i,Hcuts[i]);
    fflush(stdout);
  }
  if(VERB>=2){
    printf("reposition():Potential add sites:\n");
    for(int m = 0; m < MD; m++){
      int M = MX[m],i;
      for(int J = 1; J <= M; J++)
	if((i = map[m][J]) >= 1 && Hdel[i])
	  printf("%s Hcuts[%d]= %0.3f from map m=%d(id=%lld),J=%d,M=%d\n",skip[i] ? "Skipping" : "Keeping", i,Hcuts[i],m,gmap[pcontig->contig[m].mapid]->id,J,M);
    }
    fflush(stdout);
  }
  if(VERB/* HERE >=2 */){
    printf("reposition completed: cum wall time= %0.6f secs\n",wtime());
    fflush(stdout);
  }
}


int debug_cnt = 0;

/** add/delete/merge sites in consensus. If resize != 0 also try to resize consensus map intervals, by calling SizesEstimate() */
double AddDelete(double LPstart, /**< value of LP for current Y[] (may reflect an outdated map[],mapK[]) */
		 double *TBmapWT, /**< If != 0 : TBmapWT[m] is a the -TB based weight for map m to be applied when summing up the total log(LR+LRbias) value */
		 double *bestLPA,/**< current best per map LP values */
		 double *newLPA,/**< per map LP values (return value) */
		 double *mapWT,
		 int n, double *Hcuts, int *Hdel,/**< complete consensus map */
		 int &N, double *Y,/**< current consensus map */
		 int MD, /**< number of maps */
		 int *MX, double **X, /**< X[m=0..MD-1][j=0..MX[m]+1] : map sites */
		 int lc,/**< If left end of Y is a linear chromosome end */
		 int rc,/**< If right end of Y is a linear chromosome end */
		 int **map, /**< map[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts[0..n+1] of X[m][j], 
					map[MD][j=0..n+1] is index in Y[0..N+1] of Hcuts[j] */
		 int **mapK, /**< mapK[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts[0..n+1] of X[m][j] */ 
		 Csetlimit *limit,
		 int **nmap, /**< nmap[m=0..MD-1][j=0..MX[m]+1] is new index in Y[0..N+1] of X[m][j], 
					 nmap[MD][j=0..N+1] is index in Hcuts[0..n+1] of Y[j] */
		 int **nmapK, /**< nmapK[m=0..M-1][j=0..MX[m]+1] will be new K index offset in Y[0..N+1] of X[m][j]
					  However nmapK[0] == Lij, mapK[MX[m]+1] == Rij (-ve if ends are outliers) */
		 Ccontig *pcontig, /**< pointer to complete contig information for debugging */
		 double &trimfactor, /**< The trimmed mean parameters : smallest value 0 corresponds to normal mean
				       largest value 0.5 corresponds to median */
		 int resize, /**< If 1 resize map instervals using SizesEstimate() */
		 int &MultiMode,
		 int *skip, /**< skip[i=1..n]: > 0 if site Hcuts[i] need not be checked for addition/deletion */
		 int &Lfrozen, int &Rfrozen,/**< refine() args */
		 int merge  /* If 1, try to merge nearby labels, but only if LP improves */
		 )
{
  int failed = 0;
  int mapupdated = 0;
  int origMultiMode = MultiMode;

  double LPend = LPstart;
  double origLPstart = LPstart;

  if(DELTA_RES < 1e-5){
    if(VERB){
      printf("Changing -Mprobeval resolution from %0.6f to 0.00001\n",DELTA_RES);
      fflush(stdout);
    }
    DELTA_RES = 1e-5;
  }

  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
    (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      int lastJ = -1, lasti = -1, lastk = -1;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
	  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	  fflush(stdout);
	  assert(0 <= k && k < i);
	}
	if(lasti >= 0 && !(i-k > lasti)){
	  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	  if(VERB){
	    for(int j = 1; j <= M; j++){
	      int i = map[m][j];
	      if(i < 0)
		continue;
	      int k = mapK[m][j];
	      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	    }
	  }
	  fflush(stdout);
	  assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }
  }

  if(resize){
    MultiMode = 0;

    /* improve initial sizing estimates based on original mapping */
    /* NOTE : the old mapping will have no effect in extension region, hence with (extend && extendonly) it will have no effect on the consensus map at all !*/

    if(VERB>=2){
      printf("Calling SizesEstimate: MultiMode=%d,Lfrozen=%d,Rfrozen=%d\n",MultiMode,Lfrozen,Rfrozen);
      fflush(stdout);
    }

    if(ERRPLOT) rverb = 1;
    LPstart = SizesEstimate(LPstart,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,OldMap,FORCE_RESIZE ? -1 : 0,failed,mapupdated,Lfrozen,Rfrozen);  
    if(VERB){
      printf("Updated Sizes from original mapping: LP=%0.10f->%0.10f,N=%d,trimfactor=%0.2f,failed=%d,mapupdated=%d\n",origLPstart,LPstart,N,trimfactor,failed,mapupdated);
      printf("\t Lfrozen=%d,Rfrozen=%d\n",Lfrozen,Rfrozen);
      fflush(stdout);
    }
    rverb = 0;

    trimfactor = INIT2_TRIM;

    /* update interval sizes of Y & Hcuts based on Viterbi alignments in nmap,nmapK (without MultiMode) */
    int cnt = 0;
    if(!origMultiMode){
      do {  /* update Y,map,mapK using nmap,nmapK */
	origLPstart = LPstart;
	LPstart = SizesEstimate(LPstart,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
	if(VERB){
	  printf("After updating Sizes and mapping: LP=%0.6f->%0.6f (delta= %0.6f),N=%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f,trimfactor=%0.2f(failed=%d,mapupdated=%d)\n",
		 origLPstart,LPstart,LPstart - origLPstart, N,Y[1],Y[N],Y[N+1],trimfactor,failed,mapupdated);
	  printf("\t Lfrozen=%d,Rfrozen=%d\n",Lfrozen,Rfrozen);
	  fflush(stdout);
	}
      } while (!failed && LPstart > origLPstart + 0.1 && ++cnt < 50);
    }

    if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
      (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
      for(int m = 0; m < MD; m++){
	int M = MX[m];

	int lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  int i = map[m][J];
	  if(i < 0)
	    continue;
	  int k = mapK[m][J];
	  if(DEBUG &&  !(0 <= k && k < i)){
	    printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
	  }
	  if(lasti >= 0 && !(i-k > lasti)){
	    printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	    if(VERB){
	      for(int j = 1; j <= M; j++){
		int i = map[m][j];
		if(i < 0)
		  continue;
		int k = mapK[m][j];
		printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
	      }
	    }
	    fflush(stdout);
	    assert(i-k > lasti);
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
	}
      }
    }

    if(origMultiMode){
      MultiMode = 1;

      /* update interval sizes of Y & Hcuts based on Viterbi alignments in nmap,nmapK (with MultiMode) */
      cnt = 0;
      do {  /* update Y,map,mapK using nmap,nmapK */
	origLPstart = LPstart;
	if(DEBUG>=2){
	  /* verify LPstart,bestLPA */
	  score_init(N,Y,MD,MX,X);
	  double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  if(VERB){
	    printf("AddDelete:verifying qLP=%0.10f(LPstart=%0.10f)\n",qLP,LPstart);
	    fflush(stdout);
	  }
	  if(DEBUG){
	    assert(fabs(LPstart-qLP) < 1e-8);
	    for(register int m = 0; m < MD; m++)
	      assert(fabs(bestLPA[m] - newLPA[m]) < 1e-8);
	  }
	}
	if(VERB){
	  printf("Calling SizesEstimate:LPstart=%0.10f (Lfrozen=%d,Rfrozen=%d)\n",LPstart,Lfrozen,Rfrozen);
	  fflush(stdout);
	}
	//	int origOldMap = OldMap;
	if(MultiMode)
	  mapupdated = 0;
	LPstart = SizesEstimate(LPstart,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen);
	if(VERB){
	  if(MultiMode)
	    printf("After updating Sizes and mapping with -MultiMode: LP=%0.6f->%0.6f(delta= %0.6f),N=%d,trimfactor=%0.2f(failed=%d,mapupdated=%d)\n",
		   origLPstart,LPstart,LPstart-origLPstart,N,trimfactor,failed,mapupdated);
	  else
	    printf("After updating Sizes and mapping: LP=%0.6f->%0.6f(delta= %0.6f),N=%d,trimfactor=%0.2f(failed=%d,mapupdated=%d)\n",
		   origLPstart,LPstart,LPstart-origLPstart,N,trimfactor,failed,mapupdated);
	  //	  printf("\t Y[1]=%0.3f,Y[2]=%0.3f,Y[N+1=%d]=%0.3f\n",Y[1],Y[2],N+1,Y[N+1]);
	  printf("\t Lfrozen=%d,Rfrozen=%d\n",Lfrozen,Rfrozen);
	  fflush(stdout);

	  if(DEBUG>=2){
	    /* verify LPstart,bestLPA */
	    score_init(N,Y,MD,MX,X);
	    double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	    if(VERB){
	      printf("AddDelete:verifying qLP=%0.10f(LPstart=%0.10f)\n",qLP,LPstart);
	      //	      printf("\t Y[1]=%0.3f,Y[2]=%0.3f,Y[N+1=%d]=%0.3f\n",Y[1],Y[2],N+1,Y[N+1]);
	      fflush(stdout);
	    }
	    if(DEBUG){
	      assert(fabs(LPstart-qLP) < 1e-8);
	      for(register int m = 0; m < MD; m++)
		assert(fabs(bestLPA[m] - newLPA[m]) < 1e-8);
	    }
	  }
	}

#if 0 // debug code
	if(cnt >= 2)
	  exit(1);
	printf("Repeating SizesEstimate with MultiMode=%d : Repeat cnt=%d\n",MultiMode, cnt+1);
	fflush(stdout);
#else	
	if(cnt >= 4 || (LPstart <= origLPstart + 100.0) || !OldMap)
	  MultiMode = 0;
#endif

	if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	  (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	  for(int m = 0; m < MD; m++){
	    int M = MX[m];

	    int lastJ = -1, lasti = -1, lastk = -1;
	    for(int J = 1; J <= M; J++){
	      int i = map[m][J];
	      if(i < 0)
		continue;
	      int k = mapK[m][J];
	      if(DEBUG &&  !(0 <= k && k < i)){
		printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
		fflush(stdout);
		assert(0 <= k && k < i);
	      }
	      if(lasti >= 0 && !(i-k > lasti)){
		printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
		if(VERB){
		  for(int j = 1; j <= M; j++){
		    int i = map[m][j];
		    if(i < 0)
		      continue;
		    int k = mapK[m][j];
		    printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		  }
		}
		fflush(stdout);
		assert(i-k > lasti);
	      }
	      lasti = i;
	      lastk = k;
	      lastJ = J;
	    }
	  }
	}

      } while (!failed && LPstart > origLPstart + 0.1 && ++cnt < 50 && UPDATEMAP);

      if(mapupdated)// HERE HERE : may be expensive for large contigs during extension refinement (extendonly && Refine >= 3) : consider skipping
	reposition(n,Hcuts,Hdel,N,Y,MD,MX,X,map,mapK,limit,TBmapWT,nmap,skip,Lfrozen,Rfrozen,pcontig);/* re-position missing sites */

      MultiMode = 0;
    }
  }

  if(DEBUG>=2 && !(Hcuts[n] <= Hcuts[n+1])){
    printf("n=%d:Hcuts[n]=%0.3f,Hcuts[n+1]=%0.3f\n",n,Hcuts[n],Hcuts[n+1]);
    fflush(stdout);
    assert(Hcuts[n] <= Hcuts[n+1]);
  }

  int AddDeleteCnt = 0;/* keep track of how many sites were added OR deleted */

  if(Refine >= 2){  /* repeatedly modify Y by flipping one entry in Hdel[1..n] */
    double start = mtime(), wstart = wtime();
    if(VERB){
      printf("Trying to Add/Delete sites(Lfrozen=%d,Rfrozen=%d:%0.3f..%0.3f) LP=%0.6f\n",Lfrozen,Rfrozen,Hcuts[Lfrozen],Hcuts[Rfrozen],LPstart);
      if(VERB>=2){
	register double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	printf("Before switching RANGE_Y:LP=%0.10f -> %0.10f\n",LPstart,qLP);
      }

      fflush(stdout);
    }
    if(1){
      // customize OutlierType=1,outlierLambda=0,RANGE=4 along with DELTA_X,DELTA_Y,RANGE_Y to improve performance/speed of mprobeval() for adding/deleting labels
      int prevDELTA_X = DELTA_X;
      int prevDELTA_Y = DELTA_Y;
      int prevRANGE_Y = RANGE_Y;
      int prevRANGE = RANGE;
      int prevOutlierType = OutlierType;
      double prevOutlierLambda = outlierLambda;
      double prevPoutlier = Poutlier;
      double prevPoutlierEnd = PoutlierEnd;
      double prevLRbias = LRbias;
      double prevSF = SF[0];
      double prevSR = SR[0];

      if(DEBUG && !(RANGE_Y == RANGE_Y1)){
	printf("Before mprobevalwin() RANGE adjustment: RANGE_Y=%d, RANGE=%d, RANGE_Y1=%d, DELTA_X=%d, DELTA_Y=%d, OutlierType=%d,Lambda=%0.3e, Poutlier=%0.ee,PoutlierEnd=%0.2e,SF=%0.3f,SR=%0.5f\n",
	       RANGE_Y, RANGE, RANGE_Y1, DELTA_X, DELTA_Y, OutlierType, outlierLambda,Poutlier,PoutlierEnd,SF[0],SR[0]);
	fflush(stdout);
	assert(RANGE_Y == RANGE_Y1);
      }
      DELTA_X = origDELTA_X;
      DELTA_Y = origDELTA_Y;
      if(RANGE_UPDATE)
	RANGE = origRANGE;/* small value for speed */
      if(outlierLambdaSwitch)
	outlierLambda = outlierLambdaLabel;
      if(OutlierTypeSwitch){
	OutlierType = OutlierTypeLabel;
	if(OUTLIER_TYPE != OutlierType){
	  printf("WARNING:OutlierTypeSwitch not working because OUTLIER_TYPE in RGentigScore.h is a compile time constant of %d\n",OUTLIER_TYPE);
	  fflush(stdout);
	  OutlierType = OUTLIER_TYPE;
	}
      }
      if(PoutlierSwitch)
	Poutlier = PoutlierLabel;
      if(PoutlierEndSwitch)
	PoutlierEnd = PoutlierEndLabel;
      if(LRbiasSwitch)
	LRbias = LRbiasLabel;
      if(MinSFSwitch)
	SF[0] = max(SF[0], MinSFLabel);
      if(MinSRSwitch)
	SR[0] = max(SR[0], MinSRLabel);
      RANGE_Y = RANGE_Y2;
      if(DELTA_LIM > 0) DELTA_X = DELTA_LIM;

      if(RANGE != prevRANGE || RANGE_Y != prevRANGE_Y || DELTA_X != prevDELTA_X || DELTA_Y != prevDELTA_Y || OutlierType != prevOutlierType || outlierLambda != prevOutlierLambda ||
	 Poutlier != prevPoutlier || PoutlierEnd != prevPoutlierEnd || LRbias != prevLRbias || SF[0] != prevSF || SR[0] != prevSR){
	score_init(N,Y,MD,MX,X);
	double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	if(VERB){
	  printf("Switched RANGE=%d to %d,RANGE_Y=%d to %d,DELTA_X=%d to %d,OutlierType=%d to %d,Lambda=%0.2e->%0.2e,outlier=%0.2e->%0.2e,outlierEnd=%0.2e->%0.2e,LRbias=%0.2e->%0.2e,SF=%0.3f->%0.3f,SR=%0.4f->%0.4f before mprobevalwin():LP=%0.10f -> %0.10f\n",
		 prevRANGE, RANGE, prevRANGE_Y, RANGE_Y, prevDELTA_X, DELTA_X, prevOutlierType, OutlierType, prevOutlierLambda, outlierLambda,prevPoutlier,Poutlier,prevPoutlierEnd,PoutlierEnd,prevLRbias,LRbias,prevSF,SF[0],prevSR,SR[0],LPstart,qLP);
	  if(VERB>=2)
	     printf("outlierLambdaLabel=%0.2e,outlierLambdaSize=%0.2e,origOutlierLambda=%0.2e\n",outlierLambdaLabel,outlierLambdaSize,origOutlierLambda);
	  fflush(stdout);
	}
	LPstart = qLP;
      }

      int *Lskip = skip;
      if(!FAST_SKIP){
	Lskip = new int[n+2];/* local copy of skip, which may change without affecting skip[] */
	for(register int i = 0; i <= n+1; i++)
	  Lskip[i] = skip[i];
      }

      int imin = max(1,Lendi);
      int imax = Rendi ? min(Rendi,n) : n;
      if(Rfrozen > 0 && Rfrozen > Lfrozen){
	if(extend >= 2 && extendonly){
	  if(Lfrozen <= imin)
	    imin = max(imin,Rfrozen);
	  if(Rfrozen >= imax)
	    imax = min(imax,Lfrozen);
	  if(EndLen2 < EndLen && imin >= imax){
	    if(Lfrozen <= 0){
	      imax = min(n,Rfrozen + 1);
	      imin = imax-1;
	    } else {
	      imin = max(1,Lfrozen - 1);
	      imax = imin+1;
	    }
	  }
	} else if(extend <= 1) {
	  imin = max(imin, Lfrozen);
	  imax = min(imax, Rfrozen);
	}
      }
      if(VERB>=2 || (DEBUG && !(1 <= imin && imin <= imax && imax <= n))){
	printf("Calling mprobevalwin:n=%d,Lendi=%d,Rendi=%d,Lfrozen=%d,Rfrozen=%d:imin=%d,imax=%d,extend=%d,extendonly=%d\n",n,Lendi,Rendi,Lfrozen,Rfrozen,imin,imax,extend,extendonly);
	fflush(stdout);
	assert(1 <= imin && imin <= imax && imax <= n);
      }

      //      tverb = 1 + stage;// NOTE : applies to first mprobeval() call only

      LPend = mprobevalwin(LPstart,bestLPA,newLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,imin, imax,pcontig,trimfactor,resize,MultiMode,Lskip,Lfrozen,Rfrozen,AddDeleteCnt);
      if(VERB){
	double w = wtime();
	printf("mprobevalwin returned LPend=%0.6f(delta=%0.6f): time= %0.6f, wall= %0.6f(cum= %0.6f)\n",LPend,LPend-LPstart,mtime()-start,w-wstart,w);
	fflush(stdout);
      }

      if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	(void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	for(int m = 0; m < MD; m++){
	  int M = MX[m];

	  int lastJ = -1, lasti = -1, lastk = -1;
	  for(int J = 1; J <= M; J++){
	    int i = map[m][J];
	    if(i < 0)
	      continue;
	    int k = mapK[m][J];
	    if(DEBUG &&  !(0 <= k && k < i)){
	      printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	      fflush(stdout);
	      assert(0 <= k && k < i);
	    }
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	      if(VERB){
		for(int j = 1; j <= M; j++){
		  int i = map[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK[m][j];
		  printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }

      if(!FAST_SKIP)
	delete [] Lskip;

      if(DEBUG){
	double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig);	
	if(VERB/* HERE >=2 */ || fabs(qLP - LPend) > 1e-6){
	  printf("%sAfter mprobevalwin qLP=%0.10f, LPend=%0.10f (err=%0.10f): cum wall time= %0.6f\n",(fabs(qLP-LPend) > 1e-8) ? "WARNING: " : "", qLP,LPend, qLP-LPend, wtime());
	  fflush(stdout);
	  double newsum = 0.0, bestsum = 0.0;
	  for(int m = 0; m < MD; m++){ 
	    newsum += newLPA[m] * TBmapWT[m];
	    bestsum += bestLPA[m] * TBmapWT[m];
	    if(fabs(newLPA[m] - bestLPA[m]) * TBmapWT[m] > 1e-10) {
	      printf("m=%d:newLPA[m]= %0.10f, bestLPA[m]= %0.10f (delta= %0.10f), TBmapWT= %0.10f: cum: newLPA= %0.10f, bestLPA= %0.10f (delta= %0.10f)\n",
		     m,newLPA[m],bestLPA[m], newLPA[m]-bestLPA[m], TBmapWT[m], newsum,bestsum,newsum-bestsum);
	      fflush(stdout);
	    }
	  }
	  printf("cumulative newLPA= %0.10f, bestLPA= %0.10f (delta= %0.10f)\n", newsum,bestsum,newsum-bestsum);
	  newsum -= N* Site_Pen;
	  bestsum -= N* Site_Pen;
	  printf("Final newLPA= %0.10f, bestLPA= %0.10f (delta= %0.10f), Site_Pen= %0.10f\n", newsum,bestsum,newsum-bestsum,Site_Pen);
	  fflush(stdout);

	  if(DEBUG>=1+RELEASE) assert(fabs(qLP - LPend) <= 1e-4);
	} 

	LPend = qLP;
	for(int m = 0; m < MD; m++)
	  bestLPA[m] = newLPA[m];
      }

      if(RANGE != prevRANGE || RANGE_Y != prevRANGE_Y || DELTA_X != prevDELTA_X || DELTA_Y != prevDELTA_Y || OutlierType != prevOutlierType || outlierLambda != prevOutlierLambda ||
	 Poutlier != prevPoutlier || PoutlierEnd != prevPoutlierEnd || LRbias != prevLRbias || SF[0] != prevSF || SR[0] != prevSR){
	RANGE = prevRANGE;
	RANGE_Y = prevRANGE_Y;
	DELTA_X = prevDELTA_X;
	DELTA_Y = prevDELTA_Y;
	OutlierType = prevOutlierType;
	outlierLambda = prevOutlierLambda;
	Poutlier = prevPoutlier;
	PoutlierEnd = prevPoutlierEnd;
	LRbias = prevLRbias;
	SF[0] = prevSF;
	SR[0] = prevSR;

	score_init(N,Y,MD,MX,X);
	debug_cnt++;
	//	tverb = (debug_cnt >= 4) ? 2 : 1;

	double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);	

	tverb = 0;
	if(VERB/* >=2 */){
	  printf("Restored RANGE=%d,RANGE_Y=%d,DELTA_X=%d,DELTA_Y=%d,OutlierType=%d,Lambda=%0.2e,outlier=%0.2e,outlierEnd=%0.2e,LRbias=%0.2e,SF=%0.3f,SR=%0.5f:LP=%0.8f -> %0.8f (dcnt=%d, cum wall= %0.6f secs)\n",
		 RANGE,RANGE_Y,DELTA_X,DELTA_Y,OutlierType,outlierLambda,Poutlier,PoutlierEnd,LRbias,SF[0],SR[0],LPend,qLP,debug_cnt,wtime());
	  /*	  for(register int i = 1; i <= n;i++)
	    if(!Hdel[i])
	    printf("i=%d:Hcuts[i]=%0.3f,Hdel[i]=%d\n",i,Hcuts[i],Hdel[i]);*/
	  fflush(stdout);
	}
	LPend = qLP;
      }
    }

    LPstart = LPend;

    if(VERB){
      if(!resize)
	printf("After adding/deleting %d sites (without resizing Y) final LP=%0.6f,N=%d (cum wall= %0.6f)\n",AddDeleteCnt,LPend,N, wtime());
      else
	printf("After adding/deleting %d sites final LP=%0.6f,N=%d (cum wall= %0.6f)\n",AddDeleteCnt,LPend,N,wtime());
      fflush(stdout);
    }
  }    /* if(Refine >= 2) */

  if(Refine && resize){
    MultiMode = 0;

    double origLPend;
    int cnt = 0;
    if(AddDeleteCnt > 0){
      if(!origMultiMode){
	do {  /* update Y,map,mapK using nmap,nmapK : without MultiMode */
	  origLPend = LPend;
	  LPend = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen); 
	  if(VERB){
	    printf("After updating Sizes and mapping: LPend = %0.6f -> %0.6f(delta= %0.6f),N=%d (failed=%d,mapupdated=%d)\n", origLPend, LPend, LPend - origLPend, N, failed,mapupdated);
	    fflush(stdout);
	  }
	} while (!failed && LPend > origLPend + 0.001 && ++cnt < 50);
      }

      if(origMultiMode){
	MultiMode = 1;

	cnt = 0;
	do {  /* update Y,map,mapK using nmap,nmapK : with MultiMode */
	  origLPend = LPend;
	  LPend = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen); 
	  if(VERB){
	    if(MultiMode)
	      printf("After updating Sizes and mapping with -MultiMode: LPend = %0.6f -> %0.6f (delta= %0.6f),N=%d (failed=%d,mapupdated=%d)\n", origLPend, LPend, LPend-origLPend,N, failed, mapupdated);
	    else
	      printf("After updating Sizes and mapping: LPend = %0.6f -> %0.6f (delta= %0.6f), N=%d (failed=%d)\n", origLPend, LPend, LPend-origLPend, N, failed);
	    fflush(stdout);
	  }

	  // Unless SLOWMULTIMODE, just reset MultiMode to 0 : multiple iterations of SizesEstimate() with MultiMode=1 is not cost effective
	  if(cnt >= 4 || (LPend <= origLPend + 100.0) || !OldMap)
	    MultiMode = 0;

	  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	    (void) setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	    for(int m = 0; m < MD; m++){
	      int M = MX[m];

	      int lastJ = -1, lasti = -1, lastk = -1;
	      for(int J = 1; J <= M; J++){
		int i = map[m][J];
		if(i < 0)
		  continue;
		int k = mapK[m][J];
		if(DEBUG &&  !(0 <= k && k < i)){
		  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
		  fflush(stdout);
		  assert(0 <= k && k < i);
		}
		if(lasti >= 0 && !(i-k > lasti)){
		  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
		  if(VERB){
		    for(int j = 1; j <= M; j++){
		      int i = map[m][j];
		      if(i < 0)
			continue;
		      int k = mapK[m][j];
		      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		    }
		  }
		  fflush(stdout);
		  assert(i-k > lasti);
		}
		lasti = i;
		lastk = k;
		lastJ = J;
	      }
	    }
	  }

	} while (!failed && LPend > origLPend + 0.1 && ++cnt < 50 && UPDATEMAP);

	MultiMode = 0;
      }

      if(VERB){
	printf("After Optimizing Sizes, final LP=%0.6f,N=%d\n",LPend,N);
	fflush(stdout);
      }
    }
    if(DEBUG>=2){
      if(rverb){
	printf("Repeating qprobeval after SizesEstimate\n");
	fflush(stdout);
      }
      double nLP1 = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
      if(!(fabs(nLP1 - LPend) < 2e-9)){
	printf("Repeated qprobeval = %0.6f (was %0.6f),N=%d,Y[N+1]=%0.3f\n",nLP1,LPend,N,Y[N+1]);
	fflush(stdout);
	assert(fabs(nLP1 - LPend) < 2e-9);
      }

      int oldN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      if(DEBUG) assert(oldN == N);
      score_init(N,Y,MD,MX,X);
      double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
      if(!(fabs(nLP-LPend) < 1e-8)){
	printf("WARNING:Repeated qprobeval = %0.6f -> %0.6f (was %0.6f),N=%d,Y[N+1]=%0.3f\n",nLP1, nLP,LPend,N,Y[N+1]);
	fflush(stdout);
	assert(fabs(nLP-LPend) < 1e-6);
      }
    }
  } /* if(Refine && resize) */

  if(HEAP_MINIMIZE){
    delete heap;
    heap = new lightweight_heap(0,0);      

    getmem(VmSize,VmRSS,VmSwap);
    if(VERB){
      printf("VmSize=%lld,VmRSS=%lld, VmSwap=%lld\n",VmSize,VmRSS,VmSwap);
      fflush(stdout);
    }
  }

  if(Refine >= 2 && (resize || (MERGE_NORESIZE && AddDeleteCnt > 0))){
    double origLPend = LPend;
    double start = mtime(), wstart = wtime();
    double maxKB = max(rres * 0.500, (res[0] + resSD[0]) * PixelLen);// WAS (res[0] + resSD[0] * SDrange) * PixelLen
    double lowKB = rres*0.500 * 0.5;
    if(SITEMERGE){
      if(VERB){
 	printf("Trying to Merge sites: LP=%0.6f, minKB=%0.3f,lowKB=%0.3f,maxKB=%0.3f,N=%d,Lfrozen=%d(%0.4f),Rfrozen=%d(%0.4f),Lendi=%d,Rendi=%d,n=%d\n",
	       LPend,minKB,lowKB,maxKB,N,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[Lfrozen],Lendi,Rendi,n);
        if(VERB>=2)
           dumpmemmap();
	fflush(stdout);
      }
      if(VERB>=2){/* list sites closer than 10 bp ! */
	N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	for(int I = 1; I < N; I++)
	  if(Y[I+1]-Y[I] <= 0.01)
	    printf("  k=%d:Y[k]=%0.6f,Y[k+1]=%0.6f,delta=%0.6f (!)\n",I,Y[I],Y[I+1],Y[I+1]-Y[I]);
	fflush(stdout);
      }

      double *origHcuts = new double[n+2];
      int *origHdel = new int[n+2];
      for(int i=0;i<=n+1;i++)
	origHcuts[i] = Hcuts[i];
      for(int i=0;i<=n+1;i++)
	origHdel[i] = Hdel[i];

      int **orignmap = 0;
      int **orignmapK = 0;
      double *bestLPAorig = 0;
      int *orignmap_pool = 0;
      if(MERGE_FAST){      /* Allocate memory to backup bestLPA[] & nmap[],nmapK[] in case we need to backtrack */
	orignmap = new int*[MD];
	orignmapK = new int*[MD];
	bestLPAorig = new double[MD];
	size_t orignmap_pool_size = 0;
	for(register int m = 0; m < MD; m++){
	  orignmap_pool_size += MX[m] + 2;
	  orignmap_pool_size += MX[m] + 2;
	}
	orignmap_pool = new int[orignmap_pool_size];
	size_t offset = 0;
	for(int m = 0; m < MD; m++){
	  orignmap[m] = &orignmap_pool[offset]; offset += MX[m]+2;
	  orignmapK[m] = &orignmap_pool[offset]; offset += MX[m]+2;
	}
      }

      N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      if(DEBUG>=2){
	if(VERB>=2){
	  printf("Before Trying to Merge sites: saving bestLPA[],nmap[],nmapK[]\n");
	  fflush(stdout);
	}
	for(register int m = 0; m < MD; m++){
	  bestLPAorig[m] = bestLPA[m];
	  for(register int j = 0; j <= MX[m]+1; j++){
	    orignmap[m][j] = nmap[m][j];
	    orignmapK[m][j] = nmapK[m][j];
	  }
	}

	score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	register double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig); 	
	if(fabs(qLP - LPend) > 1e-8){
	  printf("WARNING:Before Trying to Merge sites: qLP=%0.10f, LPend=%0.10f (err=%0.10f)\n",qLP, LPend, qLP-LPend);
	  fflush(stdout);
	  assert(fabs(qLP - LPend) <= 1e-6);
	}
	for(int m = 0; m < MD; m++){
	  if(fabs(newLPA[m]-bestLPA[m]) > 1e-8){
	    printf("WARNING:Before Trying to Merge sites: m=%d:newLPA[m]=%0.10f, bestLPA[m]=%0.10f (err=%0.10f)\n", m, newLPA[m],bestLPA[m],newLPA[m]-bestLPA[m]);
	    fflush(stdout);
	    assert(fabs(newLPA[m]-bestLPA[m]) <= 1e-6);
	  }
	  for(int j = 0; j <= MX[m]+1; j++){
	    if(!(nmap[m][j] == orignmap[m][j])){
	      printf("Before Trying to Merge sites:m=%d,j=%d:nmap[m][j]=%d,nmapK[m][j]=%d:orignmap[m][j]=%d,orignmapK[m][j]=%d\n",
		     m,j,nmap[m][j],nmapK[m][j],orignmap[m][j],orignmapK[m][j]);
	      fflush(stdout);
	      assert(nmap[m][j] == orignmap[m][j]);
	    }
	    if(!(nmapK[m][j] == orignmapK[m][j])){
	      printf("Before Trying to Merge sites:m=%d,j=%d:nmap[m][j]=%d,nmapK[m][j]=%d:orignmap[m][j]=%d,orignmapK[m][j]=%d\n",
		     m,j,nmap[m][j],nmapK[m][j],orignmap[m][j],orignmapK[m][j]);
	      fflush(stdout);
	      assert(nmapK[m][j] == orignmapK[m][j]);
	    }
	  }
	}
      }

      if(MERGE_FAST==1){      /* backup bestLPA[] & nmap[],nmapK[] in case we need to backtrack */
	if(VERB>=2){
	  printf("Before Trying to Merge sites: saving bestLPA[],nmap[],nmapK[]\n");
	  fflush(stdout);
	}
	for(register int m = 0; m < MD; m++){
	  bestLPAorig[m] = bestLPA[m];
	  for(register int j = 0; j <= MX[m]+1; j++){
	    orignmap[m][j] = nmap[m][j];
	    orignmapK[m][j] = nmapK[m][j];
	  }
	}
      }

      if(VERB>=2){
         printf("After allocating & initializing orignmap[] memory:\n");
         dumpmemmap();
      }

      int progress = 0;

      if(DEBUG>=2){  /* make sure no real cuts are closer than minKB */
	for(int k = 1; k < N; k++)
	  if(DEBUG && !(Y[k+1]-Y[k] >= minKB - 2e-9)){
	    printf("Before Merging:k=%d:Y[k]=%0.6f,Y[k+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
		   k,Y[k],Y[k+1], Y[k+1]-Y[k], minKB);
	    fflush(stdout);
	    assert(Y[k+1]-Y[k] >= minKB - 2e-9);
	  }
      }

      double mt, wt;
      if(TIME_VERBOSE){
	mt = mtime();
	wt = wtime();
      }

      int cnt = 0;

      for(int I=1;I < N; I++){
	int iL = nmap[MD][I];
	int iR = nmap[MD][I+1];
 	if(extend>=2 && extendonly && Rfrozen > Lfrozen && iL >= Lfrozen && iR <= Rfrozen)
 	  continue;
	if(extend>=2 /* WAS extend >= 2 && extendonly */ && Rendi > 0 && (iR <= Lendi || iL >= Rendi)){
	  if(DEBUG) assert(Rendi > Lendi);
	  continue;
	}
 	if(extend<=1 && Rfrozen > 0 && (iR <= Lfrozen  || iL >= Rfrozen)){
	  if(DEBUG) assert(Rfrozen > Lfrozen);
	  continue;
	}
	if(iL >= 1 && iR >= 1 && !Hdel[iL] && !Hdel[iR] && lowKB <= Hcuts[iR]-Hcuts[iL] && Hcuts[iR]-Hcuts[iL] < maxKB){
	  if(VERB>=3 && iL==12026 && iR==12027){
	    printf("Before trying to merging Hcuts[%d]=%0.4f and Hcuts[%d]=%0.4f into single site(I=%d):\n",iL,origHcuts[iL],iR,origHcuts[iR],I);
	    fflush(stdout);
	    int newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	    score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	    rverb = 1;
	    double LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,newLPA,mapWT,bestLPA,origHcuts[iL],origHcuts[iR],0,0,pcontig); 
	    //	    rverb = 0;
	    printf("\t original LP=%0.10f (err=%0.10f), N=%d\n", LPnew, LPnew-LPend, newN);
	    fflush(stdout);
	  }

	  for(int i = iL; i < iR; i++)
	    Hcuts[i] = 0.5*(Hcuts[i] + Hcuts[iR]);
	  Hdel[iR] = 1;

	  if(VERB>=2){
	    printf("Try merging Hcuts[%d]=%0.4f,Hcuts[%d]=%0.4f into single site at %0.4f (I=%d,N=%d):",iL,origHcuts[iL],iR,origHcuts[iR],Hcuts[iL],I,N);
	    fflush(stdout);
	  }
	  int newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	  if(DEBUG>=2){  /* make sure no real cuts are closer than minKB */
	    for(register int k = 1; k < newN; k++)
	      if(DEBUG && !(Y[k+1]-Y[k] >= minKB - 2e-9)){
		printf("\nWhile Merging:k=%d:Y[k]=%0.6f,Y[k+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
		       k,Y[k],Y[k+1], Y[k+1]-Y[k], minKB);
		for(register int i = 1; i <= n; i++)
		  if(!Hdel[i])
		    printf("i=%d:Hcuts[i]=%0.8f -> %0.8f\n",i,origHcuts[i], Hcuts[i]);
		for(register int i = 1; i <= N; i++)
		  printf("I=%d:Y[I]=%0.8f\n",i,Y[i]);
		fflush(stdout);
		assert(Y[k+1]-Y[k] >= minKB - 2e-9);
	      }
	  }       
	  score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */

	  /*	  if(iL==926 && iR==927){
	    printf("\n");
	    fflush(stdout);
	    rverb = 1;
	    }*/

	  double LPnew;
	  //          verb_numthreads = 1;

	  if(MERGE_FAST)
	    LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,newLPA,mapWT,bestLPA,origHcuts[iL],origHcuts[iR],0,0,pcontig);
	  else
	    LPnew = qprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
	  // rverb = 0;

	  cnt++;

          if(VERB>=2 && origHcuts[iR]-origHcuts[iL] <= 0.100){
            printf("Trying to merge Hcuts[%d]=%0.4f,Hcuts[%d]=%0.4f (gap= %0.5f):LP=%0.10f -> %0.10f (delta= %0.10f), N=%d %c\n", 
		   iL, origHcuts[iL],iR,origHcuts[iR],origHcuts[iR]-origHcuts[iL],LPend, LPnew, LPnew-LPend, newN, LPnew > LPend + 2e-9 ? '!' : ' ');
            fflush(stdout);
	    //	    dumpmemmap();
          }
	  //	  if(rverb) exit(1);

	  if(DEBUG) assert(newN == N-1);
	  
	  if(VERB>=2){
	    //	    double qLP = qprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
	    //	    printf("LP=%0.10f -> %0.10f (qLP=%0.10f), N=%d %c\n", LPend, LPnew, qLP, newN, LPnew > LPend + 2e-9 ? '!' : ' ');
	    printf("LP=%0.10f -> %0.10f, N=%d %c\n", LPend, LPnew, newN, LPnew > LPend + 2e-9 ? '!' : ' ');
	    fflush(stdout);
	  }

	  if(LPnew > LPend + 2.0 * LP_MINDELTA){
	    if(VERB){
	      if(TIME_VERBOSE){
		double mt1 = mtime(), wt1 = wtime();
		printf("Merging Hcuts[%d]=%0.4f,Hcuts[%d]=%0.4f into %0.4f (gap= %0.5f): LP = %0.9f -> %0.9f,N=%d,qcnt=%d: CPU time= %0.6f, wall= %0.6f (cum wall time= %0.6f)\n",
		       iL,origHcuts[iL],iR,origHcuts[iR],Hcuts[iL], origHcuts[iR]-origHcuts[iL],LPend, LPnew, newN,cnt,mt1-mt,wt1-wt,wt1);
		mt = mt1;
		wt = wt1;
	      } else
		printf("Merging Hcuts[%d]=%0.4f,Hcuts[%d]=%0.4f into %0.4f (gap= %0.5f): LP = %0.9f -> %0.9f,N=%d,qcnt=%d\n",
		       iL,origHcuts[iL],iR,origHcuts[iR],Hcuts[iL], origHcuts[iR] - origHcuts[iL], LPend, LPnew, newN,cnt);
	      fflush(stdout);

              if(VERB>=2)
                dumpmemmap();
	    }

	    double LP = LPnew;
	    if(MERGE_FAST){ 
	      /* update bestLPA[] && nmap[],nmapK[] */
	      if(MERGE_FAST<=1)
		LP = qprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
	      else {
		LP = qprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,bestLPA,Hcuts[iL],Hcuts[iR],0,0,pcontig); 
		memcpy(bestLPA, newLPA, MD * sizeof(double));
	      }
	      if(MERGE_FAST <= 1 && LP <= LPend + 1e-9){
		if(VERB){
		  printf("WARNING: After Merging cuts LP = %0.9f -> %0.9f: consider increasing Ymin..Ymax range for merging qprobeval() call\n",LPnew,LP);
		  if(VERB>=2)
		    printf("    Restoring bestLPA[],nmap[],nmapK[], LPnew=%0.9f to LPend=%0.9f\n",LPnew,LPend);
		  fflush(stdout);
		}
		/* back off the site Merge */
		LP = LPend;
		/* restore bestLPA[] & nmap[],nmapK[] */
		for(register int m = 0; m < MD; m++){
		  bestLPA[m] = bestLPAorig[m];
		  for(register int j = 0; j <= MX[m]+1; j++){
		    nmap[m][j] = orignmap[m][j];
		    nmapK[m][j] = orignmapK[m][j];
		  }
		}
	      }
	    }/* MERGE_FAST */
	    if(VERB>=2){
	      if(MERGE_FAST <= 1)
		printf("Full LP=%0.9f, qLP= %0.10f (err= %0.10f) : I=%d, cum wall time= %0.6f secs\n",LP, LPnew, LPnew - LP, I, wtime());
	      else
		printf("qprobeval w/ nmap: LP=%0.9f, qLP= %0.10f (err= %0.10f) : I=%d, cum wall time= %0.6f secs\n",LP, LPnew, LPnew - LP, I, wtime());
	      fflush(stdout);
	    }
	    LPnew = LP;
	  }

	  if(LPnew > LPend + 2.0 * LP_MINDELTA){/* confirm changes to Hcuts[],Hdel[] */
	    if(MERGE_FAST <= 1){/* update backups of bestLPA[] & nmap[],nmapK[] */
	      if(VERB>=2){
		printf("saving bestLPA[],nmap[],nmapK[] for new Hcuts[],Hdel[]: LPnew=%0.9f,LPend=%0.9f->LPnew\n",LPnew,LPend);
		fflush(stdout);
	      }
	      for(int m = 0; m < MD; m++){
		bestLPAorig[m] = bestLPA[m];
		for(int j = 0; j <= MX[m]+1; j++){
		  orignmap[m][j] = nmap[m][j];
		  orignmapK[m][j] = nmapK[m][j];
		}
	      }
	    }//MERGE_FAST

	    progress = 1;

	    N = newN;

	    LPend = LPnew;

	    for(register int i = 0; i <= n+1; i++)
	      origHcuts[i] = Hcuts[i];

	    --I;/* try merging newly merged site with next site (if possible) */
	    
	  } else {/* undo changes to Hcuts[],Hdel[] */
	    Hdel[iR] = 0;
	    for(register int i = 0; i <= n+1; i++)
	      Hcuts[i] = origHcuts[i];
	    int oldN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* need restored value of nmap[MD][0..N+1] at top of loop */
	    if(DEBUG) assert(oldN == N);
	    if(DEBUG>=2){
	      score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	      double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,newLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
	      if(nLP < LPend - 1e-8){
		printf("WARNING:After undoing merge, LP=%0.10f (LPend = %0.10f),N=%d\n",nLP,LPend,N);
		fflush(stdout);
	      }
	      for(int m = 0; m < MD; m++){
		if(fabs(newLPA[m]-bestLPA[m]) >= 1e-8){
		  printf("WARNING: After undoing merge:m=%d,newLPA[m]=%0.10f,bestLPAorig[m]=%0.10f,bestLPA[m]=%0.10f\n",m,newLPA[m],bestLPAorig[m],bestLPA[m]);
		  fflush(stdout);
		  assert(fabs(newLPA[m]-bestLPAorig[m]) < 1e-6);
		}
		for(int j = 0; j <= MX[m]+1; j++){
		  if(!(nmap[m][j] == orignmap[m][j])){
		    printf("After undoing merge:m=%d,j=%d:nmap[m][j]=%d,nmapK[m][j]=%d:orignmap[m][j]=%d,orignmapK[m][j]=%d\n",
			   m,j,nmap[m][j],nmapK[m][j],orignmap[m][j],orignmapK[m][j]);
		    fflush(stdout);
		    assert(nmap[m][j] == orignmap[m][j]);
		  }
		  if(!(nmapK[m][j] == orignmapK[m][j])){
		    printf("After undoing merge:m=%d,j=%d:nmap[m][j]=%d,nmapK[m][j]=%d:orignmap[m][j]=%d,orignmapK[m][j]=%d\n",
			   m,j,nmap[m][j],nmapK[m][j],orignmap[m][j],orignmapK[m][j]);
		    fflush(stdout);
		    assert(nmapK[m][j] == orignmapK[m][j]);
		  }
		}
	      }
	      assert(nLP >= LPend - 1e-6);
	    }
	  }
	}
      } /* loop over sites I to merge with I+1 */

      N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */

      if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	for(int m = 0; m < MD; m++){
	  int M = MX[m];

	  int lastJ = -1, lasti = -1, lastk = -1;
	  for(int J = 1; J <= M; J++){
	    int i = map[m][J];
	    if(i < 0)
	      continue;
	    int k = mapK[m][J];
	    if(DEBUG &&  !(0 <= k && k < i)){
	      printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	      fflush(stdout);
	      assert(0 <= k && k < i);
	    }
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	      if(VERB){
		for(int j = 1; j <= M; j++){
		  int i = map[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK[m][j];
		  printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }

      if(DEBUG){  /* make sure no real cuts are closer than minKB */
	for(register int k = 1; k < N; k++)
	  if(DEBUG && !(Y[k+1]-Y[k] >= minKB - 2e-9)){
	    printf("After Merging:N=%d,k=%d:Y[k]=%0.6f,Y[k+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
		   N,k,Y[k],Y[k+1], Y[k+1]-Y[k], minKB);
	    fflush(stdout);
	    assert(Y[k+1]-Y[k] >= minKB - 2e-9);
	  }
      }
      if(VERB>=2){/* list sites closer than 10 bp ! */
	for(int I = 1; I < N; I++)
	  if(Y[I+1]-Y[I] <= 0.01)
	    printf("  k=%d:Y[k]=%0.6f,Y[k+1]=%0.6f,delta=%0.6f (!)\n",I,Y[I],Y[I+1],Y[I+1]-Y[I]);
	fflush(stdout);
      }
      score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
      double nLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
      if(VERB){
	if(resize)
	  printf("After merging sites, final LP=%0.6f(delta=%0.6f),N=%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f:time=%0.6f,wall time=%0.6f\n",
		 LPend,LPend-origLPend,N,Y[1],Y[N],Y[N+1],mtime()-start,wtime()-wstart);
	else
	  printf("After merging sites (without resizing Y) final LP=%0.6f(delta=%0.6f),N=%d,Y[1]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f,time=%0.6f,wall time=%0.6f\n",
		 LPend,LPend-origLPend,N,Y[1],Y[N],Y[N+1],mtime()-start,wtime()-wstart);
	fflush(stdout);
      }
      
      if(DEBUG && !(nLP >= LPend - 2e-8)){
	printf("WARNING: failed to restore LP after terminating site merging: LPend=%0.10f,nLP=%0.10f\n",LPend,nLP);
	if(VERB>=2)
	  for(register int i=0;i <= n+1; i++)
	    printf("i=%d:Hcuts[i]=%0.3f(orig=%0.3f),Hdel[i]=%d(orig=%d)\n",i,Hcuts[i],origHcuts[i],Hdel[i],origHdel[i]);
	fflush(stdout);
	if(!progress){/* try to recover from error */
	  for(register int i = 0; i <= n+1; i++){
	    Hcuts[i] = origHcuts[i];
	    Hdel[i] = origHdel[i];
	  }
	  N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	  score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	  double nnLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig); 
	  printf("Reverting to original map since no sites were merged: nnLP=%0.10f\n",nnLP);
	  fflush(stdout);
	  if(!(nnLP >= LPend - 2e-8)){
	    printf("Failed again (ignoring for now)\n");
	    fflush(stdout);
	    //	      assert(nnLP >= LPend - 2e-8);
	  }
	} else {
	  printf("Ignoring error for now\n");
	  fflush(stdout);
	  // assert(nLP >= LPend - 2e-8);
	}
      }
      if(MERGE_FAST){
	delete [] orignmap_pool;
	delete [] bestLPAorig;
	delete [] orignmapK;
	delete [] orignmap;
      }
      delete [] origHdel;
      delete [] origHcuts;
      if(VERB>=2)
	dumpmemmap();
      
      if(VERB>=2 && stage <= 0){
	stage = 1;
	printf("stage = 1\n");
	fflush(stdout);
      }

    }/* if(SITEMERGE) */

    if(resize && LPend > origLPend + LP_MINDELTA) {
      int cnt = 0;
      if(!origMultiMode){
	do { /* update Y,map,mapK using map,nmapK : without MultiMode */
	  origLPend = LPend;
	  LPend = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen); 
	  if(VERB){
	    printf("After updating Sizes and mapping: LP=%0.6f->%0.6f(delta=%0.6f),N=%d,trimfactor=%0.2f(failed=%d,mapupdated=%d)\n",origLPend,LPend,LPend-origLPend,N,trimfactor,failed,mapupdated);
	    fflush(stdout);
	  }
	} while (!failed && LPend > origLPend + 0.001 && ++cnt < 50);
      }
      
      if(origMultiMode){/* apply multimodal optimization one last time */
	MultiMode = 1;

	cnt = 0;
	do { /* update Y,map,mapK using map,nmapK */
	  origLPend = LPend;
	  LPend = SizesEstimate(LPend,TBmapWT,bestLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,max(0,Lendi),Rendi ? min(Rendi,n+1) : n+1,pcontig,trimfactor,0,0,failed,mapupdated,Lfrozen,Rfrozen); 
	  if(VERB){
	    if(MultiMode)
	      printf("After updating Sizes and mapping with -MultiMode: LP=%0.6f->%0.6f(delta=%0.6f),N=%d,trimfactor=%0.2f(failed=%d,mapupdated=%d)\n",
		     origLPend,LPend,LPend-origLPend,N,trimfactor,failed,mapupdated);
	    else
	      printf("After updating Sizes and mapping: LP=%0.6f->%0.6f(delta=%0.6f),N=%d,trimfactor=%0.2f(failed=%d)\n",origLPend,LPend,LPend-origLPend,N,trimfactor,failed);
	    fflush(stdout);
	  }
	  if(cnt >= 4 || (LPend <= origLPend + 100.0) || !OldMap)
	    MultiMode = 0;

	  if(DEBUG>=2){	/* check map[m][J],mapK[m][J] for consistency */
	    N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
	    for(int m = 0; m < MD; m++){
	      int M = MX[m];

	      int lastJ = -1, lasti = -1, lastk = -1;
	      for(int J = 1; J <= M; J++){
		int i = map[m][J];
		if(i < 0)
		  continue;
		int k = mapK[m][J];
		if(DEBUG &&  !(0 <= k && k < i)){
		  printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
		  fflush(stdout);
		  assert(0 <= k && k < i);
		}
		if(lasti >= 0 && !(i-k > lasti)){
		  printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
		  if(VERB){
		    for(int j = 1; j <= M; j++){
		      int i = map[m][j];
		      if(i < 0)
			continue;
		      int k = mapK[m][j];
		      printf("\t j=%d:map[m][j]=i=%d,mapK[m][j]=%d,map[MD][i]=%d\n",j,i,k,map[MD][i]);
		    }
		  }
		  fflush(stdout);
		  assert(i-k > lasti);
		}
		lasti = i;
		lastk = k;
		lastJ = J;
	      }
	    }
	  }

	} while (!failed && LPend > origLPend + 0.1 && ++cnt < 50 && UPDATEMAP);
	
	MultiMode = 0;
      }/* origMultiMode */

      if(VERB>=2){/* list sites closer than 10 bp ! */
	N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	for(int I = 1; I < N; I++)
	  if(Y[I+1]-Y[I] <= 0.01)
	    printf("  k=%d:Y[k]=%0.6f,Y[k+1]=%0.6f,delta=%0.6f (!)\n",I,Y[I],Y[I+1],Y[I+1]-Y[I]);
	fflush(stdout);
      }
    } /* resize */
  }/* if(Refine >=2) */
    
  MultiMode = origMultiMode;

  return LPend;
}

double mprobevalwin(double LPstart, /**< value of LP for current Y[] (may reflect an outdated map[],mapK[]) */
		    double *bestLPA,/**< current best per map LP values (will be updated) */
		    double *newLPA,/**< per map LP values (scratch value, should match bestLPA on return) */
		    double *mapWT,
		    int n, double *Hcuts, int *Hdel,/**< complete consensus map */
		    int &N, double *Y,/**< current consensus map */
		    int MD, /**< number of maps */
		    int *MX, double **X, /**< X[m=0..MD-1][j=0..MX[m]+1] : map sites */
		    int lc,/**< If left end of Y is a linear chromosome end */
		    int rc,/**< If right end of Y is a linear chromosome end */
		    int **map, /**< map[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts[0..n+1] of X[m][j], 
					   map[MD][j=0..n+1] is index in Y[0..N+1] of Hcuts[j] */
		    int **mapK, /**< mapK[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts[0..n+1] of X[m][j] */ 
		    Csetlimit *limit,
		    int **nmap, /**< nmap[m=0..MD-1][j=0..MX[m]+1] is new index in Y[0..N+1] of X[m][j], 
					    nmap[MD][j=0..N+1] is index in Hcuts[0..n+1] of Y[j] */
		    int **nmapK, /**< nmapK[m=0..M-1][j=0..MX[m]+1] will be new K index offset in Y[0..N+1] of X[m][j]
					     However nmapK[0] == Lij, mapK[MX[m]+1] == Rij (-ve if ends are outliers) */
		    double *TBmapWT, /**< If != 0 : TBmapWT[m] is a the -TB based weight for map m to be applied when summing up the total log(LR+LRbias) value */
		    int imin, int imax, /**< Only interested in changes in the region Hcuts[imin] .. Hcuts[imax] (relies on valid bestLPA) */
		    Ccontig *pcontig, /**< pointer to complete contig information for debugging */
		    double &trimfactor, /**< The trimmed mean parameters : smallest value 0 corresponds to normal mean
					   largest value 0.5 corresponds to median */
		    int resize, /**< If != 0 :  resize map intervals using SizesEstimate() */
		    int &MultiMode, /**< Only used if resize != 0 */
		    int *skip, /**< skip[i=1..n]: > 0 if site Hcuts[i] need not be checked for addition/deletion */
		    int Lfrozen, int Rfrozen, /**< refine() args */
		    int &AddDeleteCnt
		    )
{
  if(DEBUG>=2 && !(Hcuts[imax] >= Hcuts[imin] && Hcuts[imax] <= Hcuts[n+1])){
    printf("imin=%d,imax=%d,n=%d:Hcuts[imin]=%0.3f,Hcuts[imax]=%0.3f,Hcuts[n+1]=%0.3f\n",imin,imax,n,Hcuts[imin],Hcuts[imax],Hcuts[n+1]);
    fflush(stdout);
    assert(Hcuts[imax] >= Hcuts[imin] && Hcuts[imax] <= Hcuts[n+1]);
  }

  if(VERB>=2){
    printf("mprobevalwin:n=%d,Hcuts[n+1]=%0.3f,imin=%d(%0.3f),imax=%d(%0.3f),Lfrozen=%d(%0.3f),Rfrozen=%d(%0.3f)\n",
	   n,Hcuts[n+1],imin,Hcuts[imin],imax,Hcuts[imax], Lfrozen, Hcuts[Lfrozen], Rfrozen, Hcuts[Rfrozen]);
    fflush(stdout);
  }

  int origtverb = tverb;
  tverb = 0;

  int addcnt = 0;
  double *addloc = new double[4*(n+1) + 2 * MD];
  double *LPdel = &addloc[n+1];
  double *LPadd = &addloc[2*(n+1)];
  double *LPsite = &addloc[3*(n+1)];
  double *qLPA = &addloc[4*(n+1)];
  double *qLPA2 = &addloc[4*(n+1) + MD];
  int *addid = new int[4*(n+1)];
  int *changes = &addid[n+1];
  int *splitL = &addid[2*(n+1)];
  int *splitR = &addid[3*(n+1)];

  if(DEBUG>=2){/* check that full qprobeval matches current LPstart */
    double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    if(VERB){
      printf("mprobevalwin(%d..%d):LPstart=%0.10f, Full qprobeval=%0.10f,N=%d\n",imin,imax,LPstart,qLP,N);
      if(0 && imin==1 && imax==2097){
	rverb = 1;
	double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	rverb = 0;

	printf("qLP= %0.8f:\n",qLP);
	for(int I = 1; I <= N+1; I++)
	  printf("Y[%d]= %0.6f\n",I,Y[I]);

	double qLPAsum = 0.0, bestLPAsum = 0.0;
	for(int m = 0; m < MD; m++){
	  /* locate leftmost and rightmost aligned site in X[m] */
	  int left = 1;
	  for(;left <= MX[m]; left++)
	    if(map[m][left] >= 0)
	      break;
	  int right = MX[m];
	  for(;right >= 1; right--)
	    if(map[m][right] >= 0)
	      break;

	  qLPAsum += qLPA[m];
	  bestLPAsum += bestLPA[m];
	  printf("m=%d:qLPA[m]=%0.10f,bestLPA[m]=%0.10f(sum=%0.10f,%0.10f): Aligned with Hcuts[%d..%d]= %0.4f .. %0.4f\n",
		 m,qLPA[m],bestLPA[m],qLPAsum,bestLPAsum, map[m][left], map[m][right], Hcuts[map[m][left]], Hcuts[map[m][right]]);
	}
      }
      fflush(stdout);
    }
    if(fabs(qLP - LPstart) > 1e-8){
      printf("WARNING: At start of mprobevalwin: Full qprobeval=%0.10f, LP=%0.10f (err=%0.10f)\n",qLP, LPstart, qLP-LPstart);
      double qcum = 0.0, bestcum=0.0;
      for(int m = 0; m < MD; m++){
	qcum += qLPA[m];
	bestcum += bestLPA[m];
	if(fabs(qLPA[m] - bestLPA[m]) > 1e-8)
	  printf("m=%d:qLPA[m]=%0.10f,bestLPA[m]=%0.10f(qcum=%0.10f,bestcum=%0.10f)\n",
		 m,qLPA[m],bestLPA[m],qcum,bestcum);
      }
      fflush(stdout);
      assert(fabs(qLP - LPstart) <= 1e-6);
    }
    double qcum = 0.0, bestcum=0.0;
    for(int m = 0; m < MD; m++){
      qcum += qLPA[m];
      bestcum += bestLPA[m];
      if(DEBUG && !(fabs(qLPA[m] - bestLPA[m]) <= 1e-8)){
	printf("m=%d:qLPA[m]=%0.10f,bestLPA[m]=%0.10f(qcum=%0.10f,bestcum=%0.10f)\n",
	       m,qLPA[m],bestLPA[m],qcum,bestcum);
	fflush(stdout);
	assert(fabs(qLPA[m] - bestLPA[m]) <= 1e-8);
      }
    }
  }

  if(DEBUG && !(1 <= imin && imin <= imax && imax <= n)){
    printf("At start of mprobeval(): imin=%d, imax=%d, n=%d\n",imin,imax,n);
    fflush(stdout);
    assert(1 <= imin && imin <= imax && imax <= n);
  }

  /* precompute number of labels before Hcuts[imin] */
  int idelmin = 0;
  for(int i = 1; i < imin; i++)
    idelmin += (Hdel[i] ? 0 : 1);

  while(1){

    /* compute addloc[] : all possible sites that are not within minKB of another existing site (and skip[i] <= 0) */
    addcnt = 0;
    int delcnt = 0;
    for(int i = max(1,imin); i <= min(n,imax); i++){
      if(!Hdel[i]){
	delcnt++;
	continue;
      }
      if(Hcuts[i] <= 0.0 || Hcuts[i] >= Hcuts[n+1])
	continue;/* can happen for draft consensus */
      if(skip[i] > 0)
	continue;
      /* check if Hcuts[i] is within minKB of another existing site */
      register int left,right;
      for(left = i; --left >= 1; )
	if(!Hdel[left])
	  break;
      if(DEBUG) assert(left < 1 || !Hdel[left]);
      for(right = i; ++right <= n; )
	if(!Hdel[right])
	  break;
      if(DEBUG)	assert(right > n || !Hdel[right]);
      if(left < 1)
	left = 0;
      if(right > n)
	right = 0;
      if(left && Hcuts[i] - Hcuts[left] > minKB)
	left = 0;
      if(right && Hcuts[right] - Hcuts[i] > minKB)
	right = 0;
      if(left || right)
	continue;
      addid[addcnt] = i;
      if(DEBUG) assert(imin <= i && i <= imax);
      if(VERB>=2){
	printf("addcnt = %d: addloc= Hcuts[%d]= %0.3f\n",addcnt, i, Hcuts[i]);
	fflush(stdout);
      }
      addloc[addcnt++] = Hcuts[i];
    }
    if(DEBUG)assert(addcnt <= n);

    /* free newLPdelta[] */
    //    delete [] newLPdeltaMem; newLPdeltaMem = 0;
    if(newLPdeltaMem){
      free(newLPdeltaMem); 
      newLPdeltaMem = 0;
    }
    MaxDelta = 0;
    if(HEAP_MINIMIZE){/* free lightweight heap to minimize real memory usage */
      delete heap;
      heap = new lightweight_heap(0,0);      
    }

    if(N > NmaxLP){/* need to reallocate NmaxLP dependent arrays */
      NmaxLP = (N * 5)/4;
      size_t siz = ((size_t)MD) * (NmaxLP + 2ul);

      if(!VMEM_MINIMIZE){/* NEW8 */
	/* reallocate newLPd[] */
	delete [] newLPd[0];
	try {/* allocate initial memory for newLPd[] */
	  newLPd[0] = new double[siz];
	} catch (exception& e){
	  cout << e.what() << endl;
	  printf("refine(): exception thrown while re-allocating newLPd[]:NmaxLP=%d,MD=%d,N=%d,siz=%lu\n",NmaxLP,MD,N,siz);
	  fflush(stdout);
	  assert(0);
	}
	for(long long m = 1; m < MD; m++)
	  newLPd[m] = newLPd[0] + m * (NmaxLP + 2ul);
	if(MDEBUG)
	  for(register int m = 0; m < MD; m++)
	    for(register int S = 0; S <= N+1; S++)
	      newLPd[m][S] = LARGE_NEGATIVE;
      }
      if(MDEBUG){/* NEW8 */
	delete [] newLPdPr[0];
	newLPdPr[0] = new int[siz];
	for(long long m = 1; m < MD; m++)
	  newLPdPr[m] = newLPdPr[0] + m * (NmaxLP + 2ul);
      }

      /* reallocate Dcum[] */
      delete [] Dcum;
      Dcum = new int[NmaxLP+2];
    }
    if(DEBUG) assert(NmaxLP >= N);

    if(MDEBUG && newLPaPr[0]) { delete [] newLPaPr[0]; newLPaPr[0] = 0;}

    MaxAddcnt = addcnt;
    size_t siz = ((size_t)MD) * MaxAddcnt;
    if(VERB>=2){
      printf("MaxAddcnt=%d,MD=%d:newLPaPr[0]=%p\n",MaxAddcnt,MD,newLPaPr[0]);
      fflush(stdout);
    }

    if(VMEM_MINIMIZE)
      DoubleAllocations_free();

    if(MDEBUG){
      newLPaPr[0] = new int[siz];
      for(long long m = 1; m < MD; m++)
	newLPaPr[m] = newLPaPr[0] + m * MaxAddcnt;
    }

    if(!VMEM_MINIMIZE){    /* reallocate newLPa[] */
      if(newLPa[0]) { free(newLPa[0]); newLPa[0] = 0;}
      if(VERB>=2){
  //	dumpmemmap();
	printf("Reallocating newLPa[] : addcnt=%d, MaxAddcnt=%d -> %d\n", addcnt, MaxAddcnt, addcnt);
	fflush(stdout);
      }
      newLPa[0] = (double *) malloc(siz * sizeof(double));
      if(!newLPa[0] || (MDEBUG && !newLPaPr[0])){
	printf("mprobevalwin(): malloc failed while allocating newLPa[]:MaxAddcnt=%d,siz=%lu\n",MaxAddcnt,siz);
	fflush(stdout);
	exit(1);
      }
      for(long long m = 1; m < MD; m++)
	newLPa[m] = newLPa[0] + m*MaxAddcnt;
      if(VERB>=2){
	printf("After Reallocating newLPa[]:\n");
	dumpmemmap();
	fflush(stdout);
      }
      if(MDEBUG || DEBUG>=2){
	for(register int m = 0; m < MD; m++)
	  for(register int t = 0; t < addcnt; t++)
	    newLPa[m][t] = LARGE_NEGATIVE;
      }
    }

    //    MDEBUG = (addcnt==29 ? 1 : 0);
    // MDEBUG_M = -1;
    //    MDEBUG = 0;
    //    if(imin == 56 && imax==302 && addcnt==177){
    //      MDEBUG = 1;
    //      MDEBUG_M = 114;
      //      MDEBUG_S = 45;
      //      MDEBUG_F = MDEBUG_S - 1;
      //      MDEBUG_TS = 619;
      //      MDEBUG_T = 231;
      //      MDEBUG_TT = 2;
    //    }

    if(DEBUG>=2 && !(Hcuts[imax] >= Hcuts[imin] && Hcuts[imax] <= Hcuts[n+1])){
      printf("imin=%d,imax=%d,n=%d:Hcuts[imin]=%0.3f,Hcuts[imax]=%0.3f,Hcuts[n+1]=%0.3f\n",imin,imax,n,Hcuts[imin],Hcuts[imax],Hcuts[n+1]);
      fflush(stdout);
      assert(Hcuts[imax] >= Hcuts[imin] && Hcuts[imax] <= Hcuts[n+1]);
    }

    //    rverb = (addcnt==1474 && imin==1 && imax==1788) ? 1 : 0;
    //    rverb = (MDEBUG && MDEBUG_M >= 0) ? 1 : 0;
    //    rverb = MDEBUG;
    if(rverb){
      printf("imin=%d,imax=%d:Hcuts[imin]=%0.4f, Hcuts[imax]= %0.4f\n", imin, imax, Hcuts[imin], Hcuts[imax]);
      fflush(stdout);

      double qLP2 = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA2,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);
      printf("qprobeval= %0.10f,N=%d\n",qLP2,N);

#if 0
      printf("Added label at Hcuts[%d]= %0.4f\n",1123,Hcuts[1123]);
      fflush(stdout);

      Hdel[1123] = 0;

      int NN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      score_init(NN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
      double qLP3 = qprobeval(n,Hcuts,NN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA2,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);

      printf("qprobeval= %0.10f, N=%d\n", qLP3, NN);
      fflush(stdout);
      exit(1);
#endif
    }
    rverb = 0;

    if(VERB>=2 || SVERB || SPEEDCHECK){
      printf("mprobeval(%d..%d)=%0.3f..%0.3f:addcnt=%d,delcnt=%d,minKB=%0.3f:",imin,imax,Hcuts[imin],Hcuts[imax],addcnt,delcnt,minKB);
      fflush(stdout);
    }
    double Ltheta = LOCAL_THETA ? max(1.0,Hcuts[imax] - Hcuts[imin])/max(1,delcnt) : Xtheta;
    double Llambda = LOCAL_THETA ? max(1.0,Hcuts[imax] - Hcuts[imin])/max(1,delcnt) : Xlambda;

    if(MaxLocalTheta > 0.0){
      if(VERB/* HERE HERE >=2 */ && MaxLocalTheta < Ltheta){
	printf("Llambda= %0.3f -> %0.3f due to -LocalTheta %d %0.3f\n",Ltheta,MaxLocalTheta,LocalTheta,MaxLocalTheta);
	fflush(stdout);
      }
      Ltheta = min(MaxLocalTheta, Ltheta);

      if(VERB/* HERE HERE >=2 */ && MaxLocalTheta < Llambda){
	printf("Llambda= %0.3f -> %0.3f due to -LocalTheta %d %0.3f\n",Llambda,MaxLocalTheta,LocalTheta,MaxLocalTheta);
	fflush(stdout);
      }
      Llambda = min(MaxLocalTheta, Llambda);
    }

    double start = mtime(), wstart = wtime();

    tverb = origtverb;

    if(DEBUG) assert(Hcuts[imin] <= Hcuts[imax]);

    //    rverb = MDEBUG;
    //    rverb = (imin==1 && imax==611 && 29 <= addcnt && addcnt <= 30) ? 1 : 0;
    double mLP = mprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap[MD],TBmapWT,newLPA,bestLPA,Hcuts[imin],Hcuts[imax],addcnt,addloc,0,0,LPdel,LPadd,0,0,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,0,0,AminM,AmaxM,pcontig,0,0);
    rverb = 0;
    tverb = 0;

    if(VERB>=2 || ERRPLOT || SPEEDCHECK){
      double wt = wtime();
      printf("mLP=%0.6f:N=%d(LPstart=%0.6f,delta=%0.8f):time=%0.6f, wall time=%0.6f(cum=%0.6f)\n",mLP,N,LPstart,mLP-LPstart,mtime()-start,wt-wstart,wt);
      if(VERB>=2)
	dumpmemmap();
      fflush(stdout);
    }

    if(DEBUG>=1+RELEASE && fabs(mLP - LPstart) > (USE_MFLOAT ? 1e-5 + EPS2*10000.0 : 1e-7 + EPS2*100.0) * MD){
      int origrverb = rverb;
      rverb = 0;
      double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);
      
      rverb = origrverb;
      if(VERB && rverb){
	printf("Calling qprobeval:\n");
	fflush(stdout);
      }
      double qLP2 = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA2,mapWT,0,0.0,0.0,0,0,pcontig);
      //      rverb = 0;
      printf("WARNING:mLP=%0.8f,LPstart=%0.8f(err=%0.8f,EPS2*MD=%0.8f),qLP=%0.8f,qLP2=%0.8f(delta=%0.8f),Hcuts[%d..%d]=%0.3f ... %0.3f,N=%d,SITE_PEN=%0.10f\n",
	     mLP,LPstart,mLP-LPstart,EPS2*MD,qLP,qLP2,qLP2-LPstart,imin,imax,Hcuts[imin],Hcuts[imax],N,SITE_PEN);
      if(DEBUG>=1+RELEASE){
	double newsum = 0.0, newsum2 = 0.0, bestsum = 0.0, mLPsum = 0.0;;
	for(int m = 0; m < MD; m++){
	  newsum += qLPA[m] * TBmapWT[m];
	  newsum2 += qLPA2[m] * TBmapWT[m];
	  bestsum += bestLPA[m] * TBmapWT[m];
	  mLPsum += newLPA[m] * TBmapWT[m];
	  if((fabs(qLPA2[m] - bestLPA[m]) > 1e-8 || fabs(qLPA2[m] - qLPA[m]) > 1e-8 || fabs(qLPA[m] - newLPA[m]) > 2e-9 + EPS2*100.0 || !(fabs(mLP - LPstart) <= 1e-8 + EPS2*MD*100.0)) && TBmapWT[m] > 0.0)
	    printf("m=%d:qLPA[m]=%0.8f,qLPA2[m]=%0.8f,bestLPA[m]=%0.8f,mLP[m]=%0.8f(err=%0.8f),TBmapWT=%0.10f(qLPAsum=%0.8f,qLPA2sum=%0.8f,bestsum=%0.8f,mLPsum=%0.8f,cumerr=%0.8f)\n",
		   m,qLPA[m],qLPA2[m],bestLPA[m],newLPA[m], newLPA[m]-bestLPA[m],TBmapWT[m],newsum,newsum2,bestsum, mLPsum,mLPsum-bestsum);
	}
      }
      fflush(stdout);
      // NOTE : this can happen due to different AR vs AL alignment arrays used in mprobeval/qprobeval when the map has more than one good matchgroup and MFLOAT=1 : should switch to double precision (MFLOAT=0) when needed.
      //      assert(fabs(mLP - LPstart) <= (USE_MFLOAT ? 1e-4 + EPS2 * 100000.0 : 1e-6 + EPS2 * 1000.0) * MD);
    }
    /*    if(rverb){
      printf("Debug Exit\n");
      fflush(stdout);
      exit(1);
      }*/

    if(MDEBUG && (MDEBUG_DEL || (MDEBUG_S >= 0 && MDEBUG_F >= 0)) && !(MDEBUG_T < 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0) && !(MDEBUG_T >= 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0)){
      double *testLPA = new double[MD];

      /* check LPdel[1..N] values vs qprobeval */
      double maxerr = -1000.0;/* worst error for any single site deletion for LP sum over all maps (excluding those that dropped more than LP_DROP) */
      int maxerrI = -1;

      double ErrMax = -1000.0;/* worst error for any single site deletion for any single map (excluding those that dropped more than LP_DROP) */
      double trueLP = -1000.0;
      int maxS = -1;
      int maxM = -1;
      double maxWT = 0.0;

      int I = 0;
      for(int i = 1; i <= n; i++){
	if(Hdel[i])
	  continue;
	I++;
	if(i < imin || i > imax)
	  continue;

	Hdel[i] = 1;
	if((MDEBUG_S <= 0 || I==MDEBUG_S) && MDEBUG_T < 0 && MDEBUG_TS < 0 && MDEBUG_TT < 0){
	  int newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	  if(DEBUG) assert(newN == N-1);

	  score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */

	  printf("i=%d,I=%d:Deleted Hcuts[i]=%0.3f:", i,I,Hcuts[i]);
	  fflush(stdout);

	  //	  rverb = (MDEBUG && i==17) ? 1 : 0;
	  double qLP = qprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);
	  //	  rverb = 0;
	  if((qLP > LPstart - LP_DROP || LPdel[I] > LPstart) && (!MDEBUG_NEGERR || LPdel[I] < qLP))
	    printf("qLP=%0.10f,LPdel[I]=%0.10f (error=%0.10f)\n",qLP,LPdel[I],LPdel[I]-qLP);
	  else
	    printf("qLP=%0.10f,LPdel[I]=%0.10f (error=%0.10f:ignored)\n",qLP,LPdel[I],LPdel[I]-qLP);
	  if((qLP > LPstart - LP_DROP || LPdel[I] > LPstart) && fabs(LPdel[I]-qLP) > maxerr && (!MDEBUG_NEGERR || LPdel[I] < qLP)){
	    maxerr = fabs(LPdel[I]-qLP);
	    maxerrI = I;
	  }

	  double sumLPdIm = 0.0, sumtest = 0.0;
	  for(int m = 0; m < MD; m++){
	    double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
	    int i = (!VMEM_MINIMIZE && I < DminM[m]) ? 0 : min(DmaxM[m],I);// NEW8
	    double newLPdmi = (VMEM_MINIMIZE && I < DminM[m]) ? newLPd0[m] : newLPd[m][i];// NEW8
	    int newLPdPrmi = !MDEBUG ? 0 : (VMEM_MINIMIZE && I < DminM[m]) ? newLPdPr[m][0] : newLPdPr[m][i];// NEW8
	    if(DEBUG) assert(newLPdmi > -1e98);

	    sumLPdIm += newLPdmi * TBwtm;
	    sumtest += testLPA[m] * TBwtm;
	    if(VERB && (VERB>=2 /* ||(I==93 && N==108) */ || (I==maxerrI && maxerr > MDEBUG_ERR) || (I==MDEBUG_S && m==MDEBUG_M))){
	      //	      printf("I=%d,m=%d(id=%lld):mLPA[m]=%0.10f,bestLPA[m]=%0.10f,newLPd[m][I]=%0.10f,trueLPA[m]=%0.10f(err=%0.10f),wt=%0.5f(cum:new=%0.5f,true=%0.5f,err=%0.5f)",
	      printf("I=%d,m=%d(id=%lld):mLPA[m]=%0.10f->%0.10f,newLPd[m][I]=%0.10f,trueLPA[m]=%0.10f(err=%0.10f),wt=%0.5f(cum:new=%0.5f,true=%0.5f,err=%0.5f)",
		     I,m,gmap[pcontig->contig[m].mapid]->id,bestLPA[m], newLPA[m], newLPdmi, testLPA[m], newLPdmi - testLPA[m],TBwtm, sumLPdIm, sumtest, sumLPdIm - sumtest);
	      if(testLPA[m] <= newLPA[m]-LP_DROP && newLPdmi <= newLPA[m])
		printf(":ignored");
	      if(MDEBUG && newLPdPrmi)
		printf(":reduced precision");
	      printf("ErrMax=%0.5f,maxS=%d,maxM=%d,maxerr=%0.5f\n", ErrMax, maxS, maxM, maxerr);
	      fflush(stdout);
	    }
	    if((testLPA[m] > newLPA[m] - LP_DROP*0.1 || newLPdmi > newLPA[m] || (maxerr > MDEBUG_ERR && maxerrI == I)) && fabs(newLPdmi-testLPA[m]) * TBwtm > ErrMax && (!MDEBUG_NEGERR || newLPdmi < testLPA[m])){
	      ErrMax = fabs(newLPdmi - testLPA[m]) * TBwtm;
	      trueLP = testLPA[m];
	      maxS = I;
	      maxM = m;
	      maxWT = TBwtm;
	    }
	  }
	  if(DEBUG && ErrMax >= 0.0) assert(maxS >= 0 && maxM >= 0);
	  if(DEBUG && !(fabs(sumLPdIm-newN*SITE_PEN - LPdel[I]) < 1e-8 && fabs(sumtest-newN*SITE_PEN - qLP) < 1e-8)){
	    printf("WARNING:sum(newLPd[m=0..%d][I])=%0.10f(newN=%d,SITE_PEN=%0.6f),LPdel[I]=%0.10f(err=%0.10f)\n",MD-1,sumLPdIm, newN,SITE_PEN,LPdel[I],(sumLPdIm - newN*SITE_PEN - LPdel[I]));
	    double sum1=0.0,sum2=0.0, sum3=0.0;
	    for(int m = 0; m < MD; m++){
	      double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
	      int i = (!VMEM_MINIMIZE && I < DminM[m]) ? 0 : min(DmaxM[m],I);// NEW8
	      double newLPdmi = (VMEM_MINIMIZE && I < DminM[m]) ? newLPd0[m] : newLPd[m][i];// NEW8
	      int newLPdPrmi = !MDEBUG ? 0 : (VMEM_MINIMIZE && I < DminM[m]) ? newLPdPr[m][0] : newLPdPr[m][i];// NEW8
	      sum1 += newLPdmi * TBwtm;
	      sum2 += testLPA[m] * TBwtm;
	      sum3 += newLPA[m] * TBwtm;
	      printf("I=%d,m=%d(id=%lld):wt=%0.10f,newLPd[m][I]=%0.10f(cum=%0.10f),testLPA[m]=%0.10f(cum=%0.10f):err=%0.10f(cum=%0.10f):mLPA[m]=%0.10f(cum=%0.10f):",
		     I,m,gmap[pcontig->contig[m].mapid]->id,TBwtm,newLPdmi,sum1,testLPA[m],sum2,newLPdmi-testLPA[m],sum1-sum2, newLPA[m], sum3);
	      if(testLPA[m] <= newLPA[m]-LP_DROP*0.1 && newLPdmi <= newLPA[m])
		printf(":ignored");
	      if(MDEBUG && newLPdPrmi)
		printf(":reduced precision");
	      printf("\n");
	    }
	    printf("ErrMax=%0.8f,maxS=%d,maxM=%d\n",ErrMax,maxS,maxM);
	    fflush(stdout);
	    assert(fabs(sumLPdIm-newN*SITE_PEN - LPdel[I]) < 1e-8);
	    assert(fabs(sumtest-newN*SITE_PEN - qLP) < 1e-8);
	  }

	  if(ErrMax >= 0.0 && ((MDEBUG_S > 0 && MDEBUG_F >= 0 && newN == MDEBUG_N-1) /* || ErrMax >= MDEBUG_ERR*/)){
	    int maxs = (!VMEM_MINIMIZE && maxS < DminM[maxM]) ? 0 : min(DmaxM[maxM],maxS);// NEW8
	    double newLPdms = (VMEM_MINIMIZE &&  maxS < DminM[maxM]) ? newLPd0[maxM] : newLPd[maxM][maxs];// NEW8
	    int newLPdPrms = !MDEBUG ? 0 : (VMEM_MINIMIZE && maxS < DminM[maxM]) ? newLPdPr[maxM][0] : newLPdPr[maxM][maxs];// NEW8
	    printf("S=%d:Site/map with worst deletion error so far is S=%d(%0.3f),m=%d(id=%lld),N=%d:mLP[m]=%0.10f,newLPd[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10f:%s(excluding when LP drops by %0.3f or more)\n",
		   I,maxS,Y[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N,newLPA[maxM],newLPdms,trueLP,ErrMax, (MDEBUG && newLPdPrms) ? "reduced precision" :"", LP_DROP*0.1);

	    printf("Calling mprobeval(%d..%d)=%0.3f..%0.3f (after deleting site Y[%d]=%0.3f):",imin,imax,Hcuts[imin],Hcuts[imax],maxS,Y[maxS]);
	    fflush(stdout);

	    double mLP1 = mprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap[MD],TBmapWT,testLPA,bestLPA,Hcuts[imin],Hcuts[imax],0,addloc,0,0,LPdel,0,0,0,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,0,0,AminM,AmaxM,pcontig,0,0);
	    printf("mLP1=%0.10f\n",mLP1);
	    fflush(stdout);

	    if(MDEBUG_S > 0 && MDEBUG_F >= 0 && newN == MDEBUG_N-1)
	      exit(1);
	    if(DEBUG) assert(ErrMax < MDEBUG_ERR);
	  }
	}

	Hdel[i] = 0;
      }

      if(MDEBUG_T < 0 && MDEBUG_TS < 0 && MDEBUG_TT < 0){
	if(maxerr >= 0.0)
	  printf("Worst site deletion error =%0.10e at I=%d(excluding when LP drops by %0.3f or more)\n",maxerr,maxerrI,LP_DROP);
	if(ErrMax >= 0.0){
	  int maxs = (!VMEM_MINIMIZE && maxS < DminM[maxM]) ? 0 : min(DmaxM[maxM],maxS);// NEW8
	  double newLPdms = (VMEM_MINIMIZE &&  maxS < DminM[maxM]) ? newLPd0[maxM] : newLPd[maxM][maxs];// NEW8
	  int newLPdPrms = !MDEBUG ? 0 : (VMEM_MINIMIZE && maxS < DminM[maxM]) ? newLPdPr[maxM][0] : newLPdPr[maxM][maxs];// NEW8
	  printf("Site/map with worst deletion error is S=%d(%0.3f),m=%d(id=%lld),N=%d:mLP[m]=%0.10f,newLPd[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10f,TBwt=%0.6f:%s(excluding when LP drops by %0.3f or more)\n",
		 maxS,Y[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N,newLPA[maxM],newLPdms,trueLP,ErrMax,maxWT, (MDEBUG && newLPdPrms) ? "reduced precision" : "", LP_DROP*0.1);
	  fflush(stdout);
	  if(DEBUG) assert(ErrMax < MDEBUG_ERR * 100.0);
	}
	if(DEBUG) assert(maxerr < MDEBUG_ERR);
      }

      int restoredN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
      if(MDEBUG_M < 0){
	double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    
	printf("Restored qLP=%0.10f,N=%d(%d)\n",qLP,restoredN,N);
	fflush(stdout);
      }
      if(DEBUG) assert(restoredN == N);
      delete [] testLPA;
    }

    if(MDEBUG && (MDEBUG_ADD || (MDEBUG_T >= 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0)) && 
       !(MDEBUG_T < 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0) && !(MDEBUG_T < 0 && MDEBUG_S >= 0 && MDEBUG_F >= 0)){
      double *testLPA = new double[MD];

      /* check LPadd[0..addloc-1] values vs qprobeval */
      double maxerr = -1000.0;/* worst error for any single site addition for LP sum over all maps */
      int maxerrS = -1; /* Existing site in Y[] left of added site */
      int maxerrT = -1; /* Added site in addloc[] corresponding to worst error */
      
      double ErrMax = -1000.0;/* worst error for any single site addition for any single map */
      double trueLP = -1000.0;
      int maxM = -1;
      int maxS = -1;
      int maxT = -1;
      int maxTT = -1;
      double maxWT = 0.0;

      int T = 0, S = 0, TT = 0;
      for(int i = 1; i <= n; i++){
	if(!Hdel[i]){
	  if(VERB>=2){
	    printf("i=%d,S=%d:Hdel[i]=%d:skipped adding Hcuts[i]=%0.3f\n",i,S,Hdel[i],Hcuts[i]);
	    fflush(stdout);
	  }
	  S++;
	  TT = 0;
	  continue;
	}
	if(i < imin || i > imax)
	  continue;

	if(Hcuts[i] <= 0.0 || Hcuts[i] >= Hcuts[n+1])
	  continue;/* can happen for draft consensus */

	if(skip[i] > 0){
	  if(VERB>=2){
	    printf("i=%d,S=%d:skip[i]=%d:skipped adding Hcuts[i]=%0.3f\n",i,S,skip[i],Hcuts[i]);
	    fflush(stdout);
	  }
	  continue;
	}

	/* check if Hcuts[i] is within minKB of another existing cut */
	int left,right;
	for(left = i; --left >= 1; )
	  if(!Hdel[left])
	    break;
	if(DEBUG) assert(left < 1 || !Hdel[left]);
	for(right = i; ++right <= n; )
	  if(!Hdel[right])
	    break;
	if(DEBUG)	assert(right > n || !Hdel[right]);
	if(left < 1)
	  left = 0;
	if(right > n)
	  right = 0;
	if(left && Hcuts[i] - Hcuts[left] > minKB)
	  left = 0;
	if(right && Hcuts[right] - Hcuts[i] > minKB)
	  right = 0;
	if(left || right){
	  if(VERB>=2){
	    printf("i=%d,S=%d:left=%d(Hcuts=%0.3f),right=%d(%0.3f):skipped adding Hcuts[i]=%0.3f\n",i,S,left,Hcuts[left],right,Hcuts[right],Hcuts[i]);
	    fflush(stdout);
	  }
	  continue;
	}

	if(DEBUG && !(T < addcnt && addid[T] == i)){
	  printf("T=%d,addcnt=%d,i=%d:Hcuts[i]=%0.3f,addloc[T]=%0.3f,addid[T]=%d\n",
		 T,addcnt,i,Hcuts[i],addloc[T],addid[T]);
	  fflush(stdout);
	  assert(T < addcnt && addid[T] == i);
	}
	if(DEBUG) assert(imin <= i && i <= imax);

	Hdel[i] = 0;
	
	if(MDEBUG_S < 0 && (MDEBUG_T <= 0 || T==MDEBUG_T) && T < addcnt){
	  int newN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][] and map[MD][] */
	  if(DEBUG) assert(newN == N+1);
	  score_init(newN,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	  
	  printf("i=%d,S=%d,T=%d:Added Hcuts[i]=%0.3f,skip[i]=%d,addloc[T]=%0.3f,Y[S]=%0.3f..%0.3f:", i, S, T, Hcuts[i],skip[i],addloc[T], Y[S],Y[S+2]);
	  fflush(stdout);

	  double qLP = qprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);
	  if((qLP > LPstart-LP_DROP || LPadd[T] > LPstart) && (!MDEBUG_NEGERR || LPadd[T] < qLP))
	    printf("LP=%0.10f,qLP=%0.10f,LPadd[T]=%0.10f (error=%0.10f)\n",LPstart,qLP,LPadd[T],LPadd[T]-qLP);
	  else
	    printf("LP=%0.10f,qLP=%0.10f,LPadd[T]=%0.10f (error=%0.10f:ignored)\n",LPstart,qLP,LPadd[T],LPadd[T]-qLP);
	  if((qLP > LPstart-LP_DROP || LPadd[T] > LPstart) && fabs(LPadd[T]-qLP) > maxerr && (!MDEBUG_NEGERR || LPadd[T] < qLP)){
	    maxerr = fabs(LPadd[T]-qLP);
	    maxerrS = S;
	    maxerrT = T;
	  }

	  for(int m = 0; m < MD; m++){
	    int t = (T < TminM[m]) ? TminM[m] : (T > TmaxM[m]) ? TmaxM[m] : T;
	    double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
	    if(VERB && (VERB>=2 || (T==maxerrT && S==maxerrS && maxerr > MDEBUG_ERR) || (T==MDEBUG_T && m==MDEBUG_M) 
			|| ((testLPA[m] > newLPA[m]-LP_DROP*0.1 || newLPa[m][t] > newLPA[m]) && fabs(newLPa[m][t]-testLPA[m]) *TBwtm > max(ErrMax, MDEBUG_ERR)) )){
	      printf("S=%d,T=%d,m=%d(id=%lld):LP[m]=%0.10f,newLPa[m][T]=%0.10f,testLPA[m][T]=%0.10f(err=%0.10f)",
		     S,T,m,gmap[pcontig->contig[m].mapid]->id,bestLPA[m],newLPa[m][t], testLPA[m],newLPa[m][t] - testLPA[m]);
	      if(testLPA[m] <= newLPA[m] - LP_DROP && newLPa[m][t] <= newLPA[m])
		printf(":ignored");
	      if(MDEBUG && newLPaPr[m][t])
		printf(":reduced precision");
	      printf("\n");
	      fflush(stdout);
	    }
	    if(DEBUG) assert(newLPa[m][t] > -1e98); 
	    if((testLPA[m] > newLPA[m] - LP_DROP*0.1 || newLPa[m][t] > newLPA[m] || (maxerr > MDEBUG_ERR && maxerrS == S && maxerrT == T)) && fabs(newLPa[m][t]-testLPA[m]) * TBwtm > ErrMax 
	       && (!MDEBUG_NEGERR || newLPa[m][t] < testLPA[m])){
	      ErrMax = fabs(newLPa[m][t]-testLPA[m]) * TBwtm;
	      trueLP = testLPA[m];
	      maxS = S;
	      maxT = T;
	      maxTT = TT;
	      maxM = m;
	      maxWT = TBwtm;
	    }
	  }
	  if(DEBUG && ErrMax >= 0.0) assert(maxT >= 0 && maxM >= 0);
	    
	  if(ErrMax >= 0.0 && ((MDEBUG_T > 0 && MDEBUG_TS >= 0 && newN == MDEBUG_N+1) /* || ErrMax >= MDEBUG_ERR*/)){
	    int maxt = (maxT < TminM[maxM]) ? TminM[maxM] : (maxT > TmaxM[maxM]) ? TmaxM[maxM] : maxT;
	    printf("T=%d:Site/map with worst site addition error so far is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N=%d:mLP[m]=%0.10f,newLPa[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e:%s(excluding when LP drops by %0.3f or more)\n",
		   T,maxS,Y[maxS],Y[maxS+2],maxT,addloc[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N,newLPA[maxM],newLPa[maxM][maxt],trueLP,ErrMax, (MDEBUG && newLPaPr[maxM][maxt]) ? "reduced precision":"",LP_DROP*0.1);
	    fflush(stdout);
	      

#if 1
	    rverb = 1;

	    printf("Calling qprobeval(%d..%d)=%0.3f..%0.3f (after adding site addloc[%d]=%0.3f),rverb=%d:\n",imin,imax,Hcuts[imin],Hcuts[imax],maxT,addloc[maxT],rverb);
	    fflush(stdout);
	    double qLP2 = qprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);

	    printf("qLP2=%0.10f\n",qLP2);
	    fflush(stdout);
#endif

	    printf("Calling mprobeval(%d..%d)=%0.3f..%0.3f (after adding site addloc[%d]=%0.3f),rverb=%d:\n",imin,imax,Hcuts[imin],Hcuts[imax],maxT,addloc[maxT],rverb);
	    fflush(stdout);

	    double mLP2 = mprobeval(n,Hcuts,newN,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap[MD],TBmapWT,testLPA,bestLPA,Hcuts[imin],Hcuts[imax],0,addloc,0,0,LPdel,0,0,0,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,0,0,AminM,AmaxM,pcontig,0,0);
	    printf("mLP2=%0.10f\n",mLP2);
	    fflush(stdout);


	    if(MDEBUG_T > 0 && MDEBUG_TS >= 0 && newN == MDEBUG_N+1)
	      exit(1);
	    assert(ErrMax < MDEBUG_ERR);
	  }
	}
	T++;
	TT++;
	Hdel[i] = 1;
      }

      if(MDEBUG_T < 0 && MDEBUG_TS < 0 && MDEBUG_TT < 0){
	if(maxerr >= 0.0)
	  printf("Worst site addition error =%0.10e at T=%d(%0.3f) interval S=%d(%0.3f..%0.3f)(excluding when LP drops by %0.3f or more)\n",
		 maxerr,maxerrT,addloc[maxerrT],maxerrS,Y[maxerrS],Y[maxerrS+1],LP_DROP);
	if(ErrMax >= 0.0){
	  int maxt = (maxT < TminM[maxM]) ? TminM[maxM] : (maxT > TmaxM[maxM]) ? TmaxM[maxM] : maxT;
	  printf("Site/map with worst site addition error is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N=%d:mLP[m]=%0.10f,newLPa[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e,wt=%0.5f:%s(excluding when LP drops by %0.3f or more)\n",
		 maxS,Y[maxS],Y[maxS+1],maxT,addloc[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N,newLPA[maxM],newLPa[maxM][maxt],trueLP,ErrMax, maxWT, (MDEBUG && newLPaPr[maxM][maxt])?"reduced precision":"",LP_DROP*0.1);
	  fflush(stdout);
	  if(DEBUG) assert(ErrMax < MDEBUG_ERR * 100.0);
	}
	fflush(stdout);
      }

      if(DEBUG) assert(maxerr < MDEBUG_ERR);

      int restoredN = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);
      score_init(N,Y,MD,MX,X);
      if(MDEBUG_M < 0){
	double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,bestLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    
	printf("qLP=%0.6f,N=%d(%d)\n",qLP,restoredN,N);
	fflush(stdout);
      }

      if(DEBUG) assert(ErrMax < MDEBUG_ERR * 100.0);
      if(DEBUG) assert(maxerr < MDEBUG_ERR);
      if(DEBUG) assert(restoredN == N);

      delete [] testLPA;
    } /* MDEBUG */

    //    if(MDEBUG) exit(1);

    //    MDEBUG = 1;
    //            MDEBUG_M = -1;

    if(DEBUG>=2 && !(Hcuts[imax] >= Hcuts[imin] && Hcuts[imax] <= Hcuts[n+1])){
      printf("imin=%d,imax=%d,n=%d:Hcuts[imin]=%0.3f,Hcuts[imax]=%0.3f,Hcuts[n+1]=%0.3f\n",imin,imax,n,Hcuts[imin],Hcuts[imax],Hcuts[n+1]);
      fflush(stdout);
      assert(Hcuts[imax] >= Hcuts[imin] && Hcuts[imax] <= Hcuts[n+1]);
    }

    double LPsinglebest = LPstart;/* best single change LP value */

    double LPbest = LPstart;/* best LP value so far */
    int ibest = -1;
    int ifirst = -1, ilast = -1;/* current range of Hcuts[i] locations where changes improve previous LP */
    int splitcnt = 0;/* number of previous ranges seperated by SPLITRANGE * Ltheta */
    int iadd = 0, idel = idelmin;
    int progress = 0;
    int newN = N;/* keep track of net number of sites so they never drop below max(2,MinSites) */

    for(int i = imin/* WAS 1 */; i <= imax /* WAS n */; i++){
      if(DEBUG>=2 && i==imin) assert(idel == idelmin);

      idel += (Hdel[i] ? 0 : 1);
      /* IF Hdel[i]==0 (&& idel <= N), THEN LPdel[idel] is the LP value after deleting site Hcuts[i] */

      while(iadd < addcnt && i > addid[iadd])
	iadd++;
      /* IF Hdel[i]==1 && i == addid[iadd] (&& iadd < addcnt) THEN LPadd[iadd] is the LP value after adding site Hcuts[i] */

      int check = (skip[i] <= 0 && !(Hdel[i] && !(iadd < addcnt && i==addid[iadd]))) ? 1 : 0;
      //      if(i < imin || i > imax)
      //	check = 0;

      if(!check) {
	if(VERB>=2 && imin==56 && imax==302 && addcnt==177 && N >= 65){
	  printf("Skipping %s site Hcuts[%d]=%0.3f:skip[i]=%d,iadd=%d,addcnt=%d,addid[min(iadd,addcnt-1)]=%d,n=%d,imin=%d,imax=%d\n",
		 Hdel[i] ? "adding" : "deleting", i, Hcuts[i], skip[i], iadd, addcnt, addid[min(iadd,addcnt-1)],n,imin,imax);
	  fflush(stdout);
	}
	LPsite[i] = LPstart - 1000.0;
      } else /* if(check) */{
	double LP;
	if(!Hdel[i]){
	  if(DEBUG) assert(1 <= idel && idel <= N);
	  LP = LPdel[idel];
	} else {
	  if(DEBUG && !(i == addid[iadd] && iadd < addcnt)){
	    printf("i=%d:Hdel[i]=%d,Hcuts[i]=%0.3f,skip[i]=%d,iadd=%d,addid[iadd]=%d,addloc[iadd]=%0.3f,addcnt=%d\n",i,Hdel[i],Hcuts[i],skip[i],iadd,addid[iadd],addloc[iadd],addcnt);
	    if(iadd > 0)
	      printf("  addid[iadd-1]=%d,addloc[iadd-1]=%0.3f\n",addid[iadd-1],addloc[iadd-1]);
	    fflush(stdout);
	    assert(i == addid[iadd] && iadd < addcnt);
	  }
	  LP = LPadd[iadd];
	  if(LP < LPstart - LP_SKIP)
	    skip[i] = 1;/* skip next time */
	}
	LPsite[i] = LP;
	if(VERB>=2 && imin==56 && imax==302 && addcnt==177 && N >= 65){
	  printf("Trying to %s site Hcuts[%d]=%0.3f:LP=%0.6f -> %0.6f(best=%0.6f at Hcuts[%d]=%0.3f,ifirst=%d,ilast=%d,ibest=%d,splitcnt=%d,n=%d,imin=%d,imax=%d,skip[i]=%d)%c\n",
		 Hdel[i] ? "add" : "delete", i, Hcuts[i], LPstart, LP, LPbest, ibest, Hcuts[ibest],ifirst, ilast, ibest,splitcnt, n, imin, imax, skip[i], LP > LPstart ? (LP > LPbest ? '^' : '!') : (skip[i]==1) ? 'v' : ' ');
	  fflush(stdout);
	}
	if(LP > LPstart + LP_MINDELTA){
	  if(SPLITRANGE && ilast >= 0 && Hcuts[i] - Hcuts[ilast] > SPLITRANGE * Ltheta){/* create a new mprobevalwin() split window */
	    if(DEBUG) assert(ifirst >= 0);
	    if(VERB>=2 || SPEEDCHECK){
	      printf("mprobevalwin(%d..%d): creating new mprobevalwin split Hcuts[%d..%d]=%0.3f..%0.3f,ibest=%d,Hcuts[i=%d]=%0.3f\n",
		     imin,imax,ifirst,ilast,Hcuts[ifirst],Hcuts[ilast],ibest,i,Hcuts[i]);
	      fflush(stdout);
	    }
	    splitL[splitcnt] = ifirst;
	    splitR[splitcnt] = ilast;
	    if(EXPANDSPLIT2 > 0.0){
	      while(splitL[splitcnt] > imin && Hcuts[ifirst]-Hcuts[splitL[splitcnt]] < EXPANDSPLIT2 * Ltheta)
		splitL[splitcnt]--;
	      while(splitR[splitcnt] < imax && Hcuts[splitR[splitcnt]]-Hcuts[ilast] < EXPANDSPLIT2 * Ltheta)
		splitR[splitcnt]++;
	      if(VERB>=2 || SPEEDCHECK){
		printf("\t Expanded new mprobevalwin split :  Hcuts[%d..%d]=%0.3f .. %0.3f\n",splitL[splitcnt],splitR[splitcnt],Hcuts[splitL[splitcnt]],Hcuts[splitR[splitcnt]]);
		fflush(stdout);
	      }
	    }
	    splitcnt++;
		    
#if 0 // need to check if ibest can be confirmed and then reset LPbest,ibest. HERE : seems to result in slightly worse final LP (???)
	    if(DEBUG && SPLITRANGE >= SCANRANGE) assert(Hcuts[i]-Hcuts[ibest] >= SCANRANGE * Llambda);
	    if(ibest >= 1 /* && (i == n || Hcuts[i]-Hcuts[ibest] >= SCANRANGE * Llambda) */ && !(!Hdel[ibest] && newN <= max(2,MinSites))){/* confirm change to Hdel[ibest] */
	      register int t = -1;
	      if(progress > 0){ /* first scan back up to SCANRANGE * Llambda to confirm that this is a local peak in both directions */
		int prev = changes[progress-1];
		if(DEBUG && prev <= 0){
		  printf("WARNING:progress=%d,changes[progress-1]=%d,n=%d\n",progress,changes[progress-1],n);
		  fflush(stdout);
		  assert(prev > 0);
		}
		for(t = ibest-1; t > prev; t--){
		  if(Hcuts[SCANFIX ? ibest : i] - Hcuts[t] > SCANRANGE * Llambda)
		    break;
		  if(LPsite[t] > LPbest)
		    break;
		}
		if(DEBUG && t <= 0){
		  printf("WARNING: progress=%d,changes[progress-1]=%d,prev=%d,t=%d,n=%d,ibest=%d\n",progress,changes[progress-1],prev,t,n,ibest);
		  fflush(stdout);
		  assert(t > 0);
		}
	      }
	      if(!(progress > 0 && Hcuts[SCANFIX ? ibest : i] - Hcuts[t] <= SCANRANGE* Llambda)){
		changes[progress++] = ibest;
		newN += (Hdel[ibest] ? 1 : -1);
		Hdel[ibest] = 1-Hdel[ibest];
		AddDeleteCnt++;
		if(LPbest > LPsinglebest)
		  LPsinglebest = LPbest;
		if(VERB){
		  if(progress > 1){
		    printf("%s site Hcuts[%d]=%0.3f:LP=%0.6f -> %0.6f,N=%d->%d,n=%d (previous best site change at Hcuts[t=%d]=%0.3f(LP=%0.6f), mindist=%0.3f,Xl=%0.3f,Xt=%0.3f)\n",
			   Hdel[ibest] ? "deleted" : "added", ibest, Hcuts[ibest], LPstart, LPbest,N,newN,n,t,Hcuts[t],LPsite[t],SCANRANGE * Llambda, Llambda, Ltheta);
		    if(DEBUG && t <= 0){
		      printf("WARNING: progress=%d,changes[progress-2]=%d,t=%d,n=%d,ibest=%d\n",progress,changes[progress-2],t,n,ibest);
		      fflush(stdout);
		      assert(t > 0);
		    }
		  } else
		    printf("%s site Hcuts[%d]=%0.3f:LP=%0.6f -> %0.6f,N=%d->%d,n=%d\n",
			   Hdel[ibest] ? "deleted" : "added", ibest, Hcuts[ibest], LPstart, LPbest,N,newN,n);
		  fflush(stdout);
		}
		/* no need to expand range of current split ifirst..ilast since SPLITRANGE > EXPANDSPLIT */
		if(DEBUG) assert(SPLITRANGE > EXPANDSPLIT);
	      }
	    }
#endif
	    /* start next scan for further improvements at i */
	    ifirst = ilast = -1;
	    LPbest = LPstart;
	    ibest = -1;
	  } // if(SPLITRANGE ... )
	  if(ifirst < 0)
	    ifirst = ilast = i;
	  ilast = max(i,ilast);
	  if(LP > LPbest + 2e-9){
	    ibest = i;
	    LPbest = LP;
	  }
	} // LP > LPstart + LP_MINDELTA
      } // if(check)

      if(RESCAN_FIX || check){
	if(DEBUG>=2 && ibest >= 1) assert(i >= imin);

	if(ibest >= 1 && (i >= imax || Hcuts[i+1]-Hcuts[ibest] >= SCANRANGE * Llambda) && !(!Hdel[ibest] && newN <= max(2,MinSites))){/* confirm change to Hdel[ibest] */
	  int t = -1;
	  if(progress > 0){ /* first scan back from Hcuts[ibest] up to SCANRANGE * Llambda to confirm that Hcuts[ibest] is a local peak in both directions */
	    int prev = changes[progress-1];
	    if(DEBUG && prev <= 0){
	      printf("WARNING:progress=%d,changes[progress-1]=%d,n=%d\n",progress,changes[progress-1],n);
	      fflush(stdout);
	      assert(prev > 0);
	    }
	    for(t = ibest-1; t > prev; t--){
	      if(Hcuts[SCANFIX ? ibest : i] - Hcuts[t] > SCANRANGE * Llambda)
		break;
	      if(LPsite[t] > LPbest)
		break;
	    }
	    if(DEBUG && t <= 0){
	      printf("WARNING: progress=%d,changes[progress-1]=%d,prev=%d,t=%d,n=%d,ibest=%d\n",progress,changes[progress-1],prev,t,n,ibest);
	      fflush(stdout);
	      assert(t > 0);
	    }
	  }
	  if(!(progress > 0 && Hcuts[SCANFIX ? ibest : i] - Hcuts[t] <= SCANRANGE * Llambda)){
	    changes[progress++] = ibest;
	    newN += (Hdel[ibest] ? 1 : -1);
	    Hdel[ibest] = 1-Hdel[ibest];
	    AddDeleteCnt++;
	    if(LPbest > LPsinglebest)
	      LPsinglebest = LPbest;
	    if(VERB){
	      if(progress > 1){
		printf("%s site Hcuts[%d]=%0.3f:LP=%0.6f -> %0.6f,N=%d->%d,n=%d (previous best site change at Hcuts[t=%d]=%0.3f(LP=%0.6f), mindist=%0.3f,Xl=%0.3f,Xt=%0.3f)\n",
		       Hdel[ibest] ? "deleted" : "added", ibest, Hcuts[ibest], LPstart, LPbest,N,newN,n,t,Hcuts[t],LPsite[t],SCANRANGE * Llambda, Llambda, Ltheta);
		if(DEBUG && t <= 0){
		  printf("WARNING: progress=%d,changes[progress-2]=%d,t=%d,n=%d,ibest=%d\n",progress,changes[progress-2],t,n,ibest);
		  fflush(stdout);
		  assert(t > 0);
		}
	      } else
		printf("%s site Hcuts[%d]=%0.3f:LP=%0.6f -> %0.6f,N=%d->%d,n=%d\n",
		       Hdel[ibest] ? "deleted" : "added", ibest, Hcuts[ibest], LPstart, LPbest,N,newN,n);
	      fflush(stdout);
	    }
	    if(EXPANDSPLIT>0){/* expand range of current (potential) split ifirst .. ilast to include a distance of EXPLANDSPLIT * Llambda around Hcuts[ibest] */
	      int origifirst = ifirst, origilast = ilast;
	      if(DEBUG && !(ifirst <= ibest && ilast >= ibest)){
		printf("mprobevalwin:ifirst=%d,ilast=%d,ibest=%d\n",ifirst,ilast,ibest);
		fflush(stdout);
		assert(ifirst <= ibest && ilast >= ibest);
	      }
	      while(ifirst > imin && Hcuts[ibest]-Hcuts[ifirst] < EXPANDSPLIT * Llambda)
		ifirst--;
	      while(ilast < imax && Hcuts[ilast]-Hcuts[ibest] < EXPANDSPLIT * Llambda)
		ilast++;
	      if(VERB>=2 && N >= 65){
		printf("Expanded possible split range Hcuts[%d..%d] to Hcuts[%d..%d]=%0.3f..%0.3f due to site change at Hcuts[%d] (imin=%d,imax=%d)\n",
		       origifirst,origilast,ifirst,ilast,Hcuts[ifirst],Hcuts[ilast],ibest,imin,imax);
		fflush(stdout);
	      }
	    }
	  }
	  LPbest = LPstart;/* start next scan for further improvements at i+1 */
	  ibest = -1;
	}
      }
    } // for (i = 1; i <=n; i++)

    if(VERB>=2){
      printf("mprobevalwin: completed scan for adding/deleting labels: progress=%d: cum wall time= %0.6f secs\n",progress,wtime());
      fflush(stdout);
    }

    if(ilast >= 0){
      if(DEBUG) assert(ifirst >= 0);
      splitL[splitcnt] = ifirst;
      splitR[splitcnt] = ilast;
      if(EXPANDSPLIT2 > 0.0){
	while(splitL[splitcnt] > imin && Hcuts[ifirst]-Hcuts[splitL[splitcnt]] < EXPANDSPLIT2 * Llambda)
	  splitL[splitcnt]--;
	while(splitR[splitcnt] < imax && Hcuts[splitR[splitcnt]]-Hcuts[ilast] < EXPANDSPLIT2 * Llambda)
	  splitR[splitcnt]++;
      }
      splitcnt++;
    }
    if(!progress)
      break;

    if(progress){
      N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
      if(DEBUG>=2){
	for(int I = 1; I <= N; I++){
	  int i = nmap[MD][I];
	  if(fabs(Hcuts[i]-Y[I]) > 2e-9){
	    printf("After setmap():I=%d,i=nmap[MD][I]=%d,Y[I]=%0.10f,Hcuts[i]=%0.10f\n",
		   I,i,Y[I],Hcuts[i]);
	    fflush(stdout);
	    assert(fabs(Hcuts[i]-Y[I]) <= 2e-9);
	  }
	}
	if(fabs(Hcuts[n+1] - Y[N+1]) > 2e-9){
	  printf("After setmap():N=%d,n=%d,Y[N+1]=%0.10f,Hcuts[n+1]=%0.10f\n",
		 N,n,Y[N+1],Hcuts[n+1]);
	  fflush(stdout);
	  assert(fabs(Hcuts[n+1]-Y[N+1]) <= 2e-9);
	}
      }

      tverb = origtverb;

      score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
      if(DEBUG && !(Hcuts[imax] >= Hcuts[imin] && Hcuts[imax] <= Hcuts[n+1] && Hcuts[imax] <= Y[N+1])){
	printf("imin=%d,imax=%d,n=%d:Hcuts[imin]=%0.3f,Hcuts[imax]=%0.3f,Hcuts[n+1]=%0.3f,N=%d,Y[N+1]=%0.3f\n",imin,imax,n,Hcuts[imin],Hcuts[imax],Hcuts[n+1],N,Y[N+1]);
	fflush(stdout);
	assert(Hcuts[imax] >= Hcuts[imin] && Hcuts[imax] <= Hcuts[n+1] && Hcuts[imax] <= Y[N+1]);
      }
      double LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,newLPA,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);
      if(VERB){
	if(TIME_VERBOSE)
	  printf("    LP = %0.6f, N=%d,n=%d (LPstart=%0.6f,delta=%0.6f), LPsinglebest=%0.6f (delta=%0.6f): cum wall time= %0.6f\n", LP, N, n, LPstart,LP-LPstart,LPsinglebest, LPsinglebest-LPstart,wtime());
	else
	  printf("    LP = %0.6f, N=%d,n=%d (LPstart=%0.6f,delta=%0.6f),LPsinglebest=%0.6f (delta=%0.6f)\n", LP, N, n, LPstart,LP-LPstart,LPsinglebest,LPsinglebest - LPstart);
	fflush(stdout);
      }
      tverb = 0;

      int origprogress = progress;
      while(!(LP > LPstart + LP_MINDELTA && (progress <= 1 || LP >= LPsinglebest - LP_MINDELTA))){/* this should be rare : undo one of changes[0..progress-1] */
	if(progress > 1){
	  /* locate change with smallest improvment */
	  int minindex = 0;
	  double minchange = LPsite[changes[minindex]] - LPstart;
	  for(int t = 1; t < progress; t++){
	    int id = changes[t];
	    if(LPsite[id] - LPstart < minchange){
	      minindex = t;
	      minchange = LPsite[id] - LPstart;
	    }
	  }
	  int t = changes[minindex];
	  Hdel[t] = 1-Hdel[t];
	  /* remove changes[minindex] from changes[0..progress-1] */
	  if(minindex != progress-1){
	    int tmp = changes[minindex];
	    changes[minindex] = changes[progress-1];
	    changes[progress-1] = tmp;
	  }
	  progress--;
	  AddDeleteCnt--;

	  N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	  score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	  LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,newLPA,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);
	  
	  if(VERB){
	    if(TIME_VERBOSE)
	      printf("LPsinglebest=%0.10f,LPstart=%0.10f: undoing change at Hcuts[%d]=%0.3f:LP=%0.10f,N=%d: cum wall time= %0.6f secs\n",LPsinglebest,LPstart,t,Hcuts[t],LP,N,wtime());
	    else
	      printf("LPsinglebest=%0.10f,LPstart=%0.10f: undoing change at Hcuts[%d]=%0.3f:LP=%0.10f,N=%d\n",LPsinglebest,LPstart,t,Hcuts[t],LP,N);
	    fflush(stdout);
	  }
	  continue;
	}

	if(VERB){
	  printf("WARNING: LPsinglebest=%0.10f,LPstart=%0.10f,LP=%0.10f(undoing all %d changes)\n",LPsinglebest,LPstart,LP, origprogress);
	  fflush(stdout);
	}
	//	progress = origprogress;
	while(progress > 0){
	  int i = changes[--progress];
	  Hdel[i] = 1-Hdel[i];
	  if(VERB>=2){
	    printf("blocking changes at Hcuts[%d]=%0.3f\n",i,Hcuts[i]);
	    fflush(stdout);
	  }
	  skip[i] = 1;/* needed to avoid infinite loop trying to add/delete this set of sites */
	}
	N = setmap(n,Hcuts,Hdel,Y,map[MD],nmap[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	score_init(N,Y,MD,MX,X);/* precompute likelihood scoring constants/terms */
	LP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,newLPA,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);
	if(VERB){
	  if(TIME_VERBOSE)
	    printf("Restored LP=%0.6f (LPstart=%0.6f),N=%d : cum wall time= %0.6f secs\n",LP,LPstart,N,wtime());
	  else
	    printf("Restored LP=%0.6f (LPstart=%0.6f),N=%d\n",LP,LPstart,N);
	  fflush(stdout);
	}
	if(DEBUG && !(LP >= LPstart - 1e-8)){
	  double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  printf("WARNING: failed to undo change : LP=%0.10f(fullLP=%0.10f) (was %0.10f),N=%d\n", LP, qLP,LPstart,N);

	  rverb = 1;
	  qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  rverb = 0;

	  for(int I = 1; I <= N+1; I++)
	    printf("Y[%d]= %0.6f\n",I,Y[I]);
	  
	  double qLPAsum = 0.0, newLPAsum= 0.0, bestLPAsum = 0.0;
	  for(int m = 0; m < MD; m++){
	    /* locate leftmost and rightmost aligned site in X[m] */
	    int left = 1;
	    for(;left <= MX[m]; left++)
	      if(map[m][left] >= 0)
		break;
	    int right = MX[m];
	    for(;right >= 1; right--)
	      if(map[m][right] >= 0)
		break;

	    qLPAsum += qLPA[m];
	    newLPAsum += newLPA[m];
	    bestLPAsum += bestLPA[m];
	    printf("m=%d:qLPA[m]=%0.10f,newLPA[m]=%0.10f,bestLPA[m]=%0.10f(sum=%0.10f,%0.10f,%0.10f): Aligned with Hcuts[%d..%d]= %0.4f .. %0.4f\n",
		   m,qLPA[m],newLPA[m],bestLPA[m],qLPAsum,newLPAsum,bestLPAsum, map[m][left], map[m][right], Hcuts[map[m][left]], Hcuts[map[m][right]]);
	  }
	  fflush(stdout);
	  assert(LP >= LPstart - 1e-6);
	}
	break;
      }
      if(!progress)
	break; //continue;

      if(DEBUG>=2){/* check that full evaluation of qprobeval (without bestLPA) gives same value */
	double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	if(DEBUG>=2 && fabs(qLP - LP) > 1e-8){/* NOTE: see process2/dros_bbvci/trunk: Extension 1 of contig84,contig70(!),contig120, Extension 2 of contig80, Extension 3 of contig39 */
	  register double qLP2 = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,qLPA2,mapWT,bestLPA,Hcuts[imin],Hcuts[imax],0,0,pcontig);
	  if(VERB){
	    printf("qLP=%0.10f,LP=%0.10f(err=%0.10f),resize=%d,qLP2=%0.10f\n",qLP,LP,qLP-LP,resize,qLP2);
	    fflush(stdout);
	  }
	  printf("WARNING:Full qprobeval=%0.10f, LP=%0.10f (err=%0.10f),N=%d\n",qLP, LP, qLP-LP,N);
	  double newcum = 0.0,bestcum=0.0;
	  for(register int m = 0; m < MD; m++){
	    newcum += qLPA[m];
	    bestcum += bestLPA[m];
	    if(fabs(qLPA[m] - newLPA[m]) > 2e-9){
	      int L,R, HL= -1,HR = -1;
	      for(L = 1; L <= MX[m]; L++)
		if((HL = map[m][L]) > 0)
		  break;
	      for(R = MX[m]; R >= 1; R--)
		if((HR = map[m][R]) > 0)
		  break;
	      if(HR >= 0 && HL >= 0)
		printf("m=%d:qLPA[m]=%0.10f,newLPA[m]=%0.10f(err=%0.10f,cum=%0.10f):aligned X[%d..%d]=%0.3f..%0.3f with Hcuts[%d..%d]=%0.3f..%0.3f,qLPA2[m]=%0.10f,bestLPA[m]=%0.10f\n",
		       m,qLPA[m],newLPA[m],newLPA[m]-qLPA[m],bestcum-newcum,L,R,X[m][L], X[m][R], HL, HR,Hcuts[HL],Hcuts[HR],qLPA2[m],bestLPA[m]);
	      else
		printf("m=%d:qLPA[m]=%0.10f,newLPA[m]=%0.10f(err=%0.10f,cum=%0.10f) no aligned region found:L=%d,R=%d,M=%d,qLPA2[m]=%0.10f,bestLPA[m]=%0.10f\n",
		       m,qLPA[m],newLPA[m],newLPA[m]-qLPA[m],bestcum-newcum,L,R,MX[m],qLPA2[m],bestLPA[m]);
	    }
	  }
	  fflush(stdout);
	  if(DEBUG) assert(fabs(qLP - LP) <= 0.1);
	} else if(VERB /* && fabs(qLP - LP) > 1e-8 */){
	  if(TIME_VERBOSE)
	    printf("WARNING: Full qprobeval=%0.10f, LP=%0.1f(err=%0.10f),N=%d,resize=%d : cum wall time= %0.6f secs\n",qLP,LP,qLP-LP,N, resize,wtime());
	  else
	    printf("WARNING: Full qprobeval=%0.10f, LP=%0.1f(err=%0.10f),N=%d,resize=%d\n",qLP,LP,qLP-LP,N, resize);
	  fflush(stdout);
	}
	LP = qLP;
	for(int m = 0; m < MD; m++)
	  newLPA[m] = qLPA[m];
      }

      /* save LP and newLPA[] */
      double newLP = LP;
      for(register int i = 0; i < MD; i++)
	bestLPA[i] = newLPA[i];

      LPstart = newLP;

      if(SPLITRANGE && splitcnt > 1){/* process split ranges seperately */
	for(int t = 0; t < splitcnt-1; t++){
	  if(VERB>=2 || SPEEDCHECK){
	    printf("mprobevalwin(Hcuts[%d..%d]): calling split %d/%d as mprobevalwin(Hcuts[%d..%d]=%0.3f..%0.3f) : cum wall time= %0.6f\n",imin,imax,t+1,splitcnt,splitL[t],splitR[t],Hcuts[splitL[t]],Hcuts[splitR[t]],wtime());
	    fflush(stdout);
	  }
	  tverb = origtverb;
	  LPstart = mprobevalwin(LPstart,bestLPA,newLPA,mapWT,n,Hcuts,Hdel,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,splitL[t],splitR[t],pcontig,trimfactor,resize,MultiMode,skip,Lfrozen,Rfrozen,AddDeleteCnt);
	  tverb = 0;
	}
      }
      if(SPLITRANGE && splitcnt > 0 && (imin < splitL[splitcnt-1] || splitR[splitcnt-1] < imax)){	/* narrow range of current mprobeval to last split range */
	if(VERB>=2 || SPEEDCHECK){
	  printf("mprobevalwin(Hcuts[%d..%d]): narrowing split %d/%d as mprobevalwin(Hcuts[%d..%d]=%0.3f..%0.3f) : cum wall time= %0.6f\n",
		 imin,imax,splitcnt,splitcnt,splitL[splitcnt-1],splitR[splitcnt-1],Hcuts[splitL[splitcnt-1]],Hcuts[splitR[splitcnt-1]],wtime());
	  fflush(stdout);
	}

	/* update idelmin */
	for(int i = imin; i < splitL[splitcnt-1]; i++)
	  idelmin += (Hdel[i] ? 0 : 1);

	imin = splitL[splitcnt-1];
	imax = splitR[splitcnt-1];
      }
    } /* progress */
  }

  /* NOTE : if the following check is disabled, the assertion at line 11905 ("%sAfter mprobevalwin qLP=") may trigger (see /mnt/matrix/jobs/18444) */
  if(DEBUG>=2){/* Update nmap[],nmapK[] and check that full qprobeval matches current LPstart */
    double qLP = qprobeval(n,Hcuts,N,Y,MD,MX,X,lc,rc,map,mapK,limit,nmap,nmapK,TBmapWT,qLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    if(DEBUG && !(fabs(qLP - LPstart) < 1e-7)){
      printf("WARNING:At end of mprobevalwin: Full qprobeval=%0.10f, LP=%0.10f (err=%0.10f)\n",qLP, LPstart, qLP-LPstart);
      double qcum = 0.0,bestcum=0.0;
      for(register int m = 0; m < MD; m++){
	qcum += qLPA[m] * TBmapWT[m];
	bestcum += bestLPA[m] * TBmapWT[m];
	if(fabs(qLPA[m] - bestLPA[m]) * TBmapWT[m] > 1e-8)
	  printf("m=%d:qLPA[m]= %0.10f, bestLPA[m]= %0.10f, TBmapWT[m]= %0.10f (qcum=%0.10f,bestcum=%0.10f, err= %0.10f)\n",
		 m,qLPA[m],bestLPA[m],TBmapWT[m],qcum,bestcum,qcum-bestcum);
      }
      fflush(stdout);
      if(DEBUG>=1+RELEASE) assert(fabs(qLP - LPstart) <= 1e-5);
    }
    if(VERB>=2 || SPEEDCHECK){
      printf("mprobevalwin(Hcuts[%d..%d]): final Full qprobeval= %0.10f, LP=%0.10f (err=%0.10f) : cum wall time= %0.6f secs\n", imin, imax, qLP, LPstart, qLP - LPstart, wtime());
      fflush(stdout);
    }
    LPstart = qLP;
    for(int m = 0; m < MD; m++)
      bestLPA[m] = qLPA[m];
  }

  //  delete [] qLPA2;
  //  delete [] qLPA;

  //  delete [] LPsite;
  //  delete [] splitR;
  //  delete [] splitL;

  //  delete [] changes;
  //  delete [] LPadd;
  //  delete [] LPdel;

  delete [] addid;
  delete [] addloc;

  return LPstart;
}

/** Location and likelihood of refine change. */
class Cchanges {
public:
  int Q;
  double maxLP;
};

#if 0
static int maxLPdec(register Cchanges *p1, register Cchanges *p2)
{
  register double v1 = p1->maxLP, v2 = p2->maxLP;
  return (v1 < v2) ? 1 : (v1 > v2) ? -1 : 0;
}
#endif

static int qLPcnt = 0;

double mprobevalwinResize(int n, double *Hcuts, /**< Hcuts[i0..n+1] : complete consensus map */
			  double qLPstart, /**< value of LP for current Y[] */
			  double *bestLPA,/**< current best per map LP values (and return value) */
			  double *newLPA,/**< per map LP values (scratch memory) */
			  double *mapWT,
			  int &N, double *Y,/**< original consensus map */
			  int MD, /**< number of maps */
			  int *MX, double **X, /**< X[m=0..MD-1][j=0..MX[m]+1] : map sites */
			  int lc,/**< If left end of Y is a linear chromosome end */
			  int rc,/**< If right end of Y is a linear chromosome end */
			  int **map, /**< map[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts[0..n+1] of X[m][j], 
						 map[MD][j=0..n+1] is index in Y[0..N+1] of Hcuts[j] */
			  int **mapK, /**< mapK[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts[0..n+1] of X[m][j] */ 
			  Csetlimit *limit,/* see setlimit() */
			  int **nmap, /**< nmap[m=0..MD-1][j=0..MX[m]+1] is new index in Y[0..N+1] of X[m][j], 
						  nmap[MD][j=0..N+1] is index in Hcuts[0..n+1] of Y[j] */
			  int **nmapK, /**< nmapK[m=0..M-1][j=0..MX[m]+1] will be new K index offset in Y[0..N+1] of X[m][j]
						   However nmapK[0] == Lij, mapK[MX[m]+1] == Rij (-ve if ends are outliers) */
			  double *TBmapWT, /**< If != 0 : TBmapWT[m] is a the -TB based weight for map m to be applied when summing up the total log(LR+LRbias) value(s) */
			  int *Ycnt,
			  Cydist **Ydist,/* Ydist[Q][0..Ycnt[Q]-1] are the sample values for interval Y[Q .. Q+1] : each value based on a molecule interval aligning to Y[Q .. Q+1] */
			  double *newY,/**< newY[0..N+1] is the quick initial estimate of Y based on KDmean */
			  int Imin, int Imax, /**< Only interested in changes in to intervals Y[Imin..Imax] */
			  int *MMforce,/* MMforce[Q] == 1 IFF interval fixYdel[Q+1] == fixY[Q+1] - fixY[Q] should be changed */
			  double *fixY, /**< fixY[I] == curent estimate of Y[I] (initially same as Y[] except for end intervals) */
			  double *fixYdel,/**< fixYdel[Q+1] == fixY[Q+1] - fixY[Q] */
			  Ccontig *pcontig, /**< pointer to complete contig information for debugging */
			  int nochange,
			  int LfrozenI, int RfrozenI,
			  double &trimfactor, /**< The trimmed mean parameters : smallest value 0 corresponds to normal mean
						 largest value 0.5 corresponds to median */
			  int &Lfrozeni, int &Rfrozeni
			  )
{
  if(DEBUG) assert(MMforce != 0);
  if(DEBUG) assert(nochange <= 0);

  if(DEBUG>=2){  /* make sure no real cuts are closer than minKB */
    for(register int I = 1; I < N; I++)
      if(DEBUG && (!(fixY[I+1]-fixY[I] >= minKB - 2e-9) /* || (360 <= I && I <= 380)*/)){
	printf("mprobevalwinResize start:I=%d:Y[I]=%0.6f,Y[I+1]=%0.6f, delta=%0.6f, minKB=%0.6f\n",
	       I,fixY[I],fixY[I+1], fixY[I+1]-fixY[I], minKB);
	fflush(stdout);
	assert(fixY[I+1]-fixY[I] >= minKB - 2e-9);
      }
    assert(fixY[1] >= fixY[0]);
    if(DEBUG && !(fixY[N+1] >= fixY[N])){
      printf("N=%d,fixY[N]=%0.6f,fixY[N+1]=%0.6f\n",
	     N,fixY[N],fixY[N+1]);
      fflush(stdout);
      assert(fixY[N+1] >= fixY[N]);
    }
  }

  int numthreads = 1;
  #ifdef _OPENMP
  numthreads = MaxThreads; // WAS omp_get_max_threads();
  if(RefineThreads > 0)
    numthreads = min(numthreads,RefineThreads);
  if(DEBUG) assert(numthreads >= 1);
  #endif

  if(VERB && rverb){
    printf("mprobevalwinResize():N=%d,Imin=%d,Imax=%d,nochange=%d,LfrozenI=%d,RfrozenI=%d\n",N,Imin,Imax,nochange,LfrozenI,RfrozenI);
    fflush(stdout);
  }

  int nthreads = max(1,min(numthreads,N/64));

  double qLP = qLPstart;

  int *D = new int[N+2];
  int *Dsiz = new int[N+1];
  double *LPdel = new double[N+1];  
  double **delta = new double*[N+1];
  double **LPdelta = new double*[N+1];

  /* allocate LPdelta based on largest space needed */
  if(DEBUG)
    for(register int I=0; I <= N; I++)
      delta[I] = 0;
  for(register int I=1; I < N; I++){
    register int siz = max(20,1+2*MULTIMODE_MP);
    Dsiz[I] = siz;
    delta[I] = new double[siz];
    LPdelta[I] = new double[siz];
  }

  double *Xmid = new double[N+1];
#if MSAN
  for(int i = 0; i <= N; i++)
    Xmid[i] = aNaN;
    //  __msan_poison(Xmid, (N+1)*sizeof(double));/* mark as uninitialized */
#endif
  double *Xlow = new double[N+1];
  double *Xhigh = new double[N+1];
  double *Xnew = new double[N+1];
  double *Xbest = new double[N+1];/* only used if QUICKUPDATE */
  double *maxLP = new double[N+1];
  double *conflictLP = new double[N+1];/* conflictLP[Q] is max(t=0..MULTIMODE_MP_CONFLICT) max(maxLP[Q-t],max(mLP,maxLP[Q])-1e-6,maxLP[Q+t]) : IF !MULTIMODE_FIX4 
					                   max(t=0..MULTIMODE_MP_CONFLICT) max(peakLP[Q-t],max(mLP,peakLP[Q])-1e-6,maxLP[Q+t]) : IF MULTIMODE_FIX4 */
  Cchanges *changes = new Cchanges[N+1];

  if(VERB>=2){
    printf("mprobevalwinResize:N=%d,D = %p\n",N, D);
    if(VERB>=2){
      long long VmSize,VmRSS,VmSwap;
      getmem(VmSize,VmRSS,VmSwap);
      printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmSwap= %0.4f Gb: wall time= %0.6f secs\n",VmSize*1e-6,VmRSS*1e-9,VmSwap*1e-9,wtime());
    }

    fflush(stdout);
  }

  /* compute initial D[],delta[] based on sample values (or ladder of values if MULTIMODE_FIX==1) */
  D[0] = D[N] = D[N+1] = -1; /* D[Q] = -1 means do not process interval Q (ignore), 0 means processing of interval Q has completed */
  int Dcnt = 0, DcntT = 0;
  for(int Q = 1; Q < N; Q++){
    int siz = Dsiz[Q];
    D[Q] = 0;

    if(extend && extendonly && Refine && Rfrozeni > Lfrozeni && Q >= LfrozenI && Q+1 <= RfrozenI){ /* Y[Q..Q+1] is in frozen range Y[LfrozenI .. RfrozenI] */
      if(VERB>=2){
	printf("Q=%d/%d:Y[Q]=%0.3f,cnt=%d:",Q,N,Y[Q],Ycnt[Q]);
	printf("Located in frozen region Y[%d..%d]=%0.3f..%0.3f, Hcuts[%d..%d]=%0.3f..%0.3f (will not be modified)\n", 
	       LfrozenI, RfrozenI, Y[LfrozenI], Y[RfrozenI], Lfrozeni,Rfrozeni,Hcuts[Lfrozeni],Hcuts[Rfrozeni]);
	fflush(stdout);
      }
      D[Q] = -1;
      continue;
    }
    if(Q >= Imax || Q+1 <= Imin){/* Y[Q..Q+1] is outside of range of interest Y[Imin..Imax] */
      if(VERB>=2){
	printf("Q=%d/%d:Y[Q]=%0.3f,cnt=%d:",Q,N,Y[Q],Ycnt[Q]);
	printf("Located outside Y[Imin..Imax] (Y[%d..%d]=%0.3f..%0.3f) (will not be modified)\n", 
	       Imin,Imax, Y[Imin],Y[Imax]);
	fflush(stdout);
      }
      D[Q] = -1;
      continue;
    }

    int rcnt = 0;      
    double lastval = 0.0;
    if(VERB>=2){
      for(int t = 0; t < Ycnt[Q]; t++){
	double val = Ydist[Q][t].val;
	if(DEBUG && t > 0) assert(val >= Ydist[Q][t-1].val);
	if(MULTIMODE_DELTA != 0.0 && t > 0 && t < Ycnt[Q]-1 && Ydist[Q][t+1].val - lastval <= max(MULTIMODE_DELTA_MIN,MULTIMODE_DELTA*lastval))
	  continue;
	if(val <= minKB + 1e-6)
	  continue;
	
	lastval = val;
	rcnt++;
      }
      if(VERB>=2 && Q==8){
	printf("Q=%d/%d:Y[Q]=%0.3f,cnt=%d(%d):\n",Q,N,Y[Q],Ycnt[Q],rcnt);
	fflush(stdout);
      }
    }

    int resolved = 0;
    double sum = 0.0;
    if(VERB>=2){
      for(int k = 0; k < Ycnt[Q]; k++){
	if(Ydist[Q][k].wt >= 0.99){
	  resolved++;
	  sum += Ydist[Q][k].val;
	}
	printf("%0.3f(w=%0.3f) ",Ydist[Q][k].val,Ydist[Q][k].wt);
      }
    }

    if(!MMforce[Q]){
      if(VERB>=2){
	printf("res=%d,mean=%0.3f\n", resolved, sum/max(1,resolved));
	printf("  skipped changing Y[%d..%d]=%0.3f,Y[1]=%0.3f,Y[Q]=%0.3f,Y[N]=%0.3f,Y[N+1]=%0.3f: LP=%0.4f MMforce[Q,Q+1]=%d,%d\n",
	       Q,Q+1,fixYdel[Q+1], Y[1], Y[Q], Y[N], Y[N+1], qLP, MMforce[Q], (Q+1 <= N) ? MMforce[Q+1] : 0);
	fflush(stdout);
      }
      D[Q] = -1;
      continue;
    }
    Dcnt++;

    double origval = fixYdel[Q+1];
    double newval = newY[Q+1] - newY[Q];
    if(VERB>=2){
      printf("Q=%d/%d:Y[Q]=%0.3f,cnt=%d(%d):",Q,N,Y[Q],Ycnt[Q],rcnt);
      printf("res=%d,mean=%0.3f,origval=%0.3f,KDmean=%0.3f %s\n", 
	     resolved, sum/max(1,resolved),origval,newval, fabs(newval - origval) > 1e-3 ? "" : "(skipped)");
      fflush(stdout);
    }
    if(fabs(newval - origval) > min(1e-3, 1e-3 * origval)){
      if(VERB>=2 || SVERB){
	printf("  Y[%d..%d]=%0.6f->%0.6f=newval (delta[Q][%d]=%0.6f)\n",
	       Q,Q+1,Y[Q+1]-Y[Q],newval,D[Q],newval-origval);
	fflush(stdout);
      }
      if(DEBUG && !(D[Q] >= 0 && D[Q] < siz)){
	for(int r = 0; r < siz; r++)
	  printf("delta[Q][%d]= %0.3f\n",r,delta[Q][r]);
	printf("next delta=%0.3f,origval=%0.3f\n",newval-origval,origval);
	printf("Q=%d:D[Q]=%d,Dsiz[Q]=%d,siz=%d\n",Q,D[Q],Dsiz[Q],siz);
	fflush(stdout);
	

	assert(siz == Dsiz[Q]);
	assert(D[Q] >= 0 && D[Q] < siz);
      }
      delta[Q][D[Q]++] = newval - origval;
    }

    if(!MULTIMODE_FIX /* || !((MULTIMODE_MAXRANGE > 1.0 || MULTIMODE_MINRANGE < 1.0) && MULTIMODE_DELTA >= max(MULTIMODE_MP_MIN,MULTIMODE_MP_MAX))*/){
      if(VERB>=2 || SVERB){
	if(MULTIMODE_DELTA > 0.0)
	  printf("Trying some of %d sample values for Y[%d..%d](minimum ratio = %0.2f, minimum spacing = %0.2f):\n",Ycnt[Q],Q,Q+1,1.0+MULTIMODE_DELTA, MULTIMODE_DELTA_MIN);
	else
	  printf("Trying some of %d sample values for Y[%d..%d]:\n",Ycnt[Q],Q,Q+1);
	fflush(stdout);
      }
      lastval = -(MULTIMODE_DELTA_MIN);
      if(DEBUG) assert(D[Q] >= 0);

      for(int t = 0; t < Ycnt[Q]; t++){
	double val = Ydist[Q][t].val;
	if(DEBUG && t > 0) assert(val >= Ydist[Q][t-1].val);

	if(MULTIMODE_DELTA != 0.0 && t > 0 && (DELTA_FIX5==0 ? /* always includes last value Ydist[Q][Ycnt[Q]-1].val (!) */
					       ((!MPROBEVAL_FIX || t < Ycnt[Q]-1) && (MPROBEVAL_FIX ? Ydist[Q][t+1].val : val) - lastval <= max(MULTIMODE_DELTA_MIN, MULTIMODE_DELTA*lastval))
					       : (((MPROBEVAL_FIX && t < Ycnt[Q]-1) ? Ydist[Q][t+1].val : val) - lastval <= max(MULTIMODE_DELTA_MIN, MULTIMODE_DELTA*lastval)))){
	  if(VERB/* HERE >=3 */ && SVERB){
	    printf("    Y[%d..%d]=%0.3f->%0.3f: skipping since %s=%0.3f is too close to previous value %0.3f (min diff= %0.3f)\n",
		   Q,Q+1,Y[Q+1]-Y[Q],val, 
		   (MPROBEVAL_FIX && t < Ycnt[Q] - 1) ? "next value Ydist[Q][t+1]" : "value",
		   (MPROBEVAL_FIX && t < Ycnt[Q] - 1) ? Ydist[Q][t+1].val : val, 
		   lastval, max(MULTIMODE_DELTA_MIN, MULTIMODE_DELTA*lastval));
	    fflush(stdout);
	  }
	  continue;
	}
	if(t > 0 && val <= lastval + 1e-6){// NEW
	  if(VERB/* HERE >=3 */ && SVERB){
	    printf("    Y[%d..%d]=%0.6f->%0.6f: skipping since value is same as previous value %0.6f (min diff= 1e-6)\n", Q,Q+1,Y[Q+1]-Y[Q],val,lastval);
	    fflush(stdout);
	  }
	  continue;
	}

	if(val <= minKB + 1e-6){
	  if(VERB/* HERE >=3 */ && SVERB){
	    printf("    Y[%d..%d]=%0.3f->%0.3f: skipping since it is <= minKB(=%0.3f)\n",
		   Q,Q+1,Y[Q+1]-Y[Q],val,minKB);
	    fflush(stdout);
	  }
	  continue;
	}

	if(fabs(val - origval) > 1e-3 && fabs(val - newval) > 1e-3){
	  if(VERB>=2 || SVERB){
	    printf("  Y[%d..%d]=%0.6f->%0.6f (delta[Q][%d]=%0.6f) : origval=%0.6f,newval=%0.6f:Ydist[Q][%d].val=%0.6f,val=%0.6f,lastval=%0.6f,nextval=%0.6f(min diff=%0.6f)\n",
		   Q,Q+1,Y[Q+1]-Y[Q],val,D[Q],val-origval, origval, newval, t, Ydist[Q][t].val, val,lastval, (MPROBEVAL_FIX && t < Ycnt[Q]-1) ? Ydist[Q][t+1].val : val, 
		   max(MULTIMODE_DELTA_MIN, MULTIMODE_DELTA*lastval));
	    fflush(stdout);
	  }
	  if(!(D[Q] < siz)){
	    Dsiz[Q] = siz + 20;
	    double *newdelta = new double[Dsiz[Q]];
	    memcpy(newdelta,delta[Q],siz * sizeof(double));
	    delete [] delta[Q];
	    delete [] LPdelta[Q];
	    siz = Dsiz[Q];
	    delta[Q] = newdelta;
	    LPdelta[Q] = new double[siz];
	  }
	  if(DEBUG>=2 && !(D[Q] < siz)){
	    for(int r = 0; r < siz; r++)
	      printf("delta[Q][%d]= %0.3f\n",r,delta[Q][r]);
	    printf("next delta=%0.3f,origval=%0.3f,t=%d,Ycnt[Q]=%d\n",newval-origval,origval,t,Ycnt[Q]);
	    printf("Q=%d:D[Q]=%d,Dsiz[Q]=%d,siz=%d\n",Q,D[Q],Dsiz[Q],siz);
	    fflush(stdout);

	    assert(siz == Dsiz[Q]);
	    assert(D[Q] < siz);
	  }
	  delta[Q][D[Q]++] = val - origval;
	}
	/* ignored KD_MIN check : not needed to achieve speed */
	lastval = val;
      } /* t = 0 .. Ycnt[Q] - 1  */
    } /* if(!MULTIMODE_FIX) */

    DcntT += D[Q];
  }

  if(!Dcnt){/* all MMforce[] are 0 */
    delete [] changes;
    delete [] maxLP;
    delete [] conflictLP;
    delete [] Xbest;
    delete [] Xnew;
    delete [] Xhigh;
    delete [] Xlow;
    delete [] Xmid;
    for(register int I = 1 ; I < N; I++){
      delete [] delta[I];
      delete [] LPdelta[I];
    }
    delete [] LPdelta;
    delete [] delta;
    if(VERB && rverb){
      printf("mprobevalwinResize:N=%d,D = %p: returning qLP=%0.6f\n",N, D,qLP);
      fflush(stdout);
    }
    delete [] LPdel;
    delete [] Dsiz;
    delete [] D;

    return qLP;
  }

  /* D[] and delta[] have been initialized */
  int ifirst = -1, ilast = -1;/* range of intervals Y[ifirst .. ilast+1] over which changes are being checked */
  Dcnt = DcntT = 0;
  for(int Q=1; Q < N; Q++){
    if(D[Q] < 0)
      continue;
    if(D[Q] > 1)
      qsort(delta[Q],D[Q],sizeof(double),(intcmp *)doubleInc);
    if(VERB>=3 && Q==31){
      for(int d = 0; d < D[Q]; d++)
	printf("delta[%d][%d]=%0.6f\n",Q,d,delta[Q][d]);
      fflush(stdout);
    }
    if(DEBUG>=2){
      for(int d = 1; d < D[Q]; d++){
	if(!(delta[Q][d] > delta[Q][d-1])){
	  for(int t = 0; t < D[Q]; t++)
	    printf("delta[%d][%d]=%0.6f\n",Q,t,delta[Q][t]);
	  printf("Q=%d,d=%d,delta[Q][d]=%0.6f,delta[Q][d-1]=%0.6f\n",Q,d,delta[Q][d],delta[Q][d-1]);
	  fflush(stdout);
	  assert(delta[Q][d] > delta[Q][d-1]);
	}
      }
    }

    if(MULTIMODE_MAXRANGE > 1.0 || MULTIMODE_MINRANGE < 1.0){
      int origD = D[Q];
      double origval = fixYdel[Q+1];
      double maxval = origval * MULTIMODE_MAXRANGE;
      double minval = max(minKB, origval * MULTIMODE_MINRANGE);
      if(/* !MULTIMODE_FIX && */ Ycnt[Q] > 0){
	minval = min(minval, Ydist[Q][0].val);
	minval = max(minval, minKB);
	maxval = max(maxval, Ydist[Q][Ycnt[Q]-1].val);
      }

      if(VERB>=2 || SVERB){
	if(D[Q] > 0)
	  printf("\t Q=%d: Scanning Y[Q..Q+1] from %0.7f .. %0.7f and %0.7f .. %0.7f (minKB=%0.6f): origval=%0.7f,D[Q]=%d,DELTA=%0.2f%%,DELTA_MIN= %0.4f kb\n",
		 Q,minval,delta[Q][0]+origval, delta[Q][D[Q]-1]+origval, maxval,minKB,origval,D[Q],MULTIMODE_DELTA*100.0,MULTIMODE_DELTA_MIN);
	else
	  printf("\t Q=%d: Scanning Y[Q..Q+1] from %0.7f .. %0.7f (minKB=%0.6f): origval=%0.7f,D[Q]=%d\n",
		 Q,minval,maxval,minKB,origval,D[Q]);
	fflush(stdout);
      }

      double val = (origD > 0) ? origval + delta[Q][0] : origval;
      double ratio = (DELTA_FIX4 <= 0) ? MULTIMODE_DELTA : 1.0 - 1.0/(1.0+MULTIMODE_DELTA);
      while(val > minval){
	if(MULTIMODE_FIX)
	  val -= max(val * ratio, MULTIMODE_DELTA_MIN);
	else if(MPROBEVAL_FIX)
	  val -= max(val * MULTIMODE_MP_MIN, MULTIMODE_DELTA_MIN);
	else {
	  if(val*MULTIMODE_MP_MIN < MULTIMODE_DELTA_MIN)
	    val -= MULTIMODE_DELTA_MIN;
	  else
	    val *= (1.0-MULTIMODE_MP_MIN);
	}
	val = max(minKB,val);
	if(DELTA_FIX3 && fabs(val - origval) <= 1e-8)
	  continue;
	if(D[Q] >= Dsiz[Q]){// reallocate memory
	  if(DEBUG && Dsiz[Q] > 1000){
	    for(int t = 0; t < D[Q]; t++)
	      printf(" delta[%d][%d]=%0.6f\n",Q,t,delta[Q][t]);
	    printf("WARNING: Q=%d,Y[Q..Q+1]=%0.6f,D[Q]=%d,val=%0.6f,minKB=%0.6f,minval=%0.6f:\n",Q,Y[Q+1]-Y[Q],D[Q],val,minKB,minval);
	    fflush(stdout);
	    break;
	  }
	  double *newdel = new double[Dsiz[Q] + 20];
	  for(int k = Dsiz[Q]; --k >= 0;)
	    newdel[k] = delta[Q][k];
	  Dsiz[Q] += 20;
	  delete [] delta[Q];
	  delete [] LPdelta[Q];
	  delta[Q] = newdel;
	  LPdelta[Q] = new double[Dsiz[Q]];
	}
	if(VERB>=2 || SVERB){
	  printf("  Y[%d..%d]=%0.7f->%0.7f (delta[Q][%d]=%0.7f) : origval=%0.7f\n",
		 Q,Q+1,Y[Q+1]-Y[Q],val,D[Q],val-origval, origval);
	  fflush(stdout);
	}
	delta[Q][D[Q]++] = val - origval;
      }

      if(MULTIMODE_MINKB && val > minKB + 1e-6){/* add MinKB to sizes being scanned : needed to remove bogus intervals */
	if(D[Q] >= Dsiz[Q]){// reallocate memory
	  if(DEBUG && Dsiz[Q] > 1000){
	    for(int t = 0; t < D[Q]; t++)
	      printf(" delta[%d][%d]=%0.6f\n",Q,t,delta[Q][t]);
	    printf("WARNING: Q=%d,Y[Q..Q+1]=%0.6f,D[Q]=%d,val=%0.6f,minKB=%0.6f,minval=%0.6f:\n",Q,Y[Q+1]-Y[Q],D[Q],val,minKB,minval);
	    fflush(stdout);
	    break;
	  }
	  double *newdel = new double[Dsiz[Q] + 20];
	  for(int k = Dsiz[Q]; --k >= 0;)
	    newdel[k] = delta[Q][k];
	  Dsiz[Q] += 20;
	  delete [] delta[Q];
	  delete [] LPdelta[Q];
	  delta[Q] = newdel;
	  LPdelta[Q] = new double[Dsiz[Q]];
	}
	if(VERB>=2 || SVERB){
	  printf("  Y[%d..%d]=%0.7f->%0.7f (delta[Q][%d]=%0.7f) : origval=%0.7f\n",
		 Q,Q+1,Y[Q+1]-Y[Q],minKB,D[Q],minKB-origval, origval);
	  fflush(stdout);
	}
	delta[Q][D[Q]++] = minKB - origval;	
      }

      val = (origD > 0) ? origval + delta[Q][origD-1] : origval;
      while(val < maxval){
	if(MULTIMODE_FIX)
	  val += max(val*MULTIMODE_DELTA, MULTIMODE_DELTA_MIN);
	else if(MPROBEVAL_FIX)
	  val += max(val*MULTIMODE_MP_MAX, MULTIMODE_DELTA_MIN);
	else {
	  if(val*MULTIMODE_MP_MIN < MULTIMODE_DELTA_MIN)
	    val += MULTIMODE_DELTA_MIN;
	  else
	    val *= (1.0+MULTIMODE_MP_MAX);
	}

	if(DELTA_FIX3 && fabs(val - origval) <= 1e-8)
	  continue;

	if(D[Q] >= Dsiz[Q]){
	  if(DEBUG && Dsiz[Q] > 1000){
	    for(int t = 0; t < D[Q]; t++)
	      printf(" delta[%d][%d]=%0.6f\n",Q,t,delta[Q][t]);
	    printf("WARNING: Q=%d,Y[Q..Q+1]=%0.6f,D[Q]=%d,val=%0.6f,minKB=%0.6f,maxval=%0.6f:\n",Q,Y[Q+1]-Y[Q],D[Q],val,minKB,maxval);
	    fflush(stdout);
	    break;
	  }
	  register double *newdel = new double[Dsiz[Q] + 20];
	  for(register int k = Dsiz[Q]; --k >= 0;)
	    newdel[k] = delta[Q][k];
	  Dsiz[Q] += 20;
	  delete [] delta[Q];
	  delete [] LPdelta[Q];
	  delta[Q] = newdel;
	  LPdelta[Q] = new double[Dsiz[Q]];
	}
	if(VERB>=2 || SVERB){
	  printf("  Y[%d..%d]=%0.7f->%0.7f (delta[Q][%d]=%0.7f) : origval=%0.7f\n",
		 Q,Q+1,Y[Q+1]-Y[Q],val,D[Q],val-origval, origval);
	  fflush(stdout);
	}
	delta[Q][D[Q]++] = val - origval;
      }

      if(D[Q] > origD)
	qsort(delta[Q],D[Q],sizeof(double),(intcmp *)doubleInc);
      if(VERB>=2 && Q==31 && D[Q] > 0){
	printf("Q=%d:D[Q]=%d->%d:minval=%0.3f,maxval=%0.3f,delta[Q][0]=%0.3f,delta[Q][%d]=%0.3f\n",
	       Q,origD,D[Q],minval,maxval,delta[Q][0]+origval,D[Q]-1,delta[Q][D[Q]-1]+origval);
	for(int d = 0; d < D[Q]; d++)
	  printf("delta[%d][%d]=%0.6f\n",Q,d,delta[Q][d]);
	fflush(stdout);
      }
    }
    if(D[Q] > 0){
      if(ifirst<0)
	ifirst = Q;
      ilast = Q;

      DcntT += D[Q];
      Dcnt++;
    }
  }

  int ifirstP = ifirst, ilastP = ilast;/* range Y[ifirstP .. ilastP+1] that has changed since the last time qLP,bestLPA[] were updated (or range Y[ifirst .. ilast+1], whichever is larger) */

  if(DEBUG && !(ifirst >= 0 && ilast >= ifirst && ilast <= N)){
    printf("calling mprobeval(%d..%d,LPdelta):Dcnt=%d(sum=%d),N=%d:",ifirstP,ilastP,Dcnt,DcntT,N);
    for(register int Q=1;Q < N; Q++)
      printf("Q=%d:D[Q]=%d\n",Q,D[Q]);
    fflush(stdout);
    assert(ifirst >= 0 && ilast >= ifirst && ilast <= N);
  }

  /* free newLPa[] */
  if(MDEBUG && newLPaPr[0]) { delete [] newLPaPr[0]; newLPaPr[0] = 0;}
  if(!VMEM_MINIMIZE){
    if(newLPa[0]) { free(newLPa[0]); newLPa[0] = 0;}
  }
  MaxAddcnt = 0;
  if(HEAP_MINIMIZE){/* free lightweight heap to minimize real memory usage */
    delete heap;
    heap = new lightweight_heap(0,0);      
  }

  if(N > NmaxLP || VMEM_MINIMIZE){/* need to reallocate NmaxLP dependent arrays */
    NmaxLP = VMEM_MINIMIZE ? N : (N*5)/4;
    size_t siz = ((size_t)MD) * (NmaxLP + 2ul);

    if(!VMEM_MINIMIZE){/* NEW8 */
      /* reallocate newLPd[] */
      delete [] newLPd[0];

      try {/* allocate initial memory for newLPd[] */
	newLPd[0] = new double[siz];
      } catch (exception& e){
	cout << e.what() << endl;
	printf("refine(): exception thrown while re-allocating newLPd[]:NmaxLP=%d,MD=%d,N=%d,siz=%lu\n",NmaxLP,MD,N,siz);
	fflush(stdout);
	assert(0);
      }
      for(long long m = 1; m < MD; m++)
	newLPd[m] = newLPd[0] + m * (NmaxLP + 2ul);
      if(MDEBUG)
	for(register int m = 0; m < MD; m++)
	  for(register int S = 0; S <= N+1; S++)
	    newLPd[m][S] = LARGE_NEGATIVE;
    }

    if(MDEBUG){/* NEW8 */
      delete [] newLPdPr[0];
      newLPdPr[0] = new int[siz];
      for(long long m = 1; m < MD; m++)
	newLPdPr[m] = newLPdPr[0] + m * (NmaxLP + 2ll);
    }

    /* reallocate Dcum[] */
    delete [] Dcum;
    Dcum = new int[NmaxLP+2];
  }

  for(int sum = 0, Q = 0; Q < N; Q++){
    Dcum[Q] = sum;
    sum += max(0,D[Q]);
  }
  if(DEBUG) assert(Dcum[N-1] + max(0,D[N-1]) == DcntT);
  Dcum[N] = DcntT;

  if(DEBUG) assert(NmaxLP >= N);

  if(VMEM_MINIMIZE)
    DoubleAllocations_free();

  if(!VMEM_MINIMIZE){ /* reallocate newLPdelta[m][S,d] if needed */
    if(newLPdeltaMem){
      free(newLPdeltaMem);
      newLPdeltaMem = 0;
    }
    if(VERB>=2){
      //      dumpmemmap();
      printf("Reallocating newLPdelta[]: DcntT=%d,MaxDelta=%d->%d\n",DcntT,MaxDelta,DcntT);
      if(VERB>=2){
	long long VmSize,VmRSS,VmSwap;
	getmem(VmSize,VmRSS,VmSwap);
	printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmSwap= %0.4f Gb: wall time= %0.6f secs\n",VmSize*1e-6,VmRSS*1e-9,VmSwap*1e-9,wtime());
      }
      fflush(stdout);
    }
    MaxDelta = DcntT;
    long long siz = ((long long)MD)*MaxDelta;
    newLPdeltaMem = (double *)malloc(siz * sizeof(double));
    if(!newLPdeltaMem){
      printf("mprobevalwinResize(): malloc failed for newLPdeltaMem[],siz=%lld\n",siz);
      fflush(stdout);
      exit(1);
    }
    if(VERB>=3){
      printf("reallocated newLPdeltaMem=%p..%p(siz=%lld,MD=%d,MaxDelta=%d)\n",newLPdeltaMem, &newLPdeltaMem[siz-1],siz,MD,MaxDelta);
      if(VERB>=2){
	long long VmSize,VmRSS,VmSwap;
	getmem(VmSize,VmRSS,VmSwap);
	printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmSwap= %0.4f Gb: wall time= %0.6f secs\n",VmSize*1e-6,VmRSS*1e-9,VmSwap*1e-9,wtime());
      }
      fflush(stdout);
    }
    long long DeltaCnt = 0;
    for(int m = 0; m < MD; m++){
      newLPdelta[m] = &newLPdeltaMem[DeltaCnt];
      DeltaCnt += DcntT;
    }
    if(DEBUG) assert(DeltaCnt <= ((long long)MD)*MaxDelta);

    if((MDEBUG && (MDEBUG_DELTA || (MDEBUG_TS >= 0 &&  MDEBUG_TT >= 0)) && MDEBUG_T < 0 && MDEBUG_S < 0) || DEBUG>=2)
      for(int m = 0; m < MD; m++)
	for(int d = 0; d < DcntT; d++)
	  newLPdelta[m][d] = LARGE_NEGATIVE;
  }

  if(VERB>=2){
    printf("After reallocating newLPdeltaMem:\n");
    if(VERB>=2){
      long long VmSize,VmRSS,VmSwap;
      getmem(VmSize,VmRSS,VmSwap);
      printf("\t VmSize= %0.4f, VmRSS= %0.4f, VmSwap= %0.4f Gb: wall time= %0.6f secs\n",VmSize*1e-6,VmRSS*1e-9,VmSwap*1e-9,wtime());
    }
      //    dumpmemmap();
    fflush(stdout);
  }

  // MDEBUG = 0;
  //  if(ifirstP==64 && ilastP==103 && Dcnt == 40 && DcntT==50){
  //          MDEBUG = 1;
  //          MDEBUG_M = 140;
    //    MDEBUG_TS = 90;
    //    MDEBUG_TT = 11;
//  }

  double start = mtime(),wstart = wtime();
  if(VERB>=2 || SVERB || ERRPLOT || SPEEDCHECK){
    printf("mprobeval(%d..%d,LPdelta):Dcnt=%d(sum=%d),N=%d:",ifirstP,ilastP,Dcnt,DcntT,N);
    fflush(stdout);
  }
  //  rverb = (ifirstP==1 && ilastP==86 && Dcnt == 86 && DcntT==1568) ? 1 : 0;
  double mLP = mprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap[MD],TBmapWT,newLPA,bestLPA,fixY[ifirstP],fixY[ilastP+1],0,0,D,delta, /* LPdel */0,
			 0,0,LPdelta,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,newLPdelta,Dcum,AminM,AmaxM,pcontig,0,0);
  //  rverb = 0;
  tverb = 0;

  if(VERB>=2 || SVERB || ERRPLOT || SPEEDCHECK){
    double wt = wtime();
    printf("mLP=%0.6f(err=%0.6f):time=%0.6f, wall time=%0.6f(cum=%0.6f),minKB=%0.6f\n",mLP,mLP-qLP,mtime()-start, wt-wstart,wt,minKB);
    //    printf("\t Y[1]=%0.3f,Y[2]=%0.3f,Y[N+1=%d]=%0.3f\n",fixY[1],fixY[2],N+1,fixY[N+1]);
    if(VERB>=2)
      dumpmemmap();
    if(VERB>=3)/* display last 600 labels */
      for(int I = max(0, N-600); I <= N+1; I++)
	printf("\tfixY[%d]= %0.6f\n", I, fixY[I]);
    fflush(stdout);
    //    exit(1);
  }
  if(DEBUG>=1+RELEASE && !(fabs(qLP-mLP) < (USE_MFLOAT ? 1e-6 + EPS2 * 1000.0 : 1e-7 + EPS2 * 100.0) * MD)){
    double *fullLPA = new double[MD];
    //    rverb = 1;
    double qLP2 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,fullLPA,mapWT,0,0.0,0.0,0,0,pcontig);
    //    rverb = 0;
    printf("WARNING:mLP=%0.8f,qLP=%0.8f,err=%0.8f(EPS2*MD=%0.8f):qLP2=%0.8f(delta=%0.8f)\n",mLP,qLP,mLP-qLP,EPS2*MD,qLP2,qLP2-qLP);
    if(DEBUG>=1+RELEASE)
      for(int m = 0; m < MD; m++)
	if((fabs(bestLPA[m]-fullLPA[m]) >= 1e-7 || fabs(fullLPA[m]-newLPA[m]) >= 1e-7 + EPS2*100.0) && TBmapWT[m] > 0.0)
	  printf("m=%d:bestLPA[m]=%0.8f,newLPA[m]=%0.8f(err=%0.8f),fullLPA[m]=%0.8f, TBmapWT= %0.10f\n",m,bestLPA[m],newLPA[m],newLPA[m]-fullLPA[m],fullLPA[m],TBmapWT[m]);
    fflush(stdout);
    delete [] fullLPA;
    if(DEBUG>=2) assert(fabs(qLP-mLP) < (USE_MFLOAT ? 1e-5 + EPS2 * 100000.0 : 1e-6 + EPS2*1000.0) * MD);
  }

  qLP = mLP;

  if(MDEBUG && (MDEBUG_DELTA || (MDEBUG_TS >= 0 &&  MDEBUG_TT >= 0)) && MDEBUG_T < 0 && MDEBUG_S < 0){
    double *testLPA = new double[MD];
    
    double maxerr = -1000.0;/* worst error for any single interval change for LP sum over all maps */
    int maxerrT = -1;/* interval left site, corresponding to worst error */
    int maxerrD = -1;/* change value index, corresponding to worse error */

    double ErrMax = -1000.0;/* worst error for any single interval change for any single map */
    double trueLP = -1000.0;
    int maxM = -1;/* map index */
    int maxT = -1;/* interval left site */
    int maxD = -1;/* change value index */
    double maxWT = 0.0;

    for(register int Q=1; Q < N; Q++){
      if(D[Q] <= 0)
	continue;
      double origval = fixYdel[Q+1];
      for(register int t = 0; t < D[Q]; t++){
	if((MDEBUG_TS < 0 || Q==MDEBUG_TS) && (MDEBUG_TT < 0 || t==MDEBUG_TT) && MDEBUG_T < 0 && MDEBUG_S < 0){
	  register double testLP = LPdelta[Q][t];
	  register double val = delta[Q][t] + origval;
	  fixYdel[Q+1] = val;

	  register double cum = 0.0;
	  fixY[0] = cum;
	  for(register int I = 1; I <= N+1; I++){
	    cum += fixYdel[I];
	    fixY[I] = cum;
	  }
	  /* HERE : Hcuts[] is now inconsistent with fixY[], which may cause problems in setlimit() : fix this as in HaploType */
	  score_init(N,fixY,MD,MX,X);
	  double qLP2 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,bestLPA,fixY[ifirstP],fixY[ilastP+1],0,0,pcontig);
	  if(VERB){
	    if((qLP2 > mLP-LP_DROP || testLP > mLP) && (!MDEBUG_NEGERR || testLP < qLP2))
	      printf("    Y[%d..%d]=%0.7f->%0.6f(t=%d/%d): testLP=%0.10f (delta=%0.10f), qLP2=%0.10f (err = %0.10f)\n", 
		     Q,Q+1,origval, val, t, D[Q], testLP, testLP - mLP, qLP2, testLP - qLP2);
	    else
	      printf("    Y[%d..%d]=%0.7f->%0.7f(t=%d/%d): testLP=%0.10f (delta=%0.10f), qLP2=%0.10f (err = %0.10f:ignored)\n", 
		     Q,Q+1,origval, val, t, D[Q], testLP, testLP - mLP, qLP2, testLP - qLP2);
	    fflush(stdout);
	  }
	  if((qLP2 > mLP-LP_DROP || testLP > mLP) && fabs(testLP-qLP2) > maxerr && (!MDEBUG_NEGERR || testLP < qLP2)){
	    maxerr = fabs(testLP-qLP2);
	    maxerrT = Q;
	    maxerrD = t;
	  }

	  double sumLPmQt = 0.0, sumtest = 0.0;
	  for(int m = 0; m < MD; m++){
	    double newLPmQt = (Q >= AminM[m] && Q <= AmaxM[m]) ? newLPdelta[m][Dcum[Q]-Dcum[AminM[m]]+t] : newLPA[m];
	    double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
	    sumLPmQt += newLPmQt * TBwtm;
	    sumtest += testLPA[m] * TBwtm;
	    if(VERB && (VERB>=2 /* ||(N==112 && Q==101 && t==0)*/ || (Q==MDEBUG_TS && t==MDEBUG_TT && m==MDEBUG_M)
			|| ((testLPA[m] > newLPA[m] - LP_DROP*0.1 || newLPmQt > newLPA[m]) && fabs(newLPmQt - testLPA[m]) * TBwtm > max(ErrMax, MDEBUG_ERR)))){
	      printf("Q=%d,t=%d,m=%d(id=%lld):mLP[m]=%0.10f,newLPdelta[m][S,d]=%0.10f,testLPA[m]=%0.10f(err=%0.10f),cum LPdelta=%0.10f,LPA=%0.10f(err=%0.10f)",
		     Q,t,m,gmap[pcontig->contig[m].mapid]->id, newLPA[m], newLPmQt, testLPA[m], newLPmQt - testLPA[m], sumLPmQt, sumtest, sumLPmQt-sumtest);
	      if(testLPA[m] <= bestLPA[m] - LP_DROP*0.1 && newLPmQt <= newLPA[m])
		printf(":ignored");
	      printf("\n");
	      fflush(stdout);
	    }
	    if(DEBUG) assert(newLPmQt > LARGE_NEGATIVE * 0.9);
	    if((testLPA[m] > newLPA[m] - LP_DROP*0.1 || newLPmQt > newLPA[m] || (maxerr > MDEBUG_ERR && maxerrD == t && maxerrT == Q)) && fabs(newLPmQt-testLPA[m]) * TBwtm > ErrMax &&
	       (!MDEBUG_NEGERR || newLPmQt < testLPA[m])){
	      ErrMax = fabs(newLPmQt-testLPA[m]) * TBwtm;
	      trueLP = testLPA[m];
	      maxT = Q;
	      maxD = t;
	      maxM = m;
	      maxWT = TBwtm;
	    }
	  }
	  if(DEBUG) assert(fabs(sumLPmQt - N*SITE_PEN - testLP) < 1e-8);
	  if(DEBUG) assert(fabs(sumtest - N*SITE_PEN - qLP2) < 1e-8);

	  if(ErrMax >= 0.0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0 && N == MDEBUG_N && maxT >= 0){
	    double newLPmQt = (maxT >= AminM[maxM] && maxT <= AmaxM[maxM]) ? newLPdelta[maxM][Dcum[maxT]-Dcum[AminM[maxM]]+maxD] : newLPA[maxM];
	    printf("Interval/Delta/map with worst error so far is Q=%d(%0.3f),t=%d(%0.3f),m=%d(id=%lld):mLP[m]=%0.10f,newLPdelta[m][Q,t]=%0.10f,trueLP=%0.10f,|err|=%0.10e\n",
		   maxT,fixYdel[maxT],maxD,delta[maxT][maxD],maxM,gmap[pcontig->contig[maxM].mapid]->id,newLPA[maxM],newLPmQt,trueLP,ErrMax);
	    fflush(stdout);
	    if(DEBUG) assert(maxT >= 0 && maxM >= 0 && maxD >= 0);

	    printf("Calling qprobeval after modifying interval Q=%d(%0.3f),t=%d(%0.3f)\n", maxT,fixYdel[maxT+1],maxD,delta[maxT][maxD]);
	    fflush(stdout);
	    
	    rverb = 1;
	    double qLP3 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,newLPA,fixY[ifirstP],fixY[ilastP+1],0,0,pcontig);
	    rverb = 0;

	    printf("qLP3= %0.10f\n",qLP3);
	    fflush(stdout);

	    printf("Calling mprobeval after changing Y[Q=%d..%d] from %0.4f to %0.4f (delta[Q][t=%d]= %0.4f)\n",Q,Q+1,origval,fixYdel[Q+1],t,delta[Q][t]);
	    fflush(stdout);
	    
	    //	    MDEBUG_ST = 66;

	    double mLP2 = mprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap[MD],TBmapWT,testLPA,bestLPA,fixY[ifirstP],fixY[ilastP+1],0,0,0,delta,LPdel,0,0,0,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,newLPdelta,Dcum,AminM,AmaxM,pcontig,0,0);
	    printf("mLP2=%0.10f\n",mLP2);
	    fflush(stdout);

	    exit(1);
	  }

	  /* restore original value */
	  fixYdel[Q+1] = origval;
	}
      } /* t = 0 .. D[Q] - 1 */
    } /* Q = 1 .. N-1 */

    if(MDEBUG_T < 0){
      if(maxerr >= 0.0){
	printf("Worst interval change error =%0.10e at Q=%d,t=%d(%0.3f) (excluding when true LP drops by %0.3f or more)\n",maxerr,maxerrT,maxerrD,delta[maxerrT][maxerrD],LP_DROP);
	fflush(stdout);
	if(DEBUG) assert(maxerrT >= 0 && maxerrD >= 0);
      }
      if(ErrMax >= 0.0){
	double newLPmQt = (maxT >= AminM[maxM] && maxT <= AmaxM[maxM]) ? newLPdelta[maxM][Dcum[maxT]-Dcum[AminM[maxM]]+maxD] : bestLPA[maxM];
	printf("Interval/change/map with worst interval change error is Q=%d(%0.3f),t=%d(%0.3f),m=%d(id=%lld),N=%d:mLP[m]=%0.10f->%0.10f,newLPdelta[m][Q,t]=%0.10f,trueLP=%0.10f,|err|=%0.10e,wt=%0.5f(excluding when LP drops by %0.3f or more)\n",
	       maxT,fixYdel[maxT+1],maxD,delta[maxT][maxD],maxM,gmap[pcontig->contig[maxM].mapid]->id,N,bestLPA[maxM],newLPA[maxM],newLPmQt,trueLP,ErrMax,maxWT,LP_DROP*0.1);
	fflush(stdout);
	if(DEBUG) assert(maxT >= 0 && maxD >= 0 && maxM >= 0);
	if(DEBUG) assert(ErrMax < MDEBUG_ERR * 100.0);
      }
      if(DEBUG) assert(maxerr < MDEBUG_ERR);
    }

    delete [] testLPA;
  }

  for(register int Q=1;Q<N;Q++){
    if(D[Q]==0){/* fixYdel[Q+1] was same as KDmean value : add value back to start Goldenmean search and force D[Q] > 0 (DELTA_FIX3 needed to later filter out this value if fixYdel[Q+1] is not changed) */
      double origval = fixYdel[Q+1];
      double newval = newY[Q+1]-newY[Q];
      if(VERB>=2){
	printf("Q=%d/%d:Y[Q]=%0.3f,cnt=%d(0):origval=%0.3f,KDmean=%0.3f\n",Q,N,Y[Q],Ycnt[Q],origval,newval);
	fflush(stdout);
      }
      LPdelta[Q][0] = mLP;
      if(DEBUG) assert(origval >= minKB);
      delta[Q][0] = 0.0;
      D[Q] = 1;
    }
  }
  //  MDEBUG = 1;
  //  MDEBUG_M = -1;

  register double phi = (1.0 + sqrt(5.0))*0.5;
  register double resphi = 2.0 - phi;
  double bestLPdelta = mLP;// WAS5 -1.0e300;
  double bestX = 0.0;
  int bestQ = -1;
  double predLPdelta = 0.0;
  double totLPdelta = 0.0;

  /* track how often Goldenmean search is moving in the same direction consecutively : this is NOT used unless D[Q] == 1 */
  int *Lcnt = new int[N+1];/* how often range was narrowed at the low end */
  int *Rcnt = new int[N+1];/* how often range was rarrowed at the high end */
  int initialjump = 1;/* flag indicates that current Goldenmean range may be far from original value Xbest[Q] */
  int singlechange = 0;/* If we have to backtrack (or choose to change a single interval), this is set to 1 to signal that only a single interval will be changed in the next iteration */
  double *Xchange = new double[N+1];/* Xchange[Q] == most recent absolute change to fixYdel[Q+1] */
  double *peakLP = new double[N+1];/* peakLP[Q] is the most recent locally best LP, with current interval at origval + delta[Q][peakT[Q]] (assuming all other intervals are at Xbest[])
				      NOTE : maxLP[Q] is first updated to mLP when Xbest[] are updated, then later updated to peakLP[Q] IFF Xmid[Q] is updated to origval + delta[Q][peakT[Q]] */
  int *peakT = new int[N+1];
  int *conflictQ = new int[N+1];/* used for debugging */
  Xchange[0] = Xchange[N] = 0.0;

  /* locate interval with largest predicted improvement in LP */
  for(int Q = 1; Q < N; Q ++){
    if(DEBUG)assert(D[Q] != 0);
    if(D[Q] <= 0)
      continue;

    double origval = fixYdel[Q+1];

    for(int t = 0; t < D[Q]; t++){
      double testLP = LPdelta[Q][t];
      if(testLP > bestLPdelta){
	bestLPdelta = testLP;
	bestX = delta[Q][t] + origval;
	bestQ = Q;
      }
      if(testLP > mLP)
	totLPdelta += testLP - mLP;
    }
  }

  if(MULTIMODE_MP && MULTIMODE_MP_DELTA2 > 0.0 && bestLPdelta - qLP > MULTIMODE_MP_DELTA2)/* change only one interval */
    singlechange = (ADAPTIVE ? 2 : 1);

  if(VERB>=2 || SVERB || ERRPLOT){
    if(bestQ >= 0){
      if(singlechange)
	printf(" best single interval:Q=%d,Y[Q]=%0.3f->%0.3f,LP=%0.6f(delta=%0.6f),totLPdelta=%0.6f:making only this change\n",bestQ,fixYdel[bestQ+1],bestX,bestLPdelta,bestLPdelta-qLP,totLPdelta);
      else if(bestLPdelta > qLP)
	printf(" best single interval:Q=%d,Y[Q]=%0.3f->%0.3f,LP=%0.6f(delta=%0.6f),totLPdelta=%0.6f:making all changes\n",bestQ,fixYdel[bestQ+1],bestX,bestLPdelta,bestLPdelta-qLP,totLPdelta);
      else
	printf(" best single interval:Q=%d,Y[Q]=%0.3f->%0.3f,LP=%0.6f(delta=%0.6f),totLPdelta=%0.6f:making no changes\n",bestQ,fixYdel[bestQ+1],bestX,bestLPdelta,bestLPdelta-qLP,totLPdelta);
      fflush(stdout);
    }
  }

  /* initialize Xbest[Q] = fixYdel[Q+1], and compute maxLP[Q] == peakLP[Q] & peakT[Q] */
  for(int Q = 1; Q < N; Q ++){
    if(DEBUG)assert(D[Q] != 0);
    if(D[Q] <= 0)
      continue;

    double origval = fixYdel[Q+1];
    Xbest[Q] = origval;

    maxLP[Q] = -1e300;
    int maxt = -1;
    for(int t = 0; t < D[Q]; t++){
      double testLP = LPdelta[Q][t];
      if(VERB>=2 || SVERB || ERRPLOT){
	double val = delta[Q][t] + origval;
	printf("    Y[%d..%d]=%0.7f-> %0.7f: LP=%0.6f (delta=%0.6f) : Y[%d]=%0.4f\n", 
	       Q,Q+1,Y[Q+1]-Y[Q], val, testLP, testLP - mLP, Q, Y[Q]);
	fflush(stdout);
      }
      if(testLP > maxLP[Q]){
	maxLP[Q] = testLP;
	maxt = t;
      }
    }
    if(DEBUG) assert(maxt >= 0);
    peakLP[Q] = maxLP[Q];
    peakT[Q] = maxt;

    if(VERB>=2 || SVERB){
      printf("\tQ=%d:best sample (or KDmean) value for Y[%d..%d] = %0.7f (was %0.7f): LP=%0.10f (delta=%0.10f),Ycnt=%d,D[Q]=%d\n",
	     Q,Q,Q+1,delta[Q][maxt]+origval, origval, maxLP[Q], maxLP[Q]-qLP, Ycnt[Q],D[Q]);
      fflush(stdout);
    }
  }

  ifirstP = 0;
  ilastP = -1;

  int ChangeCnt = 0;

  double ratio1 = (DELTA_FIX4 <= 0) ? 1.0-MULTIMODE_DELTA : 1.0/(1.0+MULTIMODE_DELTA);
  double ratio2 = (1.0 + MULTIMODE_DELTA);

  double rresKB = res[0] * PixelLen;// WAS rres * 0.500 
  double DELTA1 = MULTIMODE_MP_DELTA1;/* may be reduced if mLP - qLP is less than 50% of predLPdelta */
  if(VERB>=2 || SVERB){
    printf("rresKB= %0.7f, initial DELTA1= %0.6f\n",rresKB,DELTA1);
    fflush(stdout);
  }

  // NOTE : cannot multithread this loop due to sequential update of ifirstP,ilastP 

  for(int Q = 1; Q < N; Q ++){
    Xchange[Q] = 0.0;/* needed even for D[Q] <= 0 since it is checked for Q-1 and Q+1 */

    if(DEBUG) assert(D[Q] != 0);
    if(D[Q] <= 0)
      continue;

    double origval = fixYdel[Q+1];
    int maxt = peakT[Q];

    // NOTE : maxLP[] and peakLP[] are the same after initial mprobeval, so MULTIMODE_FIX4 does NOT apply

    /* compute conflictLP[Q] : NOTE Xmid[] is not initialize here, so use fixYdel[Q+1] instead */
    conflictLP[Q] = ((DELTA_FIX2 <= 0) ? maxLP[Q] : max(mLP, maxLP[Q])) - 1e-6;
    int conflictQ = Q;
    if(MULTIMODE_MP_DELTA2 > MULTIMODE_MP_DELTA1){
      int cnt = 0;/* count of small intervals below rres * 0.500 : these intervals are not counted towards MULTIMODE_MP_CONFLICT */
      for(int t = 1; t <= MULTIMODE_MP_CONFLICT + cnt && Q-t >= 1; t++){
	if(D[Q-t] > 0 && maxLP[Q-t] > conflictLP[Q]){
	  conflictLP[Q] = maxLP[Q-t];
	  conflictQ = Q-t;
	}
	if(fixYdel[1+Q-t] <= rresKB)
	  cnt++;
      }

      cnt = 0;
      for(int t = 1; t <= MULTIMODE_MP_CONFLICT + cnt && Q+t < N; t++){
	if(D[Q+t] > 0 && maxLP[Q+t] > conflictLP[Q]){
	  conflictLP[Q] = maxLP[Q+t];
	  conflictQ = Q+t;
	}
	if(fixYdel[1+Q+t] <= rresKB)
	  cnt++;
      }
    }

    /* initialize Goldenmean search range Xlow[Q],Xhigh[Q] */
    Lcnt[Q] = Rcnt[Q] = 0;
    Xlow[Q] = Xhigh[Q] = Xmid[Q] = origval;
    if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);

    /* add origval to delta[Q][t=0..D[Q]-1] */
    for(int t = D[Q]; --t >= 0;)
      delta[Q][t] += origval;

    if(VERB>=2 || SVERB/* HERE >=2 */){
      printf("Q=%d: origval= %0.7f, singlechange(SC)=%d, bestQ=%d, conflictLP[Q]-mLP= %0.6f(q=%d), maxLP[Q]-mLP= %0.6f, DELTA1= %0.6f, mLP=%0.6f,qLP=%0.6f,D[Q]=%d,Xlow[Q]=%0.7f,Xhigh[Q]=%0.7f\n",
	     Q,origval,singlechange,bestQ,conflictLP[Q]-mLP,conflictQ,maxLP[Q]-mLP,DELTA1,mLP,qLP,D[Q],Xlow[Q],Xhigh[Q]);
      fflush(stdout);
    }

    /* NOTE : some intervals Q are not allowed to change due to singlechange or conflictLP[] : handle this case first */

    if(singlechange ? (Q != bestQ) /* For Q != bestQ just set Xnew[Q] to best known value */ :
       (conflictLP[Q] > max(maxLP[Q], mLP + DELTA1)) /* Same for intervals that conflict with a nearby interval T with maxLP[T] > max(DELTA1,maxLP[Q]) */){

      if(maxLP[Q] > mLP + LP_MINDELTA){/* expand range Xlow[Q] .. Xhigh[Q] to include Xnew[Q] = delta[Q][maxt], but don't change Xmid[Q] == origval == fixYdel[Q+1] */
	Xnew[Q] = delta[Q][maxt];

	if(MULTIMODE_FIX2 && DELTA_FIX3 && fabs(Xnew[Q] - origval) <= 1e-8){
	  if(DEBUG>=2) assert(D[Q] == 1);
	  Xlow[Q] = max(minKB, origval * ratio1);
	  Xhigh[Q] = origval * ratio2;
	  Xnew[Q] = origval + resphi * (Xhigh[Q] - origval);
	  if(DEBUG>=3 && !(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] <= minKB + 1e-6) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q])){
	    #pragma omp critical
	    {
	      printf("Q=%d:minKB= %0.8f, Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xnew[Q]= %0.8f, Xhigh[Q]= %0.8f, origval= %0.8f\n",
		     Q,minKB,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],origval);
	      fflush(stdout);
	      assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] <= minKB + 1e-6) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q]);
	    }
	  }
	} else if(Xnew[Q] < origval){
	  if(MULTIMODE_FIX2){
	    if(maxt > 0)
	      Xlow[Q] = delta[Q][maxt-1];
	    else
	      Xlow[Q] = max(minKB, Xnew[Q] * ratio1);
	    if(maxt < D[Q]-1)
	      Xhigh[Q] = max(origval * ratio2, delta[Q][maxt+1]);
	    else
	      Xhigh[Q] = max(origval, Xnew[Q]) * ratio2;
	    if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
	  } else
	    Xlow[Q] = Xnew[Q];
	  if(DEBUG>=3 && !(minKB <= Xlow[Q] + 1e-6 && Xlow[Q] <= min(Xmid[Q],Xnew[Q]) + 1e-8 && max(Xmid[Q],Xnew[Q]) < Xhigh[Q])){
	    #pragma omp critical
	    {
	      printf("Q=%d:minKB= %0.8f, Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xnew[Q]= %0.8f, Xhigh[Q]= %0.8f, origval= %0.8f\n",
		     Q,minKB,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],origval);
	      fflush(stdout);
	      assert(minKB <= Xlow[Q] + 1e-6 && Xlow[Q] <= min(Xmid[Q],Xnew[Q]) + 1e-8 && max(Xmid[Q],Xnew[Q]) < Xhigh[Q]);
	    }
	  }
	} else if((MULTIMODE_FIX2 && DELTA_FIX3) || (Xnew[Q] > origval)) {
	  if(DEBUG>=2) assert(Xnew[Q] > origval);
	  if(MULTIMODE_FIX2){
	    if(maxt < D[Q]-1)
	      Xhigh[Q] = delta[Q][maxt+1];
	    else
	      Xhigh[Q] = Xnew[Q] * ratio2;
	    if(maxt > 0)
	      Xlow[Q] = max(minKB,min(origval * ratio1, delta[Q][maxt-1]));
	    else
	      Xlow[Q] = max(minKB, min(origval, Xnew[Q] * ratio1));
	    if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
	  } else
	      Xhigh[Q] = Xnew[Q];

	  if(DEBUG>=3 && MULTIMODE_FIX2 && !(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] <= minKB + 1e-8) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q])){
	    #pragma omp critical
	    {
	      printf("Q=%d:minKB= %0.8f, Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xnew[Q]= %0.8f, Xhigh[Q]= %0.8f, origval= %0.8f\n",
		     Q,minKB,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],origval);
	      fflush(stdout);
	      assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] <= minKB + 1e-6) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q]);
	    }
	  }
	}

	if(DEBUG>=2 && !(Xnew[Q] >= minKB - 1e-8)){
	  printf("Q=%d,bestQ=%d,SC=%d:maxLP[Q]-mLP=%0.6f,mLP=%0.6f,conflictLP[Q]-mLP=%0.6f(q=%d),delta[Q][%d/%d]+origval=%0.7f,origval=%0.7f,Xnew[Q]=%0.7f,minKB=%0.7f\n",
		 Q,bestQ,singlechange,maxLP[Q]-mLP,mLP,conflictLP[Q]-mLP,conflictQ,maxt,D[Q],delta[Q][maxt],origval,Xnew[Q],minKB);
	  fflush(stdout);
	  assert(Xnew[Q] >= minKB - 1e-8);
	}

	if(MULTIMODE_FIX2){/* initialize delta[Q][0..D[Q]-1] */
	  if(DEBUG>=2 && DELTA_FIX3) assert(fabs(Xnew[Q] - origval) >= 1e-8);
	  if(DEBUG>=2 && !(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] < minKB + 1e-6) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q])){
	    #pragma omp critical
	    {
	      printf("Q=%d:minKB= %0.8f, Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xnew[Q]= %0.8f, Xhigh[Q]= %0.8f, origval= %0.8f\n",
		     Q,minKB,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q], origval);
	      fflush(stdout);
	      assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] <= minKB + 1e-6) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q]);
	    }
	  }

	  delta[Q][0] = Xnew[Q] - origval;
	  D[Q] = 1;

	  if(VERB>=2 || SVERB){
	    printf("Q=%d:minKB= %0.7f, Xlow[Q]= %0.7f, Xmid[Q]= %0.7f, Xnew[Q]= %0.7f, Xhigh[Q]= %0.7f, origval= %0.7f,D[Q]=%d\n",Q,minKB,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],origval,D[Q]);
	    fflush(stdout);
	  }
	}

      } else {/* no sample improved on previous best LP */

	if(MULTIMODE_FIX2){
	  Xnew[Q] = delta[Q][maxt];

	  if(DELTA_FIX3 && fabs(Xnew[Q] - origval) <= 1e-8){
	    if(DEBUG>=2) assert(D[Q] == 1);
	    Xlow[Q] = max(minKB, origval * ratio1);
	    Xhigh[Q] = origval * ratio2;
	    Xnew[Q] = origval + resphi * (Xhigh[Q] - origval);
	  } else if(Xnew[Q] < origval){
	    if(maxt > 0)
	      Xlow[Q] = delta[Q][maxt-1];
	    else
	      Xlow[Q] = max(minKB, Xnew[Q] * ratio1);
	    if(maxt < D[Q]-1)
	      Xhigh[Q] = max(origval * ratio2, delta[Q][maxt+1]);
	    else
	      Xhigh[Q] = max(origval, Xnew[Q]) * ratio2;
	    if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
	  } else if(DELTA_FIX3 || Xnew[Q] > origval){
	    if(DEBUG>=2) assert(Xnew[Q] > origval);
	    if(maxt < D[Q]-1)
	      Xhigh[Q] = delta[Q][maxt+1];
	    else
	      Xhigh[Q] = Xnew[Q] * ratio2;
	    if(maxt > 0)
	      Xlow[Q] = max(/* NEW160 */minKB,min(origval * ratio1, delta[Q][maxt-1]));
	    else
	      Xlow[Q] = max(minKB, min(origval, Xnew[Q] * ratio1));
	    if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
	  }
	} else  /* otherwise leave Xlow[Q] = Xmid[Q] = Xhigh[Q] = origval; */
	  Xnew[Q] = origval;

	if((DEBUG>=2 && !(Xnew[Q] >= minKB - 1e-8)) || (VERB>=2 || SVERB)){
	  printf("Q=%d,bestQ=%d,SC=%d:maxLP[Q]-mLP=%0.6f,mLP=%0.6f,delta[Q][maxt=%d/%d]+origval=%0.7f,origval=%0.7f,Xnew[Q]=%0.7f,Xlow[Q]=%0.7f,Xhigh[Q]=%0.7f,minKB=%0.7f\n",
		 Q,bestQ,singlechange,maxLP[Q]-mLP,mLP,maxt,D[Q],delta[Q][maxt],origval,Xnew[Q],Xlow[Q],Xhigh[Q],minKB);
	  fflush(stdout);
	  assert(Xnew[Q] >= minKB - 1e-8);
	}

	if(MULTIMODE_FIX2){/* initialize delta[Q][0..D[Q]-1] : this is a placeholder, will later be customized */
	  if(DEBUG>=2 && DELTA_FIX3) assert(fabs(Xnew[Q] - origval) >= 1e-8);
	  if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] <= minKB + 1e-6) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q]);

	  delta[Q][0] = Xnew[Q] - origval;
	  D[Q] = 1;

	  if(VERB>=2 || SVERB){
	    printf("Q=%d:minKB= %0.7f, Xlow[Q]= %0.7f, Xmid[Q]= %0.7f, Xnew[Q]= %0.7f, Xhigh[Q]= %0.7f, origval= %0.7f,D[Q]=%d\n",Q,minKB,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],origval,D[Q]);
	    fflush(stdout);
	  }
	}
      }

    } else {/* Update interval size fixYdel[Q+1] == Xmid[Q] based on maxLP[Q] */

      if(maxLP[Q] > mLP + LP_MINDELTA){
	ChangeCnt++;

	predLPdelta += maxLP[Q] - mLP;

	Xlow[Q] = Xhigh[Q] = Xmid[Q] = delta[Q][maxt];
	if(DEBUG>=2 && !(Xlow[Q] >= minKB - 1e-8)){
	  printf("Q=%d:maxt=%d,delta[Q][maxt]+origval=%0.6f,origval=%0.6f:Xlow[Q] -> %0.6f (minKB=%0.6f)\n",
		 Q,maxt,delta[Q][maxt],origval,Xlow[Q],minKB);
	  fflush(stdout);
	  assert(Xlow[Q] >= minKB - 1e-8);
	}

	if(maxt > 0) {
	  Xlow[Q] = delta[Q][maxt-1];
	  if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
	} else if(MULTIMODE_FIX2)
	  Xlow[Q] = max(minKB, Xmid[Q] * ratio1);

	if(maxt < D[Q]-1)
	  Xhigh[Q] = delta[Q][maxt+1];
	else if(MULTIMODE_FIX2)
	  Xhigh[Q] = Xmid[Q] * ratio2;

	if(DEBUG>=3 && MULTIMODE_FIX2 && !(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-6) && Xmid[Q] < Xhigh[Q])){
	  #pragma omp critical
	  {
	    printf("Q=%d:minKB= %0.8f, Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xhigh[Q]= %0.8f, maxt=%d, D[Q]= %d:\n",Q,minKB,Xlow[Q],Xmid[Q],Xhigh[Q],maxt,D[Q]);
	    for(int t = 0; t < D[Q]; t++)
	      printf("\t t=%d: delta[Q][t]= %0.8f, LPdelta[Q][t]= %0.6f (del= %0.6f)\n",t, delta[Q][t], LPdelta[Q][t], LPdelta[Q][t]-mLP);
	    fflush(stdout);
	    assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-6) && Xmid[Q] < Xhigh[Q]);
	  }
	}

	Xchange[Q] = fabs(Xmid[Q] - origval);

	if(VERB>=2 || SVERB){
	  printf("Q=%d:Y[Q]= %0.7f -> %0.7f, Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f, Xchange[Q]= %0.6f, predLPdelta= %0.6f\n",Q,origval,Xmid[Q],Xlow[Q],Xmid[Q],Xhigh[Q],Xchange[Q],predLPdelta);
	  fflush(stdout);
	}

	fixYdel[Q+1] = origval = Xmid[Q];
	if(ifirstP <= 0)
	  ifirstP = Q;
	ilastP = Q;

      } else if(MULTIMODE_FIX2){/* no sample improved on previous best LP */

	Xnew[Q] = delta[Q][maxt];/* NOTE : Xnew[Q] will be updated below and is only used to compute Xlow[Q] and Xhigh[Q] here */
	if(maxt > 0)
	  Xlow[Q] = max(minKB, min(origval * ratio1, delta[Q][maxt-1]));
	else
	  Xlow[Q] = max(minKB, min(origval, Xnew[Q]) * ratio1);
	if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);	    

	if(maxt < D[Q]-1)
	  Xhigh[Q] = max(origval * ratio2, delta[Q][maxt+1]);
	else
	  Xhigh[Q] = max(origval, Xnew[Q]) * ratio2;

	if(VERB>=2 || SVERB){
	  printf("Q=%d:Y[Q]= %0.7f unchanged, Xlow[Q]=%0.7f,Xmid[Q]=%0.6f,Xhigh[Q]=%0.7f\n",Q,origval,Xlow[Q],Xmid[Q],Xhigh[Q]);
	  fflush(stdout);
	}

	if(DEBUG>=3) assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-6) && Xmid[Q] < Xhigh[Q] && fabs(Xmid[Q] - origval) < 1e-6);
      } /* otherwise leave Xlow[Q] = Xhigh[Q] = Xmid[Q] = origval; */

      if(DEBUG && !(Xlow[Q] <= origval + 1e-8 && origval <= Xhigh[Q] + 1e-8)){
	printf("Q=%d:Xlow[Q]=%0.10f,Xmid[Q]=%0.6f,Xhigh[Q]=%0.10f,Xcur=%0.6f,origval=%0.10f\n",
	       Q,Xlow[Q],Xmid[Q],Xhigh[Q],fixYdel[Q+1],origval);
	fflush(stdout);
	assert(Xlow[Q] <= origval + 1e-8 && origval <= Xhigh[Q] + 1e-8);
      }

      if(MULTIMODE_FIX2 && DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-6) && Xmid[Q] < Xhigh[Q]);

      /* select new test point Xnew[Q] (could be outside of range Xlow[Q] .. Xhigh[Q]) */
      if(!MULTIMODE_FIX2 && Xlow[Q] >= Xmid[Q] - 1e-6 && Xlow[Q] >= minKB + 1e-6){
	Xnew[Q] = max(minKB,Xmid[Q] - phi*max(1.0,Xhigh[Q] - Xmid[Q]));
	if(Xnew[Q] < Xmid[Q] * 0.7)
	  Xnew[Q] = Xmid[Q] * 0.7;
	if(bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
	  Xlow[Q] = min(Xnew[Q],Xlow[Q]);
	if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
      } else if(!MULTIMODE_FIX2 && Xhigh[Q] <= Xmid[Q] + 1e-6 && Xhigh[Q] <= max(1.0,origval)*4.0){
	Xnew[Q] = Xmid[Q] + phi * max(1.0,Xmid[Q] - Xlow[Q]);
	if(Xnew[Q] > Xmid[Q] * 1.2)
	  Xnew[Q] = Xmid[Q] * 1.2;
	if(bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
	  Xhigh[Q] = max(Xnew[Q],Xhigh[Q]);
	if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
      } else {
	if(DEBUG>=2 && MULTIMODE_FIX2) assert((Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-8) && Xmid[Q] < Xhigh[Q]);

	if(max(Xhigh[Q]-Xmid[Q],Xmid[Q]-Xlow[Q]) <= min(DELTA_RES, DELTA_REL * Xmid[Q])){
	  D[Q] = 0;
	  if(VERB>=2 || SVERB || ERRPLOT){
	    printf("\t Q=%d: Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.7f,resphi=%0.7f,minKB=%0.7f,origval=%0.7f,D[Q]=%d(Completed)\n",
		   Q,Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval,D[Q]);
	    fflush(stdout);
	  }
	  continue;
	}

	// NOTE : even with MULTIMODE_FIX2 && DELTA_FIX4 it is NOT guaranteed that the first branch below will be taken (sample points are centered around KDmean and NOT origval)
	if(Xhigh[Q] - Xmid[Q] >= Xmid[Q] - Xlow[Q])
	  Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q] - Xmid[Q]);
	else
	  Xnew[Q] = Xmid[Q] - resphi*(Xmid[Q] - Xlow[Q]);
	if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
	if(DEBUG>=3) assert(minKB <= Xlow[Q] + 1e-6 && Xlow[Q] <= Xnew[Q] && Xnew[Q] < Xhigh[Q]);
      }

      if(DEBUG) assert(Xnew[Q] >= minKB - 1e-8);
      if(MULTIMODE_FIX2){/* initialize delta[Q][0..D[Q]-1] : this is a placeholder, will later be customized */
	if(DEBUG>=2 && DELTA_FIX3) assert(fabs(Xnew[Q] - origval) >= 1e-8);
	if(DEBUG>=2 && !(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] <= minKB + 1e-6) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q])){
	  printf("Q=%d:minKB= %0.8f, Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xnew[Q]= %0.8f, Xhigh[Q]= %0.8f, origval= %0.8f\n",Q,minKB,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],origval);
	  fflush(stdout);
	  assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] <= minKB + 1e-8) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q]);
	}

	delta[Q][0] = Xnew[Q] - origval;
	D[Q] = 1;

	if(VERB>=2 || SVERB){
	  printf("Q=%d:minKB= %0.7f, Xlow[Q]= %0.7f, Xmid[Q]= %0.7f, Xnew[Q]= %0.7f, Xhigh[Q]= %0.7f, origval= %0.7f,D[Q]=%d,predLPdelta=%0.6f\n",
		 Q,minKB,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],origval,D[Q],predLPdelta);
	  fflush(stdout);
	}
      }
    }
  } // for int Q = 1 .. N-1 

  if(VERB>=2){
    printf("MULTIMODE_MP=%d, MULTIMODE_MP_MIN= %0.6f, MULTIMODE_MP_MAX= %0.6f\n",MULTIMODE_MP, MULTIMODE_MP_MIN, MULTIMODE_MP_MAX);
    fflush(stdout);
  }

  /* Update D[Q], delta[Q] */
  Dcnt = DcntT = 0;
  double DcntS = 0.0;/* sum of Xhigh[Q]-Xlow[Q] for D[Q] > 0 : useful for tracking progress of GoldenMean search when LP is not making progress (repeated backtrack) */
  for(int Q = 1; Q < N; Q ++){
    if(D[Q] <= 0)
      continue;
    double origval = fixYdel[Q+1];
    int maxt = peakT[Q];

    int MPblock = (MPBLOCK && singlechange && maxLP[Q] - qLP <= 0.8 * MULTIMODE_MP_DELTA2 && (D[Q] <= 2 || (maxt > 0 && maxt < D[Q]-1)) && abs(Q-bestQ) != 1) ? 1 : 0;
    int MPscan = (MULTIMODE_MP_SCAN <= 0.0 || max(Xchange[Q-1], Xchange[Q+1]) > MULTIMODE_MP_SCAN * Xmid[Q] || 
		  (MULTIMODE_FIX5 ? conflictLP[Q] > max(maxLP[Q], mLP + DELTA1) : !(D[Q] <= 2 || (maxt > 0 && maxt < D[Q] -1)))) ? 1 : 0;

    if(VERB>=2 || SVERB || ERRPLOT){
      printf("   Q=%d:Xnew[Q]=%0.7f,Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f:singlechange=%d,MPblock=%d,MPscan=%d,bestQ=%d,maxLP[Q]-mLP=%0.6f,Xchange[Q]=%0.7f\n",
	     Q,Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],singlechange,MPblock,MPscan,bestQ,maxLP[Q]-mLP,Xchange[Q]);
      fflush(stdout);
    }

    if(DEBUG && !(Xnew[Q] >= minKB - 1e-1)){
      printf("Q=%d:Xnew[Q]=%0.10f,minKB=%0.10f:Xlow[Q]=%0.6f,Xmid[Q]=%0.6f,Xhigh[Q]=%0.6f,Xcur[Q]=%0.6f\n",
	     Q,Xnew[Q],minKB,Xlow[Q],Xmid[Q],Xhigh[Q],fixYdel[Q+1]);
      fflush(stdout);
      assert(Xnew[Q] >= minKB - 1e-8);
    }

    /* NOTE : If MULTIMODE_FIX2, delta[Q][0..D[Q]-1] should already be initialized and D[Q] could be > 1, otherwise only a single sample point Xnew[Q] is known */
    if(!MULTIMODE_FIX2){
      /* IF DELTA_FIX3 && Xnew[Q] == origval (fixYdel[Q+1]) :
	 1. If MPscan == 1 && !MPblock : Do NOT include Xnew[Q] in delta[Q]
	 2. Else : widen Xlow[Q]..Xhigh[Q] based on delta[Q][maxt-1,maxt+1]) and compute new Xnew[Q]
      */

      if(DELTA_FIX3 && fabs(Xnew[Q] - origval) <= 1e-8){
	if(MPscan && !MPblock){
	  D[Q] = 0;
	  Xlow[Q] = Xhigh[Q] = origval;
	} else {
	  Xlow[Q] = min(Xlow[Q], delta[Q][max(0,maxt-1)]);
	  if(DEBUG>=2 && !(Xlow[Q] >= minKB - 1e-8)){
	    printf("Q=%d:maxt=%d,fixYdel[Q+1]=%0.6f,origval+delta[Q][max(0,maxt-1)]=%0.6f,Xlow[Q] -> %0.6f, minKB= %0.6f\n",
		   Q,maxt,fixYdel[Q+1],delta[Q][max(0,maxt-1)],Xlow[Q],minKB);
	    fflush(stdout);
	    assert(Xlow[Q] >= minKB - 1e-8);
	  }
	  Xhigh[Q] = max(Xhigh[Q], delta[Q][min(D[Q]-1, maxt + 1)]);

	  /* select new test point Xnew[Q] (could be outside of range Xlow[Q] .. Xhigh[Q]) */
	  if(Xlow[Q] >= Xmid[Q] - 1e-6 && Xlow[Q] >= minKB + 1e-6){
	    Xnew[Q] = max(minKB,Xmid[Q] - phi*max(1.0,Xhigh[Q] - Xmid[Q]));
	    if(Xnew[Q] < Xmid[Q] * 0.7)
	      Xnew[Q] = Xmid[Q] * 0.7;
	    if(bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
	      Xlow[Q] = min(Xnew[Q],Xlow[Q]);
	    if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
	  } else if(Xhigh[Q] <= Xmid[Q] + 1e-6 && Xhigh[Q] <= max(1.0,origval)*4.0){
	    Xnew[Q] = Xmid[Q] + phi * max(1.0,Xmid[Q] - Xlow[Q]);
	    if(Xnew[Q] > Xmid[Q] * 1.2)
	      Xnew[Q] = Xmid[Q] * 1.2;
	    if(bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
	      Xhigh[Q] = max(Xnew[Q],Xhigh[Q]);
	    if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
	  } else {
	    if(Xhigh[Q] - Xmid[Q] > Xmid[Q] - Xlow[Q])
	      Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q] - Xmid[Q]);
	    else
	      Xnew[Q] = Xmid[Q] - resphi*(Xmid[Q] - Xlow[Q]);
	    if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
	  }

	  delta[Q][0] = Xnew[Q] - origval;
	  D[Q] = 1;
	  if(VERB>=2 || SVERB || ERRPLOT){
	    printf("\t Q=%d: Xnew[Q] -> %0.4f (Xlow[Q]= %0.4f, Xmid[Q]= %0.4f, Xhigh[Q]= %0.4f),D[Q]=%d\n",Q,Xnew[Q], Xlow[Q],Xmid[Q],Xhigh[Q],D[Q]);
	    fflush(stdout);
	  }
	}
      } else {
	delta[Q][0] = Xnew[Q] - origval;
	D[Q] = 1;
      }
    } // if(!MULTIMODE_FIX2)

    /* expand Xlow[Q]..Xhigh[Q] if neighboring interval Q-1 or Q+1 had large change */
    if(MULTIMODE_FIX2 && MULTIMODE_FIX3 <= 1 && max(Xchange[Q-1],Xchange[Q+1]) > (Xhigh[Q] - Xlow[Q])){
      double origXlow = Xlow[Q], origXhigh = Xhigh[Q];
      double range = max(Xchange[Q-1],Xchange[Q+1]);
      int origD = D[Q];
      if(Xhigh[Q] <= Xlow[Q] || D[Q] <= 0){
        if(DEBUG) assert(D[Q] <= 0);
	Xlow[Q] = max(minKB, Xmid[Q] - range * 0.5);
	Xhigh[Q] = Xlow[Q] + range;
	Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q] - Xmid[Q]);	
	delta[Q][0] = Xnew[Q] - origval;
	D[Q] = 1;
      } else {
        if(DEBUG) assert(D[Q] > 0);
	if(DEBUG>=2 && !((Xlow[Q] < Xnew[Q] || Xlow[Q] <= minKB + 1e-6) && Xnew[Q] < Xhigh[Q])){
	  printf(" Q=%d:Xlow[Q]= %0.8f, Xnew[Q]= %0.8f, Xhigh[Q]= %0.8f, Xmid[Q]= %0.8f\n",Q,Xlow[Q],Xnew[Q],Xhigh[Q],Xmid[Q]);
	  fflush(stdout);
	  assert((Xlow[Q] < Xnew[Q] || Xlow[Q] <= minKB + 1e-6) && Xnew[Q] < Xhigh[Q]);
	}
	double scale = range / (Xhigh[Q] - Xlow[Q]);
	if(MULTIMODE_FIX3 && scale >= 1.0 + MULTIMODE_MP_SCAN){/* add previous Xlow[Q] and Xhigh[Q] as new sample points */
	  if(D[Q] + 1 >= Dsiz[Q]){
	    register double *newdel = new double[Dsiz[Q] + 21];
	    for(register int k = Dsiz[Q]; --k >= 0;)
	      newdel[k] = delta[Q][k];
	    Dsiz[Q] += 21;
	    delete [] delta[Q];
	    delete [] LPdelta[Q];
	    delta[Q] = newdel;
	    LPdelta[Q] = new double[Dsiz[Q]];
	  }
	  if(Xlow[Q] > minKB + min(DELTA_RES, DELTA_REL * Xlow[Q])){
	    delta[Q][D[Q]++] = Xlow[Q] - origval;
	    Xlow[Q] = max(minKB, Xnew[Q] - (Xnew[Q] - Xlow[Q]) * scale);
	  }
	  delta[Q][D[Q]++] = Xhigh[Q] - origval;
	  Xhigh[Q] = Xlow[Q] + range;

	  qsort(delta[Q],D[Q],sizeof(double),(intcmp *)doubleInc);
	}
      }
      if(VERB>=2 || SVERB || ERRPLOT){
	printf("\t Q=%d: widened Xlow=%0.6f[Q],Xhigh[Q]=%0.6f to Xlow[Q]=%0.6f,Xhigh[Q]=%0.6f, D[Q]=%d->%d, Xnew[Q]= %0.6f, Xmid[Q]= %0.6f: Xch[Q-1,Q+1]= %0.6f,%0.6f\n",
	       Q,origXlow,origXhigh,Xlow[Q],Xhigh[Q],origD,D[Q],Xnew[Q],Xmid[Q],Xchange[Q-1],Xchange[Q+1]);
	if(D[Q] > origD)
	  printf("Added original Xlow and Xhigh as new sample points\n");
	fflush(stdout);
      }
      if(DEBUG>=2) assert(Xlow[Q] >= minKB);
    }

    if(MULTIMODE_MP > 0 && !MPblock){/* add additional test points */
      if(MULTIMODE_FIX3){ 
	if(1){
	  int DQ = D[Q];
	  double S1,S2;
	  if(DQ > 0){
            S1 = min(Xmid[Q], origval + delta[Q][0]);
	    S2 = max(Xmid[Q], origval + delta[Q][DQ-1]);
	  } else
	    S1 = S2 = (Xlow[Q] + Xhigh[Q]) * 0.5;

	  if(VERB>=2 || SVERB/* HERE >=2 */){
	    printf("%d:D[Q]=%d,Xlow[Q]=%0.7f,S1=%0.7f,S2=%0.7f,Xhigh[Q]=%0.7f : picking up to %d additional test points\n",
		   Q,D[Q],Xlow[Q],S1,S2,Xhigh[Q], MULTIMODE_FIX3 >= 2 ? 2*MULTIMODE_MP : 3*MULTIMODE_MP);
	    fflush(stdout);
	  }
	  if(DEBUG && !(Xlow[Q] <= S1+1e-6 && S1 <= S2+1e-6 && S2 <= Xhigh[Q]+1e-6)){
	    printf("Q=%d: Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xnew[Q]= %0.8f, Xhigh[Q]= %0.8f, S1= %0.8f, S2= %0.8f, origval= %0.8f D[Q]=%d:\n",
		   Q,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],S1,S2,origval,D[Q]);
	    for(int t = 0; t < D[Q]; t++)
	      printf("\t delta[Q][%d] + origval = %0.8f\n",t,delta[Q][t] + origval);
	    fflush(stdout);
	    assert(Xlow[Q] <= S1+1e-6 && S1 <= S2+1e-6 && S2 <= Xhigh[Q]+1e-6);
	  }

	  if(MULTIMODE_FIX3 >= 2){/* add additional points at equidistant points starting at Xlow[Q] and Xhigh[Q] and spreading out */
	    int MMpoints = (!MULTIMODE_FIX5 || MPscan) ? MULTIMODE_MP : 1;

	    if(D[Q] + 2 * MMpoints > Dsiz[Q]){
	      register double *newdel = new double[D[Q] + 2 * MMpoints];
	      for(register int k = Dsiz[Q]; --k >= 0;)
		newdel[k] = delta[Q][k];
	      Dsiz[Q] = D[Q] + 2 * MMpoints;
	      delete [] delta[Q];
	      delete [] LPdelta[Q];
	      delta[Q] = newdel;
	      LPdelta[Q] = new double[Dsiz[Q]];
	    }

	    double step = S1 - Xlow[Q];
	    if(step > min(DELTA_RES,DELTA_REL*S1)){
	      double val = Xlow[Q];
	      for(int t = 1; t <= MMpoints; t++){
		if(val <= minKB)
		  break;
		delta[Q][D[Q]++] = val - origval;
		val -= step;
	      }
	      Xlow[Q] = max(minKB,val);
	    }

	    step = Xhigh[Q] - S2;
	    if(step > min(DELTA_RES, DELTA_REL*S2)){
	      double val = Xhigh[Q];
	      for(int t = 1; t <= MMpoints; t++){
		delta[Q][D[Q]++] = val - origval;
		val += step;
	      }
	      Xhigh[Q] = val;
	    }
          } else { /* add additional equidistant points between Xlow[Q], S1, S2 and Xhigh[Q] */
	    if(D[Q] + 3*MULTIMODE_MP > Dsiz[Q]){
              register double *newdel = new double[D[Q] + 3*MULTIMODE_MP];
	      for(register int k = Dsiz[Q]; --k >= 0;)
		newdel[k] = delta[Q][k];
	      Dsiz[Q] = D[Q] + 3*MULTIMODE_MP;
	      delete [] delta[Q];
	      delete [] LPdelta[Q];
	      delta[Q] = newdel;
	      LPdelta[Q] = new double[Dsiz[Q]];
	    }

	    double invMP = 1.0/(MULTIMODE_MP+1);
	    if(S1 > Xlow[Q] + min(DELTA_RES,DELTA_REL*S1)*2.0){
	      double inc = (S1 - Xlow[Q]) * invMP;
	      double val = Xlow[Q];
	      for(int t = 1; t <= MULTIMODE_MP; t++){
		val += inc;
		delta[Q][D[Q]++] = val - origval;
	      }
	    }
	    if(S2 > S1 + min(DELTA_RES,DELTA_REL*S2)*2.0){
	      double inc = (S2 - S1) * invMP;
	      double val = S1;
	      for(int t = 1; t <= MULTIMODE_MP; t++){
		val += inc;
		delta[Q][D[Q]++] = val - origval;
	      }
	    }
	    if(Xhigh[Q] > S2 + min(DELTA_RES,DELTA_REL*Xhigh[Q])*2.0){
	      double inc = (Xhigh[Q] - S2) * invMP;
	      double val = S2;
	      for(int t = 1; t <= MULTIMODE_MP; t++){
		val += inc;
		delta[Q][D[Q]++] = val - origval;
	      }
	    }
          }
	}
      } else {/* add additional test points at intervals of MULTIMODE_MP_MIN,MULTIMODE_MP_MAX */
	double ratio1 = 1.0+ MULTIMODE_MP_MAX;
	double ratio2 = (DELTA_FIX4 <= 0) ? 1.0-MULTIMODE_MP_MIN : 1.0/(1.0+MULTIMODE_MP_MIN);
	double mratio1 = ratio1, mratio2 = ratio2;
	for(int t = 0; t < MULTIMODE_MP; t++){
	  double val = Xnew[Q] * mratio1;
	  mratio1 *= ratio1;

	  if(MPscan || (Xlow[Q] < val && val < Xhigh[Q])){
	    if(DEBUG) assert(val >= minKB);
	    delta[Q][D[Q]++] = val - origval;
	  }

	  val = Xnew[Q] * mratio2;
	  if(val > minKB){
	    if(MPscan || (Xlow[Q] < val && val < Xhigh[Q]))
	      delta[Q][D[Q]++] = val - origval;
	    mratio2 *= ratio2;
	  }
	}
      } /* !MULTIMODE_FIX3 */

      if(DEBUG) assert(D[Q] <= Dsiz[Q]);
      qsort(delta[Q],D[Q],sizeof(double),(intcmp *)doubleInc);
    }

    if(D[Q] <= 0)
      continue;

    DcntT += D[Q];
    DcntS += Xhigh[Q] - Xlow[Q];
    Dcnt++;

    if(VERB>=2 || SVERB || ERRPLOT){
      printf("   New test points:Q=%d,D[Q]=%d,maxLP[Q]=%0.6f,qLP=%0.6f,SC=%d,MPblock=%d,Xchange[Q-1,Q+1]=%0.7f,%0.7f,MPscan=%d,maxt=%d,MP_MIN=%0.3f,MP_MAX=%0.3f,MP=%d\n",
	     Q,D[Q],maxLP[Q],qLP,singlechange,MPblock,Xchange[Q-1],Xchange[Q+1],MPscan,maxt,MULTIMODE_MP_MIN,MULTIMODE_MP_MAX,MULTIMODE_MP);
      for(int t = 0; t < D[Q]; t++)
	printf("        t=%d:delta[Q][t]=%0.7f,origval=%0.7f,Xcur=%0.7f,X[t]=%0.7f,minKB=%0.7f,Q=%d\n",
	       t,delta[Q][t],origval,fixYdel[Q+1],delta[Q][t]+origval,minKB,Q);
      fflush(stdout);
    }
  } /* Q = 1 .. N-1 */

  if(DEBUG && bestLPdelta > mLP + LP_MINDELTA && !(ChangeCnt > 0 && 0 <= ifirstP && ifirstP <= ilastP && ilastP <= N)){
    printf("Before Goldenmean search:ifirstP=%d,ilastP=%d,N=%d,Dcnt=%d,DcntT=%d, qLP=%0.10f,bestLPdelta=%0.10f(delta=%0.6e)(bestQ=%d)\n",
	   ifirstP,ilastP,N,Dcnt,DcntT, qLP, bestLPdelta, bestLPdelta-qLP, bestQ);
    fflush(stdout);
    assert(ChangeCnt > 0 && 0 <= ifirstP && ifirstP <= ilastP && ilastP <= N);
  }

  int iter = 0;

  if(VERB>=2 || SVERB || ERRPLOT){
    for(register int Q = 1; Q < N; Q++){
      if(D[Q] <= 0)
	continue;
      register double origval = fixYdel[Q+1];
      printf("Q=%d:Xbest=%0.7f,Xcur=%0.7f,Xlow=%0.7f,Xmid=%0.7f,Xhigh=%0.7f:Xnew=%0.7f,D[Q]=%d\n",
	     Q,Xbest[Q],origval,Xlow[Q],Xmid[Q],Xhigh[Q],Xnew[Q],D[Q]);
    }
    fflush(stdout);
  }

  char *skipmap = new char[MD];/* keep track of which maps no longer need to be evaluated in mprobeval() as more and more D[] values drop to <= 0 */
  for(int m = 0; m < MD; m++)
    skipmap[m] = 0;

  /* The following invariants apply during the Goldenmean search at the start of each iteration:
     
     qLP : Last known (global) best LP computed by either qprobeval or mprobeval, corresponding to interval values Xbest[Q].
     mLP : Current LP computed either by qprobeval() or mprobeval(), corresponding to interval values of fixYdel[Q+1] (typically same as Xmid[Q])

     bestQ : single interval with best improvement of LP (or -1 if no improvement over mLP is possible)
     bestX : value of interval bestQ with best predicted improvement in LP
     bestLPdelta : The value of predicted LP change corresponding to bestQ and bestX (must be > mLP)
     predLPdelta : The sum of predicted LP change max(t)LPdelta[Q][t] - mLP for all intervals Q that were changed.
     totLPdelta : The total sum of predicted LP change max(t)LPdelta[Q][t] - mLP for all intervals Q with peakLP[Q] > mLP, including those that were not changed due to conflictLP[Q]
     (NOTE : bestQ ... totLPdelta, may not be correct at the start of a backtrack iteration)

     Y[ifirstP..ilastP+1] : range of changes in Y[] since qLP & bestLPA[] were computed (ie fixYdel[Q+1] != Xbest[Q])  
                     (NOTE : if there were no changes in Y[] ifirstP==0, ilastP== -1)

     fixYdel[Q+1] : the current value of interval Q (corresponding to Y[Q+1]-Y[Q])
     Xbest[Q] : Last known (global) best value of interval Q (corresponding to qLP)
     
     Xlow[Q] : lower end of range of interval values to be searched for a local maxima
     Xhigh[Q] : upper end of range of interval values to be searched for a local maxima
     Xmid[Q] : best known (predicted) value for interval Q 
               NOTE : fixYdel[Q+1] may not always equal Xmid[Q] (eg if singlechange > 0 OR MULTIMODE_MP_DELTA2 > MULTIMODE_MP_DELTA1, see conflictLP[Q])
     maxLP[Q] : The LP value corresponding to current interval = Xmid[Q] (assuming all other intervals have value Xbest[]) (NOTE : before first interation, maxLP[Q] == peakLP[Q])
     
     peakLP[Q] : The locally best LP, with current interval = origval + delta[Q][peakT[Q]] (assuming all other intervals have value fixYdel[Q+1] used by mprobeval(), often == Xmid[Q])
     peakT[Q] : see peakLP[Q]

     conflictLP[Q] : max(t=0..MULTIMODE_MP_CONFLICT) max(maxLP[Q-t],max(qLP,maxLP[Q])-1e-6,maxLP[Q+t])  : IF MULTIMODE_MP_DELTA2 > MULTIMODE_MP_DELTA1 && !MULTIMODE_FIX4
                     max(t=0..MULTIMODE_MP_CONFLICT) max(peakLP[Q-t],max(mLP,peakLP[Q])-1e-6,peakLP[Q+t]) : IF MULTIMODE_FIX4

     mLP : LP computed by mprobeval(), corresponding to interval values fixYdel[Q+1] == Xmid[Q]
     
     D[Q] : -1 if interval Q is not being changed, 0 if interval Q has already converged (min(Xhigh[Q]-Xmid[Q],Xmid[Q]-Xlow[Q]) <= min(DELTA_RES,DELTA_REL*Xmid[Q])), >= 1 otherwise
     Dcnt : number of D[Q] values > 0
     DcntT :  sum of D[Q] values > 0
     DcntS : sum of Xhigh[Q]-Xlow[Q] for D[Q] values > 0

     Xnew[Q] : new interval value being tested for interval Q (assuming all other intervals have value fixYdel[Q+1]) (Only valid if D[Q] = 1)
     All interval test values are always located at delta[Q][0..D[Q]-1], as an offset from the current value fixYdel[Q+1].
     NOTE : If MULTIMODE_MP > 0, additional test points may be used. In that case D[Q] > 1.

     singlechange : > 0 IFF previous iteration had to backtrack (to the best single interval change),
                    >= (ADAPTIVE ? 2 : 1) : Update only the best interval to the best local value

     Lcnt[Q] : Number of consecutive iterations (without backtracking) in which Xlow[Q] was increased.
     Rcnt[Q] : Number of consecutive iterations (without backtracking) in which Xhigh[Q] was decreased.
        (Large values of Lcnt[Q] (or Rcnt[Q]) suggest that the local maxima for interval Q may have moved up (or down) due to changes in other intervals).

     
   */

  //  double *testLPA = new double[MD];

  /* Goldenmean search */
  int nullcnt= 0;/* number of consecutive iterations without any progress : terminate if >= 10 */
  while(iter < GM_ITER && Dcnt > 0 && nullcnt <= 10){
    iter++;
    ifirst = ilast = -1;
    for(register int Q=1; Q < N; Q++){
      if(D[Q] > 0){
	if(ifirst < 0)
	  ifirst = Q;
	ilast = Q;
	if(DEBUG && !(Xlow[Q] <= fixYdel[Q+1] + 1e-8 && fixYdel[Q+1] <= Xhigh[Q] + 1e-8)){
	  printf("Before mprobeval:Q=%d:Xbest[Q]=%0.10f,Xcur[Q]=%0.10f,Xlow[Q]=%0.10f,Xmid[Q]=%0.10f,Xhigh[Q]=%0.10f\n",Q,Xbest[Q],fixYdel[Q+1],Xlow[Q],Xmid[Q],Xhigh[Q]);
	  fflush(stdout);
	  assert(Xlow[Q] <= fixYdel[Q+1] + 1e-8 && fixYdel[Q+1] <= Xhigh[Q] + 1e-8);
	}
      }
    }
    if(DEBUG) assert(0 <= ifirst && ifirst <= ilast && ilast <= N);

    /* generate union of intervals ifirst..ilast with ifirstP..ilastP : this is needed since there is only a single Ymin..Ymax range for both LP and delta updates */
    if(ifirstP > ilastP){
      ifirstP = ifirst;
      ilastP = ilast;
    } else {
      ifirstP = min(ifirstP,ifirst);
      ilastP = max(ilastP,ilast);
    }

    if(DEBUG) assert(fixYdel[0] == 0.0);
    register double cum = 0.0;
    fixY[0] = cum;
    for(register int I = 1; I <= N+1; I++){
      cum += fixYdel[I];
      fixY[I] = cum;
    }

    if(DEBUG) assert(NmaxLP >= N);
    for(int sum = 0, Q = 0; Q < N; Q++){
      Dcum[Q] = sum;
      sum += max(0,D[Q]);
    }
    if(DEBUG) assert(Dcum[N-1] + max(0,D[N-1]) == DcntT);
    Dcum[N] = DcntT;

    if(HEAP_MINIMIZE){/* free lightweight heap to minimize real memory usage */
      delete heap;
      heap = new lightweight_heap(0,0);      
    }

    if(MDEBUG && newLPaPr[0]) { delete [] newLPaPr[0]; newLPaPr[0] = 0;}

    if(VMEM_MINIMIZE)
      DoubleAllocations_free();

    if(!VMEM_MINIMIZE){
      /* free newLPa[] */
      if(newLPa[0]) { free(newLPa[0]); newLPa[0] = 0;}
      MaxAddcnt = 0;

      /* reallocate newLPdelta[], if needed */
      if(newLPdeltaMem){
	free(newLPdeltaMem);
	newLPdeltaMem = 0;
      }

      if(VERB>=2){
	//	dumpmemmap();
	printf("Reallocating newLPdelta[]: DcntT=%d,MaxDelta=%d->%d\n",DcntT,MaxDelta,DcntT);
	fflush(stdout);
      }
      MaxDelta = DcntT;
      long long siz = ((long long)MD)*MaxDelta;
      newLPdeltaMem = (double *)malloc(siz * sizeof(double));
      if(!newLPdeltaMem){
	printf("mprobevalwinResize(): malloc failed while allocating newLPdeltaMem[],siz=%lld\n",siz);
	fflush(stdout);
	exit(1);
      }
      if(VERB>=3){
	printf("reallocated newLPdeltaMem=%p..%p(siz=%lld,MD=%d,MaxDelta=%d)\n",newLPdeltaMem, &newLPdeltaMem[siz-1],siz,MD,MaxDelta);
	fflush(stdout);
      }
      long long DeltaCnt = 0;
      for(int m = 0; m < MD; m++){
	newLPdelta[m] = &newLPdeltaMem[DeltaCnt];
	DeltaCnt += DcntT;
      }
      if(DEBUG) assert(DeltaCnt <= ((long long)MD)*MaxDelta);

      if((MDEBUG && (MDEBUG_DELTA || (MDEBUG_TS >= 0 &&  MDEBUG_TT >= 0)) && MDEBUG_T < 0 && MDEBUG_S < 0) || DEBUG>=2)
	for(register int m = 0; m < MD; m++)
	  for(register int d = 0; d < DcntT; d++)
	    newLPdelta[m][d] = LARGE_NEGATIVE;
    }

    if(VERB>=2){
      printf("After reallocating newLPdeltaMem:\n");
      dumpmemmap();
      fflush(stdout);
    }

    //    MDEBUG = 0;
    //    MDEBUG_M = -1;
    //    if(ifirstP == 64 && ilastP== 103 && Dcnt == 40 && DcntT == 50){
    //      MDEBUG = 1;
    //      MDEBUG_M = 140;
      //      MTRACE = 1;
      //      MDEBUG_TS = 28;
      //      MDEBUG_TT = 0;
    //    }

    if(VERB>=2 || SVERB || ERRPLOT){
      printf("Before calling mprobeval:N=%d\n",N);
      for(register int Q = 1; Q < N; Q++){
	if(D[Q] <= 0)
	  continue;
	printf("Q=%d:D[Q]=%d:Xbest[Q]=%0.7f,Xcur[Q]=%0.7f,Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,Xnew[Q]=%0.7f,minKB=%0.7f\n",
	       Q,D[Q],Xbest[Q],fixYdel[Q+1],Xlow[Q],Xmid[Q],Xhigh[Q],Xnew[Q],minKB);
	if(VERB>=3)
	  for(register int t = 0; t < D[Q];t++)
	    printf("   t=%d:delta[Q][t]=%0.7f,fixYdel[Q+1]=%0.7f,X[t]=%0.7f,Q=%d\n",t,delta[Q][t],fixYdel[Q+1],delta[Q][t]+fixYdel[Q+1],Q);
      }
      fflush(stdout);
    }

    if(SPEEDCHECK){
      printf("mprobeval(%d..%d):Dcnt=%d(%d..%d,sum=%d),sum(Xhigh-Xlow)=%0.5f,N=%d,SC=%5d(Q=%5d,%0.5f,P=%0.5f,T=%0.5f),iter=%2d:",ifirstP,ilastP,Dcnt,ifirst,ilast,DcntT,DcntS,N,singlechange ? -singlechange : ChangeCnt,
	     bestQ, (bestQ >= 0 ? bestLPdelta-mLP : 0.0), predLPdelta, totLPdelta, iter);
      fflush(stdout);
    }
    score_init(N,fixY,MD,MX,X);
    double start = mtime(), wstart = wtime();
    // rverb = (MDEBUG && MDEBUG_M >= 0) ? 1 : 0;
    mLP = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,newLPA,mapWT,bestLPA,fixY[ifirstP],fixY[ilastP+1],0,0,pcontig);
    //    rverb = 0;
    double wt1 = wtime();

    //    rverb = (ifirstP==22 && ilastP==131 && Dcnt==105 && DcntT==119) ? 1 : 0;
    //    rverb = (iter >= 51) ? 1 : 0;
#if 0 // testLPA required
    double mLP2 = mprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap[MD],TBmapWT,testLPA,newLPA,fixY[ifirst],fixY[ilast+1],0,0,D,delta,/* LPdel */ 0,
			    0,0,LPdelta,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,newLPdelta,Dcum,AminM,AmaxM,pcontig,skipmap,0);
#else
    double mLP2 = mprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap[MD],TBmapWT,newLPA,newLPA,fixY[ifirst],fixY[ilast+1],0,0,D,delta,/* LPdel */ 0,
			    0,0,LPdelta,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,newLPdelta,Dcum,AminM,AmaxM,pcontig,skipmap,0);
#endif
    //    rverb = 0;

    if(DEBUG>=1+RELEASE && !(fabs(mLP2 - mLP) < (USE_MFLOAT ? 1e-6 + EPS2 * 1000.0 : 1e-7 + EPS2 * 100.0) * MD)){
      double *fullLPA = new double[MD];
      //      rverb = 1;
      double qLP2 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,fullLPA,mapWT,0,0.0,0.0,0,0,pcontig);
      //      rverb = 0;

      printf("\nWARNING:mLP2=%0.8f,qLP=%0.8f(err=%0.8f, EPS2*MD=%0.8f),qLP2=%0.8f\n",mLP2,mLP,mLP2-mLP,EPS2*MD,qLP2);
      if(DEBUG>=1+RELEASE)
	for(int m = 0; m < MD; m++)
	  if((fabs(bestLPA[m]-fullLPA[m]) >= 1e-7 || fabs(fullLPA[m]-newLPA[m]) >= 1e-7 + EPS2*100.0) && TBmapWT[m] > 0.0)
	    //	    printf("m=%d:bestLPA[m]=%0.8f,qLPA[m]=%0.8f,mLPA[m]=%0.8f(err=%0.8f),fullLPA[m]=%0.8f\n",m,bestLPA[m],newLPA[m],testLPA[m],testLPA[m]-newLPA[m],fullLPA[m]);
            printf("m=%d:bestLPA[m]=%0.8f,mLPA[m]=%0.8f(err=%0.8f),fullLPA[m]=%0.8f,TBmapWT[m]= %0.8f\n",m,bestLPA[m],newLPA[m],newLPA[m]-fullLPA[m],fullLPA[m],TBmapWT[m]);

      fflush(stdout);
      delete [] fullLPA;
      assert(fabs(mLP2 - mLP) < (USE_MFLOAT ? 1e-5 + EPS2 * 100000.0: 1e-6 + EPS2 * 1000.0) * MD);
    }

    //    double origmLP = mLP;
    mLP = mLP2;

    if(VERB>=2 || ERRPLOT || SPEEDCHECK){
      double wt = wtime();
      double mt = mtime();
      printf("mLP=%0.6f(delta=%0.6f)NC=%d:time=%0.5f,wall=%0.5f+%0.5f(cum=%0.5f)\n",mLP2,mLP-qLP,nullcnt,mt-start,wt1-wstart,wt-wt1, wt);
      //      printf("\t Y[1]=%0.3f,Y[2]=%0.3f,Y[N+1=%d]=%0.3f, mprobeval range=%d..%d(%0.3f..%0.3f)\n",fixY[1],fixY[2],N+1,fixY[N+1],ifirstP,ilastP,fixY[ifirstP],fixY[ilastP+1]);
      if(VERB>=3)/* display last 600 labels */
	for(int I = max(0, N-600); I <= N+1; I++)
	  printf("\tfixY[%d]= %0.6f\n", I, fixY[I]);
      if(VERB>=2 && SVERB){
	double LLRsum1 = 0.0;
	//	double LLRsum2 = 0.0;
	printf("\t qLP=%0.6f (err=%0.6f)\n",mLP,mLP2-mLP);
	for(int m = 0; m < MD; m++){
	  LLRsum1 += newLPA[m] * TBmapWT[m];
#if 0 // testLPA required
	  LLRsum2 += testLPA[m] * TBmapWT[m];
	  printf("m=%d:newLPA[m]= %0.6f, testLPA[m]= %0.6f, TBmapWT[m]= %0.6f (cum= %0.6f, %0.6f)\n",m, newLPA[m], testLPA[m], TBmapWT[m], LLRsum1, LLRsum2);
#else
	  printf("m=%d:newLPA[m]= %0.6f, TBmapWT[m]= %0.6f (cum= %0.6f)\n",m, newLPA[m], TBmapWT[m], LLRsum1);
#endif
	}
      }
      fflush(stdout);
      //      exit(1);
    }

#if 0 // testLPA required
    double *tmp = testLPA; testLPA = newLPA; newLPA = tmp;
#endif

    //    if(ilastP==248 && iter >= 7) exit(1);

    if(fabs(mLP-qLP) < 1e-6){
      if(++nullcnt > 10){
	if(VERB){
	  printf("no progress for %d iterations : giving up\n",nullcnt);
	  fflush(stdout);
	}
	break;
      }
    } else
      nullcnt = 0;

    //    int origDcnt = Dcnt; // origDcntT = DcntT;

    if(DEBUG>=2 || MDEBUG){/* check if full qprobeval value matches mLP */
      qLPcnt++;
      double *fullLPA = new double[MD];
      double qLP3 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,fullLPA,mapWT,0,0.0,0.0,0,0,pcontig);
      if(VERB>=2 || SVERB || ERRPLOT){
	printf("   Exact qLP3=%0.10f(err=%0.10f):qLPcnt=%d\n",qLP3,mLP-qLP3,qLPcnt);
	fflush(stdout);
      }
      if(DEBUG && !(fabs(qLP3 - mLP) < 1e-8)){
	double *testLPA = new double[MD];
	double qLP2 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,bestLPA,fixY[ifirstP],fixY[ilastP+1],0,0,pcontig);
	printf("WARNING: Exact qLP3=%0.10f,mLP=%0.10f (err=%0.10f), Yrange=Y[%d..%d]=%0.3f to %0.3f, qLP2=%0.10f(err=%0.10f)\n",
	       qLP3,mLP,mLP-qLP3, ifirstP,ilastP+1,fixY[ifirstP],fixY[ilastP+1], qLP2, qLP2-qLP3);
	for(register int m = 0; m < MD; m++)
	  if(fabs(testLPA[m]-fullLPA[m]) >= 2e-9){
	    int L,R, HL= -1,HR = -1;
	    for(L = 1; L <= MX[m]; L++)
	      if((HL = map[m][L]) > 0)
		break;
	    for(R = MX[m]; R >= 1; R--)
	      if((HR = map[m][R]) > 0)
		break;
	    if(HR >= 0 && HL >= 0)
	      printf("m=%d(id=%lld):bestLPA[m]=%0.10f,qLP3[m]=%0.10f,qLP2[m]=%0.10f(err=%0.10f)  aligned at Hcuts[%d..%d]=%0.3f..%0.3f\n",
		     m,gmap[pcontig->contig[m].mapid]->id,bestLPA[m],fullLPA[m],testLPA[m],testLPA[m]-fullLPA[m],HL,HR,Hcuts[HL],Hcuts[HR]);
	    else
	      printf("m=%d(id=%lld):bestLPA[m]=%0.10f,qLP3[m]=%0.10f,qLP2[m]=%0.10f(err=%0.10f)  no aligned region found:L=%d,R=%d,M=%d\n",
		     m,gmap[pcontig->contig[m].mapid]->id,bestLPA[m],fullLPA[m],testLPA[m],testLPA[m]-fullLPA[m],L,R,MX[m]);
	  }
	/*	for(register int i = ilast+1; i <= N+1;i++)
		printf("Y[%d]=%0.3f\n",i,Y[i]);*/
	fflush(stdout);
	assert(fabs(qLP3-mLP) < 1e-6 || (qLP3 >= mLP - 0.01));
	delete [] testLPA;
      }
      delete [] fullLPA;
    }

    if(MDEBUG && (MDEBUG_DELTA || (MDEBUG_TS >= 0 &&  MDEBUG_TT >= 0)) && MDEBUG_T < 0 && MDEBUG_S < 0){
      double *testLPA = new double[MD];

      double maxerr = -1000.0;/* worst error for any single interval change for LP sum over all maps */
      int maxerrT = -1;/* interval left site, corresponding to worst error */
      int maxerrD = -1;/* change value index, corresponding to worse error */

      double ErrMax = -1000.0;/* worst error for any single interval change for any single map */
      double trueLP = -1000.0;
      int maxM = -1;/* map index */
      int maxT = -1;/* interval left site */
      int maxD = -1;/* change value index */
      double maxWT = 0.0;

      for(register int Q=1; Q < N; Q++){
	if(D[Q] <= 0)
	  continue;
	double origval = fixYdel[Q+1];
	for(register int t = 0; t < D[Q]; t++){
	  if((MDEBUG_TS < 0 || Q==MDEBUG_TS) && (MDEBUG_TT < 0 || t==MDEBUG_TT) && MDEBUG_T < 0 && MDEBUG_S < 0){
	    register double testLP = LPdelta[Q][t];
	    register double val = delta[Q][t] + origval;
	    fixYdel[Q+1] = val;

	    register double cum = 0.0;
	    fixY[0] = cum;
	    for(register int I = 1; I <= N+1; I++){
	      cum += fixYdel[I];
	      fixY[I] = cum;
	    }
	    score_init(N,fixY,MD,MX,X);
	    double qLP2 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,newLPA,fixY[ifirstP],fixY[ilastP+1],0,0,pcontig);
	    if(VERB/* >=2*/){
	      if((qLP2 > mLP-LP_DROP || testLP > mLP) && (!MDEBUG_NEGERR || testLP < qLP2))
		printf("    Y[%d..%d]=%0.6f->%0.6f(t=%d/%d): testLP=%0.10f (delta=%0.10f), qLP2=%0.10f (err = %0.10f)\n", 
		       Q,Q+1,origval, val, t, D[Q], testLP, testLP - mLP, qLP2, testLP - qLP2);
	      else
		printf("    Y[%d..%d]=%0.6f->%0.6f(t=%d/%d): testLP=%0.10f (delta=%0.10f), qLP2=%0.10f (err = %0.10f:ignored)\n", 
		       Q,Q+1,origval, val, t, D[Q], testLP, testLP - mLP, qLP2, testLP - qLP2);
	      fflush(stdout);
	    }
	    if((qLP2 > mLP-LP_DROP || testLP > mLP) && fabs(testLP-qLP2) > maxerr && (!MDEBUG_NEGERR || testLP < qLP2)){
	      maxerr = fabs(testLP-qLP2);
	      maxerrT = Q;
	      maxerrD = t;
	    }
	    for(int m = 0; m < MD; m++){
	      double newLPmQt = (Q >= AminM[m] && Q <= AmaxM[m]) ? newLPdelta[m][Dcum[Q]-Dcum[AminM[m]]+t] : newLPA[m];
	      double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
	      if(VERB && (VERB>=2 /* ||(N==112 && Q==101 && t==0) */ || (Q==MDEBUG_TS && t==MDEBUG_TT && m==MDEBUG_M)
			  || ((testLPA[m] > newLPA[m] - LP_DROP*0.1 || newLPmQt > newLPA[m]) && fabs(newLPmQt - testLPA[m]) * TBwtm > max(ErrMax, MDEBUG_ERR)))){
		printf("Q=%d,t=%d,m=%d(id=%lld):mLP[m]=%0.10f,newLPdelta[m][S,d]=%0.10f,testLPA[m]=%0.10f(err=%0.10f)",
		       Q,t,m,gmap[pcontig->contig[m].mapid]->id,newLPA[m], newLPmQt, testLPA[m], newLPmQt - testLPA[m]);
		if(testLPA[m] <= bestLPA[m] - LP_DROP*0.1 && newLPmQt <= bestLPA[m])
		  printf(":ignored");
		printf("\n");
		fflush(stdout);
	      }
	      if(DEBUG) assert(newLPmQt > LARGE_NEGATIVE * 0.9);
	      if((testLPA[m] > newLPA[m] - LP_DROP*0.1 || newLPmQt > newLPA[m] || (maxerr > MDEBUG_ERR && maxerrD == t && maxerrT == Q)) && fabs(newLPmQt - testLPA[m])*TBwtm > ErrMax
		 && (!MDEBUG_NEGERR || newLPmQt < testLPA[m])){
		ErrMax = fabs(newLPmQt - testLPA[m]) * TBwtm;
		trueLP = testLPA[m];
		maxT = Q;
		maxD = t;
		maxM = m;
		maxWT = TBwtm;
	      }
	    }
	    
	    if(ErrMax >= 0.0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0 && N == MDEBUG_N && maxT >= 0){
	      double newLPmQt = (maxT >= AminM[maxM] && maxT <= AmaxM[maxM]) ? newLPdelta[maxM][Dcum[maxT]-Dcum[AminM[maxM]]+maxD] : newLPA[maxM];
	      printf("Interval/Delta/map with worst error so far is Q=%d(%0.3f),t=%d(%0.3f),m=%d(id=%lld):mLP[m]=%0.10f,newLPdelta[m][Q,t]=%0.10f,trueLP=%0.10f,|err|=%0.10e\n",
		     maxT,fixYdel[maxT+1],maxD,delta[maxT][maxD],maxM,gmap[pcontig->contig[maxM].mapid]->id,newLPA[maxM],newLPmQt,trueLP,ErrMax);
	      fflush(stdout);
	      if(DEBUG) assert(maxT >= 0 && maxM >= 0 && maxD >= 0);

	      printf("Calling qprobeval after modifying interval Q=%d(%0.3f),t=%d(%0.3f)\n", maxT,fixYdel[maxT+1],maxD,delta[maxT][maxD]);
	      fflush(stdout);

	      rverb = 1;
	      double qLP3 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,testLPA,mapWT,newLPA,fixY[ifirstP],fixY[ilastP+1],0,0,pcontig);
	      rverb = 0;

	      printf("qLP3= %0.10f\n",qLP3);
	      fflush(stdout);

	      //	      printf("Calling mprobeval after modifying interval Q=%d(%0.4f -> %0.3f),t=%d(%0.3f)\n", maxT,origval,fixYdel[maxT+1],maxD,delta[maxT][maxD]);
	      //	      fflush(stdout);

	      printf("Calling mprobeval after changing Y[Q=%d..%d] from %0.4f to %0.4f (delta[Q][t=%d]= %0.4f)\n",Q,Q+1,origval,fixYdel[Q+1],t,delta[Q][t]);
	      fflush(stdout);
	    
	      //	      MDEBUG_ST = 66;

	      double mLP2 = mprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap[MD],TBmapWT,testLPA,newLPA,fixY[ifirstP],fixY[ilastP+1],0,0,0,delta,LPdel,0,0,0,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,newLPdelta,Dcum,AminM,AmaxM,pcontig,0,0);
	      printf("mLP2=%0.10f\n",mLP2);
	      fflush(stdout);

	      exit(1);
	    }

	    /* restore original value */
	    fixYdel[Q+1] = origval;
	  }
	} /* t = 0 .. D[Q] - 1 */
      } /* Q = 1 .. N-1 */
      if(MDEBUG_T < 0){
	if(maxerr >= 0.0){
	  printf("Worst interval change error =%0.10e at Q=%d,t=%d(%0.3f) (excluding when LP drops by %0.3f or more)\n",maxerr,maxerrT,maxerrD,delta[maxerrT][maxerrD],LP_DROP);
	  fflush(stdout);
	  if(DEBUG) assert(maxerrT >= 0 && maxerrD >= 0);
	}
	if(ErrMax >= 0.0){
	  double newLPmQt = (maxT >= AminM[maxM] && maxT <= AmaxM[maxM]) ? newLPdelta[maxM][Dcum[maxT]-Dcum[AminM[maxM]]+maxD] : newLPA[maxM];
	  printf("Interval/change/map with worst interval change error is Q=%d(%0.3f),t=%d(%0.3f),m=%d(id=%lld),N=%d:mLP[m]=%0.10f->%0.10f,newLPdelta[m][Q,t]=%0.10f,trueLP=%0.10f,|err|=%0.10e,wt=%0.5f(excluding when LP drops by %0.3f or more)\n",
		 maxT,fixYdel[maxT+1],maxD,delta[maxT][maxD],maxM,gmap[pcontig->contig[maxM].mapid]->id,N,bestLPA[maxM],newLPA[maxM],newLPmQt,trueLP,ErrMax,maxWT, LP_DROP*0.1);
	  fflush(stdout);
	  if(DEBUG) assert(maxT >= 0 && maxD >= 0 && maxM >= 0);
	  if(DEBUG) assert(ErrMax < MDEBUG_ERR);
	}
      }

      delete [] testLPA;
    }

    //    MDEBUG = 1;
    //    MDEBUG_M = -1;

    int origIJ = initialjump;
    int origSC = singlechange;

    if(!singlechange && mLP - qLP < 0.5 * predLPdelta && DELTA1 > MIN_DELTA1){
      double nDELTA1 = max(MIN_DELTA1, DELTA1 * 0.5);
      if(VERB){
	printf("\t Changing DELTA1 from %0.6f to %0.6f (mLP-qLP= %0.6f, predLPdelta= %0.6f, ChangeCnt=%d)\n",
	       DELTA1, nDELTA1, mLP-qLP,predLPdelta,ChangeCnt);
	fflush(stdout);
      }
      DELTA1 = nDELTA1;
    }

    if(((ChangeCnt > 0 && mLP < qLP - 1e-6) || (bestQ >= 0 && mLP < bestLPdelta - 1.0)) && 
       !(mLP >= qLP - 1e-6 && !(bestQ >= 0 && bestLPdelta > qLP + LP_MINDELTA) && singlechange < (ADAPTIVE ? 2 : 1))){/* backtrack */
      if(origSC >= (ADAPTIVE ? 2 : 1))/* last single interval change failed : force complete backtrack next */
	bestQ = -1;

      if(VERB>=2 || SVERB || ERRPLOT){
	/* compute what would have been bestLPdelta,bestX,bestQ,totLPdelta (except for backtrack) */
	double mybestLPdelta = mLP, mybestX = 0.0, mytotLPdelta = 0.0;
	int mybestQ = -1;

	for(int Q = 1; Q < N; Q++){
	  if(D[Q] <= 0)
	    continue;
	  double testLPT = -1e300;
	  int maxt = -1;
	  for(int t = 0; t < D[Q]; t++){
	    double testLP = LPdelta[Q][t];
	    if(testLP > testLPT){
	      testLPT = testLP;
	      maxt = t;
	    }
	  }
	  if(DEBUG) assert(maxt >= 0);
	  if(testLPT > mLP){
	    mytotLPdelta += testLPT - mLP;
	    if(testLPT > mybestLPdelta){
	      mybestLPdelta = testLPT;
	      mybestX = delta[Q][maxt] + fixYdel[Q+1];
	      mybestQ = Q;
	    }
	  }
	}
	if(mybestQ >= 0)
	  printf(" Except for backtrack: best single interval change:Q=%d,Y[Q]=%0.3f->%0.3f,LP=%0.6f(delta=%0.6f),totLP=%0.6f\n",
		 mybestQ,Xbest[mybestQ],mybestX,mybestLPdelta,mybestLPdelta-mLP,mytotLPdelta);
	else
	  printf(" Except for backtrack: best single interval change:Q=%d,LP=%0.6f(delta=%0.6f),totLP=%0.6f\n",
		 mybestQ,mybestLPdelta,mybestLPdelta-mLP,mytotLPdelta);
	fflush(stdout);
      }

      singlechange = 1;/* If ADAPTIVE , this just flags next iteration to prevent reset of initialjump (except on 2nd backtrack), otherwise next iteration will also be single change */

      Dcnt = DcntT = 0;
      DcntS = 0.0;
      predLPdelta = totLPdelta = 0.0;

      #pragma omp parallel num_threads(nthreads) if(!MSAN && nthreads > 1 && !SVERB)
      {
	int myDcnt = 0, myDcntT = 0;
	double myDcntS = 0.0, myDcntX = 0.0;
	double mytotLPdelta = 0.0;

	#pragma omp for schedule(static,64)
	for(int Q = 1; Q < N; Q++){
	  if(D[Q] < 0)
	    continue;

	  // NOTE : It is possible that D[Q] == 0 because Goldenmean was terminated in last iteration AFTER making a small change : this change needs to be undone

	  double origval = fixYdel[Q+1];
	  double testLPT = -1e300;
	  int maxt = -1;
	  if(MULTIMODE_MP > 0 && D[Q] > 0){
	    for(int t = 0; t < D[Q]; t++){
	      double testLP = LPdelta[Q][t];
	      if(testLP > testLPT){
		testLPT = testLP;
		maxt = t;
	      }
	    }
	    if(testLPT > mLP)
	      mytotLPdelta += testLPT - mLP;
	    if(DEBUG) assert(maxt >= 0);
	  }

	  if(VERB>=2 || SVERB || ERRPLOT){
	    if(D[Q] >= 1){
	      printf("Q=%d:Xbest=%0.7f,Xcur=%0.7f:Xlow=%0.7f,Xmid=%0.7f(LP=%0.6f),Xhigh=%0.7f:Xnew=%0.7f,X[%d/%d]=%0.7f(LP=%0.6e,delta=%0.6e),totLP=%0.6f,Lcnt=%d,Rcnt=%d,IJ=%d,SC=%d->%d(backtracking)\n",
	         Q,Xbest[Q],fixYdel[Q+1],Xlow[Q],Xmid[Q],maxLP[Q],Xhigh[Q],Xnew[Q],maxt,D[Q],delta[Q][maxt]+origval, testLPT, testLPT - mLP, mytotLPdelta, Lcnt[Q],Rcnt[Q],initialjump,origSC,singlechange);
	      if((VERB>=2 || SVERB || ERRPLOT) && D[Q] >= 1)
		for(register int t = 0; t < D[Q]; t++)
		  printf("         X[%d]=%0.7f(LP=%0.6f,delta= %0.6f)\n",t,delta[Q][t]+fixYdel[Q+1], LPdelta[Q][t], LPdelta[Q][t] - mLP);
	    } else if(SLOWMULTIMODE)
	      printf("Q=%d:Xbest=%0.7f,Xcur=%0.7f:Xlow=%0.7f,Xmid=%0.7f,Xhigh=%0.7f:Lcnt=%d,Rcnt=%d,IJ=%d,SC=%d->%d(Completed)(backtracking)\n",
		     Q,Xbest[Q],fixYdel[Q+1],Xlow[Q],Xmid[Q],Xhigh[Q],Lcnt[Q],Rcnt[Q],initialjump,origSC,singlechange);
	    fflush(stdout);
	  }
	  if(DEBUG>=2 && !(origval >= minKB - 2e-9)){
	    printf("origval=fixYdel[Q+1]=%0.10f,minKB=%0.10f\n",origval,minKB);
	    fflush(stdout);
	    assert(origval >= minKB - 2e-9);
	  }
	  if(DEBUG && !MULTIMODE_MP) assert(D[Q]<=1);
	  if(DEBUG>=2 && D[Q] > 0) assert(Xnew[Q] >= minKB - 1e-8);

	  if(Q==bestQ && bestLPdelta > qLP){ /* Q==bestQ && bestLPdelta > qLP : leave Xlow[Q],Xmid[Q],Xhigh[Q],Xnew[Q] and fixYdel[Q+1] unchanged. If MULTIMODE_FIX2 also leave sample points unchanged */
            if(MULTIMODE_FIX2) {/* leave D[Q] sample points unchanged */

	      if(D[Q] > 0){// NOTE : it is possible that Xhigh[Q]-Xlow[Q] is already below DELTA_RES,DELTA_REL limit
                myDcntT += D[Q];
	        myDcntS += Xhigh[Q] - Xlow[Q];
	        myDcnt++;
		if(VERB>=2 || SVERB || ERRPLOT)
		  myDcntX += Xmid[Q];
              }

   	      if(VERB>=2 || SVERB || ERRPLOT){
	        #pragma omp critical
	        {
	          printf("   Repeating test points for Y[Q=%d]= %0.6f:D[Q]=%d,testLPT=%0.8e,mLP=%0.6f,IJ=%d,maxt=%d:Dcnt=%d(tot=%d,sum=%0.3f,sumX=%0.3f),Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f\n",
			 Q,origval,D[Q],testLPT,mLP,initialjump,maxt,myDcnt,myDcntT,myDcntS,myDcntX,Xlow[Q],Xmid[Q],Xhigh[Q]);
		  for(register int t = 0; t < D[Q]; t++)
		    printf("        t=%d:delta[Q][t]=%0.7f,origval=%0.7f,Xcur=%0.7f,X[t]=%0.7f,minKB=%0.7f,Q=%d\n",
			   t,delta[Q][t],origval,fixYdel[Q+1],delta[Q][t]+origval,minKB,Q);
		  fflush(stdout);
		}
              }

              continue;
            }
          } else {	  /* !(Q==bestQ && bestLPdelta > qLP) : backtrack Xmid[Q]==fixYdel[Q+1] to Xbest[Q] */

	    Xmid[Q] = fixYdel[Q+1] = Xbest[Q];/* NOTE : origval is still the original value of fixYdel[Q+1] */
	    Lcnt[Q] = Rcnt[Q] = 0;

	    if(D[Q] <= 0){
              if(VERB>=2 || (SVERB/* HERE >=2 */ && fabs(origval - Xmid[Q]) >= 0.0001)){
                printf("   No test points after backtrack of Y[Q=%d] from %0.6f to %0.6f:D[Q]=%d\n",Q,origval,Xmid[Q], D[Q]);
	        fflush(stdout);
	      }
	      continue;
            }

	    double testLP = LPdelta[Q][maxt];
	    double peakval = delta[Q][maxt] + origval;

	    if(MULTIMODE_FIX2){ // try to preserve multiple useful sample points (typically origval and best prediction value peakval == delta[Q][maxt]) 
	      int tmin,tmax;
              double LB, UB;

	      if(testLP > mLP + LP_MINDELTA){/* try to preserve origval only */
                LB = min(Xmid[Q], origval);
		UB = max(Xmid[Q], origval);
              } else {/* try to preserve origval and peakval */
                LB = min(Xmid[Q], min(origval,peakval));
		UB = max(Xmid[Q], max(origval,peakval));
              }

              /* expand Xlow[Q] .. Xhigh[Q] to LB .. UB */
	      for(tmin = D[Q] - 1; tmin >= 0; tmin--)
		if(delta[Q][tmin] + origval + 1e-8 < LB){
		  Xlow[Q] = delta[Q][tmin] + origval;
		  break;
  	        }
	      for(tmax = 0; tmax < D[Q]; tmax++)
		if(delta[Q][tmax] + origval > UB + 1e-8){
		  Xhigh[Q] = delta[Q][tmax] + origval;
		  break;
		}

	      Xlow[Q] = max(minKB, Xlow[Q]);
	      double range = Xhigh[Q]-Xlow[Q];

	      if(Xhigh[Q] <= Xmid[Q] + 1e-8)
		Xhigh[Q] = Xmid[Q] + range * resphi;
	      if(Xlow[Q] >= Xmid[Q] - 1e-8)
		Xlow[Q] = max(minKB, Xmid[Q] - range * resphi);

	      int DQ = D[Q];

	      if(VERB>=2 || SVERB){
                printf("Q=%d: expanded range: Xlow[Q] -> %0.7f, Xhigh[Q] -> %0.7f, Xmid[Q]= %0.7f, origval= %0.7f, peakval= %0.7f, testLP-mLP= %0.6f, minKB= %0.7f,tmin=%d,tmax=%d,DQ=%d,range=%0.7f\n",
	           Q,Xlow[Q],Xhigh[Q],Xmid[Q],origval,peakval,testLP-mLP,minKB,tmin,tmax,DQ,range);
		fflush(stdout);
              }
	      if(DEBUG>=2) assert((Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-6) && Xmid[Q] < Xhigh[Q]);
	      if(DEBUG) assert(Dsiz[Q] >= 2);

	      D[Q] = 0;
              if(!DELTA_FIX3 || fabs(origval - Xmid[Q]) >= 1e-8){
                delta[Q][D[Q]++] = origval - Xmid[Q];
		if(VERB>=2 || SVERB){
		  printf("Q=%d: Y[Q]= %0.7f -> %0.7f: picking origval as test point: Xlow[Q]= %0.7f, Xhigh[Q]= %0.7f, peakval= %0.7f,tmin=%d,tmax=%d,DQ=%d\n", 
	             Q, origval, Xmid[Q], Xlow[Q],Xhigh[Q],peakval,tmin,tmax,DQ);
		  fflush(stdout);
		}
		if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < origval || Xlow[Q] <= minKB + 1e-6) && origval < Xhigh[Q]);
	      }

	      if(!(testLP > mLP + LP_MINDELTA)){/* also add peakval */
                if(!DELTA_FIX3 || fabs(peakval - Xmid[Q]) >= 1e-8){
		  delta[Q][D[Q]++] = peakval - Xmid[Q];
		  if(VERB>=2 || SVERB){
		    printf("Q=%d: Y[Q]= %0.7f -> %0.7f: picking peakval as test point: Xlow[Q]= %0.7f, Xhigh[Q]= %0.7f, peakval= %0.7f,tmin=%d,tmax=%d,DQ=%d\n", 
	                Q, origval, Xmid[Q], Xlow[Q],Xhigh[Q],peakval,tmin,tmax,DQ);
		    fflush(stdout);
		  }
		  if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < peakval || Xlow[Q] <= minKB + 1e-6) && peakval < Xhigh[Q]);
	        }
              }
	      if(D[Q] >= 2 && peakval < origval){/* sort delta[Q][0..1] */
		delta[Q][0] = peakval - Xmid[Q];
		delta[Q][1] = origval - Xmid[Q];
	      }

	      if(D[Q] <= 0){/* add new point using Goldenmean ratio */
                if(Xhigh[Q] - Xmid[Q] > Xmid[Q] - Xlow[Q])
		  Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q]-Xmid[Q]);
		else
		  Xnew[Q] = Xmid[Q] - resphi*(Xmid[Q]-Xlow[Q]);
		if(VERB>=2 || SVERB){
                  printf("Q=%d: picking Xnew[Q]= %0.7f as test point: Xlow[Q]= %0.7f, Xmid[Q]= %0.7f, Xhigh[Q]= %0.7f, origval= %0.7f,tmin=%d,tmax=%d,DQ=%d\n", 
	              Q, Xnew[Q], Xlow[Q],Xmid[Q],Xhigh[Q],origval,tmin,tmax,DQ);
                  fflush(stdout);
		}
		delta[Q][D[Q]++] = Xnew[Q] - Xmid[Q];
              }

           } else {// !MULTIMODE_FIX2

	      /* expand Xlow[Q]..Xhigh[Q] to include new Xmid[Q] */
	      if(Xmid[Q] < Xlow[Q]){
		Xlow[Q] = Xmid[Q];
		if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
	      }
	      if(Xmid[Q] > Xhigh[Q])
		Xhigh[Q] = Xmid[Q];

	      /* expand range Xlow[Q] .. Xhigh[Q] to include test peak */
	      if(testLP > mLP + LP_MINDELTA){
		if(peakval < Xlow[Q]){
		  Xlow[Q] = peakval;
		  if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
		}
		if(peakval > Xhigh[Q])
		  Xhigh[Q] = peakval;// peakval = Xnew[Q];
	      }

	      /* select next test point Xnew[Q] */
	      if(initialjump){/* set Xnew[Q] to previous fixYdel[Q] to recheck MultiMode peak found originally (but leave Xlow[Q]..Xhigh[Q] unchanged) */
		Xnew[Q] = origval;
		if(DEBUG>=2 && !(Xnew[Q] >= minKB - 2e-9)){
		  printf("Xnew[Q]=%0.10f,origval=%0.10f,fixYdel[Q+1]=%0.10f,minKB=%0.10f\n",Xnew[Q],origval,fixYdel[Q+1],minKB);
		  fflush(stdout);
		  assert(Xnew[Q] >= minKB -2e-9);
		}
	      } else {
		if(MULTIMODE_FIX2){
		  Xnew[Q] = peakval;
		  if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < Xnew[Q] || Xlow[Q] <= minKB + 1e-6) && Xnew[Q] < Xhigh[Q]);
		} else {  /* select next test point Xnew[Q] based on GoldenMean ratio (could be outside of range Xlow[Q] .. Xhigh[Q] */
		  if(Xlow[Q] >= Xmid[Q] - 1e-6 && Xlow[Q] >= minKB + 1e-6){
		    Xnew[Q] = max(minKB,Xmid[Q] - phi*max(1.0,Xhigh[Q] - Xmid[Q]));
		    if(Xnew[Q] < Xlow[Q] * 0.7)
		      Xnew[Q] = Xlow[Q] * 0.7;
		  } else if(Xhigh[Q] <= Xmid[Q] + 1e-6 && Xhigh[Q] <= max(1.0,fixYdel[Q+1]/* WAS origval*/)*4.0){
		    Xnew[Q] = Xmid[Q] + phi * max(1.0,Xmid[Q] - Xlow[Q]);
		    if(Xnew[Q] > Xhigh[Q] * 1.2)
		      Xnew[Q] = Xhigh[Q] * 1.2;
		    if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
		  } else {
		    if(Xhigh[Q] - Xmid[Q] > Xmid[Q] - Xlow[Q])
		      Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q]-Xmid[Q]);
		    else
		      Xnew[Q] = Xmid[Q] - resphi*(Xmid[Q]-Xlow[Q]);
		    if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
		  }
		}
	      }
	    }
          }

	  if(DEBUG>=2) assert(D[Q] >= 1);

	  //	  origval = fixYdel[Q+1];

	  int MPblock = (MPBLOCK && initialjump && testLPT - mLP <= 0.8 * MULTIMODE_MP_DELTA2 && (D[Q] <= 2 || (maxt > 0 && maxt < D[Q]-1)) && abs(Q-bestQ) != 1) ? 1 : 0;
	  int MPscan = (initialjump || (bestLPdelta - qLP > MULTIMODE_MP_DELTA &&/*HERE : should use MULTIMODE_MP_SCAN instead */abs(Q-bestQ) == 1) || 
                                                                                              	(!MULTIMODE_FIX5 && !(D[Q] <= 2 || (maxt > 0 && maxt < D[Q] -1)))) ? 1 : 0;

	  if(DEBUG && !(Xnew[Q] >= minKB - 1e-8)){
	    printf("Q=%d:Xnew[Q]=%0.6f,minKB=%0.6f,Xlow[Q]=%0.6f,Xmid[Q]=%0.6f,Xhigh[Q]=%0.6f,Xcur[Q]=%0.6f,bestQ=%d,D[Q]=%d,MPblock=%d,MPscale=%d\n",
		   Q,Xnew[Q],minKB,Xlow[Q],Xmid[Q],Xhigh[Q],fixYdel[Q+1],bestQ,D[Q],MPblock,MPscan);
	    fflush(stdout);
	    assert(Xnew[Q] >= minKB - 1e-8);
	  }

	  /* NOTE : If MULTIMODE_FIX2, delta[Q][0..D[Q]-1] should already be initialized and D[Q] could be > 1, otherwise only a single sample point Xnew[Q] is known */
	  if(!MULTIMODE_FIX2){
	  
	    /* IF DELTA_FIX3 && Xnew[Q] == fixYdel[Q+1] :
	       1. If MPscan == 1 && !MPblock : Do NOT include Xnew[Q] in delta[Q]
	       2. Else : widen Xlow[Q]..Xhigh[Q] based on delta[Q][maxt-1,maxt+1]+origval) and compute new Xnew[Q]
	    */
            if(DELTA_FIX3 && fabs(Xnew[Q] - fixYdel[Q+1]) <= 1e-8){
	      if(MPscan && !MPblock)
		D[Q] = 0;
	      else {
		if(DEBUG>=2) assert(D[Q] > 0);
		double origXlow = Xlow[Q];
		Xlow[Q] = min(Xlow[Q], delta[Q][max(0,maxt-1)] + origval);
		if(DEBUG>=2 && !(Xlow[Q] >= minKB - 1e-8)){
		  printf("Q=%d:Xlow[Q]=%0.8f->%0.8f,maxt=%d,origval=%0.6f,delta[Q][max(0,maxt-1)]=%0.8f,minKB=%0.8f,fixYdel[Q+1]=%0.8f,mLP=%0.8f,qLP=%0.8f\n",
			 Q,origXlow,Xlow[Q],maxt,origval,delta[Q][max(0,maxt-1)],minKB,fixYdel[Q+1],mLP2,mLP);
		  for(int t = 0; t < D[Q]; t++)
		    printf("t=%d/%d:delta[Q][t]=%0.8f,delY=%0.8f:LP=%0.8f\n",t,D[Q],delta[Q][t],delta[Q][t]+origval,LPdelta[Q][t]);
		  fflush(stdout);
		  assert(Xlow[Q] >= minKB - 1e-8);
		}
		Xhigh[Q] = max(Xhigh[Q], delta[Q][min(D[Q]-1, maxt + 1)] + origval);

		if(MULTIMODE_FIX2){
		  Xnew[Q] = delta[Q][maxt] + origval;
		  if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < Xnew[Q] || Xlow[Q] <= minKB + 1e-6) && Xnew[Q] < Xhigh[Q]);
		} else {      /* select new test point Xnew[Q] (could be outside of range Xlow[Q] .. Xhigh[Q]) */
		  if(Xlow[Q] >= Xmid[Q] - 1e-6 && Xlow[Q] >= minKB + 1e-6){
		    Xnew[Q] = max(minKB,Xmid[Q] - phi*max(1.0,Xhigh[Q] - Xmid[Q]));
		    if(Xnew[Q] < Xmid[Q] * 0.7)
		      Xnew[Q] = Xmid[Q] * 0.7;
		    if(bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
		      Xlow[Q] = min(Xnew[Q],Xlow[Q]);
		    if(DEBUG>=2) assert(Xnew[Q] >= minKB);
		  } else if(Xhigh[Q] <= Xmid[Q] + 1e-6 && Xhigh[Q] <= max(1.0,fixYdel[Q+1]/* WAS origval */)*4.0){
		    Xnew[Q] = Xmid[Q] + phi * max(1.0,Xmid[Q] - Xlow[Q]);
		    if(Xnew[Q] > Xmid[Q] * 1.2)
		      Xnew[Q] = Xmid[Q] * 1.2;
		    if(bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
		      Xhigh[Q] = max(Xnew[Q],Xhigh[Q]);
		    if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
		  } else {
		    if(Xhigh[Q] - Xmid[Q] > Xmid[Q] - Xlow[Q])
		      Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q] - Xmid[Q]);
		    else
		      Xnew[Q] = Xmid[Q] - resphi*(Xmid[Q] - Xlow[Q]);
		    if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
		  }
		}
		delta[Q][0] = Xnew[Q] - fixYdel[Q+1]/* WAS origval */;
		D[Q] = 1;
		if(VERB>=2 || SVERB || ERRPLOT){
		  printf("\t Q=%d: Xnew[Q] -> %0.4f (Xlow[Q]= %0.4f, Xmid[Q]= %0.4f, Xhigh[Q]= %0.4f),D[Q]=%d\n",Q,Xnew[Q], Xlow[Q],Xmid[Q],Xhigh[Q],D[Q]);
		  fflush(stdout);
		}
	      }
	    } else {
	      delta[Q][0] = Xnew[Q] - fixYdel[Q+1]/* WAS origval */;
	      D[Q] = 1;
	    }
	  }
	  if(VERB>=2 || SVERB || ERRPLOT){
	    printf("Q=%d:Xnew[Q]=%0.7f,Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,Xcur[Q]=%0.7f,D[Q]=%d\n",
		   Q,Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],fixYdel[Q+1],D[Q]);
	    fflush(stdout);
	  }

	  origval = fixYdel[Q+1];

	  if(MULTIMODE_MP > 0 && !MPblock){/* add additional test points at intervals of MULTIMODE_MP_MIN, MULTIMODE_MP_MAx */
	    if(MULTIMODE_FIX3){ /* add additional equidistant points between Xlow[Q], S1, S2 and Xhigh[Q] */
              if(1){
		int DQ = D[Q];
                double S1,S2;
		if(DQ > 0){
                  S1 = min(Xmid[Q], origval + delta[Q][0]);
		  S2 = max(Xmid[Q], origval + delta[Q][DQ-1]);
                } else
		  S1 = S2 = (Xlow[Q] + Xhigh[Q]) * 0.5;

		if(VERB>=2 || SVERB/* HERE >=2 */){
                  printf("%d:D[Q]=%d,Xlow[Q]=%0.7f,S1=%0.7f,S2=%0.7f,Xhigh[Q]=%0.7f : picking up to %d additional test points\n",
	             Q,D[Q],Xlow[Q],S1,S2,Xhigh[Q],MULTIMODE_FIX3 >= 2 ? 2*MULTIMODE_MP : 3*MULTIMODE_MP);
		  fflush(stdout);
                }
		if(DEBUG && !(Xlow[Q] <= S1+1e-6 && S1 <= S2+1e-6 && S2 <= Xhigh[Q]+1e-6)){
		  printf("Q=%d: Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xnew[Q]= %0.8f, Xhigh[Q]= %0.8f, S1= %0.8f, S2= %0.8f, origval= %0.8f D[Q]=%d:\n",
			 Q,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],S1,S2,origval,D[Q]);
		  for(int t = 0; t < D[Q]; t++)
		    printf("\t delta[Q][%d] + origval = %0.8f\n",t,delta[Q][t] + origval);
		  fflush(stdout);
		  assert(Xlow[Q] <= S1+1e-6 && S1 <= S2+1e-6 && S2 <= Xhigh[Q]+1e-6);
		}

		if(MULTIMODE_FIX3 >= 2){
		  int MMpoints = (!MULTIMODE_FIX5 || MPscan) ? MULTIMODE_MP : 1;
		  if(D[Q] + 2 * MMpoints > Dsiz[Q]){
		    register double *newdel = new double[D[Q] + 2 * MMpoints];
		    for(register int k = Dsiz[Q]; --k >= 0;)
		      newdel[k] = delta[Q][k];
		    Dsiz[Q] = D[Q] + 2 * MMpoints;
		    delete [] delta[Q];
		    delete [] LPdelta[Q];
		    delta[Q] = newdel;
		    LPdelta[Q] = new double[Dsiz[Q]];
		  }

		  double step = S1 - Xlow[Q];
		  if(step > min(DELTA_RES,DELTA_REL*S1)){
		    double val = Xlow[Q];
		    for(int t = 1; t <= MMpoints; t++){
		      if(val <= minKB)
			break;
		      delta[Q][D[Q]++] = val - origval;
		      val -= step;
		    }
		    Xlow[Q] = max(minKB,val);
		  }
		  step = Xhigh[Q] - S2;
		  if(step > min(DELTA_RES, DELTA_REL*S2)){
		    double val = Xhigh[Q];
		    for(int t = 1; t <= MMpoints; t++){
		      delta[Q][D[Q]++] = val - origval;
		      val += step;
		    }
		    Xhigh[Q] = val;
		  }
		} else {
		  if(D[Q] + 3*MULTIMODE_MP > Dsiz[Q]){
		    register double *newdel = new double[D[Q] + 3*MULTIMODE_MP];
		    for(register int k = Dsiz[Q]; --k >= 0;)
		      newdel[k] = delta[Q][k];
		    Dsiz[Q] = D[Q] + 3*MULTIMODE_MP;
		    delete [] delta[Q];
		    delete [] LPdelta[Q];
		    delta[Q] = newdel;
		    LPdelta[Q] = new double[Dsiz[Q]];
		  }
		  double invMP = 1.0/(MULTIMODE_MP+1);
		  if(S1 > Xlow[Q] + min(DELTA_RES,DELTA_REL*S1)*2.0){
		    double inc = (S1 - Xlow[Q]) * invMP;
		    double val = Xlow[Q];
		    for(int t = 1; t <= MULTIMODE_MP; t++){
		      val += inc;
		      delta[Q][D[Q]++] = val - origval;
		    }
		  }
		  if(S2 > S1 + min(DELTA_RES,DELTA_REL*S2)*2.0){
		    double inc = (S2 - S1) * invMP;
		    double val = S1;
		    for(int t = 1; t <= MULTIMODE_MP; t++){
		      val += inc;
		      delta[Q][D[Q]++] = val - origval;
		    }
		  }
		  if(Xhigh[Q] > S2 + min(DELTA_RES,DELTA_REL*Xhigh[Q])*2.0){
		    double inc = (Xhigh[Q] - S2) * invMP;
		    double val = S2;
		    for(int t = 1; t <= MULTIMODE_MP; t++){
		      val += inc;
		      delta[Q][D[Q]++] = val - origval;
		    }
		  }
                }
	      }
	    } else {
	      register double ratio1 = 1.0+MULTIMODE_MP_MAX;
	      register double ratio2 = 1.0-MULTIMODE_MP_MIN;
	      for(register int t = 0; t < MULTIMODE_MP; t++){
		register double val = Xnew[Q] * ratio1;
		ratio1 *= 1.0+MULTIMODE_MP_MAX;
		if(MPscan || (Xlow[Q] < val && val < Xhigh[Q])){
		  if(DEBUG) assert(val >= minKB - 1e-8);
		  delta[Q][D[Q]++] = val - origval;
		}

		val = Xnew[Q] * ratio2;
		if(val > minKB){
		  if(MPscan || (Xlow[Q] < val && val < Xhigh[Q]))
		    delta[Q][D[Q]++] = val - origval;
		  ratio2 *= 1.0-MULTIMODE_MP_MIN;
		}
	      }
	    }
	    if(DEBUG) assert(D[Q] <= Dsiz[Q]);
	    qsort(delta[Q],D[Q],sizeof(double),(intcmp *)doubleInc);
	  }	

	  if(D[Q] <= 0)
	    continue;

	  myDcntT += D[Q];
	  myDcntS += Xhigh[Q] - Xlow[Q];
	  myDcnt++;

	  if(VERB>=2 || SVERB || ERRPLOT)
	    myDcntX += Xmid[Q];

	  if(VERB>=2 || SVERB || ERRPLOT){
	    #pragma omp critical
	    {
	      printf("   After backtrack of Y[Q=%d] to %0.7f:D[Q]=%d,testLPT=%0.8e,mLP=%0.6f,IJ=%d,MPblock=%d,maxt=%d:Dcnt=%d(tot=%d,sum=%0.3f,sumX=%0.3f),totLP=%0.6f,Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f\n",
               	Q,origval,D[Q],testLPT,mLP,initialjump,MPblock,maxt,myDcnt,myDcntT,myDcntS,myDcntX,mytotLPdelta,Xlow[Q],Xmid[Q],Xhigh[Q]);
	      for(register int t = 0; t < D[Q]; t++)
		printf("        t=%d:delta[Q][t]=%0.7f,origval=%0.7f,Xcur=%0.7f,X[t]=%0.7f,minKB=%0.7f,Q=%d\n",
                       t,delta[Q][t],origval,fixYdel[Q+1],delta[Q][t]+origval,minKB,Q);
	      fflush(stdout);
	    }
	  }
	} // for Q = 1 .. N-1

	#pragma omp critical
	{
	  DcntT += myDcntT;
	  DcntS += myDcntS;
	  Dcnt += myDcnt;
	  totLPdelta += mytotLPdelta;
	}
      } // parallel

      /* Update ifirstP,ilastP AND display summary of what we are doing */
      if(bestQ >= 0 && bestLPdelta > qLP + LP_MINDELTA){/* backtracked to single interval change */
	ifirstP = ilastP = bestQ;
	singlechange = (ADAPTIVE ? 2 : 1);// This flags backtrack as a single interval change (otherwise with ADAPTIVE > 0, singlechange==1 flags a full backtrack) 
	if(VERB>=2 || SVERB || ERRPLOT){
	  printf("Backtracking to single interval change:Y[%d]=%0.6f->%0.6f, LP=%0.10f (SC=%d,origSC=%d)\n",
		 bestQ,Xbest[bestQ],bestX,bestLPdelta,singlechange,origSC);
	  fflush(stdout);
	}
	//	if(DEBUG) assert(D[bestQ] > 0);
	if(DEBUG>=2 || MDEBUG){
	  double *fullLPA = new double[MD];
	  ifirst = ilast = -1;
	  for(register int Q=1; Q < N; Q++){
	    if(D[Q] > 0){
	      if(ifirst < 0)
		ifirst = Q;
	      ilast = Q;
	      if(DEBUG && !(Xlow[Q] <= fixYdel[Q+1] + 1e-8 && fixYdel[Q+1] <= Xhigh[Q] + 1e-8)){
		printf("Before mprobeval:Q=%d:Xbest[Q]=%0.10f,Xcur[Q]=%0.10f,Xlow[Q]=%0.10f,Xmid[Q]=%0.10f,Xhigh[Q]=%0.10f\n",Q,Xbest[Q],fixYdel[Q+1],Xlow[Q],Xmid[Q],Xhigh[Q]);
		fflush(stdout);
		assert(Xlow[Q] <= fixYdel[Q+1] + 1e-8 && fixYdel[Q+1] <= Xhigh[Q] + 1e-8);
	      }
	    }
	  }
	  if(DEBUG) assert(0 <= ifirst && ifirst <= ilast && ilast <= N);

	  if(DEBUG) assert(fixYdel[0] == 0.0);
	  register double cum = 0.0;
	  fixY[0] = cum;
	  for(register int I = 1; I <= N+1; I++){
	    cum += fixYdel[I];
	    fixY[I] = cum;
	  }
	  score_init(N,fixY,MD,MX,X);

	  double qLP2 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,fullLPA,mapWT,bestLPA,fixY[min(ifirst,ifirstP)],fixY[max(ilast,ilastP)+1],0,0,pcontig);
	  double qLP3 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,fullLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  if(VERB>=2){
	    printf("     qLP2=%0.10f(err=%0.10f),qLP3=%0.10f(err=%0.10f)\n",qLP2,bestLPdelta-qLP2,qLP3,bestLPdelta-qLP3);
	    fflush(stdout);
	  }
	  if(DEBUG && !(fabs(qLP2 - bestLPdelta) < 1e-6)){
	    printf("WARNING:best single interval change was Q=%d,bestLPdelta=%0.10f,X=%0.3f:qLP2 = %0.10f(qLP=%0.10f)\n",bestQ,bestLPdelta,bestX,qLP2,qLP);
	    for(register int Q = 1; Q < N; Q++)
	      if(D[Q] > 0 || Q==bestQ)
		printf("Y[%d..%d]=%0.6f,D[%d]=%d\n",Q,Q+1,fixYdel[Q],Q,D[Q]);
	    fflush(stdout);
	    //	    assert(fabs(qLP2-bestLPdelta) < MDEBUG_ERR || (qLP2 >= bestLPdelta - 1.0));
	  }
	  if(DEBUG && !(fabs(qLP3-qLP2) < fabs(qLP2)*(USE_MFLOAT ? 1e-5 : 1e-9) + 1e-6 || (qLP3 >= qLP2))){
	    printf("WARNING:best single interval change was Q=%d,bestLPdelta=%0.10f,X=%0.3f:qLP3 = %0.10f(qLP2=%0.10f)\n",bestQ,bestLPdelta,bestX,qLP2,qLP2);
	    for(register int Q = 1; Q < N; Q++)
	      if(D[Q] > 0 || Q==bestQ)
		printf("Y[%d..%d]=%0.6f\n",Q,Q+1,fixYdel[Q]);
	    fflush(stdout);
 	    assert(fabs(qLP3-qLP2) < fabs(qLP2)*(USE_MFLOAT ? 1e-5 : 1e-9) + 1e-6 || (qLP3 >= qLP2));
	  }
	  delete [] fullLPA;
	} // if(DEBUG>=2 || MDEBUG)

      } else {/* backtracked all the way */

	ifirstP = 0;
	ilastP = -1;

	if(VERB>=2 || SVERB || ERRPLOT){
	  if(origSC >= (ADAPTIVE ? 2 : 1))
	    printf("Backtracking to previous best qLP=%0.10f and terminating search (previous single interval backtrack failed):SC=%d,origSC=%d\n",qLP,singlechange,origSC);
	  else if(mLP < qLP - 2e-9){ /* NOTE: This should never happen since Y[] did not change : 
					Y[] is only changed if (bestQ >= 0 && bestLPdelta > qLP).
					If that failed, we would get a single interval backtrack at bestQ with singlechange==(ADAPTIVE ? 2 : 1).
					If that fails, origSC==(ADAPTIVE ? 2 : 1) and bestQ is reset to -1 (the previous case) */
	    printf("WARNING:Backtracking to previous best qLP=%0.10f from mLP=%0.10f (This should not happen)\n",qLP,mLP);
	  } else { /* This case is possible if Y[] was not changed (except due to rounding) and mLP changed by a tiny ammount due to rounding */
	    if(initialjump)
	      printf("Backtracking to (theoretically identical) previous best qLP=%0.10f from mLP=%0.10f and terminating initial jump stage:SC=%d,origSC=%d\n",qLP, mLP,singlechange,origSC);
	    else {
	      printf("Backtracking to (theoretically identical) previous best qLP=%0.10f from mLP=%0.10f:SC=%d,origSC=%d\n",qLP, mLP,singlechange,origSC);
	      /* This case would be handled quicker if we had avoided doing the backtrack and just continued as if mLP == qLP */
	    }
	  }
	  fflush(stdout);
	}

	if(DEBUG>=2 || MDEBUG || origSC >= (ADAPTIVE ? 2 : 1)){
	  double *fullLPA = new double[MD];
	  register double cum = 0.0;
	  if(DEBUG) assert(fixYdel[0] == 0.0);
	  fixY[0] = cum;
	  for(register int I = 1; I <= N+1; I++){
	    cum += fixYdel[I];
	    fixY[I] = cum;
	  }
	  score_init(N,fixY,MD,MX,X);
	  double qLP2 = qprobeval(n,Hcuts,N,fixY,MD,MX,X,lc,rc,map,mapK,limit,nmap,0,TBmapWT,fullLPA,mapWT,0,0.0,0.0,0,0,pcontig);
	  if(VERB>=2){
	    printf("     qLP2=%0.10f(err=%0.10f)\n",qLP2,qLP2-qLP);
	    fflush(stdout);
	  }
	  if(DEBUG && !origSC && !(fabs(qLP2 - qLP) < 1e-8)){
	    printf("WARNING:Full back track failed:qLP=%0.10f:qLP2 = %0.10f\n",qLP,qLP2);
	    fflush(stdout);
	    assert(fabs(qLP2-qLP) < 1e-6);
	  }
	  if(origSC >= (ADAPTIVE ? 2 : 1))
	    qLP = qLP2;
	  delete [] fullLPA;
	}// if(DEBUG>=2 || MDEBUG ...)
      }

      if(origSC >= (ADAPTIVE ? 2 : 1))
	break;/* emergency termination due to failure of single interval change backtrack */

      if(origSC && initialjump) { /* failure of full backtrack : should never happen, unless mLP ~= qLP */
	if(DEBUG && !(fabs(mLP-qLP) < 1e-8)){
	  printf("WARNING: After full backtrack mLP=%0.10f, qLP=%0.10f (err=%0.10f)\n",mLP,qLP,mLP-qLP);
	  fflush(stdout);
	  if(DEBUG>=1+RELEASE) assert(fabs(mLP-qLP) < 1e-5);
	}
	/* need to terminate initialjump in order to make progress with GoldenMean search (updates to Xlow[Q]..Xhigh[Q] don't happen while initialjump!=0) */
	initialjump = 0;
	/* We could now repeat mprobeval as usual after backtracking, but it is quicker to just continue with GoldenMean search,
	   since a 2nd consecutive full backtrack produces no change.*/
      } else {
	bestQ = -1;/* reset single best interval change */
	bestLPdelta = qLP;
	//	iter--;
	ChangeCnt = (singlechange >= (ADAPTIVE ? 2 : 1)) ? 1 : 0;
	continue;/* repeat mprobeval after backtracking */
      }
    }/* backtrack */

    double LPchange = mLP - qLP;

    if(mLP > qLP + LP_MINDELTA || ChangeCnt <= 0) {/* update qLP, Xbest[Q] and bestLPA[m] */
      if(DEBUG>=1+RELEASE && ChangeCnt <= 0) assert(mLP >= qLP - 1e-2);

      qLP = mLP;

      // HERE HERE  #pragma omp parallel for num_threads(nthreads) schedule(static,64)
      for(int Q = 1; Q < N; Q++)
	if(D[Q] >= 0)
	  Xbest[Q] = fixYdel[Q+1];

      memcpy(bestLPA,newLPA, MD*sizeof(bestLPA[0]));

      ifirstP = N+1;
      ilastP = -1;
    }

    if(!singlechange){/* successfully completed initial jump to global maximum */
      initialjump = 0;
      if(LPchange <= MULTIMODE_MP_DELTA){/* from now on MULTIMODE_MP will no longer be used */
	/* transition to gradient based optimization*/
	/* HERE : Not yet implemented : for now just use GoldenMean search, which is slower since it is quasi-Gradient based and ignores 2nd derivative information */
	/* Gradients can be approximated using mprobeval with just LPdelta using small delta values (eg 0.01). Using 2 steps is sufficient for 2nd derivatives. LPdelta
	   can be further optimized since all delta values are the same. For mixed derivatives, it is sufficient to expand mprobeval() to handle small single site movements
	   (which corresponds to changing both neighboring intervals in opposite directions) */
      }
    }

    singlechange = 0;      /* reset singlechange mode */
    bestQ = -1;/* reset single best interval change */
    bestLPdelta = mLP;
    predLPdelta = totLPdelta = 0.0;

    /* precompute peakLP[], peakT[], conflictLP[Q] (if MULTIMODE_FIX4) */
    int LoopCnt = 0;
    #pragma omp parallel num_threads(nthreads) if(!MSAN && nthreads > 1 && !SVERB)
    {
      int myLoopCnt = 0;
      double mytotLPdelta = 0.0;

      #pragma omp for schedule(static,64)
      for(int Q = 1; Q < N; Q ++){
        if(OMP_DEBUG) myLoopCnt++;
	if(D[Q] <= 0)
	  continue;
	double testLPT = -1e300;
	int maxt = -1;
	for(int t = 0; t < D[Q]; t++){
          double testLP = LPdelta[Q][t];
	  if(testLP > testLPT){
            testLPT = testLP;
	    maxt = t;
          }
        }
	if(DEBUG) assert(maxt >= 0);
	peakLP[Q] = testLPT;
	peakT[Q] = maxt;
	if(peakLP[Q] > mLP)
	  mytotLPdelta += peakLP[Q] - mLP;
      }

      if(MULTIMODE_FIX4){

        #pragma omp for schedule(static,64)
        for(int Q = 1; Q < N; Q ++){
          if(OMP_DEBUG) myLoopCnt++;
	  if(D[Q] <= 0)
	    continue;

	  /* compute conflictLP[Q] */
	  conflictLP[Q] = ((DELTA_FIX2 <= 0) ? peakLP[Q] : max(mLP, peakLP[Q])) - 1e-6;
	  conflictQ[Q] = Q;
	  int cnt = 0;/* count of small intervals below rres * 0.500 : these intervals are not counted towards MULTIMODE_MP_CONFLICT */
	  for(int t = 1; t <= MULTIMODE_MP_CONFLICT + cnt && Q-t >= 1; t++){
	    if(D[Q-t] > 0 && peakLP[Q-t] > conflictLP[Q]){
	      conflictLP[Q] = peakLP[Q-t];
	      conflictQ[Q] = Q-t;
	    }
	    if(DEBUG>=2) assert(0 < Q-t && Q-t < N);
	    if(Xmid[Q-t] <= rresKB)
	      cnt++;
	  }

	  cnt = 0;
	  for(int t = 1; t <= MULTIMODE_MP_CONFLICT + cnt && Q+t < N; t++){
	    if(D[Q+t] > 0 && peakLP[Q+t] > conflictLP[Q]){
	      conflictLP[Q] = peakLP[Q+t];
	      conflictQ[Q] = Q+t;
	    }
	    if(DEBUG>=2) assert(0 < Q+t && Q+t < N);
	    if(Xmid[Q+t] <= rresKB)
	      cnt++;
          }
        }
      }

      #pragma omp critical
      {
        if(OMP_DEBUG)
	  LoopCnt += myLoopCnt;
	totLPdelta += mytotLPdelta;
      }
    }
    if(OMP_DEBUG) assert(LoopCnt == (N-1) * (MULTIMODE_FIX4 ? 2 : 1));

    /*  precompute bestLPdelta,bestX,bestQ */
    for(int Q = 1; Q < N; Q ++){
      if(D[Q] > 0 && peakLP[Q] > bestLPdelta){
        bestLPdelta = peakLP[Q];
	bestX = delta[Q][peakT[Q]] + fixYdel[Q+1];
	bestQ = Q;
      }
    }

    /* if bestLPdelta > mLP + MULTIMODE_MP_DELTA2 force singlechange = (ADAPTIVE ? 2 : 1) */
    if(MULTIMODE_MP && MULTIMODE_MP_DELTA2 > 0.0 && bestLPdelta - mLP > MULTIMODE_MP_DELTA2)
      singlechange = (ADAPTIVE ? 2 : 1);

    if(VERB>=2 || SVERB || ERRPLOT){
      if(singlechange >= (ADAPTIVE ? 2 : 1)){
	if(bestQ >= 0 && bestLPdelta > mLP + LP_MINDELTA)
	  printf("  best single interval change:Q=%d,Y[Q]=%0.3f->%0.3f,LP=%0.6f(delta=%0.6f),totLP=%0.6f:making only this change\n",bestQ,Xbest[bestQ],bestX,bestLPdelta,bestLPdelta-mLP,totLPdelta);
	else if(bestQ >= 0){
	  printf("WARNING:best single interval change:Q=%d,Y[Q]=%0.3f->%0.3f,LP=%0.6f(delta=%0.6f),totLP=%0.6f:no changes made! This should be rare!\n",bestQ,Xbest[bestQ],bestX,bestLPdelta,bestLPdelta-mLP,totLPdelta);
	} else
	  printf("WARNING:best single interval change:None found:no changes made! This should be rare\n");
      } else if(bestLPdelta > mLP + LP_MINDELTA){
	printf("  best single interval change:Q=%d,Y[Q]=%0.3f->%0.3f,LP=%0.6f(delta=%0.6f),totLP=%0.6f:changing all intervals\n",bestQ,Xbest[bestQ],bestX,bestLPdelta,bestLPdelta-mLP,totLPdelta);
      } else
	printf("  best single interval change:Q=%d,Y[Q]=%0.3f->%0.3f,LP=%0.6f(delta=%0.6f),totLP=%0.6f:no changes made!\n",bestQ,Xbest[bestQ],bestX,bestLPdelta,bestLPdelta-mLP,totLPdelta);
      fflush(stdout);
    }

    //    if(bestLPdelta <= qLP)
    //      break;

    ChangeCnt = 0;

    LoopCnt = 0;
    #pragma omp parallel num_threads(nthreads) if(nthreads > 1 && !SVERB)
    {
      int myLoopCnt = 0;
      int myifirstP = N+1;
      int myilastP = -1;
      int myChangeCnt = 0;
      double mypredLPdelta = 0.0;

      #pragma omp for schedule(static,64)
      for(int Q = 1; Q < N; Q ++){    /* Update Xlow[Q],Xmid[Q],Xhigh[Q],Xchange[Q],fixYdel[Q+1] */
        if(OMP_DEBUG) myLoopCnt++;
	if(D[Q] <= 0){
	  if(VERB>=2 && D[Q] == 0){
	    printf("Q=%d:Xbest=%0.7f,Xcur=%0.7f:Xlow=%0.7f,Xmid=%0.7f,Xhigh=%0.7f:Lcnt=%d,Rcnt=%d(Completed)\n",
		   Q,Xbest[Q],fixYdel[Q+1],Xlow[Q],Xmid[Q],Xhigh[Q],Lcnt[Q],Rcnt[Q]);
	    fflush(stdout);
	  }
	  continue;
	}

	double origval = fixYdel[Q+1];
	if(DEBUG && !(MULTIMODE_MP || (bool(MULTIMODE_FIX2) && bool(MULTIMODE_FIX3)))) assert(D[Q]==1 && fabs(Xnew[Q] - (origval + delta[Q][0])) <= 2e-9);

	double testLPT = peakLP[Q];
	int maxt = peakT[Q];

	if(DEBUG>=1+RELEASE && !(origSC && origIJ) && !(fabs(Xmid[Q] - origval) <= 2e-9)){// NOTE : this may fail if there was a failure of full backtrack (origSC && origIJ)
	  printf("iter=%d:Q=%d:Xmid[Q]=%0.10f,origval=%0.10f,fixYdel[Q+1]=%0.10f,singlechange=%d,bestQ=%d\n",iter,Q,Xmid[Q],origval,fixYdel[Q+1],singlechange,bestQ);
	  fflush(stdout);
	  assert(fabs(Xmid[Q] - origval) <= 2e-9);
	}

	if(DEBUG>=2) assert(fabs(Xmid[Q] - origval) <= 1e-8);
	maxLP[Q] = mLP;

	if(VERB>=2 || SVERB || ERRPLOT /*||(Q==1 && iter >= 7 && Dcnt <= 165)*/){
          #pragma omp critical
          {
	    if(D[Q] >= 1){
	      printf("Q=%d:Xbest=%0.7f,Xcur=%0.7f:Xlow=%0.7f,Xmid=%0.7f(LP=%0.6f),Xhigh=%0.7f:Xnew=%0.7f,X[%d/%d]=%0.7f(LP=%0.6e,delta=%0.6e),best=%0.6f(delta=%0.6f)\n",
		     Q,Xbest[Q],origval,Xlow[Q],Xmid[Q],maxLP[Q],Xhigh[Q],Xnew[Q],maxt,D[Q],delta[Q][maxt]+origval, testLPT, testLPT - mLP, max(maxLP[Q],testLPT), max(maxLP[Q],testLPT)-mLP);
	      if(MULTIMODE_FIX4)
		printf("\t\t Lcnt=%d,Rcnt=%d,IJ=%d,SC=%d : maxLP[Q]=%0.6f,peakLP[Q]-mLP=%0.6f,conflictLP[Q]-mLP=%0.6f(q=%d),mLP=%0.6f\n",
		       Lcnt[Q],Rcnt[Q],initialjump,singlechange,maxLP[Q],peakLP[Q]-mLP,conflictLP[Q]-mLP,conflictQ[Q],mLP);
	      else
		printf("\t\t Lcnt=%d,Rcnt=%d,IJ=%d,SC=%d : maxLP[Q]=%0.6f,peakLP[Q]-mLP=%0.6f,mLP=%0.6f\n",Lcnt[Q],Rcnt[Q],initialjump,singlechange,maxLP[Q],peakLP[Q]-mLP,mLP);
	      if(D[Q] > 1)
	        for(register int t = 0; t < D[Q]; t++)
		  printf("         X[%d]=%0.8f(LP=%0.6f,delta=%0.6f),Q=%d\n",t,delta[Q][t]+origval, LPdelta[Q][t], LPdelta[Q][t] - mLP,Q);
	    } else
	      printf("Q=%d:Xbest=%0.7f,Xcur=%0.7f:Xlow=%0.6f,Xmid=%0.7f(LP=%0.6f),Xhigh=%0.7f:Lcnt=%d,Rcnt=%d,IJ=%d,SC=%d\n",
		   Q,Xbest[Q],origval,Xlow[Q],Xmid[Q],maxLP[Q],Xhigh[Q],Lcnt[Q],Rcnt[Q],initialjump,singlechange);
	    fflush(stdout);
          }
	}

	if(DEBUG && !(origval == Xmid[Q])){
	  printf("iter=%d:Q=%d:origval=%0.10f,Xmid[Q]=%0.10f,fixYdel[Q+1]=%0.10f\n",iter,Q,origval,Xmid[Q],fixYdel[Q+1]);
	  fflush(stdout);
	  assert(origval == Xmid[Q]);
	}
	if(DEBUG && !(Xlow[Q] <= origval + 1e-8 && origval <= Xhigh[Q] + 1e-8)){
	  printf("After mprobeval:Q=%d:Xbest[Q]=%0.10f,Xcur[Q]=%0.10f,Xlow[Q]=%0.10f,Xmid[Q]=%0.10f,Xhigh[Q]=%0.10f\n",Q,Xbest[Q],origval,Xlow[Q],Xmid[Q],Xhigh[Q]);
	  fflush(stdout);
	  assert(Xlow[Q] <= origval + 1e-8 && origval <= Xhigh[Q] + 1e-8);
	}

	/* If MULTIMODE_FIX4 >= 1 : The following loop is applied only if interval Q can be changed */
	if(!MULTIMODE_FIX4 || (singlechange < (ADAPTIVE ? 2 : 1) ? 
			       conflictLP[Q] <= max(peakLP[Q], mLP + DELTA1) : 
			       Q==bestQ)){
          /* loop over key new test points (best point and its neighbors) + nearest points on either side of Xmid[Q], to update range Xlow[Q],Xmid[Q],Xhigh[Q] AND maxLP[Q] */
	  int tmin = max(0,maxt-1);
	  int tmax = min(D[Q]-1, maxt + 1);

	  if(testLPT <= maxLP[Q] + LP_MINDELTA*1.001){/* instead loop over nearest neighbors of Xmid[Q], the current best point */
	    for(tmin = D[Q] - 1; tmin > 0; tmin--)
	      if(delta[Q][tmin] + origval + 1e-6 < Xmid[Q])
		break;
	    for(tmax = 0; tmax+1 < D[Q]; tmax++)
	      if(delta[Q][tmax] + origval > Xmid[Q] + 1e-6)
		break;
	    if(MULTIMODE_FIX2 && DEBUG>=2) assert(abs(tmax-tmin) <= 1);
	  }

          for(int t = tmin; t <= tmax; t++){
            double testLP = LPdelta[Q][t];
	    Xnew[Q] = delta[Q][t] + origval;

	    if(DELTA_FIX && fabs(Xnew[Q] - origval) <= 1e-8){
              if(DEBUG>=3 && DELTA_FIX3 && fabs(Xnew[Q] - origval) <= 0.9e-8){
                #pragma omp critical
                {
                  printf("Q=%d:t=%d/%d:Xtest[t]= %0.8f, origval= %0.8f\n",Q,t,D[Q],Xnew[Q],origval);
		  fflush(stdout);
                  assert(fabs(Xnew[Q] - origval) <= 0.9e-8);
                }
              }
	      continue;
            }

	    /* update the range Xlow[Q] ... Xmid[Q] .. Xhigh[Q] based on testLP at Xnew[Q] */
	    if(DEBUG>=2 && MULTIMODE_FIX2 && !(Xlow[Q] < Xnew[Q] || Xlow[Q] <= minKB + 1e-8)){
	      #pragma omp critical
	      {
		printf("Q=%d:t=%d/%d:Xtest=%0.8f, Xlow[Q]= %0.8f, LPdelta[Q][t]= %0.6f (del= %0.6f)\n",Q,t,D[Q],Xnew[Q],Xlow[Q],LPdelta[Q][t], LPdelta[Q][t]-mLP);
		for(int T = 0; T < D[Q]; T++)
		  printf("\t T=%d: Xtest[T]= %0.8f, LPdelta[Q][T]= %0.6f (del= %0.6f)\n",T,delta[Q][T]+origval,LPdelta[Q][T],LPdelta[Q][T]-mLP);
		fflush(stdout);
		assert(Xlow[Q] < Xnew[Q] || Xlow[Q] <= minKB + 1e-8);
	      }
	    }

	    if(!MULTIMODE_FIX2 && Xnew[Q] <= Xlow[Q]){
	      if(testLP > maxLP[Q] + LP_MINDELTA){
		maxLP[Q] = testLP;
		Xhigh[Q] = Xmid[Q];
		Xlow[Q] = Xmid[Q] = Xnew[Q];
		if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
	      } else if(Xlow[Q] >= Xmid[Q] - 2e-6)
		Xlow[Q] = Xnew[Q];
	    } else if(Xnew[Q] >= Xhigh[Q]){// NOTE : Even with MULTIMODE_FIX2 Xnew[Q] may be >= Xhigh[Q] since previous points Xnew[Q] may have lowered Xhigh[Q]
	      if(DEBUG>=2 && MULTIMODE_FIX2) assert(Xmid[Q] < Xhigh[Q] && t > 0);
	      if(testLP > maxLP[Q] + LP_MINDELTA){
		maxLP[Q] = testLP;
		Xlow[Q] = Xmid[Q];
		if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
		Xmid[Q] = Xnew[Q];
		if(MULTIMODE_FIX2){
		  if(t + 1 < D[Q])
		    Xhigh[Q] = delta[Q][t+1] + origval;
		  else
		    Xhigh[Q] = Xmid[Q]*2.0 - (delta[Q][t-1] + origval);
		} else
		  Xhigh[Q] = Xmid[Q];
	      } else if(!MULTIMODE_FIX2 && Xhigh[Q] <= Xmid[Q] + 2e-6)
		Xhigh[Q] = Xnew[Q];
	    } else if(Xnew[Q] > Xmid[Q]){/* Xlow[Q] <= Xmid[Q] < Xnew[Q] < Xhigh[Q] */
	      if(VERB>=3 && SVERB){
		printf("(1):Q=%d:t=%d:Xnew[Q]=%0.6f,testLP=%0.8f,maxLP[Q]=%0.8f:Xmid[Q]=%0.6f\n",
		       Q,t,Xnew[Q],testLP,maxLP[Q],Xmid[Q]);
		fflush(stdout);
	      }
	      if(testLP > maxLP[Q] + LP_MINDELTA){
		if(ADAPTIVE && D[Q]==1 && !(Xlow[Q] >= Xmid[Q] - 1e-6)){
                  if(Lcnt[Q] >= 2 && (ADAPTIVE >=2 || Xhigh[Q]-Xlow[Q] > min(DELTA_RES,DELTA_REL*Xmid[Q])))/* 3rd consecutive increase of low end : expand range at high end to accomodate shift in global maximum */
		    Xhigh[Q] += (Lcnt[Q]==2 ? 0.5 : Lcnt[Q]==3 ? 1.0 : 2.0) * (Xhigh[Q]-Xlow[Q]);
		  Lcnt[Q]++;
		  Rcnt[Q] = 0;
		}
		maxLP[Q] = testLP;
		Xlow[Q] = Xmid[Q];
		if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
		Xmid[Q] = Xnew[Q];
		if(DEBUG>=2) assert(Xnew[Q] <= Xhigh[Q]);
		if(DEBUG>=2 && MULTIMODE_FIX2) assert(Xnew[Q] < Xhigh[Q]);
		//	      Xhigh[Q] = max(Xnew[Q],Xhigh[Q]);
	      } else {
		if(ADAPTIVE && D[Q]==1){
		  if(DEBUG>=2) assert(Xnew[Q] < Xhigh[Q]);
		  if(Rcnt[Q] >= 2 && (ADAPTIVE >=2 || Xhigh[Q]-Xlow[Q] > min(DELTA_RES,DELTA_REL*Xmid[Q]))){/* 3rd consecutive decrease of high end: expand range at low end to accomodate shift in global maximum */
		    Xlow[Q] -= (Rcnt[Q]==2 ? 0.5 : Rcnt[Q]==3 ? 1.0 : 2.0) * (Xhigh[Q]-Xlow[Q]);
		    Xlow[Q] = max(minKB,Xlow[Q]);
		  }
		  Rcnt[Q]++;
		  Lcnt[Q] = 0;
		}
		Xhigh[Q] = min(Xhigh[Q],Xnew[Q]);
	      }
	      if(DEBUG>=2) assert(Xlow[Q] <= Xmid[Q] + 1e-8 && Xmid[Q] <= Xhigh[Q] + 1e-8);
	      if(DEBUG>=2 && MULTIMODE_FIX2) assert((Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-6) && Xmid[Q] < Xhigh[Q]);
	    } else /* if(Xnew[Q] < Xmid[Q]) */ {/* Xlow[Q] <? Xnew[Q] < Xmid[Q] < Xhigh[Q] */
	      if(VERB>=3 && SVERB){
		printf("(2):Q=%d:t=%d:Xnew[Q]=%0.6f,testLP=%0.8f,maxLP[Q]=%0.8f:Xmid[Q]=%0.6f\n",
		       Q,t,Xnew[Q],testLP,maxLP[Q],Xmid[Q]);
		fflush(stdout);
	      }
	      if(DELTA_FIX && DEBUG>=2 && !(Xnew[Q] < Xmid[Q])){
		#pragma omp critical
		{
		  printf("Q=%d:t=%d/%d:Xtest[t]=%0.8f,Xlow[Q]=%0.8f,Xmid[Q]=%0.8f,Xhigh[Q]=%0.8f,origval=%0.8f (2 identical test points?)\n",Q,t,D[Q],Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],origval);
		  for(int T = 0; T < D[Q]; T++)
		    printf("\t T=%d:Xtest[T]=%0.8f, LPdelta[Q][T]= %0.6f (del= %0.6f)\n",T,delta[Q][T] + origval, LPdelta[Q][T], LPdelta[Q][T] - mLP);
		  fflush(stdout);
	          assert(Xnew[Q] < Xmid[Q]);
		}
	      }

	      if(testLP > maxLP[Q] + LP_MINDELTA){
		if(ADAPTIVE && D[Q]==1 && !(Xhigh[Q] <= Xmid[Q] + 1e-6)){
                 if(Rcnt[Q] >= 2 && (ADAPTIVE >=2 || Xhigh[Q]-Xlow[Q] > min(DELTA_RES,DELTA_REL*Xmid[Q]))){/* 3rd consecutive decrease of high end: expand range at low end to accomodate shift in global maximum */
		    Xlow[Q] -= (Rcnt[Q]==2 ? 0.5 : Rcnt[Q]==3 ? 1.0 : 2.0) * (Xhigh[Q]-Xlow[Q]);
		    Xlow[Q] = max(minKB,Xlow[Q]);
		  }
		  Rcnt[Q]++;
		  Lcnt[Q] = 0;
		}
		maxLP[Q] = testLP;
		Xhigh[Q] = Xmid[Q];
		Xmid[Q] = Xnew[Q];
		if(DEBUG>=2 && !(Xlow[Q] <= Xnew[Q] + 1e-8)){
		  #pragma omp critical
		  {
		    printf("Q=%d:t=%d/%d:Xtest[t]=%0.8f,Xlow[Q]=%0.8f,Xmid[Q]=%0.8f,Xhigh[Q]=%0.8f,origval=%0.8f\n",Q,t,D[Q],Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],origval);
		    for(int T = 0; T < D[Q]; T++)
		      printf("\t T=%d:Xtest[T]=%0.8f, LPdelta[Q][T]= %0.6f (del= %0.6f)\n",T,delta[Q][T] + origval, LPdelta[Q][T], LPdelta[Q][T] - mLP);
		    fflush(stdout);
		    assert(Xlow[Q] <= Xnew[Q] + 1e-8);
		  }
		}
		// Xlow[Q] = min(Xlow[Q],Xnew[Q]);
	      } else {
		if(ADAPTIVE && D[Q]==1){
		  if(DEBUG>=2) assert(Xnew[Q] > Xlow[Q]);
		  if(Lcnt[Q] >= 2 && (ADAPTIVE >=2 || Xhigh[Q]-Xlow[Q] > min(DELTA_RES,DELTA_REL*Xmid[Q])))/* 3rd consecutive increase of low end : expand range at high end to accomodate shift in global maximum */
		    Xhigh[Q] += (Lcnt[Q]==2 ? 0.5 : Lcnt[Q]==3 ? 1.0 : 2.0) * (Xhigh[Q]-Xlow[Q]);
		  Lcnt[Q]++;
		  Rcnt[Q] = 0;
		}
		if(VERB/* HERE >=3 */ && SVERB){
		  printf("Q=%d:t=%d:Xnew[Q]=%0.6f,testLP=%0.8f,maxLP[Q]=%0.8f:Xmid[Q]=%0.6f,Xlow[Q]=%0.6f -> %0.6f\n",
			 Q,t,Xnew[Q],testLP,maxLP[Q],Xmid[Q],Xlow[Q],max(Xlow[Q],Xnew[Q]));
		  fflush(stdout);
		}
		Xlow[Q] = max(Xlow[Q],Xnew[Q]);
	      }
	      if(DEBUG>=2) assert(Xlow[Q] <= Xmid[Q] + 1e-8 && Xmid[Q] <= Xhigh[Q] + 1e-8);
	      if(DEBUG>=2 && MULTIMODE_FIX2) assert(Xlow[Q] <= Xmid[Q] + 1e-8 && Xmid[Q] < Xhigh[Q]);
	    } /* Xnew[Q] < Xmid[Q] */

	    if(VERB/* HERE >=2 */ && SVERB){
	      printf("\t Q=%d:t=%d/%d:Xnew[Q]=%0.7f,testLP=%0.6f:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,maxLP[Q]=%0.6f(singlechange=%d)\n",
		     Q,t,D[Q],Xnew[Q],testLP,Xlow[Q],Xmid[Q],Xhigh[Q],maxLP[Q],singlechange);
	      fflush(stdout);
	    }
	  }/* t = maxt-1 .. maxt+1 */

	  if(DEBUG>=2) assert(Xlow[Q] <= Xmid[Q] + 1e-8 && Xmid[Q] <= Xhigh[Q] + 1e-8);
	  if(DEBUG>=2 && MULTIMODE_FIX2) assert(Xlow[Q] <= Xmid[Q] + 1e-8 && Xmid[Q] < Xhigh[Q]);
	  if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);

	  Xnew[Q] = delta[Q][maxt] + origval;/* default Xnew[Q] if fixYdel[Q+1] is not updatable : NOT used if fixYdel[Q+1] can be updated (even if it is NOT updated) */
        } else { /* MULTIMODE_FIX4 && !((singlechange < (ADAPTIVE ? 2 : 1) ? conflictLP[Q] <= max(peakLP[Q], mLP + DELTA1) : Q==bestQ)) */
          if(DEBUG) assert(MULTIMODE_FIX4);
	  Xnew[Q] = delta[Q][maxt] + origval;/* default Xnew[Q] if fixYdel[Q+1] is not updatable : NOT used if fixYdel[Q+1] can be updated (even if it is NOT updated) */

	  if(MULTIMODE_FIX4==1){
	    if(testLPT < maxLP[Q] + LP_MINDELTA){/* narrow range Xlow[Q]..Xhigh[Q] to nearest neighbors (if any) of Xmid[Q] AND set Xnew[Q] to Xmid[Q] */
	      int tmin,tmax;
	      for(tmin = D[Q] - 1; tmin >= 0; tmin--)
		if(delta[Q][tmin] + origval + 1e-8 < Xmid[Q]){
		  Xlow[Q] = delta[Q][tmin] + origval;
		  break;
  	        }
	      
	      for(tmax = 0; tmax < D[Q]; tmax++)
		if(delta[Q][tmax] + origval > Xmid[Q] + 1e-8){
		  Xhigh[Q] = delta[Q][tmax] + origval;
		  break;
		}

	      Xnew[Q] = Xmid[Q];
	      if(VERB>=2 || SVERB){
		printf("\t Q=%d:Xnew[Q] -> %0.7f,Xlow[Q]=%0.7f,Xmid[Q]=%0.7f->%0.7f,Xhigh[Q]=%0.7f,minKB=%0.7f:tmin=%d,tmax=%d\n",
		       Q,Xnew[Q],Xlow[Q],Xmid[Q],origval,Xhigh[Q],minKB,tmin,tmax);
		fflush(stdout);
	      }
	      if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-8 && (Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-8) &&  Xmid[Q] < Xhigh[Q]);

	    } else {/* narrow range Xlow[Q]..Xhigh[Q] to nearest neighbors outside of range min(Xnew[Q],Xmid[Q]) .. max(Xnew[Q],Xmid[Q]) */
	      int tmin,tmax;
	      for(tmin = D[Q] - 1; tmin >= 0; tmin--)
		if(delta[Q][tmin] + origval + 1e-8 < min(Xmid[Q],Xnew[Q])){
		  Xlow[Q] = delta[Q][tmin] + origval;
		  break;
	      }
	      
	      for(tmax = 0; tmax < D[Q]; tmax++)
		if(delta[Q][tmax] + origval > max(Xmid[Q],Xnew[Q]) + 1e-8){
		  Xhigh[Q] = delta[Q][tmax] + origval;
		  break;
		}

	      if(VERB>=2 || SVERB){
		printf("\t Q=%d:Xnew[Q]= %0.7f,Xlow[Q]=%0.7f,Xmid[Q]=%0.7f->%0.7f,Xhigh[Q]=%0.7f,minKB=%0.7f:tmin=%d,tmax=%d\n",
		       Q,Xnew[Q],Xlow[Q],Xmid[Q],origval,Xhigh[Q],minKB,tmin,tmax);
		fflush(stdout);
	      }
	      if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-8 && (Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-8) &&  Xmid[Q] < Xhigh[Q]);
	      if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-8 && (Xlow[Q] < Xnew[Q] || Xlow[Q] <= minKB + 1e-8) &&  Xnew[Q] < Xhigh[Q]);
	    }
	  }
        }

	if(VERB/* HERE >=2 */ && SVERB){
	  printf("\t Q=%d:default Xnew[Q] = %0.6f,maxt=%d,delta[Q][maxt]= %0.6f, origval= %0.6f\n", 
		 Q, Xnew[Q], maxt, delta[Q][maxt], origval);
	  fflush(stdout);
	}
      }

      #pragma omp for schedule(static,64)
      for(int Q = 1; Q < N; Q ++){
        if(OMP_DEBUG)myLoopCnt++;

	Xchange[Q] = 0.0;/* needed even for D[Q] <= 0 since it is checked for Q-1 and Q+1 */

	if(D[Q] <= 0)
	  continue;

	double origval = fixYdel[Q+1];

	if(DELTA_FIX3)/* add origval to delta[Q][t=0..D[Q]-1] */
	  for(int t = D[Q]; --t >= 0;)
	    delta[Q][t] += origval;

	if(!MULTIMODE_FIX4){
	  conflictLP[Q] = max(mLP, maxLP[Q]) - 1e-6;
	  conflictQ[Q] = Q;
	  if(MULTIMODE_MP_DELTA2 > MULTIMODE_MP_DELTA1){/* compute conflictLP[Q] */
	    int cnt = 0;/* count of small intervals below rres * 0.500 : these intervals are not counted towards MULTIMODE_MP_CONFLICT */
	    for(int t = 1; t <= MULTIMODE_MP_CONFLICT + cnt && Q-t >= 1; t++){
	      if(D[Q-t] > 0 && maxLP[Q-t] > conflictLP[Q]){
		conflictLP[Q] = maxLP[Q-t];
		conflictQ[Q] = Q-t;
	      }
	      if(Xmid[Q-t] <= rresKB)
		cnt++;
	    }

	    cnt = 0;
	    for(int t = 1; t <= MULTIMODE_MP_CONFLICT + cnt && Q+t < N; t++){
	      if(D[Q+t] > 0 && maxLP[Q+t] > conflictLP[Q]){
		conflictLP[Q] = maxLP[Q+t];
		conflictQ[Q] = Q+t;
	      }
	      if(Xmid[Q+t] <= rresKB)
		cnt++;
	    }
	  }
	}

	if(singlechange < (ADAPTIVE ? 2 : 1) ? 
	   /* change all intervals except for conflicts */ (conflictLP[Q] <= (MULTIMODE_FIX4 ? max(peakLP[Q], mLP+DELTA1) : max(maxLP[Q], qLP+DELTA1))) : 
	   /* change only best interval bestQ */ Q==bestQ){/* interval Q can be updated */
	  Xchange[Q] = fabs(Xmid[Q] - origval);

	  if(Xchange[Q] > 0.0){
	    myChangeCnt++;

	    if(DEBUG>=2) assert(peakLP[Q] > mLP);
	    mypredLPdelta += peakLP[Q] - mLP;
	  }

	  if(VERB>=2 || SVERB || ERRPLOT){
	    if(Xchange[Q] > 1e-6 * origval)
	      printf("\t Q=%d: Changing Y[Q] from %0.7f to %0.7f (Xchange[Q]=%0.7f):peakLP[Q]-mLP= %0.6f, predLPdelta= %0.6f\n",Q,origval,Xmid[Q],Xchange[Q],peakLP[Q]-mLP,mypredLPdelta);
	    else
	      printf("\t Q=%d: Unchanged Y[Q] = %0.7f (Xchange[Q]=%0.7f):peakLP[Q]-mLP= %0.6f, predLPdelta= %0.6f\n",Q,origval,Xchange[Q],peakLP[Q]-mLP,mypredLPdelta);
	    fflush(stdout);
	  }

	  fixYdel[Q+1] = origval = Xmid[Q];

	  myifirstP = min(Q,myifirstP);
	  myilastP = max(Q,myilastP);

	  if(VERB>=2 || SVERB || ERRPLOT){
	    printf("\t Q=%d: Selecting new test point Xnew[Q]:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.7f,resphi=%0.7f,minKB=%0.7f,origval=%0.7f,D[Q]=%d\n",
		   Q,Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval,D[Q]);
	    fflush(stdout);
	  }

	  /* select new test point Xnew[Q] (could be outside of range Xlow[Q] .. Xhigh[Q] if !MULTIMODE_FIX2) */
	  if(DEBUG>=2 && MULTIMODE_FIX2) assert((Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-6) && Xmid[Q] < Xhigh[Q]);

	  if(!MULTIMODE_FIX2 && Xlow[Q] >= Xmid[Q] - 1e-6 && Xlow[Q] >= minKB + 1e-6){
	    Xnew[Q] = max(minKB,Xmid[Q] - phi*max(1.0,Xhigh[Q] - Xmid[Q]));
	    if(Xnew[Q] < Xlow[Q] * 0.7)
	      Xnew[Q] = Xlow[Q] * 0.7;
	    if(bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
	      Xlow[Q] = min(Xnew[Q],Xlow[Q]);

	    if(DEBUG>=2 && !(Xnew[Q] >= minKB - 1e-8)){
	      #pragma omp critical
	      {
		printf("\t Q=%d: Selecting new test point Xnew[Q]=%0.7f:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.7f,resphi=%0.7f,minKB=%0.7f,origval=%0.7f\n",
		       Q,Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval);
		fflush(stdout);
		assert(Xnew[Q] >= minKB - 1e-8);
	      }
	    }
	  } else if(!MULTIMODE_FIX2 && Xhigh[Q] <= Xmid[Q] + 1e-6 && Xhigh[Q] <= max(1.0,origval)*4.0){
	    Xnew[Q] = Xmid[Q] + phi * max(1.0,Xmid[Q] - Xlow[Q]);
	    if(Xnew[Q] > Xhigh[Q] * 1.2)
	      Xnew[Q] = Xhigh[Q] * 1.2;
	    if(bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
	      Xhigh[Q] = max(Xnew[Q],Xhigh[Q]);

	    if(DEBUG>=2 && !(Xnew[Q] >= minKB - 1e-8)){
	      #pragma omp critical
	      {
		printf("\t Q=%d: Selecting new test point Xnew[Q]=%0.7f:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.7f,resphi=%0.7f,minKB=%0.7f,origval=%0.7f\n",
		       Q,Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval);
		fflush(stdout);
		assert(Xnew[Q] >= minKB - 1e-8);
	      }
	    }
	  } else {
            if(max(Xhigh[Q]-Xmid[Q],Xmid[Q]-Xlow[Q]) <= min(DELTA_RES,DELTA_REL*Xmid[Q])){/* Fibonacci search completed for interval Q */
	      D[Q] = 0;
	      if(VERB>=2 || SVERB || ERRPLOT){
		printf("\t Q=%d: Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.7f,resphi=%0.7f,minKB=%0.7f,origval=%0.7f,D[Q]=%d(Completed)\n",
		       Q,Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval,D[Q]);
		fflush(stdout);
	      }
	      continue;
	    }

	    if(Xhigh[Q] - Xmid[Q] > Xmid[Q] - Xlow[Q])
	      Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q]-Xmid[Q]);
	    else
	      Xnew[Q] = Xmid[Q] - resphi*(Xmid[Q]-Xlow[Q]);

	    if(DEBUG>=2 && !(Xnew[Q] >= minKB - 1e-8)){
	      #pragma omp critical
	      {
		printf("\t Q=%d: Selecting new test point Xnew[Q]=%0.7f:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.6f,resphi=%0.6f,minKB=%0.7f,origval=%0.7f\n",
		       Q,Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval);
		fflush(stdout);
		assert(Xnew[Q] >= minKB - 1e-8);
	      }
	    }
	    if(DEBUG>=3 && MULTIMODE_FIX2 && DELTA_FIX3 && !(fabs(Xnew[Q] - origval) >= 0.9e-8)){
	      #pragma omp critical
	      {
		printf("\t Q=%d: Selected Xnew[Q]= %0.9f: Xlow[Q]=%0.9f,Xmid[Q]=%0.9f,Xhigh[Q]=%0.9f,origval=%0.9f\n",Q, Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],origval);
		fflush(stdout);
		assert(fabs(Xnew[Q] - origval) > 0.9e-8);
	      }
	    }
	  }
	  
	  if(VERB>=2 || SVERB || ERRPLOT){
            printf("\t Q=%d: Selected Xnew[Q]= %0.7f: Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,origval=%0.7f\n",Q, Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],origval);
	    fflush(stdout);
	  }

	  if(MULTIMODE_FIX2){
	    if(DEBUG>=2 && DELTA_FIX3 && !(fabs(Xnew[Q] - origval) >= 0.9e-8)){
	      #pragma omp critical
	      {
		printf("\t Q=%d: Selected Xnew[Q]= %0.9f: Xlow[Q]=%0.9f,Xmid[Q]=%0.9f,Xhigh[Q]=%0.9f,origval=%0.9f\n",Q, Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],origval);
		fflush(stdout);
		assert(fabs(Xnew[Q] - origval) > 0.9e-8);
	      }
	    }
	    if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-6 && (Xlow[Q] < min(Xmid[Q],Xnew[Q]) || Xlow[Q] <= minKB + 1e-6) && max(Xmid[Q],Xnew[Q]) < Xhigh[Q]);

	    delta[Q][0] = Xnew[Q] - origval;
	    D[Q] = 1;
	  }

	} else {/* do not change any intervals : keep fixYdel[Q+1] for interval Q, reset Xmid[Q] and leave Xnew[Q] at best known value (if MULTIMODE_FIX4), or set to Goldenmean prediction */

	  if(VERB>=2 || SVERB || ERRPLOT){
	    printf("\t Q=%d: Unchanged Y[Q]= %0.7f:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,Xnew[Q]=%0.7f (due to maxLP[Q]= %0.6f, peakLP[Q]-mLP= %0.6f, conflictLP[Q]-mLP= %0.6f(q=%d), mLP= %0.6f, Xchange[Q]=%0.7f)\n",
		   Q,origval,Xlow[Q],Xmid[Q],Xhigh[Q],Xnew[Q],maxLP[Q],peakLP[Q]-mLP,conflictLP[Q]-mLP,conflictQ[Q],mLP,Xchange[Q]);
	    fflush(stdout);
	  }
	  
	  /* reset Xmid[Q] */
	  Xmid[Q] = origval;
	  maxLP[Q] = mLP;
	  double range = Xhigh[Q] - Xlow[Q];

	  if(origval < Xlow[Q]){
	    Xlow[Q] = origval;
	    if(DEBUG>=2) assert(Xlow[Q] >= minKB - 1e-8);
          }
	  if(MULTIMODE_FIX2 && !(Xlow[Q] < origval))
            Xlow[Q] = max(minKB, origval - range * resphi);

	  if(origval > Xhigh[Q])
	    Xhigh[Q] = origval;
	  if(MULTIMODE_FIX2 && !(origval < Xhigh[Q]))
            Xhigh[Q] = origval  + range * resphi;

	  if(VERB>=2 || SVERB || ERRPLOT){
	    printf("\t Q=%d:maxLP[Q]=%0.6f,peakLP[Q]=%0.6f,conflictLP[Q]=%0.6f(+mLP,q=%d),DELTA1=%0.3f:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,Xnew[Q]=%0.7f,minKB=%0.7f\n",
		  Q,maxLP[Q]-mLP,peakLP[Q]-mLP,conflictLP[Q]-mLP,conflictQ[Q],DELTA1,Xlow[Q],Xmid[Q],Xhigh[Q],Xnew[Q],minKB);
	    fflush(stdout);
	  }

	  if(max(Xhigh[Q]-Xmid[Q],Xmid[Q]-Xlow[Q]) <= min(DELTA_RES,DELTA_REL*Xmid[Q])){/* Fibonacci search completed for interval Q */
	    D[Q] = 0;
	    if(VERB>=2 || SVERB || ERRPLOT){
	      printf("\t Q=%d: Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.7f,resphi=%0.7f,minKB=%0.7f,origval=%0.7f,D[Q]=%d(Completed)\n",
		     Q,Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval,D[Q]);
	      fflush(stdout);
	    }
	    continue;
	  }

	  if(DEBUG>=2 && MULTIMODE_FIX4==1) assert(Xlow[Q] <= Xnew[Q] + 1e-8 && Xnew[Q] < Xhigh[Q]);

	  if(MULTIMODE_FIX4 <= 1 && (bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3)) && !(/* Xlow[Q] <= Xnew[Q] + 1e-8 && Xnew[Q] < Xhigh[Q] && */ fabs(Xnew[Q]-Xmid[Q]) > 1e-8)){
	    /* select new test point Xnew[Q] (might be outside of range Xlow[Q] .. Xhigh[Q] if !MULTIMODE_FIX2) */

	    if(VERB>=2 || SVERB || ERRPLOT){
	      printf("\t Q=%d: Selecting new test point Xnew[Q]:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.6f,resphi=%0.6f,minKB=%0.7f,origval=%0.7f\n",
		     Q,Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval);
	      fflush(stdout);
	    }

	    if(DEBUG>=2 && MULTIMODE_FIX2 && !((Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-6) && Xmid[Q] < Xhigh[Q])){
	      printf("Q=%d:Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xhigh[Q]= %0.8f, minKB= %0.8f\n",Q,Xlow[Q],Xmid[Q],Xhigh[Q],minKB);
	      fflush(stdout);
	      assert((Xlow[Q] < Xmid[Q] || Xlow[Q] <= minKB + 1e-6) && Xmid[Q] < Xhigh[Q]);
	    }

	    if(!MULTIMODE_FIX2 && Xlow[Q] >= Xmid[Q] - 1e-8 && Xlow[Q] >= minKB + 1e-6){
	      Xnew[Q] = max(minKB,Xmid[Q] - phi*max(1.0,Xhigh[Q] - Xmid[Q]));
	      if(Xnew[Q] < Xlow[Q] * 0.7)
		Xnew[Q] = Xlow[Q] * 0.7;

	      if(DEBUG>=2 && !(Xnew[Q] >= minKB - 1e-8)){
                #pragma omp critical
		{
		  printf("\t Q=%d: Selecting new test point Xnew[Q]=%0.7f:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.6f,resphi=%0.6f,minKB=%0.7f,origval=%0.7f\n",
		    Q,Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval);
		  fflush(stdout);
		  assert(Xnew[Q] >= minKB - 1e-8);
	        }
	      }
	    } else if(!MULTIMODE_FIX2 && Xhigh[Q] <= Xmid[Q] + 1e-8 && Xhigh[Q] <= max(1.0,origval)*4.0){
	      Xnew[Q] = Xmid[Q] + phi * max(1.0,Xmid[Q] - Xlow[Q]);
	      if(Xnew[Q] > Xhigh[Q] * 1.2)
		Xnew[Q] = Xhigh[Q] * 1.2;

	      if(DEBUG>=2 && !(Xnew[Q] >= minKB - 1e-8)){
                #pragma omp critical
		{
		  printf("\t Q=%d: Selecting new test point Xnew[Q]=%0.7f:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.6f,resphi=%0.6f,minKB=%0.7f,origval=%0.7f\n",
			 Q,Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval);
		  fflush(stdout);
		  assert(Xnew[Q] >= minKB - 1e-8);
		}
	      }
	    } else {
	      if(Xhigh[Q] - Xmid[Q] > Xmid[Q] - Xlow[Q])
		Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q]-Xmid[Q]);
	      else
		Xnew[Q] = Xmid[Q] - resphi*(Xmid[Q]-Xlow[Q]);

	      if(DEBUG>=2 && !(Xnew[Q] >= minKB - 1e-8)){
                #pragma omp critical
		{
		  printf("\t Q=%d: Selecting new test point Xnew[Q]=%0.7f:Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,phi=%0.6f,resphi=%0.6f,minKB=%0.7f,origval=%0.7f\n",
		    Q,Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],phi,resphi,minKB,origval);
		  fflush(stdout);
		  assert(Xnew[Q] >= minKB - 1e-8);
	        }
	      }
	    }
          } // if(MULTIMODE_FIX4 <= 1 && (MULTIMODE_FIX2 || MULTIMODE_FIX3) && ... )

	  if(VERB>=2 || SVERB || ERRPLOT){
            printf("\t Q=%d: Selected Xnew[Q]= %0.7f: Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f\n",Q, Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q]);
            fflush(stdout);
	  }
	  if(DEBUG>=2) assert(minKB <= Xlow[Q] + 1e-6 && Xlow[Q] <= Xnew[Q] + 1e-8  && Xnew[Q] <= Xhigh[Q]);
  	  if(DEBUG>=2) assert(fabs(origval - fixYdel[Q+1]) <= 1e-8);
	  if(DEBUG>=2 && MULTIMODE_FIX4 >= 2 && !(fabs(origval - Xmid[Q]) <= 1e-8)){
	    #pragma omp critical
	    {
	      printf("Q=%d:Xlow[Q]=%0.8f,Xmid[Q]=%0.8f,Xhigh[Q]=%0.8f,origval=%0.8f\n",Q,Xlow[Q],Xmid[Q],Xhigh[Q],origval);
	      fflush(stdout);
	      assert(fabs(origval - Xmid[Q]) <= 1e-8);
	    }
	  }

          if(DEBUG>=2) assert(Xlow[Q] <= origval + 1e-8 && origval <= Xhigh[Q] + 1e-8);
	  if(DEBUG>=2) assert(minKB <= Xlow[Q]+1e-6 && Xlow[Q] <= Xnew[Q]+1e-6 && Xnew[Q] <= Xhigh[Q]+1e-6);

	  if(MULTIMODE_FIX2){
	    if(DEBUG>=2 && DELTA_FIX3) assert(fabs(Xnew[Q] - origval) >= 0.9e-8);
	    if(DEBUG>=2) assert(minKB <= Xlow[Q]+1e-6 && (Xlow[Q] < min(Xnew[Q],Xmid[Q]) || Xlow[Q] <= minKB + 1e-6) && max(Xnew[Q],Xmid[Q]) < Xhigh[Q]);

	    delta[Q][0] = Xnew[Q] - origval;
	    D[Q] = 1;
	  }
	}
      } // omp for Q = 1..N-1

      #pragma omp critical
      {
	if(OMP_DEBUG) LoopCnt += myLoopCnt;
	ifirstP = min(ifirstP,myifirstP);
	ilastP = max(ilastP,myilastP);
	ChangeCnt += myChangeCnt;
	predLPdelta += mypredLPdelta;
      }
    } // parallel
    if(OMP_DEBUG) assert(LoopCnt == 2*(N-1));// to verify OMP loop with two omp for clauses of N-1 iterations each

    /* Update D[Q], delta[Q] */
    //    int origDcntT = DcntT;
    Dcnt = DcntT = 0;
    DcntS = 0.0;

    if(OMP_DEBUG) LoopCnt = 0;
    #pragma omp parallel num_threads(nthreads) if(nthreads > 1 && !SVERB)
    {
      int myLoopCnt = 0;
      int myDcnt = 0, myDcntT = 0;
      double myDcntS = 0.0;
      double myDcntX = 0.0;

      #pragma omp for schedule(static,64)
      for(int Q = 1; Q < N; Q++){
        if(OMP_DEBUG) myLoopCnt++;
	if(D[Q] <= 0)
	  continue;
	register double origval = fixYdel[Q+1];
	double testLPT = peakLP[Q];
	int maxt = peakT[Q];

	int MPblock = (MPBLOCK && initialjump && singlechange && testLPT - qLP <= 0.8 * MULTIMODE_MP_DELTA2 && (D[Q] <= 2 || (maxt > 0 && maxt < D[Q] -1)) && abs(Q-bestQ) != 1) ? 1 : 0;
	int MPscan = ((initialjump || LPchange > MULTIMODE_MP_DELTA) && (MULTIMODE_MP_SCAN <= 0.0 || max(Xchange[Q-1], Xchange[Q+1]) > MULTIMODE_MP_SCAN * Xmid[Q] || 
									 (MULTIMODE_FIX5 ? conflictLP[Q] > (MULTIMODE_FIX4 ? max(peakLP[Q], mLP + DELTA1) : max(maxLP[Q], qLP + DELTA1)) 
									  : !(D[Q] <= 2 || (maxt > 0 && maxt < D[Q] -1))))) ? 1 : 0;

	if(VERB>=2 || SVERB || ERRPLOT){
	  printf("Q=%d:Xnew[Q]=%0.7f,Xlow[Q]=%0.7f,Xmid[Q]=%0.7f,Xhigh[Q]=%0.7f,Xcur[Q]=%0.7f,D[Q]=%d,MPblock=%d,MPscan=%d (bestQ=%d,singlechange=%d)\n",
		 Q,Xnew[Q],Xlow[Q],Xmid[Q],Xhigh[Q],fixYdel[Q+1],D[Q],MPblock,MPscan,bestQ,singlechange);
	  fflush(stdout);
	}

	if(DEBUG && !(Xnew[Q] >= minKB - 1e-8)){
	  #pragma omp critical
	  {
	    printf("Q=%d,N=%d:Xnew[Q]=%0.6f,minKB=%0.6f,Xlow[Q]=%0.6f,Xmid[Q]=%0.6f,Xhigh[Q]=%0.6f,Xcur[Q]=%0.6f,D[Q]=%d,MPblock=%d,MPscan=%d (bestQ=%d,singlechange=%d)\n",
                      Q,N,Xnew[Q],minKB,Xlow[Q],Xmid[Q],Xhigh[Q],fixYdel[Q+1],D[Q],MPblock,MPscan,bestQ,singlechange);
	    fflush(stdout);
	    assert(Xnew[Q] >= minKB - 1e-8);
	  }
	}

	/* NOTE : If MULTIMODE_FIX2, delta[Q][0..D[Q]-1] should already be initialized and D[Q] could be > 1, otherwise only a single sample point Xnew[Q] is known */
	if(!MULTIMODE_FIX2){
	  /* IF DELTA_FIX3 && Xnew[Q] == origval :
	     1. If MPscan == 1 && !MPblock : Do NOT include Xnew[Q] in delta[Q]
	     2. Else : widen Xlow[Q]..Xhigh[Q] based on delta[Q][maxt-1,maxt+1] and compute new Xnew[Q]
	  */

          if(DELTA_FIX3 && fabs(Xnew[Q] - origval) <= 1e-8){
	    if(MPscan && !MPblock)
	      D[Q] = 0;
	    else {
	      double origXlow = Xlow[Q];// origXhigh = Xhigh[Q];
	      Xlow[Q] = min(Xlow[Q], delta[Q][max(0,maxt-1)]);
	      Xhigh[Q] = max(Xhigh[Q], delta[Q][min(D[Q]-1, maxt + 1)]);
	      if(DEBUG>=2 && !(Xlow[Q] >= minKB - 1e-8)){
		printf("\t Q=%d: Xlow[Q] = %0.4f -> %0.4f : maxt=%d, delta[Q][%d] = %0.4f, minKB= %0.4f\n",
		       Q,origXlow,Xlow[Q],maxt, max(0,maxt-1), delta[Q][max(0,maxt-1)],minKB);
		for(int t = 0; t < D[Q]; t++)
		  printf("         X[%d]=%0.6f(LP=%0.6f,delta=%0.6f),Q=%d\n",t,delta[Q][t], LPdelta[Q][t], LPdelta[Q][t] - mLP,Q);
		fflush(stdout);
		assert(Xlow[Q] >= minKB - 1e-8);
	      }

	      /* select new test point Xnew[Q] (could be outside of range Xlow[Q] .. Xhigh[Q]) */
	      if(Xlow[Q] >= Xmid[Q] - 1e-6 && Xlow[Q] >= minKB + 1e-6){
		Xnew[Q] = max(minKB,Xmid[Q] - phi*max(1.0,Xhigh[Q] - Xmid[Q]));
		if(Xnew[Q] < Xmid[Q] * 0.7)
		  Xnew[Q] = Xmid[Q] * 0.7;
		if(bool(MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
		  Xlow[Q] = min(Xnew[Q],Xlow[Q]);
		if(DEBUG>=2) assert(Xnew[Q] >= minKB);
	      } else if(Xhigh[Q] <= Xmid[Q] + 1e-6 && Xhigh[Q] <= max(1.0,origval)*4.0){
		Xnew[Q] = Xmid[Q] + phi * max(1.0,Xmid[Q] - Xlow[Q]);
		if(Xnew[Q] > Xmid[Q] * 1.2)
		  Xnew[Q] = Xmid[Q] * 1.2;
		if((MULTIMODE_FIX2) || bool(MULTIMODE_FIX3))
		  Xhigh[Q] = max(Xnew[Q],Xhigh[Q]);
		if(DEBUG>=2) assert(Xnew[Q] >= minKB - 1e-8);
	      } else {
		if(Xhigh[Q] - Xmid[Q] > Xmid[Q] - Xlow[Q])
		  Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q] - Xmid[Q]);
		else
		  Xnew[Q] = Xmid[Q] - resphi*(Xmid[Q] - Xlow[Q]);
		if(DEBUG>=2 && !(Xnew[Q] >= minKB - 1e-8)){
		  printf("\t Q=%d: Xlow[Q] = %0.4f -> %0.4f : maxt=%d, delta[Q][%d] = %0.4f, minKB= %0.4f, Xmid[Q]=%0.4f,Xhigh[Q]=%0.4f,resphi= %0.6f:Xnew[Q]=%0.6f\n",
			 Q,origXlow,Xlow[Q],maxt, max(0,maxt-1), delta[Q][max(0,maxt-1)],minKB,Xmid[Q],Xhigh[Q],resphi,Xnew[Q]);
		  fflush(stdout);
		  assert(Xnew[Q] >= minKB - 1e-8);
		}
	      }

	      if(DEBUG>=3 && !(Xnew[Q] >= minKB - 1e-8)){
		printf("\t Q=%d: Xlow[Q] = %0.4f -> %0.4f : maxt=%d, delta[Q][%d] = %0.4f, minKB= %0.4f, Xmid[Q]=%0.4f,Xhigh[Q]=%0.4f,resphi= %0.6f:Xnew[Q]=%0.4f\n",
		       Q,origXlow,Xlow[Q],maxt, max(0,maxt-1), delta[Q][max(0,maxt-1)],minKB,Xmid[Q],Xhigh[Q],resphi,Xnew[Q]);
		fflush(stdout);
		assert(Xnew[Q] >= minKB - 1e-8);
	      }

	      delta[Q][0] = Xnew[Q] - origval;
	      D[Q] = 1;
	      if(VERB>=2 || SVERB || ERRPLOT){
		printf("\t Q=%d: Xnew[Q] -> %0.4f (Xlow[Q]= %0.4f, Xmid[Q]= %0.4f, Xhigh[Q]= %0.4f),D[Q]=%d\n",Q,Xnew[Q], Xlow[Q],Xmid[Q],Xhigh[Q],D[Q]);
		fflush(stdout);
	      }
	    }
	  } else {
	    delta[Q][0] = Xnew[Q] - origval;
	    D[Q] = 1;
	  }
	} // !MULTIMODE_FIX2

	/* expand Xlow[Q]..Xhigh[Q] if neighboring interval Q-1 or Q+1 had large change */
	if(MULTIMODE_FIX2 && MULTIMODE_FIX3 <= 1 && max(Xchange[Q-1],Xchange[Q+1]) > (Xhigh[Q] - Xlow[Q])){
	  double origXlow = Xlow[Q], origXhigh = Xhigh[Q];
	  double range = max(Xchange[Q-1],Xchange[Q+1]);
	  int origD = D[Q];
	  if(Xhigh[Q] <= Xlow[Q] || D[Q] <= 0){
	    if(DEBUG) assert(D[Q] <= 0);
	    Xlow[Q] = max(minKB, Xmid[Q] - range * 0.5);
	    Xhigh[Q] = Xlow[Q] + range;
	    Xnew[Q] = Xmid[Q] + resphi*(Xhigh[Q] - Xmid[Q]);	
	    delta[Q][0] = Xnew[Q] - origval;
	    D[Q] = 1;
	  } else {
	    if(DEBUG) assert(D[Q] > 0);
	    double scale = range / (Xhigh[Q] - Xlow[Q]);
            if(MULTIMODE_FIX3 && scale >= 1.0 + MULTIMODE_MP_SCAN){/* add previous Xlow[Q] and Xhigh[Q] as new sample points */
	      if(D[Q] + 1 >= Dsiz[Q]){
		register double *newdel = new double[Dsiz[Q] + 21];
		for(register int k = Dsiz[Q]; --k >= 0;)
		  newdel[k] = delta[Q][k];
		Dsiz[Q] += 21;
		delete [] delta[Q];
		delete [] LPdelta[Q];
		delta[Q] = newdel;
		LPdelta[Q] = new double[Dsiz[Q]];
	      }
	      if(Xlow[Q] > minKB + min(DELTA_RES,DELTA_REL*Xlow[Q])){
		delta[Q][D[Q]++] = Xlow[Q] - origval;
		Xlow[Q] = max(minKB, Xmid[Q] - (Xmid[Q] - Xlow[Q]) * scale);
	      }
	      delta[Q][D[Q]++] = Xhigh[Q] - origval;
	      Xhigh[Q] = Xlow[Q] + range;

	      qsort(delta[Q],D[Q],sizeof(double),(intcmp *)doubleInc);
	    }
	  }
	  if(VERB>=2 || SVERB || ERRPLOT){
	    #pragma omp critical
	    {
	      printf("\t Q=%d: Widened Xlow=%0.4f[Q],Xhigh[Q]=%0.4f to Xlow[Q]=%0.4f,Xhigh[Q]=%0.4f, D[Q]=%d->%d, Xnew[Q]= %0.4f: Xch[Q-1,Q+1]= %0.4f,%0.4f\n",
		     Q,origXlow,origXhigh,Xlow[Q],Xhigh[Q],origD,D[Q],Xnew[Q],Xchange[Q-1],Xchange[Q+1]);
	      if(D[Q] > origD)
		printf("\t Q=%d: Added original Xlow and Xhigh as new sample points\n",Q);
	      fflush(stdout);
	    }
	  }
	  if(DEBUG>=2) assert(Xlow[Q] >= minKB);
	}

	if(MULTIMODE_MP > 0 && !MPblock){/* add additional test points */
	  if(MULTIMODE_FIX3){ 
	    if(1){
	      int origD = D[Q];
	      double S1,S2;
	      if(origD > 0){
		S1 = min(Xmid[Q], origval + delta[Q][0]);
		S2 = max(Xmid[Q], origval + delta[Q][origD-1]);
	      } else
		S1 = S2 = (Xlow[Q] + Xhigh[Q]) * 0.5;

              if(VERB>=2 || SVERB/* HERE >=2 */){
                printf("Q=%d:D[Q]=%d,Xlow[Q]=%0.7f,S1=%0.7f,S2=%0.7f,Xhigh[Q]=%0.7f : picking up to %d additional test points\n",
		       Q,D[Q],Xlow[Q],S1,S2,Xhigh[Q],(MULTIMODE_FIX3 >= 2) ? 2*MULTIMODE_MP : 3*MULTIMODE_MP);
                fflush(stdout);
              }
	      if(DEBUG && !(Xlow[Q] <= S1+1e-6 && S1 <= S2+1e-6 && S2 <= Xhigh[Q]+1e-6)){
		printf("Q=%d: Xlow[Q]= %0.8f, Xmid[Q]= %0.8f, Xnew[Q]= %0.8f, Xhigh[Q]= %0.8f, S1= %0.8f, S2= %0.8f, origval= %0.8f D[Q]=%d:\n",
		  Q,Xlow[Q],Xmid[Q],Xnew[Q],Xhigh[Q],S1,S2,origval,D[Q]);
		for(int t = 0; t < D[Q]; t++)
		  printf("\t delta[Q][%d] + origval = %0.8f\n",t,delta[Q][t] + origval);
		fflush(stdout);
		assert(Xlow[Q] <= S1+1e-6 && S1 <= S2+1e-6 && S2 <= Xhigh[Q]+1e-6);
	      }

	      if(MULTIMODE_FIX3 >= 2){/* add additional points at equidistant points starting at Xlow[Q] and Xhigh[Q] and spreading out */
		int MMpoints = (!MULTIMODE_FIX5 || MPscan) ? MULTIMODE_MP : 1;

		if(D[Q] + 2*MULTIMODE_MP > Dsiz[Q]){
		  register double *newdel = new double[D[Q] + 2 * MMpoints];
		  for(register int k = Dsiz[Q]; --k >= 0;)
		    newdel[k] = delta[Q][k];
		  Dsiz[Q] = D[Q] + 2 * MMpoints;
		  delete [] delta[Q];
		  delete [] LPdelta[Q];
		  delta[Q] = newdel;
		  LPdelta[Q] = new double[Dsiz[Q]];
		}

		double step = S1 - Xlow[Q];
		if(step > min(DELTA_RES,DELTA_REL*S1)){
		  double val = Xlow[Q];
		  for(int t = 1; t <= MMpoints; t++){
		    if(val <= minKB)
		      break;
		    delta[Q][D[Q]++] = val - origval;
		    val -= step;
		  }
		  Xlow[Q] = max(minKB,val);
		}
		step = Xhigh[Q] - S2;
		if(step > min(DELTA_RES, DELTA_REL*S2)){
		  double val = Xhigh[Q];
		  for(int t = 1; t <= MMpoints; t++){
		    delta[Q][D[Q]++] = val - origval;
		    val += step;
		  }
		  Xhigh[Q] = val;
		}
              } else {// MULTIMODE_FIX3 == 1 : add additional equidistant points between Xlow[Q], S1, S2 and Xhigh[Q]
		if(D[Q] + 3*MULTIMODE_MP > Dsiz[Q]){
		  register double *newdel = new double[D[Q] + 3*MULTIMODE_MP];
		  for(register int k = Dsiz[Q]; --k >= 0;)
		    newdel[k] = delta[Q][k];
		  Dsiz[Q] = D[Q] + 3*MULTIMODE_MP;
		  delete [] delta[Q];
		  delete [] LPdelta[Q];
		  delta[Q] = newdel;
		  LPdelta[Q] = new double[Dsiz[Q]];
		}
		double invMP = 1.0/(MULTIMODE_MP+1);
		if(S1 > Xlow[Q] + min(DELTA_RES,DELTA_REL*S1)*2.0){
		  double inc = (S1 - Xlow[Q]) * invMP;
		  double val = Xlow[Q];
		  for(int t = 1; t <= MULTIMODE_MP; t++){
		    val += inc;
		    delta[Q][D[Q]++] = val - origval;
		  }
		}
		if(S2 > S1 + min(DELTA_RES,DELTA_REL*S2)*2.0){
		  double inc = (S2 - S1) * invMP;
		  double val = S1;
		  for(int t = 1; t <= MULTIMODE_MP; t++){
		    val += inc;
		    delta[Q][D[Q]++] = val - origval;
		  }
		}
		if(Xhigh[Q] > S2 + min(DELTA_RES,DELTA_REL*Xhigh[Q])*2.0){
		  double inc = (Xhigh[Q] - S2) * invMP;
		  double val = S2;
		  for(int t = 1; t <= MULTIMODE_MP; t++){
		    val += inc;
		    delta[Q][D[Q]++] = val - origval;
		  }
		}
	      }
	    }
	  } else {/* add additional test points at intervals of MULTIMODE_MP_MIN,MULTIMODE_MP_MAX */
	    double ratio1 = 1.0+MULTIMODE_MP_MAX;
	    double ratio2 = (DELTA_FIX4 <= 0) ? 1.0-MULTIMODE_MP_MIN : 1.0/(1.0+MULTIMODE_MP_MIN);
	    double mratio1 = ratio1, mratio2 = ratio2;
	    for(int t = 0; t < MULTIMODE_MP; t++){
	      double val = Xnew[Q] * mratio1;
	      mratio1 *= ratio1;
	      if(MPscan || (Xlow[Q] < val && val < Xhigh[Q])){
		if(DEBUG && !(val >= minKB - 1e-8)){
		  printf("\t Q=%d, t=%d, val= %0.6f, mratio1= %0.6f, Xnew[Q]= %0.6f, minKB= %0.6f\n",Q,t,val,mratio1,Xnew[Q],minKB);
		  fflush(stdout);
		  assert(val >= minKB - 1e-8);
		}
		delta[Q][D[Q]++] = val - origval;
	      }

	      val = Xnew[Q] * mratio2;
	      if(val > minKB){
		if(MPscan || (Xlow[Q] < val && val < Xhigh[Q]))
		  delta[Q][D[Q]++] = val - origval;
		mratio2 *= ratio2;
	      }
	    }
	  }/* !MULTIMODE_FIX3 */

	  if(DEBUG) assert(D[Q] <= Dsiz[Q]);
	  qsort(delta[Q],D[Q],sizeof(double),(intcmp *)doubleInc);
	}	

	if(D[Q] <= 0)
	  continue;

	myDcntT += D[Q];
	myDcntS += Xhigh[Q] - Xlow[Q];
	myDcnt++;

	if(VERB>=2 || SVERB || ERRPLOT)
	  myDcntX += Xmid[Q];

	if(VERB>=2 || SVERB || ERRPLOT){
          #pragma omp critical
	  {
	    printf("   Q=%d,D[Q]=%d,testLPT=%0.6f,qLP=%0.6f,IJ=%d,SC=%d,MPblock=%d,Xch[Q-1,Q+1]=%0.7f,%0.7f,MPscan=%d,maxt=%d:Dcnt=%d(tot=%d,sum=%0.3f,sumX=%0.3f),Xlow=%0.7f,Xmid=%0.7f,Xhigh=%0.7f:\n",
		   Q,D[Q],testLPT,qLP,initialjump,singlechange,MPblock,Xchange[Q-1],Xchange[Q+1],MPscan,maxt,myDcnt,myDcntT,myDcntS,myDcntX,Xlow[Q],Xmid[Q],Xhigh[Q]);
	    for(register int t = 0; t < D[Q]; t++)
	      printf("        t=%d:delta[Q][t]=%0.7f,origval=%0.7f,Xcur=%0.7f,X[t]=%0.7f,minKB=%0.7f,Q=%d\n",
		     t,delta[Q][t],origval,fixYdel[Q+1],delta[Q][t]+origval,minKB,Q);
	    fflush(stdout);
	  }
	}
      } // for Q=1..N-1
      
      #pragma omp critical
      {
        if(OMP_DEBUG) LoopCnt += myLoopCnt;
	DcntT += myDcntT;
	DcntS += myDcntS;
	Dcnt += myDcnt;
      }
    } // parallel
    if(OMP_DEBUG) assert(LoopCnt == N-1);

    if(VERB >= (SVERB ? 1 : 3) || ERRPLOT){
      printf("After Goldenmean search iter=%d:Dcnt=%d,DcntT=%d,DcntS=%0.3f,ifirstP=%d,ilastP=%d\n",iter,Dcnt,DcntT,DcntS,ifirstP,ilastP);
      fflush(stdout);
    }
    if(DEBUG && bestLPdelta > mLP + LP_MINDELTA && ! (0 <= ifirstP && ifirstP <= ilastP && ilastP <= N)){
      printf("During Goldenmean search iter=%d:ChangeCnt=%d,ifirstP=%d,ilastP=%d,N=%d,Dcnt=%d,DcntT=%d, best delta=%0.10f(bestQ=%d)\n",iter, ChangeCnt,ifirstP,ilastP,N,Dcnt,DcntT, bestLPdelta-qLP, bestQ);
      fflush(stdout);
      assert(0 <= ifirstP && ifirstP <= ilastP && ilastP <= N);
    }
  } // while(iter < GM_ITER && Dcnt > 0)

  /* Fibonacci search completed for all intervals */
  if(DEBUG) assert(fixYdel[0] == 0.0);
  register double cum = 0.0;
  fixY[0] = cum;
  for(register int I = 1; I <= N+1; I++){
    cum += fixYdel[I];
    fixY[I] = cum;
  }

  if(VERB>=2 || SPEEDCHECK){
    printf("mprobevalwinResize:N=%d: returning qLP=%0.6f after %d iterations\n",N, qLP,iter);
    fflush(stdout);
  }

  delete [] skipmap;

  delete [] peakT;
  delete [] peakLP;
  delete [] Xchange;

  delete [] Lcnt;
  delete [] Rcnt;

  delete [] changes;
  delete [] conflictLP;
  delete [] conflictQ;
  delete [] maxLP;
  delete [] Xbest;
  delete [] Xnew;
  delete [] Xhigh;
  delete [] Xlow;
  delete [] Xmid;
  for(register int I = 1 ; I < N; I++){
    delete [] delta[I];
    delete [] LPdelta[I];
  }
  delete [] LPdelta;
  delete [] delta;
  delete [] LPdel;
  delete [] Dsiz;
  delete [] D;

  return qLP;
}


/* correct map1[],mapK1[],map2[],mapK2[] to reflect remapping of Hcuts[i=L..R] to Hcuts[Hremap[i]]
   Returns 1 IFF any map entry was changed, 0 otherwise
 */
static int correctmapH(int n,
		       int MD, /* number of maps */
		       int *MX, /* MX[m] is number of sites of map m */
		       int **map1, /* map1[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts1[0..n+1] of X[m][j], 
				      map1[MD][j=0..n+1] is index in Y1[0..N+1] of Hcuts1[j] */
		       int **map2, /* map2[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts2[0..n+1] of X[m][j], 
				      map1[MD][j=0..n+1] is index in Y2[0..N+1] of Hcuts2[j] */
		       int **mapK1, /* mapK1[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts1[0..n+1] of X[m][j] */ 
		       int **mapK2, /* mapK2[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts2[0..n+1] of X[m][j] */ 
		       int L, int R,
		       int *Hremap,/* Hremap[L..R] remaps labels from original locations Hcuts[i=L..R] to current location Hcuts[Hremap[i]] */
		       int *HapSite,/* for debugging */
		       double *Hcuts,/* for debugging */
		       double *HapDelta,/* for debugging */
		       double *Delta,/* for debugging */
		       int numthreads
		       )
{
  int remapped = 0;

  for(int i = L; i <= R; i++)
    if(Hremap[i] != i){
      remapped = 1;
      break;
    }

  if(remapped){

    if(VERB && rverb){
      printf("correctmapH:Hremap[%d..%d]:\n",L,R);
      for(int i = L; i <= R; i++)
	if(i==L || i==R || Hremap[i] != i)
          printf("\t Hremap[%d]= %d\n",i,Hremap[i]);
      fflush(stdout);
    }

    int block = 1;
    while(block < 16 && MD > numthreads * block * 8)
      block *= 2;

    #pragma omp parallel for num_threads(numthreads) schedule(static,block)
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      if(VERB>=2 && rverb && m==163){
	#pragma omp critical
	{
	  printf("Before correctmapH:\n");
	  for(int J = 1; J <= M; J++){
	    int I = map1[m][J];
	    if(I > 0){
	      int K = mapK1[m][J];
	      printf("\t J=%d:map1[m][J]=%d(HS=%d),mapK1[m][J]=%d(HS=%d)\n",J,I,HapSite[I],K,(K < 0 ) ? -1 : HapSite[I-K]);
	    }
	  }
	  printf("\n");
	  for(int J = 1; J <= M; J++){
	    int I = map2[m][J];
	    if(I >= 0){
	      int K = mapK2[m][J];
	      printf("\t J=%d:map2[m][J]=%d(HS=%d),mapK2[m][J]=%d(HS=%d)\n",J,I,HapSite[I],K, (K < 0) ? -1 : HapSite[I-K]);
	    }
	  }
	}
      }

      for(int J = 1; J <= M; J++){
	int I = map1[m][J];
	if(I >= L){
	  int K = mapK1[m][J];
	  if(DEBUG) assert(0 <= K && K < I);
	  K = I-K;
	  
	  int rI = I, rK = K;
	  if(I <= R){
	    rI = Hremap[I];
	    if(DEBUG) assert(0 < rI && rI <= n);
	  }
	  if(L <= K && K <= R){
	    rK = Hremap[K];
	    if(DEBUG && (HapSite[rK] & 1) && (HapSite[rI] & 1) && !(0 < rK && rK <= rI)){
	      #pragma omp critical
	      {
		printf("m=%d/%d:L=%d,R=%d,M=%d:map1:J=%d,I=%d -> %d,K=%d -> %d\n",
		       m,MD,L,R,M,J,I,rI,K,rK);
		for(int i = L; i <= R; i++)
		  if(HapSite[i] || HapDelta[i] || Delta[i])
		    printf("\t i=%d:Hremap[i]= %d, HapSite[i]= %d, Hcuts[i]= %0.4f, HapDelta[i]= %0.4f, Delta[i]= %0.4f\n",i, Hremap[i], HapSite[i], Hcuts[i], HapDelta[i], Delta[i]);
		fflush(stdout);
		assert(0 < rK && rK <= rI);
	      }
	    }
	    if(DEBUG) assert(0 < rK && rK <= n);
	    if(rK > rI){
	      int tmp = rI;
	      rI = rK;
	      rK = tmp;
	    }
	  }
	  
	  map1[m][J] = rI;
	  mapK1[m][J] = rI - rK;
	}
	
	I = map2[m][J];
	if(I >= L){
	  int K = mapK2[m][J];
	  if(DEBUG) assert(0 <= K && K < I);
	  K = I-K;
	  
	  int rI = I, rK = K;
	  if(I <= R){
	    rI = Hremap[I];
	    if(DEBUG) assert(0 < rI && rI <= n);
	  }
	  if(L <= K && K <= R){
	    rK = Hremap[K];
	    if(DEBUG && (HapSite[rI] & 2) && (HapSite[rK] & 2) && !(0 < rK && rK <= rI)){
	      #pragma omp critical
	      {
		printf("m=%d/%d:L=%d,R=%d,M=%d:map2:J=%d,I=%d -> %d,K=%d -> %d\n",
		       m,MD,L,R,M,J,I,rI,K,rK);
		for(int i = L; i <= R; i++)
		  if(HapSite[i] || HapDelta[i] || Delta[i])
		    printf("\t i=%d:Hremap[i]= %d, HapSite[i]= %d, Hcuts[i]= %0.4f, HapDelta[i]= %0.4f, Delta[i]= %0.4f\n",i, Hremap[i], HapSite[i], Hcuts[i], HapDelta[i], Delta[i]);
		fflush(stdout);
		assert(0 < rK && rK <= rI);
	      }
	    }
	    if(DEBUG) assert(0 < rK && rK <= n);
	  }
	  if(rK > rI){
	    int tmp = rI;
	    rI = rK;
	    rK = tmp;
	  }
	  
	  map2[m][J] = rI;
	  mapK2[m][J] = rI - rK;
	}
      }// for J = 1..M 

      if(VERB>=2 && rverb && m==163){
	#pragma omp critical
	{
	  printf("After correctmapH:\n");
	  for(int J = 1; J <= M; J++){
	    int I = map1[m][J];
	    if(I > 0){
	      int K = mapK1[m][J];
	      printf("\t J=%d:map1[m][J]=%d(HS=%d),mapK1[m][J]=%d(HS=%d)\n",J,I,HapSite[I],K,(K < 0) ? -1 : HapSite[I-K]);
	    }
	  }
	  printf("\n");
	  for(int J = 1; J <= M; J++){
	    int I = map2[m][J];
	    if(I >= 0){
	      int K = mapK2[m][J];
	      printf("\t J=%d:map2[m][J]=%d(HS=%d),mapK2[m][J]=%d(HS=%d)\n",J,I,HapSite[I],K,(K < 0) ? -1 : HapSite[I-K]);
	    }
	  }
	}
      }
      if(CORRECTMAP_CLEANUP){
	int lastJ = -1, lasti = -1, lastk = -1, i, k;    	
	for(int J = 1; J <= M; J++){
	  if((i = map1[m][J]) > 0){
	    k = mapK1[m][J];
	    assert(0 <= k && k < i);
	    if(lasti >= 0 && !(i-k > lasti)){
	      if(map1[MD][lasti] <= 0){/* fix lasti,lastk */
		while(lastk > 0 && !(i-k > lasti) && map1[MD][lasti] <= 0){
		  lastk--;
		  lasti--;
		}
		if(!(i-k > lasti))
		  map1[m][lastJ] = -1;
		else {
		  map1[m][lastJ] = lasti;
		  mapK1[m][lastJ] = lastk;
		}
	      } else {/* fix i,k */
		while(k > 0 && !(i-k > lasti) && map1[MD][i-k] <= 0)
		  k--;
		if(!(i-k > lasti)){
		  map1[m][J] = -1;
		  continue;/* skip J : don't update lasti,lastk,lastJ */
		} else
		  mapK1[m][J] = k;
	      }
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}

	lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  if((i = map2[m][J]) > 0){
	    k = mapK2[m][J];
	    assert(0 <= k && k < i);
	    if(lasti >= 0 && !(i-k > lasti)){
	      if(map2[MD][lasti] <= 0){/* fix lasti,lastk */
		while(lastk > 0 && !(i-k > lasti) && map2[MD][lasti] <= 0){
		  lastk--;
		  lasti--;
		}
		if(!(i-k > lasti))
		  map2[m][lastJ] = -1;
		else {
		  map2[m][lastJ] = lasti;
		  mapK2[m][lastJ] = lastk;
		}
	      } else {/* fix i,k */
		while(k > 0 && !(i-k > lasti) && map2[MD][i-k] <= 0)
		  k--;
		if(!(i-k > lasti)){
		  map2[m][J] = -1;
		  continue;/* skip J : don't update lasti,lastk,lastJ */
		} else
		  mapK2[m][J] = k;
	      }
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }
    } // for m = 0..MD-1
  } // if ( remapped )

  return remapped;
}

/* Correct map1[],map2[] by removing mappings to labels Hcuts[i] that are no longer present (map1[MD][i] == -1).
   These are typically labels that were removed since the last call to cleanmap(), or were present when HaploTypeR() was called, reflecting locations of unaligned labels.
*/
static void cleanmapH(int n, 
		      int MD, /* number of maps */
		      int *MX, /* MX[m] is number of sites of map m */
		      int **map1, /* map1[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts1[0..n+1] of X[m][j], 
				    map1[MD][j=0..n+1] is index in Y1[0..N+1] of Hcuts1[j] */
		      int **map2, /* map2[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts2[0..n+1] of X[m][j], 
				    map1[MD][j=0..n+1] is index in Y2[0..N+1] of Hcuts2[j] */
		      int **mapK1, /* mapK1[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts1[0..n+1] of X[m][j] */ 
		      int **mapK2, /* mapK2[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts2[0..n+1] of X[m][j] */ 
		      int *HapSite,/* for debuggin only */
		      int numthreads
		     )
{
  int block = 1;
  while(block < 16 && MD > numthreads * block * 8)
    block *= 2;

  int LoopCnt = 0;
  #pragma omp parallel num_threads(numthreads) if(numthreads>1)
  {
    int myLoopCnt = 0;
    #pragma omp for schedule(static,block)
    for(int m = 0; m < MD; m++){
      if(OMP_DEBUG) myLoopCnt++;
      int M = MX[m];

      if(DEBUG>=2){
        if(VERB>=2 && m==9){
          printf("map1:m=%d,M=%d:\n",m,M);
	  for(int j = 1; j <= M; j++){
            int i = map1[m][j];
	    if(i < 0)
	      continue;
	    int k = mapK1[m][j];
	    printf("\t j=%d:map1[m][j]=i=%d,mapK1[m][j]=k=%d,map1[MD][i]=%d\n",j,i,k,map1[MD][i]);
          }
        }

        int lastI = -1, lastK = -1, lastJ = -1;
        for(int J = 1; J <= M; J++){
          int I = map1[m][J];
  	  if(I < 0)
	    continue;
	  if(map1[MD][I] <= 0)
	    continue;
	  int K = mapK1[m][J];
	  if(K > 0 && map1[MD][I-K] <= 0)/* locally "clean up" mapK1 */
	    K = 0;
	  if(lastI >= 0 && !(I-K > lastI)){
            #pragma omp critical
            {
	      printf("map1:m=%d,M=%d:J=%d,I=%d,K=%d:lastJ=%d,lastI=%d,lastK=%d\n",m,M,J,I,K,lastJ,lastI,lastK);
	      if(VERB/* HERE >=2 */){
		for(int j = 1; j <= M; j++){
		  int i = map1[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK1[m][j];
		  printf("\t j=%d:map1[m][j]=i=%d,mapK1[m][j]=k=%d,map1[MD][i]=%d\n",j,i,k,map1[MD][i]);
		}
	      }
	      fflush(stdout);
	      assert(I-K > lastI);
	    }	  
          }
	  lastI = I;
	  lastK = K;
	  lastJ = J;
        }
      }

      /* Correct map1[m][J],mapK1[m][J] to remove mappings to labels Hcuts1[i] that are no longer present (map1[MD][i] == -1) */
      int lasti = -1;
      for(int J = 1; J <= M; J++){
	int i = map1[m][J];
	if(i < 0)
	  continue;
	int k = mapK1[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
          #pragma omp critical
          {
            printf("m=%d/%d:M=%d,J=%d,map1[m][J]=i=%d,mapK1[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
            assert(0 <= k && k < i);
          }
        }
	k = i - k;

	while(i > k && i > lasti+1/* NEW4*/ && map1[MD][i] < 0)// NEW
	  i--;
	if(map1[MD][i] < 0){/* remove mapping of label J */
	  map1[m][J] = -1;
	  continue;
	}
	while(k < i && (map1[MD][k] < 0 || k <= lasti))// NEW
	  k++;
	if(DEBUG) assert(map1[MD][k] >= 0);

	if(k <= lasti){// NEW4 : fix error by unmapping J : not clear how this happened
	  map1[m][J] = -1;
	  continue;
	}

	map1[m][J] = i;
	mapK1[m][J] = i-k;

	lasti = i;
      }

      if(DEBUG>=1+RELEASE){
        int lasti = -1, lastk = -1, lastJ = -1;
        for(int J = 1; J <= M; J++){
          int i = map1[m][J];
  	  if(i < 0)
	    continue;
	  int k = mapK1[m][J];
	  int I = map1[MD][i];
	  if(I < 0 || (lasti >= 0 && !(i-k > lasti))){
#pragma omp critical
	    {
	      printf("map1:m=%d,M=%d:J=%d,i=%d,k=%d,map1[MD][i]=I=%d:lastJ=%d,lasti=%d,lastk=%d\n",m,M,J,i,k,I,lastJ,lasti,lastk);
	      if(VERB){
		for(int j = 1; j <= M; j++){
		  int i = map1[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK1[m][j];
		  printf("\t j=%d:map1[m][j]=i=%d,mapK1[m][j]=%d,map1[MD][i]=%d\n",j,i,k,map1[MD][i]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	      assert(I >= 0);
	    }	  
	  }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
	}
      }

      if(VERB>=2 && (m == 8674 || m == 938)){
        #pragma omp critical
        {
          printf("cleanmapH: m=%d/%d, M=%d : before updating map2:\n",  m, MD, M);
	  for(int j = 1; j <= M; j++){
            int i = map2[m][j];
	    if(i < 0)
	      continue;
	    int k = mapK2[m][j];
	    int I = map2[MD][i];
	    printf("\t j=%d:map2[m][j]=i=%d(HS=%d,I=%d),mapK2[m][j]=k=%d(HS=%d,K=%d)\n",j,i,HapSite[i],map2[MD][i],k,(k < 0) ? -1 : HapSite[i-k], (k < 0 || I < 0) ? -1 : I - map2[MD][i-k]);
          }
	  fflush(stdout);
	} 
      }

      if(DEBUG>=2){
        int lastI = -1, lastK = -1, lastJ = -1;
        for(int J = 1; J <= M; J++){
          int I = map2[m][J];
  	  if(I < 0)
	    continue;
	  if(map2[MD][I] <= 0)
	    continue;
	  int K = mapK2[m][J];
	  if(K > 0 && map2[MD][I-K] <= 0)/* locally "clean up" mapK2 */
	    K = 0;
	  if(lastI >= 0 && !(I-K > lastI)){
	    #pragma omp critical
	    {
	      printf("map2:m=%d,J=%d,I=%d,K=%d:lastJ=%d,lastI=%d,lastK=%d\n",m,J,I,K,lastJ,lastI,lastK);
	      if(VERB/* HERE >=2 */){
	        for(int j = 1; j <= J; j++){
	          int i = map2[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK2[m][j];
		  printf("\t j=%d:map2[m][j]=%d,mapK2[m][j]=%d\n",j,i,k);
	        }
              }
	      fflush(stdout);
	      //	        assert(I-K > lastI);
            }	  
	  }
	  lastI = I;
	  lastK = K;
	  lastJ = J;
        }
      }

      /* Correct map2[m][J],mapK2[m][J] to remove mappings to labels Hcuts2[i] that are no longer present (map2[MD][i] == -1) */
      lasti = -1;
      for(int J = 1; J <= M; J++){
	int i = map2[m][J];
	if(i < 0)
	  continue;
	int k = mapK2[m][J];
	if(DEBUG) assert(0 <= k && k < i);
	k = i - k;
	while(i > k && i > lasti + 1/* NEW4 */ && map2[MD][i] < 0)// NEW
	  i--;
	if(map2[MD][i] < 0){/* remove mapping of label J */
	  map2[m][J] = -1;
	  continue;
	}
	while(k < i && (map2[MD][k] < 0 || k <= lasti))// NEW
	  k++;
	if(DEBUG) assert(map2[MD][k] >= 0);
	if(k <= lasti){// NEW4 : fix error : not clear how this happened
	  map2[m][J] = -1;
	  continue;
	}
	if(VERB>=2 && (i != map2[m][J] || i-k != mapK2[m][J]) && (m == 8674 || m==938)){
	  #pragma omp critical
	  {
	    printf("\t m=%d,J=%d:map2[m][J] = %d -> %d(i), map2[MD][i]=%d, mapK2[m][J] = %d -> %d(k) (map2[MD][i-k]=%d), lasti=%d\n",
		   m,J,map2[m][J],i,map2[MD][i], mapK2[m][J], i-k, map2[MD][k],lasti);
	    fflush(stdout);
	  }
	}
	map2[m][J] = i;
	mapK2[m][J] = i-k;
	
	lasti = i;
      }
      
      if(DEBUG>=1+RELEASE){
        int lasti = -1, lastk = -1,lastJ = -1;
        for(int J = 1; J <= M; J++){
          int i = map2[m][J];
  	  if(i < 0)
	    continue;
	  int k = mapK2[m][J];
	  int I = map2[MD][i];
          if(I < 0 || (lasti >= 0 && !(i-k > lasti))){
            #pragma omp critical
            {
              printf("map2:m=%d,J=%d,i=%d,k=%d,map2[MD][i]=I=%d:lastJ=%d,lasti=%d,lastk=%d\n",m,J,i,k,I,lastJ,lasti,lastk);
	      if(VERB/* HERE >=2 */){
                for(int j = 1; j <= M; j++){
                  int i = map2[m][j];
		  if(i < 0)
		    continue;
		  int k = mapK2[m][j];
		  int I = map2[MD][i];
		  int K = (k < 0 || I < 0) ? -1 : map2[MD][i-k];
		  printf("\t j=%d:map2[m][j]=i=%d(HS=%d,I=%d),mapK2[m][j]=k=%d(HS=%d),map2[MD][i-k]=K=%d\n",
			 j,i,HapSite[i],I, k,(k < 0) ? -1 : HapSite[i-k], K);
                }
              }
	      fflush(stdout);
	      assert(i-k > lasti);
	      assert(I >= 0);
            }	  
          }
	  lasti = i;
	  lastk = k;
	  lastJ = J;
        }
      }
    } // omp for m = 0 .. MD-1
    if(OMP_DEBUG && myLoopCnt > 0){
      #pragma omp critical
      {
        LoopCnt += myLoopCnt;
      }
    }
  } // parallel
  if(OMP_DEBUG) assert(LoopCnt == MD);  
}

/* pre-allocated global arrays used by hprobeval as scratch memory */
static double *tmpLPA1 = NULL;
static double *tmpLPA2 = NULL;
static int **map1b = NULL;
static int **map2b = NULL;
static int **mapK1b = NULL;
static int **mapK2b = NULL;

static int **map1a = NULL;
static int **map2a = NULL;
static int **mapK1a = NULL;
static int **mapK2a = NULL;

//static int *tmp1 = NULL;


/* NOTE : map1b[m][j] and map2b[m][j] are space to store backup copies of map1 and map2, so that
   local changes can be made to remove mapping to labels Hcuts[i] that have been deleted and may be out of order in Hcuts[i] (see HPROBEVAL_SPREAD), since
   setlimit() called by qprobeval() requires that labels in Hcuts[i] that are mapped by map1 or map2 must be in monotonic order */

/* compute LP of a HaploType Map pair */
__attribute__ ((noinline))
double hprobeval(int n, double *Hcuts1, double *Hcuts2, /* complete consensus maps Hcuts1[0..n+1], Hcuts2[0..n+2] == Hcuts[] with appropriate HapDelta[] indels (but no SNPs) applied */
		 int N1, int N2, double *Y1, double *Y2, /* current consensus map pair (includes effect of SNPs in HapSite[]) */
		 double *HapDelta, /* HapDelta[i=0..n] is the indel size of interval Hcuts[i..i+1] : Hcuts1[i..i+1] = Hcuts[i..i+1] + HapDelta[i], Hcuts2[i..i+1] = Hcuts[i..i+1] - HapDelta[i] */
		 int *HapSite,     /* HapSite[i=1..n] is the site haplotype status of Hcuts[i] : Hdel1[i] = !(HapSite[i]&1), Hdel2[i] = !(HapSite[i]&2) */
		 int lc,/* If left end of Y1/Y2 is a linear chromosome end */
		 int rc,/* If right end of Y1/Y2 is a linear chromosome end */
		 int MD, /* number of maps */
		 int *MX, double **X, /* X[m=0..MD-1][j=0..MX[m]+1] : map sites */
		 int **map1, /* map1[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts1[0..n+1] of X[m][j], 
				map1[MD][j=0..n+1] is index in Y1[0..N+1] of Hcuts1[j] */
		 int **map2, /* map2[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts2[0..n+1] of X[m][j], 
				map1[MD][j=0..n+1] is index in Y2[0..N+1] of Hcuts2[j] */
		 int **mapK1, /* mapK1[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts1[0..n+1] of X[m][j] */ 
		 int **mapK2, /* mapK2[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts2[0..n+1] of X[m][j] */ 
                 Csetlimit *limit1,
                 Csetlimit *limit2,
		 int **nmap1, /* nmap1[m=0..MD-1][j=0..MX[m]+1] is new index in Y1[0..N1+1] of X[m][j], 
				 nmap1[MD][j=0..N1+1] is index in Hcuts1[0..n+1] of Y1[j] */
		 int **nmap2, /* nmap2[m=0..MD-1][j=0..MX[m]+1] is new index in Y2[0..N1+1] of X[m][j], 
				 nmap2[MD][j=0..N1+1] is index in Hcuts2[0..n+1] of Y2[j] */
		 int **nmapK1, /* nmapK1[m=0..M-1][j=0..MX[m]+1] will be new K index offset in Y1[0..N+1] of X[m][j]
				 However nmapK1[0] == Lij, mapK1[MX[m]+1] == Rij (-ve if ends are outliers) for alignment with Y1[] */
		 int **nmapK2, /* nmapK2[m=0..M-1][j=0..MX[m]+1] will be new K index offset in Y2[0..N+1] of X[m][j]
				 However nmapK2[0] == Lij, mapK2[MX[m]+1] == Rij (-ve if ends are outliers) for alignment with Y2[] */
		 double *TBmapWT, /* If != 0 : TBmapWT[m] is a the -TB based weight for map m to be applied when summing up the total log(LR+LRbias) value */
		 double *newLPA1,/* per map LP values (return value) for Y1[] */
		 double *newLPA2,/* per map LP values (return value) for Y2[] */
		 double *mapWT1, /* return value of map weights = LR/(LR + LRbias) value for Y1[] */
		 double *mapWT2, /* return value of map weights = LR/(LR + LRbias) value for Y2[] */
		 double *oldLP1, /* If != 0 : previous estimate of per map LP values for Y1[] */
		 double *oldLP2, /* If != 0 : previous estimate of per map LP values for Y2[] */
		 // NOTE : unlike in qprobeval/mprobeval, both oldLP and nmapK can be present : If so oldLP will be forced to 0 when calling qprobeval and only used if rverb
		 double Ymin1, double Ymax1, /* Location range in Y1[] that changed in oldLP1[] was computed : only valid if oldLP1 != 0 */
		 double Ymin2, double Ymax2, /* Location range in Y2[] that changed in oldLP2[] was computed : only valid if oldLP2 != 0 */
		 double *logPV1, /* If != 0 : -log10(Pvalue) of each map for Y1[] */
		 double *logPV2, /* If != 0 : -log10(Pvalue) of each map for Y2[] */
		 int **outlier1,
		 int **outlier2,
		 double *newLPA, /* per map LP values for Y1[] & Y2[] combined as a Haplotype map (return value) */
		 Ccontig *pcontig, /* pointer to complete contig information */
		 int numthreads,
		 int& SNPcnt, int& IndelCnt,
		 int dualmap,  /* If >= 1 : use both map1[] and map2[] for each map and see which provides a better score. Use the better score for each map and return it in newLPA1,newLPA2
				  If >= 2 : Also update map1[m] and map2[m] to correspond to the best choice for map m for ref Y1 and Y2 respectively */
		 int *forcemap = 0 /* If forcemap != 0 : pre-allocated memory forcemap[m=0..MD-1], to be used when dualmap >= 1 to make sure each map is either aligned (or uses oldLP) in all 4 cases */
		 )
{
  if(DEBUG && SETLIMIT_CACHE) assert(HPROBEVAL_SPREAD);

  double wtstart = (VERB>=2) ? wtime() : 0.0;
  double mtstart = (VERB>=2) ? mtime() : 0.0;

  int origrverb = rverb;

  if(rverb){
    printf("hprobeval() called: rverb=%d\n",rverb);
    if(VERB>=2)
      for(int i = 1; i <= n+1; i++)
	if(HapSite[i] || i > n)
	  printf("i=%d:HapSite[i]=%d,Hcuts1[i]=%0.4f,Hcuts2[i]=%0.4f\n",i,HapSite[i],Hcuts1[i],Hcuts2[i]);
    printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
    printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    fflush(stdout);
  }
  //  rverb = 0;// comment out to display verbose qprobeval() if rverb >= 1

  if(DEBUG && (!(Ymin1 <= Ymax1 + 1e-6) || !(Ymin2 <= Ymax2 + 1e-6))){
    printf("hprobeval:Ymin1=%0.6f,Ymax1=%0.6f,Ymin2=%0.6f,Ymax2=%0.6f\n",Ymin1,Ymax1,Ymin2,Ymax2);
    fflush(stdout);
    assert(Ymin1 <= Ymax1 + 1e-6);
    assert(Ymin2 <= Ymax2 + 1e-6);
  }
  if(Ymin1 > Ymax1){
    double tmp = Ymin1;
    Ymin1 = Ymax1;
    Ymax1 = tmp;
  }
  if(Ymin2 > Ymax2){
    double tmp = Ymin2;
    Ymin2 = Ymax2;
    Ymax2 = tmp;
  }

  if(DEBUG) assert(map1 != 0);
  if(DEBUG) assert(map2 != 0);
  if(DEBUG) assert(mapK1 != 0);
  if(DEBUG) assert(mapK2 != 0);
  if(DEBUG) assert(nmap1 != 0);
  if(DEBUG) assert(nmap2 != 0);

  int **map1c, **map2c, **mapK1c, **mapK2c;
  if(HPROBEVAL_SPREAD){/* no need for the following loop */
    map1c = map1;
    map2c = map2;
    mapK1c = mapK1;
    mapK2c = mapK2;
  } else {
    if(HMAP_TMPFIX){
      if(DEBUG){
	assert(map1b != NULL && map2b != NULL && mapK1b != NULL && mapK2b != NULL);
	assert(map1b[MD] == map1[MD]);
	assert(map2b[MD] == map2[MD]);
      }
    
      map1c = map1b;
      map2c = map2b;
      mapK1c = mapK1b;
      mapK2c = mapK2b;
    } else {
      map1c = map1;
      map2c = map2;
      mapK1c = mapK1;
      mapK2c = mapK2;

      if(DEBUG)
	assert(map1b == NULL && map2b == NULL && mapK1b == NULL && mapK2b == NULL);

      map1b = map1;
      map2b = map2;
      mapK1b = mapK1;
      mapK2b = mapK2;
    }

    int block = 1;
    while(block < 16 && MD > numthreads * block)
      block *= 2;

    int LoopCnt = 0;
    #pragma omp parallel num_threads(numthreads) if(!(VERB && (VERB>=3 || rverb)))
    {
      int myLoopCnt = 0;
      #pragma omp for schedule(static,block)
      for(int m = 0; m < MD; m++){
        if(OMP_DEBUG) myLoopCnt++;
        int M = MX[m];

	if(HMAP_TMPFIX){
          memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
	  memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
	  memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
	  memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
        }
      }
      if(OMP_DEBUG && myLoopCnt > 0){
        #pragma omp critical
        {
	  LoopCnt += myLoopCnt;
	}
      }
    }
    if(OMP_DEBUG) assert(LoopCnt == MD);  

    cleanmapH(n,MD,MX,map1b,map2b,mapK1b,mapK2b,HapSite,numthreads);
  } // !HPROBEVAL_SPREAD

  if(VERB>=2){
    double wt = wtime(), mt = mtime();
    printf("HPROBEVAL_SPREAD=%d:time=%0.6f,wall=%0.6f(cum=%0.6f)\n",HPROBEVAL_SPREAD,mt-mtstart,wt-wtstart,wt);
    fflush(stdout);
  }

  if(dualmap && forcemap){
    int init = (oldLP1 && oldLP2) ? -1 : 1;
    for(int m = 0; m < MD; m++)
      forcemap[m] = init; // -1 means unknown (first call to qprobeval will set value to 0 or 1), 0 means force use of oldLP, 1 means force use of alignment
  }

  // NOTE : Below map1c,map2c,mapK1c,mapK2c are used instead of map1,map2,mapK1,mapK2 : they may be pointers to the same memory (if HMAP_TMPFIX==0 or HPROBEVAL_SPREAD)

  score_init(N1,Y1,MD,MX,X);// needed to precompute the correct tables when Y1 != Y2
  if(VERB>=2){
    double wt = wtime(), mt = mtime();
    printf("score_init(Y1):time=%0.6f,wall=%0.6f(cum=%0.6f)\n",mt-mtstart,wt-wtstart,wt);
    fflush(stdout);
  }
  if(VERB>=2 && rverb){
    printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
    printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    fflush(stdout);
  }
  if(VERB && (VERB>=3 || rverb))
    printf("Calling qprobeval1(n=%d,Hcuts1,N1=%d,Ymin1=%0.3f,Ymax1=%0.3f,oldLP1=%p,oldLP1[%d]=%0.6f,...)\n",n,N1,Ymin1,Ymax1,oldLP1,MDEBUG_M,(MDEBUG_M < 0 || !oldLP1) ? -1.0 : oldLP1[MDEBUG_M]);
  double qLP1 = qprobeval(n,Hcuts1,N1,Y1,MD,MX,X,lc,rc,map1c,mapK1c,limit1,nmap1,nmapK1,TBmapWT,newLPA1,mapWT1, /* WAS nmapK1 ? 0 : */ oldLP1, Ymin1,Ymax1,logPV1,outlier1,pcontig,forcemap);
  if(VERB && (VERB>=3 || rverb))
    for(int t = 0; t < 0; t++)
      printf("\t t=%d:newLPA1[t]= %0.8f\n",t,newLPA1[t]);

  if(VERB>=2){
    double wt = wtime(), mt = mtime();
    printf("qprobeval(Y1):time=%0.6f,wall=%0.6f(cum=%0.6f)\n",mt-mtstart,wt-wtstart,wt);
    fflush(stdout);
  }
  if(HFIX >= 2 && HMAP_SWAP && dualmap){
    if(VERB && (VERB>=3 || rverb))
      printf("Calling qprobeval1(n=%d,Hcuts1,N1=%d,Ymin1=%0.3f,Ymax1=%0.3f,oldLP1[%d]=%0.6f,...) with map2\n",n,N1,Ymin1,Ymax1,MDEBUG_M,(MDEBUG_M < 0 || !oldLP1) ? -1.0 : oldLP1[MDEBUG_M]);

    int *tmp = map2c[MD];
    map2c[MD] = map1c[MD];/* map2c[MD] must refer to Y1 & Hcuts1 */
    (void) qprobeval(n,Hcuts1,N1,Y1,MD,MX,X,lc,rc,map2c,mapK2c,limit2,nmap1,0,TBmapWT,tmpLPA1,mapWT1,oldLP1/* WAS 0 */,Ymin1,Ymax1,logPV1,outlier1,pcontig,forcemap);
    map2c[MD] = tmp;
  }

  score_init(N2,Y2,MD,MX,X);// needed to precompute the correct tables when Y1 != Y2
  if(VERB>=2){
    double wt = wtime(), mt = mtime();
    printf("score_init(Y2):time=%0.6f,wall=%0.6f(cum=%0.6f)\n",mt-mtstart,wt-wtstart,wt);
    fflush(stdout);
  }
  if(VERB/* HERE >=2 */ && rverb){
    printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
    printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    fflush(stdout);
  }
  if(VERB && (VERB>=3 || rverb))
    printf("Calling qprobeval2(n=%d,Hcuts2,N2=%d,Ymin2=%0.3f,Ymax2=%0.3f,oldLP2=%p,oldLP2[%d]=%0.6f,...)\n",n,N2,Ymin2,Ymax2,oldLP2,MDEBUG_M,(MDEBUG_M < 0 || !oldLP2) ? -1.0 : oldLP2[MDEBUG_M]);
  double qLP2 = qprobeval(n,Hcuts2,N2,Y2,MD,MX,X,lc,rc,map2c,mapK2c,limit2,nmap2,nmapK2,TBmapWT,newLPA2,mapWT2,/* WAS nmapK2 ? 0 : */oldLP2,Ymin2,Ymax2,logPV2,outlier2,pcontig,forcemap);
  if(VERB && (VERB>=3 || rverb))
    for(int t = 0; t < 0; t++)
      printf("\t t=%d:newLPA2[t]= %0.8f\n",t,newLPA1[t]);
  if(VERB>=2){
    double wt = wtime(), mt = mtime();
    printf("qprobeval(Y2):time=%0.6f,wall=%0.6f(cum=%0.6f)\n",mt-mtstart,wt-wtstart,wt);
    fflush(stdout);
  }

  if(HFIX >= 2 && HMAP_SWAP && dualmap){
    if(VERB && (VERB>=3 || rverb))
      printf("Calling qprobeval2(n=%d,Hcuts2,N2=%d,Ymin2=%0.3f,Ymax2=%0.3f,oldLP2[%d]=%0.6f,...) with map1\n",n,N2,Ymin2,Ymax2,MDEBUG_M,(MDEBUG_M < 0 || !oldLP2) ? -1.0 : oldLP2[MDEBUG_M]);

    int *tmp = map1c[MD];
    map1c[MD] = map2c[MD];/* map1c[MD] must refer to Y2 & Hcuts2 */
    (void) qprobeval(n,Hcuts2,N2,Y2,MD,MX,X,lc,rc,map1c,mapK1c,limit1,nmap2,0,TBmapWT,tmpLPA2,mapWT2,oldLP2/* WAS 0 */,Ymin2,Ymax2,logPV2,outlier2,pcontig,forcemap);
    map1c[MD] = tmp;

    if(dualmap >= 2){/* switch map1c[m],map2c[m] based on which mapping worked best for molecule m */
      int block = 1;
      while(block < 16 && MD > numthreads * block)
	block *= 2;

      #pragma omp parallel for schedule(static,block) num_threads(numthreads)
      for(int m = 0; m < MD; m++){
	int M = MX[m];

	int tmp1[M+2];
	int tmp2[M+2];
	int tmpK1[M+2];
	int tmpK2[M+2];

	memcpy(tmp1, map1c[m], (M+2) * sizeof(int));
	memcpy(tmp2, map2c[m], (M+2) * sizeof(int));
	memcpy(tmpK1, mapK1c[m], (M+2) * sizeof(int));
	memcpy(tmpK2, mapK2c[m], (M+2) * sizeof(int));

	if(tmpLPA1[m] > newLPA1[m]){
	  memcpy(map1c[m], tmp2, (M+2) * sizeof(int));
	  memcpy(mapK1c[m], tmpK2, (M+2) * sizeof(int));
	}
	if(tmpLPA2[m] > newLPA2[m]){
	  memcpy(map2c[m], tmp1, (M+2) * sizeof(int));
	  memcpy(mapK2c[m], tmpK1, (M+2) * sizeof(int));
	}
      }

      /* call qprobeval() again to update nmap1[],nmap2[] (if these are being updated) */
      if(nmapK1){
	score_init(N1,Y1,MD,MX,X);// needed to precompute the correct tables when Y1 != Y2
	if(VERB && (VERB>=3 || rverb))
	  printf("Calling qprobeval1(n=%d,Hcuts1,N1=%d,...) with updated map1\n",n,N1);
	(void)qprobeval(n,Hcuts1,N1,Y1,MD,MX,X,lc,rc,map1c,mapK1c,limit1,nmap1,nmapK1,TBmapWT,newLPA1,mapWT1,nmapK1 ? 0 : oldLP1,Ymin1,Ymax1,logPV1,outlier1,pcontig);
	if(DEBUG>=2)
	  for(int m = 0; m < MD; m++)
	    assert(newLPA1[m] >= tmpLPA1[m]);
      }
      if(nmapK2){
	score_init(N2,Y2,MD,MX,X);// needed to precompute the correct tables when Y1 != Y2
	if(VERB && (VERB>=3 || rverb))
	  printf("Calling qprobeval2(n=%d,Hcuts2,N2=%d,...)\n",n,N2);
	(void) qprobeval(n,Hcuts2,N2,Y2,MD,MX,X,lc,rc,map2c,mapK2c,limit2,nmap2,nmapK2,TBmapWT,newLPA2,mapWT2,nmapK2 ? 0 : oldLP2,Ymin2,Ymax2,logPV2,outlier2,pcontig);
	if(DEBUG>=2)
	  for(int m = 0; m < MD; m++)
	    assert(newLPA2[m] >= tmpLPA2[m]);
      }
    }
    for(int m = 0; m < MD; m++){
      newLPA1[m] = max(newLPA1[m],tmpLPA1[m]);
      newLPA2[m] = max(newLPA2[m],tmpLPA2[m]);
    }
  }

  rverb = origrverb;
  //  rverb = 0;

  if(VERB && (VERB>=2 || rverb)){
    printf("qLP1=%0.6f,qLP2=%0.6f:MD=%d,oldLP1=%p,oldLP2=%p\n",qLP1,qLP2,MD,oldLP1,oldLP2);
    fflush(stdout);
  }

  double logH = -log(2.0);
  double LP = 0.0;
  int LoopCnt = 0;

  if(VERB && (VERB>=3 || rverb)){
    double myLP = 0.0;
    double oldLP = 0.0;// used for debugging only

    for(int m = 0; m < MD; m++){
      double nLP1 = newLPA1[m];
      double nLP2 = newLPA2[m];
      newLPA[m] = HapLP(nLP1,nLP2,logH);
      myLP += newLPA[m] * TBmapWT[m];

      if(1){// debugging code
	int M = MX[m];
	int L1 = 1, R1 = M;
	int L2 = 1, R2 = M;
	while(L1 < M && map1c[m][L1] < 0)
	  L1++;
	while(R1 > 1 && map1c[m][R1] < 0)
	  R1--;
	while(L2 < M && map2c[m][L2] < 0)
	  L2++;
	while(R2 > 1 && map2c[m][R2] < 0)
	  R2--;
	
	if(oldLP1 && oldLP2){
	  double oLP1 = oldLP1[m], oLP2 = oldLP2[m];
	  double oLPAm = HapLP(oLP1,oLP2,logH);
	  oldLP += oLPAm * TBmapWT[m];
	  if(/* fabs(newLPA[m] - oLPAm) > 0.01 || */ 1){
	    if(L1 <= R1 && L2 <= R2)
	      printf("m=%d/%d,id=%lld:LP1=%0.8f, LP2=%0.8f, LP12=%0.8f, TBmapWT=%0.6f: sumWT=%0.6f (orig:LP1=%0.8f,LP2=%0.8f,LP12=%0.8f,sum=%0.8f:change=%0.8f,cumWTchange=%0.8f) Hcuts1[]=%0.3f..%0.3f,Hcuts2[]=%0.3f..%0.3f,Len=%0.3f\n",
    m,MD,gmap[pcontig->contig[m].mapid]->id,nLP1,nLP2,newLPA[m], TBmapWT[m], myLP, oLP1, oLP2, oLPAm, oldLP, (newLPA[m] - oLPAm), myLP - oldLP, Hcuts1[map1c[m][L1]],Hcuts1[map1c[m][R1]],Hcuts2[map2c[m][L2]],Hcuts2[map2c[m][R2]], X[m][M+1]);
	    else
	      printf("m=%d/%d,id=%lld:LP1=%0.8f, LP2=%0.8f, TBmapWT=%0.6f: LP=%0.8f, sum=%0.6f (orig:LP1=%0.8f,LP2=%0.8f,LP=%0.8f,sum=%0.8f:change=%0.8f,cumchange=%0.8f),Len=%0.3f\n",
		     m,MD,gmap[pcontig->contig[m].mapid]->id,nLP1,nLP2,TBmapWT[m], newLPA[m] * TBmapWT[m], myLP, oLP1, oLP2, oLPAm, oldLP, (newLPA[m] - oLPAm)*TBmapWT[m], myLP - oldLP,X[m][M+1]);
	  }
	} else
	  printf("m=%d/%d,id=%lld:LP1=%0.8f, LP2=%0.8f, TBmapWT=%0.6f: LP=%0.8f,sum=%0.6f\n",
		 m,MD,gmap[pcontig->contig[m].mapid]->id,nLP1,nLP2,TBmapWT[m], newLPA[m] * TBmapWT[m], myLP);
      }
    } // omp for m = 0; m < MD; m++
    
    LP = myLP;

  } else {// !(VERB && (VERB>=3 || rverb))
    double LParray[numthreads];
    for(int tid = 0; tid < numthreads; tid++)
      LParray[tid] = 0.0;

    #pragma omp parallel num_threads(numthreads)
    {
      int myLoopCnt = 0;
      int tid = 0;
#ifdef _OPENMP
      tid = omp_get_thread_num ();
#endif
      double myLP = 0.0;

      //      #pragma omp for simd reduction(+:myLP) // HERE HERE : TRY to see if this is faster
      #pragma omp for schedule(static,8)
      for(int m = 0; m < MD; m++){
	if(OMP_DEBUG) myLoopCnt++;
	double nLP1 = newLPA1[m];
	double nLP2 = newLPA2[m];
	newLPA[m] = HapLP(nLP1,nLP2,logH);
	myLP += newLPA[m] * TBmapWT[m];
      } // omp for m = 0; m < MD; m++
    
      LParray[tid] = myLP;
      if(OMP_DEBUG && myLoopCnt > 0){
        #pragma omp atomic
	LoopCnt += myLoopCnt;
      }
    } // omp parallel

    if(OMP_DEBUG) assert(LoopCnt == MD);
    qsort(LParray, numthreads, sizeof(double), (intcmp *)doubleInc);  
    for(int tid = 0; tid < numthreads; tid++)
      LP += LParray[tid];
  }

  double origLP = LP;
  double logHapSitePvalue = log(max(HapSitePvalue,1e-300));/* this value is -ve */
  double logHapIndelPvalue = log(max(HapIndelPvalue,1e-300));
  double HapSitePen[4] = {0.0, logHapSitePvalue - 0.5*SITE_PEN, logHapSitePvalue - 0.5*SITE_PEN, -SITE_PEN};

  if(VERB>=2){
    double wt = wtime(), mt = mtime();
    printf("origLP= %0.8f: time=%0.6f,wall=%0.6f(cum=%0.6f)\n",origLP, mt-mtstart,wt-wtstart,wt);
  }

  rverb = origrverb;

  /* compute number of SNPs and Indels */
  SNPcnt = IndelCnt = 0;
  int HapSiteSNP[4] = {0,1,1,0};
  int HapCnt[4] = {0,0,0,0};

  /* Handle i = 0 (left end) outside of parallel loop */
  // i = 0;
  // h = /* HapSite[i] */ 0;
  //  HapCnt[0]++;
  if(1){
    double HapDeltaMerge = HapDelta[0];
    int t = 0;
    for(; ++t <= n; ){
      if(HapSite[t] == 3)
	break;
      HapDeltaMerge += HapDelta[t];
    }
    if(VERB>=3 && rverb && fabs(HapDeltaMerge) >= MIN_INDEL_SIZE){
      printf("hprobeval:Indel at Hcuts[%d..%d]:HapSite[]=%d,%d, HapDeltaMerged=%0.4f (HapDelta[%d]=%0.4f)\n",0,t,HapSite[0],HapSite[t],HapDeltaMerge,0,HapDelta[0]);
      fflush(stdout);
    }
    IndelCnt += (fabs(HapDeltaMerge) >= MIN_INDEL_SIZE) ? 1 : 0;
  } 

  if(OMP_DEBUG) LoopCnt = 0;

  #pragma omp parallel num_threads(numthreads) // if(!rverb)
  {
    int myLoopCnt = 0;
    int myIndelCnt = 0;
    int myHapCnt[4] = {0,0,0,0};

    #pragma omp for schedule(static,16)
    for(int i = 1; i <= n; i++){
      if(OMP_DEBUG) myLoopCnt++;
      int h = HapSite[i];
      if(!h) continue;// NOTE : myHapCnt[0] is not used

      myHapCnt[h]++;
      
      if(h == 3){
	double HapDeltaMerge = HapDelta[i];
	int t = i;
	for(; ++t <= n; ){
	  if(HapSite[t] == 3)
	    break;
	  HapDeltaMerge += HapDelta[t];
	}
	if(VERB>=3 && rverb && fabs(HapDeltaMerge) >= MIN_INDEL_SIZE){
          #pragma omp critical
	  {
	    printf("hprobeval:Indel at Hcuts[%d..%d]:HapSite[]=%d,%d, HapDeltaMerged=%0.4f (HapDelta[%d]=%0.4f)\n",i,t,HapSite[i],HapSite[t],HapDeltaMerge,i,HapDelta[i]);
	    fflush(stdout);
	  }
        }
        myIndelCnt += (fabs(HapDeltaMerge) >= MIN_INDEL_SIZE) ? 1 : 0;
	//	  if(DEBUG && fabs(HapDeltaMerge) >= MIN_INDEL_SIZE && 1 <= i && t <= n) assert(HapDelta[i] != 0.0);
      }
    }// omp for i=0 .. n+1

    #pragma omp critical
    {
      if(OMP_DEBUG) LoopCnt += myLoopCnt;
      IndelCnt += myIndelCnt;
      for(int h = 1; h < 4; h++)// NOTE : no need to compute HapCnt[0] since HapSiteSNP[0] and HapSitePen[0] are both 0 */
	HapCnt[h] += myHapCnt[h];
    }
  }
  if(OMP_DEBUG && LoopCnt != n){
    printf("LoopCnt = %d, n = %d, numthreads=%d\n", LoopCnt, n, numthreads);
    fflush(stdout);
    assert(LoopCnt == n);
  }

  for(int h = 1; h < 4; h++){ // NOTE : skipping h==0 since HapSiteSNP[0] and HapSitePen[0] are both 0 */
    LP += HapCnt[h] * HapSitePen[h];
    SNPcnt += HapCnt[h] * HapSiteSNP[h];
  }
  LP += IndelCnt * logHapIndelPvalue;

  if(VERB && (VERB>=2 || rverb)){
    double wt = wtime(),mt = mtime();
    printf("  N1=%d,N2=%d, SITE_PEN=%0.6f, log(HapSitePvalue)=%0.6f, log(HapIndelPvalue)=%0.6f, SNPs=%d, indels=%d: Final LP = %0.6f -> %0.6f: time=%0.6f,wall=%0.6f(cum=%0.6f)\n",
      N1,N2, SITE_PEN, logHapSitePvalue, logHapIndelPvalue, SNPcnt, IndelCnt, origLP, LP, mt-mtstart,wt-wtstart,wt);
    fflush(stdout);
  }
  if(VERB/* HERE >=2 */ && rverb){
    printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
    printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    fflush(stdout);
  }

  if(!HMAP_TMPFIX)
    map1b = map2b = mapK1b = mapK2b = NULL;

  if(VERB>=2){
    double wt = wtime(), mt = mtime();
    printf("hprobeval:time=%0.6f,wall=%0.6f(cum=%0.6f)\n",mt-mtstart,wt-wtstart,wt);
    fflush(stdout);
  }

#undef VERB
#define VERB 1 

  return LP;
}

/* Generate Haplotype Consensus Pair from Non-Haplotype consensus map and list of Haplotype SVs
   If error != 0 : returns 0 on success, 1 if resulting labels are too close or out of order OR no labels are present in either Allele.
   If error == 0 : returns 0 on success and exits with an error message if resulting labels are too close or out of order */

int hsetmap(int n, double *Hcuts, /* complete Non-Haplotype consensus map (all potential sites included) */
	    double *HapDelta, /* HapDelta[i=0..n] is the indel size of interval Hcuts[i..i+1] : Hcuts1[i..i+1] = Hcuts[i..i+1] + HapDelta[i], Hcuts2[i..i+1] = Hcuts[i..i+1] - HapDelta[i] */
	    int *HapSite,     /* HapSite[i=1..n] is the site haplotype status of Hcuts[i] : Hdel1[i] = !(HapSite[i]&1), Hdel2[i] = !(HapSite[i]&2) */
	    double *Delta, /* Delta[i=0..n] is the delta size of interval hcuts[i..i+1] (non-Hapotype) (If Delta==0 : assume all values are 0) */
	    double *Hcuts1,double *Hcuts2, int *Hdel1, int *Hdel2, /* Haplotype consensus map specification (return value) */
	    int &N1, int &N2, double *Y1, double *Y2, /* Actual Haplotype consensus map (return value) */
	    int *map1M, int *map2M, /* map1M[j=0..n+1] will be index of Hcuts1[j] in Y1[0..N1+1] (or -1 if not aligned) (return value) */
	    int *nmap1M, int *nmap2M, /* nmap1M[j=0..N1+1] will be index of site Y1[j] in Hcuts1[0..n+1] (return value) */
	    int error, /* If error != 0, return 1 on error, otherwise exit with error message */
	    double *spreadHapDelta,/* If != NULL : space to store spread version of HapDelta[] */
	    double *spreadDelta    /* If != NULL : space to store spread version of HapDelta[] */
      )
{
  if(error)
    N1 = N2 = -1;

  if(HPROBEVAL_SPREAD && spreadHapDelta && spreadDelta){
    /* temporarily spread out HapDelta and Delta[] values proportionally across subintervals of Hcuts[] to better match what mprobeval() sees */
    memcpy(spreadHapDelta,HapDelta,(n+2)*sizeof(double));
    memcpy(spreadDelta,Delta,(n+2)*sizeof(double));

    for(int i = 0; i <= n; i++){

      if(i && !HapSite[i])
	continue;
      int R = i+1;
      while(R <= n && !HapSite[R])
	R++;
      //      if(R > n)
      //	break;
      if(DEBUG && !(Hcuts[R] >= Hcuts[i] && (!(HapSite[R] & HapSite[i]) || Hcuts[R] > Hcuts[i]))){
        if(error)
          return 1;
	printf("WARNING:hsetmap:i=%d,R=%d,HapSite[i,R]=%d,%d,Hcuts[i,R]=%0.8f,%0.8f\n",i,R,HapSite[i],HapSite[R],Hcuts[i],Hcuts[R]);
	fflush(stdout);
	assert(Hcuts[R] >= Hcuts[i] && (!(HapSite[R] & HapSite[i]) || Hcuts[R] > Hcuts[i]));
      }
      if(DEBUG && !isfinite(spreadHapDelta[i])){
	printf("hsetmap:i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
	       i,n,spreadHapDelta[i],spreadDelta[i],HapSite[i],R,HapSite[R]);
	fflush(stdout);
	assert(isfinite(spreadHapDelta[i]));
      }

      if(DEBUG && (!(Hcuts[R]-Hcuts[i] + spreadDelta[i] - fabs(spreadHapDelta[i]) >= -1e-8)) ){
	if(error)
	  return 1;
	int RR = R;
	while(RR <= n && HapSite[RR] < 3)
	  RR++;
	int LL = i;
	while(LL > 0 && HapSite[LL] < 3)
	  LL--;

	printf("WARNING:hsetmap:LL=%d,i=%d,R=%d,RR=%d,HapSite[LL,i,R,RR]=%d,%d,%d,%d,Hcuts[LL,i,R,RR]=%0.8f,%0.8f,%0.8f,%0.8f, spreadDelta[i]= %0.8f, spreadHapDelta[i]= %0.8f\n",
	       LL,i,R,RR,HapSite[LL],HapSite[i],HapSite[R],HapSite[RR],Hcuts[LL],Hcuts[i],Hcuts[R],Hcuts[RR], spreadDelta[i], spreadHapDelta[i]);
	fflush(stdout);

	double DeltaSum = 0.0, HapDeltaSum = 0.0, spreadDeltaSum = 0.0, spreadHapDeltaSum = 0.0;
	for(int t = LL; t < RR; t++){
	  spreadDeltaSum += spreadDelta[t];
	  spreadHapDeltaSum += spreadHapDelta[t];
	  DeltaSum += Delta[t];
	  HapDeltaSum += HapDelta[t];
	}

	printf("\t Hcuts[LL..RR]= %0.8f, spreadDelta[LL..RR]= %0.8f, spreadHapDelta[LL..RR]= %0.8f, Delta[LL..RR]= %0.8f, HapDelta[LL..RR]= %0.8f: wtime= %0.6f\n",
	       Hcuts[RR] - Hcuts[LL], spreadDeltaSum, spreadHapDeltaSum, DeltaSum, HapDeltaSum,wtime());

	if(Hcuts[RR] - Hcuts[LL]){
	  for(int t = LL; t < RR; t++)
	    printf("\t t=%d: Hcuts[t..t+1]= %0.8f,HapSite[t]=%d,Delta[t]= %0.8f, spreadDelta[t]= %0.8f, HapDelta[t]= %0.8f, spreadHapDelta[t]= %0.8f (pro-rata %0.8f & %0.8f)\n",
		   t,Hcuts[t+1]-Hcuts[t], HapSite[t],Delta[t],spreadDelta[t],HapDelta[t],spreadHapDelta[t], 
		   (Hcuts[t+1]-Hcuts[t])*DeltaSum/(Hcuts[RR]-Hcuts[LL]), (Hcuts[t+1]-Hcuts[t])*HapDeltaSum/(Hcuts[RR]-Hcuts[LL]));
	}

	fflush(stdout);
	assert(Hcuts[R]-Hcuts[i] + spreadDelta[i] - fabs(spreadHapDelta[i]) >= -1e-7);
      }

      if(spreadHapDelta[i] && R > i+1){
        if(DEBUG && !(HapSite[i] || HapSite[R] || (i==0 && R==n+1))){
	  printf("hsetmap:i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
		 i,n,spreadHapDelta[i],spreadDelta[i],HapSite[i],R,HapSite[R]);
	  fflush(stdout);
	  assert(HapSite[i] || HapSite[R] || (i==0 && R==n+1));
	}
	if(DEBUG>=2)
	  for(int t = i+1; t < R; t++){
	    if(!(spreadHapDelta[t] == 0.0)){
	      printf("hsetmap:HapDelta[L]=%0.4f,HapDelta[t=%d]=%0.4f,spreadHapDelta[t]=%0.4f,Delta[t]=%0.6e,HapSite[t]=%d,L=%d,R=%d,HapSite[L,R]=%d,%d,n=%d\n",
		     HapDelta[i],t,HapDelta[t],spreadHapDelta[t],Delta[t],HapSite[t],i,R,HapSite[i],HapSite[R],n);
	      fflush(stdout);
	      assert(spreadHapDelta[t] == HapDelta[t]);
	      assert(spreadHapDelta[t] == 0.0);
            }
	    if(!(spreadDelta[t] == 0.0)){
	      printf("hsetmap:Delta[L]=%0.4f,Delta[t=%d]=%0.4f,spreadDelta[t]=%0.4f,HapDelta[t]=%0.6e,HapSite[t]=%d,L=%d,R=%d,HapSite[L,R]=%d,%d,n=%d\n",
		     Delta[i],t,Delta[t],spreadDelta[t],HapDelta[t],HapSite[t],i,R,HapSite[i],HapSite[R],n);
	      fflush(stdout);
	      assert(spreadDelta[t] == Delta[t]);
	      assert(spreadDelta[t] == 0.0);
            }
	  }
	if(Hcuts[R] > Hcuts[i]){
	  double scale = spreadHapDelta[i] / (Hcuts[R]-Hcuts[i]);
	  if(DEBUG) assert(isfinite(scale));
	  for(int t = i; t < R; t++){
	    double origHapDelta = spreadHapDelta[t];
	    spreadHapDelta[t] = scale * (Hcuts[t+1] - Hcuts[t]);
	    if(DEBUG>=2 && !(isfinite(spreadHapDelta[t]))){
	      printf("hsetmap:i=%d,t=%d,R=%d:Hcuts[i]=%0.10f,Hcuts[t]=%0.10f,Hcuts[R]=%0.10f,scale=%0.10e,spreadHapDelta[t]= %0.10e -> %0.10e\n",
		     i,t,R,Hcuts[i],Hcuts[t],Hcuts[R],scale,origHapDelta, spreadHapDelta[t]);
	      fflush(stdout);
	      assert(isfinite(spreadHapDelta[t]));
	    }
	  }
	} else {/* Hcuts[R] == Hcuts[i] */
	  double scale = spreadHapDelta[i] / (R - i);
	  if(DEBUG) assert(isfinite(scale));
	  for(int t = i; t < R; t++)
	    spreadHapDelta[t] = scale;
	}
      }

      if(DEBUG && !isfinite(spreadDelta[i])){
	printf("hsetmap:i=%d,n=%d,spreadHapDelta[i]=%0.4f,spreadDelta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
	       i,n,spreadHapDelta[i],spreadDelta[i],HapSite[i],R,HapSite[R]);
	fflush(stdout);
	assert(isfinite(spreadDelta[i]));
      }
      if(spreadDelta[i] && R > i+1){
        if(DEBUG && !(HapSite[i] || HapSite[R] || (i==0 && R==n+1))){
	  printf("hsetmap:i=%d,n=%d,spreadHapDelta[i]=%0.6f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
		 i,n,spreadHapDelta[i],spreadDelta[i],HapSite[i],R,HapSite[R]);
	  fflush(stdout);
	  assert(HapSite[i] || HapSite[R] || (i==0 && R==n+1));
	}
	if(DEBUG>=2)
	  for(int t = i+1; t < R; t++)
	    if(!(spreadDelta[t] == 0.0)){
	      printf("hsetmap:Delta[L]=%0.4f,spreadHapDelta[t=%d]=%0.4f,spreadDelta[t]=%0.4e,Delta[t]=%0.4f,HapSite[t]=%d,L=%d,R=%d,HapSite[L,R]=%d,%d,n=%d\n",
		     Delta[i],t,spreadHapDelta[t],spreadDelta[t],Delta[t],HapSite[t],i,R,HapSite[i],HapSite[R], n);
	      fflush(stdout);
	      assert(spreadDelta[t] == Delta[t]);
	      assert(spreadDelta[t] == 0.0);
	    }
	if(Hcuts[R] > Hcuts[i]){
	  double scale = spreadDelta[i] / (Hcuts[R]-Hcuts[i]);
	  if(DEBUG) assert(isfinite(scale));
	  for(int t = i; t < R; t++){
	    spreadDelta[t] = scale * (Hcuts[t+1] - Hcuts[t]);
	    if(DEBUG>=2) assert(isfinite(spreadDelta[t]));
	  }
	} else {/* Hcuts[R] == Hcuts[i] */
	  double scale = spreadDelta[i] / (R - i);
	  if(DEBUG) assert(isfinite(scale));
	  for(int t = i; t < R; t++)
	    spreadDelta[t] = scale;
	}
      }

      i = R-1;
    }

    HapDelta = spreadHapDelta;
    Delta = spreadDelta;
  }

  Hcuts1[0] = Hcuts2[0] = 0.0;
  if(Delta){
    int L = 0;/* last site with HapSite[i] != 0 */
    if(VERB && rverb){
      printf("hsetmap:n=%d,Hcuts[n+1]=%0.3f:\n",n,Hcuts[n+1]);
      fflush(stdout);
    }
    for(int i = 0; i <= n; i++){
      double Hdelta = HapDelta[i];
      double frag = Hcuts[i+1] - Hcuts[i] + Delta[i];
      Hcuts1[i+1] = Hcuts1[i] + frag + Hdelta;
      Hcuts2[i+1] = Hcuts2[i] + frag - Hdelta;
      if(VERB && rverb && HapDelta[i] && !HapSite[i]){
	printf("i=%d:HapDelta[i]=%0.3f,Delta[i]=%0.3f,HapSite[i]=%d\n",i,HapDelta[i],Delta[i],HapSite[i]);
	fflush(stdout);
      }
      if(DEBUG>=2 && !(isfinite(Hcuts1[i+1]) && isfinite(Hcuts2[i+1]))){
	int R = min(n+1,i+2);
	while(R <= n && !HapSite[R])
	  R++;
	printf("WARNING:hsetmap:i=%d,L=%d,R=%d:HapSite[L,i,i+1,R]=%d,%d,%d,%d,Hcuts[L,i,i+1,R]=%0.3f,%0.3f,%0.3f,%0.3f,minKB=%0.3f,Delta[i]=%0.3f,frag=%0.3f:\n",
	       i,L,R,HapSite[L],HapSite[i],HapSite[i+1],HapSite[R],Hcuts[L],Hcuts[i],Hcuts[i+1],Hcuts[R],minKB,Delta[i],frag);
	for(int t = L; t <= i+1 && t <= n; t++)
	  printf("\t t=%d:HapDelta[t]=%0.3f,Delta[t]=%0.3f,Hcuts[t]=%0.3f,Hcuts1[t]=%0.3f,Hcuts2[t]=%0.3f,HapSite[t]=%d\n",
		 t,HapDelta[t],Delta[t],Hcuts[t],Hcuts1[t],Hcuts2[t],HapSite[t]);
	
	printf("  i=%d,Hcuts1[i+1]=%0.3f,Hcuts2[i+1]=%0.3f\n",i,Hcuts1[i+1],Hcuts2[i+1]);
	fflush(stdout);
	assert(isfinite(Hcuts1[i+1]) && isfinite(Hcuts2[i+1]));
      }
      if(HapSite[i+1]){
	if((((HapSite[L] & 1) && (HapSite[i+1] & 1))) && !(Hcuts1[i+1] >= Hcuts1[L] + (L ? max(0.0,minKB - 1e-5) : 0.0))){
          if(!error || VERB>=2){
	    int R = min(n+1,i+2);
	    while(R <= n && !HapSite[R])
	      R++;
	    printf("WARNING: hsetmap:i=%d,L=%d,R=%d,n=%d:HapSite[L]=%d,HapSite[i]=%d,R=%d,HapSite[R]=%d,Hcuts[L]=%0.6f,Hcuts[i]=%0.6f,Hcuts[R]=%0.6f,minKB=%0.6f:\n",
		   i+1,L,R,n,HapSite[L],HapSite[i+1],R,HapSite[R],Hcuts[L],Hcuts[i+1],Hcuts[R],minKB);
	    for(int t = L; t <= i+1 && t <= n; t++)
	      printf("\t t=%d:HapDelta[t]=%0.6f,Delta[t]=%0.6f,Hcuts[t]=%0.6f,Hcuts1[t]=%0.6f,Hcuts2[t]=%0.6f,HapSite[t]=%d\n",
		     t,HapDelta[t],Delta[t],Hcuts[t],Hcuts1[t],Hcuts2[t],HapSite[t]);

	    printf("\t t=%d:HapSite[t]=%d,Hcuts[t]=%0.6f,Hcuts1[t]=%0.6f,Hcuts2[t]=%0.6f\n",i+1,HapSite[i+1],Hcuts[i+1],Hcuts1[i+1],Hcuts2[i+1]);

	    printf("  Hcuts1[L]=%0.8f,Hcuts1[i+1]=%0.8f,minKB=%0.8f,resKB=%0.8f\n",Hcuts1[L],Hcuts1[i+1],minKB,resKB);
	    fflush(stdout);
	  }

          if(error)
	    return 1;
	  assert(Hcuts1[i+1] >= Hcuts1[L] + (L ? max(0.0,minKB - 1e-5) : 0.0));
	}
	if((HapSite[L] & 2) && (HapSite[i+1] & 2) && !(Hcuts2[i+1] >= Hcuts2[L] + (L ? max(0.0,minKB - 1e-5) : 0.0))){
          if(!error || VERB>=2){
	    int R = min(n+1,i+2);
	    while(R <= n && !HapSite[R])
	      R++;
	    printf("WARNING:hsetmap:i=%d,L=%d,R=%d:HapSite[L]=%d,HapSite[i]=%d,Hcuts[L]=%0.4f,Hcuts[i]=%0.4f,Hcuts[R]=%0.4f,minKB=%0.6f:\n",
		   i+1,L,R,HapSite[L],HapSite[i+1],Hcuts[L],Hcuts[i+1],Hcuts[R],minKB);
	    for(int t = L; t <= i+1 && t <= n; t++)
	      printf("\t t=%d:HapDelta[t]=%0.4f,Delta[t]=%0.4f,Hcuts[t]=%0.4f,Hcuts1[t]=%0.4f,Hcuts2[t]=%0.4f,HapSite[t]=%d\n",
		     t,HapDelta[t],Delta[t],Hcuts[t],Hcuts1[t],Hcuts2[t],HapSite[t]);
	    
	    printf("  i=%d,L=%d,Hcuts2[L]=%0.6f,Hcuts2[i+1]=%0.6f,minKB=%0.6f(error=%d)\n",i,L,Hcuts2[L],Hcuts2[i+1],minKB,error);
	    fflush(stdout);
	  }

          if(error)
	    return 1;
	  assert(Hcuts2[i+1] >= Hcuts2[L] + (L ? max(0.0,minKB - 1e-5) : 0.0));
	}
	if(VERB && (VERB>=3 || rverb)){
	  int R = min(n+1,i+2);
	  while(R <= n && !HapSite[R])
	    R++;
	  printf("i=%d:L=%d,R=%d,n=%d:HapSite[L,i,R]=%d,%d,%d,Hcuts[L,i,R]=%0.3f,%0.3f,%0.3f,HapDelta[L,i]=%0.3f,%0.3f,Delta[L,i]=%0.3f,%0.3f,Hcuts1[L,i]=%0.3f,%0.3f,Hcuts2[L,i]=%0.3f,%0.3f\n",
		 i+1,L,R,n,HapSite[L],HapSite[i+1],HapSite[R],Hcuts[L],Hcuts[i+1],Hcuts[R],HapDelta[L],HapDelta[i+1],Delta[L],Delta[i+1],Hcuts1[L],Hcuts1[i+1],Hcuts2[L],Hcuts2[i+1]);
	  fflush(stdout);
	}

	L = i+1;
      }
    }
  } else {/* assume all Delta[] values are 0 */
    int L = 0;/* last site with HapSite[i] != 0 */
    for(int i = 0; i <= n; i++){
      double Hdelta = HapDelta[i];
      double frag = Hcuts[i+1] - Hcuts[i];
      Hcuts1[i+1] = Hcuts1[i] + frag + Hdelta;
      Hcuts2[i+1] = Hcuts2[i] + frag - Hdelta;
      if(DEBUG && HapSite[i+1]){
        if((VERB && rverb) || (VERB>=2 && error && (((((HapSite[L] & 1) && (HapSite[i+1] & 1))) && !(Hcuts1[i+1] >= Hcuts1[L] + (L ? minKB - 1e-5 : 0.0))) ||
						    ((((HapSite[L] & 2) && (HapSite[i+1] & 2))) && !(Hcuts2[i+1] >= Hcuts2[L] + (L ? minKB - 1e-5 : 0.0)))))){
	  int R = i+2;
	  while(R <= n && !HapSite[R])
	    R++;
	  printf("WARNING:hsetmap:i=%d:L=%d,R=%d,n=%d:HapSite[L,i,R]=%d,%d,%d,Hcuts[L,i,R]=%0.3f,%0.3f,%0.3f,HapDelta[L,i]=%0.3f,%0.3f,Hcuts1[L,i]=%0.3f,%0.3f,Hcuts2[L,i]=%0.3f,%0.3f\n",
		 i+1,L,R,n,HapSite[L],HapSite[i+1],HapSite[R],Hcuts[L],Hcuts[i+1],Hcuts[R],HapDelta[L],HapDelta[i+1],Hcuts1[L],Hcuts1[i+1],Hcuts2[L],Hcuts2[i+1]);
	  fflush(stdout);
	}
	if((((HapSite[L] & 1) && (HapSite[i+1] & 1))) && !(Hcuts1[i+1] >= Hcuts1[L] + (L ? minKB - 1e-5 : 0.0))){
          if(error)
	    return 1;
          assert(Hcuts1[i+1] >= Hcuts1[L] + (L ? minKB - 1e-5 : 0.0));
        }
	if((((HapSite[L] & 2) && (HapSite[i+1] & 2))) && !(Hcuts2[i+1] >= Hcuts2[L] + (L ? minKB - 1e-5 : 0.0))){
          if(error)
	    return 1;
	  assert(Hcuts2[i+1] >= Hcuts2[L] + (L ? minKB - 1e-5 : 0.0));
        }
	L = i+1;
      }
    }
  }

  for(int i = 0; i <= n+1; i++){
    int Hap = HapSite[i];
    Hdel1[i] = (Hap&1) ? 0 : 1;
    Hdel2[i] = (Hap&2) ? 0 : 1;
  }

  if(Y1)
    N1 = setmap(n,Hcuts1,Hdel1,Y1,map1M,nmap1M);
  if(Y2)
    N2 = setmap(n,Hcuts2,Hdel2,Y2,map2M,nmap2M);

  if(error && (N1 <= 0 || N2 <= 0))
    return 1;// NEW76

  if(DEBUG>=2 || error){/* make sure no real cuts are closer than minKB */
    if(Y1){
      for(register int I = 1; I < N1; I++)
	if(!(Y1[I+1]-Y1[I] >= minKB - 2e-9)){
	  if(!error){
	    printf("\nI=%d,N1=%d:Y1[I]=%0.10f,Y1[I+1]=%0.10f, delta=%0.10f, minKB=%0.6f\n",
		   I,N1,Y1[I],Y1[I+1], Y1[I+1]-Y1[I], minKB);
	    fflush(stdout);
	  }
	  if(error)
	    return 1;
	  assert(Y1[I+1]-Y1[I] >= minKB - 2e-9);
	}
    }
    if(Y2){
      for(register int I = 1; I < N2; I++)
	if(!(Y2[I+1]-Y2[I] >= minKB - 2e-9)){
	  if(!error){
	    printf("\nI=%d,N2=%d:Y2[I]=%0.10f,Y2[I+1]=%0.10f, delta=%0.10f, minKB=%0.6f\n",
		   I,N2,Y2[I],Y2[I+1], Y2[I+1]-Y2[I], minKB);
	    fflush(stdout);
	  }
	  if(error)
	    return 1;
	  assert(Y2[I+1]-Y2[I] >= minKB - 2e-9);
	}
    }
  }
  if(DEBUG>=2 && HPROBEVAL_SPREAD && spreadHapDelta && spreadDelta){
    for(int i = 1; i <= n+1; i++){
      assert(Hcuts1[i] >= Hcuts1[i-1]);
      assert(Hcuts2[i] >= Hcuts2[i-1]);
    }
  }

  return 0;
}

/* re-position deleted sites in Hcuts[] (unaligned sites in X[m][] vs Hcuts1[] or Hcuts2[])
   If HMAP_MINDISTANCE > 0.0, returns total expansion of Hcuts[] between labels on same Allele, otherwise returns 0
 */
static double repositionH(int n, double *Hcuts, double *Hcuts1, double *Hcuts2, 
			  double *&HapDelta, double *&Delta, int *&HapSite, int *Hdel1, int *Hdel2, 
			  int N1, int N2, double *Y1, double *Y2,
			  int MD, int *MX, double **X, double *LPA1, double *LPA2,
			  int **map1, int **map2, int **mapK1, int **mapK2, Csetlimit *limit1, Csetlimit *limit2, double *TBmapWT, int **nmap1, int **nmap2, int *skip, int &Lfrozen,int &Rfrozen, Ccontig *pcontig, int &imin, int &imax,
			  double *spreadHapDelta, double *spreadDelta, int *Hremap)
{
  if(SETLIMIT_CACHE)
    for(int m = 0; m < MD; m++)
      limit1[m].ileft = limit2[m].ileft = -1;

  /* remember original location of Hcuts[Lendi,Rendi]*/
  double Lend = Hcuts[Lendi], Rend = Hcuts[Rendi];

  /* remember original location of Hcuts[Lfrozen,Rfrozen] */
  double left = Hcuts[Lfrozen], right = Hcuts[(Rfrozen ? Rfrozen : n+1)];
  double origleft = Hcuts[origLfrozen], origright = Hcuts[origRfrozen ? origRfrozen : n+1];
  if(VERB/* HERE >=2 */){
    printf("repositionH:n=%d,Hcuts[n]=%0.6f,Hcuts[n+1]=%0.6f,N1=%d,N2=%d,Y1[1,N1,N1+1]=%0.4f,%0.4f,%0.4f,Y2[1,N2,N2+1]=%0.4f,%0.4f,%0.4f\n",
	   n,Hcuts[n],Hcuts[n+1],N1,N2,Y1[1],Y1[N1],Y1[N1+1],Y2[1],Y2[N2],Y2[N2+1]);
    printf("\t Lfrozen=%d,Rfrozen=%d,left=Hcuts[Lfrozen]=%0.6f,right=Hcuts[Rfrozen]=%0.6f,origLfrozen=%d,origleft=%0.6f,origRfrozen=%d,origright=%0.6f,Lendi=%d(Lend=%0.3f),Rendi=%d(Rend=%0.3f)\n",
	   Lfrozen,Rfrozen,left,right,origLfrozen,origleft,origRfrozen,origright,Lendi,Lend,Rendi,Rend);
    if(VERB>=2 && rverb){
      int cnt1 = 0, cnt2 = 0;
      for(int i = 0; i <= n; i++)
	if(HapSite[i] || HapDelta[i] || Delta[i] || i==Lfrozen || i==Rfrozen){
	  cnt1 += (HapSite[i] & 1) ? 1 : 0;
	  cnt2 += (HapSite[i] & 2) ? 1 : 0;
	  
	  printf("i=%d:Hcuts[i]=%0.4f,Hcuts1[i]=%0.4f,Hcuts2[i]=%0.4f,HapSite[i]=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f:I1=%d,I2=%d,Y1[I1]=%0.6f,Y2[I2]=%0.6f\n",
		 i,Hcuts[i],Hcuts1[i],Hcuts2[i],HapSite[i],HapDelta[i],Delta[i],cnt1,cnt2,Y1[cnt1],Y2[cnt2]);
	}
      fflush(stdout);
    }
    if(VERB && rverb){
      for(int m = 0; m < MD; m++){
	if(TBmapWT[m] <= 0.0)
	  continue;
	int M = MX[m];
	for(int J = 1; J <= M; J++){
	  int i1 = map1[m][J],I1 = -1;
	  int k1 = mapK1[m][J], K1 = -1;
	  if(i1 >= 0){
	    I1 = map1[MD][i1];
	    K1 = map1[MD][i1-k1];
	    if(MDEBUG_M >= 0 && MDEBUG_M == m)
	      printf("m=%d,id=%lld:J=%d,M=%d:map1[m][J]=i=%d,mapK1[m][J]=k=%d,X[m][J]=%0.4f,Hcuts[i]=%0.4f,Hcuts[i-k]=%0.4f,map1[MD][i]=%d,map1[MD][i-k]=%d\n",
		     m,gmap[pcontig->contig[m].mapid]->id,J,M,map1[m][J],mapK1[m][J],X[m][J],Hcuts[i1],Hcuts[i1-k1],I1,K1);
	  }
	  int i2 = map2[m][J], I2 = -1;
	  int k2 = mapK2[m][J], K2 = -1;
	  if(i2 >= 0){
	    I2 = map2[MD][i2];
	    K2 = map2[MD][i2-k2];
	    if(MDEBUG_M >= 0 && MDEBUG_M == m)
              printf("m=%d,id=%lld:J=%d,M=%d:map2[m][J]=i=%d,mapK2[m][J]=k=%d,X[m][J]=%0.4f,Hcuts[i]=%0.4f,Hcuts[i-k]=%0.4f,map2[MD][i]=%d,map2[MD][i-k]=%d\n",
		     m,gmap[pcontig->contig[m].mapid]->id,J,M,map2[m][J],mapK2[m][J],X[m][J],Hcuts[i2],Hcuts[i2-k2],I2,K2);
	  }
	  // printf("m=%d,J=%d:map1[m][J]=%d,%d(K1=%d,I1=%d),map2[m][J]=%d,%d(K2=%d,I2=%d)\n",m,J,k1,i1,K1,I1,k2,i2,K2,I2);
	}
      }
    }
    fflush(stdout);
  }

  double *origHcuts = NULL;
  if(DEBUG>=2){
    for(int i = 1; i <= n+1; i++){
      if(DEBUG && !(Hcuts[i] >= Hcuts[i-1])){
        printf("i=%d:Hcuts[i-1]=%0.6f,Hcuts[i]=%0.6f,n=%d\n",i,Hcuts[i-1],Hcuts[i],n);
        fflush(stdout);
        assert(Hcuts[i] >= Hcuts[i-1]);
      }
    }
    for(int i = 1; i <= n; i++){
      assert(0 <= Hdel1[i] && Hdel1[i] <= 1);
      assert(0 <= Hdel2[i] && Hdel2[i] <= 1);
    }
    if(DEBUG) assert(Hdel1[0]==1);
    if(DEBUG) assert(Hdel2[0]==1);
    if(DEBUG) assert(Hdel1[n+1]==1);
    if(DEBUG) assert(Hdel2[n+1]==1);
  }

  double cumshift = 0.0;
  double *shift = NULL;
  if(HMAP_MINDISTANCE > 0.0){
    /* Make sure there is a minimum distance of HMAP_MINDISTANCE kb between any two labels in Hcuts[i] and Hcuts[j] (j > i) for which (HapSite[i]&1)==(HapSite[j]&1) OR (HapSite[i]&2)==(HapSite[j]&2) */
    shift = new double[n+2];
    for(int i = 0; i <= n+1; i++)
      shift[i] = 0.0;
    for(int i = 1; i < n; i++){
      if(!HapSite[i])
	continue;
      if((HapSite[i] & 1)){
	/* locate next site in Allele 1 */
	for(int j = i+1; j <= n; j++){
	  if(HapSite[j] & 1){
	    if(Hcuts[j] - Hcuts[i] < HMAP_MINDISTANCE)
	      shift[j] = max(shift[j], HMAP_MINDISTANCE - (Hcuts[j] - Hcuts[i]));
	    break;
	  }
	}
      }
      if(HapSite[i] & 2){
	/* locate next site in Allele 2 */
	for(int j = i+1; j <= n; j++){
	  if(HapSite[j] & 2){
	    if(Hcuts[j] - Hcuts[i] < HMAP_MINDISTANCE)
	      shift[j] = max(shift[j], HMAP_MINDISTANCE - (Hcuts[j] - Hcuts[i]));
	    break;
	  }
	}
      }
    }

    cumshift = shift[0];
    for(int i = 1; i <= n+1; i++){
      if(DEBUG) assert(shift[i] >= 0.0);
      Hcuts[i] += (cumshift += shift[i]);
    }
    if(VERB/* >= 2 */ && cumshift > 0.0){
      printf("repositionH: Expanded Hcuts[] by %0.4f kb to ensure minimum spacing of %0.4f kb between real labels on either Allele\n",
	     cumshift,HMAP_MINDISTANCE);
      fflush(stdout);
      if(VERB>=2 && rverb){
	cumshift = shift[0];
	for(int i = 1; i <= n+1; i++){
	  if(!HapSite[i]){
	    if(DEBUG) assert(shift[i] <= 0.0);
	    continue;
	  }
	  cumshift += shift[i];
	  printf("i=%d: HapSite[i]=%d, shift[i]= %0.4f, cumshift= %0.4f : Hcuts[i] = %0.4f -> %0.4f -> %0.4f\n", 
		 i, HapSite[i], shift[i], cumshift, Hcuts[i] - cumshift, Hcuts[i] - shift[i], Hcuts[i]);
	}
      }
      fflush(stdout);
    }

    if(cumshift > 0.0){// NEW 
      Lend = Hcuts[Lendi];
      Rend = Hcuts[Rendi];
      left = Hcuts[Lfrozen];
      right = Hcuts[Rfrozen ? Rfrozen : n+1];
      origleft = Hcuts[origLfrozen];
      origright = Hcuts[origRfrozen ? origRfrozen : n+1];
      if(VERB/* >=2 */){
	printf("\t Lfrozen=%d,Rfrozen=%d,left=Hcuts[Lfrozen]=%0.6f,right=Hcuts[Rfrozen]=%0.6f,origLfrozen=%d,origleft=%0.6f,origRfrozen=%d,origright=%0.6f\n",
	       Lfrozen,Rfrozen,left,right,origLfrozen,origleft,origRfrozen,origright);
	fflush(stdout);
      }
    }
  }

  double cum = shift[0];
  for(int i = 1; i <= n+1; i++){
    if(DEBUG && !HapSite[i]) assert(shift[i] <= 0.0);
    cum += shift[i];
    shift[i] = cum;
  }
  if(DEBUG) assert(fabs(cum - cumshift) < 1e-6);

  if(DEBUG>=2){
    origHcuts = new double[n+2];
    memcpy(origHcuts,Hcuts,(n+2)*sizeof(double));
    
    for(int i = 1; i <= n; i++){
      if(!HapSite[i]){
	assert(HapDelta[i] == 0.0);
	assert(Delta[i] == 0.0);
      }
    }
  }

  /* If UpdateMap() was called sites in Hcuts[] may no longer be aligned with any site in X[] : just collect a set of candidate locations in each real interval and assign as many of them to deleted locations in Hcuts[]
     as possible */
  /* count number of unaligned sites in all molecules X[] based on alignment with Hcuts1[] or Hcuts2[] (whichever has better LP alignment score) */
  /* skip molecules that have TBmapWT[m] == 0.0 or have no aligned sites to anchor the unaligned sites */
  int addcnt = 0;
  for(int m = 0; m < MD; m++){
    if(TBmapWT[m] <= 0.0)
      continue;
    int M = MX[m];
    if(LPA1[m] > LPA2[m]){
      int origcnt = addcnt;
      for(int J = 1; J <= M; J++){
	int i = map1[m][J];
	if(i < 0 || map1[MD][i] < 0)
	  addcnt++;
      }
      if(VERB>=3){
	if(addcnt - origcnt >= M)
	  printf("m=%d:M=%d,addcnt=%d:TBmapWT[m]=%0.6f,LPA1[m]=%0.8f(!),LPA2[m]=%0.8f(No aligned sites)\n",m,M,origcnt,TBmapWT[m],LPA1[m],LPA2[m]);
	else
	  printf("m=%d:M=%d,addcnt=%d:TBmapWT[m]=%0.6f,LPA1[m]=%0.8f(!),LPA2[m]=%0.8f\n",m,M,addcnt+2,TBmapWT[m],LPA1[m],LPA2[m]);
	fflush(stdout);
      }
      if(addcnt - origcnt >= M)/* no aligned sites */
	addcnt = origcnt;
      else
	addcnt += 2;  /* add space for ends of molecules */
    } else {
      int origcnt = addcnt;
      for(int J = 1; J <= M; J++){
	int i = map2[m][J];
	if(i < 0 || map2[MD][i] < 0)
	  addcnt++;
      }
      if(VERB>=3){
	if(addcnt - origcnt >= M)
	  printf("m=%d:M=%d,addcnt=%d:TBmapWT[m]=%0.6f,LPA1[m]=%0.8f,LPA2[m]=%0.8f(!)(No aligned sites)\n",m,M,origcnt,TBmapWT[m],LPA1[m],LPA2[m]);
	else
	  printf("m=%d:M=%d,addcnt=%d:TBmapWT[m]=%0.6f,LPA1[m]=%0.8f,LPA2[m]=%0.8f(!)\n",m,M,addcnt+2,TBmapWT[m],LPA1[m],LPA2[m]);
	fflush(stdout);
      }
      if(addcnt - origcnt >= M)/* no aligned sites */
	addcnt = origcnt;
      else
	addcnt += 2;  /* add space for ends of molecules */
    }
  }

  int unaddcnt = addcnt;

  /* add aligned sites in Hcuts[] + space for left and right end of original consensus (in case they match one of Hcuts[origLfrozen, Lfrozen,Rfrozen, origRfrozen]) */
  addcnt += 6;
  for(int i = 1; i <= n; i++)
    if(HapSite[i])
      addcnt++;
  /* NOTE : Hcuts[n+1] may or may not be included in the above sites.  Hcuts[0] is never included and always==0.0 */

  //  int origrverb = rverb;

  if(DEBUG) assert(addcnt > 0);/* make sure there was no 31-bit overflow */

  if(addcnt > 0){
    int maxaddcnt = addcnt;
    Caddloc *addloc = new Caddloc[maxaddcnt];
    if(DEBUG>=2){/* check if map[MD] and nmap[MD] are consistent */
      int I,i;
      for(i = 1; i <= n; i++)
	if((I = map1[MD][i]) >= 0){
	  assert(nmap1[MD][I] == i);
	  assert(fabs(Hcuts1[i] - Y1[I]) < 1e-6);
	}
      for(I = 1; I <= N1; I++)
	if((i = nmap1[MD][I]) >= 0){
	  assert(map1[MD][i] == I);
	  assert(fabs(Hcuts1[i] - Y1[I]) < 1e-6);
	}
      for(i = 1; i <= n; i++)
	if((I = map2[MD][i]) >= 0){
	  assert(nmap2[MD][I] == i);
	  assert(fabs(Hcuts2[i] - Y2[I]) < 1e-6);
	}
      for(I = 1; I <= N2; I++)
	if((i = nmap2[MD][I]) >= 0){
	  assert(map2[MD][i] == I);
	  assert(fabs(Hcuts2[i] - Y2[I]) < 1e-6);
	}
    }
    if(DEBUG>=2){/* make sure map[] and mapK[] are consistent */
      int I;
      for(int m = 0; m < MD; m++){
	//	if(TBmapWT[m] <= 0.0)
	//	  continue;
	int M = MX[m];

	int lastJ = -1, lasti = -1, lastk = -1, i, k;
	for(int J = 1; J <= M; J++){
	  if((i = map1[m][J]) > 0 && (I = map1[MD][i]) >= 0){
	    k = mapK1[m][J];
	    assert(0 <= k && k < i);
	    if(k > 0 && map1[MD][i-k] < 0)
	      k = 0;
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("\nmap1:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel1[i]=%d,Hdel1[i-k]=%d,HapSite[i]=%d,HapSite[i-k]=%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel1[i],Hdel1[i-k],HapSite[i],HapSite[i-k]);
	      int K = map1[MD][i-k];
	      if(K < 0)
		printf("    I=%d,K=%d:Hcuts1[i]=%0.4f,Y1[I]=%0.4f,Hcuts1[i-k]=%0.4f\n",
		       I,K,Hcuts1[i],Y1[I],Hcuts1[i-k]);
	      else
		printf("    I=%d,K=%d:Hcuts1[i]=%0.4f,Y1[I]=%0.4f,Hcuts1[i-k]=%0.4f,Y1[K]=%0.4f\n",
		       I,K,Hcuts1[i],Y1[I],Hcuts1[i-k],Y1[K]);
	      fflush(stdout);
	      assert(i-k > lasti);
	    }

	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}

	lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  if((i = map2[m][J]) > 0 && (I = map2[MD][i]) >= 0){
	    k = mapK2[m][J];
	    assert(0 <= k && k < i);
	    if(k > 0 && map2[MD][i-k] < 0)/* locally "clean up" mapK */
	      k = 0;
	    if(lasti >= 0 && !(i-k > lasti)){
	      printf("map2:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d:Hdel2[i]=%d,Hdel2[i-k]=%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel2[i],Hdel2[i-k]);
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
	}
      }
    }

    Caddloc *p = addloc;

    double minloc = 0.0;/* leftmost unaligned site or end : for debugging large -ve values */
    double maxloc = Hcuts[n+1];/* rightmost unaligned site or end : for debugging large extensions of right end */

    for(int m = 0; m < MD; m++){
      if(TBmapWT[m] <= 0.0)
	continue;
      int M = MX[m];
      double *Xm = X[m];
      
      if(MDEBUG_M >= 0 && MDEBUG_M == m && rverb){
	long long id = gmap[pcontig->contig[m].mapid]->id;
	rverb = (id==1401 || id==598632 || id==976292 || id==951408 || id==272802) ? 2 : 1;

	printf("m=%d,id=%lld:LPA1[m]=%0.6f,LPA2[m]=%0.6f\n",m,id,LPA1[m],LPA2[m]);
	fflush(stdout);
      }

      if(LPA1[m] > LPA2[m]){

	/* locate first aligned site */
	int R = 1, iR = -1, I;
	for(; R <= M; R++)
	  if((iR = map1[m][R]) >= 0 && (I = map1[MD][iR]) >= 0)
	    break;
	if(R > M){
	  if(VERB>=3){
	    printf("m=%d:M=%d,p-addloc=%ld:TBmapWT[m]=%0.6f,LPA1[m]=%0.8f,LPA2[m]=%0.8f (No aligned sites with map1)\n",m,M,p-addloc,TBmapWT[m],LPA1[m],LPA2[m]);
	    fflush(stdout);
	  }
	  continue;/* molecule m has no aligned sites (should be rare)  */
	}
	if(DEBUG) assert(iR >= 0);
	int kR = mapK1[m][R];
	if(DEBUG) assert(kR >= 0 && kR < iR);

	while(kR > 0 && map1[MD][iR-kR] < 0)
	  kR--;
	if(DEBUG) assert(map1[MD][iR-kR] >= 0);
	if(MDEBUG_M >= 0 && MDEBUG_M == m && rverb && kR != mapK1[m][R]){
	  printf("m=%d,R=%d,adjusting mapK1[m][R] from %d to %d so it remains mapped\n",m,R,mapK1[m][R],kR);
	  fflush(stdout);
	}
	mapK1[m][R] = kR;

	/* locate sites left of Xm[R] on Hcuts[] by extrapolation: 
	   extrapolation is to Hcuts1[] which needs to be remapped on to Hcuts[] based on nearest surrounding sites with HapSite[] != 0, or ends Hcuts[0],Hcuts[n+1] */
	double loc = Hcuts1[iR-kR] - Xm[R];
	int J = 0;
	int il = 0, ir = 0;
	for(; J < R; J++, p++){
	  p->i = -3;/* unaligned, based on map1 */
	  p->m = m;
	  p->J = J;

	  double nloc = loc + Xm[J];
	  while(ir <= n && Hcuts1[ir] < nloc){
	    il = ir;
	    while(++ir <= n)
	      if(HapSite[ir] & 1)
		break;
	  }
	  if(DEBUG && !(ir <= n+1 && ir >= il && Hcuts1[ir] >= Hcuts1[il] && (il <= 0 || (HapSite[il]&1)) && (ir <= 0 || (HapSite[ir]&1)))){
	    printf("m=%d,J=%d,R=%d,M=%d,iR=%d,kR=%d,il=%d,ir=%d,n=%d:Hcuts1[iR-kR]=%0.4f,Xm[R]=%0.4f,Xm[J]=%0.4f,nloc=%0.4f,Hcuts1[il]=%0.6f,Hcuts1[ir]=%0.6f,HapSite[il,ir]=%d,%d\n",
		   m,J,R,M,iR,kR,il,ir,n,Hcuts1[iR-kR],Xm[R],Xm[J],nloc,Hcuts1[il],Hcuts1[ir],HapSite[il],HapSite[ir]);
	    fflush(stdout);
	    assert(ir <= n+1 && ir >= il && Hcuts1[ir] >= Hcuts1[il] && (il <= 0 || (HapSite[il]&1)) && (ir <= 0 || (HapSite[ir]&1)));
	  }
	  p->loc = Hcuts[il] + (Hcuts1[ir] > Hcuts1[il] ? (nloc - Hcuts1[il]) * (Hcuts[ir]-Hcuts[il]) / (Hcuts1[ir]-Hcuts1[il]) : REPOSITIONH_FIX ? nloc - Hcuts1[il] : 0.0);
	
	  if((MDEBUG_M >= 0 && MDEBUG_M == m && rverb) || (VERB>=2 && p->loc < minloc)){	
	    printf("addloc[%ld]:m=%d,J=%d,loc=%0.4f:iR=%d,kR=%d,R=%d,il=%d,ir=%d:Hcuts1[iR-kR]=%0.4f,Xm[R]=%0.4f,Xm[J]=%0.4f,Hcuts[il]=%0.4f,Hcuts[ir]=%0.4f,Hcuts1[il]=%0.4f,Hcuts1[ir]=%0.4f\n",
		   p-addloc,m,J,p->loc,iR,kR,R,il,ir,Hcuts1[iR-kR],Xm[R],Xm[J],Hcuts[il],Hcuts[ir],Hcuts1[il],Hcuts1[ir]);
	    fflush(stdout);
	  }
	  minloc = min(minloc,p->loc);

	  map1[m][J] = -1;/* in case this site has to be discarded from Hcuts[] */
	  mapK1[m][J] = 0;
	}

	int L = R, iL = iR;
	//      int kL = kR;
	for(; ++R <= M;){
	  if((iR = map1[m][R]) >= 0 && (I = map1[MD][iR]) >= 0){
	    kR = mapK1[m][R];
	    if(DEBUG) assert(kR >= 0 && kR < iR);

	    /* locate sites between L and R by interpolation */
	    double ratio = (Hcuts[iR-kR]-Hcuts[iL])/(Xm[R]-Xm[L]);
	    double loc = Hcuts[iL] - ratio*Xm[L];

	    for(int J = L+1; J < R; J++, p++){
	      p->i = -3;/* unaligned, based on map1 */
	      p->m = m;
	      p->J = J;
	      p->loc = loc + ratio * Xm[J];
	      if(MDEBUG_M >= 0 && MDEBUG_M == m && rverb){	
		printf("addloc[%ld]:m=%d,J=%d,loc=%0.4f:iL=%d,iR=%d,kR=%d,L=%d,R=%d,Hcuts[iL]=%0.4f,Hcuts[iR-kR]=%0.4f,Xm[L]=%0.4f,Xm[R]=%0.4f,Xm[J]=%0.4f\n",
		       p-addloc,m,J,p->loc,iL,iR,kR,L,R,Hcuts[iL],Hcuts[iR-kR],Xm[L],Xm[R],Xm[J]);
		fflush(stdout);
	      }
	      if(DEBUG>=2) assert(minloc <= p->loc && p->loc <= maxloc);

	      map1[m][J] = -1;/* in case this site has to be discarded from Hcuts[] */
	      mapK1[m][J] = 0;
	    }

	    L = R;
	    iL = iR;
	    //	  kL = kR;
	  }
	}

	/* locate sites right of X[m][L] by extrapolation
	   extrapolation is to Hcuts1[] which needs to be remapped on to Hcuts[] based on nearest surrounding sites with HapSite[] != 0, or ends Hcuts[0],Hcuts[n+1] */
	loc = Hcuts1[iL] - Xm[L];
	il = iL;
	for(ir = il; ++ir <= n;)
	  if(HapSite[ir] & 1)
	    break;

	for(J = L; ++J <= M+1; p++){
	  p->i = -3;/* unaligned, based on map1 */
	  p->m = m;
	  p->J = J;
	  
	  double nloc = loc + Xm[J];
	  while(ir <= n && Hcuts1[ir] < nloc){
	    il = ir;
	    while(++ir <= n)
	      if(HapSite[ir] & 1)
		break;
	  }
	  if(DEBUG && !(ir <= n+1 && ir >= il && Hcuts1[ir] >= Hcuts1[il]) && (HapSite[il]&1) && (ir > n || (HapSite[ir]&1))){
            printf("repositionH:m=%d,J=%d,L=%d,iL=%d,il=%d,ir=%d,n=%d:Hcuts1[iL]=%0.4f,Xm[L]=%0.4f,Xm[J]=%0.4f,nloc=%0.4f,Hcuts1[il]=%0.4f,Hcuts1[ir]=%0.4f,Hcuts[n+1]=%0.4f,HapSite[il,ir]=%d,%d\n",
		   m,J,L,iL,il,ir,n,Hcuts1[iL],Xm[L],Xm[J],nloc,Hcuts1[il],Hcuts1[ir],Hcuts[n+1],HapSite[il],HapSite[ir]);
	    fflush(stdout);
            assert(ir <= n+1 && ir >= il && Hcuts1[ir] >= Hcuts1[il] && (HapSite[il]&1) && (ir > n || (HapSite[ir]&1)));
          }
	  p->loc = Hcuts[il] + (Hcuts1[ir] > Hcuts1[il] ? (nloc - Hcuts1[il]) * (Hcuts[ir]-Hcuts[il]) / (Hcuts1[ir]-Hcuts1[il]) : REPOSITIONH_FIX ? nloc - Hcuts[il] : 0.0);

	  if((MDEBUG_M >= 0 && MDEBUG_M == m && rverb) || (VERB>=2 && p->loc > maxloc)){	
	    printf("addloc[%ld]:m=%d,J=%d,loc=%0.4f:iL=%d,L=%d,il=%d,ir=%d:Hcuts1[iL]=%0.4f,Xm[L]=%0.4f,Xm[J]=%0.4f,Hcuts[il]=%0.4f,Hcuts[ir]=%0.4f,Hcuts1[il]=%0.4f,Hcuts1[ir]=%0.4f,HapSite[il,ir]=%d,%d,n=%d\n",
		   p-addloc,m,J,p->loc,iL,L,il,ir,Hcuts1[iL],Xm[L],Xm[J],Hcuts[il],Hcuts[ir],Hcuts1[il],Hcuts1[ir],HapSite[il],HapSite[ir],n);
	    fflush(stdout);
	  }
	  maxloc = max(maxloc,p->loc);

	  map1[m][J] = -1;/* in case this site has to be discarded from Hcuts[] */
	  mapK1[m][J] = 0;
	}

      } else {/* LPA1[m] <= LPA2[m] */
	
	/* locate first aligned site */
	int R = 1, iR = -1, I;
	for(; R <= M; R++)
	  if((iR = map2[m][R]) >= 0 && (I = map2[MD][iR]) >= 0)
	    break;
	if(R > M){
	  if(VERB>=3){
	    printf("m=%d:M=%d,p-addloc=%ld:TBmapWT[m]=%0.6f,LPA1[m]=%0.8f,LPA2[m]=%0.8f (No aligned sites with map2)\n",m,M,p-addloc,TBmapWT[m],LPA1[m],LPA2[m]);
	    fflush(stdout);
	  }
	  continue;/* molecule m has no aligned sites (should be rare)  */
	}
	if(DEBUG) assert(iR >= 0);
	int kR = mapK2[m][R];
	if(DEBUG) assert(kR >= 0 && kR < iR);

	if(REPOSITIONH_FIX){// adjust mapK2[m][R] if map2[MD][iR-kR] < 0
	  while(kR > 0 && map2[MD][iR-kR] < 0)
	    kR--;
	  if(DEBUG) assert(map2[MD][iR-kR] >= 0);
	  if(MDEBUG_M >= 0 && MDEBUG_M == m && rverb && kR != mapK2[m][R]){
	    printf("m=%d,R=%d,adjusting mapK2[m][R] from %d to %d so it remains mapped\n",m,R,mapK2[m][R],kR);
	    fflush(stdout);
	  }
	  mapK2[m][R] = kR;
	}

	/* locate sites left of Xm[R] on Hcuts[] by extrapolation */
	// extrapolation is to Hcuts2[] which needs to be remapped on to Hcuts[] based on nearest sites with HapSite[] != 0
	double loc = Hcuts2[iR-kR] - Xm[R];
	int J = 0;
	int il = 0, ir = 0;
	for(; J < R; J++, p++){
	  p->i = -4;/* unaligned, based on map2 */
	  p->m = m;
	  p->J = J;

	  double nloc = loc + Xm[J]; 
	  while(ir <= n && Hcuts2[ir] < nloc){
	    il = ir;
	    while(++ir <= n)
	      if(HapSite[ir] & (REPOSITIONH_FIX ? 2 : 3))
		break;
	  }
	  if(DEBUG) assert(ir <= n+1 && ir >= il && Hcuts2[ir] >= Hcuts2[il]);
	  if(DEBUG && REPOSITIONH_FIX) assert((il <= 0 || (HapSite[il]&2)) && (ir <= 0 || (HapSite[ir]&2)));
	  p->loc = Hcuts[il] + (Hcuts2[ir] > Hcuts2[il] ? (nloc - Hcuts2[il]) * (Hcuts[ir]-Hcuts[il]) / (Hcuts2[ir]-Hcuts2[il]) : REPOSITIONH_FIX ? nloc - Hcuts2[il] : 0.0);

	  if((MDEBUG_M >= 0 && MDEBUG_M == m && rverb) || (VERB>=2 && p->loc < minloc)){	
	    printf("addloc[%ld]:m=%d,J=%d,loc=%0.4f:iR=%d,kR=%d,R=%d,il=%d,ir=%d:Hcuts2[iR-kR]=%0.4f,Xm[R]=%0.4f,Xm[J]=%0.4f,Hcuts[il]=%0.4f,Hcuts[ir]=%0.4f,Hcuts2[il]=%0.4f,Hcuts2[ir]=%0.4f\n",
		   p-addloc,m,J,p->loc,iR,kR,R,il,ir,Hcuts2[iR-kR],Xm[R],Xm[J],Hcuts[il],Hcuts[ir],Hcuts2[il],Hcuts2[ir]);
	    fflush(stdout);
	  }
	  minloc = min(minloc,p->loc);

	  map2[m][J] = -1;/* in case this site has to be discarded from Hcuts[] */
	  mapK2[m][J] = 0;
	}

	int L = R, iL = iR;
	//      int kL = kR;
	for(; ++R <= M;){
	  if((iR = map2[m][R]) >= 0 && (I = map2[MD][iR]) >= 0){
	    kR = mapK2[m][R];
	    if(DEBUG) assert(kR >= 0 && kR < iR);

	    /* locate sites between L and R by interpolation */
	    double ratio = (Hcuts[iR-kR]-Hcuts[iL])/(Xm[R]-Xm[L]);
	    double loc = Hcuts[iL] - ratio*Xm[L];

	    for(int J = L+1; J < R; J++, p++){
	      p->i = -4;/* unaligned, based on map2 */
	      p->m = m;
	      p->J = J;
	      p->loc = loc + ratio * Xm[J];
	      if(MDEBUG_M >= 0 && MDEBUG_M == m && rverb){	
		printf("addloc[%ld]:m=%d,J=%d,loc=%0.4f:iL=%d,iR=%d,kR=%d,L=%d,R=%d,Hcuts[iL]=%0.4f,Hcuts[iR-kR]=%0.4f,Xm[L]=%0.4f,Xm[R]=%0.4f,Xm[J]=%0.4f\n",
		       p-addloc,m,J,p->loc,iL,iR,kR,L,R,Hcuts[iL],Hcuts[iR-kR],Xm[L],Xm[R],Xm[J]);
		fflush(stdout);
	      }
	      if(DEBUG>=2) assert(minloc <= p->loc && p->loc <= maxloc);

	      map2[m][J] = -1;/* in case this site has to be discarded from Hcuts[] */
	      mapK2[m][J] = 0;
	    }

	    L = R;
	    iL = iR;
	    //	  kL = kR;
	  }
	}
	/* locate sites right of X[m][L] by extrapolation */
	// extrapolation is to Hcuts2[] which needs to be remapped on to Hcuts[] based on nearest sites with HapSite[] != 0
	loc = Hcuts2[iL] - Xm[L];
	il = iL;
	for(ir = il; ++ir <= n;)
	  if(HapSite[ir] & 2)
	    break;

	for(J = L; ++J <= M+1; p++){
	  p->i = -4;/* unaligned, based on map2 */
	  p->m = m;
	  p->J = J;

	  double nloc = loc + Xm[J];
	  while(ir <= n && Hcuts2[ir] < nloc){
	    il = ir;
	    while(++ir <= n)
	      if(HapSite[ir] & (REPOSITIONH_FIX ? 2 : 3))
		break;
	  }
	  if(DEBUG) assert(ir <= n+1 && ir >= il && Hcuts2[ir] >= Hcuts2[il]);
	  if(DEBUG && REPOSITIONH_FIX) assert((HapSite[il]&2) && (ir > n || (HapSite[ir]&2)));
	  p->loc = Hcuts[il] + (Hcuts2[ir] > Hcuts2[il] ? (nloc - Hcuts2[il]) * (Hcuts[ir]-Hcuts[il]) / (Hcuts2[ir]-Hcuts2[il]) : REPOSITIONH_FIX ? nloc - Hcuts2[il] : 0.0);

	  if((MDEBUG_M >= 0 && MDEBUG_M == m && rverb) || (VERB>=2 && p->loc > maxloc)){	
	    printf("addloc[%ld]:m=%d,J=%d,loc=%0.4f:iL=%d,L=%d,il=%d,ir=%d:Hcuts2[iL]=%0.4f,Xm[L]=%0.4f,Xm[J]=%0.4f,Hcuts[il]=%0.4f,Hcuts[ir]=%0.4f,Hcuts2[il]=%0.4f,Hcuts2[ir]=%0.4f\n",
		   p-addloc,m,J,p->loc,iL,L,il,ir,Hcuts2[iL],Xm[L],Xm[J],Hcuts[il],Hcuts[ir],Hcuts2[il],Hcuts2[ir]);
	    fflush(stdout);
	  }
	  maxloc = max(p->loc,maxloc);

	  map2[m][J] = -1;/* in case this site has to be discarded from Hcuts[] */
	  mapK2[m][J] = 0;
	}
      }
      if(VERB>=3){
	printf("m=%d:M=%d,p-addloc=%ld:TBmapWT[m]=%0.6f,LPA1[m]=%0.8f,LPA2[m]=%0.8f\n",m,M,p-addloc,TBmapWT[m],LPA1[m],LPA2[m]);
	fflush(stdout);
      }
    }

    double Rshift = 0.0;

    int unaligned_cnt = p - addloc;
    if(DEBUG && !(unaligned_cnt == unaddcnt)){
      printf("repositionH:unaddcnt=%d,unaligned_cnt=%d\n",unaddcnt,unaligned_cnt);
      fflush(stdout);
      assert(unaligned_cnt == unaddcnt);
    }

    /* add aligned sites in Hcuts1[] & Hcuts2[] */
#pragma novector
    for(int i = 1; i <= n; i++)
      if(HapSite[i]){
	p->i = i;
	p->loc = Hcuts[i];
	p->m = HapSite[i];
	p->J = -1;
	p++;
      }
      
    if(DEBUG) assert(p - addloc <= addcnt);

    if(VERB/* HERE >=2 */){
      printf("unaddcnt=%d,unaligned_cnt=%d,addcnt=%d,p-addloc=%ld,n=%d,minloc=%0.3f,maxloc=%0.3f\n",unaddcnt,unaligned_cnt,addcnt,p-addloc,n,minloc,maxloc);
      fflush(stdout);
    }

    int frozen_cnt = 0;

    /* verify that Hcuts[Lfrozen,origLfrozen] have been included */
    if(Rfrozen > 0){
      double err = 1.0, loc = Hcuts[Lfrozen];
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("Lfrozen=%d: Adding Hcuts[Lfrozen]=%0.6f at addloc[%ld] (err=%0.4f)\n", Lfrozen, Hcuts[Lfrozen], p - addloc, err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	if(DEBUG/* HERE HERE >=2 */) assert(Lfrozen >= 0);
	p->i = Lfrozen;/* unaligned */
	p->m = HapSite[Lfrozen];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >= 2*/){
	  printf("Lfrozen=%d: Hcuts[Lfrozen]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",Lfrozen,Hcuts[Lfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i >= -4){
	  addloc[ierr].i -= 2;// protect this site from deletion */
	  frozen_cnt++;
	}
      }
    }
    if(origRfrozen > 0 && origLfrozen != Lfrozen){
      double err = 1.0, loc = Hcuts[origLfrozen];
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("origLfrozen=%d: Adding Hcuts[origLfrozen]=%0.6f at addloc[%ld] (err=%0.4f)\n", origLfrozen, Hcuts[origLfrozen], p - addloc, err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	if(DEBUG/* HERE HERE >=2 */) assert(origLfrozen >= 0);
	p->i = origLfrozen;/* unaligned */
	p->m = HapSite[origLfrozen];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >= 2*/){
	  printf("origLfrozen=%d: Hcuts[origLfrozen]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",origLfrozen,Hcuts[origLfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i >= -4){
	  addloc[ierr].i -= 2;// protect this site from deletion */
	  frozen_cnt++;
	}
      }
    }
    if(Rfrozen > Lfrozen){
      double err = 1.0, loc = Hcuts[Rfrozen];
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("Rfrozen=%d: Adding Hcuts[Rfrozen]=%0.6f at addloc[%ld] (err=%0.4f)\n",Rfrozen,Hcuts[Rfrozen],p - addloc,err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	if(DEBUG/* HERE HERE >=2*/) assert(Rfrozen > 0);
	p->i = Rfrozen;/* unaligned */
	p->m = HapSite[Rfrozen];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >= 2*/){
	  printf("Rfrozen=%d: Hcuts[Rfrozen]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",Rfrozen,Hcuts[Rfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i >= -4){
	  addloc[ierr].i -= 2;// protect this site from deletion */
	  frozen_cnt++;
	}
      }
    }
    if(origRfrozen > origLfrozen && origRfrozen != Rfrozen){
      double err = 1.0, loc = Hcuts[origRfrozen];
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("origRfrozen=%d,n=%d: Adding Hcuts[origRfrozen]=%0.6f at addloc[%ld] of locations (err=%0.4f)\n",origRfrozen,n,Hcuts[origRfrozen],p-addloc,err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	if(DEBUG/* HERE HERE >=2 */) assert(origRfrozen > 0);
	p->i = origRfrozen;/* unaligned */
	p->m = HapSite[origRfrozen];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >= 2*/){
	  printf("origRfrozen=%d,n=%d: Hcuts[origRfrozen]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",origRfrozen,n,Hcuts[origRfrozen],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i >= -4){
	  addloc[ierr].i -= 2;// protect this site from deletion */
	  frozen_cnt++;
	}
      }
    }

    /* verify that Hcuts[Lendi,Rendi] have been included */
    if(Rendi > 0){
      double err = 1.0, loc = Lend;
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("Lend=%0.6f: Adding Hcuts[Lendi=%d] as protected location at addloc[%ld] (err=%0.3f)\n",Lend, Lendi, p - addloc, err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	if(DEBUG/* HERE HERE >=2 */) assert(Lendi >= 0);
	p->i = Lendi;/* special case */
	p->m = HapSite[Lendi];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >=2 */){
	  printf("Lend=%0.6f: Hcuts[Lendi=%d]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",Lend,Lendi,Hcuts[Lendi],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i >= -4){
	  addloc[ierr].i -= 2;// protect this site from deletion */
	  frozen_cnt++;
	}
      }
    }
    if(Rendi > Lendi){
      double err = 1.0, loc = Rend;
      int ierr = -1;
      for(Caddloc *q = addloc; q < p; q++)
	if(fabs(q->loc - loc) < err){
	  err = fabs(q->loc - loc);
	  ierr = q - addloc;
	}
      if(err >= 0.001){
	if(VERB/* HERE >=2 */){
	  printf("Rend=%0.6f: Adding Hcuts[Rendi=%d] as protected location at addloc[%ld] (err=%0.3f)\n",Rend, Rendi, p - addloc, err);
	  fflush(stdout);
	}
	if(DEBUG) assert(p - addloc < addcnt);
	p->loc = loc;
	if(DEBUG/* HERE HERE >=2 */) assert(Rendi >= 0);
	p->i = Rendi;/* special case */
	p->m = HapSite[Rendi];
	p->J = -1;
	p++;
      } else if(ierr < unaligned_cnt){
	if(DEBUG) assert(ierr >= 0);
	if(DEBUG) assert(addloc[ierr].i < 0);
	if(VERB/* HERE >=2 */){
	  printf("Rend=%0.6f: Hcuts[Rendi=%d]=%0.6f protected at addloc[%d]=%0.6f(i=%d)\n",Rend,Rendi,Hcuts[Rendi],ierr,addloc[ierr].loc,addloc[ierr].i);
	  fflush(stdout);
	}
	if(addloc[ierr].i >= -4){
	  addloc[ierr].i -= 2;// protect this site from deletion */
	  frozen_cnt++;
	}
      }
    }

    if(DEBUG) assert(p <= &addloc[maxaddcnt]);
    addcnt = p - addloc;

    if(addcnt > n){/* randomly remove some unaligned sites */
      srandom(1);
      if(VERB){
	printf("Randomly ignoring %d out of %d unaligned sites (n=%d,addcnt=%d,frozen_cnt=%d):\n", addcnt-n, unaligned_cnt, n, addcnt,frozen_cnt);
	fflush(stdout);
      }
      int i,j;
      int delcnt = addcnt - n;
      int remcnt = unaligned_cnt - frozen_cnt;
      if((VERB>=3 && rverb) || (DEBUG && !(delcnt <= remcnt))){
	printf("addcnt=%d,n=%d,unaligned_cnt=%d,frozen_cnt=%d,remcnt=%d,delcnt=%d:\n",
	       addcnt,n,unaligned_cnt,frozen_cnt,remcnt,delcnt);
	for(int i = 0; i < addcnt; i++)
	  printf("addloc[%d]:loc=%0.4f,i=%d,m=%d,J=%d\n",i,addloc[i].loc,addloc[i].i,addloc[i].m,addloc[i].J);
	fflush(stdout);
	if(DEBUG) assert(delcnt <= remcnt);
      }
      int protcnt = 0;/* count of protected sites copied */

      for(i = j = 0; i < addcnt; i++, remcnt--){
	if(DEBUG/* HERE HERE >=2 */) assert(addloc[i].i <= -3 || addloc[i].i >= 0);
	if(addloc[i].i >= 0 || addloc[i].i < -4){/* do NOT delete this site */
	  addloc[j++]  = addloc[i];
	  remcnt++;
	  if(addloc[i].i < -4)
	    protcnt++;
	  continue;
	}
	if(delcnt > 0){
	  if(DEBUG && !(remcnt > 0 && remcnt >= delcnt)){
	    printf("addcnt=%d,n=%d,unaligned_cnt=%d,frozen_cnt=%d:i=%d,j=%d,remcnt=%d,delcnt=%d,protcnt=%d\n",
		   addcnt,n,unaligned_cnt,frozen_cnt,i,j,remcnt,delcnt,protcnt);
	    fflush(stdout);
	    assert(remcnt > 0 && remcnt >= delcnt);
	  }
	  if(DEBUG) assert(addloc[i].i < 0);
	  double delprob = ((double)delcnt)/remcnt;
	  double r = urandom();
	  if(delcnt > 0 && (r < delprob || delcnt >= remcnt)){
	    delcnt--;
	    continue;
	  }
	}
	addloc[j++]  = addloc[i];
      }
      if(DEBUG) assert(protcnt == frozen_cnt);
      if(DEBUG) assert(remcnt == 0);
      if(DEBUG) assert(i==addcnt);
      if(DEBUG) assert(j==n);
      addcnt = j;
    } else if(VERB && addcnt < n){
      printf("%d padded sites in Hcuts (out of n=%d total sites):\n", n-addcnt,n);
      fflush(stdout);
    }

    if(DEBUG) assert(addcnt <= n);

    qsort(addloc,addcnt,sizeof(Caddloc),(intcmp *)CaddlocInc);
    if(VERB/* HERE >=2 */){
      printf("addcnt=%d,n=%d:addloc[0].loc=%0.4f,addloc[addcnt-1].loc=%0.4f,minloc=%0.3f,maxloc=%0.3f\n",addcnt,n,addloc[0].loc,addloc[addcnt-1].loc,minloc,maxloc);
      fflush(stdout);
    }

    if(addloc[0].loc  < MININTERVAL){/* shift all sites right so addloc[0].loc (== Hcuts[1]) is >= MININTERVAL */
      if(VERB/* HERE >= 2*/){
	printf("addloc[0].loc = %0.6f : shifting all sites right by %0.6f (addloc[addcnt-1].loc=%0.6f)\n",addloc[0].loc, MININTERVAL-addloc[0].loc,addloc[addcnt-1].loc);
	fflush(stdout);
      }
      Rshift = MININTERVAL - addloc[0].loc;
      for(int t = 0; t < addcnt; t++)
	addloc[t].loc += Rshift;
      Hcuts[n+1] += Rshift;
      left += Rshift;
      right += Rshift;
      origleft += Rshift;
      origright += Rshift;
      Lend += Rshift;
      Rend += Rshift;
    }

    /* Hremap[i=1..n] remaps old aligned site Hcuts[i] to Hcuts[Hremap[i]] : used to update map1[m][J],mapK1[m][J],map2[m][J],mapK2[m][J] and HapSite[i] */
    // HERE HERE : should also be used to update HapSiteScore[i], SiteScore[i], DeltaScore[i] : this is needed so later iterations of mprobeval() need only check regions that are still making progress
    //             and can rely on stable region's HapSiteScore[i], SiteScore[i] and DeltaScore[i] to remain valid for use by Het Filter
    for(int i = 1; i <= n; i++)
      Hremap[i] = -1;/* unmapped */
    Hremap[0] = 0;
    Hremap[n+1] = n+1;
    for(int i = 0; i < addcnt; i++){
      Caddloc *p = &addloc[i];
      if(p->i < 0 || !HapSite[p->i])
	continue;
      if(DEBUG) assert(1 <= p->i && p->i <= n);
      Hremap[p->i] = i+1;
    }
    if(DEBUG){
      for(int i = 1; i <= n; i++){
	if(!HapSite[i])
	  assert(Hremap[i] == -1);
	else {
	  if(DEBUG && !(1 <= Hremap[i] && Hremap[i] <= addcnt)){
	    for(int I = 1; I <= n; I++)
	      if(HapSite[I])
		printf("i=%d:HapSite[i]=%d,Hremap[i]=%d\n",I,Hdel1[I],Hremap[I]);
	    for(int t = 0; t < addcnt; t++)
	      printf("addloc[%d]:loc=%0.4f,i=%d,m=%d,J=%d\n",t,addloc[t].loc,addloc[t].i,addloc[t].m,addloc[t].J);

	    printf("i=%d,n=%d:Hremap[i]=%d,addcnt=%d,HapSite[i]=%d\n",
		   i,n,Hremap[i],addcnt,HapSite[i]);
	    fflush(stdout);
	    assert(1 <= Hremap[i] && Hremap[i] <= addcnt);
	  }
	}
      }
    }
    if(VERB>=2 && rverb){
      for(int i =0; i <= n+1; i++){
	if(Hremap[i] < 0)
	  continue;
	printf("Hremap[%d]=%d\n",i,Hremap[i]);
      }
      fflush(stdout);
    }

    /* remap map1[m][J],mapK1[m][J] based on Hremap[i] */
    for(int m = 0; m < MD; m++){
      //      if(TBmapWT[m] <= 0.0)
      //	continue; // NOTE : not safe since TBmapWT[m] may later be raised 
      int M = MX[m], iR;
      int *mapM = map1[m], *mapKM = mapK1[m];
      for(int J = 1; J <= M; J++){
	if((iR = mapM[J]) >= 0){
	  int Rnew = Hremap[iR];
	  if(Rnew < 0){
	    if(DEBUG) assert(map1[MD][iR] < 0);
	    if(DEBUG) assert(!HapSite[iR]);
	    if(DEBUG) mapM[J] = -1;
	    continue;
	  }
	  if(DEBUG) assert(HapSite[iR]);
	  int k = mapKM[J];
	  if(DEBUG) assert(k >= 0);
	  int iL = iR - k;

	  int Lnew = Hremap[iL];
	  /* NOTE : not all sites between Hcuts[iL] and Hcuts[iR] are real sites. Also mapK1[] may be out of date hence point to a site iL with HapSite[iL] == 0 */
	  /*	  if(DEBUG && !HapSite[iL]){
	    printf("m=%d,M=%d,J=%d:iR=%d,Hremap[iR]=%d,k=%d,iL=%d,n=%d,HapSite[iL]=%d,Hremap[iL]=%d\n",
		   m,M,J,iR,Hremap[iR],k,iL,n,HapSite[iL],Hremap[iL]);
	    fflush(stdout);
	    assert(HapSite[iL]);
	    }*/
	  mapM[J] = Rnew;
	  if(Lnew >= 0){
	    if(DEBUG) assert(Lnew >= 1 && Lnew <= Rnew);
	    mapKM[J] = Rnew - Lnew;
	  } else
	    mapKM[J] = 0;
	}
      }
    }

    /* remap map2[m][J],mapK2[m][J] based on Hremap[i] */
    for(int m = 0; m < MD; m++){
      //      if(TBmapWT[m] <= 0.0 /* NEW NEW */ && !(RefineEndOutlierThreshold < 2 && RefineEndOutlierWt == 0.0))
      //	continue;
      int M = MX[m], iR;
      int *mapM = map2[m], *mapKM = mapK2[m];
      for(int J = 1; J <= M; J++){
	if((iR = mapM[J]) >= 0){
	  int Rnew = Hremap[iR];
	  if(Rnew < 0){
	    if(DEBUG) assert(map2[MD][iR] < 0);
	    if(DEBUG) assert(!HapSite[iR]);
	    if(DEBUG) mapM[J] = -1;
	    continue;
	  }
	  if(DEBUG) assert(HapSite[iR]);
	  int k = mapKM[J];
	  if(DEBUG) assert(k >= 0);
	  int iL = iR - k;

	  int Lnew = Hremap[iL];
	  /* NOTE : not all sites between Hcuts[iL] and Hcuts[iR] are real sites. Also mapK2[] may be out of date hence point to a site iL with HapSite[iL] == 0 */
	  /*	  if(DEBUG && !HapSite[iL]){
	    printf("m=%d,M=%d,J=%d:iR=%d,Hremap[iR]=%d,k=%d,iL=%d,n=%d,HapSite[iL]=%d,Hremap[iL]=%d\n",
		   m,M,J,iR,Hremap[iR],k,iL,n,HapSite[iL],Hremap[iL]);
	    fflush(stdout);
	    assert(HapSite[iL]);
	    }*/
	  mapM[J] = Rnew;
	  if(Lnew >= 0){
	    if(DEBUG) assert(Lnew >= 1 && Lnew <= Rnew);
	    mapKM[J] = Rnew - Lnew;
	  } else
	    mapKM[J] = 0;
	}
      }
    }

    /* Remap HapSite[],HapDelta[],Delta[] */
    int *origHapSite = HapSite;
    double *origHapDelta = HapDelta;
    double *origDelta = Delta;
    HapSite = new int[n+2];
    HapDelta = new double[n+2];
    Delta = new double[n+2];

    for(int i = 0; i <= n+1; i++){
      HapSite[i] = 0;
      HapDelta[i] = Delta[i] = 0.0;
    }
    for(int i = 0; i <= n; i++)
      if(i==0 || origHapSite[i]){
	if(DEBUG) assert(Hremap[i] >= 0);
	HapSite[Hremap[i]] = origHapSite[i];
	HapDelta[Hremap[i]] = origHapDelta[i];
	Delta[Hremap[i]] = origDelta[i];
      }

    if(DEBUG>=2){/* check to make sure number of HapSite = 1 or 3 and HapDelta != 0 are conserved */
      int origSNPcnt = 0;
      for(int i = 1; i <= n; i++)
	origSNPcnt += (origHapSite[i]==1 || origHapSite[i]==2) ? 1 : 0;
      int origIndelCnt = 0;
      for(int i = 0; i <= n; i++){
	int h = origHapSite[i];
	if(i==0 || h == 3){
	  double HapDeltaMerge = origHapDelta[i];
	  int t = i;
	  for(; ++t <= n; ){
	    if(origHapSite[t] == 3)
	      break;
	    HapDeltaMerge += origHapDelta[t];
	  }
	  origIndelCnt += (fabs(HapDeltaMerge) >= MIN_INDEL_SIZE) ? 1 : 0;
	  if(VERB>=2 && rverb && fabs(HapDeltaMerge) >= MIN_INDEL_SIZE){
	    printf("repositionH:Indel at Hcuts[%d..%d]:origHapSite[]=%d,%d, origHapDelta[]=%0.4f (origHapDelta[%d]=%0.4f)\n",i,t,origHapSite[i],origHapSite[t],HapDeltaMerge,i,origHapDelta[i]);
	    fflush(stdout);
	  }
	  //	    if(DEBUG && fabs(HapDeltaMerge) >= MIN_INDEL_SIZE && 1 <= i && t <= n) assert(origHapDelta[i] != 0.0);
	}
      }

      int SNPcnt = 0;/* count of current number of SNPs */
      for(int i = 1; i <= n; i++)
	SNPcnt += (HapSite[i]==1 || HapSite[i]==2) ? 1 : 0;
      int IndelCnt = 0;/* count of current number of Indels (count consecutive Indels seperated by HapSite[i]==0 as one) */
      for(int i = 0; i <= n; i++){
	int h = HapSite[i];
	if(i==0 || h == 3){
	  double HapDeltaMerge = HapDelta[i];
	  int t = i;
	  for(; ++t <= n; ){
	    if(HapSite[t] == 3)
	      break;
	    HapDeltaMerge += HapDelta[t];
	  }
	  IndelCnt += (fabs(HapDeltaMerge) >= MIN_INDEL_SIZE) ? 1 : 0;
	  if(VERB>=2 && rverb && fabs(HapDeltaMerge) >= MIN_INDEL_SIZE){
	    printf("repositionH:Indel at Hcuts[%d..%d]:HapSite[]=%d,%d, HapDelta[]=%0.4f (HapDelta[%d]=%0.4f)\n",i,t,HapSite[i],HapSite[t],HapDeltaMerge,i,HapDelta[i]);
	    fflush(stdout);
	  }
	  //	    if(DEBUG && fabs(HapDeltaMerge) >= MIN_INDEL_SIZE && 1 <= i && t <= n) assert(HapDelta[i] != 0.0);
	}
      }

      if(VERB>=2 || !(SNPcnt == origSNPcnt && IndelCnt == origIndelCnt)){
	printf("After re-indexing HapSite[] and HapDelta[]:n=%d,SNPs=%d,Indels=%d:(origSNPs=%d,origIndels=%d)\n",
	       n,SNPcnt,IndelCnt,origSNPcnt,origIndelCnt);
	for(int i = 1; i <= n; i++)
	  if((origHapDelta[i] && origHapSite[i]) || origHapSite[i]==3)
	    printf("origHapDelta[%d]=%0.6f,origHapSite[i]=%d\n",i,origHapDelta[i],origHapSite[i]);
	for(int i = 1; i <= n; i++)
	  if((HapDelta[i] && HapSite[i]) || HapSite[i]==3)
	    printf("HapDelta[%d]=%0.6f,HapSite[i]=%d\n",i,HapDelta[i],HapSite[i]);
	fflush(stdout);
      }
      if(DEBUG) assert(SNPcnt == origSNPcnt);
      if(DEBUG) assert(IndelCnt == origIndelCnt);
    }

    /* Now map each site addloc[0..addcnt-1].loc to Hcuts[i=1..addcnt] and pad Hcuts[addcnt+1 .. n] (if needed) to all equal Hcuts[addcnt] and have HapSite[i] == 0 */
    if(VERB/* HERE >=2 */){
      printf("addcnt=%d,n=%d:addloc[0].loc=%0.4f,addloc[addcnt-1].loc=%0.4f\n",addcnt,n,addloc[0].loc,addloc[addcnt-1].loc);
      fflush(stdout);
    }
    p = addloc;

#pragma novector
    for(int t = 0; t < addcnt; t++, p++){
      Hcuts[t+1] = p->loc;
      if(DEBUG/* HERE HERE >=2 */) assert(p->i <= -3 || p->i >= 0);

      if(p->i < 0){/* unaligned site */
	int i = (p->i < -4) ? p->i + 2 : p->i;
	if(DEBUG) assert(HapSite[t+1]==0);
	Hdel1[t+1] = Hdel2[t+1] = 1;
	if(DEBUG && !(i== -3 || i== -4)){
	  printf("t=%d,addcnt=%d:addloc[t].i= %d, p->i= %d, i= %d\n",t,addcnt,addloc[t].i,p->i, i);
	  fflush(stdout);
	  assert(i== -3 || i== -4);
	}

	if(i== -3){
	  if(DEBUG && !(map1[p->m][p->J] < 0)){
	    printf("t=%d/%d:loc=%0.4f,i=%d,m=%d,J=%d:HapSite[t+1]=%d,map1[m][J]=%d,map2[m][J]=%d\n",
		   t,addcnt,p->loc,p->i,p->m,p->J,HapSite[t+1],map1[p->m][p->J],map2[p->m][p->J]);
	    fflush(stdout);
	    assert(map1[p->m][p->J] < 0);/* set in above remap loop */
	  }
	  map1[p->m][p->J] = t+1;
	  mapK1[p->m][p->J] = 0;
	  if(MDEBUG_M > 0 && MDEBUG_M == p->m && rverb){
            printf("Remapping map1[%d][%d] to addloc[%d] : Hcuts[%d] = %0.4f, X[%d][%d] = %0.4f\n", p->m, p->J, t, t+1, p->loc, p->m, p->J, X[p->m][p->J]);
	    fflush(stdout);
          }
	} else {
	  if(DEBUG) assert(map2[p->m][p->J] < 0);/* set in above remap loop */
	  map2[p->m][p->J] = t+1;
	  mapK2[p->m][p->J] = 0;
	}
      } else {
	if(DEBUG) assert(HapSite[t+1] == p->m);
	Hdel1[t+1] = (HapSite[t+1] & 1) ? 0 : 1;
	Hdel2[t+1] = (HapSite[t+1] & 3) ? 0 : 1;
	/* map[],mapK[] has already been remapped for real sites */
      }
    }
    /* padded sites : no labels are mapped to these sites in Hcuts[] and their location matches the rightmost mapped site Hcuts[addcnt] */
    for(int t = addcnt+1; t <= n; t++){
      Hcuts[t] = Hcuts[addcnt];
      Hdel1[t] = Hdel2[t] = 1;
      if(DEBUG) assert(HapSite[t]==0);
    }
    if(Hcuts[n] + MININTERVAL > Hcuts[n+1]){
      if(VERB){
	printf("Enlarging Hcuts[n+1]=%0.4f -> %0.4f, Hcuts[n]=%0.4f\n",Hcuts[n+1],Hcuts[n]+MININTERVAL, Hcuts[n]);
	fflush(stdout);
      }
      //	assert(Hcuts[n] < Hcuts[n+1] * 1.10 + 1.0);
      Hcuts[n+1] = Hcuts[n] + MININTERVAL;
    }

    if(DEBUG>=2){
      for(int i = 1; i <= n+1; i++){
	if(DEBUG && !(Hcuts[i] >= Hcuts[i-1])){
	  printf("i=%d:Hcuts[i-1]=%0.6f,Hcuts[i]=%0.6f\n",i,Hcuts[i-1],Hcuts[i]);
	  fflush(stdout);
	  assert(Hcuts[i] >= Hcuts[i-1]);
	}
      }
    }

    if(DEBUG>=2){
      for(int i = 1; i <= n; i++){
	if(Hremap[i] < 0){
	  assert(origHapSite[i]==0);
	  continue;
	}
	int ni = Hremap[i];
	assert(1 <= ni && ni <= n);
	if(!(fabs(origHcuts[i] + Rshift - Hcuts[ni]) < 1e-10 && HapSite[ni]) ||
	   !(Hdel1[ni] == ((HapSite[ni] & 1) ? 0 : 1)) || !(Hdel2[ni] == ((HapSite[ni] & 3) ? 0 : 1))){
	  printf("i=%d:Hremap[i]=ni=%d,origHcuts[i]=%0.10f,origHapSite[i]=%d,Rshift=%0.10f,Hcuts[ni]=%0.10f,HapSite[ni]=%d,Hdel1[ni]=%d,Hdel2[ni]=%d\n",
		 i,ni,origHcuts[i],origHapSite[i],Rshift,Hcuts[ni],HapSite[ni],Hdel1[ni],Hdel2[ni]);
	  fflush(stdout);
	  assert(fabs(origHcuts[i] + Rshift - Hcuts[ni]) < 1e-10);
	  assert(HapSite[ni]);
	  assert(Hdel1[ni] == ((HapSite[ni] & 1) ? 0 : 1));
	  assert(Hdel2[ni] == ((HapSite[ni] & 3) ? 0 : 1));
	}
      }
    }

    /* update map1[MD],nmap1[MD] */
    double *newY1 = new double[n+2];
    double *newY2 = new double[n+2];
    int newN1,newN2;
    if(VERB && rverb){
      printf("Calling hsetmap() to update map1[MD],nmap1[MD]\n");
      fflush(stdout);
    }
    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,newN1,newN2,newY1,newY2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);
    if(VERB>=2 && rverb){
      int cnt1 = 0, cnt2 = 0;
      for(int i = 0; i <= n; i++){
	if(HapSite[i] || HapDelta[i] || Delta[i]){
	  cnt1 += 1-Hdel1[i];
	  cnt2 += 1-Hdel2[i];
	  printf("i=%d:Hcuts[i]=%0.6f,HapSite[i]=%d,Hdel1[i]=%d,Hdel2[i]=%d,Hcuts1[i]=%0.6f,Hcuts2[i]=%0.6f,HapDelta[i]=%0.4f,Delta[i]=%0.4f,I1=%d,I2=%d,Y1[I1]=%0.6f,newY1[I1]=%0.6f,Y2[I2]=%0.6f,newY2[I2]=%0.6f\n",
		 i,Hcuts[i],HapSite[i],Hdel1[i],Hdel2[i],Hcuts1[i],Hcuts2[i],HapDelta[i],Delta[i],cnt1,cnt2,Y1[cnt1],newY1[cnt1],Y2[cnt2],newY2[cnt2]);
	}
      }
      printf("n=%d:Hcuts[n+1]=%0.6f,Hcuts1[n+1]=%0.6f,Hcuts2[n+1]=%0.6f,N1=%d,N2=%d,Y1[N1+1]=%0.6f,newY1[N1+1]=%0.6f,Y2[N2+1]=%0.6f,newY2[N2+1]=%0.6f,Rshift=%0.6f\n",
	     n, Hcuts[n+1],Hcuts1[n+1],Hcuts2[n+1],newN1,newN2,Y1[newN1+1],newY1[newN1+1],Y2[newN2+1],newY2[newN2+1],Rshift);
      fflush(stdout);
    }

    if(DEBUG){
      assert(newN1 == N1);
      for(int I = 1; I <= N1; I++){
	if(!(fabs(Y1[I]+Rshift - newY1[I]) < 1e-7 + cumshift)){
	  printf("WARNING:repositionH:I=%d,N1=%d:Y1[I]=%0.10f,Rshift=%0.10f,newY1[I]=%0.10f(err=%0.10f),cumshift=%0.10f\n",
		 I,N1,Y1[I],Rshift,newY1[I],newY1[I]-(Y1[I]+Rshift),cumshift);
	  fflush(stdout);
	  // HERE assert(fabs(Y1[I]+Rshift - newY1[I]) < 1e-6);
	}
      }
      if(!(newY1[N1+1] >= Y1[N1+1]+Rshift - (1e-7 + cumshift))){
	printf("WARNING:repositionH:N1=%d:Y1[N1+1]=%0.10f,Rshift=%0.10f,newY1[N1+1]=%0.10f,cumshift=%0.10f\n",
	       N1,Y1[N1+1],Rshift,newY1[N1+1],cumshift);
	fflush(stdout);
	// HERE assert(newY1[N1+1] >= Y1[N1+1]+Rshift - 1e-6);
      }
    }
    for(int I = 1; I <= N1+1; I++)
      Y1[I] = newY1[I];

    if(DEBUG/* HERE */>=2){
      assert(newN2 == N2);
      for(int I = 1; I <= N2; I++)
	assert(fabs(Y2[I]+Rshift - newY2[I]) < 1e-8 + cumshift);
      assert(newY2[N2+1] >= Y2[N2+1]+Rshift - (1e-8 + cumshift));
    }
    for(int I = 1; I <= N2+1; I++)
      Y2[I] = newY2[I];

    if(DEBUG){
      for(int i = 1; i <= n+1; i++){
	if(DEBUG && !(Hcuts[i] >= Hcuts[i-1])){
	  printf("i=%d:Hcuts[i-1]=%0.6f,Hcuts[i]=%0.6f,n=%d\n",i,Hcuts[i-1],Hcuts[i],n);
	  fflush(stdout);
	  assert(Hcuts[i] >= Hcuts[i-1]);
	}
      }
    }
    if(VERB/* HERE >=2 */){
      printf("n=%d,Hcuts[n]=%0.6f,Hcuts[n+1]=%0.6f,N1=%d,N2=%d,Y1[N1,N1+1]=%0.6f,%0.6f,Y2[N2,N2+1]=%0.6f,%0.6f\n",n,Hcuts[n],Hcuts[n+1],N1,N2,Y1[N1],Y1[N1+1],Y2[N2],Y2[N2+1]);
      fflush(stdout);
    }

    delete [] newY1;
    delete [] newY2;
    delete [] origHapSite;
    delete [] origHapDelta;
    delete [] origDelta;
    delete [] origHcuts;

    if(DEBUG && !(Hcuts[n] <= Hcuts[n+1])){
      printf("n=%d:Hcuts[n]=%0.4f,Hcuts[n+1]=%0.4f\n",n,Hcuts[n],Hcuts[n+1]);
      fflush(stdout);
      assert(Hcuts[n] <= Hcuts[n+1]);
    }

    if(Rendi > 0){/* recompute Lendi, Rendi */
      int startLendi = Lendi, startRendi = Rendi;
      if(DEBUG) assert(Rendi >= Lendi);
      Lendi = 0; Rendi = n+1;
      for(int i = 0; i <= n+1; i++){
	if(fabs(Lend - Hcuts[i]) < fabs(Lend - Hcuts[Lendi]))
	  Lendi = i;
	if(fabs(Rend - Hcuts[i]) < fabs(Rend - Hcuts[Rendi]))
	  Rendi = i;
      }
      if(VERB/* HERE  >=2 */ || (DEBUG && !(Rendi != 0 && Rendi > Lendi))){
	printf("Lendi=%d -> %d (%0.6f -> %0.6f), Rendi=%d -> %d (%0.6f -> %0.6f),n=%d,Hcuts[n+1]=%0.6f\n",
	       startLendi,Lendi,Lend,Hcuts[Lendi],startRendi,Rendi,Rend,Hcuts[Rendi],n,Hcuts[n+1]);
	fflush(stdout);

	if(DEBUG) assert(Rendi != 0 && Rendi > Lendi);
      }
    }
    if(Rfrozen > 0){ /* recompute Lfrozen, Rfrozen */
      int startLfrozen = Lfrozen, startRfrozen = Rfrozen;
      if(DEBUG) assert(Rfrozen >= Lfrozen);
      Lfrozen = Rfrozen = 0;
      for(int i = 0; i <= n+1; i++){
	if(fabs(left - Hcuts[i]) < fabs(left - Hcuts[Lfrozen]))
	  Lfrozen = i;
	if(fabs(right - Hcuts[i]) < fabs(right - Hcuts[Rfrozen]))
	  Rfrozen = i;
      }
      if((VERB/* HERE >=2 */ /* && !(startLfrozen == Lfrozen && startRfrozen == Rfrozen)*/) || (DEBUG && !(Rfrozen != 0 && Rfrozen > Lfrozen))){
	printf("Lfrozen=%d -> %d,Rfrozen=%d ->%d,left=%0.7f,right=%0.7f,Hcuts[Lfrozen]=%0.7f,Hcuts[Rfrozen]=%0.7f,n=%d:\n",
	       startLfrozen,Lfrozen,startRfrozen,Rfrozen,left,right,Hcuts[Lfrozen],Hcuts[Rfrozen],n);
	fflush(stdout);
      }
      if(DEBUG && (!(Rfrozen != 0 && Rfrozen >= Lfrozen) || !(fabs(left-Hcuts[Lfrozen]) < 0.002 && fabs(right-Hcuts[Rfrozen]) < 0.002))){
	for(int i = 0; i <= n+1; i++)
	  printf("i=%d:Hcuts[i]=%0.6f, HapSite[i]=%d\n",i,Hcuts[i],HapSite[i]);
	printf("Rfrozen=%d,Lfrozen=%d,left=%0.6f,Hcuts[Lfrozen]=%0.6f,right=%0.6f,Hcuts[Rfrozen]=%0.6f,n=%d,Hcuts[n+1]=%0.6f\n",
	       Rfrozen,Lfrozen,left,Hcuts[Lfrozen],right,Hcuts[Rfrozen],n,Hcuts[n+1]);
	fflush(stdout);
	assert(Rfrozen != 0 && Rfrozen >= Lfrozen);
	assert(fabs(left-Hcuts[Lfrozen]) < 0.002);
	assert(fabs(right-Hcuts[Rfrozen]) < 0.002);
      }
      //      Lfrozeni = Lfrozen;
      //      Rfrozeni = Rfrozen;
    }
    if(origRfrozen > 0){ /* recompute origLfrozen, origRfrozen */
      int startRfrozen = origRfrozen;
      int startLfrozen = origLfrozen;

      if(DEBUG) assert(origRfrozen > 0 && origRfrozen >= origLfrozen);
      origLfrozen = origRfrozen = 0;
      for(int i = 0; i <= n+1; i++){
	if(fabs(origleft - Hcuts[i]) < fabs(origleft - Hcuts[origLfrozen]))
	  origLfrozen = i;
	if(fabs(origright - Hcuts[i]) < fabs(origright - Hcuts[origRfrozen]))
	  origRfrozen = i;
      }
      if((VERB/* HERE >=2 */ /* && !(startLfrozen == origLfrozen && startRfrozen == origRfrozen)*/) || 
	 (DEBUG && (!(origRfrozen != 0 && origRfrozen >= origLfrozen) || !(fabs(origleft-Hcuts[origLfrozen]) < 0.002 && fabs(origright-Hcuts[origRfrozen]) < 0.002)))){
	printf("origLfrozen=%d -> %d,origRfrozen=%d ->%d,origleft=%0.7f,origright=%0.7f,Hcuts[origLfrozen]=%0.7f,Hcuts[origRfrozen]=%0.7f,n=%d:\n",
	       startLfrozen,origLfrozen,startRfrozen,origRfrozen,origleft,origright,Hcuts[origLfrozen],Hcuts[origRfrozen],n);
	if(DEBUG && (!(origRfrozen != 0 && origRfrozen > origLfrozen) || !(fabs(origleft-Hcuts[origLfrozen]) < 0.002 && fabs(origright-Hcuts[origRfrozen]) < 0.002))){
	  for(int i = 0; i <= n+1; i++)
	    printf("i=%d:Hcuts[i]=%0.6f,HapSite[i]=%d\n",i,Hcuts[i],HapSite[i]);
	}
	fflush(stdout);
	if(DEBUG) assert(origRfrozen > 0 && origRfrozen >= origLfrozen);
	if(DEBUG) assert(fabs(origleft-Hcuts[origLfrozen]) < 0.002 && fabs(origright-Hcuts[origRfrozen]) < 0.002);
      }
    }

    if(VERB/* HERE >=2 */){
      printf("Re-positioned %d unaligned sites in Hcuts[]\n",addcnt);
      fflush(stdout);
    }

    delete [] addloc;

    if(DEBUG>=2){/* make sure map[] and mapK[] are consistent */
      for(int m = 0; m < MD; m++){
	//	if(TBmapWT[m] <= 0.0)
	//	  continue;
	int M = MX[m];

	int lastJ = -1, lasti = -1, lastk = -1, i, k, I;

	for(int J = 1; J <= M; J++){
	  if((i = map1[m][J]) > 0 && (I = map1[MD][i]) > 0){
	    k = mapK1[m][J];
	    assert(0 <= k && k < i);
	    if(k > 0 && map1[MD][i-k] < 0)/* locally "clean up" mapK */
	      k = 0;
	    if(lasti >= 0 && !(i-k > lasti)){
              printf("map1:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d (map1[MD][i]=%d,map1[MD][i-k]=%d)\n",m,J,i,k,lastJ,lasti,lastk,map1[MD][i],map1[MD][i-k]);
	      for(int j = 1; j <= M; j++){
		int ni,nk;
		if((ni = map1[m][j]) > 0){
		  nk = mapK1[m][j];
		  printf("m=%d:J=%d,M=%d:map1[m][J]=i=%d,mapK1[m][J]=k=%d,X[m][J]=%0.4f,Hcuts[i]=%0.4f,Hcuts[i-k]=%0.4f,Hdel1[i,i-k]=%d,%d,map1[MD][i]=%d,map1[MD][i-k]=%d\n",
			 m,j,M,map1[m][j],mapK1[m][j],X[m][j],Hcuts[ni],Hcuts[ni-nk],Hdel1[ni],Hdel1[ni-nk],map1[MD][ni],map1[MD][ni-nk]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
        }
	
	lastJ = -1, lasti = -1, lastk = -1;
	for(int J = 1; J <= M; J++){
	  //	  if(TBmapWT[m] <= 0.0)
	  //	    continue;
	  if((i = map2[m][J]) > 0 && (I = map2[MD][i]) > 0){
	    k = mapK2[m][J];
	    assert(0 <= k && k < i);
	    if(k > 0 && map2[MD][i-k] < 0)/* locally "clean up" mapK */
	      k = 0;
	    if(lasti >= 0 && !(i-k > lasti)){
              printf("map2:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d (map2[MD][i]=%d,map2[MD][i-k]=%d)\n",m,J,i,k,lastJ,lasti,lastk,map2[MD][i],map2[MD][i-k]);
	      for(int j = 1; j <= M; j++){
		int ni,nk;
		if((ni = map2[m][j]) > 0){
		  nk = mapK2[m][j];
		  printf("m=%d:J=%d,M=%d:map2[m][J]=i=%d,mapK2[m][j]=k=%d,X[m][J]=%0.4f,Hcuts[i]=%0.4f,Hcuts[i-k]=%0.4f,Hdel2[i,i-k]=%d,%d,map2[MD][i]=%d,map2[MD][i-k]=%d\n",
			 m,j,M,map2[m][j],mapK2[m][j],X[m][j],Hcuts[ni],Hcuts[ni-nk],Hdel2[ni],Hdel2[ni-nk],map2[MD][ni],map2[MD][ni-nk]);
		}
	      }
	      fflush(stdout);
	      assert(i-k > lasti);
	    }
	    lasti = i;
	    lastk = k;
	    lastJ = J;
	  }
        }
      }
    }
  }

  //  rverb = origrverb;

  /* recompute imin,imax */
  imin = max(1,Lendi);
  imax = Rendi ? min(Rendi,n) : n;
  if(DEBUG) assert(extendonly <= 0);/* Haplotyping not supported with -extendonly */
  if(Rfrozen > 0 && Lfrozen < Rfrozen && extend <= 1){
    imin = max(1,Lfrozen);
    imax = min(n,Rfrozen);
  }

  if(DEBUG && !(Hcuts[n] <= Hcuts[n+1])){
    printf("n=%d:Hcuts[n]=%0.4f,Hcuts[n+1]=%0.4f\n",n,Hcuts[n],Hcuts[n+1]);
    fflush(stdout);
    assert(Hcuts[n] <= Hcuts[n+1]);
  }

  /* recompute skip[] values */
  int skipcnt = 0;
  for(int i = 0; i <= n+1; i++)
    skip[i] = 0;

  if(SKIP_DIST_FIX){// Use method in skip_sites() that can handle more than 2 coincident labels in a row
    if(1 /* HERE SKIP_DIST <= 0.0 */){/* If SKIP_DIST > 0.0, skip_sites() will take care of coincident labels, if SKIP_DIST_FIX >= 1 */
      int j = 1;
      for(; j <= n; j++)
	if(!skip[j])
	  break;

      for(int i=j+1; i <= n; i++){
	if(HapSite[i]){
	  if(Hcuts[i] <= Hcuts[j] + 1e-6 && !HapSite[j]){
	    if(VERB>=2){
	      printf("repositionH:skipping site %d (Hcuts[%d,%d]=%0.4f,%0.4f) as duplicate site\n",j, j, i, Hcuts[j], Hcuts[i]);
	      fflush(stdout);
	    }
	    skip[j] = 1;
	    skipcnt++;
	  }

	  j = i;
	  continue;
	}

	if(Hcuts[i] <= Hcuts[j] + 1e-6){
	  if(VERB>=2){
	    printf("repositionH:skipping site %d (Hcuts[%d,%d]=%0.4f,%0.4f) as duplicate site\n",i, j, i, Hcuts[j], Hcuts[i]);
	    fflush(stdout);
	  }
	  skip[i] = 1;
	  skipcnt++;
	  continue;
	}

	j = i;
      }
    }

  } else {// SKIP_DIST_FIX == 0 : older algorithm, does not correctly handle 3 or more coincident labels

    for(int i = 2; i <= n; i++){
      if(DEBUG/* HERE >=2 */) assert(Hcuts[i] >= Hcuts[i-1] && (Hcuts[i] > Hcuts[i-1] || !(HapSite[i] & HapSite[i-1])));
      if(Hcuts[i] <= Hcuts[i-1] && !skip[i] && !skip[i-1]){
	if(DEBUG && !(!HapSite[i] || !HapSite[i-1])){
	  printf("WARNING:i=%d,n=%d,Hcuts[i-1]=%0.6f,Hcuts[i]=%0.6f,HapSite[i-1]=%d,HapSite[i]=%d (changing HapSite[i-1] to 3, HapSite[i] to 0))\n",i,n,Hcuts[i-1],Hcuts[i],HapSite[i-1],HapSite[i]);
	  printf("\tDelta[i-1]=%0.4f,Delta[i]=%0.4f,HapDelta[i-1]=%0.4f,HapDelta[i]=%0.4f\n",Delta[i-1],Delta[i],HapDelta[i-1],HapDelta[i]);
	  fflush(stdout);
	  assert(!(HapSite[i] & HapSite[i-1]));
	  //	assert(!HapSite[i] || !HapSite[i-1]);
	}
	if(!HapSite[i])
	  skip[i] = 1;
	else if(!HapSite[i-1])
	  skip[i-1] = 1;
	if(skip[i] || skip[i-1]){
	  skipcnt++;
	  if(VERB>=2){
	    printf("repositionH:skipping site %d (%0.4f,%0.4f) as duplicate site\n",!HapSite[i] ? i : i-1, Hcuts[i-1],Hcuts[i]);
	    fflush(stdout);
	  }
	}
      }
    }
  }

  if(VERB /* >=2 */){
    printf("n=%d: skipping %d duplicate sites\n",n,skipcnt);
    fflush(stdout);
  }
  if(extend && Refine >= 2 && Rfrozen > Lfrozen){
    if(extendonly){/* block any changes to sites in the non-extension region */
      if(DEBUG) assert(extend >= 2);
      int L = Lfrozen,R = Rfrozen;
      if(VERB)
	skipcnt = 0;
#if 0 // WAS excluding regions outside the first and last site in this region ???
      for(; L < Rfrozen;L++)
	if(HapSite[L])
	  break;
      for(; R > L;R--)
	if(HapSite[R])
	  break;
#endif
      for(int i = L; i <= R; i++){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.4f in non-extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
      }
      if(VERB/* >=2 */ && skipcnt){
	printf("n=%d: Blocking %d sites in non-extension region due to -extendonly\n",n,skipcnt);
	fflush(stdout);
      }
      if(Rendi > 0){/* permanantly block any changes to sites outside of Hcuts[Lendi .. Rendi] */
	int origskipcnt = skipcnt;
	for(int i = 0; i < Lendi; i++){
	  if(VERB)
	    skipcnt += (skip[i] ? 0 : 1);
	  if(VERB>=2 && !skip[i]){
	    printf(" Blocking Hcuts[%d]=%0.3f in left extension region due to -EndTrim %0.2f -maxExtend %0.3f\n",i,Hcuts[i],EndTrimCov,MaxExtend);
	    fflush(stdout);
	  }
	  skip[i] = 2;
	  //	  if(DEBUG) assert(Hdel[i]);
	}
	for(int i = Rendi; ++i <= n; ){
	  if(VERB)
	    skipcnt += (skip[i] ? 0 : 1);
	  if(VERB>=2 && !skip[i]){
	    printf(" Blocking Hcuts[%d]=%0.3f in right extension region due to -EndTrim %0.2f -maxExtend %0.3f\n",i,Hcuts[i],EndTrimCov,MaxExtend);
	    fflush(stdout);
	  }
	  skip[i] = 2;
	  //	  if(DEBUG) assert(Hdel[i]);
	}
	if(VERB/* >=2 */ && skipcnt > origskipcnt){
	  printf("n=%d: Blocking %d sites in extension region due to -EndTrim %0.2f -maxExtend %0.3f\n",n,skipcnt-origskipcnt,EndTrimCov,MaxExtend);
	  fflush(stdout);
	}
      }
    }
    if(extend <= 1){ /* block any changes to sites in the extension region */
      if(VERB)
	skipcnt = 0;
      for(int i = 0; i < Lfrozen; i++){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.4f in extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
	//	if(DEBUG) assert(Hdel[i]);
      }
      for(int i = Rfrozen; ++i <= n; ){
	if(VERB)
	  skipcnt += (skip[i] ? 0 : 1);
	if(VERB>=2 && !skip[i]){
	  printf(" Blocking Hcuts[%d]=%0.4f in extension region\n",i,Hcuts[i]);
	  fflush(stdout);
	}
	skip[i] = 2;
	//	if(DEBUG) assert(Hdel[i]);
      }
      if(VERB/* >=2 */ && skipcnt){
	printf("n=%d: Blocking %d sites in extension region due to -extend %d\n",n,skipcnt,extend);
	fflush(stdout);
      }
    }
  }

  int *Hdel = new int[n+1];
  for(int i = 1; i <= n; i++)
    Hdel[i] = HapSite[i] ? 0 : 1;
  skip_sites(n,skip,Hdel,Hcuts);

  if(DEBUG>=2 && !(Hcuts[n] <= Hcuts[n+1])){
    printf("n=%d:Hcuts[n]=%0.4f,Hcuts[n+1]=%0.4f\n",n,Hcuts[n],Hcuts[n+1]);
    fflush(stdout);
    assert(Hcuts[n] <= Hcuts[n+1]);
  }

  if(VERB>=2){
    printf("reposition():Potential add sites:\n");
    for(int i = 1; i <= n; i++)
      if(Hdel[i] && !skip[i])
	printf("Hcuts[%d]=%0.4f\n",i,Hcuts[i]);
    fflush(stdout);
  }
  delete [] Hdel;
  delete [] shift;

  return cumshift;
}

//static int ReversalWarning = 0;

static int *gDELTA_RANGE = NULL;
static double **gInitial_Delta = NULL;

class CLabel {
public:
  int i;
  int Allele;/* same as HapSite[i], except that for i==R it is either 1 or 2, rather than HapSite[R]==3 */
  double loc;/* distance from Hcuts[L] of same allele */
  double frac;/* fraction of interval covered along current Allele */
};

#if 0
/* qsort() intcmp function to sort CLabel array in increasing order of loc */
static inline int CLabelLocInc(CLabel *p1, CLabel *p2)
{
  return (p1->loc > p2->loc) ? 1 : (p1->loc < p2->loc) ? -1 : 0;
}
#endif

/* qsort() intcmp function to sort CLabel array in increasing order of frac */
static inline int CLabelFracInc(CLabel *p1, CLabel *p2)
{
  return (p1->frac > p2->frac) ? 1 : (p1->frac < p2->frac) ? -1 : 0;
}

/* Redistribute HapDelta[] and Delta[] across Hcuts[L..R] so Hcuts1[],Hcuts2[] are monotonic, without changing underlying Allele maps Y1,Y2
   May require reordering labels in Hcuts[L..R] with matching changes in HapSite[L..R].

   Returns Hremap[L..R], a mapping from the original Hcuts[] to the new Hcuts[] that can be used to correct map[m][J] values.

   returns 1 if proposed HapDelta[] is invalid (can happen rarely when two valid changes are combined in the same iteration)
 */
static int HapDeltaSpread(int n, int L, int R, double *HapDelta, double *Delta, double *Hcuts, int *HapSite, CLabel *Label, int *Index, int *Hremap)
{
  if(Hremap)
    for(int i = L; i <= R; i++)
      Hremap[i] = i;

  if(L < 1 || R > n)// handle by temporarily setting HapSite[0] == HapSite[n+1] = 3
    HapSite[0] = HapSite[n+1] = 3;

  if(DEBUG && !(HapSite[L] == 3 && HapSite[R] == 3)){
    printf("HapDeltaSpread:L=%d,R=%d,HapSite[L,R]=%d,%d,Hcuts[L,R]=%0.4f,%0.4f\n",L,R,HapSite[L],HapSite[R],Hcuts[L],Hcuts[R]);
    fflush(stdout);
    assert(HapSite[L] == 3 && HapSite[R] == 3);
  }
  if(DEBUG && !(0 <= L && L < R && R <= n+1)){
    printf("HapDeltaSpread:L=%d,R=%d,n=%d,HapSite[L,R]=%d,%d,Hcuts[L,R]=%0.4f,%0.4f\n",L,R,n,HapSite[L],HapSite[R],Hcuts[L],Hcuts[R]);
    fflush(stdout);
    assert(0 <= L && L < R && R <= n+1);
  }

  /* compute total of HapDelta values in interval L..R */
  double HapIndelMerge = 0.0;
  for(int i = L; i < R; i++){
    if(DEBUG && i > L && HapSite[i] && HapSite[i]==3){
      for(int t = L; t <= R; t++)
	if(t==L || t==R || HapSite[t] || HapDelta[t] || Delta[t])
	  printf("t=%d:HapSite[t]=%d,Hcuts[t]=%0.4f,HapDelta[t]=%0.4f,Delta[t]=%0.4f\n",t,HapSite[t],Hcuts[t],HapDelta[t],Delta[t]);
      printf("\t i=%d:HapSite[i]=%d\n",i,HapSite[i]);
      fflush(stdout);
      assert(HapSite[i] != 3);
    }
    if(HapDelta[i]){
      if(DEBUG) assert(HapSite[i] != 0);
      HapIndelMerge += HapDelta[i];
    }
  }
 
  if(VERB>=2 && rverb){
    printf("HapDeltaSpread():Labels in Hcuts[%d..%d]= %0.6f..%0.6f before spreading out HapIndel total = %0.6f:\n",L,R,Hcuts[L],Hcuts[R],HapIndelMerge);
    fflush(stdout);
  }

  /* first accumulate all actual labels right of Hcuts[L] with distances measured from left end, until Hcuts[R] on both Alleles is hit */
  double fragsum = 0.0;

  double loc1 = 0.0, loc2 = 0.0;/* distance from Hcuts[L] to Hcuts[ip] on 1st and 2nd Allele respectively */
  int lcnt = 0, ip;
  CLabel *p = &Label[lcnt++];
  p->i = ip = L;
  p->loc = 0.0;
  p->Allele = 3;
  for(int i = L+1; i <= R; i++){
    if(!HapSite[i]){
      if(DEBUG) assert(Delta[i]==0.0 && HapDelta[i]==0.0);
      continue;
    }
    if(DEBUG) assert(lcnt < R-L+1);
    CLabel *p = &Label[lcnt];

    /* process interval Hcuts[ip .. i] */
    double Hdelta = HapDelta[ip];
    double frag = Hcuts[i] - Hcuts[ip] + Delta[ip];
    fragsum += frag;
    loc1 += frag + Hdelta;
    loc2 += frag - Hdelta;
    if(VERB>=2 && rverb){
      printf("ip=%d,i=%d,L=%d,R=%d:HapDelta[ip]=%0.6f,Delta[ip]=%0.6f,Hcuts[ip]=%0.6f,Hcuts[i]-Hcuts[ip]=%0.6f,loc1=%0.6f,loc2=%0.6f,HapSite[i]=%d\n",
	     ip,i,L,R,HapDelta[ip],Delta[ip],Hcuts[ip],Hcuts[i]-Hcuts[ip],loc1,loc2,HapSite[i]);
      fflush(stdout);
    }
    p->i = ip = i;
    if(i == R){
      if(DEBUG) assert(HapSite[i] == 3);
      if(loc1 < loc2){
	p->Allele = 1;
	p->loc = loc1;
	p[1].i = i;
	p[1].Allele = 2;
	p[1].loc = loc2;
      } else {
	p->Allele = 2;
	p->loc = loc2;
	p[1].i = i;
	p[1].Allele = 1;
	p[1].loc = loc1;
      }
    } else {
      if(DEBUG && !(lcnt < R-L && 1 <= HapSite[i] && HapSite[i] <= 2)){
	printf("lcnt=%d,L=%d,R=%d:i=%d,HapSite[i]=%d,HapSite[L]=%d,HapSite[R]=%d\n",
	       lcnt,L,R,i,HapSite[i],HapSite[L],HapSite[R]);
	fflush(stdout);

	assert(lcnt < R-L);
	assert(1 <= HapSite[i] && HapSite[i] <= 2);
      }
      p->Allele = HapSite[i];
      p->loc = (HapSite[i]==1) ? loc1 : loc2;
    }
    lcnt++;
  }
  lcnt++;
  double len1 = loc1, len2 = loc2;/* lengths of Allele1 and Allele2 for interval Hcuts[L..R] */

  if(DEBUG) assert(lcnt <= R-L+2);
  if(DEBUG) assert(Label[lcnt-1].i == R && Label[lcnt-2].i == R);
  if(DEBUG) assert(len1 > 0.0 && len2 > 0.0);

  /* spread out total HapIndel (HapIndelMerge) over all intervals */

  for(int t = 0; t < lcnt; t++)
    Index[t] = Label[t].i;

  Label[0].frac = 0.0;
  Label[lcnt-1].frac = Label[lcnt-2].frac = 1.0;

  for(int t = 1; t < lcnt-2; t++){    /* update relative location of Label[t] */
    CLabel *q = &Label[t];
    if(DEBUG) assert(1 <= q->Allele && q->Allele <= 2);

    if(q->Allele == 1)
      q->frac = q->loc / len1;
    else
      q->frac = q->loc / len2;

    if(q->frac >= 1.0 || q->frac <= 0.0){
      if(VERB){
	printf("Invalid Delta or HapDelta values (Possible due to combination of two valid Delta or HapDelta values)\n");
	fflush(stdout);
      }
      HapSite[0] = HapSite[n+1] = 0;
      return 1;
    }
  }

  /* sort relative locations of internal Label[1..lcnt-3] based on frac */
  if(lcnt-3 > 1)
    qsort(&Label[1], lcnt-3, sizeof(CLabel), (intcmp *)CLabelFracInc);

  if(VERB && rverb){
    printf("New Label ordering:\n");
    for(int r = 0; r < lcnt; r++){
      int i = Label[r].i;
      int ni = Index[r];
      if(1 <= r && r < lcnt-2 && i != ni)
	printf("Label[%d].i=%d -> %d, Allele=%d, frac=%0.10f, loc=%0.6f: Hcuts[i]=%0.6f,HapSite[i]=%d -> %d\n",
	       r,i,ni,Label[r].Allele,Label[r].frac,Label[r].loc, Hcuts[ni], HapSite[ni], Label[r].Allele);
      else
	printf("Label[%d]:i=%d, Allele=%d, frac=%0.10f, loc=%0.6f:Hcuts[i]=%0.6f,HapSite[i]=%d\n",
	       r,i,Label[r].Allele,Label[r].frac,Label[r].loc,Hcuts[i],HapSite[i]);
    }
  }

  /* remap internal Labels Label[1..lcnt-3].i in ascending order of frac */
  for(int t = 1; t < lcnt-2; t++){
    int i = Label[t].i;
    int ni = Index[t];
    HapSite[ni] = Label[t].Allele;
    Label[t].i = ni;
    if(Hremap){
      if(DEBUG) assert(Hremap[i] > 0);
      Hremap[i] = ni;
    }
  }

  /* recompute HapDelta[] and Delta[] for internal intervals */
  loc1 = loc2 = 0.0;
  ip = L;

  for(int t = 1; t < lcnt-1; t++){
    CLabel *q = &Label[t];
    ip = Label[t-1].i;
    int i = q->i;
    if(DEBUG) assert(1 <= q->Allele && q->Allele <= 2);
    if(DEBUG) assert(i > ip);

    double nloc1 = q->frac * len1;
    double nloc2 = q->frac * len2;

    double nfrag1 = nloc1 - loc1;
    double nfrag2 = nloc2 - loc2;

    if((VERB && rverb) || (DEBUG && !(nloc1 >= loc1 && nloc2 >= loc2))){
      printf("t=%d:ip=%d,i=%d:Hcuts[i]-Hcuts[ip]=%0.6f,HapSite[ip,i]=%d,%d:loc1=%0.6f..%0.6f,loc2=%0.6f..%0.6f,nfrag=%0.6f,%0.6f,len=%0.6f,%0.6f,Delta[ip]=%0.6f -> %0.6f,HapDelta[ip]=%0.6f -> %0.6f\n",
	     t,ip,i,Hcuts[i]-Hcuts[ip],HapSite[ip],HapSite[i],loc1,nloc1,loc2,nloc2,nfrag1,nfrag2,len1,len2,Delta[ip],0.5 * (nfrag1 + nfrag2) - (Hcuts[i] - Hcuts[ip]), HapDelta[ip],0.5 * (nfrag1 - nfrag2));
      fflush(stdout);
    }

    if(DEBUG) assert(nloc1 >= loc1 && (!(HapSite[ip] & HapSite[i]) || nloc1 > loc1));
    if(DEBUG) assert(nloc2 >= loc2 && (!(HapSite[ip] & HapSite[i]) || nloc2 > loc2));

    Delta[ip] = 0.5 * (nfrag1 + nfrag2) - (Hcuts[i] - Hcuts[ip]);
    HapDelta[ip] = 0.5 * (nfrag1 - nfrag2);

    loc1 = nloc1;
    loc2 = nloc2;
  }
	  
  if(fabs(HapIndelMerge) < MIN_INDEL_SIZE)
    for(int i = L; i < R; i++)
      HapDelta[i] = 0.0;

  if(DEBUG >= 1+RELEASE /* HERE >=2 */){
    if(VERB && rverb){
      printf("Labels in Hcuts[%d..%d] after spreading out HapIndel total = %0.6f, len1=%0.4f, len2=%0.4f:\n",L,R,HapIndelMerge, len1,len2);
      fflush(stdout);
    }
    loc1 = loc2 = 0.0;
    lcnt = 0;
    p = &Label[lcnt++];
    p->i = ip = L;
    p->loc = 0.0;
    p->Allele = 3;
    for(int i = L+1; i <= R; i++){
      if(!HapSite[i]){
	if(DEBUG) assert(Delta[i]==0.0 && HapDelta[i]==0.0);
	continue;
      }
      if(DEBUG) assert(lcnt < (R-L+1));
      CLabel *p = &Label[lcnt];
	      
      /* process interval Hcuts[ip .. i] */
      double Hdelta = HapDelta[ip];
      double frag = Hcuts[i] - Hcuts[ip] + Delta[ip];
      fragsum += frag;
      loc1 += frag + Hdelta;
      loc2 += frag - Hdelta;

      if(VERB && rverb){
	printf("ip=%d,i=%d,L=%d,R=%d:HapDelta[ip]=%0.8f,Delta[ip]=%0.4f,Hcuts[ip]=%0.3f,Hcuts[i]-Hcuts[ip]=%0.4f,loc1=%0.4f,loc2=%0.4f,HapSite[i]=%d(frag=%0.8f,Hdelta=%0.8f)\n",
	       ip,i,L,R,HapDelta[ip],Delta[ip],Hcuts[ip],Hcuts[i]-Hcuts[ip],loc1,loc2,HapSite[i],frag,Hdelta);
	fflush(stdout);
      }
      if(DEBUG) assert(frag >= fabs(Hdelta) - 1e-8);

      p->i = ip = i;
      if(i == R){
	if(DEBUG) assert(HapSite[i] == 3);
	if(loc1 < loc2){
	  p->Allele = 1;
	  p->loc = loc1;
	  p[1].i = i;
	  p[1].Allele = 2;
	  p[1].loc = loc2;
	} else {
	  p->Allele = 2;
	  p->loc = loc2;
	  p[1].i = i;
	  p[1].Allele = 1;
	  p[1].loc = loc1;
	}
      } else {
	if(DEBUG) assert(lcnt < R-L);
	if(DEBUG && !(1 <= HapSite[i] && HapSite[i] <= 2)){
	  printf("L=%d,R=%d:i=%d,HapSite[i]=%d,HapSite[L]=%d,HapSite[R]=%d\n",L,R,i,HapSite[i],HapSite[L],HapSite[R]);
	  fflush(stdout);
	  assert(1 <= HapSite[i] && HapSite[i] <= 2);
	}
	p->Allele = HapSite[i];
	p->loc = (HapSite[i]==1) ? loc1 : loc2;
      }
      lcnt++;
    }
    lcnt++;

    if(DEBUG && !(fabs(loc1 - len1) <= 1e-6)){
      printf("loc1= %0.8f, len1= %0.8f (err= %0.8f), lcnt=%d\n",loc1, len1, loc1 - len1,lcnt);
      fflush(stdout);
      assert(fabs(loc1 - len1) <= 1e-6);
    }
    if(DEBUG && !(fabs(loc2 - len2) <= 1e-6)){
      printf("loc2= %0.8f, len2= %0.8f (err= %0.8f), lcnt=%d\n",loc2, len2, loc2 - len2,lcnt);
      fflush(stdout);
      assert(fabs(loc2 - len2) <= 1e-6);
    }
  }// DEBUG

  HapSite[0] = HapSite[n+1] = 0;
  return 0;
}

/* Merge labels I and I+1 of specified Allele (1 or 2) or both Alleles (3)
   return 0 on success, 1 for unhandled cases 

   Also performs hsetmap(), to check for invalid configurations and update Y1,Y2,N1,N2,Hcuts1,Hcuts2
 */
static int LabelMerge(int Allele, int LL, int L, int iL, int iR, int RR, double mergeKB, int numthreads, 
		      int MD, int *MX,
		      int **map1, int **mapK1, int **map2, int **mapK2,
		      int **nmap1, int **nmapK1, int **nmap2, int **nmapK2,
		      int &N1, double *Y1,
		      int &N2, double *Y2,
		      int n, double *Hcuts, double *Hcuts1, double *Hcuts2,
		      int *HapSite, double *Delta, double *HapDelta,
		      int *prevHapSite, double *prevDelta, double *prevHapDelta,
		      double *spreadDelta, double *spreadHapDelta, 
		      CLabel *Label, int *Index, int *Hremap,
		      int *Hdel1, int *Hdel2)
{
#if 0
  if(mergeKB <= rres * 0.500 + 1e-6 && HapSite[iL]==3 && HapSite[iR]==3){
    if(RR > n)
      RR = iR;/* special case to handle iR==n */
  }
#endif

  if(VERB>=1+RELEASE/* HERE >=2 */){
    printf("Before Merging on Allele %d at Hcuts[iL=%d]=%0.4f,Hcuts[iR=%d]=%0.4f(delta=%0.4f,%0.4f,%0.4f), mergeKB=%0.4f,HapSite[LL=%d,L=%d,iL=%d,iR=%d,RR=%d]=%d,%d,%d,%d,%d,Delta[L,iL]=%0.4f,%0.4f,HapDelta[LL,iL]=%0.4f,%0.4f\n",
	   Allele,iL,Hcuts[iL]+Delta[LL]+Delta[L],iR,Hcuts[iR]+Delta[LL]+Delta[L]+Delta[iL],Hcuts[iR]-Hcuts[iL]+Delta[iL],Hcuts1[iR]-Hcuts1[iL],Hcuts2[iR]-Hcuts2[iL],mergeKB,LL,L,iL,iR,RR,HapSite[LL],HapSite[L],HapSite[iL],HapSite[iR],HapSite[RR],Delta[L],Delta[iL],HapDelta[LL],HapDelta[iL]);
    if(VERB>=3 && mergeKB <= rres * 0.500 + 1e-3 && rverb){
      printf("\t Hcuts[LL,L,iL,iR,RR]= %0.4f,%0.4f,%0.4f,%0.4f,%0.4f\n", Hcuts[LL],Hcuts[L],Hcuts[iL],Hcuts[iR],Hcuts[RR]);
      double cumDelta = 0.0;
      for(int t = LL; t <= RR; t++){
	if(t==LL || t==RR || HapSite[t] || HapDelta[t] || Delta[t])
	  printf("t=%d:Hcuts[t]= %0.6f, HapSite[t]=%d, Delta[t]= %0.6f, HapDelta[t]= %0.6f: Hcuts[t]+cumDelta[t]=%0.6f, Hcuts1[t]= %0.6f, Hcuts2[t]= %0.6f\n",
		 t, Hcuts[t], HapSite[t], Delta[t], HapDelta[t], Hcuts[t]+cumDelta, Hcuts1[t], Hcuts2[t]);
	cumDelta += Delta[t];
      }
    }
    fflush(stdout);
  }
  if(DEBUG){
    assert(1 <= iL && iL < iR && iR <= n);
    assert(HapSite[iL] && HapSite[iR]);
  }
		
  if((LL<=0 || RR > n) && ((HapDelta[iL] && HapSite[iL]==3) || (HapDelta[iR] && HapSite[iR]==3))){/* this case not handled : try to fix later */
    if(VERB>=1+RELEASE /* HERE >=2 */){
      printf("WARNING:Case with LL=0 or RR=n+1 not handled\n");
      fflush(stdout);
    }
    return 1;
  }

#if 0
  if(mergeKB <= rres * 0.500 + 1e-6 && HapSite[iL] == 3 && HapSite[iR] == 3 && Hcuts1[iR] - Hcuts1[iL] <= mergeKB + 1e-6 && Hcuts2[iR] - Hcuts2[iL] <= mergeKB + 1e-6){
    /* merge both allele's provided there are no intermediate labels between iL and iR */
    int i = iL + 1;
    for(; i < iR; i++)
      if(HapSite[i])
	break;
    if(i >= iR)
      Allele = 3;
    if(VERB/* HERE >=2 */){
      if(Allele==3){
	printf("\t Merging both Alleles\n");
	fflush(stdout);
      } else {
	printf("\t WARNING:Cannot merge both Alleles:\n");
	for(int t = iL; t <= iR; t++)
	  if(HapSite[t] || HapDelta[t] || Delta[t])
	    printf("t=%d:Hcuts[t]= %0.6f, HapSite[t]=%d, Delta[t]= %0.6f, HapDelta[t]= %0.6f, Hcuts1[t]= %0.6f, Hcuts2[t]= %0.6f\n",
		   t, Hcuts[t], HapSite[t], Delta[t], HapDelta[t], Hcuts1[t], Hcuts2[t]);
      }
    }
  }
#endif

  /* check for labels between iL and iR */
  if(DEBUG && (Allele & 1))/* check that there are no intermediate labels with Hapsite[i] & 1 */
    for(int i = iL + 1; i < iR; i++)
      assert(!(HapSite[i] & 1));
  if(DEBUG && (Allele & 2))/* check that there are no intermediate labels with Hapsite[i] & 2 */
    for(int i = iL + 1; i < iR; i++){
      if(DEBUG && (HapSite[i] & 2)){
	printf("i=%d (iL=%d,iR=%d):HapSite[i]=%d\n",i,iL,iR,HapSite[i]);

	printf("\t Hcuts[LL,L,iL,iR,RR]= %0.4f,%0.4f,%0.4f,%0.4f,%0.4f,Hcuts1=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,Hcuts2=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f\n",
	       Hcuts[LL],Hcuts[L],Hcuts[iL],Hcuts[iR],Hcuts[RR],Hcuts1[LL],Hcuts1[L],Hcuts1[iL],Hcuts1[iR],Hcuts1[RR],Hcuts2[LL],Hcuts2[L],Hcuts2[iL],Hcuts2[iR],Hcuts2[RR]);
	for(int t = LL; t <= RR; t++)
	  if(HapSite[t] || HapDelta[t] || Delta[t])
	    printf("t=%d:Hcuts[t]= %0.6f, HapSite[t]=%d, Delta[t]= %0.6f, HapDelta[t]= %0.6f, Hcuts1[t]= %0.6f, Hcuts2[t]= %0.6f\n",
		   t, Hcuts[t], HapSite[t], Delta[t], HapDelta[t], Hcuts1[t], Hcuts2[t]);
	fflush(stdout);

	assert(!(HapSite[i] & 2));
      }
    }

  int iRn = iL;
  for(int i = iL; ++i < iR;)
    if(HapSite[i])
      iRn = i;

  /* now merge the two labels into one, half-way between the original labels */
  int idel = iL, ikeep = iR;/* remember which label was deleted and which was kept, so we can fix up map[] */
  if(Allele==3){
    if(DEBUG) assert(HapSite[iL]==3 && HapSite[iR]==3);
    double shift = 0.5*(Hcuts[iR] - Hcuts[iL] + Delta[iL]);
    HapSite[iL] = 0;
    Delta[L] += Delta[iL];
    HapDelta[L] += HapDelta[iL];

    Delta[L] -= shift;
    Delta[iR] += shift;
    HapDelta[L] -= HapDelta[iL]*0.5;
    HapDelta[iR] += HapDelta[iL]*0.5;
    
    Delta[iL] = HapDelta[iL] = 0.0;
  } else if(Allele==1){
    if(DEBUG) assert((HapSite[iL] & 1) && (HapSite[iR] & 1));
    double shift = 0.5*(Hcuts1[iR] - Hcuts1[iL]);// NOTE : cannot use 0.5*(Hcuts[iR]-Hcuts1[iL]+Delta[iL]+HapDelta[iL]) since there may be additional sites between iL,iR with HapSite==2
    if(HapSite[iL]==1 && HapSite[iR]==1){/* Allele1 only merge */
      HapSite[iL] = 0;
      
      /* shift label iR left by "shift" */
      Delta[iRn==iL ? L : iRn] -= shift;
      Delta[iR] += shift;

      Delta[L] += Delta[iL];
      HapDelta[L] += HapDelta[iL];
      Delta[iL] = HapDelta[iL] = 0.0;
    } else if(HapSite[iL]==3 && HapSite[iR]==1){
      HapSite[iL] = 2;

      /* shift label iR left by "shift" */
      Delta[iRn] -= shift;
      Delta[iR] += shift;
    } else if(HapSite[iL]==1 && HapSite[iR]==3){
      HapSite[iR] = 2;

      /* shift label iL right by "shift" */
      Delta[iL] -= shift;
      Delta[L] += shift;

      idel = iR;
      ikeep = iL;
    } else {/* merge only Allele 1 labels */
      if(DEBUG) assert(HapSite[iL]==3 && HapSite[iR]==3);
      int iMid = (iR+iL)/2;
#if 1
      /* locate label iMid with HapSite[iMid]==0 AND Hcuts1[iMid] closest to tloc */
      double tloc = Hcuts1[iR] - shift;
      double Err = shift;
      for(int i = iL+1; i < iR; i++)
	if(HapSite[i] == 0 && fabs(Hcuts1[i] - tloc) < Err){
	  iMid = i;
	  Err = fabs(Hcuts1[i] - tloc);
	}
#else
      if(HapSite[iMid] != 0)// it is possible that intermediate labels of Allele1 are present : fix by looking for another empty position
	for(iMid = iL+1; iMid < iR; iMid++)
	  if(!HapSite[iMid])
	    break;
#endif
      if(HapSite[iMid]){ /* approximate by deleting from HapSite[iL] */
	HapSite[iL] = 2;
      } else {
	//	int iMid = (iR+iL)/2;
	if(DEBUG) assert(HapSite[iMid]==0);
	if(DEBUG) assert(Delta[iMid] == 0.0);
	if(DEBUG) assert(HapDelta[iMid] == 0.0);

	/* locate nearest label ip left of iMid */
	int ip = iMid - 1;
	while(!HapSite[ip])
	  ip--;
	if(DEBUG) assert(ip >= iL);

	if(HPROBEVAL_SPREAD){	  /* spread Delta[ip] and HapDelta[ip] between ip and iMid */
	  /* locate nearest label Hcuts[in] right of iMid */
	  int in = iMid + 1;
	  while(!HapSite[in])
	    in++;
	  if(DEBUG) assert(in <= iR);

	  if(Delta[ip]){
	    double scale = Delta[ip] / (Hcuts[in] - Hcuts[ip]);
	    Delta[iMid] = scale * (Hcuts[in] - Hcuts[iMid]);
	    Delta[ip] -= Delta[iMid];
	  }
	  if(HapDelta[ip]){
	    double scale = HapDelta[ip] / (Hcuts[in] - Hcuts[ip]);
	    HapDelta[iMid] = scale * (Hcuts[in] - Hcuts[iMid]);
	    HapDelta[ip] -= HapDelta[iMid];
	  }
	}

	HapSite[iL] = HapSite[iR] = 2;
	HapSite[iMid] = 1;
	double tshift = Hcuts1[iR] - Hcuts1[iMid] - shift;
	if(VERB>=3 && rverb){
	  printf("iL=%d,ip=%d,iMid=%d,iR=%d,shift=%0.4f,tshift=%0.4f:Delta[ip]=%0.4f -> %0.4f,Delta[iMid]=%0.4f -> %0.4f, idel=%d,ikeep=%d -> %d,Hcuts1[iMid]=%0.4f\n",
		 iL,ip,iMid,iR,shift,tshift,Delta[ip],Delta[ip]+tshift,Delta[iMid],Delta[iMid]-tshift,idel,ikeep,iMid,Hcuts1[iMid]);
	  fflush(stdout);
	}
	Delta[ip] += tshift;
	Delta[iMid] -= tshift;
	ikeep = iMid;
      }
    }
  } else {/* Allele == 2 */
    if(DEBUG) assert((HapSite[iL] & 2) && (HapSite[iR] & 2));
    double shift = 0.5*(Hcuts2[iR] - Hcuts2[iL]);
    if(HapSite[iL]==2 && HapSite[iR]==2){/* Allele2 only merge */
      HapSite[iL] = 0;

      /* shift label iR left by "shift" */
      Delta[iRn==iL ? L : iRn] -= shift;
      Delta[iR] += shift;

      Delta[L] += Delta[iL];
      HapDelta[L] += HapDelta[iL];
      Delta[iL] = HapDelta[iL] = 0.0;
    } else if(HapSite[iL]==3 && HapSite[iR]==2){
      HapSite[iL] = 1;

      /* shift label iR left by "shift" */
      Delta[iRn] -= shift;
      Delta[iR] += shift;
    } else if(HapSite[iL]==2 && HapSite[iR]==3){
      HapSite[iR] = 1;

      /* shift label iL right by "shift" */
      Delta[iL] -= shift;
      Delta[L] += shift;

      idel = iR;
      ikeep = iL;
    } else {/* merge only Allele 2 labels */
      if(DEBUG) assert(HapSite[iL]==3 && HapSite[iR]==3);
      int iMid = (iL + iR)/2;
#if 1
      /* locate label iMid with HapSite[iMid]==0 AND Hcuts2[iMid] closest to tloc */
      double tloc = Hcuts2[iR] - shift;
      double Err = shift;
      for(int i = iL+1; i < iR; i++)
	if(HapSite[i] == 0 && fabs(Hcuts2[i] - tloc) < Err){
	  iMid = i;
	  Err = fabs(Hcuts2[i] - tloc);
	}
#else
      if(HapSite[iMid] != 0)// it is possible that intermediate labels of Allele1 are present : fix by looking for another empty position
	for(iMid = iL+1; iMid < iR; iMid++)
	  if(!HapSite[iMid])
	    break;
#endif
      if(HapSite[iMid]) {/* approximating by deleting Allele2 from HapSite[iL] */
	HapSite[iL] = 1;
      } else {
	if(DEBUG) assert(HapSite[iMid]==0);
	if(DEBUG) assert(Delta[iMid] == 0.0);
	if(DEBUG) assert(HapDelta[iMid] == 0.0);

	/* locate nearest label ip left of iMid */
	int ip = iMid - 1;
	while(!HapSite[ip])
	  ip--;
	if(DEBUG) assert(ip >= iL);

	if(HPROBEVAL_SPREAD){	  /* spread Delta[ip] and HapDelta[ip] between ip and iMid */
	  /* locate nearest label Hcuts[in] right of iMid */
	  int in = iMid + 1;
	  while(!HapSite[in])
	    in++;
	  if(DEBUG) assert(in <= iR);

	  if(Delta[ip]){
	    double scale = Delta[ip] / (Hcuts[in] - Hcuts[ip]);
	    Delta[iMid] = scale * (Hcuts[in] - Hcuts[iMid]);
	    Delta[ip] -= Delta[iMid];
	  }
	  if(HapDelta[ip]){
	    double scale = HapDelta[ip] / (Hcuts[in] - Hcuts[ip]);
	    HapDelta[iMid] = scale * (Hcuts[in] - Hcuts[iMid]);
	    HapDelta[ip] -= HapDelta[iMid];
	  }
	}

	HapSite[iL] = HapSite[iR] = 1;
	HapSite[iMid] = 2;
	double tshift = Hcuts2[iR] - Hcuts2[iMid] - shift;
	if(VERB>=3 && rverb){
	  printf("iL=%d,ip=%d,iMid=%d,iR=%d,shift=%0.4f,tshift=%0.4f:Delta[ip]=%0.4f -> %0.4f,Delta[iMid]=%0.4f -> %0.4f, idel=%d,ikeep=%d -> %d,Hcuts2[iMid]=%0.4f\n",
		 iL,ip,iMid,iR,shift,tshift,Delta[ip],Delta[ip]+tshift,Delta[iMid],Delta[iMid]-tshift,idel,ikeep,iMid,Hcuts2[iMid]);
	  fflush(stdout);
	}

	Delta[ip] += tshift;
	Delta[iMid] -= tshift;
	ikeep = iMid;
      }
    }
  }

  /* HapDeltaSpread() works on an interval bounded by HapSite= 3 and no other labels with HapSite=3 */
  int SR = (HapSite[iR]==3) ? iR : RR;
  if(DEBUG) assert(HapSite[iL] != 3);

  if(HapDeltaSpread(n, LL, SR, HapDelta, Delta, Hcuts, HapSite, Label, Index, Hremap) ||
    (SR < RR && HapDeltaSpread(n, SR, RR, HapDelta, Delta, Hcuts, HapSite, Label, Index, Hremap))){
    //		  rverb = 0;
    if(VERB>=1+RELEASE/* HERE >=2 */){
      printf("\t Failed to merge labels due to HapDeltaSpread\n");
      fflush(stdout);
    }
    memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
    memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
    memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
    return 1;
  }
  int origrverb = rverb;
  rverb = 0;

  int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);
  if(err){
    if(VERB>=1+RELEASE/* HERE >=2 */){
      printf("\t Failed to merge labels due to hsetmap (N1=%d,N2=%d)!\n",N1,N2);
      fflush(stdout);
    }

    memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
    memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
    memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
    return 1;
  }
		
  rverb = origrverb;

  if(HPROBEVAL_SPREAD){ /* fix up map1[] or map2[] */
    if(Allele==1 || Allele==3){/* fix map1[] */
      if(VERB>=3 && rverb && 163 < MD){
	int m = 163;
	int M = MX[m];
	printf("Before adjusting map1[]: idel=%d,ikeep=%d,iL=%d,iR=%d,Allele=%d\n",idel,ikeep,iL,iR,Allele);
	printf("m=%d:M=%d:\n",m,M);
	for(int J = 1; J <= M; J++){
	  int I = map1[m][J];
	  if(I < 0)
	    continue;
	  int K = mapK1[m][J];
	  printf("\t J=%d:map1[m][J]=%d,mapK1[m][J]=%d\n",J,I,K);
	}
	
	printf("Hremap[%d..%d]:\n",LL,RR);
	for(int i = LL; i <= RR; i++)
	  if(i==LL || i == RR || Hremap[i] != i || HapSite[i])
	    printf("\t Hremap[%d] = %d, HapSite[%d]=%d\n",i,Hremap[i],i,HapSite[i]);

	fflush(stdout);
      }

      int block = 1;
      while(block < 16 && MD > numthreads * block)
	block *= 2;

      int LoopCnt = 0;
      #pragma omp parallel num_threads(numthreads)
      {
	int myLoopCnt = 0;
        #pragma omp for schedule(static,block)
        for(int m  = 0; m < MD; m++){
	  if(OMP_DEBUG) myLoopCnt++;
	  int M = MX[m];

	  /* Apply mapping from idel to ikeep : provided another label is not already mapped to ikeep */
	  for(int J = 1; J <= M; J++){
	    int I = map1[m][J];
	    if(I < 0)
	      continue;
	    int K = mapK1[m][J];
	    if(DEBUG>=1+RELEASE) assert(0 <= K && K < I);
	    K = I-K;

	    if(VERB>=3 && m==138){
	      printf("m=%d:J=%d,I=%d,K=%d:idel=%d,ikeep=%d,iR=%d:M=%d\n",
		     m,J,I,K,idel,ikeep,iR,M);
	      fflush(stdout);
	    }

	    if(I== idel || K == idel || (/* Allele==3 && */ ikeep != iR && ikeep != iL && (I== iR || K== iR))){/* check if another label j is already mapped to ikeep */
	      int j = M;
	      for(; j > 0; j--){
		if(j == J)
		  continue;
		int i = map1[m][j];
		if(i < 0)
		  continue;
		int k = mapK1[m][j];
		if(DEBUG>=1+RELEASE) assert(0 <= k && k < i);
		k = i-k;
		if(k <= ikeep && ikeep <= i)
		  break;
	      }
	      if(VERB>=3 && m==138 && rverb){
		printf("m=%d:J=%d,I=%d,K=%d:idel=%d,ikeep=%d,iR=%d:j=%d,M=%d\n",
		       m,J,I,K,idel,ikeep,iR,j,M);
		fflush(stdout);
	      }
	      if(j <= 0){/* OK to map to ikeep */
		if(I== idel) I = ikeep;
		if(K== idel) K = ikeep;
		if(ikeep != iR && ikeep != iL){
		  if(DEBUG) assert(prevHapSite[iL]==3 && prevHapSite[iR]==3 && idel == iL);
		  if(I== iR) I = ikeep;
		  if(K== iR) K = ikeep;
		}
	      } else {/* unmap map1[m][J] : this would be done by cleanmapH() later anyway, but can trigger assertion failure if not done now */
		// NOTE: cannot use map1[MD][] since it has already been remapped by hsetmap()
		if(I== idel) I = K = -1;
		else if(K==idel) {
		  if(DEBUG) assert(K < I);
		  int origK = K;
		  K = ikeep;
		  while(++K < I)
		    if(K != idel && (prevHapSite[K] & 1))
		      break;
		  if(VERB>=3 && m==138 && rverb){
		    printf("m=%d:J=%d,I=%d,K=%d -> %d, prevHapSite[K]=%d\n",m,J,I,origK,K,prevHapSite[K]);
		    fflush(stdout);
		  }
		}
		if(ikeep != iR && ikeep != iL){
		  if(DEBUG) assert(prevHapSite[iL]==3 && prevHapSite[iR]==3 && idel == iL);
		  if(I== iR) I = K = -1;
		  else if(K == iR){
		    if(DEBUG) assert(K < I);
		    int origK = K;
		    K = ikeep;
		    while(++K < I)
		      if(K != idel && K != iR && (prevHapSite[K] & 1))
			break;
		    if(VERB>=3 && m==138 && rverb){
		      printf("m=%d:J=%d,I=%d,K=%d -> %d, prevHapSite[K]=%d\n",m,J,I,origK,K,prevHapSite[K]);
		      fflush(stdout);
		    }
		  }
		}
	      }
	    }
	  
	    map1[m][J] = I;
	    mapK1[m][J] = I - K;
          } // for J = 1..M

	  if(VERB>=3 && rverb && m== 163){
            #pragma omp critical
	    {
	      printf("After adjusting map1[] based on idel=%d,ikeep=%d:\n",idel,ikeep);
	      printf("m=%d:M=%d:\n",m,M);
	      for(int J = 1; J <= M; J++){
	        int I = map1[m][J];
		if(I < 0)
		  continue;
		int K = mapK1[m][J];
		printf("\t J=%d:map1[m][J]=%d,mapK1[m][J]=%d\n",J,I,K);
	      }
	      fflush(stdout);
	    }
	  }

	  /* NOTE : this loop partition is needed so the label scan in the previous loop can work in both directions without seeing updated data in backwards direction */

	  /* apply Hremap[LL..RR] to map1[] */
	  int lastI = -1, lastK = -1, lastJ = -1;
	  for(int J = 1; J <= M; J++){
	    int I = map1[m][J];
	    if(I < 0)
	      continue;
	    int K = mapK1[m][J];
	    if(DEBUG>=1+RELEASE) assert(0 <= K && K < I);
	    K = I-K;
	    
	    if(LL <= I && I <= RR){
	      if(DEBUG>=1+RELEASE) assert(0 < Hremap[I] && Hremap[I] <= n);
	      I = Hremap[I];
	    }
	    if(LL <= K && K <= RR){
	      if(DEBUG>=1+RELEASE && !(0 < Hremap[K] && Hremap[K] <= I)){
	        printf("m=%d:J=%d,M=%d,I=%d->%d,K=%d,Hremap[K]=%d,LL=%d,RR=%d\n",m,J,M,map1[m][J],I,K,Hremap[K],LL,RR);
		fflush(stdout);
		assert(0 < Hremap[K] && Hremap[K] <= I);
	      }
	      K = Hremap[K];
	    }
	    map1[m][J] = I;
	    mapK1[m][J] = I - K;

	    if(DEBUG>=1+RELEASE){
	      I = map1[m][J];
	      K = mapK1[m][J];
	      if(HapSite[I] & 1){// NEW : If Hcuts[I] is not in Allele1 ignore mappings to this label in map1, since map1 may not be clean 
                if(lastI >= 0 && !(I-K > lastI)){
                  #pragma omp critical
		  {
	            printf("map1:m=%d,M=%d,J=%d,I=%d,K=%d:lastJ=%d,lastI=%d,lastK=%d\n",m,M,J,I,K,lastJ,lastI,lastK);
		    if(VERB/* HERE >=2 */){
		      for(int j = 1; j <= J; j++){
		        int i = map1[m][j];
			if(i < 0)
			  continue;
			int k = mapK1[m][j];
			printf("\t j=%d:map1[m][j]=%d,mapK1[m][j]=%d\n",j,i,k);
		      }
		    }
		    fflush(stdout);
		    assert(I-K > lastI);
		  }
		}
		lastI = I;
		lastK = K;
		lastJ = J;
	      }
	    }
	  }
        }
	if(OMP_DEBUG && myLoopCnt > 0){
          #pragma omp critical
	  {
            LoopCnt += myLoopCnt;
	  }
        }
      }
      if(OMP_DEBUG) assert(LoopCnt == MD);
    }

    if(Allele==2 || Allele==3){/* fix map2[] */
      if(VERB>=3 && rverb){
	printf("Before adjusting map2[]: idel=%d,ikeep=%d,iL=%d,iR=%d,Allele=%d\n",idel,ikeep,iL,iR,Allele);
	for(int m = 0; m < MD; m++){
	  if(m != 163)
	    continue;
	  int M = MX[m];
	  printf("m=%d:M=%d:\n",m,M);
	  for(int J = 1; J <= M; J++){
	    int I = map2[m][J];
	    if(I < 0)
	      continue;
	    int K = mapK2[m][J];
	    printf("\t J=%d:map2[m][J]=%d,mapK2[m][J]=%d\n",J,I,K);
	  }
	}
	
	printf("Hremap[%d..%d]:\n",LL,RR);
	for(int i = LL; i <= RR; i++)
	  if(i==LL || i == RR || Hremap[i] != i || HapSite[i])
	    printf("\t i=%d:Hremap[i]= %d, HapSite[i]= %d, Hcuts[i]= %0.4f\n",i,Hremap[i],HapSite[i], Hcuts[i]);

	fflush(stdout);
      }

      int block = 1;
      while(block < 16 && MD > numthreads * block)
	block *= 2;

      int LoopCnt = 0;
      #pragma omp parallel num_threads(numthreads) 
      {
	int myLoopCnt = 0;
        #pragma omp for schedule(static,block)
	for(int m  = 0; m < MD; m++){
	  if(OMP_DEBUG) myLoopCnt++;
	  int M = MX[m];

	  /* Apply mapping from idel to ikeep : provided another label is not already mapped to ikeep */
	  int lastI = -1, lastK = -1, lastJ = -1;
	  for(int J = 1; J <= M; J++){
	    int I = map2[m][J];
	    if(I < 0)
	      continue;
	    int K = mapK2[m][J];
	    if(DEBUG>=1+RELEASE) assert(0 <= K && K < I);
	    K = I-K;
	    
	    if(I== idel || K == idel || (/* Allele==3 && */ ikeep != iR && ikeep != iL && (I== iR || K == iR))){/* check if another Label j is already mapped to ikeep */
	      int j = M;
	      for(; j > 0; j--){
		if(j==J)
		  continue;
		int i = map2[m][j];
		if(i < 0)
		  continue;
		int k = mapK2[m][j];
		if(DEBUG>=1+RELEASE) assert(0 <= k && k < i);
		k = i-k;
		if(k <= ikeep && ikeep <= i)
		  break;
	      }

	      if(j <= 0){/* OK to map to ikeep */
		if(I== idel) I = ikeep;
		if(K== idel) K = ikeep;
		if(ikeep != iR && ikeep != iL){
		  if(DEBUG) assert(prevHapSite[iL]==3 && prevHapSite[iR]==3 && idel == iL);
		  if(I== iR) I = ikeep;
		  if(K== iR) K = ikeep;
		}
	      } else {/* unmap map2[m][J] : this would be done by cleanmapH() later anyway, but can trigger assertion failure if not done now */
		// NOTE: cannot use map2[MD][] since it has already been remapped by hsetmap()
		if(I== idel) I = K = -1;
		else if(K==idel) {
		  if(DEBUG) assert(K < I);
		  K = ikeep;
		  while(++K < I)
		    if(K != idel && (prevHapSite[K] & 2))
		      break;
		}
		if(ikeep != iR && ikeep != iL){
		  if(DEBUG) assert(prevHapSite[iL]==3 && prevHapSite[iR]==3 && idel == iL);
		  if(I== iR) I = K = -1;
		  else if(K == iR){
		    if(DEBUG) assert(K < I);
		    K = ikeep;
		    while(++K < I)
		      if(K != idel && K != iR && (prevHapSite[K] & 2))
			break;
		  }
		}
	      }
	    }

	    map2[m][J] = I;
	    mapK2[m][J] = I - K;
	  }

	  if(VERB>=3 && rverb && m==163){
            #pragma omp critical
	    {
	      printf("After adjusting map2[] based on idel=%d,ikeep=%d:\n",idel,ikeep);
	      printf("m=%d:M=%d:\n",m,M);
	      for(int J = 1; J <= M; J++){
	        int I = map2[m][J];
		if(I < 0)
		  continue;
		int K = mapK2[m][J];
		printf("\t J=%d:map2[m][J]=%d,mapK2[m][J]=%d\n",J,I,K);
	      }
	      fflush(stdout);
	    }
	  }

	  /* apply Hremap[LL..RR] */
	  lastI = lastK = lastJ = -1;
	  for(int J = 1; J <= M; J++){
	    int I = map2[m][J];
	    if(I < 0)
	      continue;
	    int K = mapK2[m][J];
	    K = I-K;

	    if(LL <= I && I <= RR){
	      if(DEBUG>=1+RELEASE) assert(0 < Hremap[I] && Hremap[I] <= n);
	      I = Hremap[I];
	    }
	    if(LL <= K && K <= RR){
	      if(DEBUG>=1+RELEASE && !(0 < Hremap[K] && Hremap[K] <= I)){
	        printf("m=%d,M=%d:J=%d,map2[m][J]=%d -> %d(=I),mapK2[m][J]=%d,K=%d,LL=%d,RR=%d,Hremap[K]=%d,rverb=%d\n",
	          m,M,J,map2[m][J],I,mapK2[m][J],K,LL,RR,Hremap[K],rverb);
		fflush(stdout);
		assert(0 < Hremap[K] && Hremap[K] <= I);
	      }
	      K = Hremap[K];
	    }
	    map2[m][J] = I;
	    mapK2[m][J] = I - K;

	    if(DEBUG>=1+RELEASE){
	      I = map2[m][J];
	      K = mapK2[m][J];
	      if(HapSite[I] & 2){// NEW : If Hcuts[I] is not in Allele 2 ignore mappings to I in map2 since map2 may not be clean
		if(lastI >= 0 && !(I-K > lastI)){
		  #pragma omp critical
		  {
		    printf("map2:m=%d,J=%d,I=%d,K=%d:lastJ=%d,lastI=%d,lastK=%d\n",m,J,I,K,lastJ,lastI,lastK);
		    if(VERB/* HERE >=2 */){
		      for(int j = 1; j <= J; j++){
			int i = map2[m][j];
			if(i < 0)
			  continue;
			int k = mapK2[m][j];
			printf("\t j=%d:map2[m][j]=%d,mapK2[m][j]=%d\n",j,i,k);
		      }
		      printf("Hremap[%d..%d]:\n",LL,RR);
		      for(int i = LL; i <= RR; i++)
			if(i==LL || i==RR || Hremap[i] != i || HapSite[i])
			  printf("\t i=%d:Hremap[i]= %d, HapSite[i]= %d, Hcuts[i]= %0.4f, Delta[i]= %0.4f, HapDelta[i]= %0.4f\n",
				 i,Hremap[i],HapSite[i], Hcuts[i], Delta[i], HapDelta[i]);
		    }
		    fflush(stdout);
		    assert(I-K > lastI);
		  }
		}
		lastI = I;
		lastK = K;
		lastJ = J;
	      }
	    }
	  }
	}
        if(OMP_DEBUG && myLoopCnt > 0){
          #pragma omp critical
          {
	    LoopCnt += myLoopCnt;
	  }
	}
      }
      if(OMP_DEBUG) assert(LoopCnt == MD);  
    }
  }
  return 0;
}

static int *gIndex = NULL;

static int MAX_INDEL_WARNING = 0;

static double IntervalEps = IntervalEps1;// will be re-initialized at start of HaplotypeR() 
static double HapIndelEps = HapIndelEps1;// will be re-initialized at start of HaplotypeR() 
static double HapLabelEps = HapLabelEps1;// will be re-initialized at start of HaplotypeR() 

/* Apply -rres and -ccres and return 1 if any labels were changed, 0 otherwise */
int HaploTypeDeres(int &Deresed, const int Filtered,
		   int &SNPfail, int &SNPskip, int &lastiter, int &maxiter,
		   int &HapUpdatemapSkipcnt,
		   int &iter, const int numthreads,
		   const double BigPen,  double &newLP,
		   double &LPhwm, int &LPdrop_count,
		   int &n, double *Hcuts,
		   double *HapDelta, double *HapDeltaMerged,
		   int *HapSite, double *Delta,
		   double *HapSiteScore, double *SiteScore, double *HapDeltaScore,
		   double *Hcuts1, double *Hcuts2,
		   int *Hdel1, int *Hdel2,
		   int &N1, int &N2,
		   double *Y1, double *Y2,
		   const int MD, int *MX, double **X,
		   const int lc, const int rc,
		   int **map1, int **map2, int **mapK1, int **mapK2,
		   Csetlimit *limit1, 
		   Csetlimit *limit2,
		   int **nmap1, int **nmap2, int **nmapK1, int **nmapK2,
		   double *TBmapWT, /* If != 0 : TBmapWT[m] is a the -TB based weight for map m to be applied when summing up the total log(LR+LRbias) value */
		   double * &newLPA1, double * &newLPA2, 
                   double * &testLPA1, double * &testLPA2,
		   double * &bestLPA1, double * &bestLPA2,
		   double *mapWT1, double *mapWT2,
		   int **outlier1, int **outlier2,
		   double *newLPA,
		   Ccontig *pcontig, /* pointer to complete contig information */
		   int& SNPcnt, int& IndelCnt,
		   double *prevHapDelta, double *prevDelta, int *prevHapSite,
		   double *spreadHapDelta,/* If != NULL : space to store spread version of HapDelta[] */
		   double *spreadDelta,    /* If != NULL : space to store spread version of HapDelta[] */
		   CLabel *Label, int *Index, int *Hremap,
		   const int DELTA_OVERSAMPLE, const int maxIN, 
		   int *DELTA_RANGE, double **Initial_Delta, int &activecnt,
		   const int DELTA_SCAN, const int Lfrozen, const int Rfrozen 
		   )
{
  int SNPs, Indels;

  int changecnt = 0;

  double wtstart = wtime();

  if(VERB>=3 && !HAP_MAX_DERES){
    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
    printf("Y1:N1=%d\n",N1);
    for(int I = 1; I <= N1; I++)
      printf("I=%d:Y1[I]= %0.4f (Y1[I]-Y1[1]= %0.4f) : Hcuts[%d]=%0.4f\n",I,Y1[I], Y1[I] - Y1[1], nmap1[MD][I], Hcuts[nmap1[MD][I]]);
    printf("Y2:N2=%d\n",N2);
    for(int I = 1; I <= N2; I++)
      printf("I=%d:Y2[I]= %0.4f (Y2[I]-Y2[1]= %0.4f) : Hcuts[%d]=%0.4f\n",I,Y2[I], Y2[I] - Y2[1], nmap2[MD][I], Hcuts[nmap2[MD][I]]);
    fflush(stdout);
  }

  if(Deresed < HAP_MAX_DERES){
    Deresed++;

    if(VERB>=1+RELEASE/* HERE >=2 */){
      printf("iter=%d:Filtered=%d,Deresed=%d->%d(max=%d),rres=%0.4f\n",iter,Filtered,Deresed-1,Deresed,HAP_MAX_DERES,rres);
      if(VERB>=2){
	printf("Before Merging nearby sites:\n");
	int hap = 0;
	for(int i = 1; i <= n; i++){
	  if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
	    printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		   i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	  if(hap && HapSite[i]==3)
	    hap = 0;
	  if(HapDelta[i])
	    hap = 1;
	}
	fflush(stdout);
      }

      fflush(stdout);
    }

    /* remove consensus sites on the same Allele closer than rres*PixelLen (OR closer than cres if there are not at least 3 maps with both sites) */
    if(REMOVE_CLOSE_SITES && rres > 0.0){/* remove consensus sites closer than rres*PixelLen (OR closer than cres if there are not at least 3 maps with both sites) */  
      double mergeKB = rres * 0.500;

      int prevN1 = N1, prevN2 = N2;

      if(VERB){
	printf("Merging all sites closer than mergeKB=%0.3f kb: newLP=%0.6f: wall time= %0.6f\n",mergeKB, newLP,wtstart);
	fflush(stdout);
      }

      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
      cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			     TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels, 0);
      if(VERB/* HERE>=2*/){
	printf("After cleaning up map1,map2: LP=%0.8f -> %0.8f (delta=%0.8f),SNPs=%d,Indels=%d: cum wall= %0.6f\n",newLP, nLP, nLP-newLP, SNPs, Indels,wtime());
	fflush(stdout);
      }
      newLP = nLP;
      SNPcnt = SNPs;
      IndelCnt = Indels;

      if(VERB>=3){/* display alignments of molecules near Hcuts= 19673.3990 .. 19687.4437 */
	rverb = 1;
	printf("Displaying hprobeval near Hcuts[39955..39988] (Hcut1=%0.4f..%0.4f, Hcuts2=%0.4f..%0.4f), before rres merging\n", Hcuts1[39955],Hcuts1[39988],Hcuts2[39955],Hcuts2[39988]);
	fflush(stdout);
	double qLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			       TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[39955],Hcuts1[39988],Hcuts2[39955],Hcuts2[39988],0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels, 0);
	printf("qLP= %0.8f\n",qLP);
	fflush(stdout);
	rverb = 0;
      }

      int origN1 = N1, origN2 = N2;

      if(VERB>=3){
	printf("Y1:N1=%d\n",N1);
	for(int I = 1; I <= N1; I++)
	  printf("I=%d:Y1[I]= %0.4f (Y1[I]-Y1[1]= %0.4f) : Hcuts[%d]=%0.4f\n",I,Y1[I], Y1[I] - Y1[1], nmap1[MD][I], Hcuts[nmap1[MD][I]]);
	printf("Y2:N2=%d\n",N2);
	for(int I = 1; I <= N2; I++)
	  printf("I=%d:Y2[I]= %0.4f (Y2[I]-Y2[1]= %0.4f) : Hcuts[%d]=%0.4f\n",I,Y2[I], Y2[I] - Y2[1], nmap2[MD][I], Hcuts[nmap2[MD][I]]);
	fflush(stdout);
      }

      int progress = 1;
      while(progress){
	progress = 0;

	/* locate smallest remaining interval on either Allele */
	int iL = -1, iR = -1, Allele = -1;
	double smallKB = mergeKB * 100.0;
	for(int I1 = 1; I1 < N1; I1++){
	  if(Y1[I1 + 1] - Y1[I1] < smallKB){
	    smallKB = Y1[I1+1] - Y1[I1];
	    Allele = 1;
	    iL = nmap1[MD][I1];
	    iR = nmap1[MD][I1 + 1];
	  }
	}
	for(int I2 = 1; I2 < N2; I2++){
	  if(Y2[I2 + 1] - Y2[I2] < smallKB){
	    smallKB = Y2[I2+1] - Y2[I2];
	    Allele = 2;
	    iL = nmap2[MD][I2];
	    iR = nmap2[MD][I2 + 1];
	  }
	}
	      
	if(VERB/* HERE >=2 */ && Allele && smallKB <= mergeKB){
	  if(Allele == 1){
	    int I1 = map1[MD][iL];
	    int I2 = map1[MD][iR];
	    printf("Next smallest interval is on Allele1 : Y1[%d]=%0.6f (Hcuts[iL=%d]=%0.6f),Y1[%d]=%0.6f(Hcuts[iR=%d]=%0.6f): delta=%0.6f (HapSite[iL,iR]=%d,%d): cum wall= %0.6f\n",
		   I1,Y1[I1],iL,Hcuts[iL],I2,Y1[I2],iR,Hcuts[iR], smallKB, HapSite[iL],HapSite[iR], wtime());
	  } else {
	    int I1 = map2[MD][iL];
	    int I2 = map2[MD][iR];
	    printf("Next smallest interval is on Allele2 : Y2[%d]=%0.6f (Hcuts[iL=%d]=%0.6f),Y2[%d]=%0.6f(Hcuts[iR=%d]=%0.6f): delta=%0.6f (HapSite[iL,iR]=%d,%d): cum wall= %0.6f\n",
		   I1,Y2[I1],iL,Hcuts[iL],I2,Y2[I2],iR,Hcuts[iR], smallKB, HapSite[iL], HapSite[iR], wtime());
	  }
	  fflush(stdout);
	}

	if(smallKB <= mergeKB){
	  progress = 1;
	  changecnt++;
	  if(DEBUG) assert(0 < iL && iL < iR && Allele > 0);
		
	  if(HapSite[iL] == 3 && HapSite[iR] == 3 && Hcuts1[iR] - Hcuts1[iL] <= mergeKB + 1e-6 && Hcuts2[iR] - Hcuts2[iL] <= mergeKB + 1e-6){
	    /* merge both allele's provided there are no intermediate labels between iL and iR */
	    int i = iL + 1;
	    for(; i < iR; i++)
	      if(HapSite[i])
		break;
	    if(i >= iR)
	      Allele = 3;
	    if(VERB/* HERE >=2 */){
	      if(Allele==3){
		printf("\t Merging both Alleles\n");
		fflush(stdout);
	      } else {
		printf("\t WARNING:Cannot merge both Alleles:\n");
		for(int t = iL; t <= iR; t++)
		  if(HapSite[t] || HapDelta[t] || Delta[t])
		    printf("t=%d:Hcuts[t]= %0.6f, HapSite[t]=%d, Delta[t]= %0.6f, HapDelta[t]= %0.6f, Hcuts1[t]= %0.6f, Hcuts2[t]= %0.6f\n",
			   t, Hcuts[t], HapSite[t], Delta[t], HapDelta[t], Hcuts1[t], Hcuts2[t]);
	      }
	    }
	  }

	  /* locate L, first label left of interval Hcuts[iL,iR] */
	  int L= iL - 1;
	  for(; L > 0; L--)
	    if(HapSite[L])
	      break;
	  /* locate iM, first Label left of iR (which is not necessarily the same as iL) */
	  int iM = iR-1;
	  for(;iM > iL; iM--)
	    if(HapSite[iM])
	      break;
	  //	    iM = iL;

	  /* locate LL, first non-Hap label left of interval Hcuts[iL,iR] */
	  int LL = L;
	  for(; LL > 0; LL--)
	    if(HapSite[LL]==3)
	      break;
	  /* locate RR, first non-Hap label right of interval Hcuts[iL,iR] */
	  int RR = iR + 1;
	  for(; RR <= n; RR++)
	    if(HapSite[RR]==3)
	      break;

	  memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	  memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	  memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL+1)*sizeof(int));
	  if(cresFix && HPROBEVAL_SPREAD){  /* need to backup map1[],map2[] */
	    int LoopCnt = 0;

	    int block = 1;
	    while(block < 16 && MD > numthreads * block)
	      block *= 2;

            #pragma omp parallel num_threads(numthreads)
	    {
	      int myLoopCnt = 0;

              #pragma omp for schedule(static,block)
	      for(int m = 0; m < MD; m++){
		if(OMP_DEBUG) myLoopCnt++;
		int M = MX[m];

		memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
		memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
		memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
		memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
	      }
	      if(OMP_DEBUG && myLoopCnt > 0){
                #pragma omp critical
		{
		  LoopCnt += myLoopCnt;
		}
	      }
	    } // omp parallel
	    if(OMP_DEBUG) assert(LoopCnt == MD);
	  }
		
	  int bestChange = 0;/* 0 means no change, 1 means delete Hcuts[iL], 2 means delete Hcuts[iR], 3 means merge Hcuts[iL,iR] */
	  double bestLP = newLP - BigPen;

	  if(cresFix){

	    if(VERB>=2){
	      printf("Originally: Hcuts[LL=%d,L=%d,iL=%d,iM=%d,iR=%d,RR=%d]=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,Delta=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,HapDelta=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f\n",
	        LL,L,iL,iM,iR,RR,Hcuts[LL],Hcuts[L],Hcuts[iL],Hcuts[iM],Hcuts[iR],Hcuts[RR],Delta[LL],Delta[L],Delta[iL],Delta[iM],Delta[iR],HapDelta[LL],HapDelta[L],HapDelta[iL],HapDelta[iM],HapDelta[iR]);
	      for(int i = LL; i <= RR; i++)
		if(HapSite[i] || Delta[i] || HapDelta[i])
		  printf("i=%d:Hcuts[i]=%0.4f,Delta[i]=%0.4f,HapDelta[i]=%0.4f,HapSite[i]=%d\n",i,Hcuts[i],Delta[i],HapDelta[i],HapSite[i]);
	      fflush(stdout);
	    }

	    /* First try to just remove left label Hcuts[iL] */
	    if(DEBUG) assert(HapSite[iL]);
	    HapSite[iL] &= ~Allele;
	    if(!HapSite[iL]){
	      HapDelta[L] += HapDelta[iL];
	      Delta[L] += Delta[iL];
	      Delta[iL] = HapDelta[iL] = 0.0;
	    }

	    if(TIME_VERBOSE){
	      printf("Testing Removal of Allele %d from Hcuts[iL=%d] = %0.4f: cum wall= %0.6f\n",Allele,iL,Hcuts[iL],wtime());

	      if(VERB>=2){
	        printf("\t Hcuts[LL=%d,L=%d,iL=%d,iM=%d,iR=%d,RR=%d]=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,Delta=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f\n",
	          LL,L,iL,iM,iR,RR,Hcuts[LL],Hcuts[L],Hcuts[iL],Hcuts[iM],Hcuts[iR],Hcuts[RR],Delta[LL],Delta[L],Delta[iL],Delta[iM],Delta[iR]);
		printf("\t Hcuts1[LL=%d,L=%d,iL=%d,iM=%d,iR=%d,RR=%d]=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,HapDelta=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f\n",
	           LL,L,iL,iM,iR,RR,Hcuts1[LL],Hcuts1[L],Hcuts1[iL],Hcuts1[iM],Hcuts1[iR],Hcuts1[RR],HapDelta[LL],HapDelta[L],HapDelta[iL],HapDelta[iM],HapDelta[iR]);
		for(int i = LL; i <= RR; i++)
		  if(HapSite[i] || Delta[i] || HapDelta[i])
		    printf("i=%d:Hcuts[i]=%0.4f,Delta[i]=%0.4f,HapDelta[i]=%0.4f,HapSite[i]=%d:Hcuts1[i]=%0.4f,Hcuts2[i]=%0.4f,Hdel1=%d,Hdel2=%d\n",
			 i,Hcuts[i],Delta[i],HapDelta[i],HapSite[i],Hcuts1[i],Hcuts2[i],Hdel1[i],Hdel2[i]);
		fflush(stdout);
	      }
	    }

	    int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
	    if(err){
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("Testing Removal of Allele %d from Hcuts[iL=%d] = %0.4f(%0.4f):failed due to hsetmap (N1=%d,N2=%d)\n",Allele,iL,Hcuts[iL], Hcuts[iL]+Delta[LL]+Delta[L],N1,N2);
		fflush(stdout);
	      }
	    } else {
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[iL],Hcuts1[iL],Hcuts2[iL],Hcuts2[iL],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB/* HERE >=2 */){
		printf("Testing Removal of Allele %d from Hcuts[iL=%d]= %0.4f(%0.4f): nLP = %0.6f (delta = %0.6f), SNPs = %d, Indels=%d: cum wall= %0.6f\n", 
	          Allele, iL, Hcuts[iL], Hcuts[iL]+Delta[LL]+Delta[L], nLP, nLP-newLP, SNPs, Indels, wtime());
		fflush(stdout);
	      }
	      if(nLP > bestLP){
		bestChange = 1;
		bestLP = nLP;
	      }
	    }
	    HapSite[iL] = prevHapSite[iL];
	    Delta[L] = prevDelta[L];
	    Delta[iL] = prevDelta[iL];
	    HapDelta[L] = prevHapDelta[L];
	    HapDelta[iL] = prevHapDelta[iL];
	    if(DEBUG>=2){
	      for(int i = LL; i < RR; i++){
		assert(HapSite[i] == prevHapSite[i]);
		assert(HapDelta[i] == prevHapDelta[i]);
		assert(Delta[i] == prevDelta[i]);
	      }
	    }

	    /* Next try to just remove right label Hcuts[iR] */
	    if(DEBUG) assert(HapSite[iR]);
	    HapSite[iR] &= ~Allele;
	    if(!HapSite[iR]){
	      HapDelta[iM] += HapDelta[iR];
	      Delta[iM] += Delta[iR];
	      Delta[iR] = HapDelta[iR] = 0.0;
	    }

	    if(VERB>=2){
	      printf("Testing Removal of Allele %d from Hcuts[iR=%d] = %0.4f\n",Allele,iR,Hcuts[iR]);
	      printf("\t Hcuts[LL=%d,L=%d,iL=%d,iM=%d,iR=%d,RR=%d]=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,Delta=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f\n",
	      LL,L,iL,iM,iR,RR,Hcuts[LL],Hcuts[L],Hcuts[iL],Hcuts[iM],Hcuts[iR],Hcuts[RR],Delta[LL],Delta[L],Delta[iL],Delta[iM],Delta[iR]);
	      printf("\t Hcuts1[LL=%d,L=%d,iL=%d,iM=%d,iR=%d,RR=%d]=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,HapDelta=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f\n",
	      LL,L,iL,iM,iR,RR,Hcuts1[LL],Hcuts1[L],Hcuts1[iL],Hcuts1[iM],Hcuts1[iR],Hcuts1[RR],HapDelta[LL],HapDelta[L],HapDelta[iL],HapDelta[iM],HapDelta[iR]);
	      for(int i = LL; i <= RR; i++)
		if(HapSite[i] || Delta[i] || HapDelta[i])
		  printf("i=%d:Hcuts[i]=%0.4f,Delta[i]=%0.4f,HapDelta[i]=%0.4f,HapSite[i]=%d:Hcuts1[i]=%0.4f,Hcuts2[i]=%0.4f,Hdel1=%d,Hdel2=%d\n",
			 i,Hcuts[i],Delta[i],HapDelta[i],HapSite[i],Hcuts1[i],Hcuts2[i],Hdel1[i],Hdel2[i]);
	      fflush(stdout);
	    }

	    err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */

	    if(err){
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("Testing Removal of Allele %d from Hcuts[iR=%d]= %0.4f, %0.4f failed due to hsetmap,N1=%d,N2=%d\n",Allele,iR,Hcuts[iR], Hcuts[iR]+Delta[LL]+Delta[L]+Delta[iL],N1,N2);
		fflush(stdout);
	      }
	    } else {
	      //  		    rverb = 1;
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[iR],Hcuts1[iR],Hcuts2[iR],Hcuts2[iR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      // 	   			   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      //		    rverb = 0;
	      if(VERB/* HERE >=2 */){
		printf("Testing Removal of Allele %d from Hcuts[iR=%d]= %0.4f,%0.4f : nLP = %0.6f (delta = %0.6f), SNPs = %d, Indels=%d: cum wall= %0.6f\n", 
   	          Allele, iR, Hcuts[iR], Hcuts[iR]+Delta[LL]+Delta[L]+Delta[iL], nLP, nLP-newLP, SNPs, Indels, wtime());
		fflush(stdout);
	      }
	      if(nLP > bestLP){
		bestChange = 2;
		bestLP = nLP;
	      }
	    }
	    HapSite[iR] = prevHapSite[iR];		
	    Delta[iM] = prevDelta[iM];
	    Delta[iR] = prevDelta[iR];
	    HapDelta[iM] = prevHapDelta[iM];
	    HapDelta[iR] = prevHapDelta[iR];
	    if(DEBUG>=2){
	      for(int i = LL; i < RR; i++){
		assert(HapSite[i] == prevHapSite[i]);
		assert(HapDelta[i] == prevHapDelta[i]);
		assert(Delta[i] == prevDelta[i]);
	      }
	    }

	    /* need to call hsetmap() so Hcuts1,Hcuts2 are defined for use by LabelMerge */
	    err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);
	    if(DEBUG) assert(err==0);
	  }

	  //		rverb = (iter==71) ? 1 : 0;
	  if(!LabelMerge(Allele, LL, L, iL, iR, RR, mergeKB, numthreads, MD, MX, map1, mapK1, map2, mapK2, nmap1, nmapK1, nmap2, nmapK2, N1, Y1, N2, Y2, n, Hcuts, Hcuts1, Hcuts2, HapSite, Delta, HapDelta, prevHapSite, prevDelta, prevHapDelta, spreadDelta, spreadHapDelta, Label, Index, Hremap, Hdel1, Hdel2)){
	    // rverb = 0;

	    //		rverb = 1 /* (iter==375 ? 1 : 0*/;
	    if(cresFix){
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      //					   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB>=1+RELEASE/* HERE >=2 */){
	        printf("Testing Merging labels iL=%d,iR=%d : nLP= %0.6f (delta = %0.6f), SNPs=%d,Indels=%d: cum wall= %0.6f\n",iL,iR,nLP,nLP - newLP, SNPs,Indels, wtime());
		fflush(stdout);
	      }
	      if(nLP > bestLP){
		bestChange = 3;
		bestLP = nLP;
	      }
	    } else {
	      cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				     TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("\t newLP= %0.6f -> %0.6f, SNPs=%d,Indels=%d\n",newLP,nLP,SNPs,Indels);
		fflush(stdout);
	      }
	      newLP = nLP;
	      IndelCnt = Indels;
	      SNPcnt = SNPs;
	    }
	  } else if(!cresFix){
	    //		  rverb = 0;
	    break;/* break out of while(progress) */
	  }
	  //		rverb = 0;
		  
	  if(cresFix){
	    if(bestChange < 3){
	      memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
	      if(HPROBEVAL_SPREAD){  /* need to restore map1[],map2[] */
		int block = 1;
		while(block < 16 && MD > numthreads * block)
		  block *= 2;

                #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		for(int m = 0; m < MD; m++){
		  int M = MX[m];

		  memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		  memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		  memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		  memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
		}
	      }
	      if(TIME_VERBOSE){
		printf("Restored: Hcuts[LL=%d,L=%d,iL=%d,iR=%d,RR=%d]=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,Delta=%0.4f,%0.4f,%0.4f,%0.4f,HapDelta=%0.4f,%0.4f,%0.4f,%0.4f,best=%d: cum wall= %0.6f\n",
		       LL,L,iL,iR,RR,Hcuts[LL],Hcuts[L],Hcuts[iL],Hcuts[iR],Hcuts[RR],Delta[LL],Delta[L],Delta[iL],Delta[iR],HapDelta[LL],HapDelta[L],HapDelta[iL],HapDelta[iR],bestChange,wtime());
		if(VERB>=3){
		  for(int i = LL; i <= RR; i++)
		    if(HapSite[i] || Delta[i] || HapDelta[i])
		      printf("i=%d:Hcuts[i]=%0.4f,Delta[i]=%0.4f,HapDelta[i]=%0.4f,HapSite[i]=%d\n",i,Hcuts[i],Delta[i],HapDelta[i],HapSite[i]);
		  printf("\t bestChange=%d\n",bestChange);
		  fflush(stdout);
		}
	      }
	    }

	    if(bestChange == 1){
	      if(DEBUG) assert(HapSite[iL]);
	      HapSite[iL] &= ~Allele;
	      if(!HapSite[iL]){
		HapDelta[L] += HapDelta[iL];
		Delta[L] += Delta[iL];
		Delta[iL] = HapDelta[iL] = 0.0;
	      }
	    }
	    if(bestChange == 2){
	      if(DEBUG) assert(HapSite[iR]);
	      HapSite[iR] &= ~Allele;
	      if(!HapSite[iR]){
		HapDelta[iM] += HapDelta[iR];
		Delta[iM] += Delta[iR];
		Delta[iR] = HapDelta[iR] = 0.0;
	      }
	    }
	    if(bestChange){
	      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
	      cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
	      //		    rverb = 1;
#if 1 // HERE HERE : use full hprobeval, until verifying that faster method is equivalent
	      nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,0.0/*Hcuts1[LL]*/,Hcuts1[n+1]/*Hcuts1[RR]*/,0.0 /*Hcuts2[LL]*/,Hcuts2[n+1]/*Hcuts2[RR]*/,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
#else
	      // NOTE : cannot use fastest incremental hprobeval, since all nmap1[] for maps to the right of the point of change need to be updated as well to reflect label deletions in Y1,Y2
	      nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
#endif
	      //		    rverb = 0;
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		if(bestChange==1)
		  printf("Deleting Allele %d from Hcuts[iL=%d]=%0.4f(%0.4f)",Allele,iL,Hcuts[iL],Hcuts[iL]+Delta[LL]+Delta[L]);
		else if(bestChange==2)
		  printf("Deleting Allele %d from Hcuts[iR=%d]=%0.4f(%0.4f)",Allele,iR,Hcuts[iR],Hcuts[iR]+Delta[LL]+Delta[L]+Delta[iL]);
		else
		  printf("Merging Hcuts[%d,%d]=%0.4f,%0.4f(%0.4f,%0.4f) on Allele %d",iL,iR,Hcuts[iL],Hcuts[iR],Hcuts[iL]+Delta[LL]+Delta[L],Hcuts[iR]+Delta[LL]+Delta[L]+Delta[iL],Allele);
		if(TIME_VERBOSE)
		  printf(": newLP= %0.6f -> %0.6f (err=%0.6f), SNPs=%d,Indels=%d: cum wall= %0.6f\n",newLP,nLP,nLP-bestLP,SNPs,Indels, wtime());
		else
		  printf(": newLP= %0.6f -> %0.6f (err=%0.6f), SNPs=%d,Indels=%d\n",newLP,nLP,nLP-bestLP,SNPs,Indels);
		fflush(stdout);
	      }
	      if(DEBUG) assert(nLP >= bestLP - (USE_MFLOAT ? 1e-4 : 1e-5));
	      newLP = nLP;
	      IndelCnt = Indels;
	      SNPcnt = SNPs;
	      double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;

	      if(DELTA_STOP >= 3){	      /* re-activate nearby intervals */
		double DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		int IN1 = floor((Hcuts[iL] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		int IN2 = floor((Hcuts[iR] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		IN1 = max(0, IN1);
		IN2 = min(maxIN, IN2);
		if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
		  printf("After merging Hcuts[i=%d,iR=%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			 iL,iR,Hcuts[iL],Hcuts[iR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		  fflush(stdout);
		  assert(0 <= IN1 && IN1 <= maxIN);
		}
		if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
		  printf("After merging Hcuts[i=%d,iR=%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			 iL,iR,Hcuts[iL],Hcuts[iR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		  fflush(stdout);
		  assert(0 <= IN2 && IN2 <= maxIN);
		}
		if(DEBUG) assert(IN1 <= IN2);
		  
		int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		int origactivecnt = activecnt;

		for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
		  if(DELTA_RANGE[T] <= 0){
		    activecnt++;
		    DELTA_RANGE[T] = min_DELTA;
		    for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
		      Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
		    if(HAPSTOP_DEBUG){
		      printf("Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to merging of Hcuts[%d..%d]=%0.4f..%0.4f\n",
			     T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			     DELTA_RANGE[T],Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],iL, iR, Hcuts[iL], Hcuts[iR]);
		      fflush(stdout);
		    }
		  } else if(HAPSTOP_DEBUG>=2){
		    printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after merging of Hcuts[%d..%d] with DELTA_RANGE[T]=%d (%0.3f .. %0.3f)\n",
			   T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			   iL,iR,DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1]);
		    fflush(stdout);
		  }
		}

		if(VERB && activecnt > origactivecnt){
		  if(VERB>=2 || HAPSTOP_DEBUG){
		    int inactivecnt = 0;
		    for(int IN = 0; IN <= maxIN; IN++)
		      if(DELTA_RANGE[IN] <= 0)
			inactivecnt++;

		    printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f : inactive intervals = %d/%d\n",
		       activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, iL, iR, Hcuts[iL], Hcuts[iR], inactivecnt,maxIN+1);
	          } else
		    printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f\n",
		  activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, iL, iR, Hcuts[iL], Hcuts[iR]);
		  fflush(stdout);
		}
	      }	      
	    }
	  } // if(cresFix)
	}// smallKB <= mergeKB
      }

      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
      if(DEBUG/* HERE >=2 */ || cres > 0.0){/* verify LP value (and update nmap) */
	//	rverb = 1;
	double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2, 0, 0, 0.0, 0.0, 0.0, 0.0, 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	//	rverb = 0;
	if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) || VERB/* HERE >=2 */){
	  printf("After merging all sites closer than mergeKB= %0.3f kb:\n",mergeKB);
	  if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt))
	    printf("WARNING: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d: cum wall= %0.6f\n", nLP2,newLP,nLP2-newLP, SNPs, Indels,wtime());
	  else
	    printf("nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d: cum wall= %0.6f\n", nLP2,newLP,nLP2-newLP, SNPs, Indels,wtime());
	  fflush(stdout);
	  if(DEBUG>=1+RELEASE) assert(fabs(nLP2 - newLP) < 1e-4 && SNPs == SNPcnt && Indels == IndelCnt);
	}
	newLP = nLP2;
	SNPcnt = SNPs;
	IndelCnt = Indels;

      }

      if(cres > rres){
	if(VERB>=3){/* display alignments of molecules near Hcuts= 19673.3990 .. 19687.4437 */
	  rverb = 1;
	  printf("Displaying hprobeval near Hcuts[39955..39988] before cres merging\n");
	  fflush(stdout);
	  double qLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				 TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[39955],Hcuts1[39988],Hcuts2[39955],Hcuts2[39988],0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels, 0);
	  printf("qLP= %0.8f\n",qLP);
	  fflush(stdout);
	  rverb = 0;
	}

	int iterations = (int)floor((cres - rres) / 0.40 + 0.5);
	double res_delta = (cres - rres) * 0.500 / max(1,iterations) - 1e-8;
	res_delta = max(0.100, res_delta);
	      
	if(VERB>=3){
	  printf("Checking all sites closer than cres=%0.3f kb: N1=%d,N2=%d,Y1[1,N1]=%0.3f,%0.3f,Y2[1,N2]=%0.3f,%0.3f\n",
		 cres * 0.500, N1,N2,Y1[1],Y1[N1],Y2[1],Y2[N2]);
	  for(int I = 1; I < N1; I++)
	    printf("I=%d:Y1[I]=%0.4f, Y1[I+1]-Y1[I]= %0.4f\n", I, Y1[I], Y1[I+1] - Y1[I]);
	  for(int I = 1; I < N2; I++)
	    printf("I=%d:Y2[I]=%0.4f, Y2[I+1]-Y2[I]= %0.4f\n", I, Y2[I], Y2[I+1] - Y2[I]);
	  fflush(stdout);
	}

	/* assign each molecule into one of two Alleles */
	for(int m = 0; m < MD; m++){
	  double LP1 = bestLPA1[m];
	  double LP2 = bestLPA2[m];
	  pcontig->MapPhase[m] = 1.0/(1.0 + exp(LP2-LP1));
	}

	double prev_cresKB = CRES_CUMULATIVE ? 0.0 : rres * 0.500;

	for(double cresKB = prev_cresKB + res_delta; cresKB <= cres * 0.5; prev_cresKB = (CRES_CUMULATIVE ? 0.0 : cresKB), cresKB += res_delta){
	  if(VERB){
	    printf("Checking all sites within %0.3f ..  %0.3f kb (cres=%0.3f kb): LP=%0.6f,minKB=%0.6f (N1=%d,N2=%d,Y1[1,N1]=%0.3f,%0.3f,Y2[1,N2]=%0.3f,%0.3f): cum wall= %0.6f\n", 
		   prev_cresKB, cresKB, cres * 0.5,newLP,minKB,N1,N2,Y1[1],Y1[N1],Y2[1],Y2[N2],wtime());
	    fflush(stdout);
	  }

	  /* first check 2 consecutive sites closer than cresKB on  Allele1 */
	  for(int I = 1; I < N1; I++){
	    if(Y1[I + 1] - Y1[I] > cresKB)
	      continue;
	    if(!CRES_CUMULATIVE && Y1[I + 1] - Y1[I] <= prev_cresKB)
	      continue;
		  
	    int iL = nmap1[MD][I];
	    int iR = nmap1[MD][I + 1];
	    if(DEBUG) assert(1 <= iL && iL <= iR && iR <= n);
	    if(DEBUG) assert(HapSite[iL] & 1);
	    if(DEBUG) assert(HapSite[iR] & 1);
		  
	    /* count number of molecules that have separate sites aligned to Y1[I] and Y1[I+1] */
	    int cnt = 0, ccnt = 0, lcnt = 0, rcnt = 0, bcnt = 0;
	    double Wcnt = 0.0, Wccnt = 0.0, Wlcnt = 0.0, Wrcnt = 0.0, Wbcnt = 0.0;

	    // HERE HERE : multithread ?
	    for(int m = 0; m < MD; m++){
	      double wt = pcontig->MapPhase[m];
	      if(wt < 1.0 - HapAlleleProb)/* definitely Allele2 */
		continue;
	      wt *= TBmapWT[m];

	      int M = MX[m];
	      int J = 1;
	      for(; J <= M; J++){
		if(DEBUG>=2) assert(nmap1[m][J] == -1 || (1 <= nmap1[m][J] && nmap1[m][J] <= N1 && nmapK1[m][J] >= 0 && nmapK1[m][J] <= KMAX && nmap1[m][J] > nmapK1[m][J]));
		if(nmap1[m][J] >= I)
		  break;
	      }
	      int left = (J <= M && nmap1[m][J] >= I && nmap1[m][J] - nmapK1[m][J] <= I) ? J : 0;

	      if(!CRES_CNT_FIX)
		J++;
	      for(; J <= M; J++){
		if(DEBUG>=2) assert(nmap1[m][J] == -1 || (1 <= nmap1[m][J] && nmap1[m][J] <= N1 && nmapK1[m][J] >= 0 && nmapK1[m][J] <= KMAX && nmap1[m][J] > nmapK1[m][J]));
		if(nmap1[m][J] >= I + 1)
		  break;
	      }
	      int right = (J <= M && nmap1[m][J] >= I + 1 && nmap1[m][J] - nmapK1[m][J] <= I + 1) ? J : 0;
	      int both = (J <= M && nmap1[m][J] >= I + 1 && nmap1[m][J] - nmapK1[m][J] <= I) ? J : 0;
	      if(both){
		if(DEBUG && CRES_CNT_FIX) assert(left && right && left == right && right == both); // WAS11 assert(left || right);
		bcnt++;
		Wbcnt += wt;
	      }
	      if(left || right){
		ccnt++;
		Wccnt += wt;
	      }
	      if(left && !right){
		lcnt++;
		Wlcnt += wt;
	      }
	      if(right && !left){
		rcnt++;
		Wrcnt += wt;
	      }
	      if(left && right && (!CRES_CNT_FIX || left != right)){
		if(VERB>=3){
		  int IL = nmap1[m][left], IR = nmap1[m][right];
		  int KL = nmapK1[m][left], KR = nmapK1[m][right];
		  printf("    Allele1 at I=%d,%d(i=%d..%d):m=%d (id=%lld, Phase= %0.6f) : M=%d, left=%d(nmap1:%d..%d,map1:%d..%d), right=%d(nmap1:%d..%d,map1:%d..%d)\n",
			 I,I+1,iL,iR,m, gmap[pcontig->contig[m].mapid]->id, pcontig->MapPhase[m], M, left, IL-KL, IL, map1[m][left]-mapK1[m][left],map1[m][left], right, IR-KR, IR, map1[m][right]-mapK1[m][right],map1[m][right]);
		  fflush(stdout);
		}
		cnt++;
		Wcnt += wt;
	      }
	    } // for m = 0 .. MD-1

	    //	    int iL = nmap1[MD][I];
	    //	    int iR = nmap1[MD][I+1];

	    int ccntF = (int) floor(ccnt * cresF + 0.5);
	    if(TIME_VERBOSE){
	      printf("Checking Merging Y1[%d]=%0.4f,Y1[%d]=%0.4f (Hcuts[%d,%d]=%0.4f,%0.4f,delta=%0.4f, mol cnt=%d+%d+%d+%d/%d, cresKB=%0.4f):cum wall= %0.6f\n",
		     I,Y1[I],I+1,Y1[I+1],iL,iR,Hcuts[iL],Hcuts[iR],Y1[I+1]-Y1[I],cnt,lcnt,rcnt,bcnt,ccnt,cresKB,wtime());
	      fflush(stdout);
	    }
	    if(cnt < max(cresN, ccntF)){ /* merge Y1[I] with Y1[I+1] */
	      if(VERB){
		printf("Testing Merging Y1[%d]=%0.4f,Y1[%d]=%0.4f (Hcuts1[%d,%d]=%0.4f,%0.4f,delta=%0.4f,mol cnt=%d+%d+%d+%d/%d(%0.1f+%0.1f+%0.1f+%0.1f/%0.1f), cresKB=%0.4f,cresN=%d,ccntF=%d):\n",
		       I,Y1[I],I+1,Y1[I+1],iL,iR,Hcuts1[iL],Hcuts1[iR],Y1[I+1]-Y1[I],cnt,lcnt,rcnt,bcnt,ccnt,Wcnt,Wlcnt,Wrcnt,Wbcnt,Wccnt,cresKB,cresN,ccntF);
		fflush(stdout);
	      }


	      int Allele = 1;
	      if(HapSite[iL]==3 && HapSite[iR]==3 && map2[MD][iR] == map2[MD][iL] + 1 && Hcuts2[iR] - Hcuts2[iL] < cresKB + res_delta){ /* check if Allele2 should also be merged */
		int I = map2[MD][iL];
		if(DEBUG) assert(0 < I && I < N2);
		int cnt = 0, ccnt = 0, lcnt = 0, rcnt = 0, bcnt = 0;
		double Wcnt = 0.0, Wccnt = 0.0, Wlcnt = 0.0, Wrcnt = 0.0, Wbcnt = 0.0;

		// HERE HERE : multithread this loop ?
		for(int m = 0; m < MD; m++){
		  double wt = pcontig->MapPhase[m];
		  if(wt > HapAlleleProb)/* definitely Allele1 */
		    continue;
		  wt *= TBmapWT[m];

		  int M = MX[m];
		  int J = 1;
		  for(; J <= M; J++){
		    if(DEBUG>=2) assert(nmap2[m][J] == -1 || (1 <= nmap2[m][J] && nmap2[m][J] <= N2 && nmapK2[m][J] >= 0 && nmapK2[m][J] <= KMAX && nmap2[m][J] > nmapK2[m][J]));
		    if(nmap2[m][J] >= I)
		      break;
		  }
		  int left = (J <= M && nmap2[m][J] >= I && nmap2[m][J] - nmapK2[m][J] <= I) ? J : 0;
		  if(!CRES_CNT_FIX)
		    J++;
		  for(; J <= M; J++){
		    if(DEBUG>=2) assert(nmap2[m][J] == -1 || (1 <= nmap2[m][J] && nmap2[m][J] <= N2 && nmapK2[m][J] >= 0 && nmapK2[m][J] <= KMAX && nmap2[m][J] > nmapK2[m][J]));
		    if(nmap2[m][J] >= I + 1)
		      break;
		  }
		  int right = (J <= M && nmap2[m][J] >= I + 1 && nmap2[m][J] - nmapK2[m][J] <= I + 1) ? J : 0;
		  int both = (J <= M && nmap2[m][J] >= I + 1 && nmap2[m][J] - nmapK2[m][J] <= I) ? J : 0;
		  if(both){
		    if(DEBUG && CRES_CNT_FIX) assert(left && right && left == right && right == both); // WAS11 assert(left || right);
		    bcnt++;
		    Wbcnt += wt;
		  }
		  if(left || right){
		    ccnt++;
		    Wccnt += wt;
		  }
		  if(left && !right){
		    lcnt++;
		    Wlcnt += wt;
		  }
		  if(right && !left){
		    rcnt++;
		    Wrcnt += wt;
		  }
		  if(left && right && (!CRES_CNT_FIX || left != right)){
		    if(VERB>=3){
		      int IL = nmap2[m][left], IR = nmap2[m][right];
		      int KL = nmapK2[m][left], KR = nmapK2[m][right];
		      printf("    Allele2 at I=%d,%d(i=%d..%d):m=%d (id=%lld, Phase=%0.6f) : M=%d, left=%d(nmap2:%d..%d,map2:%d..%d), right=%d(nmap2:%d..%d,map2:%d..%d)\n",
			     I,I+1,iL,iR,m, gmap[pcontig->contig[m].mapid]->id, pcontig->MapPhase[m], M, left, IL-KL, IL, map2[m][left]-mapK2[m][left],map2[m][left],right, IR-KR, IR,map2[m][right]-mapK2[m][right],map2[m][right]);
		      fflush(stdout);
		    }

		    cnt++;
		    Wcnt += wt;
		  }
		} 

		int ccntF = (int) floor(ccnt * cresF + 0.5);
		if(TIME_VERBOSE){
		  printf("Checking also merging Y2[%d]=%0.4f,Y2[%d]=%0.4f (Hcuts2[%d,%d]=%0.4f,%0.4f,delta=%0.4f, mol cnt=%d+%d+%d+%d/%d(%0.1f+%0.1f+%0.1f+%0.1f/%0.1f),cresKB=%0.4f):cum wall= %0.6f\n",
			 I,Y2[I],I+1,Y2[I+1],iL,iR,Hcuts2[iL],Hcuts2[iR],Y2[I+1]-Y2[I],cnt,lcnt,rcnt,bcnt,ccnt,Wcnt,Wlcnt,Wrcnt,Wbcnt,Wccnt,cresKB,wtime());
		  fflush(stdout);
		}
		if(cnt * 4 < max(cresN, ccntF) * 5){/* NOTE: slightly loser check to encourage merging both Alleles the same way */
		  if(VERB){
		    printf("Testing also merging Y2[%d]=%0.4f,Y2[%d]=%0.4f (Hcuts2[%d,%d]=%0.4f,%0.4f,delta=%0.4f, mol cnt=%d+%d+%d+%d/%d(%0.1f+%0.1f+%0.1f+%0.1f/%0.1f), cresKB=%0.4f):\n",
			   I,Y2[I],I+1,Y2[I+1],iL,iR,Hcuts2[iL],Hcuts2[iR],Y2[I+1]-Y2[I],cnt,lcnt,rcnt,bcnt,ccnt,Wcnt,Wlcnt,Wrcnt,Wbcnt,Wccnt,cresKB);
		    fflush(stdout);
		  }
		  Allele = 3;
		}
	      }

	      /* locate L, first label left of interval Hcuts[iL,iR] */
	      int L= iL - 1;
	      for(; L > 0; L--)
		if(HapSite[L])
		  break;
	      /* locate LL, first non-Hap label left of interval Hcuts[iL,iR] */
	      int LL = L;
	      for(; LL > 0; LL--)
		if(HapSite[LL]==3)
		  break;
	      /* locate RR, first non-Hap label right of interval Hcuts[iL,iR] */
	      int RR = iR + 1;
	      for(; RR <= n; RR++)
		if(HapSite[RR]==3)
		  break;

	      memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	      memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL+1)*sizeof(int));
	      if(HPROBEVAL_SPREAD){  /* need to backup map1[],map2[] */
		int LoopCnt = 0;

		int block = 1;
		while(block < 16 && MD > numthreads * block)
		  block *= 2;

                #pragma omp parallel num_threads(numthreads)
		{
		  int myLoopCnt = 0;

                  #pragma omp for schedule(static,block)
		  for(int m = 0; m < MD; m++){
		    if(OMP_DEBUG) myLoopCnt++;
		    int M = MX[m];

		    memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
		    memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
		    memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
		    memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
		  }
		  if(OMP_DEBUG && myLoopCnt > 0){
                    #pragma omp critical
		    {
		      LoopCnt += myLoopCnt;
		    }
		  }
		} // omp parallel
		if(OMP_DEBUG) assert(LoopCnt == MD);
		if(TIME_VERBOSE){
		  printf("Saved map1,map2 (block=%d): cum wall= %0.6f\n",block,wtime());
		  fflush(stdout);
	        }
	      }
		
	      int bestChange = 0;/* 0 or -1 means no change (-1 means recompute nmap[] anyway), 1 means delete Hcuts[iL], 2 means delete Hcuts[iR], 3 means merge Hcuts[iL,iR] */
	      double bestLP = newLP - BigPen;

	      if(cresFix){

		/* First try to just remove left label Hcuts[iL] */
		HapSite[iL] &= ~Allele;
		if(!HapSite[iL]){
		  HapDelta[L] += HapDelta[iL];
		  Delta[L] += Delta[iL];
		  Delta[iL] = HapDelta[iL] = 0.0;
		}

		int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
		if(err){
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("Testing Removal of Allele %d from Hcuts[iL=%d] = %0.4f failed due to hsetmap\n",Allele,iL,Hcuts[iL]);
		    fflush(stdout);
		  }
		} else {
		  //		  rverb = 1;
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[iL],Hcuts1[iL],Hcuts2[iL],Hcuts2[iL],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  //		  rverb = 0;
		  if(VERB/* HERE >=2 */){
		    printf("Testing Removal of Allele %d from Hcuts[iL=%d]= %0.4f : nLP = %0.6f (delta = %0.6f), SNPs = %d, Indels=%d:cum wall= %0.6f\n", Allele, iL, Hcuts[iL], nLP, nLP-newLP, SNPs, Indels,wtime());
		    fflush(stdout);
		  }
		  if(nLP > bestLP){
		    bestChange = 1;
		    bestLP = nLP;
		  }
		}
		HapSite[iL] = prevHapSite[iL];
		Delta[L] = prevDelta[L];
		Delta[iL] = prevDelta[iL];
		HapDelta[L] = prevHapDelta[L];
		HapDelta[iL] = prevHapDelta[iL];
		if(DEBUG>=2){
		  for(int i = LL; i < RR; i++){
		    if(HapSite[i] != prevHapSite[i] || HapDelta[i] != prevHapDelta[i] || Delta[i] != prevDelta[i]){
		      printf("LL=%d,L=%d,iL=%d,iR=%d,RR=%d;i=%d:HapSite=%d,%d,%d,%d,%d;%d, (prev=%d,%d,%d,%d,%d;%d), Hcuts=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f;%0.4f\n",
			     LL,L,iL,iR,RR,i,HapSite[LL],HapSite[L],HapSite[iL],HapSite[iR],HapSite[RR],HapSite[i],
			     prevHapSite[LL],prevHapSite[L],prevHapSite[iL],prevHapSite[iR],prevHapSite[RR],prevHapSite[i],
			     Hcuts[LL],Hcuts[L],Hcuts[iL],Hcuts[iR],Hcuts[RR],Hcuts[i]);
		      printf("\t HapDelta= %0.4f,%0.4f,%0.4f,%0.4f,%0.4f;%0.4f, Delta=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f;%0.4f\n",
			     HapDelta[LL],HapDelta[L],HapDelta[iL],HapDelta[iR],HapDelta[RR],HapDelta[i],
			     Delta[LL],Delta[L],Delta[iL],Delta[iR],Delta[RR],Delta[i]);
		      printf("\t prevHapDelta= %0.4f,%0.4f,%0.4f,%0.4f,%0.4f;%0.4f, prevDelta=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f;%0.4f\n",
			     prevHapDelta[LL],prevHapDelta[L],prevHapDelta[iL],prevHapDelta[iR],prevHapDelta[RR],prevHapDelta[i],
			     prevDelta[LL],prevDelta[L],prevDelta[iL],prevDelta[iR],prevDelta[RR],prevDelta[i]);
		      fflush(stdout);
		      assert(HapSite[i] == prevHapSite[i]);
		      assert(HapDelta[i] == prevHapDelta[i]);
		      assert(Delta[i] == prevDelta[i]);
		    }
		  }
		}

		/* Next try to just remove right label Hcuts[iR] */
		HapSite[iR] &= ~Allele;
		if(!HapSite[iR]){
		  HapDelta[iL] += HapDelta[iR];
		  Delta[iL] += Delta[iR];
		  Delta[iR] = HapDelta[iR] = 0.0;
		}

		err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
		if(err){
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("Testing Removal of Allele %d from Hcuts[iR=%d] = %0.4f failed due to hsetmap\n",Allele,iR,Hcuts[iR]);
		    fflush(stdout);
		  }
		} else {
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[iR],Hcuts1[iR],Hcuts2[iR],Hcuts2[iR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB/* HERE >=2 */){
		    printf("Testing Removal of Allele %d from Hcuts[iR=%d]= %0.4f : nLP = %0.6f (delta = %0.6f), SNPs = %d, Indels=%d: cum wall= %0.6f\n", Allele, iR, Hcuts[iR], nLP, nLP-newLP, SNPs, Indels,wtime());
		    fflush(stdout);
		  }
		  if(nLP > bestLP){
		    bestChange = 2;
		    bestLP = nLP;
		  }
		}
		HapSite[iR] = prevHapSite[iR];		
		Delta[iL] = prevDelta[iL];
		Delta[iR] = prevDelta[iR];
		HapDelta[iL] = prevHapDelta[iL];
		HapDelta[iR] = prevHapDelta[iR];
		if(DEBUG>=2){
		  for(int i = LL; i < RR; i++){
		    assert(HapSite[i] == prevHapSite[i]);
		    assert(HapDelta[i] == prevHapDelta[i]);
		    assert(Delta[i] == prevDelta[i]);
		  }
		}

		/* need to call hsetmap() so Hcuts1,Hcuts2 are defined for use by LabelMerge */
		err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);
		if(DEBUG) assert(err==0);
	      }

	      // rverb = (iter==55) ? 1 : 0;
	      if(!LabelMerge(Allele, LL, L, iL, iR, RR, cresKB, numthreads, MD, MX, map1, mapK1, map2, mapK2, nmap1, nmapK1, nmap2, nmapK2, N1, Y1, N2, Y2, n, Hcuts, Hcuts1, Hcuts2, HapSite, Delta, HapDelta, prevHapSite, prevDelta, prevHapDelta, spreadDelta, spreadHapDelta, Label, Index, Hremap, Hdel1, Hdel2)){
		//		      rverb = 0;
		      
		//		  rverb = (iter==45) ? 1 : 0;
		if(cresFix){
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("Testing Merging labels iL=%d,iR=%d : LP= %0.6f (delta = %0.6f), SNPs=%d,Indels=%d: cum wall= %0.6f\n",iL,iR,nLP,nLP-newLP,SNPs,Indels,wtime());
		    fflush(stdout);
		  }
		  if(nLP > bestLP){
		    bestChange = 3;
		    bestLP = nLP;
		  }
		} else {
		  cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
					 TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("\t newLP= %0.6f -> %0.6f, SNPs=%d,Indels=%d: cum wall= %0.6f\n",newLP,nLP,SNPs,Indels, wtime());
		    fflush(stdout);
		  }
		  newLP = nLP;
		  IndelCnt = Indels;
		  SNPcnt = SNPs;
		}
	      } else if(!cresFix) {// !LabelMerge()
		//		    rverb = 0;
		continue;/* next I for Allele1 */
	      }
	      // rverb = 0;

	      if(cresFix){
		if(bestChange && cresMaxLPdrop >= 0.0 && bestLP < newLP - cresMaxLPdrop){// NEW12
		  if(VERB/* HERE HERE >=2 */){
		    printf("skipping Merging labels due to -cresMaxLPdrop %0.3f (best delta = %0.6f), newLP= %0.6f\n",cresMaxLPdrop, bestLP - newLP, newLP);
		    fflush(stdout);
		  }
		  bestChange = -1;
		  bestLP = newLP;
		}

		if(bestChange < 3){
		  memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL+1)*sizeof(int));
		  int block = 1;
		  if(HPROBEVAL_SPREAD){  /* need to restore map1[],map2[] */
		    while(block < 16 && MD > numthreads * block)
		      block *= 2;

                    #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		    for(int m = 0; m < MD; m++){
		      int M = MX[m];

		      memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		      memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		      memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		      memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
		    }
		  }
		  if(TIME_VERBOSE){
		    printf("Restored map1,map2(block=%d): cum wall= %0.6f\n",block,wtime());
		    fflush(stdout);
		  }
		}

		if(bestChange == 1){
		  HapSite[iL] &= ~Allele;
		  if(!HapSite[iL]){
		    HapDelta[L] += HapDelta[iL];
		    Delta[L] += Delta[iL];
		    Delta[iL] = HapDelta[iL] = 0.0;
		  }
		}
		if(bestChange == 2){
		  HapSite[iR] &= ~Allele;
		  if(!HapSite[iR]){
		    HapDelta[iL] += HapDelta[iR];
		    Delta[iL] += Delta[iR];
		    Delta[iR] = HapDelta[iR] = 0.0;
		  }
		}
		if(bestChange){
		  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
		  cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
		  if(bestChange > 0){
#if 1 // HERE HERE : use full hprobeval until faster method has been verified
		    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,0.0,Hcuts1[n+1],0.0,Hcuts2[n+1],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
#else
		    // NOTE : does not save much time, since relatively few labels are deresed in this stage
		    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[n+1],Hcuts2[LL],Hcuts2[n+1],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
#endif
		  } else {// NEW75 : incremental hprobeval() only, just to verify LP value is restored : no need to recompute nmap[]
		    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    
		  }
		  if(VERB/* HERE >=2 */){
		    if(bestChange <= 0)
		      printf("Skipping Merging labels Hcuts[%d,%d]= %0.4f,%0.4f on Allele %d", iL,iR,Hcuts[iL],Hcuts[iR],Allele);
		    else if(bestChange==1)
		      printf("Deleting Allele %d from Hcuts[iL=%d]=%0.4f",Allele,iL,Hcuts[iL]);
		    else if(bestChange==2)
		      printf("Deleting Allele %d from Hcuts[iR=%d]=%0.4f",Allele,iR,Hcuts[iR]);
		    else
		      printf("Merging Hcuts[%d,%d]=%0.4f,%0.4f on Allele %d",iL,iR,Hcuts[iL],Hcuts[iR],Allele);
		    if(TIME_VERBOSE)
		      printf(": newLP= %0.6f -> %0.6f (err=%0.6f), SNPs=%d,Indels=%d: cum wall= %0.6f\n",newLP,nLP,nLP-bestLP,SNPs,Indels,wtime());
		    else
		      printf(": newLP= %0.6f -> %0.6f (err=%0.6f), SNPs=%d,Indels=%d\n",newLP,nLP,nLP-bestLP,SNPs,Indels);
		    fflush(stdout);
		  }
		  if(bestChange > 0)
		    changecnt++;
		  if(!(nLP >= bestLP - (USE_MFLOAT ? 1e-4 : 1e-5) * MD)){
		    printf("WARNING: unexpected drop in likelihood (err=%0.6f)\n",nLP-bestLP);
		    fflush(stdout);
		  }
		}
		newLP = nLP;
		IndelCnt = Indels;
		SNPcnt = SNPs;
		double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
		tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;

		if(DELTA_STOP >= 3 && bestChange > 0){	      /* re-activate nearby intervals */
		  double DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		  int IN1 = floor((Hcuts[iL] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		  int IN2 = floor((Hcuts[iR] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		  IN1 = max(0, IN1);
		  IN2 = min(maxIN, IN2);
		  if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
		    printf("After merging Hcuts[i=%d,iR=%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			   iL,iR,Hcuts[iL],Hcuts[iR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		    fflush(stdout);
		    assert(0 <= IN1 && IN1 <= maxIN);
		  }
		  if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
		    printf("After merging Hcuts[i=%d,iR=%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			   iL,iR,Hcuts[iL],Hcuts[iR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		    fflush(stdout);
		    assert(0 <= IN2 && IN2 <= maxIN);
		  }
		  if(DEBUG) assert(IN1 <= IN2);
		  
		  int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		  int origactivecnt = activecnt;

		  for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
		    if(DELTA_RANGE[T] <= 0){
		      activecnt++;
		      DELTA_RANGE[T] = min_DELTA;
		      for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
			Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
		      if(HAPSTOP_DEBUG){
			printf("Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to merging of Hcuts[%d..%d]=%0.4f..%0.4f\n",
			       T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			       DELTA_RANGE[T],Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],iL, iR, Hcuts[iL], Hcuts[iR]);
			fflush(stdout);
		      }
		    } else if(HAPSTOP_DEBUG>=2){
		      printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after merging of Hcuts[%d..%d] with DELTA_RANGE[T]=%d (%0.3f .. %0.3f)\n",
			     T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			     iL,iR,DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1]);
		      fflush(stdout);
		    }
		  }

		  if(VERB && activecnt > origactivecnt){
		    if(VERB>=2 || HAPSTOP_DEBUG){
		      int inactivecnt = 0;
		      for(int IN = 0; IN <= maxIN; IN++)
			if(DELTA_RANGE[IN] <= 0)
			  inactivecnt++;

		      printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f : inactive intervals = %d/%d\n",
			     activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, iL, iR, Hcuts[iL], Hcuts[iR], inactivecnt,maxIN+1);
		    } else
		      printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f\n",
			     activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, iL, iR, Hcuts[iL], Hcuts[iR]);
		    fflush(stdout);
		  }
		}	      
	      } // if(cresFix)
	    } // cnt < max(cresN,ccntF)
	  }

	  /* next check 2 consecutive sites closer than cresKB on  Allele2 */
	  for(int I = 1; I < N2; I++){
	    if(Y2[I + 1] - Y2[I] > cresKB)
	      continue;
	    if(!CRES_CUMULATIVE && Y2[I + 1] - Y2[I] <= prev_cresKB)
	      continue;

	    int iL = nmap2[MD][I];
	    int iR = nmap2[MD][I + 1];
	    if(DEBUG) assert(1 <= iL && iL <= iR && iR <= n);
	    if(DEBUG) assert(HapSite[iL] & 2);
	    if(DEBUG) assert(HapSite[iR] & 2);

	    /* count number of molecules that have separate sites aligned to Y2[I] and Y2[I+1] */
	    int cnt = 0, lcnt = 0, rcnt = 0, ccnt = 0, bcnt = 0;
	    double Wcnt = 0.0, Wccnt = 0.0, Wlcnt = 0.0, Wrcnt = 0.0, Wbcnt = 0.0;		  

	    // HERE HERE : multithread ?
	    for(int m = 0; m < MD; m++){
	      double wt = pcontig->MapPhase[m];
	      if(wt > HapAlleleProb)/* definitely Allele1 */
		continue;
	      wt *= TBmapWT[m];

	      int M = MX[m];
	      int J = 1;
	      for(; J <= M; J++){
		if(DEBUG>=2) assert(nmap2[m][J] == -1 || (1 <= nmap2[m][J] && nmap2[m][J] <= N2 && nmapK2[m][J] >= 0 && nmapK2[m][J] <= KMAX && nmap2[m][J] > nmapK2[m][J]));
		if(nmap2[m][J] >= I)
		  break;
	      }
	      int left = (J <= M && nmap2[m][J] >= I && nmap2[m][J] - nmapK2[m][J] <= I) ? J : 0;

	      if(!CRES_CNT_FIX)
		J++;
	      for(; J <= M; J++){
		if(DEBUG>=2) assert(nmap2[m][J] == -1 || (1 <= nmap2[m][J] && nmap2[m][J] <= N2 && nmapK2[m][J] >= 0 && nmapK2[m][J] <= KMAX && nmap2[m][J] > nmapK2[m][J]));
		if(nmap2[m][J] >= I + 1)
		  break;
	      }
	      int right = (J <= M && nmap2[m][J] >= I + 1 && nmap2[m][J] - nmapK2[m][J] <= I + 1) ? J : 0;
	      int both = (J <= M && nmap2[m][J] >= I+1 && nmap2[m][J] - nmapK2[m][J] <= I) ? J : 0;
	      if(both){
	        if(DEBUG && CRES_CNT_FIX) assert(left || right);
		bcnt++;
		Wbcnt += wt;
	      }
	      if(left || right){
		ccnt++;
		Wccnt += wt;
	      }
	      if(left && !right){
		lcnt++;
		Wlcnt += wt;
	      }
	      if(right && !left){
		rcnt++;
		Wrcnt += wt;
	      }
	      if(left && right && (!CRES_CNT_FIX || left != right)){
		if(VERB>=3){
		  int IL = nmap2[m][left], IR = nmap2[m][right];
		  int KL = nmapK2[m][left], KR = nmapK2[m][right];
		  printf("    Allele2 at I=%d,%d(i=%d..%d):m=%d (id=%lld, Phase=%0.6f) : M=%d, left=%d(nmap2:%d..%d,map2:%d..%d), right=%d(nmap2:%d..%d,map2:%d..%d)\n",
			 I,I+1,iL,iR,m, gmap[pcontig->contig[m].mapid]->id, pcontig->MapPhase[m], M, left, IL-KL, IL, map2[m][left]-mapK2[m][left],map2[m][left],right, IR-KR, IR,map2[m][right]-mapK2[m][right],map2[m][right]);
		  fflush(stdout);
		}
		cnt++;
		Wcnt += wt;
	      }
	    }

	    int ccntF = (int) floor(ccnt * cresF + 0.5);
	    if(TIME_VERBOSE){
	      printf("Checking Merging Y2[%d]=%0.4f,Y2[%d]=%0.4f (delta=%0.4f, mol cnt=%d+%d+%d+%d/%d,cresKB=%0.4f):cum wall= %0.6f\n",
		     I,Y2[I],I+1,Y2[I+1],Y2[I+1]-Y2[I],cnt,lcnt,rcnt,bcnt,ccnt,cresKB,wtime());
	      fflush(stdout);
	    }
	    if(cnt < max(cresN, ccntF)){ /* merge Y2[I] with Y2[I+1] */
	      if(VERB){
		printf("Testing Merging Y2[%d]=%0.4f,Y2[%d]=%0.4f (delta=%0.4f, mol cnt=%d+%d+%d+%d/%d(%0.1f+%0.1f+%0.1f+%0.1f/%0.1f),cresKB=%0.4f):\n",
		       I,Y2[I],I+1,Y2[I+1],Y2[I+1]-Y2[I], cnt,lcnt,rcnt,bcnt,ccnt,Wcnt,Wlcnt,Wrcnt,Wbcnt,Wccnt,cresKB);
		fflush(stdout);
	      }

	      int iL = nmap2[MD][I];
	      int iR = nmap2[MD][I+1];

	      int Allele = 2;
	      if(HapSite[iL]==3 && HapSite[iR]==3 && map1[MD][iR] == map1[MD][iL] + 1 && Hcuts2[iR] - Hcuts2[iL] < cresKB + res_delta){/* check if Allele1 should also be merged */
		int I = map1[MD][iL];
		if(DEBUG) assert(0 < I && I < N1);

		/* count number of molecules that have separate sites aligned to Y1[I] and Y1[I+1] */
		int cnt = 0, ccnt = 0, lcnt = 0, rcnt = 0, bcnt = 0;
		double Wcnt = 0.0, Wccnt = 0.0, Wlcnt = 0.0, Wrcnt = 0.0, Wbcnt = 0.0;
		// HERE HERE : multithread ?
		for(int m = 0; m < MD; m++){
		  double wt = pcontig->MapPhase[m];
		  if(pcontig->MapPhase[m] < 1.0-HapAlleleProb)/* definitely Allele2 */
		    continue;
		  wt *= TBmapWT[m];

		  int M = MX[m];
		  int J = 1;
		  for(; J <= M; J++){
		    if(DEBUG>=1+RELEASE) assert(nmap1[m][J] == -1 || (1 <= nmap1[m][J] && nmap1[m][J] <= N1 && nmapK1[m][J] >= 0 && nmapK1[m][J] <= KMAX && nmap1[m][J] > nmapK1[m][J]));
		    if(nmap1[m][J] >= I)
		      break;
		  }
		  int left = (J <= M && nmap1[m][J] >= I && nmap1[m][J] - nmapK1[m][J] <= I) ? J : 0;
		  if(!CRES_CNT_FIX)
		    J++;
		  for(; J <= M; J++){
		    if(DEBUG>=1+RELEASE) assert(nmap1[m][J] == -1 || (1 <= nmap1[m][J] && nmap1[m][J] <= N1 && nmapK1[m][J] >= 0 && nmapK1[m][J] <= KMAX && nmap1[m][J] > nmapK1[m][J]));
		    if(nmap1[m][J] >= I + 1)
		      break;
		  }
		  int right = (J <= M && nmap1[m][J] >= I + 1 && nmap1[m][J] - nmapK1[m][J] <= I + 1) ? J : 0;
		  int both = (J <= M && nmap1[m][J] >= I + 1 && nmap1[m][J] - nmapK1[m][J] <= I) ? J : 0;
		  if(both){
		    if(DEBUG && CRES_CNT_FIX) assert(left || right);
		    bcnt++;
		    Wbcnt += wt;
		  }
		  if(left || right){
		    ccnt++;
		    Wccnt += wt;
		  }
		  if(left && !right){
		    lcnt++;
		    Wlcnt += wt;
		  }
		  if(right && !left){
		    rcnt++;
		    Wrcnt += wt;
		  }
		  if(left && right && (!CRES_CNT_FIX || left != right)){
		    if(VERB>=3){
		      int IL = nmap1[m][left], IR = nmap1[m][right];
		      int KL = nmapK1[m][left], KR = nmapK1[m][right];
		      printf("    Allele1 at I=%d,%d(i=%d..%d):m=%d (id=%lld, Phase= %0.6f) : M=%d, left=%d(nmap1:%d..%d,map1:%d..%d), right=%d(nmap1:%d..%d,map1:%d..%d)\n",
			     I,I+1,iL,iR,m, gmap[pcontig->contig[m].mapid]->id, pcontig->MapPhase[m], M, left, IL-KL, IL, map1[m][left]-mapK1[m][left],map1[m][left], right, IR-KR, IR, map1[m][right]-mapK1[m][right],map1[m][right]);
		      fflush(stdout);
		    }
		    cnt++;
		    Wcnt += wt;
		  }
		}

		int ccntF = (int) floor(ccnt * cresF + 0.5);
		if(TIME_VERBOSE){
		  printf("Checking also merging Y1[%d]=%0.4f,Y2[%d]=%0.4f (delta=%0.4f, mol cnt=%d+%d+%d+%d/%d(%0.1f+%0.1f+%0.1f+%0.1f/%0.1f),cresKB=%0.4f):cum wall= %0.6f\n",
			 I,Y1[I],I+1,Y1[I+1],Y1[I+1]-Y1[I],cnt,lcnt,rcnt,bcnt,ccnt,Wcnt,Wlcnt,Wrcnt,Wbcnt,Wccnt,cresKB,wtime());
		  fflush(stdout);
		}

		if(cnt * 4 < max(cresN, ccntF) * 5){/* NOTE: slightly loser check to encourage merging both Alleles the same way */
		  if(VERB){
		    printf("Testing also merging Y1[%d]=%0.4f,Y1[%d]=%0.4f (delta=%0.4f, mol cnt=%d+%d+%d+%d/%d(%0.1f+%0.1f+%0.1f+%0.1f/%0.1f), cresKB=%0.4f):\n",
			   I,Y1[I],I+1,Y1[I+1],Y1[I+1]-Y1[I],cnt,lcnt,rcnt,bcnt,ccnt,Wcnt,Wlcnt,Wrcnt,Wbcnt,Wccnt,cresKB);
		    fflush(stdout);
		  }
		  Allele = 3;
		}
	      }

	      /* locate L, first label left of interval Hcuts[iL,iR] */
	      int L= iL - 1;
	      for(; L > 0; L--)
		if(HapSite[L])
		  break;
	      /* locate LL, first non-Hap label left of interval Hcuts[iL,iR] */
	      int LL = L;
	      for(; LL > 0; LL--)
		if(HapSite[LL]==3)
		  break;
	      /* locate RR, first non-Hap label right of interval Hcuts[iL,iR] */
	      int RR = iR + 1;
	      for(; RR <= n; RR++)
		if(HapSite[RR]==3)
		  break;

	      memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	      memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL+1)*sizeof(int));
	      if(HPROBEVAL_SPREAD){  /* need to backup map1[],map2[] */
		int LoopCnt = 0;

		int block = 1;
		while(block < 16 && MD > numthreads * block)
		  block *= 2;

                #pragma omp parallel num_threads(numthreads)
		{
		  int myLoopCnt = 0;

                  #pragma omp for schedule(static,block)
		  for(int m = 0; m < MD; m++){
		    if(OMP_DEBUG) myLoopCnt++;
		    int M = MX[m];

		    // HERE HERE : combine memcpy calls ?
		    memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
		    memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
		    memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
		    memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
		  }
		  if(OMP_DEBUG && myLoopCnt > 0){
                    #pragma omp critical
		    {
		      LoopCnt += myLoopCnt;
		    }
		  }
		} // omp parallel
		if(OMP_DEBUG) assert(LoopCnt == MD);

		if(TIME_VERBOSE){
		  printf("Saved map1,map2: cum wall= %0.6f\n",wtime());
		  fflush(stdout);
	        }
	      }

	      int bestChange = 0;/* 0 or -1 means no change, 1 means delete Hcuts[iL], 2 means delete Hcuts[iR], 3 means merge Hcuts[iL,iR] */
	      double bestLP = newLP - BigPen;

	      if(cresFix){

		/* First try to just remove left label Hcuts[iL] */
		HapSite[iL] &= ~Allele;
		if(!HapSite[iL]){
		  HapDelta[L] += HapDelta[iL];
		  Delta[L] += Delta[iL];
		  Delta[iL] = HapDelta[iL] = 0.0;
		}

		int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
		if(err){
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("Testing Removal of Allele %d from Hcuts[iL=%d] = %0.4f failed due to hsetmap\n",Allele,iL,Hcuts[iL]);
		    fflush(stdout);
		  }
		} else {
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[iL],Hcuts1[iL],Hcuts2[iL],Hcuts2[iL],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB/* HERE >=2 */){
		    printf("Testing Removal of Allele %d from Hcuts[iL=%d]= %0.4f : nLP = %0.6f (delta = %0.6f), SNPs = %d, Indels=%d: cum wall= %0.6f\n", Allele, iL, Hcuts[iL], nLP, nLP-newLP, SNPs, Indels,wtime());
		    fflush(stdout);
		  }
		  if(nLP > bestLP){
		    bestChange = 1;
		    bestLP = nLP;
		  }
		}
		HapSite[iL] = prevHapSite[iL];
		Delta[L] = prevDelta[L];
		Delta[iL] = prevDelta[iL];
		HapDelta[L] = prevHapDelta[L];
		HapDelta[iL] = prevHapDelta[iL];
		if(DEBUG>=2){
		  for(int i = LL; i < RR; i++){
		    assert(HapSite[i] == prevHapSite[i]);
		    assert(HapDelta[i] == prevHapDelta[i]);
		    assert(Delta[i] == prevDelta[i]);
		  }
		}

		/* Next try to just remove right label Hcuts[iR] */
		HapSite[iR] &= ~Allele;
		if(!HapSite[iR]){
		  HapDelta[iL] += HapDelta[iR];
		  Delta[iL] += Delta[iR];
		  Delta[iR] = HapDelta[iR] = 0.0;
		}

		err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
		if(err){
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("Testing Removal of Allele %d from Hcuts[iR=%d] = %0.4f failed due to hsetmap\n",Allele,iR,Hcuts[iR]);
		    fflush(stdout);
		  }
		} else {
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[iR],Hcuts1[iR],Hcuts2[iR],Hcuts2[iR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB/* HERE >=2 */){
		    printf("Testing Removal of Allele %d from Hcuts[iR=%d]= %0.4f : nLP = %0.6f (delta = %0.6f), SNPs = %d, Indels=%d: cum wall= %0.6f\n", Allele, iR, Hcuts[iR], nLP, nLP-newLP, SNPs, Indels,wtime());
		    fflush(stdout);
		  }
		  if(nLP > bestLP){
		    bestChange = 2;
		    bestLP = nLP;
		  }
		}
		HapSite[iR] = prevHapSite[iR];		
		Delta[iL] = prevDelta[iL];
		Delta[iR] = prevDelta[iR];
		HapDelta[iL] = prevHapDelta[iL];
		HapDelta[iR] = prevHapDelta[iR];
		if(DEBUG>=2){
		  for(int i = LL; i < RR; i++){
		    assert(HapSite[i] == prevHapSite[i]);
		    assert(HapDelta[i] == prevHapDelta[i]);
		    assert(Delta[i] == prevDelta[i]);
		  }
		}

		/* need to call hsetmap() so Hcuts1,Hcuts2 are defined for use by LabelMerge */
		err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);
		if(DEBUG) assert(err==0);
	      }

	      //		    rverb = (iter==55 || iter==56) ? 1 : 0;
	      if(!LabelMerge(Allele, LL, L, iL, iR, RR, cresKB, numthreads, MD, MX, map1, mapK1, map2, mapK2, nmap1, nmapK1, nmap2, nmapK2, N1, Y1, N2, Y2, n, Hcuts, Hcuts1, Hcuts2, HapSite, Delta, HapDelta, prevHapSite, prevDelta, prevHapDelta, spreadDelta, spreadHapDelta, Label, Index, Hremap, Hdel1, Hdel2)){
		//		    rverb = 0;

		//		  rverb = (iter==45) ? 1 : 0;
		if(cresFix){
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("Testing Merging labels iL=%d,iR=%d : LP= %0.6f, SNPs=%d,Indels=%d: cum wall= %0.6f\n",iL,iR,nLP,SNPs,Indels,wtime());
		    fflush(stdout);
		  }
		  if(nLP > bestLP){
		    bestChange = 3;
		    bestLP = nLP;
		  }
		} else {
		  cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
					 TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("\t newLP= %0.6f -> %0.6f, SNPs=%d,Indels=%d\n",newLP,nLP,SNPs,Indels);
		    fflush(stdout);
		  }
		  newLP = nLP;
		  IndelCnt = Indels;
		  SNPcnt = SNPs;
		}
	      } else if(!cresFix) {// !LabelMerge()
		//		    rverb = 0;
		continue;/* next I for Allele2 */
	      }
	      //		    rverb = 0;

	      if(cresFix){
		if(bestChange && cresMaxLPdrop >= 0.0 && bestLP < newLP - cresMaxLPdrop){// NEW12
		  if(VERB){
		    printf("skipping Merging labels due to -cresMaxLPdrop %0.3f (best delta = %0.6f)\n",cresMaxLPdrop, bestLP - newLP);
		    fflush(stdout);
		  }
		  bestChange = -1;
		  bestLP = newLP;
		}

		if(bestChange < 3){
		  memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL+1)*sizeof(int));
		  int block = 1;
		  if(HPROBEVAL_SPREAD){  /* need to restore map1[],map2[] */
		    while(block < 16 && MD > numthreads * block)
		      block *= 2;

                    #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		    for(int m = 0; m < MD; m++){
		      int M = MX[m];

		      memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		      memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		      memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		      memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
		    }
		    if(TIME_VERBOSE){
		      printf("Restored map1,map2 (block=%d): cum wall= %0.6f\n",block,wtime());
		      fflush(stdout);
		    }
		  }
		}
		if(bestChange == 1){
		  HapSite[iL] &= ~Allele;
		  if(!HapSite[iL]){
		    HapDelta[L] += HapDelta[iL];
		    Delta[L] += Delta[iL];
		    Delta[iL] = HapDelta[iL] = 0.0;
		  }
		}
		if(bestChange == 2){
		  HapSite[iR] &= ~Allele;
		  if(!HapSite[iR]){
		    HapDelta[iL] += HapDelta[iR];
		    Delta[iL] += Delta[iR];
		    Delta[iR] = HapDelta[iR] = 0.0;
		  }
		}
		if(bestChange){
		  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
		  cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
		  if(bestChange > 0){
#if 1 // HERE HERE : use full hprobeval until faster method has been verified
		    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,0.0/* Hcuts1[LL]*/,Hcuts1[n+1]/*Hcuts1[RR]*/,0.0/*Hcuts2[LL]*/,Hcuts2[n+1]/*Hcuts2[RR]*/,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
#else
		    // NOTE : cannot use fastest incremental hprobeval, since all nmap1[] for maps to the right of the point of change need to be updated as well to reflect label deletions in Y1,Y2
		    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[n+1]/*Hcuts1[RR]*/,Hcuts2[LL],Hcuts2[n+1]/*Hcuts2[RR]*/,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
#endif
		  } else {// NEW75 : incremental hprobeval() only, just to verify LP value is restored : no need to recompute nmap[]
		    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  }
		  if(VERB/* HERE >=2 */){
		    if(bestChange== -1)
		      printf("Skipping Merging labels Hcuts[%d,%d]= %0.4f,%0.4f on Allele %d", iL,iR,Hcuts[iL],Hcuts[iR],Allele);
		    else if(bestChange==1)
		      printf("Deleting Allele %d from Hcuts[iL=%d]=%0.4f",Allele,iL,Hcuts[iL]);
		    else if(bestChange==2)
		      printf("Deleting Allele %d from Hcuts[iR=%d]=%0.4f",Allele,iR,Hcuts[iR]);
		    else
		      printf("Merging Hcuts[%d,%d]=%0.4f,%0.4f on Allele %d",iL,iR,Hcuts[iL],Hcuts[iR],Allele);
		    printf(": newLP= %0.6f -> %0.6f (err=%0.6f), SNPs=%d,Indels=%d:cum wall= %0.6f\n",newLP,nLP,nLP-bestLP,SNPs,Indels,wtime());
		    fflush(stdout);
		  }
		  if(bestChange > 0)
		    changecnt++;
		  if(!(nLP >= bestLP - (USE_MFLOAT ? 1e-4 : 1e-5) * MD)){
		    printf("WARNING: unexpected drop in likelihood (err=%0.6f)\n",nLP-bestLP);
		    fflush(stdout);
		  }
		}
		newLP = nLP;
		IndelCnt = Indels;
		SNPcnt = SNPs;
		double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
		tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;

		if(DELTA_STOP >= 3 && bestChange > 0){	      /* re-activate nearby intervals */
		  double DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		  int IN1 = floor((Hcuts[iL] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		  int IN2 = floor((Hcuts[iR] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		  IN1 = max(0, IN1);
		  IN2 = min(maxIN, IN2);
		  if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
		    printf("After merging Hcuts[i=%d,iR=%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			   iL,iR,Hcuts[iL],Hcuts[iR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		    fflush(stdout);
		    assert(0 <= IN1 && IN1 <= maxIN);
		  }
		  if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
		    printf("After merging Hcuts[i=%d,iR=%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			   iL,iR,Hcuts[iL],Hcuts[iR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		    fflush(stdout);
		    assert(0 <= IN2 && IN2 <= maxIN);
		  }
		  if(DEBUG) assert(IN1 <= IN2);
		  
		  int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		  int origactivecnt = activecnt;

		  for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
		    if(DELTA_RANGE[T] <= 0){
		      activecnt++;
		      DELTA_RANGE[T] = min_DELTA;
		      for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
			Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
		      if(HAPSTOP_DEBUG){
			printf("Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to merging of Hcuts[%d..%d]=%0.4f..%0.4f\n",
			       T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			       DELTA_RANGE[T],Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],iL, iR, Hcuts[iL], Hcuts[iR]);
			fflush(stdout);
		      }
		    } else if(HAPSTOP_DEBUG>=2){
		      printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after merging of Hcuts[%d..%d] with DELTA_RANGE[T]=%d (%0.3f .. %0.3f)\n",
			     T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			     iL,iR,DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1]);
		      fflush(stdout);
		    }
		  }

		  if(VERB && activecnt > origactivecnt){
		    if(VERB>=2 || HAPSTOP_DEBUG){
		      int inactivecnt = 0;
		      for(int IN = 0; IN <= maxIN; IN++)
			if(DELTA_RANGE[IN] <= 0)
			  inactivecnt++;

		      printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f : inactive intervals = %d/%d\n",
		          activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, iL, iR, Hcuts[iL], Hcuts[iR], inactivecnt,maxIN+1);
		    } else
		      printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f\n",
		          activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, iL, iR, Hcuts[iL], Hcuts[iR]);
		    fflush(stdout);
		  }
		}	      
	      } // if(cresFix)
	    } // cnt < max(cresN,ccntF)
          }

	  if(VERB>=3){/* display alignments of molecules near Hcuts= 19673.3990 .. 19687.4437 */
	    rverb = 1;
	    printf("Displaying hprobeval near Hcuts[39955..39988] after cresKB= %0.4f merging\n",cresKB);
	    fflush(stdout);
	    double qLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				   TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[39955],Hcuts1[39988],Hcuts2[39955],Hcuts2[39988],0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels, 0);
	    printf("qLP= %0.8f\n",qLP);
	    fflush(stdout);
	    rverb = 0;
	  }
	}

	hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	if(DEBUG/* >=2 */){/* verify LP value */
	  double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				  TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2, 0, 0, 0.0, 0.0, 0.0, 0.0, 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) || VERB/* HERE >=2 */){
	    if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt))
	      printf("WARNING: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d: cum wall= %0.6f\n", nLP2,newLP,nLP2-newLP, SNPs, Indels, wtime());
	    else
	      printf("nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d: cum wall= %0.6f\n", nLP2,newLP,nLP2-newLP, SNPs, Indels,wtime());
	    fflush(stdout);
	    if(DEBUG>=1+RELEASE) assert(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt);
	  }
	  newLP = nLP2;
	  SNPcnt = SNPs;
	  IndelCnt = Indels;
	}
      }

      // Check for almost coincident HapSites on opposite Alleles and try to combine them into a single regular Site : usually a win unless there is a Hap Indel involved
      //             Look at RefAligner5/trunk/run for a test case generated by setting -HapSiteRes 0.001 which generates lots of coincident HapSites on opposite Alleles that form local maxima

      //      prevN1 = N1;
      //      prevN2 = N2;

     if(MERGE_SNPS && (cresHapL >= 0 || cres > 0.0)){

        double cresKB = (cresHapL >= 0.0) ? cresHapL : cres * 0.5;

	if(VERB){
	  printf("Looking for coincident HapSites on opposite Alleles within cresKB= %0.4f kb\n",cresKB);
	  fflush(stdout);
	}

	/* scan for HapSite = 1 or 2 with next label in either direction also a SNP in the opposite Allele */
	for(int i = 1; i <= n; i++){
	  if(HapSite[i] == 0 || HapSite[i] == 3)
	    continue;

	  /* locate previous & next label */
	  int iL = i-1;
	  for(; iL > 0; iL--)
	    if(HapSite[iL])
	      break;
	  
	  int iR = i+1;
	  for(; iR <= n; iR++)
	    if(HapSite[iR])
	      break;
	  
	  double left = cresKB * 2.0, right = cresKB  * 2.0;
	  if(iL > 0 && (HapSite[i] == 3 - HapSite[iL]))
	    left = Hcuts[i] - Hcuts[iL] + Delta[iL];
	  if(iR <= n && (HapSite[iR] == 3 - HapSite[i]))
	    right = Hcuts[iR] - Hcuts[i] + Delta[i];

	  if(VERB>=2){
	    printf("i=%d:iL=%d,iR=%d,HapSite[iL,i,iR]=%d,%d,%d,Hcuts[iL,i,iR]=%0.4f,%0.4f,%0.4f,Delta[iL,i]=%0.4f,%0.4f:left=%0.4f,right=%0.4f,cresKB=%0.4f\n",
		   i,iL,iR,HapSite[iL],HapSite[i],HapSite[iR],Hcuts[iL],Hcuts[i],Hcuts[iR],Delta[iL],Delta[i],left,right,cresKB);
	    fflush(stdout);
	  }

	  if(right > cresKB)
	    continue;

	  /* locate nearest labels with HapSite == 3 */
	  int LL = iL;
	  for(;LL > 0; LL--)
	    if(HapSite[LL] == 3)
	      break;
	  int RR = iR;
	  for(;RR <= n; RR++)
	    if(HapSite[RR] == 3)
	      break;

	  memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	  memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	  memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL+1)*sizeof(int));

	  int bestChange = 0;/* 0 means no change, 1 means delete Hcuts[i], 2 means delete Hcuts[iR], 3 means merge Hcuts[i, iR] at midpoint */
	  double bestLP = newLP - cresHapMaxLPdrop;

	  if(cresFix){
	    /* First try to remove Hcuts[i] and merge it into Hcuts[iR] */
	    HapSite[i] = 0;
	    HapSite[iR] = 3;
	    HapDelta[iL] += HapDelta[i];
	    Delta[iL] += Delta[i];
	    Delta[i] = HapDelta[i] = 0.0;

	    int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
	    if(err){
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("Testing Merging Hcuts[i=%d]= %0.4f(%0.4f) into Hcuts[iR=%d]= %0.4f(%0.4f) :failed due to hsetmap\n",
		       i,Hcuts[i], Hcuts[i]+prevDelta[LL]+prevDelta[iL],iR,Hcuts[iR],Hcuts[iR]+prevDelta[LL]+prevDelta[iL]+prevDelta[i]);
		fflush(stdout);
	      }
	    } else {
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[iL],Hcuts1[iR],Hcuts2[iL],Hcuts2[iR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB/* HERE >=2 */){
		printf("Testing Merging Hcuts[i=%d]= %0.4f(%0.4f) into Hcuts[iR=%d]= %0.4f(%0.4f): qLP= %0.6f (delta= %0.6f), SNPs= %d, Indels= %d: cum wall= %0.6f\n",
		       i,Hcuts[i], Hcuts[i]+prevDelta[LL]+prevDelta[iL],iR,Hcuts[iR],Hcuts[iR]+prevDelta[LL]+prevDelta[iL]+prevDelta[i], nLP, nLP-newLP, SNPs, Indels,wtime());
		//		printf("\t Delta[LL=%d,iL=%d,i=%d]= %0.4f,%0.4f,%0.4f\n",LL,iL,i,prevDelta[LL],prevDelta[iL],prevDelta[i]);
		fflush(stdout);
	      }
	      if(nLP > bestLP){
		bestChange = 1;
		bestLP = nLP;
	      }
	    }

	    HapSite[i] = prevHapSite[i];
	    HapSite[iR] = prevHapSite[iR];
	    Delta[iL] = prevDelta[iL];
	    Delta[i] = prevDelta[i];
	    HapDelta[iL] = prevHapDelta[iL];
	    HapDelta[i] = prevHapDelta[i];
	    if(DEBUG>=2){
	      for(int i = LL; i < RR; i++){
		assert(HapSite[i] == prevHapSite[i]);
		assert(HapDelta[i] == prevHapDelta[i]);
		assert(Delta[i] == prevDelta[i]);
	      }
	    }

	    /* Next try to remove Hcuts[iR] and merge it into Hcuts[i] */
	    HapSite[iR] = 0;
	    HapSite[i] = 3;
	    HapDelta[i] += HapDelta[iR];
	    Delta[i] += Delta[iR];
	    Delta[iR] = HapDelta[iR] = 0.0;

	    err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	    
	    if(err){
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("Testing Merging Hcuts[iR=%d]= %0.4f(%0.4f) into Hcuts[i=%d]= %0.4f(%0.4f) :failed due to hsetmap\n",
		       iR,Hcuts[iR], Hcuts[iR]+prevDelta[LL]+prevDelta[iL]+prevDelta[i],i,Hcuts[i],Hcuts[i]+prevDelta[LL]+prevDelta[iL]);
		fflush(stdout);
	      }
	    } else {
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[iL],Hcuts1[iR],Hcuts2[iL],Hcuts2[iR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB/* HERE >=2 */){
		printf("Testing Merging Hcuts[iR=%d]= %0.4f(%0.4f) into Hcuts[i=%d]= %0.4f(%0.4f): qLP= %0.6f (delta= %0.6f), SNPs= %d, Indels= %d:cum wall= %0.6f\n",
		       iR,Hcuts[iR], Hcuts[iR]+prevDelta[LL]+prevDelta[iL]+prevDelta[i],i,Hcuts[i],Hcuts[i]+prevDelta[LL]+prevDelta[iL], nLP, nLP-newLP, SNPs, Indels,wtime());
		//		printf("\t Delta[LL=%d,iL=%d,i=%d]= %0.4f,%0.4f,%0.4f\n",LL,iL,i,prevDelta[LL],prevDelta[iL],prevDelta[i]);
		fflush(stdout);
	      }
	      if(nLP > bestLP){
		bestChange = 2;
		bestLP = nLP;
	      }
	    }

	    HapSite[i] = prevHapSite[i];
	    HapSite[iR] = prevHapSite[iR];
	    Delta[i] = prevDelta[i];
	    Delta[iR] = prevDelta[iR];
	    HapDelta[i] = prevHapDelta[i];
	    HapDelta[iR] = prevHapDelta[iR];
	    if(DEBUG>=2){
	      for(int i = LL; i < RR; i++){
		assert(HapSite[i] == prevHapSite[i]);
		assert(HapDelta[i] == prevHapDelta[i]);
		assert(Delta[i] == prevDelta[i]);
	      }
	    }
	  }

	  /* merge Hcuts[i] with Hcuts[R] at midpoint */
	  int idel=i, ikeep=iR;/* remember which label was deleted and which was kept, so we can later fix up map[] */
	  if(VERB/* HERE >=2 */){
	    printf("Trying to Merge Hcuts[i=%d]= %0.4f(%0.4f) with Hcuts[iR=%d]= %0.4f(%0.4f) : HapSite[LL=%d,iL=%d,i=%d,iR=%d,RR=%d]= %d,%d,%d,%d,%d, Hcuts[LL,iL,RR]=%0.4f,%0.4f,%0.4f\n",
		   i,Hcuts[i],Hcuts[i]+prevDelta[LL]+prevDelta[iL],iR,Hcuts[iR],Hcuts[iR]+prevDelta[LL]+prevDelta[iL]+prevDelta[i],LL,iL,i,iR,RR,HapSite[LL],HapSite[iL],HapSite[i],HapSite[iR],HapSite[RR],
		   Hcuts[LL],Hcuts[iL],Hcuts[RR]);
	    //	    printf("\t Delta[LL=%d,iL=%d,i=%d]= %0.4f,%0.4f,%0.4f\n",LL,iL,i,prevDelta[LL],prevDelta[iL],prevDelta[i]);
	    fflush(stdout);
	  }

	  double shift = 0.5*(Hcuts[iR] - Hcuts[i] + Delta[i]);
	  HapSite[i] = 0;
	  Delta[iL] += Delta[i];
	  HapDelta[iL] += HapDelta[i];
	  
	  HapSite[iR] = 3;
	  Delta[iL] -= shift;
	  Delta[iR] += shift;
	  HapDelta[iL] -= HapDelta[i] * 0.5;
	  HapDelta[iR] += HapDelta[i] * 0.5;
	  
	  Delta[i] = HapDelta[i] = 0.0;

	  if(DEBUG) assert(ikeep > idel);	  
	  int err = 1;
	  if(HapDeltaSpread(n,LL,ikeep,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap) ||
	     HapDeltaSpread(n,ikeep,RR,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){
	    if(VERB>=1+RELEASE){
	      printf("\t Failed to merge labels due to HapDeltaSpread\n");
	      fflush(stdout);
	    }
	    memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
	    if(!cresFix)
	      continue;/* check next SNP at HapSite[i+1...n]  */
	  } else {
	    err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);
	    if(err){
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("\t Failed to merge labels due to hsetmap!\n");
		fflush(stdout);
	      }

	      memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
	      if(!cresFix)
		continue;/* check next SNP at HapSite[i+1...n]  */
	    }
	  }

	  if(!err){
	    int block = 1;
	    if(HPROBEVAL_SPREAD){  /* need to backup map1[],map2[] */
	      while(block < 16 && MD > numthreads * block)
		block *= 2;

	      int LoopCnt = 0;

	      #pragma omp parallel num_threads(numthreads)
	      {
		int myLoopCnt = 0;

		#pragma omp for schedule(static,block)
		for(int m = 0; m < MD; m++){
		  if(OMP_DEBUG) myLoopCnt++;
		  int M = MX[m];

		  memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
		  memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
		  memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
		  memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
		}
		if(OMP_DEBUG && myLoopCnt > 0){
		  #pragma omp critical
		  {
		    LoopCnt += myLoopCnt;
		  }
		}
	      }
	      if(OMP_DEBUG) assert(LoopCnt == MD);

	      if(TIME_VERBOSE){
		printf("Saved map1,map2 (block=%d): cum wall= %0.6f\n",block,wtime());
		fflush(stdout);
	      }
	    }
	  
	    /* fix up map1[] */
	    if(VERB>=3 && rverb && 163 < MD){
	      int m = 163;
	      int M = MX[m];
	      printf("Before adjusting map1[]: idel=%d,ikeep=%d,iL=%d,iR=%d\n",idel,ikeep,iL,iR);
	      printf("m=%d:M=%d:\n",m,M);
	      for(int J = 1; J <= M; J++){
		int I = map1[m][J];
		if(I < 0)
		  continue;
		int K = mapK1[m][J];
		printf("\t J=%d:map1[m][J]=%d,mapK1[m][J]=%d\n",J,I,K);
	      }
	      
	      printf("Hremap[%d..%d]:\n",LL,RR);
	      for(int i = LL; i <= RR; i++)
		if(i==LL || i == RR || Hremap[i] != i || HapSite[i])
		  printf("\t Hremap[%d] = %d, HapSite[%d]=%d\n",i,Hremap[i],i,HapSite[i]);

	      fflush(stdout);
	    }
	    
	    block = 1;
	    while(block < 16 && MD > numthreads * block)
	      block *= 2;

	    int LoopCnt = 0;
	    #pragma omp parallel num_threads(numthreads)
	    {
	      int myLoopCnt = 0;
	      #pragma omp for schedule(static,block)
	      for(int m  = 0; m < MD; m++){
		if(OMP_DEBUG) myLoopCnt++;
		int M = MX[m];
		
		/* Apply mapping from idel to ikeep : provided another label is not already mapped to ikeep */
		for(int J = 1; J <= M; J++){
		  int I = map1[m][J];
		  if(I < 0)
		    continue;
		  int K = mapK1[m][J];
		  if(DEBUG>=1+RELEASE) assert(0 <= K && K < I);
		  K = I-K;

		  if(VERB>=3 && m==138){
		    printf("m=%d:J=%d,I=%d,K=%d:idel=%d,ikeep=%d,iR=%d:M=%d\n",
			   m,J,I,K,idel,ikeep,iR,M);
		    fflush(stdout);
		  }

		  if(I== idel || K == idel){/* check if another label j is already mapped to ikeep */
		    int j = M;
		    for(; j > 0; j--){
		      if(j == J)
			continue;
		      int i = map1[m][j];
		      if(i < 0)
			continue;
		      int k = mapK1[m][j];
		      if(DEBUG>=1+RELEASE) assert(0 <= k && k < i);
		      k = i-k;
		      if(k <= ikeep && ikeep <= i)
			break;
		    }
		    if(VERB>=3 && m==138 && rverb){
		      printf("m=%d:J=%d,I=%d,K=%d:idel=%d,ikeep=%d,iR=%d:j=%d,M=%d\n",
			     m,J,I,K,idel,ikeep,iR,j,M);
		      fflush(stdout);
		    }
		    if(j <= 0){/* OK to map to ikeep */
		      if(I== idel) I = ikeep;
		      if(K== idel) K = ikeep;
		    } else {/* unmap map1[m][J] : this would be done by cleanmapH() later anyway, but can trigger assertion failure if not done now */
		      // NOTE: cannot use map1[MD][] since it has already been remapped by hsetmap()
		      if(I== idel) I = K = -1;
		      else if(K==idel) {
			if(DEBUG) assert(K < I);
			int origK = K;
			K = ikeep;
			while(++K < I)
			  if(K != idel && (prevHapSite[K] & 1))
			    break;
			if(VERB>=3 && m==138 && rverb){
			  printf("m=%d:J=%d,I=%d,K=%d -> %d, prevHapSite[K]=%d\n",m,J,I,origK,K,prevHapSite[K]);
			  fflush(stdout);
			}
		      }
		    }
		  }
	  
		  map1[m][J] = I;
		  mapK1[m][J] = I - K;
		}

		if(VERB>=3 && rverb && m== 163){
		  #pragma omp critical
		  {
		    printf("After adjusting map1[] based on idel=%d,ikeep=%d:\n",idel,ikeep);
		    printf("m=%d:M=%d:\n",m,M);
		    for(int J = 1; J <= M; J++){
		      int I = map1[m][J];
		      if(I < 0)
			continue;
		      int K = mapK1[m][J];
		      printf("\t J=%d:map1[m][J]=%d,mapK1[m][J]=%d\n",J,I,K);
		    }
		    fflush(stdout);
		  }
		}

		/* apply Hremap[LL..RR] to map1[] */
		int lastI = -1, lastK = -1, lastJ = -1;
		for(int J = 1; J <= M; J++){
		  int I = map1[m][J];
		  if(I < 0)
		    continue;
		  int K = mapK1[m][J];
		  K = I-K;
	    
		  if(LL <= I && I <= RR){
		    if(DEBUG>=1+RELEASE) assert(0 < Hremap[I] && Hremap[I] <= n);
		    I = Hremap[I];
		  }
		  if(LL <= K && K <= RR){
		    if(DEBUG>=1+RELEASE && !(0 < Hremap[K] && Hremap[K] <= I)){
		      printf("m=%d:J=%d,M=%d,I=%d->%d,K=%d,Hremap[K]=%d,LL=%d,RR=%d\n",m,J,M,map1[m][J],I,K,Hremap[K],LL,RR);
		      fflush(stdout);
		      assert(0 < Hremap[K] && Hremap[K] <= I);
		    }
		    K = Hremap[K];
		  }
		  map1[m][J] = I;
		  mapK1[m][J] = I - K;

		  if(DEBUG>=1+RELEASE){
		    I = map1[m][J];
		    K = mapK1[m][J];
		    if(HapSite[I] & 1){// If Hcuts[I] is not in Allele1 ignore mappings to this label in map1, since map1 may not be clean 
		      if(lastI >= 0 && !(I-K > lastI)){
			#pragma omp critical
			{
			  printf("map1:m=%d,M=%d,J=%d,I=%d,K=%d:lastJ=%d,lastI=%d,lastK=%d\n",m,M,J,I,K,lastJ,lastI,lastK);
			  if(VERB/* HERE >=2 */){
			    for(int j = 1; j <= J; j++){
			      int i = map1[m][j];
			      if(i < 0)
				continue;
			      int k = mapK1[m][j];
			      printf("\t j=%d:map1[m][j]=%d,mapK1[m][j]=%d\n",j,i,k);
			    }
			  }
			  fflush(stdout);
			  assert(I-K > lastI);
			}
		      }
		      lastI = I;
		      lastK = K;
		      lastJ = J;
		    }
		  }
		}
	      } // omp for m = 0 .. MD-1
	      if(OMP_DEBUG && myLoopCnt > 0){
		#pragma omp critical
		{
		  LoopCnt += myLoopCnt;
		}
	      } 
	    }
	    if(OMP_DEBUG) assert(LoopCnt == MD);

	    /* fix map2[] */
	    if(VERB>=3 && rverb){
	      printf("Before adjusting map2[]: idel=%d,ikeep=%d,iL=%d,iR=%d\n", idel,ikeep,iL,iR);
	      for(int m = 0; m < MD; m++){
		if(m != 163)
		  continue;
		int M = MX[m];
		printf("m=%d:M=%d:\n",m,M);
		for(int J = 1; J <= M; J++){
		  int I = map2[m][J];
		  if(I < 0)
		    continue;
		  int K = mapK2[m][J];
		  printf("\t J=%d:map2[m][J]=%d,mapK2[m][J]=%d\n",J,I,K);
		}
	      }
	
	      printf("Hremap[%d..%d]:\n",LL,RR);
	      for(int i = LL; i <= RR; i++)
		if(i==LL || i == RR || Hremap[i] != i || HapSite[i])
		  printf("\t i=%d:Hremap[i]= %d, HapSite[i]= %d, Hcuts[i]= %0.4f\n",i,Hremap[i],HapSite[i], Hcuts[i]);

	      fflush(stdout);
	    }
	    
	    LoopCnt = 0;
	    #pragma omp parallel num_threads(numthreads) 
	    {
	      int myLoopCnt = 0;
	      #pragma omp for schedule(static,block)
	      for(int m = 0; m < MD; m++){
		if(OMP_DEBUG) myLoopCnt++;
		int M = MX[m];

		/* Apply mapping from idel to ikeep : provided another label is not already mapped to ikeep */
		int lastI = -1, lastK = -1, lastJ = -1;
		for(int J = 1; J <= M; J++){
		  int I = map2[m][J];
		  if(I < 0)
		    continue;
		  int K = mapK2[m][J];
		  if(DEBUG>=1+RELEASE) assert(0 <= K && K < I);
		  K = I-K;
	    
		  if(I== idel || K == idel){/* check if another Label j is already mapped to ikeep */
		    int j = M;
		    for(; j > 0; j--){
		      if(j==J)
			continue;
		      int i = map2[m][j];
		      if(i < 0)
			continue;
		      int k = mapK2[m][j];
		      if(DEBUG>=1+RELEASE) assert(0 <= k && k < i);
		      k = i-k;
		      if(k <= ikeep && ikeep <= i)
			break;
		    }

		    if(j <= 0){/* OK to map to ikeep */
		      if(I== idel) I = ikeep;
		      if(K== idel) K = ikeep;
		      if(ikeep != iR && ikeep != iL){
			if(I== iR) I = ikeep;
			if(K== iR) K = ikeep;
		      }
		    } else {/* unmap map2[m][J] : this would be done by cleanmapH() later anyway, but can trigger assertion failure if not done now */
		      // NOTE: cannot use map2[MD][] since it has already been remapped by hsetmap()
		      if(I== idel) I = K = -1;
		      else if(K==idel) {
			if(DEBUG) assert(K < I);
			K = ikeep;
			while(++K < I)
			  if(K != idel && (prevHapSite[K] & 2))
			    break;
		      }
		    }
		  }

		  map2[m][J] = I;
		  mapK2[m][J] = I - K;
		}

		if(VERB>=3 && rverb && m==163){
		  #pragma omp critical
		  {
		    printf("After adjusting map2[] based on idel=%d,ikeep=%d:\n",idel,ikeep);
		    printf("m=%d:M=%d:\n",m,M);
		    for(int J = 1; J <= M; J++){
		      int I = map2[m][J];
		      if(I < 0)
			continue;
		      int K = mapK2[m][J];
		      printf("\t J=%d:map2[m][J]=%d,mapK2[m][J]=%d\n",J,I,K);
		    }
		    fflush(stdout);
		  }
		}

		/* apply Hremap[LL..RR] */
		lastI = lastK = lastJ = -1;
		for(int J = 1; J <= M; J++){
		  int I = map2[m][J];
		  if(I < 0)
		    continue;
		  int K = mapK2[m][J];
		  K = I-K;

		  if(LL <= I && I <= RR){
		    if(DEBUG>=1+RELEASE) assert(0 < Hremap[I] && Hremap[I] <= n);
		    I = Hremap[I];
		  }
		  if(LL <= K && K <= RR){
		    if(DEBUG>=1+RELEASE && !(0 < Hremap[K] && Hremap[K] <= I)){
		      printf("m=%d,M=%d:J=%d,map2[m][J]=%d -> %d(=I),mapK2[m][J]=%d,K=%d,LL=%d,RR=%d,Hremap[K]=%d,rverb=%d\n",
			     m,M,J,map2[m][J],I,mapK2[m][J],K,LL,RR,Hremap[K],rverb);
		      fflush(stdout);
		      assert(0 < Hremap[K] && Hremap[K] <= I);
		    }
		    K = Hremap[K];
		  }
		  map2[m][J] = I;
		  mapK2[m][J] = I - K;

		  if(DEBUG>=1+RELEASE){
		    I = map2[m][J];
		    K = mapK2[m][J];
		    if(HapSite[I] & 2){// NEW : If Hcuts[I] is not in Allele 2 ignore mappings to I in map2 since map2 may not be clean
		      if(lastI >= 0 && !(I-K > lastI)){
			#pragma omp critical
			{
			  printf("map2:m=%d,J=%d,I=%d,K=%d:lastJ=%d,lastI=%d,lastK=%d\n",m,J,I,K,lastJ,lastI,lastK);
			  if(VERB/* HERE >=2 */){
			    for(int j = 1; j <= J; j++){
			      int i = map2[m][j];
			      if(i < 0)
				continue;
			      int k = mapK2[m][j];
			      printf("\t j=%d:map2[m][j]=%d,mapK2[m][j]=%d\n",j,i,k);
			    }
			    printf("Hremap[%d..%d]:\n",LL,RR);
			    for(int i = LL; i <= RR; i++)
			      if(i==LL || i==RR || Hremap[i] != i || HapSite[i])
				printf("\t i=%d:Hremap[i]= %d, HapSite[i]= %d, Hcuts[i]= %0.4f, Delta[i]= %0.4f, HapDelta[i]= %0.4f\n",
				       i,Hremap[i],HapSite[i], Hcuts[i], Delta[i], HapDelta[i]);
			  }
			  fflush(stdout);
			  assert(I-K > lastI);
			}
		      }
		      lastI = I;
		      lastK = K;
		      lastJ = J;
		    }
		  }
		}
	      }
	      if(OMP_DEBUG && myLoopCnt > 0){
		#pragma omp critical
		{
		  LoopCnt += myLoopCnt;
		}
	      }
	    }
	    if(OMP_DEBUG) assert(LoopCnt == MD);  

	    if(TIME_VERBOSE){
	      printf("After fixing/adjusting map1,map2 (block=%d): cum wall= %0.6f\n",block,wtime());
	      fflush(stdout);
	    }

	    /* now check hprobeval (hsetmap previously called) */
	    double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);

	    if(VERB>=1+RELEASE/* HERE >=2 */){
	      printf("\t qLP= %0.6f (delta = %0.6f), SNPs=%d,Indels=%d: cum wall= %0.6f\n",nLP,nLP - newLP, SNPs,Indels,wtime());
	      fflush(stdout);
	    }

	    if(nLP >= bestLP){
	      bestChange = 3;
	      bestLP = nLP;
	    } else { /* undo changes */
	      memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
	      if(HPROBEVAL_SPREAD){  /* need to restore map1[],map2[] */
		int block = 1;
		while(block < 16 && MD > numthreads * block)
		  block *= 2;

		#pragma omp parallel for num_threads(numthreads) schedule(static,block)
		for(int m = 0; m < MD; m++){
		  int M = MX[m];
		    
		  memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		  memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		  memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		  memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
		}
		if(TIME_VERBOSE){
		  printf("After Restoring map1,map2 (block=%d): cum wall= %0.6f\n",block,wtime());
		  fflush(stdout);
	        }
	      }
	      if(!cresFix)
		continue;/* check next SNP at HapSite[i+1...n]  */
	    }
	  }// if(!err)

	  if(cresFix){
	    if(bestChange == 1){
	      HapSite[i] = 0;
	      HapSite[iR] = 3;
	      HapDelta[iL] += HapDelta[i];
	      Delta[iL] += Delta[i];
	      Delta[i] = HapDelta[i] = 0.0;
	    }
	    if(bestChange==2){
	      HapSite[iR] = 0;
	      HapSite[i] = 3;
	      HapDelta[i] += HapDelta[iR];
	      Delta[i] += Delta[iR];
	      Delta[iR] = HapDelta[iR] = 0.0;
	    }
	    // If bestChange==3, changes were never undone
	    
	    if(bestChange){	  /* confirm Merge */
	      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
	      cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
	      //		    rverb = 1;
#if 1
	      nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,0.0/*Hcuts1[LL]*/,Hcuts1[n+1]/*Hcuts1[RR]*/,0.0/*Hcuts2[LL]*/,Hcuts2[n+1]/*Hcuts2[RR]*/,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
#else
	      // HERE HERE : cannot use fastest incremental hprobeval, since all nmap1[] for maps to the right of the point of change need to be updated as well to reflect label deletions in Y1,Y2
	      nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		  TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
#endif
	      //		    rverb = 0;
	      if(VERB/* >=1+RELEASE */ || (DEBUG && !(nLP >= bestLP - (USE_MFLOAT ? 1e-6 : 1e-7) * MD))){
		if(bestChange==1)
		  printf("Merged Hcuts[i=%d]=%0.4f(%0.4f) into Hcuts[iR=%d]=%0.4f(%0.4f)", i,Hcuts[i], Hcuts[i]+prevDelta[LL]+prevDelta[iL],iR,Hcuts[iR],Hcuts[iR]+prevDelta[LL]+prevDelta[iL]+prevDelta[i]);
		else if(bestChange==2)
		  printf("Merged Hcuts[iR=%d]=%0.4f(%0.4f) into Hcuts[i=%d]=%0.4f(%0.4f)", iR,Hcuts[iR], Hcuts[iR]+prevDelta[LL]+prevDelta[iL]+prevDelta[i],i,Hcuts[i],Hcuts[i]+prevDelta[LL]+prevDelta[iL]);
		else
		  printf("Merged Hcuts[i=%d]= %0.4f(%0.4f) with Hcuts[iR=%d]= %0.4f(%0.4f)", i,Hcuts[i],Hcuts[i]+prevDelta[LL]+prevDelta[iL],iR,Hcuts[iR],Hcuts[iR]+prevDelta[LL]+prevDelta[iL]+prevDelta[i]);
		printf(": newLP= %0.6f -> %0.6f (err=%0.6f), SNPs=%d,Indels=%d: cum wall= %0.6f\n",newLP,nLP,nLP-bestLP,SNPs,Indels,wtime());
		fflush(stdout);

		if(DEBUG && !(nLP >= bestLP - (USE_MFLOAT ? 1e-6 : 1e-7) * MD)){
		  printf("WARNING: unexpected drop in likelihood (err=%0.6f,MD=%d)\n",nLP-bestLP,MD);
		  fflush(stdout);
		  if(DEBUG>=1+RELEASE) assert(nLP >= bestLP - (USE_MFLOAT ? 1e-5 : 1e-7) * MD);
		}
	      }

	      if(bestChange > 0)
		changecnt++;
	      newLP = nLP;
	      IndelCnt = Indels;
	      SNPcnt = SNPs;
	      double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;

	      if(DELTA_STOP >= 3){	      /* re-activate nearby intervals */
		double DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		int IN1 = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		int IN2 = floor((Hcuts[iR] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		IN1 = max(0, IN1);
		IN2 = min(maxIN, IN2);
		if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
		  printf("After merging Hcuts[i=%d,iR=%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			 i,iR,Hcuts[i],Hcuts[iR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		  fflush(stdout);
		  assert(0 <= IN1 && IN1 <= maxIN);
		}
		if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
		  printf("After merging Hcuts[i=%d,iR=%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			 i,iR,Hcuts[i],Hcuts[iR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		  fflush(stdout);
		  assert(0 <= IN2 && IN2 <= maxIN);
		}
		if(DEBUG) assert(IN1 <= IN2);
		  
		int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		int origactivecnt = activecnt;

		for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
		  if(DELTA_RANGE[T] <= 0){
		    activecnt++;
		    DELTA_RANGE[T] = min_DELTA;
		    for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
		      Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
		    if(HAPSTOP_DEBUG){
		      printf("Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to merging of Hcuts[%d..%d]=%0.4f..%0.4f\n",
			     T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			     DELTA_RANGE[T],Initial_Delta[T][0], Initial_Delta[T][DELTA_RANGE[T]-1], i, iR, Hcuts[i], Hcuts[iR]);
		      fflush(stdout);
		    }
		  } else if(HAPSTOP_DEBUG>=2){
		    printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after merging of Hcuts[%d..%d] with DELTA_RANGE[T]=%d (%0.3f .. %0.3f)\n",
			   T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			   i,iR,DELTA_RANGE[T], Initial_Delta[T][0], Initial_Delta[T][DELTA_RANGE[T]-1]);
		    fflush(stdout);
		  }
		}

		if(VERB && activecnt > origactivecnt){
		  if(VERB>=2 || HAPSTOP_DEBUG){
		    int inactivecnt = 0;
		    for(int IN = 0; IN <= maxIN; IN++)
		      if(DELTA_RANGE[IN] <= 0)
			inactivecnt++;

		    printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f : inactive intervals = %d/%d\n",
			   activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, iR, Hcuts[i], Hcuts[iR], inactivecnt,maxIN+1);
		  } else
		    printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f\n",
			   activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, iR, Hcuts[i], Hcuts[iR]);
		  fflush(stdout);
		}
	      }	      
	    }
	  }
	}/* for i = 1..n */
      } // if(MERGE_SNPS)

      /* If labels were removed continue adjusting sizes, otherwise break out of the main loop */
      if(Deresed <= HAP_MAX_DERES && (changecnt > 0 || prevN1 != origN1 || prevN2 != origN2 || N1 != prevN1 || N2 != prevN2)){

	LPhwm = newLP;
	LPdrop_count = 0;

	if(DELTA_STOP && !(DELTA_STOP >= 3)){	/* increase range of Delta values to at least LOW_VALUES + HIGH_VALUES + 1 and reset Initial_Delta[IN][d] values to original values (starting at 0.070) */
	  int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);
	  for(int IN = 0; IN <= maxIN; IN++){
	    DELTA_RANGE[IN] = max(min_DELTA, DELTA_RANGE[IN]);

	    // NOTE : it is faster if the Initial_Delta[IN][] are left at the previous values (which are typically the lowest possible values) : values can increase if any improvements are found
	    /*	    for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
		    Initial_Delta[IN][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;*/

	    if(DEBUG>=1+RELEASE){
	      for(int d = 0; d < DELTA_RANGE[IN]; d++){
		if(!(fabs(Initial_Delta[IN][d]) < 1000.0)){
		  printf("Initial_Delta[IN=%d][d=%d] = %0.4f is too large\n",IN,d,Initial_Delta[IN][d]);
		  fflush(stdout);
		  assert(fabs(Initial_Delta[IN][d] < 1000.0));
		}
		if(d > 0 && !(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0)){
		  printf("Initial_Delta[IN=%d][d=%d,%d] = %0.4f,%0.4f ratio is too large\n",IN,d-1,d,Initial_Delta[IN][d-1],Initial_Delta[IN][d]);
		  fflush(stdout);
		  assert(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0);
		}
	      }	
	    }
	  }
	  if(VERB/* HERE >=2 */ || HAPSTOP_DEBUG){
	    printf("Re-activated all %d ranges:Initial_Delta[0][0..%d..%d] -> %0.4f,%0.4f .. %0.4f,%0.4f .. %0.4f,%0.4f:DELTA_RANGE[0]=%d,localINITIAL_DELTA_RANGE=%d,min_DELTA=%d,DELTA_OVERSAMPLE=%d\n",
		   maxIN+1,DELTA_RANGE[0]-1,localINITIAL_DELTA_RANGE-1,Initial_Delta[0][0], Initial_Delta[0][1], Initial_Delta[0][DELTA_RANGE[0]-2],Initial_Delta[0][DELTA_RANGE[0]-1],
		   Initial_Delta[0][localINITIAL_DELTA_RANGE-2],Initial_Delta[0][localINITIAL_DELTA_RANGE-1],DELTA_RANGE[0],localINITIAL_DELTA_RANGE,min_DELTA,DELTA_OVERSAMPLE);
	    fflush(stdout);
	  }
	}

	// make sure next iteration is NOT an Indel iteration, so that all SNPs are rechecked with new (Final) scoring function
	if(HINDELITER(iter+1))
	  iter++;

	SNPfail = SNPskip = 0;
	lastiter = iter;
	int origmaxiter = maxiter;
	maxiter = max(maxiter, iter + (int)(ITER_INC + max(N1,N2)*ITER_FRAC)/2);
	HapUpdatemapSkipcnt = 0;

	if(VERB){
	  double wt = wtime();
	  printf("After merging %d(%d + %d) labels in Y1 + Y2: Resuming Haplotype refinement (no new HapSites or HapIndels) : increased -HapMinLL from %0.2f %0.2f %0.2f to %0.2f %0.2f %0.2f (delta,indel,SNP), maxiter= %d to %d, iter=%d: wall delta=%0.6f (elapsed= %0.6f)\n",
		 changecnt,origN1-N1,origN2-N2, IntervalEps,HapIndelEps,HapLabelEps,IntervalEps2,HapIndelEps2,HapLabelEps2,origmaxiter, maxiter, iter, wt-wtstart,wt);
	  if(VERB>=2){
	    int hap = 0;
	    for(int i = 1; i <= n; i++){
	      if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
		printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	      if(hap && HapSite[i]==3)
		hap = 0;
	      if(HapDelta[i])
		hap = 1;
	    }
	  }
	  fflush(stdout);
	}
	IntervalEps = IntervalEps2;
	HapIndelEps = HapIndelEps2;
	HapLabelEps = HapLabelEps2;
	return changecnt;// labels were changed
      }

      if(VERB){
	double wt = wtime();
	printf("After trying to merge labels in Y1 + Y2: NOT resuming Haplotype refinement (no new HapSites or HapIndels) : -HapMinLL %0.2f %0.2f %0.2f (delta,indel,SNP),iter=%d: wall delta=%0.6f (elapsed= %0.6f)\n",
	       IntervalEps,HapIndelEps,HapLabelEps,iter, wt-wtstart,wt);
	fflush(stdout);
      }
    }
  }// if (Deresed < Hap_MAX_DERES)

  return changecnt;
}

// HERE HERE : return number of changes made : If 0, no need to expect any improvement or check LP
static __attribute__ ((noinline)) void fastHapDelta(const int iter, const int imin, const int imax, const int n,
			 const double initHapIndelPvalue, const double origHapIndelPvalue,
			 const int startN1, const int startN2, 
			 const int maxIN, const int DELTA_OVERSAMPLE, const int DELTA_SCAN, int *DELTA_RANGE, const int DELTA_INTERVALS, const double DELTA_INTERVAL, int &activecnt, int &newactivecnt,
			 double **Initial_Delta,
			 int *ID1, int *ID2, int *Dcum, int *Dcum2,
			 const int Filtered, const int Deresed, const size_t threadsize,
			 const double HtrimL1, const double HtrimR1, const double HtrimL2, const double HtrimR2,
			 const int numthreads,
			 double *Hcuts, double *Hcuts1, double *Hcuts2, 
			 int *Hdel1, int *Hdel2,
			 int &N1, int &N2, double *Y1, double *Y2, double *startY1, double *startY2,
			 int *skip, double *TBmapWT, double *startLP,
			 int *HapSite, double *HapDelta, double *Delta, 
			 int *prevHapSite, double *prevHapDelta, double *prevDelta, 
			 double *nHapDelta, double *nHapDelta2, double *nDelta,
			 double *DelCum, double *HapDelCum, double *HapDeltaScore,
			 int *startHdel1, int *startHdel2, int *addid1, int *addid2, 
			 const double LPstart, const double BigPen, const double logH, const double rawLPstart,
			 const double logHapSitePvalue, double logHapIndelPvalue,
			 const int startSNPcnt, const int startIndelCnt,
			 double *startLPA1, double *startLPA2,
			 double *LPindel, double *LPdelta, double **newLPdelta, double **newLPdelta2,
			 int *D1, int *D2, int *DR1, int *DR2, int *biggestD1,
			 int *AminM, int *AminM2, int *AmaxM, int *AmaxM2,
			 double ***LPddT, double **LPdd, double *LPddmem, 
			 int *d1List, int *d2List, double *pvLP1, double *pvLP2, double *prLP,
			 double **delta1, double **delta2,
			 double *HapDeltaMerged,
			 CdoubleBlock **pBlock1, CdoubleBlock **pBlock2, 
			 CLabel *Label, int *Index, int *Hremap,
			 int *changes, int *tchanges, int &progress, int &changecnt, int &hapdeltacnt, int &deltacnt,
			 double *spreadHapDelta, double *spreadDelta,
			 int **map1, int **map2, int **mapK1, int **mapK2, 
			 int **nmap1, int **nmap2, int *MX, const int MD
)
{
  /* keep track of locally best improvement to LP values */
  double LPbest = LPstart;/* best LP value so far since last change (at site ibest), during following main i=1..imax+1 loop */
  int ibest = -1, Lbest = -1, Rbest = -1;/* site i value corresponding to LPbest (and previous and next site with HapSite[] != 0) */
  int LLbest = -1, RRbest = -1;/* corresponding LL and RR values (see HINDEL_MERGE >= 2) */
  int tbest = -1;/* Type of LPbest : 0 == nHapSite[ibest] changed, 1 == nHapDelta[ibest] change, 2 == nDelta[ibest] change (non HaploType interval size change for Hcuts[ibest..ibest+1]) */

  /* Use the saved per map LP values to score HaploType changes */
  int I1 = 0, I2 = 0;/* Number of real sites encoutered on HaploType 1 and 2 respectively : used to access site deletion LP values newLPd2[m][I2 < DminM2[m] ? 0 : min(DmaxM2[m],I2)] */
  //  int T1 = -1, T2 = -1;/* addloc2[T2] is last missing site encountered on HaploType 2 : used to access site addition LP values newLPa2[m][T2 < TminM2[m] ? TminM2[m] : min(TmaxM2[m],T2)] */
  //  double LPsnp[4];/* LPsnp[h=0..3] is used to save LP values for HapSite[i] = h */

  double cumwt1 = 0.0;/* time to compute LPdd and find next best change */
  double cumwt2 = 0.0;/* time from LcheckbestB till HapDeltaSpread (tbest == 1) */
  double cumwt3 = 0.0;/* time from HapDeltaSpread to end of loop (tbest == 1) */
  double cumwt4 = 0.0;/* time from LcheckbestB till HapDeltaSpread (tbest == 2) */
  double cumwt5 = 0.0;/* time from HapDeltaSpread to end of loop (tbest == 2) */

  double lastmt = TIME_VERBOSE ? mtime() : 0.0;
  double lastwt = TIME_VERBOSE ? wtime() : 0.0;

  double lastVmRSS = 0.0;

  for(int i = 1; i <= imax+1; i++){// main i loop */
    int L,R;
    int LL = -1;/* previous site with HapSite[LL] == 3 (or 0 if none) */
    int RR = -1;/* next site with HapSite[RR] == 3 (or n+1 if none) */

    double range1 = -1.0,range2 = -1.0;
    int IN1 = -1, IN2 = -1;
    if(i > imax){
      if(ibest >= 1)
	goto LcheckbestB;/* need to check last improvement */
      break;
    }

    I1 += 1 - startHdel1[i];
    I2 += 1 - startHdel2[i];
    if(DEBUG>=2 && !(I1 <= startN1 && I2 <= startN2 && startY1[I1] <= startY1[I1+1] && startY2[I2] <= startY2[I2+1])){
      printf("i=%d,n=%d,imax=%d:I1=%d,N1=%d,Y1[I1]=%0.3f,Y1[I1+1]=%0.3f,Hdel1[i]=%d\n",i,n,imax,I1,startN1,startY1[I1],startY1[I1+1],startHdel1[i]);
      printf("i=%d,n=%d,imax=%d:I2=%d,N2=%d,Y2[I2]=%0.3f,Y2[I2+1]=%0.3f,Hdel2[i]=%d\n",i,n,imax,I2,startN2,startY2[I2],startY2[I2+1],startHdel2[i]);
      fflush(stdout);
      assert(I1 <= startN1);
      assert(startY1[I1] <= startY1[I1+1]);
      assert(I2 <= startN2);
      assert(startY2[I2] <= startY2[I2+1]);
    }
    if(DEBUG>=2) assert(startHdel1[i]==0 || startHdel1[i]==1);
    if(DEBUG>=2) assert(startHdel2[i]==0 || startHdel2[i]==1);
    if(DEBUG>=2) assert(i <= n);

    if(i <= imin)
      continue;

    L = i - 1;/* previous site with HapSite[L] */
    while(L >= 1 && !HapSite[L])
      L--;
    R = i+1;/* next site with HapSite[R] */
    while(R <= n && !HapSite[R])
      R++;

    LL = i;
    while(LL >= 1 && HapSite[LL] != 3)
      LL--;
    RR = R;
    while(RR <= n && HapSite[RR] != 3)
      RR++;

    //    LPsite[i] = LPstart - BigPen;/* default value == no improvement possible */
    //    nHapSite[i] = HapSite[i];

    LPindel[i] = LPstart - BigPen;/* default value == no improvement possible */
    nHapDelta[i] = 0.0;/* nHapDelta[i] is the change in HapDelta[i] during the current iteration */
    nHapDelta2[i] = 0.0;/* nHapDelta2[i] is the change in Delta[i] that goes along with nHapDelta[i] (typically 0.0, unless there are outliers) */

    LPdelta[i] = LPstart - BigPen;/* default value == no improvement possible */
    nDelta[i] = 0.0;/* nDelta[i] is the change in Delta[i] during the current iteration */

    /* compute current sizes of Hcuts1[] and Hcuts2[] intervals that include changes from the current iteration so far : This may differ from what existed when mprobeval() was called */
    range1 = (1 <= I1 && I1 < startN1) ? (Y1[I1+1] - Y1[I1]) : Hcuts[R] - Hcuts[i] + HapDelta[i] + Delta[i];
    range2 = (1 <= I2 && I2 < startN2) ? (Y2[I2+1] - Y2[I2]) : Hcuts[R] - Hcuts[i] - HapDelta[i] + Delta[i];

    if(HINDEL_FAST && HapSite[i] && R <= n){

      if(DEBUG>=2) assert(0 <= I1 && I1 <= startN1);
      if(DEBUG>=2) assert(0 <= I2 && I2 <= startN2);
      IN1 = ID1[I1];
      IN2 = ID2[I2];
      if(DEBUG>=2) assert(0 <= IN1 && IN1 <= maxIN);
      if(DEBUG>=2) assert(0 <= IN2 && IN2 <= maxIN);

      /* precompute LPdd[d1][d2] for list of (d1,d2) pairs that will be needed by both HINDEL and HSIZES.
	 Speedup is obtained by only computing the change in LP for molecules m with (AminM[m] <= I1 && I1 <= AmaxM[m]) || (AminM2[m] <= I2 && I2 <= AmaxM2[m]) */

      /* (re)allocate LPdd[d1][d2] and LPddT[tid][d1][d2] */
      size_t memcnt = 0, tmemcnt = 0;
      for(int d1 = -1; d1 < D1[I1]; d1++){
	LPdd[d1] = &LPddmem[1 + memcnt];
	memcnt += 1 + D2[I2];
      }
      if(DEBUG>=2) assert(memcnt <= tmemcnt + threadsize);
      memcnt = tmemcnt += threadsize;
      if(!HAPSTOP_FIX || D1[I1] > 0 || D2[I2] > 0){
	for(int tid = 0; tid < numthreads; tid++){
	  for(int d1 = -1; d1 < D1[I1]; d1++){
	    LPddT[tid][d1] = &LPddmem[1 + memcnt];
	    memcnt += 1 + D2[I2];
	  }
	  assert(memcnt <= tmemcnt + threadsize);
	  memcnt = tmemcnt += threadsize;
	}
      }
      if(DEBUG) assert(tmemcnt <= (numthreads+1) * threadsize);

      /* initialize d1List[0..ddcnt-1],d2List[0..ddcnt-1] */
      int ddcnt = 0;
      if(DR1[I1] > 0 && DR2[I2] > 0){
	for(int d1 = 0; d1 < DR1[I1]; d1++){
	  int d2 = min(d1,DR2[I2]-1);
	  while(d2 < DR2[I2]-1 && delta1[I1][d1] - delta2[I2][d2] >= MIN_INDEL_SIZE)
	    d2++;
	  while(d2 > 0 && delta2[I2][d2] - delta1[I1][d1] >= MIN_INDEL_SIZE)
	    d2--;
	  if(DEBUG) assert(0 <= d2 && d2 < DR2[I2]);
	  if(fabs(delta1[I1][d1] - delta2[I2][d2]) < MIN_INDEL_SIZE){
	    if((range1 + delta1[I1][d1] < minKB || range2 + delta2[I2][d2] < minKB))
	      continue;
	    d1List[ddcnt] = d1;
	    d2List[ddcnt++] = d2;
	  }
	}
      }

      if((HINDEL_UPDATE || HapDelta[i] == 0.0)){
	if(DEBUG) assert(HINDEL_NONSYMETRIC);// otherwise symmetric case below is more complicated
	for(int d1 = 0; d1 < D1[I1]; d1++){
	  int d2;
	  if(d1 >= DR1[I1]){/* check for indel reversals and terminate d1 loop */
	    if(!(HapDelta[i] && (HINDEL_PHASED == 0.0 || HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)))
	      break;
	    /* locate d1 value corresponding to HapDelta[i] == -delta1[I1][d1] */
	    while(d1 < D1[I1] && fabs((HapDeltaMerged[i]) + delta1[I1][d1]) >= MIN_INDEL_SIZE)
	      d1++;
	    if(d1 >= D1[I1])
	      continue;
	    d2 = DR2[I2];
	    for(; d2 < D2[I2]; d2++)
	      if(fabs((HapDeltaMerged[i]) - delta2[I2][d2]) < MIN_INDEL_SIZE)
		break;
	    if(d2 >= D2[I2])
	      continue;
	    if(DEBUG) assert(fabs(HapDeltaMerged[i] + delta1[I1][d1]) < MIN_INDEL_SIZE &&
			     fabs(HapDeltaMerged[i] - delta2[I2][d2]) < MIN_INDEL_SIZE);
	  } else if(d1 >= DELTA_RANGE[IN1]){
	    d2 = d1 - DELTA_RANGE[IN1];// NOTE : this may not always be the symmetric case, but will be included in HINDEL_NONSYMETRIC branch below
	  } else {
	    d2 = d1 + DELTA_RANGE[IN2];// NOTE : this may not always be the symmetric case, but will be included in HINDEL_NONSYMETRIC branch below
	  }

	  if(DEBUG) assert(d2 >= 0);
	  double incDelta = (d2 >= D2[I2]) ? 0.0 : 0.5 * (delta1[I1][d1] + delta2[I2][d2]);
	  double incHapDelta = (d2 >= D2[I2]) ? 0.0 : 0.5 * (delta1[I1][d1] - delta2[I2][d2]);

	  double origHapDelta = HapDeltaMerged[i];
	  if((Filtered /* NEW157 */|| (Deresed && cresHapMaxLPdrop > 0.0)) && d1 < DR1[I1] && fabs(origHapDelta) < MIN_INDEL_SIZE && fabs(origHapDelta + incHapDelta) >= MIN_INDEL_SIZE)
	    continue;// Avoid adding new Hap Indel

	  if(d1 >= DR1[I1] || (d2 < DR2[I2] && (d1 < DELTA_RANGE[IN1] || d2 < DELTA_RANGE[IN2]) && fabs(incHapDelta) >= MIN_INDEL_SIZE && 
			       (range1 + incDelta + incHapDelta >= minKB && range2 + incDelta - incHapDelta >= minKB))){
	    d1List[ddcnt] = d1;
	    d2List[ddcnt++] = d2;
	  }
	  if(HINDEL_NONSYMETRIC && d1 < DR1[I1]){
	    int origd2 = d2;
	    for(d2 = 0; d2 < DR2[I2]; d2++){
	      incHapDelta = 0.5 * (delta1[I1][d1] - delta2[I2][d2]);
	      if(fabs((RefineFix ? 1.0 : 2.0) * incHapDelta) < MIN_INDEL_SIZE || d2 == origd2)
		continue;
	      if((Filtered /* NEW157 */|| (Deresed && cresHapMaxLPdrop > 0.0)) && fabs(origHapDelta) < MIN_INDEL_SIZE && fabs(origHapDelta + incHapDelta) >= MIN_INDEL_SIZE)
		continue;// Avoid adding new Hap Indel
	      incDelta = 0.5 * (delta1[I1][d1] + delta2[I2][d2]);
	      if(range1 + incDelta + incHapDelta < minKB || range2 + incDelta - incHapDelta < minKB)
		continue;
	      d1List[ddcnt] = d1;
	      d2List[ddcnt++] = d2;
	    }
	  }
	}
	if(DEBUG) assert(ddcnt <= (2*INITIAL_DELTA_RANGE + MAX_INDEL)*(2*INITIAL_DELTA_RANGE + MAX_INDEL));
      }/* if(HINDEL) */

      if(!HAPSTOP_FIX || ddcnt > 0){

	int nthreads = numthreads;

	/* Now precompute LPdd[d1][d2] for all (d1,d2) values in d1List[0..ddcnt-1],d2List[0..ddcnt-1] */
	for(int d = 0; d < ddcnt; d++){
	  int d1 = d1List[d], d2 = d2List[d];
	  LPdd[d1][d2] = 0.0;
	}
	  
	if(MPROBEVAL_LAZYRESTORE >= 2 && blockListLen >= 1000 && blockListSwapped * 100 < blockListLen * LAZYRESTORE_MIN){
	  double wt = wtime();
	  if(wt > lastVmRSS + 1.0){
	    getmem(VmSize,VmRSS,VmSwap);
	    lastVmRSS = wt;
	  }

	  if(VmRSS + VmSwap > MaxMem * (double) (1e7 * VMRSS_MIN)) { 
	    SwappedAllocations_DONTNEED(blockListLen * LAZYRESTORE_MAX / 100);
	  
            #pragma omp flush // make sure the swapout fields have been written out to memory before the next parallel section (to avoid having other threads seeing stale data and doing unnecessary critical sections to verify)
	  }
	}

	const size_t dsize = 2*INITIAL_DELTA_RANGE + MAX_INDEL+1;	    

	if(DEBUG/* HERE >=2 */){/* verify size and alignment of pre-allocated memory for vectorized code */
	  if(DEBUG && !((size_t)ddcnt <= dsize*dsize)){
	    printf("INITIAL_DELTA_RANGE=%d, MAX_INDEL=%d, dsize=%lu, ddcnt=%d\n",
		   INITIAL_DELTA_RANGE, MAX_INDEL, dsize, ddcnt);
	    fflush(stdout);
	    assert((size_t)ddcnt <= dsize*dsize); 
	  }
	  size_t p = (size_t)prLP;
	  if(DEBUG && !(p == (p & ~(VALIGN-1)))){
	    printf("prLP= 0x%lx, VALIGN= %d\n",(size_t)prLP, VALIGN);
	    fflush(stdout);
	    assert(p == (p & ~(VALIGN-1)));
	  }
	  p = (size_t)pvLP1;
	  if(DEBUG && !(p == (p & ~(VALIGN-1)))){
	    printf("pvLP1= 0x%lx, VALIGN= %d\n",(size_t)pvLP1, VALIGN);
	    fflush(stdout);
	    assert(p == (p & ~(VALIGN-1)));
	  }
	  p = (size_t)pvLP2;
	  if(DEBUG && !(p == (p & ~(VALIGN-1)))){
	    printf("pvLP2= 0x%lx, VALIGN= %d\n",(size_t)pvLP2, VALIGN);
	    fflush(stdout);
	    assert(p == (p & ~(VALIGN-1)));
	  }
	}

        int block = 1;/* NOTE : very few molecules participate in below loop for current I1,I2 with (valid1 || valid2) */
	/*	while(block < 16 && MD > nthreads * block * 32)
		block *= 2;*/

	int LoopCnt = 0, LoopCnt2 = 0;
        #pragma omp parallel num_threads(nthreads)
	{
	  int myLoopCnt = 0, myLoopCnt2 = 0;
	  int tid = 0;
#ifdef _OPENMP
	  tid = omp_get_thread_num ();
#endif

	  // allocate per-thread memory for vectorized code
	  
#if 0 // STACK ALLOCATION : can overflow the per-thread stack
	  double rLP[ddcnt] __attribute__((aligned(VALIGN)));
	  double vLP1[ddcnt] __attribute__((aligned(VALIGN)));
	  double vLP2[ddcnt] __attribute__((aligned(VALIGN)));
#else // Heap Allocation, pre-allocated in parent
	  size_t ddcnt_align = (ddcnt + (VALIGN/sizeof(double)) - 1) & ~((VALIGN/sizeof(double)) - 1);
	  double *rLP = &prLP[ddcnt_align * tid];
	  double *vLP1 = &pvLP1[ddcnt_align * tid];
	  double *vLP2 = &pvLP2[ddcnt_align * tid];
#endif

	  for(int d = 0; d < ddcnt; d++)
	    LPddT[tid][d1List[d]][d2List[d]] = 0.0;
	  
          #pragma omp for schedule(dynamic,block) 
	  for(int m = 0; m < MD; m++){
	    if(OMP_DEBUG) myLoopCnt++;
	    int valid1 = (AminM[m] <= I1 && I1 <= AmaxM[m]);
	    int valid2 = (AminM2[m] <= I2 && I2 <= AmaxM2[m]);
	    if(!valid1 && !valid2)
	      continue;

	    if(MPROBEVAL_LAZYRESTORE){
	      CdoubleBlock *p;

	      if(valid1 && (p = pBlock1[m])->swapout > 0){// NOTE : the value of swapout may be stale (some other thread may have changed it) but values only change from 1 to 0 within this parallel section
                #pragma omp critical(blockList)
	        {
	          if(p->swapout > 0){
	            int origswapout = p->swapout;
	            int origswapcnt = blockListSwapped;
	            if(DEBUG>=2) assert(blockListSwapped == SwappedAllocations_swapcnt());

	            p->readin();
	            blockListSwapped--;

	            if((DEBUG && !(0 <= blockListSwapped && p->swapout < 0)) || (DEBUG>=2 && !(blockListSwapped == SwappedAllocations_swapcnt()))){
		      printf("WARNING:m=%d/%d,swapout=%d->%d,blockListSwapped=%d->%d(correct value=%d),blockListLen=%d,blockListMax=%d\n",m,MD,origswapout,(int)p->swapout,origswapcnt,blockListSwapped,SwappedAllocations_swapcnt(),blockListLen,blockListMax);
		      fflush(stdout);

		      assert(0 <= blockListSwapped && p->swapout < 0);
		      assert(blockListSwapped == SwappedAllocations_swapcnt());
	            }
	          }
	        }
	      }
	      if(valid2 && (p = pBlock2[m])->swapout > 0){// NOTE : the value of swapout may be stale (some other thread may have changed it) but values only change from 1 to 0
                #pragma omp critical(blockList)
	        {
	          if(p->swapout > 0){
	            int origswapout = p->swapout;
	            int origswapcnt = blockListSwapped;
	            if(DEBUG>=2) assert(blockListSwapped == SwappedAllocations_swapcnt());

	            p->readin();
	            blockListSwapped--;

	            if((DEBUG && !(0 <= blockListSwapped && p->swapout < 0)) || (DEBUG>=2 && !(blockListSwapped == SwappedAllocations_swapcnt()))){
	              printf("WARNING:m=%d/%d,swapout=%d->%d,blockListSwapped=%d->%d(correct value=%d),blockListLen=%d,blockListMax=%d\n",m,MD,origswapout,(int)p->swapout,origswapcnt,blockListSwapped,SwappedAllocations_swapcnt(),blockListLen,blockListMax);
	              fflush(stdout);

	              assert(0 <= blockListSwapped && p->swapout < 0);
	              assert(blockListSwapped == SwappedAllocations_swapcnt());
	            }
	          }
	        }
	      }
	    }

	    double origLP = startLP[m];
	    int Doffset1 = Dcum[I1] - Dcum[AminM[m]];
	    int Doffset2 = Dcum2[I2] - Dcum2[AminM2[m]];

#if 0 // OLD CODE (not vectorized)
	    for(int d = 0; d < ddcnt; d++){
	      int d1 = d1List[d];
	      int d2 = d2List[d];
	      double LP1 = valid1 ? newLPdelta[m][Doffset1 + d1] : startLPA1[m];
	      double LP2 = valid2 ? newLPdelta2[m][Doffset2 + d2] : startLPA2[m];

	      double nLP = HapLP(LP1,LP2);

	      LPddT[tid][d1][d2] += (nLP - origLP) * TBmapWT[m];
	    }
#else // NEW CODE with vectorized (simd) calls to log() and exp() : requires per thread memory vLP1[],vLP2[],rLP[]
	    double wt = TBmapWT[m];
	    double *pLPdelta1 = &newLPdelta[m][Doffset1];
	    double *pLPdelta2 = &newLPdelta2[m][Doffset2];

	    // vectorize the calls to log() and exp() by accumulating vectors of LP1, LP2 and computing vector result rLP == (nLP - origLP) * wt
	    if(valid1){
	      if(valid2){// valid1 && valid2

		for(int d = 0; d < ddcnt; d++){// #pragma no vector // pLPdelta1[] and pLPdelta2[] are unaligned
		  int d1 = d1List[d];
		  int d2 = d2List[d];
		  vLP1[d] = pLPdelta1[d1];
		  vLP2[d] = pLPdelta2[d2];// segfault on this line
		}

		#pragma omp simd aligned(vLP1,vLP2,rLP : VALIGN)
		for(int d = 0; d < ddcnt; d++){
		  double LP1 = vLP1[d];
		  double LP2 = vLP2[d];
		  double nLP = HapLP(LP1,LP2,logH);

		  rLP[d] = (nLP - origLP) * wt;
		}
	      } else {// valid1 && !valid2
		double LP2 = startLPA2[m];

		for(int d = 0; d < ddcnt; d++){
		  int d1 = d1List[d];
		  vLP1[d] = pLPdelta1[d1];
		}

		#pragma omp simd aligned(vLP1,rLP : VALIGN)
		for(int d = 0; d < ddcnt; d++){
		  double LP1 = vLP1[d];
		  double nLP = HapLP(LP1,LP2,logH);

		  rLP[d] = (nLP - origLP) * wt;
		}
	      }
	    } else { // !valid1 && valid2
	      if(DEBUG>=2) assert(valid2);

	      double LP1 = startLPA1[m];

	      for(int d = 0; d < ddcnt; d++){
		int d2 = d2List[d];
		vLP2[d] = pLPdelta2[d2];
	      }

	      #pragma omp simd aligned(vLP2,rLP : VALIGN)
	      for(int d = 0; d < ddcnt; d++){
		double LP2 = vLP2[d];
		double nLP = HapLP(LP1,LP2,logH);

		rLP[d] = (nLP - origLP) * wt;
	      }
	    }

	    for(int d = 0; d < ddcnt; d++){
	      int d1 = d1List[d];
	      int d2 = d2List[d];
	      LPddT[tid][d1][d2] += rLP[d];
	    }
#endif // NEW CODE
	  } // omp for m = 0..MD-1
	  
// #pragma omp barrier // Not needed since "omp for" includes a barrier at the end
         /* add up the results from the different threads */

          #pragma omp for schedule(static,1)
	  for(int d = 0; d < ddcnt; d++){
	    if(OMP_DEBUG) myLoopCnt2++;
	    int d1 = d1List[d];
	    int d2 = d2List[d];

	    double sum = 0.0;
	    for(int tid = 0; tid < nthreads; tid++)
	      sum += LPddT[tid][d1][d2];
	    LPdd[d1][d2] = sum;
	  }// omp for d = 0 .. ddcnt-1

          if(OMP_DEBUG && (myLoopCnt > 0 || myLoopCnt2 > 0)){
            #pragma omp critical
	    {
	      LoopCnt += myLoopCnt;
	      LoopCnt2 += myLoopCnt2;
	    }
	  }
	}// omp parallel
	if(OMP_DEBUG) assert(LoopCnt == MD);
	if(OMP_DEBUG) assert(LoopCnt2 == ddcnt);
      }// if(ddcnt > 0)
    }// if(HINDEL_FAST ...)

    /* next check adding an indel in interval Hcuts[i..i+1] */
    /* only check for indels if left end of interval has a site in at least one of the 2 Alleles */
    if(HapSite[i] && R <= n && (HINDEL_UPDATE || HapDelta[i] == 0.0) && D1[I1] > 0){
      if(DEBUG>=2) assert(0 <= IN1 && IN1 <= maxIN);
      if(DEBUG>=2) assert(0 <= IN2 && IN2 <= maxIN);

      double LPd[INITIAL_DELTA_RANGE*2];/* LPd[d1 = 0..D1[I1]-1] */
      int LPd2[INITIAL_DELTA_RANGE*2];/* LPd2[d1] is the corresponding d2 value with the best score */

      /* check intervals Y1[I1..I1+1] and Y2[I2..I2+1] for presence of Indel */
      int d1, d2;/* index into delta1[I1][d1=0..D1[I1]-1] & delta2[I2][d2=0..D2[I2]-1] respectively : 
		    used to access indel LP values : (AminM2[m] <= I2 <= AmaxM2[m]) ? newLPdelta2[m][I2,d2] : startLPA2[m] */
      if(DEBUG) assert(i < R && R <=n && HapSite[R]);

      for(d1 = 0; d1 < D1[I1]; d1++){
	LPd[d1] = LPstart - BigPen;/* bad value as default for unhandled cases */
	LPd2[d1] = -1;
      }

      for(d1 = 0; d1 < D1[I1]; d1++){
	if(d1 >= DR1[I1]){/* check for indel reversals and terminate d1 loop */
	  if(!(HapDelta[i] && (HINDEL_PHASED == 0.0 || HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)))
	    break;
	  /* locate d1 value corresponding to HapDelta[i] == -delta1[I1][d1] */
	  while(d1 < D1[I1] && fabs(HapDeltaMerged[i] + delta1[I1][d1]) >= MIN_INDEL_SIZE)
	    d1++;
	  if(d1 >= D1[I1])	// NOTE : this can also happen if I1 <= 0 or I1 >= N1 (hence no sizing changes considered) because the end label became Heterozygous after the HapDelta next to it was introduced
	    continue;
	  for(d2 = DR2[I2]; d2 < D2[I2]; d2++)
	    if(fabs(HapDeltaMerged[i] - delta2[I2][d2]) < MIN_INDEL_SIZE)
	      break;
	  if(d2 >= D2[I2])   // NOTE : this can also happen if I2 <= 0 or I2 >= N2 (hence no sizing changes considered) because the end label became Heterozygous after the HapDelta next to it was introduced
	    continue;
	  if(DEBUG>=2 && !(fabs(HapDeltaMerged[i] + delta1[I1][d1]) < MIN_INDEL_SIZE &&
			fabs(HapDeltaMerged[i] - delta2[I2][d2]) < MIN_INDEL_SIZE)){
	    printf("d1=%d,d2=%d,I1=%d,I2=%d,delta1[I1][d1]=%0.3f,delta2[I2][d2]=%0.3f,D1[I1]=%d,D2[I2]=%d\n", d1,d2,I1,I2,delta1[I1][d1],delta2[I2][d2],D1[I1],D2[I2]);
	    fflush(stdout);
	    assert(fabs(HapDeltaMerged[i] + delta1[I1][d1]) < MIN_INDEL_SIZE &&
		   fabs(HapDeltaMerged[i] - delta2[I2][d2]) < MIN_INDEL_SIZE);
	  }
	} else if(d1 >= DELTA_RANGE[IN1]){
	  d2 = d1 - DELTA_RANGE[IN1];// NOTE : this may not always be the symmetric case, but will be included in HINDEL_NONSYMETRIC branch below
	  if(DEBUG>=2 && d2 < DR2[I2] && d2 < DELTA_RANGE[IN2] && !(delta1[I1][d1] < 0.0 && delta2[I2][d2] > 0.0)){
	    printf("d1=%d,d2=%d,IN1=%d,IN2=%d,DELTA_RANGE[IN1]=%d,DELTA_RANGE[IN2]=%d,I1=%d,I2=%d,DR1[I1]=%d,D1[I1]=%d,DR2[I2]=%d,D2[I2]=%d:delta1[I1][d1]= %0.4f,delta2[I2][d2]=%0.4f\n",
	      d1,d2,IN1,IN2,DELTA_RANGE[IN1],DELTA_RANGE[IN2],I1,I2,DR1[I1],D1[I1],DR2[I2],D2[I2],delta1[I1][d1],delta2[I2][d2]);
	    for(int t = 0; t < D1[I1]; t++)
	      printf("delta1[I1][%d]= %0.6f\n",t,delta1[I1][t]);
	    for(int t = 0; t < D2[I2]; t++)
	      printf("delta2[I2][%d]= %0.6f\n",t,delta2[I2][t]);
	    for(int t = 0; t < DELTA_RANGE[IN1]; t++)
	      printf("Initial_Delta[IN1][%d] = %0.6f\n",t, Initial_Delta[IN1][t]);
	    for(int t = 0; t < DELTA_RANGE[IN2]; t++)
	      printf("Initial_Delta[IN2][%d] = %0.6f\n",t, Initial_Delta[IN1][t]);
	    fflush(stdout);
	    assert(delta1[I1][d1] < 0.0 && delta2[I2][d2] > 0.0);
	  }
	} else {
	  d2 = d1 + DELTA_RANGE[IN2];// NOTE : this may not always be the symmetric case, but will be included in HINDEL_NONSYMETRIC branch below
	  if(DEBUG>=2 && d2 < DR2[I2] && !(delta1[I1][d1] > 0.0 && delta2[I2][d2] < 0.0)){	    
	    printf("i=%d:d1=%d,d2=%d,I1=%d,I2=%d,delta1[I1][d1]=%0.3f,delta2[I2][d2]=%0.3f,D1[I1]=%d,D2[I2]=%d,DELTA_RANGE[%d,%d]=%d,%d,R=%d,HapSite[i,R]=%d,%d\n",
	      i,d1,d2,I1,I2,delta1[I1][d1],delta2[I2][d2],D1[I1],D2[I2],IN1,IN2,DELTA_RANGE[IN1],DELTA_RANGE[IN2],R,HapSite[i],HapSite[R]);
	    for(int d = 0; d < D1[I1]; d++)
	      printf("delta1[I1][%d]=%0.3f\n",d,delta1[I1][d]);
	    for(int d = 0; d < D2[I2]; d++)
	      printf("delta2[I2][%d]=%0.3f\n",d,delta2[I2][d]);
	    for(int t = i; t < R; t++)
	      if(HapDelta[t] || Delta[t])
		printf("HapDelta[%d]=%0.3f,Delta[%d]=%0.3f\n",t,HapDelta[t],t,Delta[t]);
	    fflush(stdout);
	    assert(delta1[I1][d1] > 0.0 && delta2[I2][d2] < 0.0);	    
	  }
	}
	
	if(DEBUG>=2) assert(d2 >= 0);
	double incDelta = (d2 >= D2[I2]) ? 0.0 : 0.5 * (delta1[I1][d1] + delta2[I2][d2]);
	double incHapDelta = (d2 >= D2[I2]) ? 0.0 : 0.5 * (delta1[I1][d1] - delta2[I2][d2]);
	double origHapDelta = HapDeltaMerged[i];
	if((Filtered /* NEW157 */|| (Deresed && cresHapMaxLPdrop > 0.0)) && d1 < DR1[I1] && fabs(origHapDelta) < MIN_INDEL_SIZE && fabs(origHapDelta + incHapDelta) >= MIN_INDEL_SIZE)
	  continue;// Avoid adding new Hap Indel

	if((LL <= 0 || RR > n) && Hcuts[R] - Hcuts[i] + Delta[i] + incDelta - fabs(HapDelta[i]+incHapDelta) < minKB)
	  continue;

	if(d1 >= DR1[I1] || (d2 < DR2[I2] && (d1 < DELTA_RANGE[IN1] || d2 < DELTA_RANGE[IN2]) && fabs(incHapDelta) >= MIN_INDEL_SIZE && 
			     !(range1 + delta1[I1][d1] < minKB || range2 + delta2[I2][d2] < minKB))){
	  LPd[d1] = rawLPstart + LPdd[d1][d2];

	  LPd[d1] -= 0.5*(startN1+startN2)*SITE_PEN;
	  LPd[d1] += logHapSitePvalue * startSNPcnt + logHapIndelPvalue * startIndelCnt;
	  LPd[d1] += logHapIndelPvalue * ((fabs(HapDeltaMerged[i] + incHapDelta) >= MIN_INDEL_SIZE ? 1 : 0) - (HapDeltaMerged[i] ? 1 : 0));
	  LPd2[d1] = d2;

	  /* update HapDeltaScore[i] */
	  if(d1 >= DR1[I1] && HapDelta[i] && (HINDEL_PHASED == 0.0 || HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE))
	    HapDeltaScore[i] = LPstart - LPd[d1];
	}

        // HERE HERE : should include changing only one Allele in the following section : encode no change as d1= -1 or d2= -1
        if(HINDEL_NONSYMETRIC && d1 < DR1[I1]){/* check for alternate d2 values */
	  /* HERE :  precompute Doffset[m] = Dcum[AminM[m]] & Doffset2[m] = Dcum2[AminM2[m]] */

	  int origd2 = d2;
#pragma novector
	  for(d2 = 0; d2 < DR2[I2]; d2++){
	    incHapDelta = 0.5 * (delta1[I1][d1] - delta2[I2][d2]);
	    if(fabs((RefineFix ? 1.0 : 2.0) * incHapDelta) < MIN_INDEL_SIZE || d2 == origd2)
	      continue;
	    if((Filtered /* NEW157 */|| (Deresed && cresHapMaxLPdrop > 0.0)) && fabs(origHapDelta) < MIN_INDEL_SIZE && fabs(origHapDelta + incHapDelta) >= MIN_INDEL_SIZE)
	      continue;// Avoid adding new Hap Indel
	    incDelta = 0.5 * (delta1[I1][d1] + delta2[I2][d2]);
	    if(range1 + delta1[I1][d1] < minKB || range2 + delta2[I2][d2] < minKB)
	      continue;

	    if((LL <= 0 || RR > n) && Hcuts[R] - Hcuts[i] + Delta[i] + incDelta - fabs(HapDelta[i]+incHapDelta) < minKB)
	      continue;
	      
	    double LPd1 = 0.0;
	    if(DEBUG>=2) assert(isfinite(LPdd[d1][d2]));
	    LPd1 = rawLPstart + LPdd[d1][d2];

	    LPd1 -= 0.5*(startN1+startN2)*SITE_PEN;
	    LPd1 += logHapSitePvalue * startSNPcnt + logHapIndelPvalue * startIndelCnt;
	    LPd1 += logHapIndelPvalue * ((fabs(HapDeltaMerged[i] + incHapDelta) >= MIN_INDEL_SIZE ? 1 : 0) - (HapDeltaMerged[i] ? 1 : 0));

	    if(LPd1 > LPd[d1]){
	      LPd[d1] = LPd1;
	      LPd2[d1] = d2;
	    }
	  }/* d2 = 0 .. DR2[I2] - 1 */
	}/* if(HINDEL_NONSYMMETRIC) */
      } /* d1 = 0 .. D1[I1] - 1 */

      /* locate best indel value LPd[d1 = 0..D1[I1]-1] and see if it is better than LPstart */
      int maxd1 = -1, maxd2 = -1;

#pragma novector
      for(int d1 = 0; d1 < D1[I1]; d1++)
	if(maxd1 < 0 || LPd[d1] > LPd[maxd1]){
	  maxd1 = d1;
	  maxd2 = LPd2[d1];
	}
      
      LPindel[i] = LPstart;
      nHapDelta[i] = 0.0;
      nHapDelta2[i] = 0.0;

      if(maxd1 >= 0 && maxd2 >= 0){// NEW93 : this can happen near ends (eg if I1==0 or I2==0 or I1==N1 or I2==N2) when only one allele can be adjusted (which is currently not supported)
	if(DEBUG && !(0 <= maxd1 && maxd1 < D1[I1] && 0 <= maxd2 && maxd2 < D2[I2])){
	  printf("i=%d: I1=%d,I2=%d,D1[I1]=%d,D2[I2]=%d,N1=%d,N2=%d : maxd1= %d, maxd2= %d\n",i, I1,I2,D1[I1],D2[I2],N1,N2,maxd1, maxd2);
	  fflush(stdout);
	  assert(0 <= maxd1 && maxd1 < D1[I1]);
	  assert(0 <= maxd2 && maxd2 < D2[I2]);
	}

	LPindel[i] = max(LPd[maxd1],LPstart);
	nHapDelta[i] = ((LPd[maxd1] > LPstart + HLP_MINDELTA) ? 0.5*(delta1[I1][maxd1]-delta2[I2][maxd2]) : 0.0);
	nHapDelta2[i] = ((LPd[maxd1] > LPstart + HLP_MINDELTA) ? 0.5*(delta1[I1][maxd1]+delta2[I2][maxd2]) : 0.0);

	/* initialize HapDeltaScore[i] */
	if(!HapDelta[i] && nHapDelta[i] && fabs(nHapDelta2[i]) < MIN_INDEL_SIZE)
	  HapDeltaScore[i] = LPindel[i] - LPstart;

	if(HAPSTOP_DEBUG && maxd1 >= 0 && (HAPSTOP_DEBUG>=2 || LPd[maxd1] > LPstart + LP_INDEL_MINDELTA)){
	  printf("i=%d:HapDelta[i]=%0.4f,Hcuts[i]=%0.3f,%0.3f,R=%d,Hcuts[i..R]=%0.4f->%0.4f:LP=%0.6f->%0.6f:ibest=%d(type=%d,LP=%0.6f) cum=%0.6f\n",
		 i, HapDelta[i], Hcuts[i], Hcuts[i] + DelCum[i], R,Hcuts[R]-Hcuts[i] + Delta[i], Hcuts[R]-Hcuts[i] + Delta[i] + nHapDelta2[i], 
		 LPstart, LPd[maxd1], ibest, tbest, LPbest, wtime());
	  fflush(stdout);
	}
	if(DEBUG) assert(maxd1 >= 0);

	/* update LPbest, ibest, tbest */
	if(LPd[maxd1] > LPstart + HLP_MINDELTA){
	  if(LPd[maxd1] > LPstart + LP_INDEL_MINDELTA){
	    if(maxd1 < DR1[I1]){
	      int biggestD = maxd1 % DELTA_RANGE[IN1];
	      for(int T = max(0,IN1-DELTA_SCAN); T <= IN1 + DELTA_SCAN && T <= maxIN; T++){
		if(DELTA_SCAN_FIX && biggestD1[T] < 0){
		  activecnt++;
		  if(DELTA_RANGE[T] <= 0){		      // copy Initial_Delta[T] from Initial_Delta[IN1]
		    newactivecnt++;
		    if(DEBUG) assert(T != IN1);
		    for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
		      Initial_Delta[T][k] = Initial_Delta[IN1][k];
		    // WAS50 biggestD1[T] = biggestD;
		  } // WAS50 else
		  biggestD1[T] = 0;// NOTE : exact value is determined below 
		  if(HAPSTOP_DEBUG){
		    if(DELTA_RANGE[T] > 0)
		      printf("Activating region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) with IDelta[%d]=%0.3f..%0.3f:HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(maxd1=%d,maxd2=%d),Hcuts[i]=%0.3f,%0.3f,Y1[I1..I1+1]=%0.3f..%0.3f: LP=%0.6f->%0.6f, DELTA_RANGE[T]=%d\n",
			     T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1, DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],
			     i, HapDelta[i], HapDelta[i] + nHapDelta[i], nHapDelta2[i], maxd1,maxd2, Hcuts[i], Hcuts[i]+DelCum[i], startY1[I1],startY1[I1+1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		    else
		      printf("Re-Activating region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) with IDelta[0]=%0.3f..:HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(maxd1=%d,maxd2=%d),Hcuts[i]=%0.3f,%0.3f,Y1[I1..I1+1]=%0.3f..%0.3f: LP=%0.6f->%0.6f, DELTA_RANGE[T]=%d\n",
			     T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1, Initial_Delta[T][0],
			     i, HapDelta[i], HapDelta[i] + nHapDelta[i], nHapDelta2[i], maxd1,maxd2, Hcuts[i], Hcuts[i]+DelCum[i], startY1[I1],startY1[I1+1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		    fflush(stdout);
		  }  
		}

		/* increase biggestD1[T], if needed, to match biggestD */
		if(DELTA_SCAN_FIX && T != IN1 && fabs(Initial_Delta[IN1][0] - Initial_Delta[T][0]) > MIN_DELTA * 0.001){
		  while(biggestD1[T] < localINITIAL_DELTA_RANGE - 1 && Initial_Delta[T][biggestD1[T]] + MIN_DELTA * 0.001 < Initial_Delta[IN1][biggestD])
		    biggestD1[T]++;
		} else if(biggestD > biggestD1[T])
		  biggestD1[T] = biggestD;

		if(DEBUG>=2) assert(0 <= biggestD1[T] && biggestD1[T] < localINITIAL_DELTA_RANGE && DELTA_RANGE[T] <= localINITIAL_DELTA_RANGE);
	      }
	    } // maxd1 < DR1[I1]

	    if(maxd2 < DR2[I2]){
	      int biggestD = maxd2 % DELTA_RANGE[IN2];
	      for(int T = max(0,IN2-DELTA_SCAN); T <= IN2 + DELTA_SCAN && T <= maxIN; T++){
		if(DELTA_SCAN_FIX && biggestD1[T] < 0){
		  activecnt++;
		  if(DELTA_RANGE[T] <= 0){		      // copy Initial_Delta[T] from Initial_Delta[IN2]
		    newactivecnt++;
		    if(DEBUG) assert(T != IN2);
		    for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
		      Initial_Delta[T][k] = Initial_Delta[IN2][k];
		    // WAS50 biggestD1[T] = biggestD;
		  } // WAS50 else
		  biggestD1[T] = 0;// NOTE : exact value is determined below 

		  if(HAPSTOP_DEBUG){
		    if(DELTA_RANGE[T] > 0)
		      printf("Activating region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) with IDelta[%d]=%0.3f..%0.3f:HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(maxd1=%d,maxd2=%d),Hcuts[i]=%0.3f,%0.3f,Y2[I2..I2+1]=%0.3f..%0.3f: LP=%0.6f->%0.6f, DELTA_RANGE[T]=%d\n",
			     T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2, DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],
			     i, HapDelta[i], HapDelta[i] + nHapDelta[i], nHapDelta2[i], maxd1,maxd2, Hcuts[i], Hcuts[i]+DelCum[i], startY2[I2],startY2[I2+1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		    else
		      printf("Re-Activating region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) with IDelta[0]=%0.3f..:HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(maxd1=%d,maxd2=%d),Hcuts[i]=%0.3f,%0.3f,Y2[I2..I2+1]=%0.3f..%0.3f: LP=%0.6f->%0.6f, DELTA_RANGE[T]=%d\n",
			     T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2, Initial_Delta[T][0],
			     i, HapDelta[i], HapDelta[i] + nHapDelta[i], nHapDelta2[i], maxd1,maxd2, Hcuts[i], Hcuts[i]+DelCum[i], startY2[I2],startY2[I2+1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		    fflush(stdout);
		  }  
		} else if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		  printf("Region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) active:biggestD1[T]=%d,HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y2[I2+]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			 T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2,biggestD1[T],i,HapDelta[i], HapDelta[i] + nHapDelta[i], nHapDelta2[i], maxd1,DR1[I1],maxd2,DR2[I2],
			 HapSite[i],Hcuts[i], Hcuts[i]+DelCum[i], startY2[I2+1]-startY2[I2], LPstart, LPd[maxd1], DELTA_RANGE[T]);
		  fflush(stdout);
		}

		/* increase biggestD1[T], if needed, to match biggestD */
		if(DELTA_SCAN_FIX && T != IN2 && fabs(Initial_Delta[IN2][0] - Initial_Delta[T][0]) > MIN_DELTA * 0.001){
		  while(biggestD1[T] < localINITIAL_DELTA_RANGE - 1 && Initial_Delta[T][biggestD1[T]] + MIN_DELTA*0.001 < Initial_Delta[IN2][biggestD])
		    biggestD1[T]++;
		} else if(biggestD > biggestD1[T])
		  biggestD1[T] = biggestD;
		if(DEBUG>=2) assert(0 <= biggestD1[T] && biggestD1[T] < localINITIAL_DELTA_RANGE && DELTA_RANGE[T] <= localINITIAL_DELTA_RANGE);
	      }
	    }
	  }

	  if(LPd[maxd1] > LPbest + 2e-9){
	    ibest = i;
	    Lbest = L;
	    Rbest = R;
	    LLbest = LL;
	    RRbest = RR;
	    tbest = 1;
	    LPbest = LPd[maxd1];
	  }
	  if(DEBUG) assert(ibest >= 1);
	}
      } // if(maxd1 >= 0 && maxd2 >= 0)
    } // if(HapSite[i] && (HINDEL_UPDATE || HapDelta[i]==0.0))

    /* next check changing Hcuts[i..i+1] by changing Delta[i], provided HapSite[i] != 0 */
    if(HapSite[i] && R <= n && DR1[I1] > 0 && DR2[I2] > 0){
      if(DEBUG>=2) assert(0 <= IN1 && IN1 <= maxIN);
      if(DEBUG>=2) assert(0 <= IN2 && IN2 <= maxIN);

      double LPd[INITIAL_DELTA_RANGE*2];
      int LPd2[INITIAL_DELTA_RANGE*2];/* LPd2[d1] is the corresponding d2 value with the best score */

      /* increase intervals Y1[I1..I1+1] and Y2[I2..I2+1] by same amount */
      int d1;/* index into delta1[I1][d1=0..min(D1[I1],D2[I2])-1] == delta2[I2][d2=0..min(D1[I1],D2[I2])-1] : 
		used to access indel LP values : (AminM2[m] <= I2 <= AmaxM2[m]) ? newLPdelta2[m][I2,d2] : startLPA2[m] */
      if(DEBUG>=2) assert(i < R && R <= n && HapSite[R]);

      for(d1 = 0; d1 < D1[I1]; d1++){
	LPd[d1] = LPstart - BigPen;/* bad value as default for unhandled cases */
	LPd2[d1] = -1;
      }

      for(d1 = 0; d1 < DR1[I1]; d1++){
	int d2 = min(d1,DR2[I2]-1);
	while(d2 < DR2[I2]-1 && delta1[I1][d1] - delta2[I2][d2] >= MIN_INDEL_SIZE)
	  d2++;
	while(d2 > 0 && delta2[I2][d2] - delta1[I1][d1] >= MIN_INDEL_SIZE)
	  d2--;
	if(DEBUG>=2) assert(0 <= d2 && d2 < DR2[I2]);
	if(!(fabs(delta1[I1][d1] - delta2[I2][d2]) < MIN_INDEL_SIZE))
	  continue;

	if(DEBUG>=2 && !(fabs(delta1[I1][d1] - delta2[I2][d2]) < MIN_INDEL_SIZE && D1[I1] >= DR1[I1] && D2[I2] >= DR2[I2]) ){
	  printf("d1=%d,d2=%d:I1=%d/%d,I2=%d/%d,DR1[I1]=%d,D1[I1]=%d,DR2[I2]=%d,D2[I2]=%d,delta1[I1][d1]=%0.6f,delta2[I2][d2]=%0.6f\n",
		 d1,d2,I1,startN1,I2,startN2,DR1[I1],D1[I1],DR2[I2],D2[I2],delta1[I1][d1],delta2[I2][d2]);
	  printf("i=%d,R=%d:Hcuts[i,R]=%0.3f,%0.3f,HapSite[i,R]=%d,%d,startN1=%d,startN2=%d\n",i,R,Hcuts[i],Hcuts[R],HapSite[i],HapSite[R],startN1,startN2);
	  for(int t = i; t < R; t++)
	    if(HapDelta[t] || Delta[t])
	      printf("  t=%d:HapDelta[t]=%0.3f,Delta[t]=%0.3f\n",t,HapDelta[t],Delta[t]);
	  for(int t = 0; t < DR1[I1]; t++)
	    printf("d1=%d:delta1[I1][d1]=%0.6f\n",t,delta1[I1][t]);
	  for(int t = 0; t < DR2[I2]; t++)
	    printf("d2=%d:delta2[I2][d2]=%0.6f\n",t,delta2[I2][t]);
	  fflush(stdout);
	  assert(fabs(delta1[I1][d1] - delta2[I2][d2]) < MIN_INDEL_SIZE && D1[I1] >= DR1[I1] && D2[I2] >= DR2[I2]);
	}

	if(range1 + delta1[I1][d1] < minKB || range2 + delta2[I2][d2] < minKB)
	  continue;

	LPd[d1] = rawLPstart + LPdd[d1][d2];

	LPd[d1] -= 0.5*(startN1+startN2)*SITE_PEN;
	LPd[d1] += logHapSitePvalue * startSNPcnt + logHapIndelPvalue * startIndelCnt;
	LPd2[d1] = d2;
      } /* d1 = 0 .. DR1[I1] -1 */

      /* locate best value LPd[d1 = 0..D1[I1]-1] and see if it is better than LPstart */
      int maxd1 = -1, maxd2 = -1;
      for(int d1 = 0; d1 < DR1[I1]; d1++)
	if(maxd1 < 0 || LPd[d1] > LPd[maxd1]){
	  maxd1 = d1;
	  maxd2 = LPd2[d1];
	}

      LPdelta[i] = LPstart;
      nDelta[i] = 0.0;
	  
      if(maxd1 >= 0 && maxd2 >= 0){// NEW93 : this can happen near ends (eg if I1==0 or I2==0 or I1==N1 or I2==N2) when only one allele can be adjusted (which is currently not supported)

	LPdelta[i] = max(LPd[maxd1],LPstart);
	nDelta[i] = (LPd[maxd1] > LPstart + HLP_MINDELTA) ? delta1[I1][maxd1] : 0.0;
	
	/* update LPbest, ibest, tbest */
	if(LPd[maxd1] > LPstart + HLP_MINDELTA){
	  if(LPd[maxd1] > LPstart + LP_INTERVAL_MINDELTA){
	    if(DEBUG) assert(maxd1 < DR1[I1]);
	    int biggestD = maxd1 % DELTA_RANGE[IN1];
	    for(int T = max(0,IN1-DELTA_SCAN); T <= IN1 + DELTA_SCAN && T <= maxIN; T++){
	      if(DELTA_SCAN_FIX && biggestD1[T] < 0){
		activecnt++;
		if(DELTA_RANGE[T] <= 0){		      // copy Initial_Delta[T] from Initial_Delta[IN1]
		  newactivecnt++;
		  if(DEBUG>=2) assert(T != IN1);
		  for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
		    Initial_Delta[T][k] = Initial_Delta[IN1][k];
		  // WAS50 biggestD1[T] = biggestD;
		} // WAS50 else
		biggestD1[T] = 0;// updated below

		if(HAPSTOP_DEBUG){
		  if(DELTA_RANGE[T] > 0)
		    printf("Activating region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) with IDelta[%d]=%0.3f..%0.3f due to Delta[i=%d]=%0.4f->%0.4f(maxd1=%d,maxd2=%d),Hcuts[i]=%0.3f,%0.3f,Y1[I1..I1+1]=%0.3f..%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			   T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1,DELTA_RANGE[T],Initial_Delta[T][0], Initial_Delta[T][DELTA_RANGE[T]-1],
			   i, Delta[i], Delta[i] + nDelta[i], maxd1,maxd2, Hcuts[i],Hcuts[i]+DelCum[i], startY1[I1],startY1[I1+1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		  else
		    printf("Re-Activating region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) with IDelta[0]=%0.3f.. due to Delta[i=%d]=%0.4f->%0.4f(maxd1=%d,maxd2=%d),Hcuts[i]=%0.3f,%0.3f,Y1[I1..I1+1]=%0.3f..%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
		           T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1, Initial_Delta[T][0],
			   i, Delta[i], Delta[i] + nDelta[i], maxd1,maxd2, Hcuts[i],Hcuts[i]+DelCum[i], startY1[I1],startY1[I1+1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		  fflush(stdout);
	        }
	      } else if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
	        printf("Region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) active:biggestD1[T]=%d,Delta[i=%d]=%0.4f->%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y1[I1+]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
		       T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1,biggestD1[T], i, Delta[i], Delta[i] + nDelta[i], maxd1,DR1[I1],maxd2,DR2[I2],
		       HapSite[i], Hcuts[i],Hcuts[i]+DelCum[i], startY1[I1+1]-startY1[I1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		fflush(stdout);
	      }

	      /* increase biggestD1[T], if needed, to match biggestD */
	      if(DELTA_SCAN_FIX && T != IN1 && fabs(Initial_Delta[IN1][0] - Initial_Delta[T][0]) > MIN_DELTA * 0.001){
		while(biggestD1[T] < localINITIAL_DELTA_RANGE - 1 && Initial_Delta[T][biggestD1[T]] + MIN_DELTA*0.001 < Initial_Delta[IN1][biggestD])
		  biggestD1[T]++;
	      } else if(biggestD > biggestD1[T])
		biggestD1[T] = biggestD;
	      if(DEBUG>=2) assert(0 <= biggestD1[T] && biggestD1[T] < localINITIAL_DELTA_RANGE && DELTA_RANGE[T] <= localINITIAL_DELTA_RANGE);
	    }

	    if(DEBUG>=2) assert(maxd2 < DR2[I2]);
	    biggestD = maxd2 % DELTA_RANGE[IN2];
	    for(int T = max(0,IN2-DELTA_SCAN); T <= IN2 + DELTA_SCAN && T <= maxIN; T++){
	      if(DELTA_SCAN_FIX && biggestD1[T] < 0){
		activecnt++;
		if(DELTA_RANGE[T] <= 0){		      // copy Initial_Delta[T] from Initial_Delta[IN2]
		  newactivecnt++;
		  if(DEBUG>=2) assert(T != IN2);
		  for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
		    Initial_Delta[T][k] = Initial_Delta[IN2][k];
		  // WAS50 biggestD1[T] = biggestD;
		} // WAS50 else
		biggestD1[T] = 0;// updated below

		if(HAPSTOP_DEBUG){
		  if(DELTA_RANGE[T] > 0)
		    printf("Activating region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) with IDelta[%d]=%0.3f..%0.3f due to Delta[i=%d]=%0.4f->%0.4f(maxd1=%d,maxd2=%d),Hcuts[i]=%0.3f,%0.3f,Y2[I2..I2+1]=%0.3f..%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			   T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2, DELTA_RANGE[T],Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],
			   i, Delta[i], Delta[i] + nDelta[i], maxd1,maxd2, Hcuts[i],Hcuts[i]+DelCum[i], startY2[I2],startY2[I2+1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		  else
		    printf("Re-Activating region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) with IDelta[0]=%0.3f.. due to Delta[i=%d]=%0.4f->%0.4f(maxd1=%d,maxd2=%d),Hcuts[i]=%0.3f,%0.3f,Y2[I2..I2+1]=%0.3f..%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			   T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2, Initial_Delta[T][0],
			   i, Delta[i], Delta[i] + nDelta[i], maxd1,maxd2, Hcuts[i],Hcuts[i]+DelCum[i], startY2[I2],startY2[I2+1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		  fflush(stdout);
		}
	      } else if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		printf("Region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) active:biggestD1[T]=%d,Delta[i=%d]=%0.4f->%0.4f(maxd1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y2[I2+]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
		       T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2,biggestD1[T],i, Delta[i], Delta[i] + nDelta[i], maxd1,DR1[I1],maxd2, DR2[I2],
		       HapSite[i],Hcuts[i],Hcuts[i]+DelCum[i], startY2[I2+1]-startY2[I2],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		fflush(stdout);
	      }

	      /* increase biggestD1[T], if needed, to match biggestD */
	      if(DELTA_SCAN_FIX && T != IN2 && fabs(Initial_Delta[IN2][0] - Initial_Delta[T][0]) > MIN_DELTA * 0.001){
		while(biggestD1[T] < localINITIAL_DELTA_RANGE - 1 && Initial_Delta[T][biggestD1[T]] + MIN_DELTA*0.001 < Initial_Delta[IN2][biggestD])
		  biggestD1[T]++;
	      } else if(biggestD > biggestD1[T])
		biggestD1[T] = biggestD;
	      if(DEBUG>=2) assert(0 <= biggestD1[T] && biggestD1[T] < localINITIAL_DELTA_RANGE && DELTA_RANGE[T] <= localINITIAL_DELTA_RANGE);
	    }
	  }
	  if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
	    printf("i=%d:Delta[i]= %0.4f -> %0.4f(maxd1=%d,d2=%d,D1[%d]=%d,D2[%d]=%d) : LP=%0.8f -> %0.8f (Hcuts[i]=%0.4f,%0.4f,Hcuts[i..R]=%0.4f,L=%d,R=%d),HapSite[L,i,R]=%d,%d,%d\n",
		   i,Delta[i], Delta[i] + nDelta[i], maxd1, maxd2,I1, D1[I1],I2,D2[I2], LPstart, LPd[maxd1], Hcuts[i],Hcuts[i]+DelCum[i],Hcuts[R]-Hcuts[i],L,R,HapSite[L],HapSite[i],HapSite[R]);
	    printf("\t ibest=%d(type=%d,LP=%0.8f), progress=%d(%d,%d), iter=%d(LPbest=%0.8f,tbest=%d),cum=%0.6f\n",
		   ibest,tbest,LPbest,progress,hapdeltacnt,deltacnt, iter,LPbest,tbest,wtime());
	    fflush(stdout);
	  }
	  if(LPd[maxd1] > LPbest + 2e-9){
	    ibest = i;
	    Lbest = L;
	    Rbest = R;
	    LLbest = LL;
	    RRbest = RR;
	    tbest = 2;
	    LPbest = LPd[maxd1];
	  }
	}
      } // if(maxd1 >= 0 && maxd2 >= 0)
    } // if(Hsizes && HapSite[i] ... )

LcheckbestB:
    if(TIME_VERBOSE){
      double wt = wtime();
      cumwt1 += wt - lastwt;
      lastwt = wt;
    }

   /* check if previous best improvment is far enough back that it can be confirmed as locally optimal */
   if(ibest >= 1 && (i >= imax || Hcuts[i] - Hcuts[(SNP_SCAN_FIX && !tbest) ? ibest : RRbest] >= HSCANRANGE*Xlambda)){
     changes[progress] = ibest;
     tchanges[progress++] = tbest;
     if(DEBUG) assert(tbest >= 1);// cannot be 0 (HapSite change)

     /* now make the change and validate the actual LP value */
     if(changecnt <= 0 || tbest >= 2 || fabs(HapDeltaMerged[ibest]+nHapDelta[ibest]) < MIN_INDEL_SIZE){/* no need to check phasing of new HaploType */
       double origHapDelta = HapDelta[ibest];
       double origDelta = Delta[ibest];
       /* need to save all HapDelta[LLbest .. RRbest-1] and Delta[LLbest .. RRbest-1] */
       int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
       memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
       memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
       memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));

       /* skip backup map1[],map2[], since neither hsetmap() nor haprobeval() will be checked */

       changecnt++;/* If changecnt was 0 : should be no need to confirm since this is the first change since mprobeval() was called */

       if(tbest==1){ /* first HapDelta change (to HapDelta[ibest]) in this iteration (or HapDelta[ibest] is being reset to 0) */
	 if(DEBUG>=2) assert(LPindel[ibest] > LPstart);
	 if(DEBUG>=2) assert(HapSite[ibest]);
	 if(DEBUG>=2) assert(isfinite(HapDeltaMerged[ibest]));

	 if(FVERB){
	   printf("Changing HapDelta[ib=%d]=%0.4f->%0.4f(tot=%0.4f->%0.4f),Delta[ib]=%0.4f->%0.4f,Hcuts[ib..%d]=%0.3f->%0.3f(LP=%0.6f->%0.6f):Hcuts[ib]=%0.3f,%0.3f,Hcuts[i=%d]=%0.3f,progress=%d(%d,%d),changes=%d,iter=%d,LL=%d,RR=%d,HapSite[LL,RR]=%d,%d\n", 
		  ibest, origHapDelta, origHapDelta+nHapDelta[ibest], HapDeltaMerged[ibest], HapDeltaMerged[ibest]+nHapDelta[ibest],
		  origDelta, origDelta+nHapDelta2[ibest], Rbest, Hcuts[Rbest]-Hcuts[ibest]+origDelta, Hcuts[Rbest]-Hcuts[ibest]+origDelta+nHapDelta2[ibest],
		  LPstart, LPindel[ibest], Hcuts[ibest], Hcuts[ibest]+DelCum[ibest], i, Hcuts[i], progress, hapdeltacnt, deltacnt, changecnt, iter,
		  LLbest,RRbest,HapSite[LLbest],HapSite[RRbest]);
	   fflush(stdout);
	 }

	 HapDelta[ibest] = origHapDelta + nHapDelta[ibest];
	 Delta[ibest] = origDelta + nHapDelta2[ibest];
	 if(HapDeltaSpread(n,LLbest,RRbest,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){/* Should never happen : give up */
	   changecnt--;
	
	   int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	   memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	   memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	   memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		

	   tbest = ibest = -1;
	   LPbest = LPstart;
	   if(TIME_VERBOSE){
	     double wt = wtime();
	     cumwt2 += wt - lastwt;
	     lastwt = wt;
	   }
	   continue;
	 }
	 if(TIME_VERBOSE){
	   double wt = wtime();
	   cumwt2 += wt - lastwt;
	   lastwt = wt;
	 }
	 correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,LLbest,RRbest,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);

       } else {/* change in Delta[ibest] */
	 if(DEBUG>=2) assert(tbest==2);
	 if(DEBUG>=2) assert(LPdelta[ibest] > LPstart);
	 if(FVERB){
	   printf("Changing Hcuts[%d..%d]= %0.4f -> %0.4f (LP= %0.6f -> %0.6f, delta=%0.8f) : i=%d,Hcuts[ibest]=%0.4f,%0.4f,Hcuts[Rbest]=%0.4f,%0.4f,Hcuts[i]=%0.3f\n\t\t HapDelta[ibest]=%0.4f,HapSite[ibest,Rbest]=%d,%d,progress=%d(%d,%d),changes=%d,iter=%d\n",
		  ibest,Rbest, Hcuts[Rbest]-Hcuts[ibest]+Delta[ibest], Hcuts[Rbest]-Hcuts[ibest]+Delta[ibest] + nDelta[ibest], LPstart, LPdelta[ibest], LPdelta[ibest]-LPstart, i, Hcuts[ibest], Hcuts[ibest]+DelCum[ibest], 
		  Hcuts[Rbest], Hcuts[Rbest] + DelCum[Rbest], Hcuts[i], HapDelta[ibest], HapSite[ibest], HapSite[Rbest], progress, hapdeltacnt, deltacnt, changecnt, iter);
	   fflush(stdout);
	 }

	 Delta[ibest] += nDelta[ibest];
	 if(HapDeltaSpread(n,LLbest,RRbest,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){/* Should never happen : give up */
	   changecnt--;

	   int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	   memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	   memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	   memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		

	   tbest = ibest = -1;
	   LPbest = LPstart;
	   if(TIME_VERBOSE){
	     double wt = wtime();
	     cumwt4 += wt - lastwt;
	     lastwt = wt;
	   }
	   continue;
	 }
	 if(TIME_VERBOSE){
	   double wt = wtime();
	   cumwt4 += wt - lastwt;
	   lastwt = wt;
	 }
	 correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,LLbest,RRbest,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);
       } // change in Delta[ibest]
       
       /* confirm change */
       if(tbest == 1){
	 if(TIME_VERBOSE){
	   double wt = wtime();
	   cumwt3 += wt - lastwt;
	   lastwt = wt;
	 }
	 hapdeltacnt++;
       }
       if(tbest == 2){
	 if(TIME_VERBOSE){
	   double wt = wtime();
	   cumwt5 += wt - lastwt;
	   lastwt = wt;
	 }
	 deltacnt++;
       }
     } else {/* changecnt >= 1 && tbest<=1 : need to check phasing of new HaploType it may interact with previous changes due to phase linkage */
       double origHapDelta = HapDelta[ibest];
       double origDelta = Delta[ibest];

       /* indel HaploType */
       if(DEBUG>=2) assert(tbest==1);
       if(DEBUG>=2) assert(nHapDelta[ibest] != 0.0);
       if(DEBUG>=2) assert(HapSite[ibest]);

       /* need to save all HapDelta[LLbest .. RRbest-1] and Delta[LLbest .. RRbest-1] */
       int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
       memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
       memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
       memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));

       /* recompute LP with HapDelta[ibest] = origHapDelta + nHapDelta[ibest] or -(origHapDelta + nHapDelta[ibest]) */
       HapDelta[ibest] = origHapDelta + nHapDelta[ibest];
       Delta[ibest] = origDelta + nHapDelta2[ibest];
       
       if(FVERB){
	 printf("Changing HapDelta[%d]=%0.4f -> %0.4f (tot=%0.4f -> %0.4f)(LP= %0.6f -> %0.6f, delta=%0.8f) Hcuts[%d..%d]=%0.4f->%0.4f,Hcuts[%d..%d]=%0.4f->%0.4f,Hcuts[%d]=%0.4f+-%0.4f:\n\t\t progress=%d(%d,%d),changes=%d,iter=%d,minKB=%0.3f,range1=%0.4f,range2=%0.4f\n",
		ibest, origHapDelta, origHapDelta + nHapDelta[ibest], HapDeltaMerged[ibest], HapDeltaMerged[ibest] + nHapDelta[ibest], LPstart,LPbest,LPbest-LPstart,
		ibest,Rbest,Hcuts[Rbest]-Hcuts[ibest]+origDelta, Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest], 
		LLbest,RRbest,Hcuts[RRbest]+DelCum[RRbest]-Hcuts[LLbest]-DelCum[LLbest],Hcuts[RRbest]+DelCum[RRbest]-Hcuts[LLbest]-DelCum[LLbest] + Delta[ibest]-origDelta,
		ibest, Hcuts[ibest] + DelCum[ibest], HapDelCum[i+1], progress, hapdeltacnt, deltacnt, changecnt, iter, minKB, range1,range2);
	 fflush(stdout);
       }

       if(HapDeltaSpread(n,LLbest,RRbest,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){/* can happen due to combination of two valid HapDelta changes */
	 changecnt--;

	 int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	 memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	 memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	 memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		

	 tbest = ibest = -1;
	 LPbest = LPstart;
	 if(TIME_VERBOSE){
	   double wt = wtime();
	   cumwt2 += wt - lastwt;
	   lastwt = wt;
	 }
	 continue;
       }
       if(TIME_VERBOSE){
	 double wt = wtime();
	 cumwt2 += wt - lastwt;
	 lastwt = wt;
       }
       correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,LLbest,RRbest,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);

       if(TIME_VERBOSE){
	 double wt = wtime();
	 cumwt3 += wt - lastwt;
	 lastwt = wt;
       }
       changecnt++;
       hapdeltacnt++;
     } /* changecnt >= 1 */
	
     /* reset LPbest, ibest, tbest */
     tbest = ibest = -1;
     LPbest = LPstart;

   } /* if(ibest >= 1 ...) :  previous best improvement rechecked/confirmed */
  }/* i = imin .. imax */

  if(TIME_VERBOSE){
    double wt = wtime();
    cumwt1 += wt-lastwt;
    printf("\t bestHapDelta: CPU=%0.6f, wall=%0.6f(wt1=%0.6f,w2=%0.6f,w3=%0.6f,w4=%0.6f,w5=%0.6f) cum=%0.6f\n",
	   mtime() - lastmt, cumwt1+cumwt2+cumwt3+cumwt4+cumwt5, cumwt1,cumwt2,cumwt3,cumwt4,cumwt5, wt);
    fflush(stdout);
  }	  
}

static void fastHapSite(const int iter, const int imin, const int imax, const int n,
		  const int startN1, const int startN2, 
			const int maxIN, const int DELTA_OVERSAMPLE, const int DELTA_SCAN, int *DELTA_RANGE, const int DELTA_INTERVALS, const double DELTA_INTERVAL, int &activecnt,
		  double **Initial_Delta,
		  int *ID1, int *ID2,
		  const int Filtered, const int Deresed,
		  const double HtrimL1, const double HtrimR1, const double HtrimL2, const double HtrimR2,
		  const int Lfrozen,
		  double *Hcuts, double *Hcuts1, double *Hcuts2, 
		  int *Hdel1, int *Hdel2,
		  int &N1, int &N2, double *Y1, double *Y2, double *startY1, double *startY2,
		  int *skip, int *HapSite, int *nHapSite, int *prevHapSite,
		  double *HapDelta, double *Delta, double *prevHapDelta, double *prevDelta, 
		  double *DelCum,
		  int *startHdel1, int *startHdel2, int *addid1, int *addid2, int addcnt1, int addcnt2, 
		  const double LPstart, const double BigPen,
		  double *LPsite,
		  double **LP,
		  double *HapSiteScore, double *SiteScore,
		  int *changes, int *tchanges, int &progress, int &changecnt, int &hapsitecnt,
		  double *spreadHapDelta, double *spreadDelta,
		  int **map1, int **map2, int **nmap1, int **nmap2, const int MD
)
{
  double LPbest = LPstart;/* best LP value so far since last change (at site ibest), during following main i=1..imax+1 loop */
  int ibest = -1, Lbest = -1, Rbest = -1;/* site i value corresponding to LPbest (and previous and next site with HapSite[] != 0) */
  int LLbest = -1, RRbest = -1;/* corresponding LL and RR values (see HINDEL_MERGE >= 2) */
  int tbest = -1;/* Type of LPbest : 0 == nHapSite[ibest] changed, 1 == nHapDelta[ibest] change, 2 == nDelta[ibest] change (non HaploType interval size change for Hcuts[ibest..ibest+1]) */
  int ileft = 0;

  /* Use the saved per map LP values to score HaploType changes */
  int I1 = 0, I2 = 0;/* Number of real sites encoutered on HaploType 1 and 2 respectively : used to access site deletion LP values I2 < DminM2[m] ? newLPd20[m] : newLPd2[m][min(DmaxM2[m],I2)] */
  int T1 = -1, T2 = -1;/* addloc2[T2] is last missing site encountered on HaploType 2 : used to access site addition LP values newLPa2[m][T2 < TminM2[m] ? TminM2[m] : min(TmaxM2[m],T2)] */
  double LPsnp[4];/* LPsnp[h=0..3] is used to save LP values for HapSite[i] = h */

  int lastibest = -1;

  double cumwt1 = 0.0;/* time to compute LPdd and find next best change */
  double cumwt2 = 0.0;/* time from LcheckbestA till end of loop */

  double lastwt = TIME_VERBOSE ? wtime() : 0.0;

  if(LEFTEXT_FIX){/* locate current leftmost non-Haplotype site */
    for(ileft = 1; ileft <= imax; ileft++)
      if(HapSite[ileft] == 3)
	break;
    
    if(SNP_TRACE){
      printf("ileft=%d, HapSite[ileft]=%d, Hcuts[ileft]= %0.4f\n",ileft,HapSite[ileft],Hcuts[ileft]);
      fflush(stdout);
    }
  }

  for(int i = 1; i <= imax+1; i++){// main i loop */
    int L,R;
    int LL = -1;/* previous site with HapSite[LL] == 3 (or 0 if none) */
    int RR = -1;/* next site with HapSite[RR] == 3 (or n+1 if none) */

    int IN1 = -1, IN2 = -1;
    if(i > imax){
      if(ibest >= 1)
	goto LcheckbestA;/* need to check last improvement */
      break;
    }

    I1 += 1 - startHdel1[i];
    I2 += 1 - startHdel2[i];

    if(startHdel1[i])
      if(T1 < addcnt1-1/*NEW10*/ && addid1[T1+1] == i)
	T1++;
    if(startHdel2[i])
      if(T2 < addcnt2-1/*NEW10*/ && addid2[T2+1] == i)
	T2++;
      
    if(i <= imin)
      continue;

    L = i - 1;/* previous site with HapSite[L] */
    while(L >= 1 && !HapSite[L])
      L--;
    R = i+1;/* next site with HapSite[R] */
    while(R <= n && !HapSite[R])
      R++;

    LL = i;
    while(LL >= 1 && HapSite[LL] != 3)
      LL--;
    RR = R;
    while(RR <= n && HapSite[RR] != 3)
      RR++;

    LPsite[i] = LPstart - BigPen;/* default value == no improvement possible */
    nHapSite[i] = HapSite[i];

    if(SNP_TRACE && i==SITE_ID){
      printf("i=%d:LPstart=%0.6f,HapSite[i]=%d,Hcuts[i]=%0.3f,skip[i]=%d,Filtered=%d,Deresed=%d\n",i,LPstart,HapSite[i],Hcuts[i],skip[i],Filtered,Deresed);
      fflush(stdout);
    }

    /* check adding/deleting sites at Hcuts[i] */

    if(skip[i])// skip sites in frozen region
      goto LcheckbestA;

    if(SKIPMAP_ADD>=2 && DELTA_STOP >= 2 && iter >= HMIN_ITER){/* skip sites that fall in inactive regions */
      int IN = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
      if(DEBUG/* HERE >=2 */) assert(0 <= IN && IN <= maxIN);
      if(DELTA_RANGE[IN] <= 0)
	goto LcheckbestA;
    }

    /* use previously computed LP[h=0..3][i] */
    for(int h = 0; h <= 3; h++)
      LPsnp[h] = LP[h][i] + LPstart;
 
    /* compute Pvalue of best HaploType hypothesis (1 or 2) vs best non-HaploType hypothesis (0 or 3) : do this before suppressing sites due to minKB, Filtered=1 or Deresed=1 */
    HapSiteScore[i] = max(LPsnp[1],LPsnp[2]) - max(LPsnp[0],LPsnp[3]);
    SiteScore[i] = LPsnp[3] - LPsnp[0];
    /* HERE HERE HERE : Save HapSiteRevScore[i] = LPsnp[1] - LPsnp[2] and use it to fix -HapSiteUnphased */

    // NOTE : most label OR SNP additions near another label have already been suppressed if HapSite[i]==0
    // NOTE : this is tricky to get right without unnecessarily block sites from being added : just rely on later merging of nearby sites with REMOVE_CLOSE_SITES

    if(SNP_DELAY && iter < SNP_ITER && !(HapSite[i]==1 || HapSite[i]==2)){
      if(Hcuts[i]-Hcuts[L] < SNP_DELTA_KB){
	if(SNP_DELAY>=2)
	  LPsnp[1] = LPsnp[2] = LPstart - BigPen;
	else {
	  if(HapSite[L] & 1){
	    LPsnp[1] = LPstart - BigPen;
	  }
	  if(HapSite[L] & 2)
	    LPsnp[2] = LPstart - BigPen;
	}
      }
      if(Hcuts[R]-Hcuts[i] < SNP_DELTA_KB){
	if(SNP_DELAY>=2)
	  LPsnp[1] = LPsnp[2] = LPstart - BigPen;
	else {
	  if(HapSite[R] & 1)
	    LPsnp[1] = LPstart - BigPen;
	  if(HapSite[R] & 2)
	    LPsnp[2] = LPstart - BigPen;
	}
      }
    }

    if(Filtered && (HapSite[i]==0 || HapSite[i]==3)) /* suppress adding new HapSite (1 or 2), but OK to change to 0 (or 3 if !Deresed) */
      for(int h = 1; h <= 2; h++)
	LPsnp[h] = LPstart - BigPen;
    if(Filtered && !(HapSite[i] & 1) &&  (Hcuts1[i] < HtrimL1 || Hcuts1[i] > Hcuts1[n+1] - HtrimR1)){/* suppress adding label to Allele1 in trimmed region */
      LPsnp[1] = LPstart - BigPen;
      LPsnp[3] = LPstart - BigPen;
    }	    
    if(Filtered && !(HapSite[i] & 2) && (Hcuts2[i] < HtrimL2 || Hcuts2[i] > Hcuts2[n+1] - HtrimR2)){/* suppress adding label to Allele2 in trimmed region */
      LPsnp[2] = LPstart - BigPen;
      LPsnp[3] = LPstart - BigPen;
    }	    
    if(Deresed /* WAS && HapSite[i] */)/* suppress any change other than changing to 0 */
      for(int h = 1; h <= 3; h++)
	if(h != HapSite[i])
	  LPsnp[h] = LPstart - BigPen;

    /* locate best LPsnp[h=0..3] and see if best h is different from HapSite[i] */
    if(1){
      int maxh = HapSite[i];
      if(DEBUG) assert(startN1 >= 1 && startN2 >= 1);
      for(int h = 0; h <= 3; h++){
	int newN1 = startN1 + (h & 1) - (HapSite[i] & 1);
	int newN2 = startN2 + (h >> 1) - (HapSite[i] >> 1);
	if(newN1 <= 0 || newN2 <= 0)
	  continue;/* make sure at least one label remains in each Allele */
	if(LPsnp[h] > LPsnp[maxh])
	  maxh = h;
      }
      LPsite[i] = LPsnp[maxh];
      nHapSite[i] = maxh;

      if(VERB>=3 && (i==99 || LPsite[i] > LPstart + HLP_MINDELTA)){
	printf("iter=%d:i=%d/%d(LL=%d,RR=%d):LPstart=%0.6f,LPbest=%0.6f,ibest=%d(LL=%d,RR=%d):maxh=%d,LPsite[i]=%0.6f:Hcuts[RRbest-i]=%0.3f/%0.3f\n",
	       iter,i,n,LL,RR,LPstart,LPbest,ibest,LLbest,RRbest,maxh,LPsite[i],Hcuts[i]-Hcuts[RRbest],HSCANRANGE*Xlambda);
	fflush(stdout);
      }

      /* update LPbest, ibest, tbest */
      if(LPsite[i] > LPstart + HLP_MINDELTA){
	if(DELTA_STOP){/* mark current interval as active for HapIndel changes */
	  if(DEBUG) assert(0 <= I1 && I1 <= startN1);
	  if(DEBUG) assert(0 <= I2 && I2 <= startN2);
	  IN1 = ID1[I1];
	  IN2 = ID2[I2];
	  if(DEBUG) assert(0 <= IN1 && IN1 <= maxIN);
	  if(DEBUG) assert(0 <= IN2 && IN2 <= maxIN);

	  int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

	  int Tmin = max(0, min(IN1,IN2)-DELTA_SCAN);
	  int Tmax = min(maxIN, max(IN1,IN2) + DELTA_SCAN);
	  if(Tmax > Tmin + 100){
	    printf("WARNING: single HapSite[%d]=%d -> %d (LP= %0.6f -> %0.6f) activating %d intervals (%d .. %d) out of %d:I1=%d,I2=%d,N1=%d,N2=%d,IN1=%d,IN2=%d\n", 
		   i,HapSite[i],maxh,LPstart,LPsite[i],Tmax-Tmin+1,Tmin,Tmax,maxIN+1,I1,I2,N1,N2,IN1,IN2);
	    fflush(stdout);
	  }

	  for(int T = Tmin; T <= Tmax; T++){
	    if(DELTA_RANGE[T] <= 0){
	      activecnt++;
	      DELTA_RANGE[T] = min_DELTA;
	      for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
		Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
	      if(HAPSTOP_DEBUG){
		printf("Re-Activating region T=%d (%0.3f..%0.3f,IN1=%d,IN2=%d,I1=%d,I2=%d) with IDelta[0]=%0.3f..:HapSite[i=%d]=%d->%d:LP=%0.6f->%0.6f Hcuts[i]=%0.3f(%0.3f),Y1[I1..I1+1]=%0.3f..%0.3f,Y2[I2..I2+1]=%0.3f..%0.3f\n",
		       T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,IN2,I1,I2,Initial_Delta[T][0],
		       i,HapSite[i],maxh, LPstart, LPsite[i],Hcuts[i],Hcuts[i]+DelCum[i],startY1[I1],startY1[I1+1],startY2[I2],startY2[I2+1]);
		fflush(stdout);
	      }
	    } else if(HAPSTOP_DEBUG>=2){
	      printf("Region T=%d (%0.3f..%0.3f,IN1=%d,IN2=%d,I1=%d,I=%d) already active with IDelta[%d]=%0.3f .. %0.3f:HapSite[i=%d]=%d->%d:Hcuts[i]=%0.3f(%0.3f),Y1[I1..I1+1]=%0.3f..%0.3f,Y2[I2..I2+1]=%0.3f..%0.3f\n",
		     T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,IN2,I1,I2,DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],
		     i,HapSite[i],maxh,Hcuts[i],Hcuts[i]+DelCum[i],startY1[I1],startY1[I1+1],startY2[I2],startY2[I2+1]);
	      fflush(stdout);
	    }
	  }
	}

	if((LPsite[i] > LPbest + 2e-9 ||
	    (LEFTEXT_FIX /* && LPsite[i] > LPstart + HLP_MINDELTA */ && i < ileft && ibest > 0 && Hcuts[i] - Hcuts[ibest] >= HSCANRANGE*Xlambda))
	   /* && !(SNP_TRACE && iter==ITER_ID && i <= 200)*/){
	  if(DEBUG) assert(!skip[i]);
	  ibest = i;
	  Lbest = L;
	  Rbest = R;
	  LLbest = LL;
	  RRbest = RR;
	  tbest = 0;
	  LPbest = LPsite[i];
	}
      }
    }
    /* End :  try adding/deleting SNP at site i */

  LcheckbestA:
    if(TIME_VERBOSE){
      double wt = wtime();
      cumwt1 += wt-lastwt;
      lastwt = wt;
    }
    if(VERB>=3 && ibest > lastibest && iter==2){
      printf("iter=%d:i=%d/%d: ibest=%d,imax=%d,RRbest=%d:Hcuts[i]= %0.4f, Hcuts[RRbest]= %0.4f (delta=%0.4f), HSCANRANGE*Xlambda= %0.4f\n",
		  iter,i,n,ibest,imax,RRbest,Hcuts[i],Hcuts[RRbest],Hcuts[i]-Hcuts[RRbest],HSCANRANGE*Xlambda);
      fflush(stdout);
      lastibest = ibest;
    }

    /* check if previous best improvment is far enough back that it can be confirmed as locally optimal */
    if(ibest >= 1 && (i >= imax || (Hcuts[i] - Hcuts[RRbest] >= HSCANRANGE*Xlambda && (!LEFTEXT_FIX || i >= ileft)))){
      changes[progress] = ibest;
      tchanges[progress++] = tbest;

      if(VERB>=3 && ibest==7746){
	printf("iter=%d:i=%d,imax=%d,ibest=%d,tbest=%d,Lbest=%d,Rbest=%d,LLbest=%d,RRbest=%d,changecnt=%d,LPbest=%0.6f,hapsitecnt=%d,cum=%0.6f\n",
		  iter,i,imax,ibest,tbest,Lbest,Rbest,LLbest,RRbest,changecnt,LPbest,hapsitecnt,wtime());
	fflush(stdout);
      }

      if(DEBUG) assert(tbest == 0);

      /* now make the change WITHOUT any validation with hprobeval() */

      if(changecnt <= 0 || nHapSite[ibest]==0 || nHapSite[ibest]==3){/* no need to check phasing of new HaploType */
	int origHapSite = HapSite[ibest];
	double origHapDeltaL = HapDelta[Lbest];/* original value of HapDelta[Lbest] before being merged with HapDelta[ibest] */
	double origDeltaL = Delta[Lbest];/* original value of Delta[Lbest] before being merged with Delta[ibest] */

	if(FAST_SNP_HSETMAP){/* need to save all HapDelta[LLbest .. RRbest-1] and Delta[LLbest .. RRbest-1] */
	  int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	  memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	  memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	  memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));
	}

	changecnt++;/* If changecnt was 0 : should be no need to confirm since this is the first change since mprobeval() was called */

	if(FVERB){
	  printf("Changing HapSite[%d]= %d -> %d (LP= %0.8f -> %0.8f) : i=%d,Hcuts[ibest]=%0.4f,%0.4f,Hcuts[i]=%0.4f, progress=%d,changes=%d,hapsitecnt=%d,iter=%d\n",
		 ibest,HapSite[ibest],nHapSite[ibest], LPstart, LPsite[ibest], i, Hcuts[ibest],Hcuts[ibest]+DelCum[ibest],Hcuts[i],progress,changecnt,hapsitecnt,iter);
	  if(FVERB/* HERE >=2 */)
	    printf("\t Lbest=%d,Rbest=%d,n=%d:Hcuts[Lbest]=%0.4f,Hcuts[Rbest]=%0.4f,Hcuts[n+1]=%0.4f,LLbest=%d,RRbest=%d,HapSite[%d,%d,%d,%d,%d]=%d,%d,%d,%d,%d,Delta[Lbest]=%0.4f,HapDelta[Lbest]=%0.4f\n",
		   Lbest,Rbest,n,Hcuts[Lbest],Hcuts[Rbest],Hcuts[n+1],LLbest,RRbest,LLbest,Lbest,ibest,Rbest,RRbest,HapSite[LLbest],HapSite[Lbest],HapSite[ibest],HapSite[Rbest],HapSite[RRbest],Delta[Lbest],HapDelta[Lbest]);
	  fflush(stdout);
	}

	HapSite[ibest] = nHapSite[ibest];
	if(HPROBEVAL_SPREAD <= 1 && HapSite[ibest] && !origHapSite){
	  if(Delta[Lbest] /* && Rbest <= n */){/* divide Delta[Lbest] across 2 intervals */
	    double scale = origDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
	    Delta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
	    Delta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
	    if(FVERB>=2){
	      printf("\t Splitting Delta[Lbest=%d]=%0.8f -> %0.8f + Delta[ibest=%d]=%0.8f (Hcuts[Lbest]=%0.8f,Hcuts[ibest]=%0.8f,Hcuts[Rbest=%d]=%0.8f)\n",
		     Lbest,origDeltaL,Delta[Lbest], ibest, Delta[ibest], Hcuts[Lbest],Hcuts[ibest],Rbest,Hcuts[Rbest]);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(fabs(Delta[Lbest] + Delta[ibest] - origDeltaL) < MIN_INDEL_SIZE);
	  }
	  if(HapDelta[Lbest] /* && Rbest <= n */){/* divide HapDelta[Lbest] across 2 intervals */
	    double scale = origHapDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
	    HapDelta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
	    HapDelta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
	    if(FVERB){
	      printf("\t Splitting HapDelta[Lbest=%d]=%0.8f -> %0.8f + HapDelta[ibest=%d]=%0.8f (Hcuts[Lbest]=%0.8f,Hcuts[ibest]=%0.8f,Hcuts[Rbest=%d]=%0.8f)\n",
		     Lbest,origHapDeltaL,HapDelta[Lbest], ibest, HapDelta[ibest], Hcuts[Lbest],Hcuts[ibest],Rbest,Hcuts[Rbest]);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(fabs(HapDelta[Lbest] + HapDelta[ibest] - origHapDeltaL) < MIN_INDEL_SIZE);
	  }
	  if(DEBUG && !(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) >= 0.0)){
	    printf("\nLbest=%d,ibest=%d,Rbest=%d,n=%d,HapSite[Lbest,ibest,Rbest]=%d,%d,%d,Hcuts[ibest]=%0.8f,Hcuts[Rbest]=%0.8f,Delta[ibest]=%0.8e,HapDelta[ibest]=%0.8e,minKB=%0.6f\n",
		   Lbest,ibest,Rbest,n,HapSite[Lbest],HapSite[ibest],HapSite[Rbest],Hcuts[ibest],Hcuts[Rbest],Delta[ibest],HapDelta[ibest],minKB);
	    printf("\n\t Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) = %0.8e, Hcuts[Rbest]-Hcuts[ibest]= %0.8e\n",
		   Hcuts[Rbest]-Hcuts[ibest]+Delta[ibest]-fabs(HapDelta[ibest]), Hcuts[Rbest]-Hcuts[ibest]);
	    printf("\n\t origDeltaL= %0.8f, origHapDeltaL= %0.8f\n", origDeltaL, origHapDeltaL);
	    fflush(stdout);
	    assert(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) >= -1e-10);
	  }
	  if(DEBUG && !(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) >= 0.0)){
	    printf("\nLbest=%d,ibest=%d,HapSite[Lbest,ibest]=%d,%d,Hcuts[Lbest]=%0.6f,Hcuts[ibest]=%0.6f,Delta[Lbest]=%0.6f,HapDelta[Lbest]=%0.6f,minKB=%0.6f\n",
		   Lbest,ibest,HapSite[Lbest],HapSite[ibest],Hcuts[Lbest],Hcuts[ibest],Delta[Lbest],HapDelta[Lbest],minKB);
	    fflush(stdout);
	    assert(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) >= -1e-10);
	  }
	}

	if(HPROBEVAL_SPREAD <= 1 && !HapSite[ibest]){
	  if(HapDelta[ibest]){/* Indel HapDelta[ibest] needs to be moved/merged with HapDelta[Lbest] */
	    HapDelta[Lbest] += HapDelta[ibest];
	    if(fabs(HapDelta[Lbest]) < MIN_INDEL_SIZE)
	      HapDelta[Lbest] = 0.0;
	    if(FVERB){
	      printf("\t Merging HapDelta[ibest=%d]=%0.4f with HapDelta[Lbest=%d]=%0.4f -> %0.4f\n",ibest,HapDelta[ibest],Lbest, origHapDeltaL, HapDelta[Lbest]);
	      fflush(stdout);
	    }
	    HapDelta[ibest] = 0.0;
	  }
	  if(Delta[ibest]){/* Delta[ibest] needs to be moved/merged with Delta[Lbest] */
	    Delta[Lbest] += Delta[ibest];
	    if(FVERB){
	      printf("\t Merging Delta[ibest=%d]=%0.4f with Delta[Lbest=%d]=%0.4f -> %0.4f\n",ibest,Delta[ibest],Lbest, origDeltaL, Delta[Lbest]);
	      fflush(stdout);
	    }
	    Delta[ibest] = 0.0;
	  }
	}

	if(FAST_SNP_HSETMAP){
	  int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	  if(err){
	    if(VERB/* HERE >=2 */){
	      printf("\t WARNING:hsetmap failed (eg when trying to divide an interval that is already close to minKB = %0.6f on one Allele)\n",minKB);
	      fflush(stdout);
	    }

	    int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	    memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		
	    if(DEBUG) assert(HapSite[ibest] == origHapSite);
	      
	    if(TIME_VERBOSE){
	      double wt = wtime();
	      cumwt2 += wt - lastwt;
	      lastwt = wt;
	    }
	    continue;
	  } // err from hsetmap()
	}

	/* confirm change : swap newLPA and bestLPA */
	hapsitecnt++;
      } else {/* changecnt >= 1 && tbest==0 : need to check phasing of new HaploType it may interact with previous changes due to phase linkage */
	int origHapSite = HapSite[ibest];
	double origHapDeltaL = HapDelta[Lbest];
	double origDeltaL = Delta[Lbest];

	if(FVERB){
	  printf("Changing HapSite[%d]=%d -> %d (LP = %0.6f -> %0.6f) : i=%d,Hcuts[ibest]=%0.3f,Hcuts[i]=%0.3f, progress=%d(%d),changes=%d,iter=%d:\n",
		 ibest,HapSite[ibest],nHapSite[ibest], LPstart, LPsite[ibest], i, Hcuts[ibest],Hcuts[i],progress,hapsitecnt,changecnt,iter);
	  fflush(stdout);
	}

	if(DEBUG>=1+RELEASE) assert(nHapSite[ibest] == 1 || nHapSite[ibest] == 2);

	/* recompute LP with HapSite[ibest] = nHapSite[ibest] */
	HapSite[ibest] = nHapSite[ibest];

	if(HPROBEVAL_SPREAD <= 1 && !origHapSite){
	  if(Delta[Lbest] /* && Rbest <= n */){/* divide Delta[Lbest] across 2 intervals */
	    double scale = origDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
	    Delta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
	    Delta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
	    if(FVERB>=2){
	      printf("\t Splitting Delta[Lbest=%d]=%0.8f -> %0.8f + Delta[ibest=%d]=%0.8f (Hcuts[Lbest]=%0.8f,Hcuts[ibest]=%0.8f,Hcuts[Rbest=%d]=%0.8f)\n",
		     Lbest,origDeltaL,Delta[Lbest], ibest, Delta[ibest], Hcuts[Lbest],Hcuts[ibest],Rbest,Hcuts[Rbest]);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(fabs(Delta[Lbest] + Delta[ibest] - origDeltaL) < MIN_INDEL_SIZE);
	  }
	  if(HapDelta[Lbest] /* && Rbest <= n */){
	    double scale = origHapDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
	    HapDelta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
	    HapDelta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
	    if(FVERB){
	      printf("\t Splitting HapDelta[Lbest=%d]=%0.8f -> %0.8f + HapDelta[ibest=%d]=%0.8f (Hcuts[Lbest]=%0.8f,Hcuts[ibest]=%0.8f,Hcuts[Rbest=%d]=%0.8f)\n",
		     Lbest,origHapDeltaL,HapDelta[Lbest], ibest, HapDelta[ibest], Hcuts[Lbest],Hcuts[ibest],Rbest,Hcuts[Rbest]);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(fabs(HapDelta[Lbest] + HapDelta[ibest] - origHapDeltaL) < MIN_INDEL_SIZE);
	  }
	  if(DEBUG && !(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) >= 0.0)){
	    printf("ibest=%d,Rbest=%d,HapSite[ibest,Rbest]=%d,%d,Hcuts[ibest]=%0.6f,Hcuts[Rbest]=%0.6f,Delta[ibest]=%0.6f,HapDelta[ibest]=%0.6f,minKB=%0.6f\n",
		   ibest,Rbest,HapSite[ibest],HapSite[Rbest],Hcuts[ibest],Hcuts[Rbest],Delta[ibest],HapDelta[ibest],minKB);
	    fflush(stdout);
	    assert(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) > -1e-10);
	  }
	  if(DEBUG && !(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) >= 0.0)){
	    printf("Lbest=%d,ibest=%d,HapSite[Lbest,ibest]=%d,%d,Hcuts[Lbest]=%0.6f,Hcuts[ibest]=%0.6f,Delta[Lbest]=%0.6f,HapDelta[Lbest]=%0.6f,minKB=%0.6f\n",
		   Lbest,ibest,HapSite[Lbest],HapSite[ibest],Hcuts[Lbest],Hcuts[ibest],Delta[Lbest],HapDelta[Lbest],minKB);
	    fflush(stdout);
	    assert(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) > -1e-10);
	  }
	}

	if(FAST_SNP_HSETMAP){	// NOTE there is a small chance minKB restriction is violated due to previous change being too close to current change
	  int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	  if(err){
	    if(VERB/* HERE >=2 */){
	      printf("\t hprobeval failed due to hsetmap\n");
	      fflush(stdout);
	    }
	    
	    int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	    memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		
	    if(DEBUG) assert(HapSite[ibest] == origHapSite);
	    
	    if(TIME_VERBOSE){
	      double wt = wtime();
	      cumwt2 += wt - lastwt;
	      lastwt = wt;
	    }
	    continue;
	  }
	}

	if(DEBUG) assert(HapSite[ibest] == nHapSite[ibest]);
	changecnt++;
	hapsitecnt++;
      } /* changecnt >= 1 */
	
      /* reset LPbest, ibest, tbest */
      tbest = ibest = -1;
      LPbest = LPstart;

      if(TIME_VERBOSE){
	double wt = wtime();
	cumwt2 += wt - lastwt;
	lastwt = wt;
      }
    } /* previous best improvement implemented without checking */
  }/* i = imin .. imax */

  if(TIME_VERBOSE){
    double wt = wtime();
    cumwt1 += wt-lastwt;
    printf("\t bestHapSite: wall=%0.6f(wt1=%0.6f,wt2=%0.6f)\n",cumwt1+cumwt2,cumwt1,cumwt2);
    fflush(stdout);
  }
}


__attribute__ ((noinline))
double HaploTypeR(int n, double *Hcuts, int *&HapSite, double *&HapDelta,/* complete Haplotype map pair specification : implies Hcuts1, Hcuts2, Y1, Y2, N1, N2, see hsetmap() */
		  int lc,/* If left end of Y is a linear chromosome end */
		  int rc,/* If right end of Y is a linear chromosome end */
		  int MD, /* number of maps */
		  int *MX, double **X, /* X[m=0..MD-1][j=0..MX[m]+1] : map sites */
		  int **map1, /* map1[m=0..MD-1][j=0..MX[m]+1] is original index in Hcuts1[0..n+1] of X[m][j], 
				 map1[MD][j=0..n+1] is index in Y1[0..N1+1] of Hcuts1[j] (not initialized) */
		  int **map2, /* map2[m=0..MD-1][j=0..MX[m]+1] is original index in Hcuts2[0..n+1] of X[m][j], 
				 map2[MD][j=0..n+1] is index in Y2[0..N2+1] of Hcuts2[j] (not initialized) */
		  int **mapK1, /* mapK1[m=0..MD-1][j=0..MX[m]+1] is original K index offset in Hcuts1[0..n+1] of X[m][j] */ 
		  int **mapK2, /* mapK2[m=0..MD-1][j=0..MX[m]+1] is original K index offset in Hcuts2[0..n+1] of X[m][j] */ 
		  Csetlimit *limit1,
		  Csetlimit *limit2,
		  double *TBmapWT, /* If != 0 : TBmapWT[m] is a the -TB based weight for map m to be applied when summing up the total log(LR+LRbias) value */
		  Ccontig *pcontig, /* pointer to contig with input map ids in contig->contig[0..MD].mapid, and initial pcontig->HapSite,pcontig->HapDelta (aliased as HapSite,HapDelta args)
				       Final refined Haplotype Information will be in pcontig->HapSite, pcontig->HapDelta, pcontig->HapSiteScore etc
				       and final map alignments to Hcuts[] in pcontig->sitecnt,pcontig->sitecntL (based on best scoring Allele for each map) */
		  int *skip, /* skip[1..n] : skip[i] > 0 if site Hcuts[i],HapSite[i] should not be changed (typically these sites have HapSite[i]== 0, or are in a frozen region) */
		  int& Lfrozen, int& Rfrozen /* refine() args : may change when Hcuts[] changes in repositionH() */
		  )
{
  if(VERB>=2){
    printf("HaploTypeR(): Lfrozen=%d,Rfrozen=%d,Lendi=%d,Rendi=%d,n=%d\n",Lfrozen,Rfrozen,Lendi,Rendi,n);
    fflush(stdout);
  }

  if(DEBUG>=3 && !(HapSite[0]==0 && HapSite[n+1] == 0)){
    printf("n=%d,HapSite[0]=%d,HapSite[n+1]=%d\n",n,HapSite[0],HapSite[n+1]);
    fflush(stdout);
    assert(HapSite[0]==0 && HapSite[n+1] == 0);
  }

  if(HINDEL_MERGE < 2){
    printf("HaploTypeR(): HINDEL_MERGE=%d no longer supported : Please use -HapIndelMerge\n",HINDEL_MERGE);
    fflush(stdout);exit(1);
  }
  if(!HINDEL){
    printf("HaploTypeR(): HINDEL=%d no longer supported : Please use non-zero HapIndelPvalue= %0.6e\n",HINDEL,HapIndelPvalue);
    fflush(stdout);exit(1);
  }
  if(HSIZES != 3){
    printf("HaploTypeR(): HSIZES=%d no longer supported : Please use non-zero HapIndelPvalue= %0.6e\n",HSIZES,HapIndelPvalue);
    fflush(stdout);exit(1);
  }

  if(DEBUG>=2){ /* make sure map[] and mapK[] are consistent */
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      /* check map1[m][J],mapK1[m][J] for consistency */
      int lastJ = -1, lasti = -1, lastk = -1;
      for(int J = 1; J <= M; J++){
	int i = map1[m][J];
	if(i < 0)
	  continue;
	int k = mapK1[m][J];
	if((DEBUG && !(0 <= k && k < i)) ){
          #pragma omp critical
	  {
	    printf("m=%d/%d:M=%d,J=%d,map1[m][J]=i=%d,mapK1[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
          }
        }
	if(lasti >= 0 && !(i-k > lasti)){
           printf("\nmap1:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,HapSite[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,HapSite[i],HapSite[i-k]);
	   if(VERB){
	     for(int j = 1; j <= M; j++){
	       int i = map1[m][j];
	       if(i < 0)
		 continue;
	       int k = mapK1[m][j];
	       printf("\t j=%d:map1[m][j]=%d,mapK1[m][j]=%d\n",j,i,k);
	     }
	   }
	   fflush(stdout);
	   assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }

      /* check map2[m][J],mapK2[m][J] for consistency */
      lastJ = lasti = lastk = -1;
      for(int J = 1; J <= M; J++){
	int i = map2[m][J];
	if(i < 0)
	  continue;
	int k = mapK2[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
          #pragma omp critical
	  {
	    printf("m=%d/%d:M=%d,J=%d,map2[m][J]=i=%d,mapK2[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
	  }
	}
	if(lasti >= 0 && !(i-k > lasti)){
	  printf("\nmap21:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,HapSite[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,HapSite[i],HapSite[i-k]);
	  if(VERB){
	    for(int j = 1; j <= M; j++){
	      int i = map2[m][j];
	      if(i < 0)
		continue;
	      int k = mapK2[m][j];
	      printf("\t j=%d:map2[m][j]=%d,mapK2[m][j]=%d\n",j,i,k);
	    }
	  }
	  fflush(stdout);
	  assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }
  }

  /* start of Haplotype only refinement function */

  // MDEBUG = 1;
  IntervalEps = IntervalEps1;
  HapIndelEps = HapIndelEps1;
  HapLabelEps = HapLabelEps1;

  if(DEBUG) assert(MIN_INDEL_SIZE > 0.0);

  int origglobalfallback = globalfallback;
  globalfallback = 0;

  double origminKB = minKB;
  int origZERO_MINKB = ZERO_MINKB;

  // NOTE : The following should not be needed but an assertion is triggered in hsetmap(), typically when a interval is split by a new HapSite, since we no longer require the opposite
  // Allele spacing to satisfy minKB.

  //  ZERO_MINKB = 0.001;// command line parameter
  minKB = ZERO_MINKB ? ZERO_MINKB /* WAS45 0.001 * PixelLen */ : rres * 0.500;/* score_init() will now compute the same value, when called before mprobeval() */

  //  double BigPen = 1000.0*log(10.0);
  double BigPen =  9999.0*log(10.0);// NEW70

  if(HEAP_MINIMIZE){/* (re)allocate newLPd[], newLPdPr[] etc inside iter loop */
    if(MDEBUG){
      delete [] newLPdPr[0];
      newLPdPr[0] = NULL;

      delete [] newLPaPr[0];
      newLPaPr[0] = NULL;
    }
    if(!VMEM_MINIMIZE){
      delete [] newLPd[0];
      newLPd[0] = NULL;

      delete [] newLPdeltaMem;
      newLPdeltaMem = NULL;
    }

    delete [] Dcum; 
    Dcum = NULL;

    NmaxLP = 0;
  }

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;
    printf("At start of HaploTypeR(): VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f\n", VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB);
    fflush(stdout);
  }

  pcontig->MapPhase = new double[MD];/* used to store Allele1 probability of each map */

  double *startLP = new double[MD];

  CdoubleBlock **pBlock1 = 0, **pBlock2 = 0;
  if(MPROBEVAL_LAZYRESTORE){
    pBlock1 = new CdoubleBlock*[MD*2];
    pBlock2 = &pBlock1[MD];
  }

  int *forcemap = new int[MD];/* used to allow use of oldLP during phase reversal checks */

  /* rescale each map X[m][] to minimize scaling error (to avoid spurious indels caused by mixtures of different sets of data with different -bpp scaling) */
  /* NOTE : this should also be done periodically during refinement (perhaps unless -Haplotype was specified) */
  /* HERE HERE */

  double *Delta = new double[n+2];/* change in interval sizes (non-Haplotype) */

  double *SiteScore = new double[n+2];/* difference in homozygous site vs no site */

  double *HapSiteScore = pcontig->HapSiteScore[0] = new double[n+2];
  double *HapDeltaScore = pcontig->HapDeltaScore[0] = new double[n+2];
  double *HapSitePhase = pcontig->HapSitePhase[0] = new double[n+2];
  double *HapDeltaPhase = pcontig->HapDeltaPhase[0] = new double[n+2];

  for(int i = 0; i <= n+1; i++)
    HapDeltaPhase[i] = HapDeltaScore[i] = Delta[i] = 0.0;
  for(int i = 0; i <= n+1; i++)
    HapSitePhase[i] = HapSiteScore[i] = SiteScore[i] = 0.0;
  if(DEBUG && !(HapSite[0]==0 && HapSite[n+1] == 0)){
    printf("n=%d,HapSite[0]=%d,HapSite[n+1]=%d\n",n,HapSite[0],HapSite[n+1]);
    fflush(stdout);
    assert(HapSite[0]==0 && HapSite[n+1] == 0);
  }

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;	
    printf("After Allocating pcontig->HapSiteScore[] etc & Delta[],SiteScore[]: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f\n", VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB);
    fflush(stdout);
  }

  /* Allocate memory for 2 sets of Hcuts[],Hdel[],Y[], map[], mapK[], nmap[], nmapK[], newLPA[], mapWT[], logPV[] */
  double *Hcuts1 = new double[n+2];
  double *Hcuts2 = new double[n+2];
  int *Hdel1 = new int[n+2];
  int *Hdel2 = new int[n+2];
  for(int i = 0; i <= n+1; i++){
    Hdel1[i] = (HapSite[i] & 1) ? 0 : 1;
    Hdel2[i] = (HapSite[i] & 2) ? 0 : 1;
  }
  double *Y1 = new double[n+2];
  double *Y2 = new double[n+2];

  int **origmap1 = new int*[MD];
  int **origmap2 = new int*[MD];

  int **origmapK1 = new int*[MD];
  int **origmapK2 = new int*[MD];
  int **nmap1 = new int*[MD+1];
  int **nmap2 = new int*[MD+1];
  int **nmapK1 = new int*[MD];
  int **nmapK2 = new int*[MD];

  /* global scratch space used by hprobeval() etc */
  tmpLPA1 = new double[MD];
  tmpLPA2 = new double[MD];
  map1a = new int*[MD+1];
  map2a = new int*[MD+1];
  mapK1a = new int*[MD];
  mapK2a = new int*[MD];
  if(HMAP_TMPFIX){
    map1b = new int*[MD+1];
    map2b = new int*[MD+1];
    mapK1b = new int*[MD];
    mapK2b = new int*[MD];
  }

  for(int m = 0; m < MD; m++){
    origmap1[m] = new int[MX[m]+2];
    origmap2[m] = new int[MX[m]+2];

    map1a[m] = new int[MX[m]+2];
    map2a[m] = new int[MX[m]+2];
    mapK1a[m] = new int[MX[m]+2];
    mapK2a[m] = new int[MX[m]+2];

    if(HMAP_TMPFIX){
      map1b[m] = new int[MX[m]+2];
      map2b[m] = new int[MX[m]+2];
      mapK1b[m] = new int[MX[m]+2];
      mapK2b[m] = new int[MX[m]+2];
    }

    origmapK1[m] = new int[MX[m]+2];
    origmapK2[m] = new int[MX[m]+2];

    nmap1[m] = new int[MX[m]+2];
    nmap2[m] = new int[MX[m]+2];
    nmapK1[m] = new int[MX[m]+2];
    nmapK2[m] = new int[MX[m]+2];
  }
  if(HMAP_TMPFIX){
    map1b[MD] = map1[MD];
    map2b[MD] = map2[MD];
  }
  nmap1[MD] = new int[n+3];
  *(nmap1[MD])++ = -1;
  nmap2[MD] = new int[n+3];
  *(nmap2[MD])++ = -1;
  double *mapWT1 = new double[MD];
  double *mapWT2 = new double[MD];
  double *bestLPA1 = new double[MD];
  double *bestLPA2 = new double[MD];
  double *startLPA1 = new double[MD];
  double *startLPA2 = new double[MD];
  double *newLPA = new double[MD];
  double *testLPA = new double[MD];
  double *newLPA1 = new double[MD];
  double *newLPA2 = new double[MD];
  double *testLPA1 = new double[MD];
  double *testLPA2 = new double[MD];
  double *logPV1 = new double[MD];
  double *logPV2 = new double[MD];
  int **outlier1 = new int*[MD];
  int **outlier2 = new int*[MD];
  for(int k = 0; k < MD; k++){
    outlier1[k] = new int[MX[k] + 2];
    outlier2[k] = new int[MX[k] + 2];
    for(int j = 0; j <= MX[k] + 1; j++)
      outlier1[k][j] = outlier2[k][j] = 0;
  }
  double *spreadHapDelta = NULL;/* see HPROBEVAL_SPREAD */
  double *spreadDelta = NULL;/* see HPROBEVAL_SPREAD */
  if(HPROBEVAL_SPREAD){
    spreadHapDelta = new double[n+2];
    spreadDelta = new double[n+2];
  }

  if(VERB>=2){
    printf("bestLPA1=%p..%p,bestLPA2=%p..%p,testLPA1=%p..%p,testLPA2=%p..%p\n newLPA1=%p..%p,newLPA2=%p..%p,startLPA1=%p..%p,startLPA2=%p..%p\n",
	   bestLPA1,&bestLPA1[MD-1],bestLPA2,&bestLPA2[MD-1],testLPA1,&testLPA1[MD-1],testLPA2,&testLPA2[MD-1],newLPA1,&newLPA1[MD-1],newLPA2,&newLPA2[MD-1],startLPA1,&startLPA1[MD-1],startLPA2,&startLPA2[MD-1]);
    fflush(stdout);
  }

  int numthreads = 1;
  #ifdef _OPENMP
  numthreads = MaxThreads; // WAS omp_get_max_threads();
  if(RefineThreads > 0)
    numthreads = min(numthreads,RefineThreads);
  if(DEBUG) assert(numthreads >= 1);
  #endif

  double origHapIndelPvalue = HapIndelPvalue;
  double origHapSitePvalue = HapSitePvalue;
  double initHapIndelPvalue = HapIndelPvalue;
  //  double initHapSitePvalue = HapSitePvalue;
  if(HINDEL_PHASED != 0.0 && (HINDEL_PHASED > origHapIndelPvalue || HSNP_PHASED > origHapSitePvalue)){
    initHapIndelPvalue = HapIndelPvalue = max(origHapIndelPvalue,HINDEL_PHASED);/* to allow exact HapDelta[] value to be computed before checking if HapIndelPvalue is satisfied */
    HapSitePvalue = max(origHapSitePvalue,HSNP_PHASED);
    if(VERB){
      printf("Changing initial HapIndelPvalue=%0.3e -> %0.3e, HapSitePvalue=%0.3e -> %0.3e\n",origHapIndelPvalue,HapIndelPvalue,origHapSitePvalue,HapSitePvalue);
      fflush(stdout);
    }
  }

  double *DelCum = new double[n+2];
  double *HapDelCum = new double[n+2];
  if(1){    /* compute DelCum[i+1] = Sum(Delta[0..i]) and HapDelCum[] */
    double DeltaCum = 0.0, HapDeltaCum = 0.0;
    HapDelCum[0] = DelCum[0] = 0.0;// NEW10
    for(int i = 0; i <= n; i++){
      HapDelCum[i+1] = HapDeltaCum += HapDelta[i];
      DelCum[i+1] = DeltaCum += Delta[i];
    }
  }

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;	
    printf("After Allocation of 2 sets of Hcuts[],Hdel[] ... map[] .. HapDelCum[]: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f\n", VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB);
    fflush(stdout);
  }

  int imin = max(1,Lendi), imax = (Rendi ? min(Rendi,n) : n);
  if(DEBUG) assert(extendonly <= 0);/* Haplotyping not supported with -extendonly */
  if(Rfrozen > 0 && Lfrozen < Rfrozen && extend <= 1){
    imin = max(1,Lfrozen);
    imax = min(n,Rfrozen);
  }
  // currently imin and imax are never changed : should gradually reduce the range as regions stabilize (or even better recursively call Haplotyper with narrower split ranges as in mprovevalwin())
  // However the ranges may widen after a phase change (with HapIndelPvalue change, for example, which can remove previously stable HapIndels)

  /* compute Hcuts1[],Hcuts2[] etc from Hcuts[] and HapDelta[] and HapSite[], then call hprobeval to compute initial LP */
  int N1,N2, SNPs,Indels;
  double mt0,wt0;
  if(VERB){
    mt0 = mtime();
    wt0 = wtime();
  }
    
  if(DEBUG>=2){/* check that all Delta[i] and HapDelta[i] values are zero if HapSite[i]==0 */
    for(int i = 1; i <= n; i++)
      if(!HapSite[i] && (Delta[i] || HapDelta[i])){
	printf("i=%d,n=%d:HapSite[i]=%d,Delta[i]=%0.10f,HapDelta[i]=%0.10f\n",i,n,HapSite[i],Delta[i],HapDelta[i]);
	fflush(stdout);
	assert(!(Delta[i] || HapDelta[i]));
      }
  }

  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
  if(!FILL_HMAP)
    cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
  //  rverb = 1;
  double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			 TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
  rverb = 0;

  if(VERB){
    double mt = mtime(),wt = wtime();
    printf("Initial hprobeval=%0.6f,SNPs=%d,Indels=%d,Y1[N1=%d]-Y1[1]= %0.3f, Y2[N2=%d]-Y2[1]= %0.3f, left=%0.4f(%0.4f),right=%0.4f(%0.4f): CPU=%0.6f,wall time=%0.6f(cum wall= %0.6f)\n",
	   hLP, SNPs, Indels, N1,Y1[N1]-Y1[1], N2,Y2[N2]-Y2[1], Hcuts[Lfrozen],Hcuts[Lfrozen]+DelCum[Lfrozen], Hcuts[Rfrozen ? Rfrozen : n+1],Hcuts[Rfrozen ? Rfrozen : n+1]+DelCum[(Rfrozen ? Rfrozen : n+1)],mt-mt0,wt-wt0,wt);
    //    fflush(stdout);exit(1);

    mt0 = mt;
    wt0 = wt;
    
    if(SNPs > 0 || Indels > 0){

      for(int i = imin; i <= imax; i++){
	if(!(HapSite[i] && (HapSite[i] <= 2 || HapDelta[i] || (i > 0 && HapDelta[i-1]))))
	  continue;

	if(HapDelta[i]){
	  int RR = i+1, LL = i;
	  while(RR <= n && HapSite[RR] != 3)
	    RR++;
	  while(LL >= 1 && HapSite[LL] != 3)
	    LL--;
	  double totHapDelta = 0.0, abssum = 0.0;
	  for(int t = LL; t < RR; t++){
	    totHapDelta += HapDelta[t];
	    abssum += fabs(HapDelta[t]);// NEW7
          }
	  double origHapDelta = totHapDelta;
	  if(abssum < MIN_INDEL_SIZE) {// NEW7
	    abssum = totHapDelta = 0.0;
	    for(int t = LL; t < RR; t++)
	      HapDelta[t] = 0.0;
	  }

	  printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f->%0.4f),Hcuts[i]=%0.4f,%0.4f,Hcuts[%d..%d]=%0.4f\n",
		 i,HapSite[i],HapDelta[i],origHapDelta,totHapDelta, Hcuts[i],Hcuts[i]+DelCum[i],LL,RR,Hcuts[RR]+DelCum[RR]-Hcuts[LL]-DelCum[LL]);
	} else {
	  if(DEBUG>=1+RELEASE/* HERE HERE >=2 */) assert(HapSite[i] && (HapSite[i] <= 2 || (i > 0 && HapDelta[i-1])));

	  int R = i+1,L = i-1;
	  while(R <= n && !HapSite[R])
	    R++;
	  while(L >= 1 && !HapSite[L])
	    L--;

	  printf("i=%d:HapSite[i]=%d,Hcuts[i]=%0.4f,%0.4f,Hcuts[%d..i]=%0.4f,Hcuts[i..%d]=%0.4f\n",
		 i,HapSite[i],Hcuts[i],Hcuts[i]+DelCum[i],L,Hcuts[i]+DelCum[i]-Hcuts[L]-DelCum[L],R,Hcuts[R]+DelCum[R]-Hcuts[i]-DelCum[i]);
	}
      }
    }

    fflush(stdout);
  }
  //  exit(1);

  if(DEBUG) assert(isfinite(hLP));

  int prevDELTA_X = DELTA_X;
  int prevDELTA_Y = DELTA_Y;
  int prevRANGE_Y = RANGE_Y;
  int prevRANGE = RANGE;

  int prevOutlierType = OutlierType;
  double prevOutlierLambda = outlierLambda;
  double prevPoutlier = Poutlier;
  double prevPoutlierEnd = PoutlierEnd;
  double prevLRbias = LRbias;
  double prevSF = SF[0];
  double prevSR = SR[0];

  // customize OutlierType=1,outlierLambda=0,RANGE=4 along with DELTA_X,RANGE_Y to improve performance/speed of mprobeval() for adding/deleting labels
  DELTA_X = origDELTA_X;
  DELTA_Y = origDELTA_Y;
  if(RANGE_UPDATE)
    RANGE = origRANGE;/* small value for speed */
  if(outlierLambdaSwitch)
    outlierLambda = outlierLambdaLabel;
  if(OutlierTypeSwitch){
    OutlierType = OutlierTypeLabel;
    if(OUTLIER_TYPE != OutlierType){
      printf("WARNING:OutlierTypeSwitch not working because OUTLIER_TYPE in RGentigScore.h is a compile time constant of %d\n",OUTLIER_TYPE);
      fflush(stdout);
      OutlierType = OUTLIER_TYPE;
    }
  }
  if(PoutlierSwitch)
    Poutlier = PoutlierLabel;
  if(PoutlierEndSwitch)
    PoutlierEnd = PoutlierEndLabel;
  if(LRbiasSwitch)
    LRbias = LRbiasLabel;
  if(MinSFSwitch)
    SF[0] = max(SF[0], MinSFLabel);
  if(MinSRSwitch)
    SR[0] = max(SR[0], MinSRLabel);
  if(ViterbiSwitch)
    HAP_VITERBI_WT = min(1.0, ViterbiLabel);

  RANGE_Y = RANGE_Y2;
  if(DELTA_LIM > 0) DELTA_X = DELTA_LIM;

  if(RANGE != prevRANGE || RANGE_Y != prevRANGE_Y || DELTA_X != prevDELTA_X || DELTA_Y != prevDELTA_Y || OutlierType != prevOutlierType || outlierLambda != prevOutlierLambda ||
     Poutlier != prevPoutlier || PoutlierEnd != prevPoutlierEnd || LRbias != prevLRbias || SF[0] != prevSF || SR[0] != prevSR || HAP_VITERBI_WT != origViterbi){
    //    rverb = 1;
    double qLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			   TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
    //    rverb = 0;
    if(VERB){
      printf("Switched RANGE=%d to %d,RANGE_Y=%d to %d,DELTA_X=%d to %d,OutlierType=%d to %d,Lambda=%0.2e->%0.2e,outlier=%0.2e->%0.2e,outlierEnd=%0.2e->%0.2e,LRbias=%0.2e->%0.2e,SF=%0.3f->%0.3f,SR=%0.3f->%0.3f,Vit -> %0.3f:LP=%0.10f -> %0.10f\n",
	     prevRANGE, RANGE, prevRANGE_Y, RANGE_Y, prevDELTA_X, DELTA_X, prevOutlierType, OutlierType, prevOutlierLambda, outlierLambda,prevPoutlier,Poutlier,prevPoutlierEnd,PoutlierEnd,
	     prevLRbias,LRbias,prevSF,SF[0],prevSR,SR[0],HAP_VITERBI_WT,hLP,qLP);
      fflush(stdout);
    }

    //    exit(1);

    if(VERB>=3){/* check effect of increasing RANGE on LP */
      int pRANGE = RANGE;
      int poutlierLambda = outlierLambda;
      int pOutlierType = OutlierType;
      int pRANGE_Y = RANGE_Y;

      outlierLambda = origOutlierLambda;
      OutlierType = 0;
      RANGE = 1;

      printf("Checking effect of RANGE = %d to %d with RANGE_Y=RANGE, OutlierType=%d,outlierLambda=%0.3e: wall time=%0.6f\n",RANGE,30,OutlierType,outlierLambda,wtime());
      fflush(stdout);

      double pLP = qLP;

      for(; RANGE <= 30; RANGE++){
	RANGE_Y = RANGE;
	double qLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	if(RANGE==2)
	  pLP = qLP2;

	printf("RANGE=%d: LP=%0.10f (delta=%0.10f): wall time=%0.6f\n",RANGE,qLP2,qLP2-pLP,wtime());
	fflush(stdout);
	pLP = qLP2;
      }

      outlierLambda = 1e+30;
      OutlierType = 1;
      RANGE = 1;

      printf("Checking effect of RANGE = %d to %d with RANGE_Y=0,OutlierType=%d,outlierLambda=%0.3e: wall time=%0.6f\n",RANGE,30,OutlierType,outlierLambda,wtime());
      fflush(stdout);

      for(; RANGE <= 30; RANGE++){
	RANGE_Y = 0;
	double qLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	if(RANGE==1)
	  pLP = qLP2;
	printf("RANGE=%d: LP=%0.10f (delta=%0.10f): wall time=%0.6f\n",RANGE,qLP2,qLP2-pLP,wtime());
	fflush(stdout);
	pLP = qLP2;
      }

      RANGE = pRANGE;
      RANGE_Y = pRANGE_Y;
      outlierLambda = poutlierLambda;
      OutlierType = pOutlierType;
    }

    if(DEBUG && rverb){/* check for large differences in startLPA1[],startLPA2[] vs bestLPA1[],bestLPA2[] */
      for(int m = 0; m < MD; m++){
	if(fabs(startLPA1[m]-bestLPA1[m]) > 1.0){
	  printf("m=%d:startLPA1[m]=%0.8f,bestLPA1[m]=%0.8f\n",m,startLPA1[m],bestLPA1[m]);
	  fflush(stdout);
	}
	if(fabs(startLPA2[m]-bestLPA2[m]) > 1.0){
	  printf("m=%d:startLPA2[m]=%0.8f,bestLPA2[m]=%0.8f\n",m,startLPA2[m],bestLPA2[m]);
	  fflush(stdout);
	}
      }
      assert(fabs(hLP-qLP) < 10.0);
    }
    
    hLP = qLP;

    /* copy startLPA[] to bestLPA[] */
    memcpy(bestLPA1,startLPA1,MD*sizeof(double));
    memcpy(bestLPA2,startLPA2,MD*sizeof(double));
  }

  localINITIAL_DELTA_RANGE = INITIAL_DELTA_RANGE;/* so HapIndelHiRes can change the value */
  if(1/* WAS50 !MaxInitialDelta */ ){
    if(Max_Initial_Delta)
      delete [] Max_Initial_Delta;
    Max_Initial_Delta = new double[INITIAL_DELTA_RANGE];

    double step = 1.0/(2 << MAX_DELTA_OVERSAMPLE);

    if(DEBUG/* HERE HERE >=2 */)
      for(int i = 0; i < INITIAL_DELTA_RANGE; i++)
	Max_Initial_Delta[i] = 0.0;

    for(int i = 0; i < INITIAL_DELTA_RANGE; i++){
      Max_Initial_Delta[i] = START_DELTA * pow(2.0, i * step);
      //      if(DEBUG) assert(Max_Initial_Delta[i] < 200.0);
      if(Max_Initial_Delta[i] > MaxHapDelta){// NEW50
	localINITIAL_DELTA_RANGE = min(localINITIAL_DELTA_RANGE, i+1);
	break;
      }
      if(VERB>=2){
	printf("Max_Initial_Delta[%d]= %0.4f\n", i, Max_Initial_Delta[i]);
        fflush(stdout);
      }
    }
    if(VERB && localINITIAL_DELTA_RANGE < INITIAL_DELTA_RANGE){
      printf("localINITIAL_DELTA_RANGE = %d -> %d (due to -MaxDelta %0.3f)\n",INITIAL_DELTA_RANGE,localINITIAL_DELTA_RANGE,MaxHapDelta);
      fflush(stdout);
    }
    if(VERB){
      printf("Max_Initial_Delta[0, %d]= %0.4f, %0.4f\n",localINITIAL_DELTA_RANGE-1,Max_Initial_Delta[0],Max_Initial_Delta[localINITIAL_DELTA_RANGE-1]);
      fflush(stdout);
    }
  }

  /* re-initialize global variables (in case refine() is called more than once) */
  int DELTA_OVERSAMPLE = MAX_DELTA_OVERSAMPLE;

  double DELTA_INTERVAL = SCANRANGE*Xlambda/* TRY Xlambda */;/* use uniform intervals of Hcuts[] to bin the Initial_Delta[] arrays */
  const int DELTA_INTERVALS = 2 + (int)floor((Hcuts[(Rfrozen ? Rfrozen : n+1)]-Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);
  // NOTE : DELTA_INTERVAL is adjusted as Hcuts[Rfrozen]-Hcuts[Lfrozen] changes, so entire range is covered
  if(VERB>=2){
    printf("Initialized DELTA_INTERVALS=%d,Hcuts[Lfrozen=%d,Rfrozen=%d]=%0.3f,%0.3f,DELTA_INTERVAL=%0.3f,SCANRANGE=%0.1f,Xlambda=%0.3f\n", 
	   DELTA_INTERVALS,Lfrozen,(Rfrozen ? Rfrozen : n+1),Hcuts[Lfrozen],Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL,SCANRANGE,Xlambda);
    fflush(stdout);
  }
  const int DELTA_SCAN = HapLocalScan;/* range of intervals over which changes in interval sizes may be inter-dependent (0 means each interval is independant) */
  double **Initial_Delta = new double*[DELTA_INTERVALS];
  double *Initial_Delta_Mem = new double[(size_t)DELTA_INTERVALS * (size_t)INITIAL_DELTA_RANGE];
  int *DELTA_RANGE = new int[DELTA_INTERVALS];
  int *biggestD1 = new int[DELTA_INTERVALS];
  for(int IN = 0; IN < DELTA_INTERVALS; IN++)
    biggestD1[IN] = -1;

  if(DEBUG){
    gDELTA_RANGE = DELTA_RANGE;
    gInitial_Delta = Initial_Delta;
  }

  for(int IN = 0; IN < DELTA_INTERVALS; IN++){
    DELTA_RANGE[IN] = localINITIAL_DELTA_RANGE;
    Initial_Delta[IN] = &Initial_Delta_Mem[(size_t)IN * (size_t)INITIAL_DELTA_RANGE];
    for(int i = 0; i < DELTA_RANGE[IN]; i++){
      Initial_Delta[IN][i] = Max_Initial_Delta[i];
      if(DEBUG>=1+RELEASE) assert(fabs(Initial_Delta[IN][i] < 1000.0));
    }
  }

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;	
    printf("After Allocation of Initial_Delta: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f\n", VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB);
    fflush(stdout);
  }

  /* Allocate two sets of D[],delta[][], addcnt, addloc[], LPdel[], LPadd[], LPdelta[] */
  double *LPdel1 = new double[n+1];
  int *ID1 = new int[n+1];

  char *deltamem = NULL;// NEW

  int *D1 = NULL;// WAS new int[n+1];
  int *DR1 = NULL; // WAS new int[n+1];
  double **delta1 = NULL;// WAS new double*[n+1];
  double **LPdelta1 = NULL; // WAS new double*[n+1];
  //  int deltasiz1 = (n+1)*(2*INITIAL_DELTA_RANGE + MAX_INDEL);
  double *delta1mem = NULL;// WAS new double[deltasiz1];
  double *LPdelta1mem = NULL;// new double[deltasiz1];

  double *LPadd1 = new double[n+1];
  int addcnt1 = 0;
  int *addid1 = new int[n+1];/* addid1[0..addcnt1-1] are valid */
  double *addloc1 = new double[n+1];

  double *LPdel2 = new double[n+1];
  int *ID2 = new int[n+1];

  int *D2 = NULL;// WAS new int[n+1];
  int *DR2 = NULL;// WAS new int[n+1];
  double **delta2 = NULL;// WAS new double*[n+1];
  double **LPdelta2 = NULL;// WAS new double*[n+1];
  //  int deltasiz2 = (n+1)*(2*INITIAL_DELTA_RANGE+MAX_INDEL);
  double *delta2mem = NULL;// WAS new double[deltasiz2];
  double *LPdelta2mem = NULL;// WAS new double[deltasiz2];

  double *LPadd2 = new double[n+1];
  int addcnt2 = 0;
  int *addid2 = new int[n+1];/* addid2[0..addcnt2-1] is valid */
  double *addloc2 = new double[n+1];

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;	
    printf("After Allocation of two sets of addloc[],LPdel,LPadd[] for n=%d: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f\n", n, VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB);
    fflush(stdout);
  }

  /* Allocate 2nd set of newLPd,newLPd0,newLPdPr,newLPa,newLPaPr,newLPdelta for 2nd Haplotype map */
  double **newLPd2 = NULL;
  double *newLPd20 = NULL;
  int **newLPdPr2 = NULL;
  int *DminM2 = NULL, *DmaxM2 = NULL;

  double **newLPa2 = NULL;
  int **newLPaPr2 = NULL;
  int MaxAddcnt2 = 0;
  int *TminM2 = NULL, *TmaxM2 = NULL;

  int *Dcum2 = NULL;
  double **newLPdelta2 = NULL;
  int MaxDelta2 = 0; // (2 * INITIAL_DELTA_RANGE + MAX_INDEL) * max(N1,N2) * 1.10;/* maximum value of sum(D2[i=1..N2-1]) */
  int *AminM2 = NULL, *AmaxM2 = NULL;
  double *newLPdeltaMem2 = NULL;

  size_t siz = ((size_t)MD) * (NmaxLP + 2ul);
  size_t tot = MD * (6 * sizeof(int) + sizeof(double*) + (MDEBUG ? sizeof(int*):0)) + siz * ((VMEM_MINIMIZE ? sizeof(double) : 0) + (MDEBUG ? sizeof(int):0));

  try {
    /* allocate initial memory for DminM2[] ... AmaxM2[] AND newLPd2[], newLPd20[], newLPdPr2[] */
    DminM2 = new int[MD*6];
    DmaxM2 = &DminM2[MD];
    TminM2 = &DminM2[MD*2];
    TmaxM2 = &DminM2[MD*3];
    AminM2 = &DminM2[MD*4];
    AmaxM2 = &DminM2[MD*5];
    newLPd2 = new double*[MD]; newLPd2[0] = NULL;
    newLPd20 = new double[MD];// NEW8
    if(NmaxLP > 0){
      if(MDEBUG) {
	newLPdPr2 = new int*[MD];
	newLPdPr2[0] = new int[siz];
	for(long long m = 1; m < MD; m++)
	  newLPdPr2[m] = newLPdPr2[0] + m * (NmaxLP + 2ll);
      }
      if(!VMEM_MINIMIZE){
        newLPd2[0] = new double[siz];
        for(long long m = 1; m < MD; m++)
	  newLPd2[m] = newLPd2[0] + m * (NmaxLP + 2ll);
      }
    }
  } catch (exception& e){
    cout << e.what() << endl;
    printf("refine(): exception thrown while allocating newLPd2[]:MaxAddcnt2=%d,n=%d,MaxDelta2=%d,MD=%d,N1=%d,N2=%d (%lu total bytes)\n",MaxAddcnt2,n,MaxDelta2,MD,N1,N2,tot);
    fflush(stdout);
    assert(0);
  }

  try {    /* allocate initial memory for newLPa2[],newLPaPr2[] */
    newLPa2 = new double*[MD];
    newLPa2[0] = 0;
    if(MDEBUG) newLPaPr2 = new int*[MD];
    if(MDEBUG) newLPaPr2[0] = 0;
  } catch (exception& e){
    cout << e.what() << endl;
    printf("refine(): exception thrown while allocating newLPa2[]:MaxAddcnt2=%d,n=%d,MaxDelta2=%d,MD=%d,N1=%d,N2=%d\n",MaxAddcnt2,n,MaxDelta2,MD,N1,N2);
    fflush(stdout);
    assert(0);
  }

  try {    /* allocate initial memory for newLPdelta2[][] */
    newLPdelta2 = new double*[MD];
    if(NmaxLP > 0)
      Dcum2 = new int[NmaxLP+2];
  } catch (exception& e){
    cout << e.what() << endl;
    printf("refine(): exception thrown while allocating newLPdelta2[]:MaxAddcnt2=%d,n=%d,MaxDelta2=%d,NmaxLP=%d,MD=%d,N1=%d,N2=%d\n",MaxAddcnt2,n,MaxDelta2,NmaxLP,MD,N1,N2);
    fflush(stdout);
    assert(0);
  }

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;	
    printf("After Allocation of 2nd set of newLPd,...newLPdelta: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f\n", VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB);
    fflush(stdout);
  }

  if(VERB/* >=2 */){
    printf("Initial MaxAddcnt2=%d,n=%d,MaxDelta2=%d,NmaxLP=%d,MD=%d,N1=%d,N2=%d\n",MaxAddcnt2,n,MaxDelta2,NmaxLP,MD,N1,N2);
    fflush(stdout);
  }

  double *LPsite = new double[n+2];/* LPsite[i] is LP value of HapSite[i] changed to nHapSite[i] (with all other HapSite[],HapDelta[] values unchanged) */
  double *LPindel = new double[n+2];/* LPindel[i] is LP value with HapDelta[i] changed to nHapDelta[i] (with all other HapSite[],HapDelta[] values unchanged) */
  double *LPdelta = new double[n+2];
  int *nHapSite = new int[n+2];/* best candidate value for HapSite[] during current iteration */
  double *HapDeltaMerged = new double[n+2];/* totHapDelta[i] is the sum of HapDelta[L..R-1], where the range L..R is the smallest range that include i..i+1 and HapSite[L,R]==3 */
  double *nHapDelta = new double[n+2];/* change in HapDelta[] during current iteration */
  double *nHapDelta2 = new double[n+2];/* change in Delta[] during current iteration that goes along with HapDelta[] */
  double *nDelta = new double[n+2];/* change in Delta[] during current iteration (with no change in HapDelta[]) */
  int *changes = new int[n+2]; /* i values of locally best changes found so far */
  int *tchanges = new int[n+2];/* type of locally best changes found so far (0 == change HapSite[i], 1 == change HapDelta[i]) */

  /* allocate memory to hold LPdd[d1=0..2*INITIAL_DELTA_RANGE+MAX_INDEL-1][d2=0..2*INITIAL_DELTA_RANGE+MAX_INDEL-1] the predicted change in LP for intervals starting at Hcuts[i] */
  double **LPdd = 0;
  double **LPddmemp = 0;
  double *LPddmem = 0;
  const size_t dsize = 2*INITIAL_DELTA_RANGE + MAX_INDEL+1;
  const size_t dmemsiz = dsize*dsize*(sizeof(int)*2 + sizeof(double)*3*numthreads) + (2 + 3*numthreads)*VALIGN;
  char *dmem = NULL;  POSIX_MEMALIGN(dmem, VALIGN, dmemsiz);
  size_t dcnt = 0;
  int *d1List = (int *)&dmem[dcnt]; dcnt += (dsize*dsize*sizeof(int) + VALIGN-1) & ~(VALIGN-1);
  int *d2List = (int *)&dmem[dcnt]; dcnt += (dsize*dsize*sizeof(int) + VALIGN-1) & ~(VALIGN-1);
  double *pvLP1 = (double *)&dmem[dcnt]; dcnt += ((dsize*dsize*sizeof(double) + VALIGN-1) & ~(VALIGN-1)) * numthreads;
  double *pvLP2 = (double *)&dmem[dcnt]; dcnt += ((dsize*dsize*sizeof(double) + VALIGN-1) & ~(VALIGN-1)) * numthreads;
  double *prLP = (double *)&dmem[dcnt]; dcnt += ((dsize*dsize*sizeof(double) + VALIGN-1) & ~(VALIGN-1)) * numthreads;
  if(DEBUG) assert(dcnt <= dmemsiz);

  double ***LPddT = new double**[numthreads];/* LPddT[tid][d1][d2] is the per thread version of LPdd[d1][d2] */
  const size_t threadpsize = (dsize + 7) & ~7;// round up pointer arrays to nearest cache line size (8 pointers = 64 bytes)
  const size_t threadsize = (dsize * dsize + 511) & (~511);// round up each thread's memory to nearest page size (512 doubles = 4096 bytes)
  if(HINDEL_FAST){
    //    POSIX_MEMALIGN(LPddmemp, 64, (numthreads+1) * threadpsize * sizeof(double*));
    //    POSIX_MEMALIGN(LPddmem, 4096, (numthreads+1) * threadsize * sizeof(double));
    LPddmemp = new double*[(numthreads+1) * threadpsize];
    LPddmem = new double[(numthreads+1) * threadsize];
    LPdd = &LPddmemp[1];
    for(int tid = 0; tid < numthreads; tid++)
      LPddT[tid] = &LPddmemp[1 + (tid + 1) * threadpsize];
  }

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;	
    printf("After Allocation of LPdd[][]: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f\n", VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB);
    fflush(stdout);
  }

  /* allocate memory that is initialized at the start of the iter=0..999 loop below : used for fast computation of prediction change in LP from changing HapSite[] */
  int *delid1 = 0;/* i = delid1[I1=1..N1] points to site Hcuts[i] that corresponds to Y1[I1] */
  int *delid2 = 0;/* i = delid2[I2=1..N2] points to site Hcuts[i] that corresponds to Y2[I2] */
  double **delmemp = 0, *delmem = 0;
  long long delmemsiz = 0;
  double **LP = 0;/* LP[h=0..3][i=imin..imax] are the LP for Haplotype 1 & 2 when HapSite[i] is changed to h : contribution from all maps is included */
  double ***LPT = new double**[numthreads];/* LPT[tid][h][i] is the per thread version of LP[h][i] */
  double ***LP1mT = new double**[numthreads];/* LP1mT[tid][h1=0..1][i=imin..imax] is the LP for HaploType 1 when (HapSite[i]&1) is changed to h1 : only contribution of a single map m is included */
  double ***LP2mT = new double**[numthreads];/* LP2mT[tid][h2=0..1][i=imin..imax] is the LP for HaploType 2 when (HapSite[i]>>1) is changed to h2 : only contribution of a single map m is included */

  if(HSNP_FAST){
    delid1 = new int[n+1];
    delid2 = new int[n+1];
    delmemp = new double*[numthreads * 8];
    if(!HEAP_MINIMIZE){
      delmem = new double[numthreads * 8ul * (n + 1ul)];

      for(int tid = 0; tid < numthreads; tid++){
	LPT[tid] = &delmemp[tid*8];
	LP1mT[tid] = &delmemp[tid*8 + 4];
	LP2mT[tid] = &delmemp[tid*8 + 6];
	for(int h = 0; h <= 3; h++)
	  LPT[tid][h] = &delmem[(tid * 8ul + h) * (n + 1ul)];
	for(int h = 0; h <= 1; h++){
	  LP1mT[tid][h] = &delmem[(tid*8ul + 4 + h) * (n + 1ul)];
	  LP2mT[tid][h] = &delmem[(tid*8ul + 6 + h) * (n + 1ul)];
	}
      }  
      LP = LPT[0];
    }
  }

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;	
    printf("After Allocation of LPT*[tid][], delid1[],delid2[]: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f\n", VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB);
    fflush(stdout);
  }

  double *startHapDelta = new double[n+2];
  double *startDelta = new double[n+2];
  double *startHcuts1 = new double[n+2];
  double *startHcuts2 = new double[n+2];
  int *startHdel1 = new int[n+2];
  int *startHdel2 = new int[n+2];
  double *startY1 = new double[n+2];
  double *startY2 = new double[n+2];

  int totchangecnt = 0;

  double newLP = hLP;

  double logH = -log(2.0);
  double logHapSitePvalue = log(max(HapSitePvalue, 1e-300));
  double logHapIndelPvalue = log(max(HapIndelPvalue, 1e-300));

  Lrange = LRANGE_HINIT;/* increase LRANGE so it can be used during SNP/indel validation */

  int reversalcnt = 0;/* number of times we tried phase reversal : limited to HREVERSAL times to avoid potential infinite loop */
  int lastiter = -1;/* last iteration in which we made progress */
  int SNPfail = 0;/* Number of iterations for SNPs with no progress */
  int SNPskip = 0;/* number of iterations that SNPs have been skipped */

  int miniter = HMIN_ITER + 2*(HapIndelHiRes-1+MAX_DELTA_OVERSAMPLE);
  int maxiter = !RefineFix ? 1000 : miniter + ITER_INC + max(N1,N2) * ITER_FRAC;

  if(Refine <= 1)
    maxiter = 0;
  if(VERB){
    printf("miniter= %d, maxiter= %d, HMIN_ITER=%d,SWITCH_ITER=%d,HapIndelHiRes=%d,MAX_DELTA_OVERSAMPLE=%d,N1=%d,N2=%d,HINDEL_REVERSE=%d\n", 
	   miniter, maxiter, HMIN_ITER, HMIN_ITER + 2*(MAX_SWITCH_ITER - 1), HapIndelHiRes,MAX_DELTA_OVERSAMPLE,N1,N2,HINDEL_REVERSE);
    fflush(stdout);
  }

  CLabel *Label = new CLabel[n+2];/* see HINDEL_MERGE */
  int *Index = new int[n+2];
  int *Hremap = new int[n+2];// used by repositionH() and HapDeltaSpread()
  double *prevHapDelta = new double[n+2];
  double *prevDelta = new double[n+2];
  int *prevHapSite = new int[n+2];

  double *origHapDelta = NULL;
  double *origDelta = NULL;
  int *origHapSite = NULL;
  // WAS92  if(FAST_HPROBEVAL >= 4) {
  origHapDelta = new double[n+2];
  origDelta = new double[n+2];
  origHapSite = new int[n+2];

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;	
    printf("After Allocation of Label[],Index[],Hremap[] etc: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f\n", VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB);
    fflush(stdout);
  }

  // Allocate memory for filtering unphased SNPs and Hap Indels and SNPs with unbalanced Allele ratio
#ifndef ASAN
  double *covA = new double[13*(n+2) + MD];
  double *covB = &covA[n+2];
  double *covC = &covA[2*(n+2)];
  double *SNRwtsum = &covA[3*(n+2)];/* sum of map weights */
  double *SNRsum = &covA[4*(n+2)];/* sum of log(SNR) values aligned to each label in Hcuts[1..n] */
  double *IcovA = &covA[5*(n+2)];/* weighted coverage between non-SNP labels only */
  double *IcovB = &covA[6*(n+2)];
  double *IoutA = &covA[7*(n+2)];
  double *IoutB = &covA[8*(n+2)];
  double *varA = &covA[9*(n+2)];/* weighted variance between non-SNP labels only */
  double *varB = &covA[10*(n+2)];
  double *meanA = &covA[11*(n+2)];
  double *meanB = &covA[12*(n+2)];
  double *MapWeight = &covA[13*(n+2)];
#else 
  double *covA = new double[n+2];
  double *covB = new double[n+2];
  double *covC = new double[n+2];
  double *SNRwtsum = new double[n+2];
  double *SNRsum = new double[n+2];
  double *IcovA = new double[n+2];
  double *IcovB = new double[n+2];
  double *IoutA = new double[n+2];
  double *IoutB = new double[n+2];
  double *varA = new double[n+2];
  double *varB = new double[n+2];
  double *meanA = new double[n+2];
  double *meanB = new double[n+2];
  double *MapWeight = new double[MD];
#endif

  if(TIME_VERBOSE){
    getmem(VmSize,VmRSS, VmSwap);
    double InvGB = 1e-9;	
    printf("After Allocation of covA[],covB[],covC[] etc: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: wtime= %0.6f\n", VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB,wtime());
    fflush(stdout);
  }

  gIndex = Index;// for debugging

  for(int i = 0; i <= n+1; i++)
    HapDeltaMerged[i] = 0.0;

  double LPhwm = -BigPen;/* keep track of LP value during iterations with HINDELITER(iter) and make sure the value keeps increasing (except when changing Pvalues or after Final Switch) */
  int LPdrop_count = 0;
  int Filtered = 0;/* set to 1 after HapIndels & HapSites have been filtered and only sizing changes are allowed */
  int Deresed = 0;/* increment after applying rres/cres filter  */
  
  int HapIndelDelSkipcnt = 0;
  int HapUpdatemapSkipcnt = 0;

  int SwitchFade = 0; /* When set to 1, stop applying *Switch options */

  /* Amount of trimmed length at ends of each Allele (see -HapEndTrim) : no new labels may be added in these regions */
  double HtrimL1 = 0.0, HtrimR1 = 0.0, HtrimL2= 0.0, HtrimR2 = 0.0;

  int hapsitecnt = 0;/* number of changes above LP_SITE_MINDELTA suggested for HapSite[] (for this value of iter) */
  int hapdeltacnt = 0;/* number of changes above LP_INDEL_MINDELTA suggested for HapDelta[] (for this value of iter) */
  int deltacnt = 0;/* number of changes suggested above LP_INTERVAL_MINDELTA for Delta[] (for this value of iter) */

  int HapIndelDelIter = 0;// last iteration during which deletion of Hap Indels was performed 
  int HapSiteScoreIter = 0;// laster iteration during which HapSiteScore[] was computed

  int SNPverbose = 0;// for debugging : forces display of all HapSiteScore[i] values computed by mprobeval() if recheck of HapSiteScore[i] in last iterations showed -ve values

  int HapSizeOnlyCnt = 0;// Number of consecutive iterations with only Delta[] changes (no HapDelta[],HapSite[] changes)

  int SNPIterCnt = 0;/* number of SNP Iterations completed (excluding current iteration) */
  int IndelIterCnt = 0;/* number of Indel Iterations completed (excluding current iteration) */

  int iter = (SNPs > 0 || Indels > 0) ? FAST_SNPS_STARTUP : 0;// speed up if SNPs/Indels are already present
  int startiter = iter;

  int origSKIPMAP_ADD = SKIPMAP_ADD;

  int checkHapSite = 0;// Will be set to 1 IFF the current iteration is used only to compute HapSiteScore[] and then jump to LcheckHapSite
  int checkHapSiteMaxIter = 0;// Only valid if checkHapSite == 1 : this is the value of maxiter that will be restored after jumping to LcheckHapSite
  int ForceUnphased = 0;// Only valid if checkHapSite == 1 : this value is 1 IFF the Unphased SNP checking would have been called in the last iteration, but for this interruption to compute HapSiteScore[]
  int UnphasedCnt = 0;// number of times Unphased SNP checking was actually performed

  double *LPd = new double[INITIAL_DELTA_RANGE*2];/* LPd[d1 = 0..D1[I1]-1] */
  int *LPd2 = new int[INITIAL_DELTA_RANGE*2];/* LPd2[d1] is the corresponding d2 value with the best score */

  for(; iter < maxiter; iter++){ /* repeatedly update HaploType to improve LP, until no further progress is possible */

    /*    if(iter > 38){
      printf("iter=%d : DEBUG : terminating refinement\n",iter);
      fflush(stdout);
      break;
      }*/
    
    if(iter > startiter){
      if(HINDELITER(iter-1))
	IndelIterCnt++;
      else
	SNPIterCnt++;
    }

    SKIPMAP_ADD = origSKIPMAP_ADD;

    //    if(iter >= 1) break;

    if(VERB>=4 && iter >= 1){
      printf("Debug termination\n");
      fflush(stdout);  exit(1);
    }

    int progress = 0;/* how many locally best changes have been found by mprobeval (but not necessarily confirmed with hprobeval) */
    int changecnt = 0;/* number of changes made to HapSite[],HapDelta[],Delta[] (for this value of iter) */

    int SNPcnt = 0;/* count of current number of SNPs */
    for(int i = imin; i <= imax; i++)
      SNPcnt += (HapSite[i]==1 || HapSite[i]==2) ? 1 : 0;
    int IndelCnt = 0;/* count of current number of Indels (count consecutive Indels seperated by HapSite[i]==0 as one) */
    for(int i = imin; i < imax; i++){
      int h = HapSite[i];
      if(h == 3){
	double HapDeltaMerge = HapDelta[i];
	for(int t = i; ++t <= n; ){
	  if(HapSite[t] == 3)
	    break;
	  HapDeltaMerge += HapDelta[t];
	}
	IndelCnt += (HapDeltaMerge != 0.0) ? 1 : 0;
      }
    }

    if(IndelCnt > 0){/* compute HapDeltaMerged[1..n] */
      for(int i = 0; i <= n; i++){
	if(i <= 0 || HapSite[i] == 3){
	  int RR = i+1;
	  while(RR <= n && HapSite[RR] != 3)
	    RR++;

	  double sum = 0.0, abssum = 0.0;
	  for(int t = i; t < RR; t++){
	    sum += HapDelta[t];
	    abssum += fabs(HapDelta[t]);
	  }
	  if(abssum < MIN_INDEL_SIZE)
	    abssum = sum = 0.0;// WAS7 abssum = 0.0;
	  else if(fabs(sum) < MIN_INDEL_SIZE)
	    sum = copysign(MIN_INDEL_SIZE,sum);

	  for(int t = i; t < RR; t++)
	    HapDeltaMerged[t] = sum;
	  
	  i = RR-1;
	}
      }
    }

    if(DEBUG>=2 || (HFIX>=2 && HINDELITER(iter-1))){/* check that newLP is still valid (and update nmapK1[],nmapK2[] if UpdateMap() will be called)*/
      if(VERB){
	int inactivecnt = 0;/* number of already inactive intervals in current iter */
	int maxIN = max(1,DELTA_INTERVALS - 2);
	for(int IN = 0; IN <= maxIN; IN++)
	  inactivecnt += (DELTA_RANGE[IN] <= 0) ? 1 : 0;

	printf("At start of HaploType iteration %d: lastiter=%d,HapSiteIter=%d,HapIndelDelIter=%d, previous LP=%0.10f, inactivecnt=%d/%d : elapsed wall time=%0.6f\n",
	       iter,lastiter,HapSiteScoreIter,HapIndelDelIter,newLP,inactivecnt,maxIN+1,wtime());
	if(VERB && (VERB>=2 || iter==ITER_ID || rverb)){
	  int hap = 0;
	  for(int i = 1; i <= n; i++){
	    if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3) || (iter==ITER_ID && HapSite[i]))
	      printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		     i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	    if(hap && HapSite[i]==3)
	      hap = 0;
	    if(HapDelta[i])
	      hap = 1;
	  }
	}
	if(0 && iter==ITER_ID){/* try to remove SNPs left of 800kb */
	  for(int i = 1; i <= n; i++){
	    //	    if(800.0 <= Hcuts[i] && Hcuts[i] <= 950.0)
	    //	      continue;
	    if(1045.0 <= Hcuts[i])
	      continue;
	    if(1 <= HapSite[i] && HapSite[i] <= 2){
	      int origHapSite = HapSite[i];
	      double origDelta = Delta[i];
	      int L = i;

	      HapSite[i] = (SiteScore[i] > 0.0) ? 3 : 0;
	      
	      if(HapSite[i] == 0){
		if(HapDelta[i]){
		  printf("\t i=%d: Hcuts[i]= %0.3f,HapSite[i]=%d,HapDelta[i]=%0.10f : Cannot change HapSite due to HapDelta\n",i,Hcuts[i],HapSite[i],HapDelta[i]);
		  HapSite[i] = origHapSite;
		  continue;
		}

		if(Delta[i]){
		  for(; --L >= 1;)
		    if(HapSite[L])
		      break;
		  if(!HapSite[L]){
		    HapSite[i] = origHapSite;
		    printf("\t i=%d: Hcuts[i]= %0.3f,HapSite[i]=%d,Delta[i]=%0.10f : Cannot change HapSite due to Delta\n",i,Hcuts[i],HapSite[i],Delta[i]);
		    continue;
		  }
		  Delta[L] += Delta[i];
		  Delta[i] = 0.0;
		}
	      }

	      if(L < i)
		printf("\t i=%d: Hcuts[i]= %0.3f, HapSite[i] = %d -> %d, Delta[i]= %0.4f -> 0, Delta[%d]= %0.4f -> %0.4f\n",i,Hcuts[i],origHapSite,HapSite[i], origDelta,L,Delta[L]-origDelta,Delta[L]);
	      else
		printf("\t i=%d: Hcuts[i]= %0.3f, HapSite[i] = %d -> %d\n",i,Hcuts[i],origHapSite,HapSite[i]);
	    }
	  }
	}
	fflush(stdout);
      }

      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* needed to update N1,N2,Y1,Y2 etc */
      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			     TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);

      if(DEBUG>=1+RELEASE || rverb || !(fabs(nLP - newLP) < HLP_MINDELTA && SNPs == SNPcnt && Indels == IndelCnt) || (HFIX >= 2 && HINDELITER(iter-1))){
	printf("%siter=%d:hprobeval=%0.10f,SNPs=%d,Indels=%d(expected newLP=%0.10f,SNPcnt=%d,IndelCnt=%d), err=%0.10f: wall time= %0.6f\n",
	       fabs(nLP - newLP) < HLP_MINDELTA ? "" : "WARNING:", iter,nLP,SNPs,Indels,newLP,SNPcnt,IndelCnt,nLP-newLP,wtime());
	fflush(stdout);
	if(DEBUG>=2) assert(nLP > newLP - 1e-5);
      }
      rverb = 0;

      newLP = nLP;
      SNPcnt = SNPs;
      IndelCnt = Indels;
    }

    if(DEBUG>=2){/* check that SNP/Indel counts are valid */
      int SNPcnt = 0;/* count of current number of SNPs */
      for(int i = imin; i <= imax; i++)
	SNPcnt += (HapSite[i]==1 || HapSite[i]==2) ? 1 : 0;

      int IndelCnt = 0;/* count of current number of Indels (count consecutive Indels seperated by HapSite[i]==0 as one) */
      for(int i = imin; i < imax; i++){
	int h = HapSite[i];
	if(h == 3){
	  double HapDeltaMerge = HapDelta[i];
	  for(int t = i; ++t <= n; ){
	    if(HapSite[t] == 3)
	      break;
	    HapDeltaMerge += HapDelta[t];
	  }
	  IndelCnt += (HapDeltaMerge != 0.0) ? 1 : 0;
	}
      }

      if(VERB){
	printf("At start of iteration %d:n=%d,imin=%d,imax=%d,N1=%d,N2=%d,Indels=%d,SNPs=%d:SNPs=%d,Indels=%d\n",
	       iter,n,imin,imax,N1,N2,IndelCnt,SNPcnt,SNPs,Indels);
	
	fflush(stdout);
      }
      if(DEBUG) assert(SNPcnt == SNPs);
      if(DEBUG) assert(IndelCnt == Indels);
    }

    //    if(iter==18)
    //      rverb = 1;

    if(HINDELITER(iter-1) && LPDROP_FIX)
      LPhwm = max(newLP,LPhwm);

    // If last iteration was a Indel iteration, perform equivalent of UpdateMap() (to update map1[],map2[],mapK1[],mapK2[]) and repositionH() (to update Hcuts[]) */
    // NOTE : repositionH() will invalidate all HapSiteScore[],SiteScore[] and HapIndelScore[] values. To ensure they are valid, the last iteration must have HINDELITER(iter).
    // NOTE : this is not called every other iteration, see HapUpdatemapSkipcnt

    if(HFIX >= 2 && HINDELITER(iter-1) && HapUpdatemapSkipcnt-- <= 0){ 
      double wt = wtime();

      double startLP = newLP, nLP;
      
      int startDELTA_X = DELTA_X;
      int startDELTA_Y = DELTA_Y;
      int startRANGE = RANGE;
      int startRANGE_Y = RANGE_Y;
      int startOutlierType = OutlierType;
      double startOutlierLambda = outlierLambda;
      double startPoutlier = Poutlier;
      double startPoutlierEnd = PoutlierEnd;
      double startLRbias = LRbias;
      double startSF = SF[0];
      double startSR = SR[0];

      // restore original RANGE,RANGE_Y,DELTA_X,DELTA_Y, OutlierType, outlierLambda, Poutlier, PoutlierEnd and call hprobeval() before calling UpdateMap()
      if(1){

	if(!SWITCH_FIX && !SwitchFade){
	  DELTA_X = origDELTA_X;
	  DELTA_Y = origDELTA_Y;
	  RANGE = origRANGE;
	  if(RANGE_UPDATE)
	    RANGE = RANGE_UPDATE;
	  RANGE_Y = RANGE_Y1;
	  OutlierType = origOutlierType;
	  outlierLambda = origOutlierLambda;
	  Poutlier = gorigPoutlier;
	  PoutlierEnd = gorigPoutlierEnd;
	  LRbias = origLRbias;
	  SF[0] = origSF;
	  SR[0] = origSR;

	  if(VERB && (DELTA_X != startDELTA_X || DELTA_Y != startDELTA_Y || RANGE != startRANGE || RANGE_Y != startRANGE_Y || LRbias != startLRbias || OutlierType != startOutlierType ||
		      outlierLambda != startOutlierLambda || Poutlier != startPoutlier || PoutlierEnd != startPoutlierEnd || SF[0] != startSF || SR[0] != startSR)) {
	    printf("Changing deltaX=%d->%d,deltaY=%d->%d,RANGE=%d->%d,RANGE_Y=%d->%d,OutlierType=%d->%d,Lambda=%0.2e->%0.2e,outlier=%0.2e->%0.2e,endoutlier=%0.2e->%0.2e,LRbias=%0.2e->%0.2e,SF=%0.3f->%0.3f,SR=%0.4f->%0.4f before UpdateMap:cum time = %0.6f\n",
		   startDELTA_X,DELTA_X,startDELTA_Y,DELTA_Y,startRANGE, RANGE, startRANGE_Y, RANGE_Y, startOutlierType, OutlierType, 
		   startOutlierLambda, outlierLambda, startPoutlier, Poutlier, startPoutlierEnd, PoutlierEnd, startLRbias, LRbias, startSF,SF[0],startSR,SR[0],wt);
	    fflush(stdout);
	  }
	}

	if(VERB>=3){
	  printf("Before calling hsetmap:iter=%d,n=%d\n",iter,n);
	  for(int u = 1; u <= n; u++)
	    printf("\t u=%d:Hcuts1[u]= %0.8f, Hcuts2[u]= %0.8f, skip[u]= %d, Hcuts[u]= %0.8f, HapSite[u]=%d, HapDelta[u]= %0.8f, Delta[u]= %0.8f\n",
		   u, Hcuts1[u], Hcuts2[u], skip[u], Hcuts[u], HapSite[u], HapDelta[u], Delta[u]);
	  fflush(stdout);
	}

	/* NEW*/hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* needed to update N1,N2,Y1,Y2 etc */

	if(VERB>=3){
	  printf("Before calling UpdateMap:iter=%d,n=%d\n",iter,n);
	  for(int u = 1; u <= n; u++)
	    printf("\t u=%d:Hcuts1[u]= %0.8f, Hcuts2[u]= %0.8f, skip[u]= %d, Hcuts[u]= %0.8f, HapSite[u]=%d, HapDelta[u]= %0.8f, Delta[u]= %0.8f\n",
		   u, Hcuts1[u], Hcuts2[u], skip[u], Hcuts[u], HapSite[u], HapDelta[u], Delta[u]);
	  fflush(stdout);
	}

	if(DEBUG>=2){/* check if map[MD] and nmap[MD] are consistent */
	  int I,i;
	  for(i = 1; i <= n; i++)
	    if((I = map1[MD][i]) >= 0){
	      assert(nmap1[MD][I] == i);
	      assert(fabs(Hcuts1[i] - Y1[I]) < 1e-6);
	    }
	  for(I = 1; I <= N1; I++)
	    if((i = nmap1[MD][I]) >= 0){
	      assert(map1[MD][i] == I);
	      assert(fabs(Hcuts1[i] - Y1[I]) < 1e-6);
	    }
	  for(i = 1; i <= n; i++)
	    if((I = map2[MD][i]) >= 0){
	      assert(nmap2[MD][I] == i);
	      assert(fabs(Hcuts2[i] - Y2[I]) < 1e-6);
	    }
	  for(I = 1; I <= N2; I++)
	    if((i = nmap2[MD][I]) >= 0){
	      assert(map2[MD][i] == I);
	      assert(fabs(Hcuts2[i] - Y2[I]) < 1e-6);
	    }
	}
	if(DEBUG>=2){/* make sure map[] and mapK[] are consistent */
	  for(int m = 0; m < MD; m++){
	    //	    if(TBmapWT[m] <= 0.0)
	    //	      continue;
	    int M = MX[m];

	    int lastJ = -1, lasti = -1, lastk = -1, i, k, I;
	    for(int J = 1; J <= M; J++){
	      if((i = map1[m][J]) > 0 && (I = map1[MD][i]) > 0){
		k = mapK1[m][J];
		assert(0 <= k && k < i);
		if(k > 0 && map1[MD][i-k] < 0)/* locally "clean up" mapK */
		  k = 0;
		if(lasti >= 0 && !(i-k > lasti)){
		  printf("\nmap1:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel1[i,i-k]=%d,%d,HapSite[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel1[i],Hdel1[i-k],HapSite[i],HapSite[i-k]);
		  int K = map1[MD][i-k];
		  printf("    I=%d,K=%d:Hcuts1[i]=%0.4f,Y1[I]=%0.4f,Hcuts1[i-k]=%0.4f,Y1[K]=%0.4f\n",
			 I,K,Hcuts1[i],I < 0 ? -1.0 : Y1[I],Hcuts1[i-k], K < 0 ? -1.0 : Y1[K]);
		  if(VERB){
		    for(int j = 1; j <= M; j++){
		      int i = map1[m][j];
		      if(i < 0)
			continue;
		      int k = mapK1[m][j];
		      printf("\t j=%d:map1[m][j]=%d,mapK1[m][j]=%d\n",j,i,k);
		    }
		  }
		  fflush(stdout);
		  assert(i-k > lasti);
		}

		lasti = i;
		lastk = k;
		lastJ = J;
	      }
	    }

	    lastJ = -1, lasti = -1, lastk = -1;
	    for(int J = 1; J <= M; J++){
	      if((i = map2[m][J]) > 0 && (I = map2[MD][i]) > 0){
		k = mapK2[m][J];
		assert(0 <= k && k < i);
		if(k > 0 && map2[MD][i-k] < 0)/* locally "clean up" mapK */
		  k = 0;
		if((lasti >= 0 && !(i-k > lasti))){
		  int K = map2[MD][i-k];
		  printf("\nmap2:m=%d,J=%d,i=%d,k=%d,I=%d,K=%d:lastJ=%d,lasti=%d,lastk=%d:Hdel2[i,i-k]=%d,%d,HapSite[i,i-k]=%d,%d\n",m,J,i,k,I,K,lastJ,lasti,lastk,Hdel2[i],Hdel2[i-k],HapSite[i],HapSite[i-k]);
		  if(VERB){
		    for(int j = 1; j <= M; j++){
		      int i = map2[m][j];
		      if(i < 0)
			continue;
		      int k = mapK2[m][j];
		      printf("\t j=%d:map2[m][j]=%d,mapK2[m][j]=%d\n",j,i,k);
		    }
		  }
		  fflush(stdout);
		  assert(i-k > lasti);
		}
		lasti = i;
		lastk = k;
		lastJ = J;
	      }
	    }
	  }
	}

	int origglobalfallback = globalfallback;
	if(GLOBAL_FALLBACK)
	  globalfallback = 1;// set globalfallback = 1, to force computing alignments for un-aligned maps ?

	nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels, 2);
	globalfallback = origglobalfallback;
	double wt2 = wtime();

	if(DEBUG>=2){/* not needed if previous hprobeval() did not use 2 as last arg */
	  //	  rverb = (iter>=24 ? 1 : 0);
	  double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				 TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  //	  rverb = 0;
	  if(VERB || rverb){
	    printf("After swapping map1,map2: LP=%0.8f -> %0.8f(delta= %0.8f), hLP=%0.8f(err=%0.8f),SNPs=%d,Indels=%d (wt=%0.6f,cum=%0.6f)\n",
		   newLP, nLP, nLP-newLP, hLP,hLP-nLP,SNPs,Indels, wt2-wt,wt2);
	    fflush(stdout);
	  }
	  nLP = hLP;
	} else if(VERB){
	  printf("After swapping map1,map2: LP=%0.8f -> %0.8f(delta= %0.8f),SNPs=%d,Indels=%d (wt=%0.6f,cum=%0.6f)\n",newLP, nLP, nLP-newLP, SNPs,Indels, wt2-wt,wt2);
	  fflush(stdout);
	}

	/* remove invalid mappings from map1,map2 */
	cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
	double pLP = nLP;
	//	rverb = (iter>=24 ? 1 : 0);
	nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels, 0);
	//	rverb = 0;
	if(VERB/* HERE>=2*/){
	  printf("After cleaning up map1,map2: LP=%0.8f -> %0.8f (delta=%0.8f),SNPs=%d,Indels=%d:wall time=%0.6f\n",pLP,nLP,nLP-pLP,SNPs,Indels,wtime());
	  fflush(stdout);
	}

	if(DEBUG>=2){
	  for(int m = 0; m < MD; m++){
	    if(DEBUG && !(isfinite(mapWT1[m]) && isfinite(mapWT2[m]))){
	      printf("m=%d/%d:mapWT1[m]= %0.6e, mapWT2[m]= %0.6fe, TBmapWT[m]= %0.6e\n",m,MD,mapWT1[m], mapWT2[m], TBmapWT[m]);
	      fflush(stdout);
	      assert(isfinite(mapWT1[m]));
	      assert(isfinite(mapWT2[m]));
	    }
	  }
	}

	if(DEBUG>=3){/* make sure map[] and mapK[] are consistent AND clean */
	  for(int m = 0; m < MD; m++){
	    //	    if(TBmapWT[m] <= 0.0)
	    //	      continue;
	    int M = MX[m];

	    int lastJ = -1, lasti = -1, lastk = -1, i, k, I;

	    for(int J = 1; J <= M; J++){
	      if((i = map1[m][J]) > 0 && (I = map1[MD][i]) > 0){
		k = mapK1[m][J];
		assert(0 <= k && k < i);
		if(k > 0 && map1[MD][i-k] < 0)/* locally "clean up" mapK */
		  k = 0;
		if(lasti >= 0 && !(i-k > lasti && map1[MD][i] >= 0 && map1[MD][i-k] >= 0)){
		  printf("map1:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d (map1[MD][i]=%d,map1[MD][i-k]=%d)\n",m,J,i,k,lastJ,lasti,lastk,map1[MD][i],map1[MD][i-k]);
		  for(int j = 1; j <= M; j++){
		    int ni,nk;
		    if((ni = map1[m][j]) > 0){
		      nk = mapK1[m][j];
		      printf("m=%d:J=%d,M=%d:map1[m][J]=i=%d,mapK1[m][J]=k=%d,X[m][J]=%0.4f,Hcuts[i]=%0.4f,Hcuts[i-k]=%0.4f,map1[MD][i]=%d,map1[MD][i-k]=%d\n",
			     m,j,M,map1[m][j],mapK1[m][j],X[m][j],Hcuts[ni],Hcuts[ni-nk],map1[MD][ni],map1[MD][ni-nk]);
		    }
		  }
		  fflush(stdout);
		  assert(i-k > lasti);
		  assert(0 <= map1[MD][i] && map1[MD][i] <= N1+1);
		  assert(0 <= map1[MD][i-k] && map1[MD][i-k] <= N1+1);
		}
		lasti = i;
		lastk = k;
		lastJ = J;
	      }
	    }
	
	    lastJ = -1, lasti = -1, lastk = -1;
	    for(int J = 1; J <= M; J++){
	      //	      if(TBmapWT[m] <= 0.0)
	      //		continue;
	      if((i = map2[m][J]) > 0 && (I = map2[MD][i]) > 0){
		k = mapK2[m][J];
		assert(0 <= k && k < i);
		if(k > 0 && map2[MD][i-k] < 0)/* locally "clean up" mapK */
		  k = 0;
		if(lasti >= 0 && !(i-k > lasti && map2[MD][i] >= 0 && map2[MD][i-k] >= 0)){
		  printf("map2:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d (map2[MD][i]=%d,map2[MD][i-k]=%d)\n",m,J,i,k,lastJ,lasti,lastk,map2[MD][i],map2[MD][i-k]);
		  for(int j = 1; j <= M; j++){
		    int ni,nk;
		    if((ni = map2[m][j]) > 0){
		      nk = mapK2[m][j];
		      printf("m=%d:J=%d,M=%d:map2[m][J]=i=%d,mapK2[m][j]=k=%d,X[m][J]=%0.4f,Hcuts[i]=%0.4f,Hcuts[i-k]=%0.4f,map2[MD][i]=%d,map2[MD][i-k]=%d\n",
			     m,j,M,map2[m][j],mapK2[m][j],X[m][j],Hcuts[ni],Hcuts[ni-nk],map2[MD][ni],map2[MD][ni-nk]);
		    }
		  }
		  fflush(stdout);
		  assert(i-k > lasti);
		  assert(0 <= map1[MD][i] && map1[MD][i] <= N2+1);
		  assert(0 <= map1[MD][i-k] && map1[MD][i-k] <= N2+1);
		}
		lasti = i;
		lastk = k;
		lastJ = J;
	      }
	    }
	  }
	}

	//	rverb = (iter==26) ? 1 : 0;
	global = (FAST_HPROBEVAL>=2 ? 0 : 1);

	if(global) {
	  //	  memcpy(bestLPA1,startLPA1,MD*sizeof(double));
	  //	  memcpy(bestLPA2,startLPA2,MD*sizeof(double));

	  int SNPs2,Indels2;
	  double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				  TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs2,Indels2,0);
	  if(VERB){
	    double wt3 = wtime();
	    printf("Global alignment before UpdateMap:LP=%0.8f -> %0.8f, N1=%d,N2=%d:wtime=%0.6f (cum=%0.6f)\n",  nLP, nLP2, N1, N2, wt3-wt2, wt3);
	    fflush(stdout);
	  }

	  if(DEBUG>=2){
	    for(int m = 0; m < MD; m++){
	      int M = MX[m];
	      for(int J = 0; J <= M+1; J++){
		int I = nmap1[m][J];
		if(DEBUG && !(I >= -1 && I <= N1+1)){
		  printf("m=%d/%d:J=%d,M=%d,N1=%d,nmap1[m][J]=I=%d\n",m,MD,J,M,N1,nmap1[m][J]);
		  fflush(stdout);
		  assert(I >= -1 && I <= N1 + 1);
		}
		if(1 <= J && J <= M && I >= 0){
		  int K = nmapK1[m][J];
		  assert(0 <= K && K <= KMAX && K <= I);
		}

		I = nmap2[m][J];
		if(DEBUG && !(I >= -1 && I <= N2 + 1)){
		  printf("m=%d/%d:J=%d,M=%d,N2=%d,nmap2[m][J]=I=%d\n",m,MD,J,M,N2,nmap2[m][J]);
		  fflush(stdout);
		  assert(I >= -1 && I <= N2 + 1);
		}
		if(1 <= J && J <= M && I >= 0){
		  int K = nmapK2[m][J];
		  assert(0 <= K && K <= KMAX && K <= I);
		}
	      }
	    }
	  }
	}

	rverb = 0;

	newLP = nLP;
        SNPcnt = SNPs;
        IndelCnt = Indels;

	if(DEBUG>=3){/* make sure map[] and mapK[] are consistent AND clean */
	  for(int m = 0; m < MD; m++){
	    //	    if(TBmapWT[m] <= 0.0)
	    //	      continue;
	    int M = MX[m];

	    int lastJ = -1, lasti = -1, lastk = -1, i, k, I;

	    for(int J = 1; J <= M; J++){
	      if((i = map1[m][J]) > 0 && (I = map1[MD][i]) > 0){
		k = mapK1[m][J];
		assert(0 <= k && k < i);
		if(k > 0 && map1[MD][i-k] < 0)/* locally "clean up" mapK */
		  k = 0;
		if(VERB>=3 && iter==18 && m==73)
		  printf("m=%d:J=%d,M=%d:map1[m][J]=i=%d,mapK2[m][j]=k=%d,X[m][J]=%0.4f,Hcuts[i]=%0.4f,Hcuts[i-k]=%0.4f,Hdel1[i,i-k]=%d,%d,map1[MD][i]=%d,map1[MD][i-k]=%d\n",
			 m,J,M,i,k,X[m][J],Hcuts[i],Hcuts[i-k],Hdel1[i],Hdel1[i-k],map1[MD][i],map1[MD][i-k]);

		if(lasti >= 0 && !(i-k > lasti && map1[MD][i] >= 0 && map1[MD][i-k] >= 0)){
		  printf("map1:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d (map1[MD][i]=%d,map1[MD][i-k]=%d)\n",m,J,i,k,lastJ,lasti,lastk,map1[MD][i],map1[MD][i-k]);
		  for(int j = 1; j <= M; j++){
		    int ni,nk;
		    if((ni = map1[m][j]) > 0){
		      nk = mapK1[m][j];
		      printf("m=%d:J=%d,M=%d:map1[m][J]=i=%d,mapK1[m][J]=k=%d,X[m][J]=%0.4f,Hcuts[i]=%0.4f,Hcuts[i-k]=%0.4f,map1[MD][i]=%d,map1[MD][i-k]=%d\n",
			     m,j,M,map1[m][j],mapK1[m][j],X[m][j],Hcuts[ni],Hcuts[ni-nk],map1[MD][ni],map1[MD][ni-nk]);
		    }
		  }
		  fflush(stdout);
		  assert(i-k > lasti);
		  assert(0 <= map1[MD][i] && map1[MD][i] <= N1+1);
		  assert(0 <= map1[MD][i-k] && map1[MD][i-k] <= N1+1);
		}
		lasti = i;
		lastk = k;
		lastJ = J;
	      }
	    }
	
	    lastJ = -1, lasti = -1, lastk = -1;
	    for(int J = 1; J <= M; J++){
	      //	      if(TBmapWT[m] <= 0.0)
	      //		continue;
	      if((i = map2[m][J]) > 0 && (I = map2[MD][i]) > 0){
		k = mapK2[m][J];
		assert(0 <= k && k < i);
		if(k > 0 && map2[MD][i-k] < 0)/* locally "clean up" mapK */
		  k = 0;
		if(lasti >= 0 && !(i-k > lasti && map2[MD][i] >= 0 && map2[MD][i-k] >= 0)){
		  printf("map2:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d (map2[MD][i]=%d,map2[MD][i-k]=%d)\n",m,J,i,k,lastJ,lasti,lastk,map2[MD][i],map2[MD][i-k]);
		  for(int j = 1; j <= M; j++){
		    int ni,nk;
		    if((ni = map2[m][j]) > 0){
		      nk = mapK2[m][j];
		      printf("m=%d:J=%d,M=%d:map2[m][J]=i=%d,mapK2[m][j]=k=%d,X[m][J]=%0.4f,Hcuts[i]=%0.4f,Hcuts[i-k]=%0.4f,map2[MD][i]=%d,map2[MD][i-k]=%d\n",
			     m,j,M,map2[m][j],mapK2[m][j],X[m][j],Hcuts[ni],Hcuts[ni-nk],map2[MD][ni],map2[MD][ni-nk]);
		    }
		  }
		  fflush(stdout);
		  assert(i-k > lasti);
		  assert(0 <= map1[MD][i] && map1[MD][i] <= N2+1);
		  assert(0 <= map1[MD][i-k] && map1[MD][i-k] <= N2+1);
		}
		lasti = i;
		lastk = k;
		lastJ = J;
	      }
	    }
	  }
	}
      }

      if(global){
	global = 0;

	/* try updating both maps simultaneously to benefit from global update */

	/* first save map,mapK */
	for(int m = 0; m < MD; m++){
	  memcpy(origmap1[m],map1[m],(MX[m]+2)*sizeof(int));
	  memcpy(origmapK1[m],mapK1[m],(MX[m]+2)*sizeof(int));

	  memcpy(origmap2[m],map2[m],(MX[m]+2)*sizeof(int));
	  memcpy(origmapK2[m],mapK2[m],(MX[m]+2)*sizeof(int));

	  if(VERB>=3 && iter==18 && m==73){
	    int M = MX[m];
	    printf("Saved origmap1[m=%d]:M=%d\n",m,M);
	    for(int J = 1; J <= M; J++)
	      printf("\t J=%d:origmap1[m][J]=%d,origmapK1[m][J]=%d\n",J,origmap1[m][J],origmapK1[m][J]);
	    fflush(stdout);
	  }
	}

	if(DEBUG>=2){
	  for(int m = 0; m < MD; m++){
	    if(DEBUG && !(isfinite(mapWT1[m]) && isfinite(mapWT2[m]))){
	      printf("m=%d:mapWT1[m]= %0.6e, mapWT2[m]= %0.6fe, TBmapWT[m]= %0.6e\n",m,mapWT1[m], mapWT2[m], TBmapWT[m]);
	      fflush(stdout);
	      assert(isfinite(mapWT1[m]));
	      assert(isfinite(mapWT2[m]));
	    }
	  }
	}

	UpdateMap(n, N1, Y1, MD, MX, X, Hcuts, Hdel1, map1, mapK1, limit1, nmap1, nmapK1, mapWT1, 0, FILL_HMAP);
	UpdateMap(n, N2, Y2, MD, MX, X, Hcuts, Hdel2, map2, mapK2, limit2, nmap2, nmapK2, mapWT2, 0, FILL_HMAP);
	//	rverb = (iter==94) ? 1 : 0;
	nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0/* bestLPA1*/,0/*bestLPA2*/,0.0,Hcuts1[n+1],0.0,Hcuts2[n+1],0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	rverb = 0;

	if(nLP > newLP + 1e-9 /* WAS 1e-10 */){
	  if(VERB){
	    printf("  After updating both map1 & map2: LP=%0.10f -> %0.10f (delta=%0.10f), N1=%d,N2=%d\n",newLP,nLP,nLP-newLP,N1,N2);
	    fflush(stdout);
	  }
	  newLP = nLP;
	  /* swap testLPA and startLPA */
	  double *tmp = testLPA1; testLPA1 = startLPA1; startLPA1 = tmp;
	  tmp = testLPA2; testLPA2 = startLPA2; startLPA2 = tmp;

	} else {/* try partial update */
	  if(VERB){
	    printf("  After updating both map1 & map2: LP=%0.10f -> %0.10f (delta=%0.10f), N1=%d,N2=%d (Will try partial updates of map1,map2)\n",newLP,nLP,nLP-newLP,N1,N2);
	    fflush(stdout);
	  }

	  /* try to perform a partial update */
	  double sum = 0;
	  for(int m = 0; m < MD; m++){
	    int M = MX[m];
	    if(testLPA1[m] > startLPA1[m])
	      sum += testLPA1[m] - startLPA1[m];
	    else {
	      memcpy(map1[m],origmap1[m],(M+2)*sizeof(int));
	      memcpy(mapK1[m],origmapK1[m],(M+2)*sizeof(int));
	    }
	    if(testLPA2[m] > startLPA2[m])
	      sum += testLPA2[m] - startLPA2[m];
	    else {
	      memcpy(map2[m],origmap2[m],(M+2)*sizeof(int));
	      memcpy(mapK2[m],origmapK2[m],(M+2)*sizeof(int));
	    }
	  }

	  double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				  TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);

	  if(nLP2 > newLP + 1e-9 /* WAS 1e-10 */){
	    if(VERB){
	      printf("   After partial update of map1 & map2: LP=%0.8f->%0.8f (delta=%0.8f)\n",newLP,nLP, nLP-newLP);
	      fflush(stdout);
	    }
	    newLP = nLP;
	    /* swap testLPA and startLPA */
	    double *tmp = testLPA1; testLPA1 = startLPA1; startLPA1 = tmp;
	    tmp = testLPA2; testLPA2 = startLPA2; startLPA2 = tmp;

	  } else { /* revert */

	    if(VERB){
	      printf("  After partial update of map1 & map2: LP=%0.8f->%0.8f (delta=%0.8f): reverting to original map1,map2\n",newLP,nLP, nLP-newLP);
	      fflush(stdout);
	    }

	    for(int m = 0; m < MD; m++){ 	    /* avoid reverting if origmap1[m] has no valid mappings */
	      int M = MX[m], J;
	      for(J = 1; J <= M; J++)
		if(origmap1[m][J] >= 0)
		  break;
	      if(J <= M){
		memcpy(map1[m],origmap1[m],(M+2)*sizeof(int));
		memcpy(mapK1[m],origmapK1[m],(M+2)*sizeof(int));
	      } else if(VERB>=2 && iter==18){
		printf("\t Keeping updated mapping for map1[%d]\n",m);
		fflush(stdout);
	      }

	      for(J = 1; J <= M; J++)
		if(origmap2[m][J] >= 0)
		  break;
	      if(J <= M){
		memcpy(map2[m],origmap2[m],(M+2)*sizeof(int));
		memcpy(mapK2[m],origmapK2[m],(M+2)*sizeof(int));
	      } else if(VERB>=2 && iter==18){
		printf("\t Keeping updated mapping for map2[%d]\n",m);
		fflush(stdout);
	      }
	    }

	    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels, 2);

	    if(VERB){
	      printf("  After reverting map1 & map2: LP=%0.8f (err=%0.8f), SNPs=%d, Indels=%d\n",nLP,nLP-newLP,SNPs,Indels);
	      if(nLP < newLP - 1e-6){
		double logH = -log(2.0);
		for(int m= 0; m < MD; m++){
		  double testLP = HapLP(testLPA1[m],testLPA2[m],logH);
		  double startLP = HapLP(startLPA1[m],startLPA2[m],logH);
		  if(fabs(testLP - startLP) > 1e-6)
		    printf("\t m=%d:testLP[m]= %0.6f, startLP[m]= %0.6f (delta= %0.6f): testLPA1[m]=%0.6f,testLPA2[m]=%0.6f,startLPA1[m]=%0.6f,startLPA2[m]=%0.6f\n",
			   m, testLP, startLP, testLP - startLP, testLPA1[m],testLPA2[m],startLPA1[m],startLPA2[m]);
		}
	      }
	      fflush(stdout);
	    }
	    newLP = nLP;

	    /* swap testLPA and startLPA */
	    double *tmp = testLPA1; testLPA1 = startLPA1; startLPA1 = tmp;
	    tmp = testLPA2; testLPA2 = startLPA2; startLPA2 = tmp;

	  }
	}
      }

      int block = 1;
      while(block < 16 && MD > numthreads * block)
	block *= 2;

      /* update map1,mapK1 */
      for(int cnt = 0; cnt < 50; cnt++) {

	/* first save map1,mapK1 */
        #pragma omp parallel for schedule(static,block) num_threads(numthreads)
	for(int m = 0; m < MD; m++){
	  memcpy(origmap1[m],map1[m],(MX[m]+2)*sizeof(int));
	  memcpy(origmapK1[m],mapK1[m],(MX[m]+2)*sizeof(int));
	}

	UpdateMap(n, N1, Y1, MD, MX, X, Hcuts, Hdel1, map1, mapK1, limit1, nmap1, nmapK1, mapWT1, 0, FILL_HMAP);
	//	rverb = (iter>=24 ? 1 : 0);
	nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	rverb = 0;

	if(nLP > newLP + (cnt ? 1e-9/* WAS 1e-10 */ : -1.0)){// NEW
	  if(VERB){
	    printf("  Updated map1: LP=%0.10f -> %0.10f (delta=%0.10f) , N1=%d (cnt=%d)\n",newLP,nLP,nLP-newLP,N1,cnt);
	    fflush(stdout);
	  }
	  newLP = nLP;
	  /* swap testLPA and startLPA */
	  double *tmp = testLPA1; testLPA1 = startLPA1; startLPA1 = tmp;
	  tmp = testLPA2; testLPA2 = startLPA2; startLPA2 = tmp;
	  continue;
	}
	if(VERB/* HERE >=2 */){
	  printf("  NOT updated map1: LP=%0.10f -> %0.10f (delta=%0.10f) , N1=%d (cnt=%d)\n",newLP,nLP,nLP-newLP,N1,cnt);
	  fflush(stdout);
	}

	/* try performing a partial update */
	double sum = 0.0;
        #pragma omp parallel num_threads(numthreads)
	{
	  double mysum = 0.0;

          #pragma omp for nowait schedule(static,block)
	  for(int m = 0; m < MD; m++){
	    int M = MX[m];
	    if(testLPA1[m] > startLPA1[m])
	      mysum += testLPA1[m] - startLPA1[m];
	    else {
	      memcpy(map1[m],origmap1[m],(M+2)*sizeof(int));
	      memcpy(mapK1[m],origmapK1[m],(M+2)*sizeof(int));
            }
	  }

	  #pragma omp atomic
	  sum += mysum;
	}

	//	rverb = (iter>=24 ? 1 : 0);
	double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	//	rverb = 0;

	if(nLP2 > newLP + (cnt ? 1e-9 /* WAS 1e-10 */: -1.0)){
	  if(VERB){
	    printf("  Partially updated map1: LP=%0.10f -> %0.10f (delta=%0.10f), N2=%d, sum = %0.10f (cnt=%d)\n",newLP,nLP2,nLP2-newLP, N2, sum, cnt);
	    fflush(stdout);
	  }
	  newLP = nLP2;
	  /* swap testLPA and startLPA */
	  double *tmp = testLPA1; testLPA1 = startLPA1; startLPA1 = tmp;
	  tmp = testLPA2; testLPA2 = startLPA2; startLPA2 = tmp;

	  continue;
	}

	/* revert and terminate */
	if(VERB){
	  printf("  After map1 updates: LP=%0.10f -> %0.10f -> %0.10f, N1=%d (reverting to previous map1)\n",newLP,nLP,nLP2,N1);
	  fflush(stdout);
	}
	/* restore map1,mapK1 */
        #pragma omp parallel for schedule(static,block) num_threads(numthreads)
	for(int m = 0; m < MD; m++){	    /* avoid reverting if origmap1[m] has no valid mappings */
	  int M = MX[m], J;
	  for(J = 1; J <= M; J++)
	    if(origmap1[m][J] >= 0)
	      break;
	  if(J <= M){
	    memcpy(map1[m],origmap1[m],(M+2)*sizeof(int));
	    memcpy(mapK1[m],origmapK1[m],(M+2)*sizeof(int));
	  }
	}

	if(DEBUG>=2){
	  //	  rverb = (iter>=24 ? 1 : 0);
	  double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				  TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  //	  rverb = 0;
	  if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) || VERB/* HERE >=2 */){
	    printf("After reverting to previous map1: nLP=%0.10f (err=%0.10f), SNPs=%d, Indels=%d\n",nLP2,nLP2-newLP,SNPs,Indels);
	    fflush(stdout);
	    assert(fabs(nLP2 - newLP) < 1e-5);
	  }
	}
	break;
      }

      /* next update map2,mapK2 */
      for(int cnt = 0; cnt < 50; cnt++) {
	/* first save map2,mapK2 */
        #pragma omp parallel for schedule(static,block) num_threads(numthreads)
	for(int m = 0; m < MD; m++){
	  memcpy(origmap2[m],map2[m],(MX[m]+2)*sizeof(int));
	  memcpy(origmapK2[m],mapK2[m],(MX[m]+2)*sizeof(int));
	}

	UpdateMap(n, N2, Y2, MD, MX, X, Hcuts, Hdel2, map2, mapK2, limit2, nmap2, nmapK2, mapWT2, 0, FILL_HMAP);
	//	rverb = (iter>=24 ? 1 : 0);
	nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	//	rverb = 0;
	
	if(nLP > newLP + (cnt ? 1e-9 /* WAS 1e-10 */ : -1.0)){// NEW
	  if(VERB){
	    printf("  Updated map2: LP=%0.10f -> %0.10f (delta=%0.10f), N2=%d (cnt=%d)\n",newLP,nLP,nLP-newLP,N2,cnt);
	    fflush(stdout);
	  }
	  newLP = nLP;
	  /* swap testLPA and startLPA */
	  double *tmp = testLPA1; testLPA1 = startLPA1; startLPA1 = tmp;
	  tmp = testLPA2; testLPA2 = startLPA2; startLPA2 = tmp;

	  continue;
	}
	if(VERB/* HERE >=2 */){
	  printf("  NOT updated map2: LP=%0.10f -> %0.10f (delta=%0.10f), N2=%d (cnt=%d)\n",newLP,nLP,nLP-newLP,N2,cnt);
	  fflush(stdout);
	}

	/* try performing a partial update */
	double sum = 0.0;
        #pragma omp parallel num_threads(numthreads)
	{
	  double mysum = 0.0;

          #pragma omp for nowait schedule(static,block)
	  for(int m = 0; m < MD; m++){
	    int M = MX[m];
	    if(testLPA2[m] > startLPA2[m])
	      mysum += testLPA2[m] - startLPA2[m];
	    else {
	      memcpy(map2[m],origmap2[m],(M+2)*sizeof(int));
	      memcpy(mapK2[m],origmapK2[m],(M+2)*sizeof(int));
	    }
	  }

	  #pragma omp atomic
	  sum += mysum;
	}

	//	rverb = (iter>=24 ? 1 : 0);
	double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	//	rverb = 0;

	if(nLP2 > newLP + (cnt ? 1e-9 /* WAS 1e-10 */ : -1.0)){
	  if(VERB){
	    printf("  Partially updated map2: LP=%0.10f -> %0.10f (delta=%0.10f), N2=%d, sum = %0.10f (cnt=%d)\n",newLP,nLP2,nLP2-newLP, N2, sum, cnt);
	    fflush(stdout);
	  }
	  newLP = nLP2;
	  /* swap testLPA and startLPA */
	  double *tmp = testLPA1; testLPA1 = startLPA1; startLPA1 = tmp;
	  tmp = testLPA2; testLPA2 = startLPA2; startLPA2 = tmp;

	  continue;
	}

	/* revert and terminate */
	if(VERB){
	  printf("  Updated map2: LP=%0.10f -> %0.10f -> %0.10f, N2=%d (reverting to previous map2)\n",newLP,nLP,nLP2,N2);
	  fflush(stdout);
	}

	/* restore map2,mapK2 */
        #pragma omp parallel for schedule(static,block) num_threads(numthreads)
	for(int m = 0; m < MD; m++){
	  int M = MX[m], J;
	  for(J = 1; J <= M; J++)
	    if(origmap2[m][J] >= 0)
	      break;
	  if(J <= M){
	    memcpy(map2[m],origmap2[m],(MX[m]+2)*sizeof(int));
	    memcpy(mapK2[m],origmapK2[m],(MX[m]+2)*sizeof(int));
	  }
	}
	if(DEBUG>=2){
	  //	  rverb = (iter>=24 ? 1 : 0);
	  double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				  TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  //	  rverb = 0;

	  if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) || VERB/* HERE >=2 */){
	    printf("After reverting to previous map2: nLP=%0.10f (err=%0.10f), SNPs=%d, Indels=%d\n",nLP2,nLP2-newLP,SNPs, Indels);
	    fflush(stdout);
	    assert(fabs(nLP2 - newLP) < 1e-5);
	  }
	}
	break;
      }

      int origrverb = rverb;
      //      rverb = (iter>=24 ? 1 : 0);
      nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		      TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0 /* HERE TRY 2 */);
      //      rverb = origrverb;

      if(VERB){
	double wt = wtime();
	printf("Before calling repositionH:n=%d,imin=%d,imax=%d,N1=%d,N2=%d:nLP=%0.8f,LPbest=%0.8f(err=%0.8f),IndelCnt=%d,SNPcnt=%d:(SNPs=%d,Indels=%d):cum time=%0.6f\n",
	       n,imin,imax,N1,N2,nLP,newLP,nLP-newLP,IndelCnt,SNPcnt,SNPs,Indels,wt);
	fflush(stdout);
      }
      if(DEBUG>=1+RELEASE) assert(nLP >= newLP - 1e-4);

      newLP = nLP;
      IndelCnt = Indels;
      SNPcnt = SNPs;

      if(HFIX >= 3){ /* reposition Hcuts[] */
	if(VERB>=3 && iter==48){
	  for(int i = n+1; i >= 1; i--){
	    printf("i=%d/%d:Hcuts[i]=%0.6f,Hcuts1[i]=%0.6f,HapSite[i]=%d (HtrimR1=%0.6f)\n",i,n,Hcuts[i],Hcuts1[i],HapSite[i], HtrimR1);
	    if(Hcuts1[i] < HtrimR1 - 10.0)
	      break;
	  }
	  fflush(stdout);
	}

	//	rverb = (iter==38) ? 1 : 0;
	double shift = repositionH(n,Hcuts,Hcuts1,Hcuts2,HapDelta,Delta,HapSite,Hdel1,Hdel2,N1,N2,Y1,Y2,MD,MX,X,startLPA1,startLPA2,map1,map2,mapK1,mapK2,limit1,limit2,TBmapWT,nmap1,nmap2, 
				   skip,Lfrozen,Rfrozen,pcontig,imin,imax,spreadHapDelta,spreadDelta,Hremap);
	rverb = origrverb;

	if((DEBUG && !(HapSite == pcontig->HapSite[0])) || VERB>=2){
	  printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
	  fflush(stdout);
	  assert(HapSite == pcontig->HapSite[0]);
	}

	if(DEBUG>=2){
	  memcpy(newLPA1,startLPA1,MD*sizeof(double));
	  memcpy(newLPA2,startLPA2,MD*sizeof(double));
	  memcpy(testLPA1,newLPA,MD*sizeof(double));
	}

	hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* needed to update N1,N2,Y1,Y2 etc */

//	rverb = (iter>=24 ? 1 : 0);
	nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
//	rverb = 0;

	if((DEBUG && !(fabs(nLP - newLP) < HLP_MINDELTA && SNPcnt == SNPs && IndelCnt == Indels)) || VERB>=1+RELEASE/* HERE >=2 */){
	  if(DEBUG>=2 && !(fabs(nLP - newLP) < HLP_MINDELTA)){
	    double cumtest = 0.0, cumnew = 0.0;
	    for(int m = 0; m < MD; m++){
	      if(fabs(newLPA1[m] - startLPA1[m])*TBmapWT[m] >= HLP_MINDELTA)
		printf("LPA1[%d]=%0.10f -> %0.10f (err=%0.10f,TBmapWT=%0.10f)\n",m,newLPA1[m],startLPA1[m],startLPA1[m]-newLPA1[m],TBmapWT[m]);
	      if(fabs(newLPA2[m] - startLPA2[m])*TBmapWT[m] >= HLP_MINDELTA)
		printf("LPA2[%d]=%0.10f -> %0.10f (err=%0.10f,TBmapWT=%0.10f)\n",m,newLPA2[m],startLPA2[m],startLPA2[m]-newLPA2[m],TBmapWT[m]);
	      cumtest += testLPA1[m] * TBmapWT[m];
	      cumnew += newLPA[m] * TBmapWT[m];
	      if(fabs(testLPA1[m] - newLPA[m]) * TBmapWT[m] >= HLP_MINDELTA)
		printf("LPA[%d]=%0.10f -> %0.10f (err=%0.10f, TBmapWT=%0.10f), cum=%0.10f -> %0.10f (err=%0.10f\n",
		       m,testLPA1[m],newLPA[m],newLPA[m]-testLPA1[m], TBmapWT[m], cumtest, cumnew, cumnew - cumtest);
	    }
	  }
	  if(!(fabs(nLP - newLP) < HLP_MINDELTA))
	    printf("WARNING:After calling repositionH(shift=%0.4f):hprobeval = %0.10f -> %0.10f (err=%0.10f), SNPs=%d->%d, Indels=%d->%d(Filtered=%d)\n",
		   shift,newLP,nLP,nLP-newLP,SNPcnt,SNPs, IndelCnt, Indels,Filtered);
	  else
	    printf("After calling repositionH(shift=%0.4f):hprobeval = %0.10f -> %0.10f (err=%0.10f), SNPs=%d->%d, Indels=%d->%d(Filtered=%d)\n",
		   shift,newLP,nLP,nLP-newLP,SNPcnt,SNPs, IndelCnt, Indels,Filtered);
	  fflush(stdout);

	  //if(!(shift > 0.0)) assert(fabs(nLP - newLP) < nLP * 1e-5);// Can happen due to Hcuts[] adjustment and its weak effect on setlimit etc
	}

	newLP = nLP;
	SNPcnt = SNPs;
	IndelCnt = Indels;
      }
      
      // NOTE : repositionH() just added mappings from unaligned labels in X to Hcuts hence cleaning map1,map2 is not advised 

      if(VERB/* HERE >=2 */ || HapUpdatemapSkip > 0){/* restore previous RANGE etc and check value of LP */
	if(DELTA_X != startDELTA_X || DELTA_Y != startDELTA_Y || RANGE != startRANGE || RANGE_Y != startRANGE_Y || 
	   OutlierType != startOutlierType || outlierLambda != startOutlierLambda || Poutlier != startPoutlier || PoutlierEnd != startPoutlierEnd) {

	  if(VERB){
	    printf("Restoring deltaX=%d->%d,deltaY=%d->%d,RANGE=%d->%d,RANGE_Y=%d->%d,OutlierType=%d->%d,outlierLambda=%0.3e->%0.3e,Poutlier=%0.4e->%0.4e,PoutlierEnd=%0.4e->%0.4e:LP=%0.8f:\n",
		   DELTA_X,startDELTA_X,DELTA_Y,startDELTA_Y,RANGE,startRANGE,RANGE_Y,startRANGE_Y,OutlierType,startOutlierType,outlierLambda,startOutlierLambda,Poutlier,startPoutlier,
		   PoutlierEnd, startPoutlierEnd, newLP);
	    fflush(stdout);
	  }
	  DELTA_X = startDELTA_X;
	  DELTA_Y = startDELTA_Y;
	  RANGE = startRANGE;
	  RANGE_Y = startRANGE_Y;
	  OutlierType = startOutlierType;
	  outlierLambda = startOutlierLambda;
	  Poutlier = startPoutlier;
	  PoutlierEnd = startPoutlierEnd;

//	  rverb = (iter>=24) ? 1 : 0;
	  nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			  TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
//	  rverb = 0;
	  if(VERB){
	    printf("    LP=%0.8f -> %0.8f, SNPs=%d,Indels=%d\n",newLP,nLP,SNPs,Indels);
	    fflush(stdout);
	  }
	  newLP = nLP;
	  SNPcnt = SNPs;
	  IndelCnt = Indels;
	}
      }
      if(newLP < startLP + HapSkipEps + HapSkipEpsPermap * MD)
	HapUpdatemapSkipcnt = HapUpdatemapSkip;
      if(VERB){
	if(newLP < startLP - 1e-5)
	  printf("WARNING: LP dropped from %0.8f to %0.8f (delta=%0.8f) during UpdateMap and repositionH: cum wall time=%0.6f (Skipcnt=%d)\n", startLP, newLP, newLP-startLP, wtime(), HapUpdatemapSkipcnt);
	else
	  printf("LP changed from %0.8f to %0.8f (delta=%0.8f) during UpdateMap and repositionH: cum wall time=%0.6f (Skipcnt=%d)\n",startLP, newLP, newLP-startLP,wtime(),HapUpdatemapSkipcnt);
	fflush(stdout);
      }
    }

    if(!HINDELITER(iter)){
      // check if next iteration might be last one : if so DON't skip this iteration AND reduce SKIPMAP_ADD to 1 during current iteration only
      int ntermination = (iter+1 >= maxiter-2) ? 1 : 0;
      if(ntermination && SKIPMAP_ADD>=2){
	if(VERB){
	  printf("iter=%d,maxiter=%d: reducing SKIPMAP_ADD = %d -> %d since next iteration may be last one\n",iter,maxiter,SKIPMAP_ADD, 0 /* WAS157 1 */);
	  fflush(stdout);
	}
	SKIPMAP_ADD = 0;// WAS157 1;
      }

      if(SNPskip < SNPfail && lastiter == iter-1 && !ntermination){
	if(VERB){
	  printf("iter=%d,maxiter=%d,lastiter=%d,SNPfail=%d,SNPskip=%d:Skipping SNP iteration\n",iter,maxiter,lastiter,SNPfail,SNPskip);
	  fflush(stdout);
	}
	SNPskip++;
	continue;
      }
      if(VERB>=2){
	printf("At start of SNP iteration:iter=%d,lastiter=%d,imin=%d,imax=%d\n",iter,lastiter,imin,imax);
	fflush(stdout);
      }
      SNPskip = 0;
    }

    double origDELTA_INTERVAL = DELTA_INTERVAL;
    int maxIN = max(1,DELTA_INTERVALS - 2);
    DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
    if(VERB/* HERE >=2 */ && DELTA_INTERVAL != origDELTA_INTERVAL){
      printf("DELTA_INTERVALS=%d,Hcuts[Lfrozen=%d]=%0.4f,Hcuts[Rfrozen=%d]=%0.4f: DELTA_INTERVAL= %0.6f -> %0.6f\n",
	     DELTA_INTERVALS,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],origDELTA_INTERVAL, DELTA_INTERVAL);
      fflush(stdout);
    }

    if(HapIndelHiRes && DELTA_OVERSAMPLE > 0 && (iter >= HMIN_ITER + 2 * HapIndelHiRes 
	 /* remove following two conditions and adjust -HapIndelHiRes 3 3 -> 1 2 ||HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue*/) 
       && HINDELITER(iter)){
      /* reduce oversampling by 2x */
      int origINITIAL_DELTA_RANGE = localINITIAL_DELTA_RANGE;

      if(VERB){
	printf("Reducing Delta[] value samples from INITIAL_DELTA_RANGE=%d->%d,DELTA_OVERSAMPLE=%d -> %d\n",origINITIAL_DELTA_RANGE,(localINITIAL_DELTA_RANGE+1)/2,DELTA_OVERSAMPLE,DELTA_OVERSAMPLE-1);
	fflush(stdout);
      }

      for(int IN = 0; IN < DELTA_INTERVALS; IN++)
	for(int i = 2; i < localINITIAL_DELTA_RANGE; i += 2)
	  Initial_Delta[IN][i/2] = Initial_Delta[IN][i];
      localINITIAL_DELTA_RANGE = (localINITIAL_DELTA_RANGE+1)/2;
      for(int IN = 0; IN < DELTA_INTERVALS; IN++){
	int orig = DELTA_RANGE[IN];
	DELTA_RANGE[IN] = (DELTA_RANGE[IN]+1/* WAS 2 */)/2;
	DELTA_RANGE[IN] = min(localINITIAL_DELTA_RANGE,DELTA_RANGE[IN]);
	if(DEBUG) assert((orig==0) == (DELTA_RANGE[IN]==0));
	if(HAPSTOP_DEBUG && IN <= maxIN){
	  if(DELTA_RANGE[IN] > 1)
	    printf("Reducing DELTA_RANGE[IN=%d]=%d->%d and reducing values sampled:Initial_Delta[IN][0..%d..%d]= %0.4f,%0.4f .. %0.4f,%0.4f .. %0.4f,%0.4f\n",
		   IN,orig,DELTA_RANGE[IN],DELTA_RANGE[IN]-1,localINITIAL_DELTA_RANGE-1,Initial_Delta[IN][0],Initial_Delta[IN][1],Initial_Delta[IN][DELTA_RANGE[IN]-2],Initial_Delta[IN][DELTA_RANGE[IN]-1],
		   Initial_Delta[IN][localINITIAL_DELTA_RANGE-2],Initial_Delta[IN][localINITIAL_DELTA_RANGE-1]);
	  else
	    printf("Reducing DELTA_RANGE[IN=%d]=%d->%d and reducing values sampled:Initial_Delta[IN][0..%d]= %0.4f .. %0.4f\n",
		   IN,orig,DELTA_RANGE[IN],localINITIAL_DELTA_RANGE-1,Initial_Delta[IN][0],Initial_Delta[IN][localINITIAL_DELTA_RANGE-1]);
	  fflush(stdout);
	}
	if(DEBUG>=1+RELEASE && IN <= maxIN){
	  for(int d = 0; d < DELTA_RANGE[IN]; d++){
	    if(!(fabs(Initial_Delta[IN][d]) < 1000.0)){
	      printf("Initial_Delta[IN=%d][d=%d] = %0.4f is too large\n",IN,d,Initial_Delta[IN][d]);
	      fflush(stdout);
	      assert(fabs(Initial_Delta[IN][d] < 1000.0));
	    }
	    if(d > 0 && !(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0)){
	      printf("Initial_Delta[IN=%d][d=%d,%d] = %0.4f,%0.4f ratio is too large\n",IN,d-1,d,Initial_Delta[IN][d-1],Initial_Delta[IN][d]);
	      fflush(stdout);
	      assert(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0);
	    }
	  }
	}
      }
      
      DELTA_OVERSAMPLE--;
    }

    int startDELTA_X = DELTA_X;
    int startDELTA_Y = DELTA_Y;
    int startRANGE_Y = RANGE_Y;
    int startRANGE = RANGE;
    int startOutlierType = OutlierType;
    double startOutlierLambda = outlierLambda;
    double startPoutlier = Poutlier;
    double startPoutlierEnd = PoutlierEnd;
    double startLRbias = LRbias;
    double startSF = SF[0];
    double startSR = SR[0];
    double startViterbi = HAP_VITERBI_WT;

    /* Add/delete SNPs during even iterations, Add/Delete/Optimize Indels/sizes during odd iterations */
    if(!HINDELITER(iter)){
      // customize OutlierType=1,outlierLambda=1e4,RANGE=4 along with DELTA_X,DELTA_Y,RANGE_Y to improve performance/speed of mprobeval() for adding/deleting labels
      DELTA_X = origDELTA_X;
      DELTA_Y = origDELTA_Y;
      if(RANGE_UPDATE)
	RANGE = origRANGE;/* small value for speed */
      if(outlierLambdaSwitch && !SwitchFade)
	outlierLambda = outlierLambdaLabel;
      if(OutlierTypeSwitch && !SwitchFade){
	OutlierType = OutlierTypeLabel;
	if(OUTLIER_TYPE != OutlierType){
	  printf("WARNING:OutlierTypeSwitch not working because OUTLIER_TYPE in RGentigScore.h is a compile time constant of %d\n",OUTLIER_TYPE);
	  fflush(stdout);
	  OutlierType = OUTLIER_TYPE;
	}
      }
      if(PoutlierSwitch && !SwitchFade)
	Poutlier = PoutlierLabel;
      if(PoutlierEndSwitch && !SwitchFade)
	PoutlierEnd = PoutlierEndLabel;
      if(LRbiasSwitch && !SwitchFade)
	LRbias = LRbiasLabel;
      if(MinSFSwitch && !SwitchFade)
	SF[0] = (MinSFLabelIter > 0 && SNPIterCnt >= MinSFLabelIter) ? origSF: max(origSF, MinSFLabel);
      if(MinSRSwitch && !SwitchFade)
	SR[0] = (MinSRLabelIter > 0 && SNPIterCnt >= MinSRLabelIter) ? origSR : max(origSR, MinSRLabel);
      if(ViterbiSwitch && !SwitchFade)
	HAP_VITERBI_WT = (ViterbiLabelIter > 0 && SNPIterCnt >= ViterbiLabelIter) ? origViterbi/* WAS116 1.0 */ : min(1.0, ViterbiLabel);
	

      RANGE_Y = RANGE_Y2;
      if(DELTA_LIM > 0) DELTA_X = DELTA_LIM;

    } else {

      // customize OutlierType=0,outlierLambda=10,RANGE=4 along with DELTA_X,DELTA_Y,RANGE_Y to improve performance/speed of mprobeval() for resizing intervals
      DELTA_X = origDELTA_X;
      DELTA_Y = origDELTA_Y;
      if(RANGE_UPDATE)
	RANGE = origRANGE;/* small value for speed */
      if(outlierLambdaSwitch && !SwitchFade)
	outlierLambda = outlierLambdaSize;
      if(OutlierTypeSwitch && !SwitchFade){
	OutlierType = OutlierTypeSize;
	if(OUTLIER_TYPE != OutlierType){
	  printf("WARNING:OutlierTypeSwitch not working because OUTLIER_TYPE in RGentigScore.h is a compile time constant of %d\n",OUTLIER_TYPE);
	  fflush(stdout);
	  OutlierType = OUTLIER_TYPE;
	}
      }
      RANGE_Y = RANGE_Y1;
      if(PoutlierSwitch && !SwitchFade)
	Poutlier = PoutlierSize;
      if(PoutlierEndSwitch && !SwitchFade)
	PoutlierEnd = PoutlierEndSize;
      if(LRbiasSwitch && !SwitchFade)
	LRbias = LRbiasSize;
      if(VERB>=2){
	printf("startSF= %0.6f, origSF= %0.6f, MinSFSize= %0.6f, SF[0]= %0.6f\n",startSF, origSF, MinSFSize, SF[0]);
	fflush(stdout);
      }
      if(MinSFSwitch && !SwitchFade)
	SF[0] = (MinSFSizeIter > 0 && IndelIterCnt >= MinSFSizeIter) ? origSF : max(origSF, MinSFSize);
      if(MinSRSwitch && !SwitchFade)
	SR[0] = (MinSRSizeIter > 0 && IndelIterCnt >= MinSRSizeIter) ? origSR : max(origSR, MinSRSize);
      if(ViterbiSwitch && !SwitchFade)
	HAP_VITERBI_WT = (ViterbiSizeIter > 0 && IndelIterCnt >= ViterbiSizeIter) ? origViterbi /* WAS116 1.0 */ : min(1.0, ViterbiSize);
    }

    if(RANGE != startRANGE || RANGE_Y != startRANGE_Y || DELTA_X != startDELTA_X || DELTA_Y != startDELTA_Y || OutlierType != startOutlierType || outlierLambda != startOutlierLambda ||
	Poutlier != startPoutlier || PoutlierEnd != startPoutlierEnd || LRbias != startLRbias || SF[0] != startSF || SR[0] != startSR || HAP_VITERBI_WT != startViterbi){
      if(VERB>=2){
	printf("Calling hprobeval() after switching parameters RANGE etc\n");
	fflush(stdout);
      }

      //      rverb = (iter==4) ? 1 : 0;
      //      rverb = 1;
      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			     TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
      if(VERB>=2 && iter==11){/* display hprobeval around Hcuts[53346 .. 53400] : to help debug missing Het insertion of 8.9kb at that location */
	rverb = 2; 
	double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,startLPA1,startLPA2,Hcuts1[53346],Hcuts1[53400],Hcuts2[53346],Hcuts2[53400],0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	printf("nLP2= %0.8f\n",nLP2);
	fflush(stdout);
      }
      rverb = 0;

      if(VERB/* HERE >=2 */){
	printf("Switched RANGE=%d->%d,RANGE_Y=%d->%d,DELTA_X=%d->%d,DELTA_Y=%d->%d,OutlierType=%d->%d,Lambda=%0.2e->%0.2e,Poutlier=%0.2e->%0.2e,End=%0.2e->%0.2e,LRbias=%0.2e->%0.2e,SF=%0.3f->%0.3f,SR=%0.4f->%0.4f,Vit=%0.2f->%0.2f: LP=%0.8f -> %0.8f,SNPs=%d,Indels=%d: Cum wall time=% 0.6f\n",
	       startRANGE, RANGE, startRANGE_Y, RANGE_Y, startDELTA_X, DELTA_X, startDELTA_Y, DELTA_Y, startOutlierType, OutlierType, startOutlierLambda, outlierLambda, startPoutlier, Poutlier, 
	startPoutlierEnd, PoutlierEnd,startLRbias,LRbias,startSF,SF[0],startSR,SR[0],startViterbi,HAP_VITERBI_WT,newLP, nLP, SNPs,Indels, wtime());
	fflush(stdout);
      }
      newLP = nLP;
      SNPcnt = SNPs;
      IndelCnt = Indels;
    }

    /* check LPhwm for problems with convergence */
    if(HINDELITER(iter)){
      if(newLP < LPhwm - 1e-5){
	LPdrop_count++;
	printf("WARNING: At start of iter=%d: LP=%0.8f, LPhwm=%0.8f (drop=%0.8f, cnt=%d)\n", 
	       iter, newLP, LPhwm, newLP - LPhwm, LPdrop_count);
	fflush(stdout);
	if(newLP < LPhwm - HLP_MAXDROP*MD || LPdrop_count >= HLP_DROP_CNT){
	  printf("Will try to terminate Haplotyping due to drop=%0.6f,MD=%d,cnt=%d:iter=%d,lastiter=%d->%d\n",newLP-LPhwm,MD,LPdrop_count,iter,lastiter,min(lastiter,iter-2));
	  fflush(stdout);

	  lastiter = min(lastiter,iter-2);
	  goto Lbreakout;

	  // assert(newLP >= LPhwm - 0.01);
	}
      }
      if(newLP > LPhwm){
	LPhwm = newLP;
	LPdrop_count = 0;
      }
    }

    if(DELTA_STOP >= 2 && SKIPMAP_ADD >= 2){// NEW3
      int inactivecnt = 0;/* number of already inactive intervals in current iter */
      for(int IN = 0; IN <= maxIN; IN++)
	inactivecnt += (DELTA_RANGE[IN] <= 0) ? 1 : 0;

      if(inactivecnt >= maxIN + 1)
	goto Lbreakout;
    }

    {/* braces to protect region till Lbreakout label */

      if(DEBUG){/* check that all Delta[i] and HapDelta[i] values are zero if HapSite[i]==0 */
	for(int i = 1; i <= n; i++)
	  if(!HapSite[i] && (Delta[i] || HapDelta[i])){
	    printf("i=%d,n=%d:HapSite[i]=%d,Delta[i]=%0.10f,HapDelta[i]=%0.10f\n",i,n,HapSite[i],Delta[i],HapDelta[i]);
	    fflush(stdout);
	    assert(!(Delta[i] || HapDelta[i]));
	  }
      }

      /* HapDelta[] should be aggregated between the nearest labels LL,RR with HapSite[LL,RR] = 3 to avoid multiple HapDelta penalties for a single Het indel with multiple added/deleted labels

	 Originally (HINDEL_MERGE==0) both HapDelta[] and Delta[] are aggregated to the nearest left site L with HapSite[L] != 0.
	 Fixing this requires changes in multiple places: Currently the code assumes that consecutive labels L,R with HapSite[L]=1 and HapSite[R] =2 (or the other way round) don't reverse order 
	 in Hcuts1[],Hcuts2[]. 

	 A solution (HINDEL_MERGE==2) is to penalize only once per interval Hcuts[LL..RR] with HapSite[LL,RR]=3 and HapSite[L+1..R-1] < 3 but still break the HapIndel[] values into subintervals
	 so ordering of labels with HapSite[i] != 0 is maintained in both Hcuts1[] and Hcuts2[].

      */

      /* temporarily spread out HapDelta[],Delta[] so Hcuts[] remain monotonic : required by mprobeval(), but not by qprobeval(), which only requires Y[] to be monotonic */
      memcpy(startHapDelta,HapDelta,(n+2)*sizeof(double));
      memcpy(startDelta,Delta,(n+2)*sizeof(double));
      int L = 0;
      for(int i = 0; i <= n; i++){
	if(i && !HapSite[i])
	  continue;
	int R = i+1;
	while(R <= n && !HapSite[R])
	  R++;
	/*	if(R > n)
		break;*/
	if(DEBUG && !(Hcuts[R] >= Hcuts[i] && (!(HapSite[R] & HapSite[i]) || Hcuts[R] > Hcuts[i]))){
	  printf("Before iter=%d:i=%d,R=%d,HapSite[i,R]=%d,%d,Hcuts[i,R]=%0.8f,%0.8f\n",iter,i,R,HapSite[i],HapSite[R],Hcuts[i],Hcuts[R]);
	  fflush(stdout);
	  assert(Hcuts[R] >= Hcuts[i] && (!(HapSite[R] & HapSite[i]) || Hcuts[R] > Hcuts[i]));
	}
	if(DEBUG && !isfinite(HapDelta[i])){
	  printf("Before iter=%d:i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
		 iter,i,n,HapDelta[i],Delta[i],HapSite[i],R,HapSite[R]);
	  fflush(stdout);
	  assert(isfinite(HapDelta[i]));
	}

	if(HapDelta[i] && R > i+1){
	  if(DEBUG && !(HapSite[i] || HapSite[R] || (i==0 && R==n+1))){
	    printf("iter=%d:i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
		   iter,i,n,HapDelta[i],Delta[i],HapSite[i],R,HapSite[R]);
	    fflush(stdout);
	    assert(HapSite[i] || HapSite[R] || (i==0 && R==n+1));
	  }
	  if(Hcuts[R] > Hcuts[i]){
	    double scale = HapDelta[i] / (Hcuts[R]-Hcuts[i]);
	    if(DEBUG) assert(isfinite(scale));
	    for(int t = i; t < R; t++)
	      HapDelta[t] = scale * (Hcuts[t+1] - Hcuts[t]);
	  } else {/* Hcuts[R] == Hcuts[i] */
	    double scale = HapDelta[i] / (R - i);
	    if(DEBUG) assert(isfinite(scale));
	    for(int t = i; t < R; t++)
	      HapDelta[t] = scale;
	  }
	}

	if(DEBUG && !isfinite(Delta[i])){
	  printf("Before iter=%d:i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
		 iter,i,n,HapDelta[i],Delta[i],HapSite[i],R,HapSite[R]);
	  fflush(stdout);
	  assert(isfinite(Delta[i]));
	}
	if(Delta[i] && R > i+1){
	  if(DEBUG && !(HapSite[i] || HapSite[R] || (i==0 && R==n+1))){
	    printf("iter=%d:i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
		   iter,i,n,HapDelta[i],Delta[i],HapSite[i],R,HapSite[R]);
	    fflush(stdout);
	    assert(HapSite[i] || HapSite[R] || (i==0 && R==n+1));
	  }
	  if(Hcuts[R] > Hcuts[i]){
	    double scale = Delta[i] / (Hcuts[R]-Hcuts[i]);
	    if(DEBUG) assert(isfinite(scale));
	    for(int t = i; t < R; t++)
	      Delta[t] = scale * (Hcuts[t+1] - Hcuts[t]);
	  } else {/* Hcuts[R] == Hcuts[i] */
	    double scale = Delta[i] / (R - i);
	    if(DEBUG) assert(isfinite(scale));
	    for(int t = i; t < R; t++)
	      Delta[t] = scale;
	  }
	}
	L = i;
	i = R - 1;
      }

      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,0,0);/* generate haplotype consensus map pair */
      double LPstart = newLP;
      if(DEBUG>=2){
	for(int i = 1; i <= n+1; i++){
	  assert(Hcuts1[i] >= Hcuts1[i-1]);
	  assert(Hcuts2[i] >= Hcuts2[i-1]);
	}

	int origrverb = rverb;
	//    rverb = 1;
	LPstart = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				   TBmapWT,startLPA1,startLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	rverb = origrverb;

	if(DEBUG && !(fabs(LPstart-newLP) < 2e-6)){
	  if(startRANGE == RANGE && startRANGE_Y == RANGE_Y && startDELTA_X == DELTA_X && startDELTA_Y == DELTA_Y && startOutlierType == OutlierType && startOutlierLambda == outlierLambda 
	     && startPoutlier == Poutlier && startPoutlierEnd == PoutlierEnd){
	    printf("WARNING:iter=%d:hprobeval=%0.6f(expected newLP=%0.6f), err=%0.8f\n",iter,LPstart,newLP,fabs(LPstart-newLP));
	    fflush(stdout);
	    //      assert(fabs(LPstart-newLP) < 2e-6);
	  }
	}
	if(VERB/* HERE >=2 */){
	  printf("iter=%d:After spreading HapDelta[],Delta[]: LP=%0.10f -> %0.10f,SNPs=%d,Indels=%d: cum wall time= %0.6f\n",
		 iter, newLP, LPstart,SNPs,Indels, wtime());

	  if(VERB>=3)
	    for(int u = 1; u <= n; u++)
	      printf("\t u=%d:Hcuts1[u]= %0.8f, Hcuts2[u]= %0.8f, skip[u]= %d, Hcuts[u]= %0.8f, HapSite[u]=%d, HapDelta[u]= %0.8f, Delta[u]= %0.8f\n",
		     u, Hcuts1[u], Hcuts2[u], skip[u], Hcuts[u], HapSite[u], HapDelta[u], Delta[u]);

	  fflush(stdout);
	}
	SNPcnt = SNPs;
	IndelCnt = Indels;
	newLP = LPstart;/* The LP value after making any changes to RANGE etc and HapDelta[],HapSite[] in this iteration */
      }

      // NOTE : LPstart is value of LP before calling mprobeval() and performing updates based on mprobeval() predictions
      //        newLP keeps track of the current best LP
      //        nLP etc keep track of LP of some tested modification

      /* copy startLPA[] to bestLPA[] */
      memcpy(bestLPA1,startLPA1,MD*sizeof(double));
      memcpy(bestLPA2,startLPA2,MD*sizeof(double));
      
      if(VERB>=3){
	printf("startLPA1[1]=%0.8f,startLPA2[1]=%0.8f\n",startLPA1[1],startLPA2[1]);
	printf("startLPA1[491]=%0.8f,startLPA2[491]=%0.8f\n",startLPA1[491],startLPA2[491]);
	fflush(stdout);
      }

      if(HSNP_FAST){/* initialize  delid1[1..N1], delid2[1..N2] */
	int I1 = 0, I2 = 0;
	for(int i = 1; i <= n; i++){
	  if(!Hdel1[i])
	    delid1[++I1] = i;
	  if(!Hdel2[i])
	    delid2[++I2] = i;
	  if(DEBUG) assert(Hdel1[i]==0 || Hdel1[i]==1);
	  if(DEBUG) assert(Hdel2[i]==0 || Hdel2[i]==1);
	}
	if(DEBUG) assert(I1 == N1);
	if(DEBUG) assert(I2 == N2);
      }

      if(VERB){  
	/* compute DelCum[i+1] = Sum(Delta[0..i]) and HapDelCum[] */
	double DeltaCum = 0.0, HapDeltaCum = 0.0;
	int ileft = n+1, iright = 0;

	for(int i = 0; i <= n; i++){
	  HapDelCum[i+1] = HapDeltaCum += HapDelta[i];
	  DelCum[i+1] = DeltaCum += Delta[i];
	  if(HapSite[i]){
	    ileft = min(i,ileft);
	    iright = max(i,iright);
	  }
	}

	printf("n=%d,imin=%d,imax=%d,N1=%d,N2=%d,Indels=%d,SNPs=%d:hprobeval=%0.6f(HapSiteConf= %0.2f, HapIndelConf= %0.2f, left=%0.4f(%0.4f,%0.4f),right=%0.4f(%0.4f,%0.4f)): elapsed wall time=%0.6f\n",
	       n,imin,imax,N1,N2,IndelCnt,SNPcnt,LPstart,-logHapSitePvalue/log(10.0),-logHapIndelPvalue/log(10.0), 
	       Hcuts[ileft], Hcuts[ileft] + DelCum[ileft] + HapDelCum[ileft], Hcuts[ileft] + DelCum[ileft] - HapDelCum[ileft],
	       Hcuts[iright], Hcuts[iright] + DelCum[iright] + HapDelCum[iright], Hcuts[iright] + DelCum[iright] - HapDelCum[iright], wtime());
	fflush(stdout);
      }

      /* save original N1,N2,SNPcnt,IndelCnt so we can use mprobeval to predict change in LP from changing one SNP/site/indel/interval relative to the current state, even after other changes have been confirmed */
      int startN1 = N1, startN2 = N2;
      int startSNPcnt = SNPcnt, startIndelCnt = IndelCnt;
      /* Hdel1[],Hdel2[],Y1[],Y2[] change as Indels/SNPs are modified : save original values */
      memcpy(startHcuts1,Hcuts1,(n+2)*sizeof(double));
      memcpy(startHcuts2,Hcuts2,(n+2)*sizeof(double));
      memcpy(startHdel1,Hdel1,(n+2)*sizeof(int));
      memcpy(startHdel2,Hdel2,(n+2)*sizeof(int));
      memcpy(startY1,Y1,(N1+2)*sizeof(double));
      memcpy(startY2,Y2,(N2+2)*sizeof(double));

      double minKBadd = max(rres * 0.500, HapSiteRes);
      minKBadd = max(minKB,minKBadd);

      int inactivecnt = 0;/* number of already inactive intervals in current iter */
      for(int IN = 0; IN <= maxIN; IN++)
	inactivecnt += (DELTA_RANGE[IN] <= 0) ? 1 : 0;
      if(VERB/* HERE >=2 */ && iter >= HMIN_ITER){
	printf("iter=%d:inactivecnt= %d, maxIN+1= %d\n",iter,inactivecnt,maxIN+1);
	fflush(stdout);
      }

      if(!HINDELITER(iter)) {

	if(SKIPMAP_ADD <= 1 || inactivecnt == 0  /* NEW137 */)
	  HapSiteScoreIter = iter;

	/* compute addloc1[] : all possible sites with Hdel1[] that are not within minKB of another existing site AND skip[i]==0 (site is not at the same location as another site) */
	/* Don't add new site i on Allele 1 if (HapSite[L]&1) and Hcuts[i]-Hcuts[L]+Delta[L..i-1]+HapDelta[L..i-1] < minKBadd */
    
        if(VERB>=2 && iter==0){
	  printf("iter=%d:Computing addloc1[]:imin=%d,imax=%d\n",iter,imin,imax);
	  fflush(stdout);
	}

	addcnt1 = 0;
	L = 0;

	for(int i = 1; i <= imax; i++){
          if((HapSite[i-1] & 1))
	    L = i-1;

	  if(!Hdel1[i])
	    continue;
	  if(i < imin)
	    continue;
	  if(skip[i] > 0){
	    if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
	      printf("Skipping adding site i=%d in Allele 1 due to skip[i]=%d: Hcuts[i]= %0.6f, HapSite[i]=%d\n", i,skip[i],Hcuts[i],HapSite[i]);
	      fflush(stdout);
	    }

	    continue;
	  }
	  
	  if(DELTA_STOP >= 2 && iter >= HMIN_ITER && (SKIPMAP_ADD>=2 || !HapSite[i])){// NOTE: Unless SKIPMAP_ADD>=2, only suppress if there is not already a label for Allele 1 or 2
	    int IN = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
	    if(DEBUG && !(0 <= IN && IN <= maxIN)){
	      printf("i=%d:IN=%d,maxIN=%d:Lfrozen=%d,i=%d,Rfrozen=%d,Hcuts[Lfrozen,i,Rfrozen]=%0.3f,%0.3f,%0.3f,DELTA_INTERVALS=%d\n",
		     i,IN,maxIN,Lfrozen,i,Rfrozen,Hcuts[Lfrozen],Hcuts[i],Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVALS);
	      fflush(stdout);
	      assert(0 <= IN && IN <= maxIN);
	    }
	    if(DELTA_RANGE[IN] <= 0) {
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d in Allele 1 since region around Hcuts[i]= %0.6f has stabilized (IN=%d)\n", i,Hcuts[i],IN);
		fflush(stdout);
	      }
	      
	      continue;
	    }
	  }

	  //  Only suppress adding Allele 1 label at Hcuts[i] if there is not already an Allele 2 label at Hcuts[i], otherwise HapSiteScore[i] and SiteScore[i] will not be correct
	  //     Adding them will still be suppressed after calling mprobeval and computing HapSiteScore[],Sitescore[i]
	  //     Exception : avoid adding a label closer than minKB to an existing label, since mprobeval() considers duplicate labels an error and hsetmap() would fail anyway if closer than minKB.

 	  if(DUP_FIX && !HapSite[i]){ /* also check that no existing site is at the same location as Hcuts[i] (Unless there is already a SNP at Hcuts[i]) */
	    int t = i;
	    while(--t > 0)
	      if(HapSite[t] || Hcuts[t] + 1e-3 < Hcuts[i])
		break;
	    if(Hcuts[t] + 1e-6 >= Hcuts[i] && HapSite[t]){
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d to Allele 1 since site t=%d is at same location : HapSite[i,t]=%d,%d,Hcuts[i,t]=%0.6f,%0.6f\n",
		       i,t,HapSite[i],HapSite[t],Hcuts[i],Hcuts[t]);
		fflush(stdout);
	      }
	      continue;
	    }

	    for(t = i; ++t <= n;)
	      if(HapSite[t] || Hcuts[t] > Hcuts[i] + 1e-3)
		break;
	    if(Hcuts[t] <= Hcuts[i] + 1e-6 && HapSite[t]){
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d to Allele 1 since site t=%d is at same location : HapSite[i,t]=%d,%d,Hcuts[i,t]=%0.6f,%0.6f\n",
		       i,t,HapSite[i],HapSite[t],Hcuts[i],Hcuts[t]);
		fflush(stdout);
	      }
	      continue;
	    }
	  }

	  if((HapSite[L] & 1)){
	    double hapdelta = 0.0, delta = 0.0;
	    for(int t = L; t < i; t++){
	      hapdelta += HapDelta[t];
	      delta += Delta[t];
	    }
	    if(Hcuts[i] - Hcuts[L] + delta + hapdelta < (HapSite[i] ? minKB : minKBadd)/* NEW */){
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d since site L=%d is too close on Allele 1: Hcuts[L,i]= %0.6f,%0.6f, HapSite[L,i]=%d,%d,HapDelta[L..i]=%0.6f,Delta[L..i]=%0.6f,minKBadd=%0.6f,minKB=%0.6f\n",
		       i,L,Hcuts[L],Hcuts[i],HapSite[L],HapSite[i],hapdelta,delta,minKBadd,minKB);
		fflush(stdout);
	      }
	      continue;
	    }
	  }

	  int R = i+1;
	  while(R < n && !(HapSite[R]&1))
	    R++;
	  if(DEBUG) assert(R <= n || i >= n);
	  if((HapSite[R] & 1)){
	    double hapdelta = 0.0, delta = 0.0;	
	    for(int t = i; t < R; t++){
	      hapdelta += HapDelta[t];
	      delta += Delta[t];
	    }
	    if(Hcuts[R] - Hcuts[i] + delta + hapdelta < (HapSite[i] ? minKB : minKBadd)/* NEW */){
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d since site R=%d is too close on Allele 1: Hcuts[i,R]= %0.6f,%0.6f, HapSite[i,R]=%d,%d,HapDelta[i..R]=%0.6f,Delta[i..R]=%0.6f,minKBadd=%0.6f,minKB=%0.6f\n",
		       i,R,Hcuts[i],Hcuts[R],HapSite[i],HapSite[R],hapdelta,delta,minKBadd,minKB);
		fflush(stdout);
	      }
	      continue;
	    }
	  }

	  if(DEBUG/* HERE >=2 */ && SKIP_DIST_FIX && addcnt1 > 0){
	    if(DEBUG && !(Hcuts1[i] >= addloc1[addcnt1-1])){
	      int t = addid1[addcnt1 - 1];
	      int LL = L;
	      while(LL > 0 && HapSite[LL] != 3)
		LL--;
	      int RR = R;
	      while(RR <= n && HapSite[RR] != 3)
		RR++;
	      printf("LL=%d,L=%d,t=%d,i=%d,R=%d,RR=%d:addloc1[%d]= %0.8f, Hcuts1[LL,L,t,i,R,RR]= %0.6f,%0.6f,%0.6f,%0.6f,%0.6f,%0.6f, skip[t,i]=%d,%d, Hcuts[LL,L,t,i,R,RR]= %0.6f,%0.6f,%0.6f,%0.6f,%0.6f,%0.6f\n",
		     LL,L,t,i,R,RR,addcnt1-1,addloc1[addcnt1 - 1], Hcuts1[LL],Hcuts1[L],Hcuts1[t], Hcuts1[i], Hcuts1[R], Hcuts1[RR], skip[t],skip[i],Hcuts[LL],Hcuts[L],Hcuts[t],Hcuts[i],Hcuts[R],Hcuts[RR]);
	      for(int u = LL; u <= RR; u++)
		printf("\t u=%d:Hcuts1[u]= %0.8f, skip[u]= %d, Hcuts[u]= %0.8f, HapSite[u]=%d, HapDelta[u]= %0.8f, Delta[u]= %0.8f\n",
		       u, Hcuts1[u], skip[u], Hcuts[u], HapSite[u], HapDelta[u], Delta[u]);
	      fflush(stdout);
	      // NOTE : Following assertion can be violated if indels are large : this only causes a problem because mprobeval assumes addloc1[] values are in ascending order
	      //        Problem could be fixed by having mprobeval remap[] the index of addloc1[] so they are in ascending order then remap the results so they correspond to the original order
	      assert(Hcuts1[i] + 1e-6 >= addloc1[addcnt1 - 1]);
	      Hcuts1[i] = max(Hcuts1[i], addloc1[addcnt1 - 1]);
	    }
	  }

	  if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
	    printf("iter=%d,i=%d: addid1[%d]=i,Hcuts1[i]=%0.4f\n",iter,i,addcnt1,Hcuts1[i]);
	    fflush(stdout);
	  }

	  addid1[addcnt1] = i;
	  if(DEBUG) assert(imin <= i && i <= imax);
	  addloc1[addcnt1++] = Hcuts1[i];
	}

	/* compute addloc2[] : all possible sites with Hdel2[] that are not within minKB of another existing site AND skip[i]==0 (site is not at the same location as another site) */
	/* Don't add site i on Allele 2 if for last site L (HapSite[L]&2) and Hcuts[i]-Hcuts[L]+Delta[L..i-1] - HapDelta[L..i-1] < minKBadd */

	addcnt2 = 0;
	L = 0;
	for(int i = 1; i <= imax; i++){
	  if((HapSite[i-1] & 2))
	    L = i-1;

	  if(i < imin)
	    continue;
	  if(!Hdel2[i])
	    continue;
	  if(skip[i] > 0){
	    if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
	      printf("Skipping adding site i=%d in Allele 2 due to skip[i]=%d: Hcuts[i]= %0.6f, HapSite[i]=%d\n", i,skip[i],Hcuts[i],HapSite[i]);
	      fflush(stdout);
	    }
	    continue;
	  }

	  if(DELTA_STOP >= 2 && iter >= HMIN_ITER && (SKIPMAP_ADD>=2 || !HapSite[i])){// NOTE: Unless SKIPMAP_ADD>=2, only suppress if there is not already a label for Allele 1 or 2
	    int IN = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
	    if(DEBUG) assert(0 <= IN && IN <= maxIN);
	    if(DELTA_RANGE[IN] <= 0){
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d in Allele 2 since region around Hcuts[i]= %0.6f has stabilized (IN=%d)\n", i,Hcuts[i],IN);
		fflush(stdout);
	      }

	      continue;
	    }
	  }

	  // Only suppress adding Allele 2 label at Hcuts[i] if there is not already an Allele 1 label at Hcuts[i], otherwise HapSiteScore[i] and SiteScore[i] will not be correct
	  //       Adding them will still be suppressed after calling mprobeval and computing HapSiteScore[],Sitescore[i]
	  //       Exception : avoid adding a label closer than minKB to an existing label on Allele 2, since mprobeval() consider duplicate labels an error and hsetmap() would fail anyway if closer than minKB.

	  if(DUP_FIX && !HapSite[i]){ /* also check that no existing site is at the same location as Hcuts[i] */
	    int t = i;
	    while(--t > 0)
	      if(HapSite[t] || Hcuts[t] + 1e-3 < Hcuts[i])
		break;
	    if(Hcuts[t] + 1e-6 >= Hcuts[i] && HapSite[t]){
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d to Allele 2 since site t=%d is at same location : HapSite[i,t]=%d,%d,Hcuts[i,t]=%0.6f,%0.6f\n",
		       i,t,HapSite[i],HapSite[t],Hcuts[i],Hcuts[t]);
		fflush(stdout);
	      }
	      continue;
	    }
	    for(t = i; ++t <= n;)
	      if(HapSite[t] || Hcuts[t] > Hcuts[i] + 1e-3)
		break;
	    if(Hcuts[t] <= Hcuts[i] + 1e-6 && HapSite[t]){
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d to Allele 2 since site t=%d is at same location : HapSite[i,t]=%d,%d,Hcuts[i,t]=%0.6f,%0.6f\n",
		       i,t,HapSite[i],HapSite[t],Hcuts[i],Hcuts[t]);
		fflush(stdout);
	      }
	      continue;
	    }
	  }

	  if((HapSite[L]&2)){
	    double hapdelta = 0.0, delta = 0.0;
	    for(int t = L; t < i; t++){
	      hapdelta += HapDelta[t];
	      delta += Delta[t];
	    }
	    if(Hcuts[i] - Hcuts[L] + delta - hapdelta < (HapSite[i] ? minKB : minKBadd)/* NEW */){
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d since site L=%d is too close on Allele 2: Hcuts[L,i]= %0.6f,%0.6f, HapSite[L,i]=%d,%d,HapDelta[L..i]=%0.6f,Delta[L..i]=%0.6f,minKBadd=%0.6f,minKB=%0.6f\n",
		       i,L,Hcuts[L],Hcuts[i],HapSite[L],HapSite[i],hapdelta,delta,minKBadd,minKB);
		fflush(stdout);
	      }
	      continue;
	    }
	  }

	  int R = i+1;
	  while(R < n && !((HapSite[R] & 2)))
	    R++;
	  if(DEBUG) assert(R <= n || i >= n);

	  if((HapSite[R] & 2)){
	    double hapdelta = 0.0, delta = 0.0;	
	    for(int t = i; t < R; t++){
	      hapdelta += HapDelta[t];
	      delta += Delta[t];
	    }
	    if(Hcuts[R] - Hcuts[i] + delta - hapdelta < (HapSite[i] ? minKB : minKBadd)){
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		printf("Skipping adding site i=%d since site R=%d is too close on Allele 2: Hcuts[i,R]= %0.6f,%0.6f, HapSite[i,R]=%d,%d,HapDelta[i..R]=%0.6f,Delta[i..R]=%0.6f,minKBadd=%0.6f,minKB=%0.6f\n",
		       i,R,Hcuts[i],Hcuts[R],HapSite[i],HapSite[R],hapdelta,delta,minKBadd,minKB);
		fflush(stdout);
	      }
	      continue;
	    }
	  }

	  if(DEBUG/* HERE >=2 */ && SKIP_DIST_FIX && addcnt2 > 0 && !(Hcuts2[i] >= addloc2[addcnt2-1])){
	    int k = addid2[addcnt2-1];
	    double hapdelta = 0.0, delta = 0.0;	
	    for(int t = k; t < i; t++){
	      hapdelta += HapDelta[t];
	      delta += Delta[t];
	    }
	    #pragma omp critical
	    {
	      printf("addcnt2=%d,addid2[addcnt2-1]=k=%d,Hcuts2[k]= %0.6f, addloc2[addcnt2 - 1]= %0.6f, i=%d, L=%d, Hcuts2[i]= %0.6f, HapSite[k,i]= %d,%d, HapDelta[k..i-1]= %0.6f, Delta[k..i-1]= %0.6f,minKBadd=%0.6f\n",
		     addcnt2, k, Hcuts2[k], addloc2[addcnt2 - 1], i, L, Hcuts2[i], HapSite[k], HapSite[i], hapdelta, delta, minKBadd);
	      for(int t = min(k,L); t <= i; t++)
		if(HapSite[t] || HapDelta[t] || Delta[t])
		  printf("\t t=%d: Hcuts[t]= %0.6f, Hcuts1[t]= %0.6f, Hcuts2[t]= %0.6f, HapSite[t]= %d, HapDelta[t]= %0.6f, Delta[t]= %0.6f\n",
			 t, Hcuts[t], Hcuts1[t], Hcuts2[t], HapSite[t], HapDelta[t], Delta[t]);
	      fflush(stdout);

	      assert(Hcuts2[i] + 1e-6 >= addloc2[addcnt2 - 1]);
	      Hcuts2[i] = max(Hcuts2[i], addloc2[addcnt2 - 1]);
	    }
	  }

	  if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
	    printf("iter=%d,i=%d: addid2[%d]=i,Hcuts2[i]=%0.4f\n",iter,i,addcnt2,Hcuts2[i]);
	    fflush(stdout);
	  }

	  addid2[addcnt2] = i;
	  if(DEBUG) assert(imin <= i && i <= imax);
	  addloc2[addcnt2++] = Hcuts2[i];
	}
	
	if(DELTA_STOP){/* initialize ID1[S=0..N1] and ID2[S=0..N2] */
	  ID1[0] = 0;
	  ID1[N1] = maxIN;
	  for(int S = 1; S < N1; S++)
	    ID1[S] = -1;
	  for(int S = 1; S < N1; S++){
	    int i = nmap1[MD][S];
	    if(DEBUG) assert(0 < i && i < n);
	    if(DEBUG) assert((HapSite[i] & 1));
	    int r = i+1;
	    while(r < n && !((HapSite[r] & 1)))
	      r++;
	    if(DEBUG) assert(r <= n && (HapSite[r] & 1));
	    if(DEBUG) assert(r == nmap1[MD][S+1]);

	    int IN = floor((Hcuts[i]+(Y1[S+1]-Y1[S])*0.5 - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
	    if(!(0 <= IN && IN <= maxIN)){
	      if(VERB/* HERE >=2 */){
		printf("WARNING:iter=%d,S=%d,N1=%d,i=%d,r=%d,n=%d,Hcuts[i]=%0.4f,Hcuts[Lfrozen]=%0.4f,Y1[S]=%0.4f,Y1[S+1]=%0.4f,Y1[N1]=%0.4f,DELTA_INTERVAL=%0.4f,IN=%d,maxIN=%d\n",
		       iter,S,N1,i,r,n,Hcuts[i],Hcuts[Lfrozen],Y1[S],Y1[S+1],Y1[N1+1],DELTA_INTERVAL,IN,maxIN);
		fflush(stdout);
	      }
	      IN = max(0,min(IN, maxIN));
	    }
	    ID1[S] = IN;
	  }

	  ID2[0] = 0;
	  ID2[N2] = maxIN;
	  for(int S = 1; S < N2; S++)
	    ID2[S] = -1;
	  for(int S = 1; S < N2; S++){
	    int i = nmap2[MD][S];
	    if(DEBUG) assert(0 < i && i < n);
	    if(DEBUG) assert(HapSite[i] & 2);
	    int r = i+1;
	    while(r < n && !(HapSite[r] & 2))
	      r++;
	    if(DEBUG) assert(r <= n && (HapSite[r] & 2));
	    if(DEBUG) assert(r == nmap2[MD][S+1]);

	    int IN = floor((Hcuts[i]+(Y2[S+1]-Y2[S])*0.5 - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
	    if(!(0 <= IN && IN <= maxIN)){
	      if(VERB/* HERE >=2 */){
		printf("WARNING:iter=%d,S=%d,N2=%d,i=%d,r=%d,n=%d,Hcuts[i]=%0.4f,Hcuts[Lfrozen]=%0.4f,Y2[S]=%0.4f,Y2[S+1]=%0.4f,Y2[N2]=%0.4f,DELTA_INTERVAL=%0.4f,IN=%d,maxIN=%d\n",
		       iter,S,N2,i,r,n,Hcuts[i],Hcuts[Lfrozen],Y2[S],Y2[S+1],Y2[N2+1],DELTA_INTERVAL,IN,maxIN);
		fflush(stdout);
	      }
	      IN = max(0,min(IN, maxIN));
	    }
	    ID2[S] = IN;
	  }
	}
      } // if(!HINDELITER(iter))

      int Dcnt1 = -1, Dcnt2 = -1;

      delete deltamem; deltamem = NULL;/* in case it is still allocated */

      if(HINDELITER(iter)) {

	if(VERB>=3 && iter <= 15){
	  printf("iter=%d: Initializing delta1[S=1..N1-1], N1=%d\n",iter,N1);
	  fflush(stdout);
	}

	/* allocate memory for two sets of D[],delta[][],LPdelta[] */
	int deltasiz1 = (N1+1) * (2*INITIAL_DELTA_RANGE + MAX_INDEL);
	int deltasiz2 = (N2+1) * (2*INITIAL_DELTA_RANGE + MAX_INDEL);
	size_t deltasiz = (deltasiz1 + deltasiz2) * sizeof(double) + (N1+1+N2+1)*sizeof(int) * 2 + (N1+1+N2+1)*sizeof(double *) * 2;
	if(MDEBUG)
	  deltasiz += (deltasiz1 + deltasiz2) * sizeof(double);
	if((deltamem = (char *)malloc(deltasiz)) == NULL){
	  printf("Failed to allocate %lu bytes of memory:N1=%d,N2=%d,INITIAL_DELTA_RANGE=%d,MAX_INDEL=%d\n",deltasiz,N1,N2,INITIAL_DELTA_RANGE,MAX_INDEL);
	  fflush(stdout);exit(1);
	}
	size_t deltacnt = 0;
	D1 = (int *) &deltamem[deltacnt]; deltacnt += (N1+1)*sizeof(int);
	DR1 = (int *) &deltamem[deltacnt]; deltacnt += (N1+1)*sizeof(int);
	delta1 = (double **) &deltamem[deltacnt]; deltacnt += (N1+1)*sizeof(double *);
	delta1mem = (double *)  &deltamem[deltacnt]; deltacnt += deltasiz1 * sizeof(double);
	if(MDEBUG){
	  LPdelta1 = (double **) &deltamem[deltacnt]; deltacnt += (N1+1)*sizeof(double *);
	  LPdelta1mem = (double *) &deltamem[deltacnt]; deltacnt += deltasiz1 * sizeof(double);
	}
	if(DEBUG) assert(deltacnt <= deltasiz);

	D2 = (int *) &deltamem[deltacnt]; deltacnt += (N2+1)*sizeof(int);
	DR2 = (int *) &deltamem[deltacnt]; deltacnt += (N2+1)*sizeof(int);
	delta2 = (double **) &deltamem[deltacnt]; deltacnt += (N2+1)*sizeof(double *);
	delta2mem = (double *) &deltamem[deltacnt]; deltacnt += deltasiz2 * sizeof(double);
	if(MDEBUG){
	  LPdelta2 = (double **) &deltamem[deltacnt]; deltacnt += (N2+1)*sizeof(double *);
	  LPdelta2mem = (double *) &deltamem[deltacnt]; deltacnt += deltasiz2 * sizeof(double);
	}

	if(DEBUG) assert(deltacnt <= deltasiz);

	if(TIME_VERBOSE){
	  getmem(VmSize,VmRSS, VmSwap);
	  double InvGB = 1e-9;	
	  printf("iter=%d:After Re-Allocation of two sets of D[],delta[],LPdelta[] for N1=%d,N2=%d,INITIAL_DELTA_RANGE=%d: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: cum wall= %0.6f\n", 
		 iter,N1,N2,INITIAL_DELTA_RANGE, VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB,wtime());
	  fflush(stdout);
	}

	/* reallocate & initialize delta1[S=1..N1-1][d = 0..D[S]-1] = {Initial_Delta[],-Initial_Delta[]} */
	Dcnt1 = 0;
	D1[0] = DR1[0] = ID1[0] = D1[N1] = DR1[N1] = 0;
	ID1[N1] = maxIN;
	for(int S = 1; S < N1; S++)
	  ID1[S] = -1;

	for(int S = 1; S < N1; S++){
	  int i = nmap1[MD][S];
	  if(DEBUG) assert(0 < i && i < n);
	  if(DEBUG) assert((HapSite[i] & 1));
	  int r = i+1;
	  while(r < n && !(HapSite[r] & 1))
	    r++;
	  if(DEBUG) assert(r <= n && (HapSite[r] & 1));
	  if(DEBUG) assert(r == nmap1[MD][S+1]);

	  int IN = floor((Hcuts[i]+(Y1[S+1]-Y1[S])*0.5 - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
	  if(!(0 <= IN && IN <= maxIN)){
	    if(VERB>=2){
	      printf("WARNING:iter=%d,S=%d,N1=%d,i=%d,r=%d,n=%d,Hcuts[i]=%0.4f,Hcuts[Lfrozen]=%0.4f,Y1[S]=%0.4f,Y1[S+1]=%0.4f,Y1[N1]=%0.4f,DELTA_INTERVAL=%0.4f,IN=%d,maxIN=%d\n",
		     iter,S,N1,i,r,n,Hcuts[i],Hcuts[Lfrozen],Y1[S],Y1[S+1],Y1[N1+1],DELTA_INTERVAL,IN,maxIN);
	      fflush(stdout);
	    }
	    IN = max(0,min(IN, maxIN));
	  }
	  if(DEBUG_CONVERGE && iter >= DEBUG_CONVERGE){
	    printf("iter=%d:I1=%d/%d,i=%d/%d:Hcuts[i]= %0.3f, Y1[I1]=%0.3f,%0.3f Hcuts[Lfrozen]= %0.3f, DELTA_INTERVAL= %0.3f:ID2[I2]= IN2 = %d\n", 
		   iter,S,N1,i,n,Hcuts[i],Y1[S+1]-Y1[S],startY1[S+1]-startY1[S],Hcuts[Lfrozen],DELTA_INTERVAL,IN);
	    fflush(stdout);
	  }
	  ID1[S] = IN;

	  double delta = 0.0, hapdelta = 0.0;
	  for(int t = i; t < r; t++){
	    delta += Delta[t];
	    hapdelta += HapDelta[t];
	  }
	  if(DEBUG && !(Hcuts[r] - Hcuts[i] + delta + hapdelta <= Y1[S+1] - Y1[S] + 1e-6)){
	    printf("S=%d,Y1[S]=%0.4f,Y1[S+1]=%0.4f,i=%d,r=%d,Hcuts1[i]=%0.4f,Hcuts1[r]=%0.4f,Hcuts[i]=%0.4f,Hcuts[r]=%0.4f,delta=%0.4f,hapdelta=%0.4f\n",
		   S,Y1[S],Y1[S+1],i,r,Hcuts1[i],Hcuts1[r],Hcuts[i],Hcuts[r],Delta[i],HapDelta[i]);
	    printf("nmap1[MD][S+1]=%d\n",nmap1[MD][S+1]);
	    for(int t = i; t < r; t++)
	      if(Delta[t] || HapDelta[t])
		printf("\t t=%d:Delta[t]=%0.4f,HapDelta[t]=%0.4f\n",t,Delta[t],HapDelta[t]);
	    fflush(stdout);
	    assert(Hcuts[r] - Hcuts[i] + delta + hapdelta <= Y1[S+1] - Y1[S] + 1e-6);
	  }
	  double Y1S = Hcuts[r] - Hcuts[i] + delta + hapdelta - minKB;

	  if(VERB>=3 && iter <= 15){
	    printf("i=%d:S=%d,N1=%d,Y1[S..S+1]=%0.3f,r=%d,Hcuts[i..r]=%0.3f,delta=%0.3f,hapdelta=%0.3f,minKB=%0.3f,Y2S=%0.3f:IN=%d,DELTA_RANGE[IN]=%d,IDelta[IN][]=%0.3f..%0.3f\n",
		   i,S,N1,Y1[S+1]-Y1[S],r,Hcuts[r]-Hcuts[i],delta,hapdelta,minKB,Y1S,IN,DELTA_RANGE[IN],Initial_Delta[IN][0],Initial_Delta[IN][DELTA_RANGE[IN]-1]);
	    fflush(stdout);
	  }

	  delta1[S] = &delta1mem[S*(2*INITIAL_DELTA_RANGE + MAX_INDEL)];
	  if(MDEBUG)
	    LPdelta1[S] = &LPdelta1mem[S*(2*INITIAL_DELTA_RANGE + MAX_INDEL)];

	  int d = 0;
	  for(; d < DELTA_RANGE[IN];d++){
	    delta1[S][d] = Initial_Delta[IN][d];
	    if(DEBUG>=1+RELEASE/* HERE >=2 */ && fabs(delta1[S][d]) >= 1000.0){
	      printf("WARNING:delta1[S=%d][d=%d]=%0.4f is too large: N1=%d, i=%d, Hcuts[i]=%0.4f,Y1[S]=%0.4f,Y1[S+1]=%0.4f, IN=%d, maxIN=%d, DELTA_RANGE[IN]=%d,INITIAL_DELTA_RANGE=%d,Max_Initial_Delta[]=%0.4f..%0.4f\n",
		     S,d,delta1[S][d],N1,i,Hcuts[i],Y1[S],Y1[S+1],IN,maxIN,DELTA_RANGE[IN],INITIAL_DELTA_RANGE,Max_Initial_Delta[0],Max_Initial_Delta[INITIAL_DELTA_RANGE-1]);
	      fflush(stdout);
	      assert(fabs(delta1[S][d] < 1000.0));
	    }
	  }
	  for(d = 0; d < DELTA_RANGE[IN] && Initial_Delta[IN][d] < Y1S; d++)
	    delta1[S][d+DELTA_RANGE[IN]] = -Initial_Delta[IN][d];

	  DR1[S] = DELTA_RANGE[IN] + d;/* end of regular delta values (without haplotype reversal values) */

	  if(HINDEL_PHASED == 0.0 || HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE){/* add ability to reverse haplotype */
	    int LL = i, RR = r;

	    // NOTE : most cases are handled explicitly while estimating HapDeltaScore, so all HapIndel[] values that belong together can be reversed simultaneously (similar to Indel Filter code)
	    //        However cases with LL=0 or RR==n+1 are handled here, same as with HINDEL_MERGE < 2
	    // HERE : check if end cases can be safely handled later as well, then remove this section
	    while(LL > 0 && HapSite[LL] < 3)
	      LL--;
	    while(RR <= n && HapSite[RR] < 3)
	      RR++;
	    if(LL < 1 || RR > n) {
	      /* track down all intervals in HapSite[] for interval Y1[S..S+1] */
	      int indelcnt = 0;
	      double Indel[MAX_INDEL];
	      int R = i;
	      while(indelcnt < MAX_INDEL && !(R > i && (HapSite[R] & 1))){
		double indelval = HapDelta[R++];
		while(R < n && !HapSite[R])
		  indelval += HapDelta[R++];
		if(DEBUG) assert(R <= n && HapSite[R]);
		if(fabs(indelval) >= MIN_INDEL_SIZE)
		  Indel[indelcnt++] = indelval;
	      }
	      if(indelcnt >= MAX_INDEL && !(HapSite[R] & 1)){
		int peakcnt = indelcnt;
		while(!(HapSite[R] & 1)){
		  R++;
		  while(R < n && !HapSite[R])
		    R++;
		  peakcnt++;
		}
		MAX_INDEL_WARNING = max(MAX_INDEL_WARNING, peakcnt);
	      }
	      for(int t = 0; t < indelcnt; t++){
		delta1[S][d+DELTA_RANGE[IN]] = -Indel[t];
		d++;
	      }
	    }
	  }
	  Dcnt1 += D1[S] = DELTA_RANGE[IN] + d;  
	  if(DEBUG>=2 && iter==HMIN_ITER) assert(D1[S] > 0);
      
	  if(VERB>=3 && iter==11){
	    printf("i=%d:S=%d,D1[S]=%d,DR1[S]=%d:Hcuts[i=%d]=%0.3f,Hcuts[r=%d]=%0.3f,delta=%0.3f,hapdelta=%0.3f,Y1S=%0.3f,HapSite[i,r]=%d,%d:cum=%d\n",
		   i,S,D1[S],DR1[S],i,Hcuts[i],r,Hcuts[r],delta,hapdelta,Y1S,HapSite[i],HapSite[r],Dcnt1);
	    /*
	    for(int d = 0; d < D1[S]; d++)
	      printf("  delta1[%d][%d]=%0.6f\n",S,d,delta1[S][d]);
	     for(int t = i; t <= n; t++){
	      if(t > i && (HapSite[t] & 1)){
	      printf(" t=%d:HapSite[t]=%d\n",t,HapSite[t]);
	      break;
	      }
	      if(HapSite[t] || HapDelta[t] || Delta[t])
	      printf(" t=%d:HapSite[t]=%d,HapDelta[t]=%0.3f,Delta[t]=%0.3f\n",t,HapSite[t],HapDelta[t],Delta[t]);
	      }*/
	    fflush(stdout);
	  }
	  if(DEBUG) assert(D1[S] >= DR1[S]);
	  if(DEBUG) assert(D1[S] <= 2*INITIAL_DELTA_RANGE + MAX_INDEL);
	}

	if(VERB>=4 && N1 > 30 && iter==25){
	  int IN1 = ID1[30];
	  printf("Before delta2[][] initialization: iter=%d,D1[30]=%d,DR1[30]=%d,IN1[30]=%d,DELTA_RANGE[IN1]=%d\n",
		 iter,D1[30],DR1[30],ID1[30],DELTA_RANGE[IN1]);
	  for(int t = 0; t < D1[30]; t++){
	    printf("  delta1[30][%d] = %0.6f\n", t, delta1[30][t]);
	    fflush(stdout);
	    if(DEBUG && t < DR1[30] && t >= DELTA_RANGE[IN1]) assert(delta1[30][t] < 0.0);
	  }
	}

	/* reallocate/initialize delta2[S=1..N2-1][d = 0..D2[S]-1] = Initial_Delta[IN][d] */
	Dcnt2 = 0;
	D2[0] = DR2[0] = ID2[0] = D2[N2] = DR2[N2] = 0;
	ID2[N2] = maxIN;
	for(int S = 1; S < N2; S++)
	  ID2[S] = -1;
	for(int S = 1; S < N2; S++){
	  int i = nmap2[MD][S];
	  if(DEBUG) assert(0 < i && i < n);
	  if(DEBUG) assert(HapSite[i] & 2);
	  int r = i+1;
	  while(r < n && !(HapSite[r] & 2))
	    r++;
	  if(DEBUG) assert(r <= n && (HapSite[r] & 2));
	  if(DEBUG) assert(r == nmap2[MD][S+1]);

	  int IN = floor((Hcuts[i] + (Y2[S+1]-Y2[S])*0.5 - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
	  if(DEBUG && !(0 <= IN && IN <= maxIN)){
	    if(VERB>=2){
	      printf("WARNING:iter=%d,S=%d,N1=%d,i=%d,r=%d,n=%d,Hcuts[i]=%0.4f,Hcuts[Lfrozen]=%0.4f,Y2[S]=%0.4f,Y2[S+1]=%0.4f,Y2[N2]=%0.4f,DELTA_INTERVAL=%0.4f,IN=%d,maxIN=%d\n",
		     iter,S,N1,i,r,n,Hcuts[i],Hcuts[Lfrozen],Y2[S],Y2[S+1],Y2[N2+1],DELTA_INTERVAL,IN,maxIN);
	      fflush(stdout);
	    }
	    IN = max(0,min(IN, maxIN));
	  }
	  if(DEBUG_CONVERGE && iter >= DEBUG_CONVERGE){
	    printf("iter=%d:I2=%d/%d,i=%d/%d:Hcuts[i]= %0.3f, Y2[I2]=%0.3f,%0.3f Hcuts[Lfrozen]= %0.3f, DELTA_INTERVAL= %0.3f:ID2[I2]= IN2 = %d\n", 
		   iter,S,N2,i,n,Hcuts[i],Y2[S+1]-Y2[S],startY2[S+1]-startY2[S],Hcuts[Lfrozen],DELTA_INTERVAL,IN);
	    fflush(stdout);
	  }
	  ID2[S] = IN;

	  double delta = 0.0, hapdelta = 0.0;
	  for(int t = i; t < r; t++){
	    delta += Delta[t];
	    hapdelta += HapDelta[t];
	  }
	  if(DEBUG && !(Hcuts[r] - Hcuts[i] + delta - hapdelta <= Y2[S+1] - Y2[S] + 1e-6)){
	    printf("S=%d,Y2[S]=%0.3f,Y2[S+1]=%0.3f,i=%d,r=%d,Hcuts2[i]=%0.3f,Hcuts2[r]=%0.3f,Hcuts[i]=%0.3f,Hcuts[r]=%0.3f,delta=%0.3f,hapdelta=%0.3f\n",
		   S,Y2[S],Y2[S+1],i,r,Hcuts2[i],Hcuts2[r],Hcuts[i],Hcuts[r],Delta[i],HapDelta[i]);
	    printf("nmap2[MD][S+1]=%d\n",nmap2[MD][S+1]);
	    for(int t = i; t < r; t++)
	      if(Delta[t] || HapDelta[t])
		printf("\t t=%d:Delta[t]=%0.3f,HapDelta[t]=%0.3f\n",t,Delta[t],HapDelta[t]);
	    fflush(stdout);
	    assert(Hcuts[r] - Hcuts[i] + delta - hapdelta <= Y2[S+1] - Y2[S] + 1e-6);
	  }
	  double Y2S = Hcuts[r] - Hcuts[i] + delta - hapdelta - minKB;
	  if(VERB>=3 && iter==11 && i==1152){
	    printf("i=%d:S=%d,N2=%d,Y2[S..S+1]=%0.3f,r=%d,Hcuts[i..r]=%0.3f,delta=%0.3f,hapdelta=%0.3f,minKB=%0.3f,Y2S=%0.3f:IN=%d,DELTA_RANGE[IN]=%d,IDelta[]=%0.3f..%0.3f\n",
		   i,S,N2,Y2[S+1]-Y2[S],r,Hcuts[r]-Hcuts[i],delta,hapdelta,minKB,Y2S,IN,DELTA_RANGE[IN],Initial_Delta[IN][0],Initial_Delta[IN][DELTA_RANGE[IN]-1]);
	    fflush(stdout);
	  }

	  delta2[S] = &delta2mem[S*(2*INITIAL_DELTA_RANGE + MAX_INDEL)];
	  if(MDEBUG)
	    LPdelta2[S] = &LPdelta2mem[S*(2*INITIAL_DELTA_RANGE + MAX_INDEL)];

	  int d = 0;
	  for(; d < DELTA_RANGE[IN];d++)
	    delta2[S][d] = Initial_Delta[IN][d];
	  for(d = 0; d < DELTA_RANGE[IN] && Initial_Delta[IN][d] < Y2S; d++)
	    delta2[S][d+DELTA_RANGE[IN]] = -Initial_Delta[IN][d];
	  DR2[S] = DELTA_RANGE[IN] + d;/* end of regular delta values (without haplotype reversal values) */
	  if(HINDEL_PHASED == 0.0 || HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE){/* add ability to reverse haplotype */
	    int LL = i, RR = r;
	    // NOTE : most cases are handled explicitly while estimating HapDeltaScore, so all HapIndel[] values that belong together can be reversed simultaneously (similar to Indel Filter code)
	    //        However cases with LL=0 or RR==n+1 are handled here
	    // HERE : check if end cases can be safely handled later as well, then remove this section
	    while(LL > 0 && HapSite[LL] < 3)
	      LL--;
	    while(RR <= n && HapSite[RR] < 3)
	      RR++;
	    if(LL < 1 || RR > n) {
	      int indelcnt = 0;
	      double Indel[MAX_INDEL];
	      int R = i;
	      while(indelcnt < MAX_INDEL && !(R > i && (HapSite[R] & 2))){
		double indelval = HapDelta[R++];
		while(R < n && !HapSite[R])
		  indelval += HapDelta[R++];
		if(DEBUG) assert(R <= n && HapSite[R]);
		if(fabs(indelval) >= MIN_INDEL_SIZE)
		  Indel[indelcnt++] = indelval;
	      }
	      if(indelcnt >= MAX_INDEL && !(HapSite[R] & 2)){
		int peakcnt = indelcnt;
		while(!(HapSite[R] & 2)){
		  R++;
		  while(R < n && !HapSite[R])
		    R++;
		  peakcnt++;
		}
		MAX_INDEL_WARNING = max(MAX_INDEL_WARNING, peakcnt);
	      }
	      for(int t = 0; t < indelcnt; t++){
		delta2[S][d+DELTA_RANGE[IN]] = Indel[t];
		d++;
	      }
	    }
	  }
	  Dcnt2 += D2[S] = DELTA_RANGE[IN] + d;
	  if(DEBUG>=2 && iter==HMIN_ITER) assert(D2[S] > 0);

	  if(VERB>=3 && iter==11 && i==1152){
	    printf("S=%d,D2[S]=%d:Hcuts[i=%d]=%0.3f,Hcuts[r=%d]=%0.3f,delta=%0.3f,hapdelta=%0.3f,Y2S=%0.3f,HapSite[i,r]=%d,%d\n",S,D2[S],i,Hcuts[i],r,Hcuts[r],delta,hapdelta,Y2S,HapSite[i],HapSite[r]);
	    for(int d = 0; d < D2[S]; d++)
	      printf("  delta2[S][%d]=%0.3f\n",d,delta2[S][d]);
	    for(int t = i; t <= n; t++){
	      if(t > i && (HapSite[t] & 2)){
		printf(" t=%d:HapSite[t]=%d\n",t,HapSite[t]);
		break;
	      }
	      if(HapSite[t] || HapDelta[t] || Delta[t])
		printf(" t=%d:HapSite[t]=%d,HapDelta[t]=%0.3f,Delta[t]=%0.3f\n",t,HapSite[t],HapDelta[t],Delta[t]);
	    }
	    fflush(stdout);
	  }
	  if(DEBUG) assert(D2[S] >= DR2[S] && DR2[S] >= 0);
	}
	if(DEBUG) assert(Dcnt2 >= 0);

	if(VERB>=4 && N1 > 30 && iter==25){
	  int IN1 = ID1[30];
	  printf("Before mprobeval memory re-allocation: iter=%d,D1[30]=%d,DR1[30]=%d,IN1[30]=%d,DELTA_RANGE[IN1]=%d\n",
		 iter,D1[30],DR1[30],ID1[30],DELTA_RANGE[IN1]);
	  for(int t = 0; t < D1[30]; t++){
	    printf("  delta1[30][%d] = %0.6f\n", t, delta1[30][t]);
	    fflush(stdout);
	    if(DEBUG && t < DR1[30] && t >= DELTA_RANGE[IN1]) assert(delta1[30][t] < 0.0);
	  }
	}
      }

      /* free newLPdeltaMem,newLPdeltaMem2 */
      if(newLPdeltaMem){
	free(newLPdeltaMem);
	newLPdeltaMem = 0;
      }
      if(newLPdeltaMem2){
	free(newLPdeltaMem2);
	newLPdeltaMem2 = 0;
      }
      MaxDelta = MaxDelta2 = 0;

      if(HEAP_MINIMIZE){/* free lightweight heap to minimize real memory usage */
	delete heap;
	heap = new lightweight_heap(0,0);      
      }

      if(HEAP_MINIMIZE || max(N1,N2) > NmaxLP){/* need to reallocate NmaxLP dependent arrays */
	NmaxLP = HEAP_MINIMIZE ? max(N1,N2) : (max(N1,N2) * 5)/4;

	if(!VMEM_MINIMIZE){/* NEW8 */
	  delete [] newLPd[0]; newLPd[0] = NULL;
	  delete [] newLPd2[0]; newLPd2[0] = NULL;
	}
	if(MDEBUG){
	  delete [] newLPdPr[0]; newLPdPr[0] = NULL;
	  delete [] newLPdPr2[0]; newLPdPr2[0] = NULL;
	}

	if(!HINDELITER(iter)){
	  /* reallocate newLPd[] */
	  size_t siz = ((size_t)MD) * ((HEAP_MINIMIZE ? N1 : NmaxLP) + 2ul);
	  if(!VMEM_MINIMIZE){// NEW8
	    try { /* allocate initial memory for newLPd[] */
	      newLPd[0] = new double[siz];
	    } catch (exception& e){
	      cout << e.what() << endl;
	      printf("refine(): exception thrown while re-allocating newLPd[]:NmaxLP=%d,MD=%d,N1=%d,N2=%d,siz=%lu\n",NmaxLP,MD,N1,N2,siz);
	      fflush(stdout);
	      assert(0);
	    }
	    for(long long m = 1; m < MD; m++)
	      newLPd[m] = newLPd[0] + m * (N1 /* WAS NmaxLP */ + 2ll);
	    if(MDEBUG)
	      for(register int m = 0; m < MD; m++)
		for(register int S = 0; S <= N1+1; S++)
		  newLPd[m][S] = LARGE_NEGATIVE;
	  }

	  if(MDEBUG){
	    try {
	      newLPdPr[0] = new int[siz];
	      for(long long m = 1; m < MD; m++)
		newLPdPr[m] = newLPdPr[0] + m * (N1 /* WAS NmaxLP */ + 2ll);
	    } catch (exception& e){
	      cout << e.what() << endl;
	      printf("refine(): exception thrown while re-allocating newLPdPr[]:NmaxLP=%d,MD=%d,N1=%d,N2=%d,siz=%lu\n",NmaxLP,MD,N1,N2,siz);
	      fflush(stdout);
	      assert(0);
	    }
	  }

	  /* reallocate newLPd2[] */
	  siz = ((size_t)MD) * ((HEAP_MINIMIZE ? N2 : NmaxLP) + 2ul);
	  if(!VMEM_MINIMIZE){// NEW8
	    try {/* allocate initial memory for newLPd[] */
	      newLPd2[0] = new double[siz];
	    } catch (exception& e){
	      cout << e.what() << endl;
	      printf("refine(): exception thrown while re-allocating newLPd[]:NmaxLP=%d,MD=%d,N1=%d,N2=%d,siz=%lu\n",NmaxLP,MD,N1,N2,siz);
	      fflush(stdout);
	      assert(0);
	    }
	    for(long long m = 1; m < MD; m++)
	      newLPd2[m] = newLPd2[0] + m * (N2 /* WAS NmaxLP */ + 2ll);
	    if(MDEBUG)
	      for(register int m = 0; m < MD; m++)
		for(register int S = 0; S <= N2+1; S++)
		  newLPd2[m][S] = LARGE_NEGATIVE;
	  }
	  if(MDEBUG){
	    try {/* allocate initial memory for newLPd[] */
	      newLPdPr2[0] = new int[siz];
	    } catch (exception& e){
	      cout << e.what() << endl;
	      printf("refine(): exception thrown while re-allocating newLPd[]:NmaxLP=%d,MD=%d,N1=%d,N2=%d,siz=%lu\n",NmaxLP,MD,N1,N2,siz);
	      fflush(stdout);
	      assert(0);
	    }
	    for(long long m = 1; m < MD; m++)
	      newLPdPr2[m] = newLPdPr2[0] + m * (N2 /* WAS NmaxLP */ + 2ll);
	  }
	}
      
	/* reallocate Dcum[],Dcum2[] */
	delete [] Dcum;
	Dcum = new int[N1 /* WAS NmaxLP */ + 2];
	delete [] Dcum2;
	Dcum2 = new int[N2 /* WAS NmaxLP */ + 2];
      }

      if(TIME_VERBOSE){
	getmem(VmSize,VmRSS, VmSwap);
	double InvGB = 1e-9;	
	printf("iter=%d:After Re-Allocation of two sets of newLPd[] for N1=%d,N2=%d: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: cum wall= %0.6f\n", iter,N1,N2, VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB,wtime());
	fflush(stdout);
      }

      if(HINDELITER(iter)){
	for(int sum = 0, Q = 0; Q < N1; Q++){
	  Dcum[Q] = sum;
	  sum += max(0,D1[Q]);
	}
	if(DEBUG) assert(Dcnt1 >= 0);
	if(DEBUG && N1 > 0) assert(Dcum[N1-1] + max(0,D1[N1-1]) == Dcnt1);
	if(DEBUG && N1 <= 0) assert(Dcnt1 <= 0);
	Dcum[N1] = Dcnt1;

	for(int sum = 0, Q = 0; Q < N2; Q++){
	  Dcum2[Q] = sum;
	  sum += max(0,D2[Q]);
	}
	if(DEBUG) assert(Dcnt2 >= 0);
	if(DEBUG && N2 > 0) assert(Dcum2[N2-1] + max(0,D2[N2-1]) == Dcnt2);
	if(DEBUG && N2 <= 0) assert(Dcnt2 <= 0);

	Dcum2[N2] = Dcnt2;
      }

      if(MDEBUG && newLPaPr[0]) { delete [] newLPaPr[0]; newLPaPr[0] = 0;}
      if(MDEBUG && newLPaPr2[0]) { delete [] newLPaPr2[0]; newLPaPr2[0] = 0;}

      MaxAddcnt = addcnt1;
      long long siz = ((long long)MD) * MaxAddcnt;
      if(MDEBUG){
	newLPaPr[0] = new int[siz];
	for(long long m = 1; m < MD; m++)
	  newLPaPr[m] = newLPaPr[0] + m*MaxAddcnt;
      }

      if(VMEM_MINIMIZE)
	DoubleAllocations_free();

      if(!VMEM_MINIMIZE){ /* reallocate newLPa[] */
	/* free newLPa[][], newLPa2[][] */
	if(newLPa[0]) { free(newLPa[0]); newLPa[0] = 0;}
	if(newLPa2[0]) { free(newLPa2[0]); newLPa2[0] = 0;}

	if(VERB>=2){
	  //      dumpmemmap();
	  printf("Reallocating newLPa[] : addcnt1=%d, MaxAddcnt=%d -> %d\n", addcnt1, MaxAddcnt, addcnt1);
	  fflush(stdout);
	}
	newLPa[0] = (double *) malloc(siz * sizeof(double));
	if(!newLPa[0]){
	  printf("HaploType: malloc failed while allocating newLPa[]: MaxAddcnt=%d,siz=%lld\n",MaxAddcnt,siz);
	  fflush(stdout);
	  exit(1);
	}
	for(long long m = 1; m < MD; m++)
	  newLPa[m] = newLPa[0] + m*MaxAddcnt;
	if(MDEBUG || DEBUG>=2)
	  for(register int m = 0; m < MD; m++)
	    for(register int t = 0; t < addcnt1; t++)
	      newLPa[m][t] = LARGE_NEGATIVE;
      }

      MaxAddcnt2 = addcnt2;
      siz = ((long long)MD) * MaxAddcnt2;
      if(MDEBUG){
	newLPaPr2[0] = new int[siz];
	for(long long m = 1; m < MD; m++)
	  newLPaPr2[m] = newLPaPr2[0] + m*MaxAddcnt2;
      }

      if(!VMEM_MINIMIZE){ /* reallocate newLPa2[] */
	if(VERB>=2){
	  printf("Reallocating newLPa2[] : addcnt2=%d, MaxAddcnt2=%d -> %d\n", addcnt2, MaxAddcnt2, addcnt2);
	  fflush(stdout);
	}
	newLPa2[0] = (double *) malloc(siz * sizeof(double));
	if(!newLPa2[0]){
	  printf("HaploType: malloc failed while allocating newLPa2[]: MaxAddcnt2=%d,siz=%lld\n",MaxAddcnt2,siz);
	  fflush(stdout);
	  exit(1);
	}
	for(long long m = 1; m < MD; m++)
	  newLPa2[m] = newLPa2[0] + m*MaxAddcnt2;
	if(MDEBUG || DEBUG>=2)
	  for(register int m = 0; m < MD; m++)
	    for(register int t = 0; t < addcnt2; t++)
	      newLPa2[m][t] = LARGE_NEGATIVE;

	/* reallocate newLPdelta[m][S,d] */
	MaxDelta = Dcnt1;
	siz = ((long long)MD)*MaxDelta;
	if(VERB>=2){
	  printf("Reallocating newLPdelta[]: Dcnt1=%d,MaxDelta=%d->%d,siz=%lld doubles\n",Dcnt1,MaxDelta,Dcnt1,siz);
	  fflush(stdout);
	}
	newLPdeltaMem = (double *)malloc(siz * sizeof(double));
	if(!newLPdeltaMem){
	  printf("HaploType: malloc failed while allocating newLPdeltaMem[],siz=%lld\n",siz);
	  fflush(stdout);
	  exit(1);
	}
	if(VERB>=2){
	  printf("reallocated newLPdeltaMem=%p..%p(siz=%lld,MD=%d,MaxDelta=%d)\n",newLPdeltaMem, &newLPdeltaMem[siz-1],siz,MD,MaxDelta);
	  fflush(stdout);
	}

	long long DeltaCnt = 0;
	for(int m = 0; m < MD; m++){
	  newLPdelta[m] = &newLPdeltaMem[DeltaCnt];
	  DeltaCnt += Dcnt1;
	}
	if(DEBUG) assert(DeltaCnt <= ((long long)MD)*MaxDelta);

	if((MDEBUG && (MDEBUG_DELTA || (MDEBUG_TS >= 0 &&  MDEBUG_TT >= 0)) && MDEBUG_T < 0 && MDEBUG_S < 0) || DEBUG>=2)
	  for(int m = 0; m < MD; m++)
	    for(int d = 0; d < Dcnt1; d++)
	      newLPdelta[m][d] = LARGE_NEGATIVE;
    
	/* reallocate newLPdelta2[m][S,d] */
	if(VERB>=2){
	  printf("Reallocating newLPdelta2[]: Dcnt2=%d,MaxDelta2=%d->%d,siz=%lld doubles\n",Dcnt2,MaxDelta2,Dcnt2,siz);
	  fflush(stdout);
	}
	MaxDelta2 = Dcnt2;
	siz = ((long long)MD)*MaxDelta2;
	newLPdeltaMem2 = (double *)malloc(siz * sizeof(double));
	if(!newLPdeltaMem2){
	  printf("HaploType: malloc failed while allocating newLPdeltaMem2[],siz=%lld\n",siz);
	  fflush(stdout);
	  exit(1);
	}
	if(VERB>=2){
	  printf("reallocated newLPdeltaMem2=%p..%p(siz=%lld,MD=%d,MaxDelta2=%d)\n",newLPdeltaMem, &newLPdeltaMem[siz-1],siz,MD,MaxDelta2);
	  fflush(stdout);
	}
	DeltaCnt = 0;
	for(int m = 0; m < MD; m++){
	  newLPdelta2[m] = &newLPdeltaMem2[DeltaCnt];
	  DeltaCnt += Dcnt2;
	}
	if(DEBUG) assert(DeltaCnt <= ((long long)MD)*MaxDelta2);

	if((MDEBUG && (MDEBUG_DELTA || (MDEBUG_TS >= 0 &&  MDEBUG_TT >= 0)) && MDEBUG_T < 0 && MDEBUG_S < 0) || DEBUG>=2)
	  for(int m = 0; m < MD; m++)
	    for(int d = 0; d < Dcnt2; d++)
	      newLPdelta2[m][d] = LARGE_NEGATIVE;
      }

      if(VERB>=2){
	printf("After memory reallocation:\n");
	dumpmemmap();
      }

      if(VERB>=4 && N1 > 30 && iter==25 && HINDELITER(iter)){
	int IN1 = ID1[30];
	printf("Before mprobeval for HaploType 1: iter=%d,D1[30]=%d,DR1[30]=%d,IN1[30]=%d,DELTA_RANGE[IN1]=%d\n",
	       iter,D1[30],DR1[30],ID1[30],DELTA_RANGE[IN1]);
	for(int t = 0; t < D1[30]; t++){
	  printf("  delta1[30][%d] = %0.6f\n", t, delta1[30][t]);
	  fflush(stdout);
	  if(DEBUG && t < DR1[30] && t >= DELTA_RANGE[IN1]) assert(delta1[30][t] < 0.0);
	}
      }

      /* call mprobeval() on both HaploTypes and save the per map LP values */
      if(VERB>=2 || SPEEDCHECK){
	if(HINDELITER(iter)){
	  int Dcnt = 0;
	  for(int S = 0; S < N1; S++){
	    if(DEBUG) assert(D1[S] >= 0);
	    Dcnt += D1[S];
	    if(DEBUG>=3){
	      for(int t = 0; t < D1[S]; t++)
		if(fabs(delta1[S][t]) >= 1000.0){
		  printf("WARNING: delta1[S=%d][t=%d] = %0.4f : N1=%d, D1[S]=%d\n",S,t,delta1[S][t],N1,D1[S]);
		  fflush(stdout);
		  assert(fabs(delta1[S][t] < 1000.0));
		}
	    }
	  }
	  printf("Calling mprobeval for HaploType 1: iter=%d,N1=%d,sum(D1)=%d:", iter, N1, Dcnt);
	} else
	  printf("Calling mprobeval for HaploType 1: iter=%d,N1=%d,addcnt1=%d:", iter, N1, addcnt1);
	fflush(stdout);
      }
      if(MDEBUG || iter > 0 || SNPcnt > 0 || IndelCnt > 0)
	score_init(N1,Y1,MD,MX,X);// needed to precompute the correct tables when Y1 != Y2
      double start = mtime(), wstart = wtime();
      if(DEBUG)
	for(int m = 0; m < MD; m++)
	  TminM[m] = TmaxM[m] = AminM[m] = AmaxM[m] = DminM[m] = DmaxM[m] = -1;

#if 0
      MDEBUG = (iter == 6) ? 1 : 0;
      //      MDEBUG_M = (iter == 6) ? 34 : -1;
      printf("iter=%d:MDEBUG=%d,MDEBUG_TS=%d,MDEBUG_TT=%d\n",iter,MDEBUG,MDEBUG_TS,MDEBUG_TT);
      fflush(stdout);
#endif

      if(MPROBEVAL_LAZYRESTORE && HINDELITER(iter))
	memset(pBlock1, 0, 2*MD*sizeof(CdoubleBlock *));
	
      // NOTE : LPdelta1 and LPdelta2 are not used and equal to NULL unless MDEBUG
      //      rverb = (iter == 23) ? 1 : 0;
      double LP1 = HINDELITER(iter) ?
	mprobeval(n, Hcuts1, N1, Y1, MD, MX, X, lc, rc, map1, mapK1, limit1, nmap1[MD], TBmapWT, newLPA1, bestLPA1, 0.0/*Ymin*/, Y1[N1+1]/*Ymax*/, 0, 0, D1, delta1, 0, 0, 0, LPdelta1, 
		  /* newLPd */ 0, /*newLPd0*/ 0, /* newLPdPr*/ 0, DminM, DmaxM, newLPa, newLPaPr, TminM, TmaxM, newLPdelta, Dcum, AminM, AmaxM, pcontig,/* skipmap*/ 0, 1, pBlock1) :
	mprobeval(n, Hcuts1, N1, Y1, MD, MX, X, lc, rc, map1, mapK1, limit1, nmap1[MD], TBmapWT, newLPA1, bestLPA1, -1.0/*Ymin*/, -1.0/*Ymax*/, addcnt1, addloc1, 0, 0, LPdel1, LPadd1, 0, 0,
		  newLPd, newLPd0, newLPdPr, DminM, DmaxM, newLPa, newLPaPr, TminM, TmaxM, 0, 0, 0, 0, pcontig, /* skipmap */0, 1);
      //  rverb = 0;

      if(DEBUG>=2){
	if(HINDELITER(iter)){
	  for(int m = 0; m < MD; m++){
	    if(!(0 <= AminM[m] && AmaxM[m] <= N1+1)){
	      printf("m=%d/%d:AminM[m]=%d,AmaxM[m]=%d,N1=%d\n",m,MD,AminM[m],AmaxM[m],N1);
	      fflush(stdout);
	      assert(0 <= AminM[m] && AmaxM[m] <= N1+1);
	    }
	  }
	} else {
	  if(addcnt1)
	    for(int m = 0; m < MD; m++){
	      if(!(0 <= TminM[m] && TmaxM[m] < addcnt1)){
		printf("m=%d/%d:TminM[m]=%d,TmaxM[m]=%d,addcnt1=%d\n",m,MD,TminM[m],TmaxM[m],addcnt1);
		fflush(stdout);
		assert(0 <= TminM[m] && TmaxM[m] < addcnt1);
	      }
	    }
	  for(int m = 0; m < MD; m++){
	    if(!(1 <= DminM[m] && DmaxM[m] <= N1)){
	      printf("m=%d/%d:DminM[m]=%d,DmaxM[m]=%d,N1=%d\n",m,MD,DminM[m],DmaxM[m],N1);
	      fflush(stdout);
	      assert(1 <= DminM[m] && DmaxM[m] <= N1);
	    }
	  }
	}
      }

      if(VERB>=2 || SPEEDCHECK){
	double wt = wtime();
	printf(" LP=%0.6f: time=%0.6f, wall time=%0.6f (cum=%0.6f)\n", LP1, mtime()-start, wt-wstart,wt);
	fflush(stdout);
      }
      if(TIME_VERBOSE){
	getmem(VmSize,VmRSS, VmSwap);
	double InvGB = 1e-9;	
	printf("iter=%d:After calling mprobeval: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: cum wall= %0.6f\n", iter, VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB,wtime());
	fflush(stdout);
      }

      if(MDEBUG && (MDEBUG_DEL || (MDEBUG_S >= 0 && MDEBUG_F >= 0)) && !(MDEBUG_T < 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0) && !(MDEBUG_T >= 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0) && !HINDELITER(iter)){
	double *testLPA = new double[MD];
      
	/* check LPdel1[1..N1] vs qprobeval() */
	double maxerr = -1000.0;/* worst error for any single site deletion for LP sum over all maps (excluding those that dropped more than LP_DROP) */
	int maxerrI = -1;

	double ErrMax = -1000.0;/* worst error for any single site deletion for any single map (excluding those that dropped more than LP_DROP) */
	double trueLP = -1000.0;
	int maxS = -1;
	int maxM = -1;

	int I = 0;
	if(VERB>=2){
	  for(int i = 1; i <= n; i++)
	    I += (Hdel1[i] ? 0 : 1);
	  printf("Initial number of sites in Hdel1[1..n] = %d, N1=%d\n",I,N1);
	  fflush(stdout);
	  I = 0;
	}

	for(register int i = 1; i <= n; i++){
	  if(Hdel1[i])
	    continue;
	  I++;
	  if(i < imin || i > imax)
	    continue;

	  Hdel1[i] = 1;
	  if(VERB>=2){
	    printf("Testing site deletion at Hcuts1[i=%d]=%0.3f\n",i,Hcuts1[i]);
	    fflush(stdout);
	  }
	  if((MDEBUG_S <= 0 || I==MDEBUG_S) && MDEBUG_T < 0 && MDEBUG_TS < 0 && MDEBUG_TT < 0){
	    int newN1 = setmap(n,Hcuts1,Hdel1,Y1,map1[MD],nmap1[MD]);/* compute Y1[] and nmap1[MD][0..N+1] and map1[MD][0..n+1] */
	    if(DEBUG && !(newN1 == N1-1)){
	      printf("i=%d:Hdel1[i] -> %d, N1=%d,newN1=%d\n",i,Hdel1[i],N1,newN1);
	      fflush(stdout);
	      assert(newN1 == N1-1);
	    }

	    score_init(newN1,Y1,MD,MX,X);/* precompute likelihood scoring constants/terms */

	    printf("i=%d,I1=%d:Deleted Hcuts1[i]=%0.3f, N1=%d, newN1=%d:", i,I,Hcuts1[i],N1,newN1);
	    fflush(stdout);

	    //	    if(I==MDEBUG_S) rverb = 1;
	    double qLP = qprobeval(n,Hcuts1,newN1,Y1,MD,MX,X,lc,rc,map1,mapK1,limit1, nmap1,0,TBmapWT,testLPA,mapWT1,bestLPA1,Hcuts1[i],Hcuts1[i],0,0,pcontig);
	    rverb = 0;

	    if(qLP > LP1-LP_DROP || LPdel1[I] > LP1)
	      printf("qLP=%0.10f,LPdel1[I]=%0.10f (error=%0.10f)\n",qLP,LPdel1[I],LPdel1[I]-qLP);
	    else
	      printf("qLP=%0.10f,LPdel1[I]=%0.10f (error=%0.10f:ignored) LP1=%0.6f\n",qLP,LPdel1[I],LPdel1[I]-qLP, LP1);
	    if((qLP > LP1-LP_DROP || LPdel1[I] > LP1) && fabs(LPdel1[I]-qLP) > maxerr){
	      maxerr = fabs(LPdel1[I]-qLP);
	      maxerrI = I;
	    }

	    double sumLPdIm = 0.0, sumtest = 0.0;
	    for(int m = 0; m < MD; m++){
	      double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
	      int i = (!VMEM_MINIMIZE && I < DminM[m]) ? 0 : min(DmaxM[m],I);// NEW8
	      double newLPdmi = (VMEM_MINIMIZE && I < DminM[m]) ? newLPd0[m] : newLPd[m][i];// NEW8
	      int newLPdPrmi = !MDEBUG ? 0 : (VMEM_MINIMIZE && I < DminM[m]) ? newLPdPr[m][0] : newLPdPr[m][i];// NEW8
	      sumLPdIm += newLPdmi * TBwtm;
	      sumtest += testLPA[m] * TBwtm;
	      if(VERB && (VERB>=2 || (I==maxerrI && maxerr > MDEBUG_ERR) || (I==MDEBUG_S && m==MDEBUG_M))){
		printf("I=%d,m=%d(id=%lld):wt=%0.10f,mLPA[m]=%0.10f,bestLPA1[m]=%0.10f,newLPd[m][I]=%0.10f,trueLPA[m]=%0.10f(err=%0.10f, cumwt=%0.10f)",
		       I,m,gmap[pcontig->contig[m].mapid]->id,TBwtm,newLPA1[m],bestLPA1[m],newLPdmi,testLPA[m],newLPd[m][i]-testLPA[m], sumLPdIm - sumtest);
		if(testLPA[m] <= newLPA1[m]-LP_DROP && newLPdmi <= newLPA1[m])
		  printf(":ignored");
		if(MDEBUG && newLPdPrmi)
		  printf(":reduced precision");
		printf("\n");
		fflush(stdout);
	      }
	      if(DEBUG) assert(newLPdmi > -1e98); 
	      if((testLPA[m] > newLPA1[m] - LP_DROP*0.1 || newLPdmi > newLPA1[m] || maxerr > MDEBUG_ERR) && fabs(newLPdmi-testLPA[m]) * TBwtm > ErrMax && (!MDEBUG_NEGERR || newLPdmi < testLPA[m])){
		ErrMax = fabs(newLPdmi-testLPA[m]) * TBwtm;
		trueLP = testLPA[m];
		maxS = I;
		maxM = m;
	      }
	    }
	    if(DEBUG && ErrMax >= 0.0) assert(maxS >= 0 && maxM >= 0);
	    if(DEBUG && !(fabs(sumLPdIm - newN1*SITE_PEN - LPdel1[I]) < (sizeof(MFLOAT) <= 4 ? 1e-7 : 1e-8) && fabs(sumtest-newN1*SITE_PEN -qLP) < 1e-8)){
	      printf("WARNING:sum(newLPd[m=0..%d][I])=%0.10f(newN1=%d,SITE_PEN=%0.6f),LPdel1[I]=%0.10f(err=%0.10f)\n",MD-1,sumLPdIm, newN1,SITE_PEN,LPdel1[I],(sumLPdIm - newN1*SITE_PEN - LPdel1[I]));
	      printf("\t sumtest= %0.10f(newN1=%d,SITE_PEN=%0.6f),qLP=%0.10f(err=%0.10f)\n",sumtest,newN1,SITE_PEN, qLP, sumtest - newN1*SITE_PEN - qLP);
	      fflush(stdout);

	      double sum1=0.0,sum2=0.0, sum3=0.0;
	      for(int m = 0; m < MD; m++){
		double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
		int i = (!VMEM_MINIMIZE && I < DminM[m]) ? 0 : min(DmaxM[m],I);// NEW8
		double newLPdmi = (VMEM_MINIMIZE && I < DminM[m]) ? newLPd0[m] : newLPd[m][i];// NEW8
		int newLPdPrmi = !MDEBUG ? 0 : (VMEM_MINIMIZE && I < DminM[m]) ? newLPdPr[m][0] : newLPdPr[m][i];// NEW8
		sum1 += newLPdmi * TBwtm;
		sum2 += testLPA[m] * TBwtm;
		sum3 += newLPA1[m] * TBwtm ;
		printf("I=%d,m=%d(id=%lld):wt=%0.10f,newLPd[m][I]=%0.10f(cum=%0.10f),testLPA[m]=%0.10f(cum=%0.10f):err=%0.10f(cum=%0.10f):mLPA1[m]=%0.10f(cum=%0.10f):",
		       I,m,gmap[pcontig->contig[m].mapid]->id,TBwtm,newLPdmi,sum1,testLPA[m],sum2,newLPdmi-testLPA[m],sum1-sum2, newLPA1[m], sum3);
		if(testLPA[m] <= newLPA1[m]-LP_DROP && newLPdmi <= newLPA1[m])
		  printf(":ignored");
		if(MDEBUG && newLPdPrmi)
		  printf(":reduced precision");
		printf("\n");
	      }
	      fflush(stdout);
	      assert(fabs(sumLPdIm - newN1*SITE_PEN - LPdel1[I]) < (sizeof(MFLOAT) <= 4 ? 1e-7 : 1e-8));
	      assert(fabs(sumtest-newN1*SITE_PEN - qLP) < 1e-8);
	    }

	    if(/* HERE HERE ErrMax >= 0.0 &&*/ ((MDEBUG_S > 0 && MDEBUG_F >= 0 && newN1 == MDEBUG_N-1) /* || ErrMax >= MDEBUG_ERR*/)){
	      int maxs = (!VMEM_MINIMIZE && maxS < DminM[maxM]) ? 0 : min(DmaxM[maxM],maxS);// NEW8
	      double newLPdms = (VMEM_MINIMIZE &&  maxS < DminM[maxM]) ? newLPd0[maxM] : newLPd[maxM][maxs];// NEW8
	      int newLPdPrms = !MDEBUG ? 0 : (VMEM_MINIMIZE && maxS < DminM[maxM]) ? newLPdPr[maxM][0] : newLPdPr[maxM][maxs];// NEW8
	      if(MDEBUG && newLPdPrms)
		printf("S=%d:Site/map with worst deletion error so far is S=%d(%0.3f),m=%d(id=%lld),N1=%d:mLP1[m]=%0.10f,newLPd[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10e:reduced precision(excluding when LP drops by %0.3f or more)\n",
		       I,maxS,Y1[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N1,newLPA1[maxM],newLPdms,trueLP,ErrMax, LP_DROP*0.1);
	      else
		printf("S=%d:Site/map with worst deletion error so far is S=%d(%0.3f),m=%d(id=%lld),N1=%d:mLP1[m]=%0.10f,newLPd[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10e(excluding when LP drops by %0.3f or more)\n",
		       I,maxS,Y1[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N1,newLPA1[maxM],newLPdms,trueLP,ErrMax, LP_DROP*0.1);

#if 1	    
	      printf("Calling mprobeval(%d..%d)=%0.3f..%0.3f (after deleting site Y1[%d]=%0.3f):",imin,imax,Hcuts1[imin],Hcuts1[imax],maxS,Y1[maxS]);
	      fflush(stdout);

	      double mLP1 = mprobeval(n,Hcuts1,newN1,Y1,MD,MX,X,lc,rc,map1,mapK1,limit1,nmap1[MD],TBmapWT,testLPA,bestLPA1,-1.0,-1.0,0,addloc1,0,0,LPdel1,0,0,0,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,0,0,0,0/*newLPdelta,Dcum,AminM,AmaxM*/,pcontig,0,1);
	      printf("mLP1=%0.10f\n",mLP1);
	      fflush(stdout);

#endif
	      if(MDEBUG_S > 0 && MDEBUG_F >= 0 && newN1 == MDEBUG_N-1)
		exit(1);
	      if(DEBUG) assert(ErrMax < MDEBUG_ERR);
	    }
	  }

	  Hdel1[i] = 0;
	}

	if(MDEBUG_T < 0 && MDEBUG_TS < 0 && MDEBUG_TT < 0){
	  if(maxerr >= 0.0)
	    printf("Max site deletion error =%0.10e at I=%d(excluding when LP drops by %0.3f or more)\n",maxerr,maxerrI,LP_DROP);
	  if(ErrMax >= 0.0){
	    int maxs = (!VMEM_MINIMIZE && maxS < DminM[maxM]) ? 0 : min(DmaxM[maxM],maxS);// NEW8
	    double newLPdms = (VMEM_MINIMIZE &&  maxS < DminM[maxM]) ? newLPd0[maxM] : newLPd[maxM][maxs];// NEW8
	    int newLPdPrms = !MDEBUG ? 0 : (VMEM_MINIMIZE && maxS < DminM[maxM]) ? newLPdPr[maxM][0] : newLPdPr[maxM][maxs];// NEW8
	    if(MDEBUG && newLPdPrms)
	      printf("Site/map with worst deletion error is S=%d(%0.3f),m=%d(id=%lld),N1=%d:mLP1[m]=%0.10f,newLPd[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10e:reduced precision (excluding when LP drops by %0.3f or more)\n",
		     maxS,Y1[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N1,newLPA1[maxM],newLPdms,trueLP,ErrMax,LP_DROP*0.1);
	    else
	      printf("Site/map with worst deletion error is S=%d(%0.3f),m=%d(id=%lld),N1=%d:mLP1[m]=%0.10f,newLPd[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10e (excluding when LP drops by %0.3f or more)\n",
		     maxS,Y1[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N1,newLPA1[maxM],newLPdms,trueLP,ErrMax,LP_DROP*0.1);
	    fflush(stdout);
	    if(DEBUG) assert(ErrMax < MDEBUG_ERR);
	  }
	}
	if(DEBUG) assert(maxerr < MDEBUG_ERR);

	int restoredN = setmap(n,Hcuts1,Hdel1,Y1,map1[MD],nmap1[MD]);/* compute Y[] and nmap[MD][0..N+1] and map[MD][0..n+1] */
	score_init(N1,Y1,MD,MX,X);/* precompute likelihood scoring constants/terms */
	if(MDEBUG_M < 0){
	  double qLP = qprobeval(n,Hcuts1,N1,Y1,MD,MX,X,lc,rc,map1,mapK1,limit1,nmap1,0,TBmapWT,testLPA,mapWT1,0,0.0,0.0,0,0,pcontig);
    
	  printf("Restored qLP=%0.10f,N1=%d(%d)\n",qLP,restoredN,N1);
	  fflush(stdout);
	}
	if(DEBUG) assert(restoredN == N1);
	delete [] testLPA;
      } // MDEBUG && (MDEBUG_DEL || ...)

      if(MDEBUG && !HINDELITER(iter) && (MDEBUG_ADD || (MDEBUG_T >= 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0)) && 
	 !(MDEBUG_T < 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0) && !(MDEBUG_T < 0 && MDEBUG_S >= 0 && MDEBUG_F >= 0) && !HINDELITER(iter)){
	double *testLPA = new double[MD];

	/* check LPadd[0..addloc-1] values vs qprobeval */
	double maxerr = -1000.0;/* worst error for any single site addition for LP sum over all maps */
	int maxerrS = -1; /* Existing site in Y[] left of added site */
	int maxerrT = -1; /* Added site in addloc[] corresponding to worst error */
      
	double ErrMax = -1000.0;/* worst error for any single site addition for any single map */
	double trueLP = -1000.0;
	int maxM = -1;
	int maxS = -1;
	int maxT = -1;
	int maxTT = -1;

	int T = 0, S = 0, TT = 0;
	int L = 0;
	for(int i = 1; i <= imax; i++){
          if((HapSite[i-1] & 1))
	    L = i-1;

	  if(!Hdel1[i]){
	    S++;
	    TT = 0;
	    continue;
	  }
	  if(i < imin)
	    continue;
	  if(skip[i] > 0)
	    continue;

	  if(DELTA_STOP >= 2 && iter >= HMIN_ITER && (SKIPMAP_ADD>=2 || !HapSite[i])){
	    int IN = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
	    if(DEBUG) assert(0 <= IN && IN <= maxIN);
	    if(DELTA_RANGE[IN] <= 0)
	      continue;
	  }

	  if(DUP_FIX && !HapSite[i]){ /* also check that no existing site is at the same location as Hcuts[i] */
	    int t = i;
	    while(--t > 0)
	      if(HapSite[t] || Hcuts[t] +1e-3 < Hcuts[i])
		break;
	    if(Hcuts[t] +1e-6 >= Hcuts[i] && HapSite[t])
	      continue;

	    for(t = i; ++t <= n;)
	      if(HapSite[t] || Hcuts[t] > Hcuts[i] + 1e-3)
		break;
	    if(Hcuts[t] <= Hcuts[i] + 1e-6 && HapSite[t])
	      continue;
	  }

	  if((HapSite[L] & 1)){
	    double hapdelta = 0.0, delta = 0.0;
	    for(int t = L; t < i; t++){
	      hapdelta += HapDelta[t];
	      delta += Delta[t];
	    }
	    if(Hcuts[i] - Hcuts[L] + delta + hapdelta < (HapSite[i] ? minKB : minKBadd))
	      continue;
	  }

	  int R = i+1;
	  while(R < n && !(HapSite[R]&1))
	    R++;
	  if(DEBUG) assert(R <= n || i >= n);
	  if((HapSite[R] & 1)){
	    double hapdelta = 0.0, delta = 0.0;	
	    for(int t = i; t < R; t++){
	      hapdelta += HapDelta[t];
	      delta += Delta[t];
	    }
	    if(Hcuts[R] - Hcuts[i] + delta + hapdelta < (HapSite[i] ? minKB : minKBadd))
	      continue;
	  }

	  if(DEBUG && !(T < addcnt1 && addid1[T] == i)){
	    printf("T=%d,addcnt1=%d,i=%d:Hcuts1[i]=%0.3f,addloc1[T]=%0.3f,addid1[T]=%d,n=%d,skip[i]=%d,L=%d,Rt=%d\n",
		   T,addcnt1,i,Hcuts1[i],addloc1[T],addid1[T],n,skip[i],L,R);
	    fflush(stdout);
	    assert(T < addcnt1 && addid1[T] == i);
	  }
	  if(DEBUG) assert(imin <= i && i <= imax);

	  Hdel1[i] = 0;
	
	  if(MDEBUG_S < 0 && (MDEBUG_T <= 0 || T==MDEBUG_T) && T < addcnt1){
	    int newN1 = setmap(n,Hcuts1,Hdel1,Y1,map1[MD],nmap1[MD]);/* compute Y[] and nmap[MD][] and map[MD][] */
	    if(DEBUG) assert(newN1 == N1+1);
	    score_init(newN1,Y1,MD,MX,X);/* precompute likelihood scoring constants/terms */
	  
	    printf("i=%d,S=%d,T=%d:Added Hcuts1[i]=%0.3f,addloc1[T]=%0.3f,Y1[S]=%0.3f..%0.3f:", i, S, T, Hcuts1[i],addloc1[T], Y1[S],Y1[S+2]);
	    fflush(stdout);

	    if(VERB>=3 && iter==1 && i==425)
	      rverb = 1;

	    double qLP = qprobeval(n,Hcuts1,newN1,Y1,MD,MX,X,lc,rc,map1,mapK1,limit1,nmap1,0,TBmapWT,testLPA,mapWT1,bestLPA1,Hcuts1[i],Hcuts1[i],0,0,pcontig);
	    rverb = 0;

	    if(qLP > LP1-LP_DROP || LPadd1[T] > LP1)
	      printf("qLP=%0.10f,LPadd1[T]=%0.10f (error=%0.10f)\n",qLP,LPadd1[T],LPadd1[T]-qLP);
	    else
	      printf("qLP=%0.10f,LPadd[T]=%0.10f (error=%0.10f:ignored) LP1=%0.6f\n",qLP,LPadd1[T],LPadd1[T]-qLP, LP1);
	    if((qLP > LP1-LP_DROP || LPadd1[T] > LP1) && fabs(LPadd1[T]-qLP) > maxerr){
	      maxerr = fabs(LPadd1[T]-qLP);
	      maxerrS = S;
	      maxerrT = T;
	    }

	    double sumLPaTm = 0.0, sumtest = 0.0;
	    for(int m = 0; m < MD; m++){
	      int t = (T < TminM[m]) ? TminM[m] : (T > TmaxM[m]) ? TmaxM[m] : T;
	      double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
	      sumLPaTm += newLPa[m][t] * TBwtm;
	      sumtest += testLPA[m] * TBwtm;
	      if(VERB && (VERB>=2 /* ||(iter==1&&m==8&&T==8) */ || (T==maxerrT && S==maxerrS && maxerr > MDEBUG_ERR) || (T==MDEBUG_T && m==MDEBUG_M) 
			  /* || ((testLPA[m] > newLPA[m]-LP_DROP*0.1 || newLPa[m][T] > newLPA[m]) && fabs(newLPa[m][T]-testLPA[m]) *TBwtm > MDEBUG_ERR)*/ )){
		printf("S=%d,T=%d,m=%d(id=%lld):wt=%0.10f,mLP1[m]=%0.10f,bestLPA1[m]=%0.10f,newLPa[m][T]=%0.10f,testLPA[m]=%0.10f(err=%0.10f, cumwt=%0.10f)",
		       S,T,m,gmap[pcontig->contig[m].mapid]->id,TBwtm,newLPA1[m],bestLPA1[m],newLPa[m][t], testLPA[m],newLPa[m][t] - testLPA[m], sumLPaTm - sumtest);
		if(testLPA[m] <= newLPA1[m] - LP_DROP && newLPa[m][t] <= newLPA1[m])
		  printf(":ignored");
		if(MDEBUG && newLPaPr[m][t])
		  printf(":reduced precision");
		printf("\n");
		fflush(stdout);
	      }
	      if(DEBUG) assert(newLPa[m][t] > -1e98); 
	      if((testLPA[m] > newLPA1[m]-LP_DROP*0.1 || newLPa[m][t] > newLPA1[m] || maxerr > MDEBUG_ERR) && fabs(newLPa[m][t]-testLPA[m]) * TBwtm > ErrMax && (!MDEBUG_NEGERR || newLPa[m][t] < testLPA[m])){
		ErrMax = fabs(newLPa[m][t]-testLPA[m]) * TBwtm;
		trueLP = testLPA[m];
		maxS = S;
		maxT = T;
		maxTT = TT;
		maxM = m;
	      }
	    }
	    if(DEBUG && ErrMax >= 0.0) assert(maxT >= 0 && maxM >= 0);
	    
	    if(ErrMax >= 0.0 && ((MDEBUG_T > 0 && MDEBUG_TS >= 0 && newN1 == MDEBUG_N+1) /* || ErrMax >= MDEBUG_ERR*/)){
	      int maxt = (maxT < TminM[maxM]) ? TminM[maxM] : (maxT > TmaxM[maxM]) ? TmaxM[maxM] : maxT;
	      if(MDEBUG && newLPaPr[maxM][maxt])
		printf("T=%d:Site/map with worst site addition error so far is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N1=%d:mLP[m]=%0.10f,newLPa[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e:reduced precision(excluding when LP drops by %0.3f or more)\n",
		       T,maxS,Y1[maxS],Y1[maxS+2],maxT,addloc1[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N1,newLPA1[maxM],newLPa[maxM][maxt],trueLP,ErrMax, LP_DROP*0.1);
	      else
		printf("T=%d:Site/map with worst site addition error so far is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N1=%d:mLP[m]=%0.10f,newLPa[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e(excluding when LP drops by %0.3f or more)\n",
		       T,maxS,Y1[maxS],Y1[maxS+2],maxT,addloc1[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N1,newLPA1[maxM],newLPa[maxM][maxT],trueLP,ErrMax, LP_DROP*0.1);
	      fflush(stdout);
	      
#if 0
	      printf("Calling mprobeval(%d..%d)=%0.3f..%0.3f (after adding site addloc1[%d]=%0.3f):",imin,imax,Hcuts1[imin],Hcuts1[imax],maxT,addloc1[maxT]);
	      fflush(stdout);

	      double mLP2 = mprobeval(n,Hcuts1,newN1,Y1,MD,MX,X,lc,rc,map1,mapK1,nmap1[MD],TBmapWT,testLPA,0/*bestLPA1*/,-1.0,-1.0,0,addloc1,0,0,LPdel1,0,0,0,newLPd,newLPd0,newLPdPr,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,newLPdelta,Dcum,AminM,AmaxM,pcontig,0,1);
	      printf("mLP2=%0.10f\n",mLP2);
	      fflush(stdout);
#endif

	      if(MDEBUG_T > 0 && MDEBUG_TS >= 0 && newN1 == MDEBUG_N+1)
		exit(1);
	      assert(ErrMax < MDEBUG_ERR);
	    }
	  }
	  T++;
	  TT++;
	  Hdel1[i] = 1;
	}

	if(MDEBUG_T < 0 && MDEBUG_TS < 0 && MDEBUG_TT < 0){
	  if(maxerr >= 0.0)
	    printf("Worst site addition error =%0.10e at T=%d(%0.3f) interval S=%d(%0.3f..%0.3f)(excluding when LP drops by %0.3f or more)\n",
		   maxerr,maxerrT,addloc1[maxerrT],maxerrS,Y1[maxerrS],Y1[maxerrS+1],LP_DROP);
	  if(ErrMax >= 0.0){
	    int maxt = (maxT < TminM[maxM]) ? TminM[maxM] : (maxT > TmaxM[maxM]) ? TmaxM[maxM] : maxT;
	    if(MDEBUG && newLPaPr[maxM][maxt])
	      printf("Site/map with worst site addition error is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N1=%d:mLP[m]=%0.10f,newLPa[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e:reduced precision(excluding when LP drops by %0.3f or more)\n",
		     maxS,Y1[maxS],Y1[maxS+1],maxT,addloc1[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N1,newLPA1[maxM],newLPa[maxM][maxt],trueLP,ErrMax, LP_DROP*0.1);
	    else
	      printf("Site/map with worst site addition error is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N1=%d:mLP[m]=%0.10f,newLPa[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e(excluding when LP drops by %0.3f or more)\n",
		     maxS,Y1[maxS],Y1[maxS+1],maxT,addloc1[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N1,newLPA1[maxM],newLPa[maxM][maxt],trueLP,ErrMax, LP_DROP*0.1);
	    fflush(stdout);
	    if(DEBUG) assert(ErrMax < MDEBUG_ERR * 100.0);
	  }
	  fflush(stdout);
	}

	if(DEBUG) assert(maxerr < MDEBUG_ERR);

	int restoredN = setmap(n,Hcuts1,Hdel1,Y1,map1[MD],nmap1[MD]);
	score_init(N1,Y1,MD,MX,X);
	if(MDEBUG_M < 0){
	  double qLP = qprobeval(n,Hcuts1,N1,Y1,MD,MX,X,lc,rc,map1,mapK1,limit1,nmap1,0,TBmapWT,testLPA,mapWT1,0,0.0,0.0,0,0,pcontig);
    
	  printf("Restored qLP=%0.10f,N1=%d(%d)\n",qLP,restoredN,N1);
	  fflush(stdout);
	}
	if(DEBUG) assert(restoredN == N1);
	delete [] testLPA;
      } /* if(MDEBUG ...)  */

      if(MDEBUG && HINDELITER(iter) && (MDEBUG_DELTA || (MDEBUG_TS >= 0 &&  MDEBUG_TT >= 0)) && MDEBUG_T < 0 && MDEBUG_S < 0){/* check newLPdelta[][][] */
	double *testLPA = new double[MD];
	double *fixY = new double[N1+2];
	double *fixYdel = new double[N1+2];
	double *fixHcuts = new double[n+2];
	double *fixHcutsDel = new double[n+2];

	fixY[0] = fixYdel[0] = 0.0;
	for(int I=1; I <= N1+1; I++){
	  fixY[I] = Y1[I];
	  fixYdel[I] = Y1[I]-Y1[I-1];
	}

	fixHcuts[0] = fixHcutsDel[0] = 0.0;
	for(int i = 1; i <= n+1; i++){
	  fixHcuts[i] = Hcuts1[i];
	  fixHcutsDel[i] = Hcuts1[i] - Hcuts1[i-1];
	}

	double maxerr = -1000.0;/* worst error for any single interval change for LP sum over all maps */
	int maxerrT = -1;/* interval left site, corresponding to worst error */
	int maxerrD = -1;/* change value index, corresponding to worse error */

	double ErrMax = -1000.0;/* worst error for any single interval change for any single map */
	double trueLP = -1000.0;
	int maxM = -1;/* map index */
	int maxT = -1;/* interval left site */
	int maxD = -1;/* change value index */

	for(int Q=1; Q < N1; Q++){
	  //	  if(Q != 3022)  continue;

	  if(D1[Q] <= 0)
	    continue;
	  int q0 = nmap1[MD][Q];
	  int q1 = nmap1[MD][Q+1];
	  /*	fixHcuts[q0..q1] corresponds to fixY[Q..Q+1] */

	  double origval = fixYdel[Q+1];
	  if(DEBUG) assert(origval > 0.0);

	  for(int t = 0; t < D1[Q]; t++){
	    if((MDEBUG_TS < 0 || Q==MDEBUG_TS) && (MDEBUG_TT < 0 || t==MDEBUG_TT) && MDEBUG_T < 0 && MDEBUG_S < 0){
	      double testLP = LPdelta1[Q][t];
	      double val = delta1[Q][t] + origval;
	      double ratio = val/origval;
	      fixYdel[Q+1] = val;
	      for(int q = q0+1; q <= q1; q++)
		fixHcutsDel[q] *= ratio;

	      double cum = 0.0;
	      fixY[0] = cum;
	      for(int I = 1; I <= N1+1; I++){
		cum += fixYdel[I];
		fixY[I] = cum;
	      }
	      fixHcuts[0] = cum = 0.0;
	      for(int q = 1; q <= n+1; q++){
		cum += fixHcutsDel[q];
		fixHcuts[q] = cum;
	      }
	      if(DEBUG) assert(fabs(fixHcuts[q0] - fixY[Q]) < 1e-8);
	      if(DEBUG) assert(fabs(fixHcuts[q1] - fixY[Q+1]) < 1e-8);

	      score_init(N1,fixY,MD,MX,X);

#if 0
	      if(Q==MDEBUG_TS && t==MDEBUG_TT){
		rverb = 1;

		printf("Validating Q=%d,t=%d,Y1[Q..Q+1]=%0.4f -> %0.4f (delta1[Q][t]= %0.4f)\n", Q,t, Y1[Q+1]-Y1[Q],Y1[Q+1]-Y1[Q]+delta1[Q][t],delta1[Q][t]);
		fflush(stdout);
	      }
	      if(MDEBUG && t==0) {
		rverb = 2;
		printf("Validating Q=%d,t=%d,Y1[Q..Q+1]=%0.8f -> %0.8f (delta1[Q][t]= %0.8f)\n", Q,t, Y1[Q+1]-Y1[Q],Y1[Q+1]-Y1[Q]+delta1[Q][t],delta1[Q][t]);
		fflush(stdout);
	      }
#endif
	      double qLP2 = qprobeval(n,fixHcuts,N1,fixY,MD,MX,X,lc,rc,map1,mapK1,limit2,nmap1,0,TBmapWT,testLPA,mapWT1,bestLPA1,fixY[Q],fixY[Q+1],0,0,pcontig);
	      //	      rverb = 0;

	      if(VERB){
		if(qLP2 > LP1 - LP_DROP || testLP > LP1)
		  printf("    Y[%d..%d]=%0.6f->%0.6f(t=%d/%d): testLP=%0.10f (delta=%0.10f), qLP2=%0.10f (err = %0.10f)\n", 
			 Q,Q+1, origval, val, t, D1[Q], testLP, testLP - LP1, qLP2, testLP - qLP2);
		else
		  printf("    Y[%d..%d]=%0.6f->%0.6f(t=%d/%d): testLP=%0.10f (delta=%0.10f), qLP2=%0.10f (err = %0.10f:ignored)\n", 
			 Q,Q+1,origval, val, t, D1[Q], testLP, testLP - LP1, qLP2, testLP - qLP2);
		fflush(stdout);
	      }
	      if((qLP2 > LP1 - LP_DROP || testLP > LP1) && fabs(testLP-qLP2) > maxerr && (!MDEBUG_NEGERR || testLP < qLP2)){
		maxerr = fabs(testLP - qLP2);
		maxerrT = Q;
		maxerrD = t;
	      }
	      double sumLPmQt = 0.0, sumtest = 0.0;
	      for(int m = 0; m < MD; m++){
		double newLPmQt = (Q >= AminM[m] && Q <= AmaxM[m]) ? newLPdelta[m][Dcum[Q]-Dcum[AminM[m]]+t] : newLPA1[m];
		double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
		sumLPmQt += newLPmQt * TBwtm;
		sumtest += testLPA[m] * TBwtm;
		if(VERB && (VERB>=2 || (MDEBUG && t==0) || (Q==MDEBUG_TS && t==MDEBUG_TT && m==MDEBUG_M))){
		  printf("Q=%d,t=%d,m=%d(id=%lld):mLP1[m]=%0.10f,newLPdelta1[m][S,d]=%0.10f,testLPA[m]=%0.10f(err=%0.10f)",
			 Q,t,m,gmap[pcontig->contig[m].mapid]->id, newLPA1[m], newLPmQt, testLPA[m], newLPmQt - testLPA[m]);
		  if(testLPA[m] <= newLPA1[m] - LP_DROP*0.1 && newLPdelta[m][Dcum[Q]-Dcum[AminM[m]]+t] <= newLPA1[m])
		    printf(":ignored");
		  printf("\n");
		  fflush(stdout);
		}
		if(DEBUG) assert(newLPmQt > LARGE_NEGATIVE * 0.9);
		if((testLPA[m] > newLPA1[m] - LP_DROP*0.1 || newLPmQt > newLPA1[m]) && fabs(newLPmQt-testLPA[m]) *TBwtm > ErrMax && (!MDEBUG_NEGERR || newLPmQt < testLPA[m])){
		  ErrMax = fabs(newLPmQt - testLPA[m]) * TBwtm;
		  trueLP = testLPA[m];
		  maxT = Q;
		  maxD = t;
		  maxM = m;
		}
	      }

	      if(DEBUG) assert(fabs(sumLPmQt - N1*SITE_PEN - testLP) < 1e-8);
	      if(DEBUG) assert(fabs(sumtest - N1*SITE_PEN - qLP2) < 1e-8);

	      if(ErrMax >= 0.0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0 && N1 == MDEBUG_N && maxT >= 0){
		double newLPmQt = (maxT >= AminM[maxM] && maxT <= AmaxM[maxM]) ? newLPdelta[maxM][Dcum[maxT]-Dcum[AminM[maxM]]+maxD] : newLPA1[maxM];
		printf("Interval/Delta/map with worst error so far is Q=%d(%0.3f),t=%d(%0.3f),m=%d(id=%lld):mLP1[m]=%0.10f,newLPdelta1[m][Q,t]=%0.10f,trueLP=%0.10f,|err|=%0.10e\n",
		       maxT,fixYdel[maxT],maxD,delta1[maxT][maxD],maxM,gmap[pcontig->contig[maxM].mapid]->id,newLPA1[maxM],newLPmQt,trueLP,ErrMax);
		fflush(stdout);
		if(DEBUG) assert(maxT >= 0 && maxM >= 0 && maxD >= 0);

#if 0
		double mLP2 = mprobeval(n,fixHcuts,N1,fixY,MD,MX,X,lc,rc,map1,mapK1,nmap1[MD],TBmapWT,testLPA,0/*bestLPA1*/,0.0/*fixY[Q]*/,0.0/*fixY[Q+1]*/,0,0,0,delta1,LPdel1,0,0,0,/*newLPd*/0,/*newLPd0*/0,/*newLPdPr*/0,DminM,DmaxM,newLPa,newLPaPr,TminM,TmaxM,newLPdelta,Dcum,AminM,AmaxM,pcontig,0,1);
		printf("mLP2=%0.10f\n",mLP2);
		fflush(stdout);
#endif

		if(MDEBUG_TS >= 0 && MDEBUG_TT >= 0 && N1 == MDEBUG_N)
		  exit(1);
		assert(ErrMax < MDEBUG_ERR);
	      }

	      /* restore original value of fixYdel[Q+1] and fixHcutsDel[q0+1..q1] */
	      fixYdel[Q+1] = origval;
	      for(int q = q0+1; q <= q1; q++)
		fixHcutsDel[q] = Hcuts1[q] - Hcuts1[q-1];
	    }
	  } /* t = 0 .. D1[Q] - 1 */
	} /* Q = 1 .. N1-1 */
	if(MDEBUG_T < 0){
	  if(maxerr >= 0.0){
	    printf("Max interval change error =%0.10e at Q=%d,t=%d(%0.3f) (excluding when LP drops by %0.3f or more)\n",maxerr,maxerrT,maxerrD,delta1[maxerrT][maxerrD],LP_DROP);
	    fflush(stdout);
	    if(DEBUG) assert(maxerrT >= 0 && maxerrD >= 0);
	  }
	  if(ErrMax >= 0.0){
	    double newLPmQt = (maxT >= AminM[maxM] && maxT <= AmaxM[maxM]) ? newLPdelta[maxM][Dcum[maxT]-Dcum[AminM[maxM]]+maxD] : newLPA1[maxM];
	    printf("Interval/change/map with worst interval change error is Q=%d(%0.3f),t=%d(%0.3f),m=%d(id=%lld),N1=%d:mLP1[m]=%0.10f,newLPdelta[m][Q,t]=%0.10f,trueLP=%0.10f,|err|=%0.10e(excluding when LP drops by %0.3f or more)\n",
		   maxT,fixYdel[maxT+1],maxD,delta1[maxT][maxD],maxM,gmap[pcontig->contig[maxM].mapid]->id,N1,newLPA1[maxM],newLPmQt,trueLP,ErrMax,LP_DROP*0.1);
	    fflush(stdout);
	    if(DEBUG) assert(maxT >= 0 && maxD >= 0 && maxM >= 0);
	    if(DEBUG) assert(ErrMax < MDEBUG_ERR);
	  }
	}

	delete [] testLPA;
	delete [] fixY;
	delete [] fixYdel;
	delete [] fixHcuts;
	delete [] fixHcutsDel;
      } /* if(MDEBUG ...)  */

      // MDEBUG = 0;

      if(VERB>=4 && N1 > 30 && iter==25 && HINDELITER(iter)){
	int IN1 = ID1[30];
	printf("Before mprobeval for HaploType 2: iter=%d,D1[30]=%d,DR1[30]=%d,IN1[30]=%d,DELTA_RANGE[IN1]=%d\n",
	       iter,D1[30],DR1[30],ID1[30],DELTA_RANGE[IN1]);
	for(int t = 0; t < D1[30]; t++){
	  printf("  delta1[30][%d] = %0.6f\n", t, delta1[30][t]);
	  fflush(stdout);
	  if(DEBUG && t < DR1[30] && t >= DELTA_RANGE[IN1]) assert(delta1[30][t] < 0.0);
	}
      }

      if(VERB>=2 || SPEEDCHECK){
	if(HINDELITER(iter)){
	  int Dcnt = 0;
	  for(int S = 0; S < N2; S++){
	    if(DEBUG) assert(D2[S] >= 0);
	    Dcnt += D2[S];
	    if(DEBUG>=3){
	      for(int t = 0; t < D2[S]; t++)
		if(fabs(delta2[S][t]) >= 1000.0){
		  printf("WARNING:delta2[S=%d][t=%d] = %0.4f : N2=%d, D2[S]=%d\n",S,t,delta2[S][t],N2,D2[S]);
		  fflush(stdout);
		  assert(fabs(delta2[S][t] < 1000.0));
		}
	    }
	  }
	  printf("Calling mprobeval for HaploType 2: iter=%d,N2=%d,sum(D2)=%d:", iter,N2, Dcnt);
	} else
	  printf("Calling mprobeval for HaploType 2: iter=%d,N2=%d,addcnt2=%d:", iter,N2, addcnt2);
	fflush(stdout);
      }
      if(MDEBUG || iter > 0 || SNPcnt > 0 || IndelCnt > 0)
	score_init(N2,Y2,MD,MX,X);// needed to precompute the correct tables when Y1 != Y2
      start = mtime(); wstart = wtime();
      if(DEBUG)
	for(int m = 0; m < MD; m++)
	  TminM2[m] = TmaxM2[m] = AminM2[m] = AmaxM2[m] = DminM2[m] = DmaxM2[m] = -1;

      //      rverb = (iter == 23) ? 1 : 0;

#if 0
      MDEBUG = (iter == 11) ? 1 : 0;
      printf("iter=%d:MDEBUG=%d,MDEBUG_TS=%d,MDEBUG_TT=%d\n",iter,MDEBUG,MDEBUG_TS,MDEBUG_TT);
      fflush(stdout);
#endif
      double LP2 = HINDELITER(iter) ?
	mprobeval(n, Hcuts2, N2, Y2, MD, MX, X, lc, rc, map2, mapK2, limit2, nmap2[MD], TBmapWT, newLPA2, bestLPA2, 0.0/*Ymin*/, Y2[N2+1]/*Ymax*/, 0, 0, D2, delta2, /* LPdel2 */ 0, LPadd2, 0, LPdelta2, 
		  /* newLPd2 */0, /*newLPd20*/ 0, /*newLPdPr2*/ 0, DminM2, DmaxM2, newLPa2, newLPaPr2, TminM2, TmaxM2, newLPdelta2, Dcum2, AminM2, AmaxM2, pcontig, /* skipmap */ 0, 2, pBlock2) :
	mprobeval(n, Hcuts2, N2, Y2, MD, MX, X, lc, rc, map2, mapK2, limit2, nmap2[MD], TBmapWT, newLPA2, bestLPA2, -1.0/*Ymin*/, -1.0/*Ymax*/, addcnt2, addloc2, 0, 0, LPdel2, LPadd2, 0, 0,
		  newLPd2, newLPd20, newLPdPr2, DminM2, DmaxM2, newLPa2, newLPaPr2, TminM2, TmaxM2, 0, 0, 0, 0, pcontig, /* skipmap */0, 2);
      rverb = 0;
    
      if(DEBUG>=2){
	if(HINDELITER(iter)){
	  for(int m = 0; m < MD; m++)
	    assert(0 <= AminM2[m] && AmaxM2[m] <= N2+1);
	} else {
	  if(addcnt2)
	    for(int m = 0; m < MD; m++){
	      if(!(0 <= TminM2[m] && TmaxM2[m] < addcnt2)){
		printf("m=%d/%d:TminM2[m]=%d,TmaxM2[m]=%d,addcnt2=%d\n",m,MD,TminM2[m],TmaxM2[m],addcnt2);
		fflush(stdout);
		assert(0 <= TminM2[m] && TmaxM2[m] < addcnt2);
	      }
	    }
	  for(int m = 0; m < MD; m++)
	    assert(1 <= DminM2[m] && DmaxM2[m] <= N2);
	}
      }

      if(VERB>=2 || SPEEDCHECK){
	double wt = wtime();
	printf(" LP=%0.6f: time=%0.6f, wall time=%0.6f (cum=%0.6f)\n",LP2, mtime()-start, wt-wstart,wt);
	fflush(stdout);
      }
      if(TIME_VERBOSE){
	getmem(VmSize,VmRSS, VmSwap);
	double InvGB = 1e-9;	
	printf("iter=%d:After calling mprobeval: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: cum wall= %0.6f\n", iter, VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB,wtime());
	fflush(stdout);
      }

      if(VMEM_MINIMIZE){
	SwappedAllocations_ListSort();

	if(!(MPROBEVAL_LAZYRESTORE && HINDEL_FAST>=2) || !HINDELITER(iter)){
	  SwappedAllocations_restore();

	  if(TIME_VERBOSE){
	    getmem(VmSize,VmRSS, VmSwap);
	    double InvGB = 1e-9;	
	    printf("iter=%d:After calling SwappedAllocations_restore: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: cum wall= %0.6f\n", iter, VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB,wtime());
	    fflush(stdout);
	  }
	}
      }

      //      if(iter >= 12) exit(1);

      if(MDEBUG && !HINDELITER(iter) && (MDEBUG_DEL || (MDEBUG_S >= 0 && MDEBUG_F >= 0)) && !(MDEBUG_T < 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0) && !(MDEBUG_T >= 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0)){
	double *testLPA = new double[MD];
      
	/* check LPdel2[1..N1] vs qprobeval() */
	double maxerr = -1000.0;/* worst error for any single site deletion for LP sum over all maps (excluding those that dropped more than LP_DROP) */
	int maxerrI = -1;

	double ErrMax = -1000.0;/* worst error for any single site deletion for any single map (excluding those that dropped more than LP_DROP) */
	double trueLP = -1000.0;
	int maxS = -1;
	int maxM = -1;

	int I = 0;
	if(VERB>=2){
	  for(int i = 1; i <= n; i++)
	    I += (Hdel2[i] ? 0 : 1);
	  printf("Initial number of sites in Hdel2[1..n] = %d, N2=%d\n",I,N2);
	  fflush(stdout);
	  I = 0;
	}

	for(register int i = 1; i <= n; i++){
	  if(Hdel2[i])
	    continue;
	  I++;
	  if(i < imin || i > imax)
	    continue;

	  Hdel2[i] = 1;
	  if(VERB>=2 && i==449){
	    printf("Testing site deletion at Hcuts2[i=%d]=%0.3f\n",i,Hcuts2[i]);
	    fflush(stdout);
	  }
	  if((MDEBUG_S <= 0 || I==MDEBUG_S) && MDEBUG_T < 0 && MDEBUG_TS < 0 && MDEBUG_TT < 0){
	    int newN2 = setmap(n,Hcuts2,Hdel2,Y2,map2[MD],nmap2[MD]);/* compute Y2[] and nmap2[MD][0..N+1] and map2[MD][0..n+1] */
	    if(DEBUG && !(newN2 == N2-1)){
	      printf("i=%d:Hdel2[i] -> %d, N2=%d,newN2=%d\n",i,Hdel2[i],N2,newN2);
	      fflush(stdout);
	      assert(newN2 == N2-1);
	    }

	    score_init(newN2,Y2,MD,MX,X);/* precompute likelihood scoring constants/terms */

	    printf("i=%d,I2=%d:Deleted Hcuts2[i]=%0.3f:", i,I,Hcuts2[i]);
	    fflush(stdout);

	    double qLP = qprobeval(n,Hcuts2,newN2,Y2,MD,MX,X,lc,rc,map2,mapK2,limit2,nmap2,0,TBmapWT,testLPA,mapWT2,0/*bestLPA2*/,0.0/*Hcuts2[imin]*/,0.0/*Hcuts2[imax]*/,0,0,pcontig);
	    if(qLP > LP2 - LP_DROP || LPdel2[I] > LP2)
	      printf("qLP=%0.10f,LPdel2[I]=%0.10f (error=%0.10f)\n",qLP,LPdel2[I],LPdel2[I]-qLP);
	    else
	      printf("qLP=%0.10f,LPdel2[I]=%0.10f (error=%0.10f:ignored) LP2=%0.6f\n",qLP,LPdel2[I],LPdel2[I]-qLP, LP2);
	    if((qLP > LP2 - LP_DROP || LPdel2[I] > LP2) && fabs(LPdel2[I]-qLP) > maxerr){
	      maxerr = fabs(LPdel2[I]-qLP);
	      maxerrI = I;
	    }
	    if(VERB>=2 && i==449){
	      if(VERB>=2){
		printf("N1=%d,N2=%d\n",N1,newN2);
		for(int t = 1; t <= n; t++)
		  printf("i=%d:Hdel1[i]=%d,Hdel2[i]=%d,Hcuts2[i]=%0.3f\n",t,Hdel1[t],Hdel2[t],Hcuts2[t]);
		for(int T = 1; T <= newN2+1; T++)
		  printf("I2=%d:Y2[I2]=%0.3f\n",T,Y2[T]);
		fflush(stdout);
	      }

	      for(int m = 0; m < MD; m++){
		int t = (!VMEM_MINIMIZE && I < DminM2[m]) ? 0 : min(DmaxM2[m],I);// NEW8
		double newLPd2mt = (VMEM_MINIMIZE && I < DminM2[m]) ? newLPd20[m] : newLPd2[m][t];// NEW8
		printf("m=%d/%d:I2=%d,DminM2[m]=%d,DmaxM2[m]=%d,t=%d:newLPd2[m][t]=%0.6f,testLPA[m]=%0.6f\n",
		       m,MD,I,DminM2[m],DmaxM2[m],t,newLPd2mt,testLPA[m]);
	      }
	      fflush(stdout);
	    }

	    double sumLPdIm = 0.0, sumtest = 0.0;
	    for(int m = 0; m < MD; m++){
	      double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
	      int t = (!VMEM_MINIMIZE && I < DminM2[m]) ? 0 : min(DmaxM2[m],I);// NEW8
	      double newLPd2mt = (VMEM_MINIMIZE && I < DminM2[m]) ? newLPd20[m] : newLPd2[m][t];// NEW8
	      int newLPdPr2mt = !MDEBUG ? 0 : (VMEM_MINIMIZE && I < DminM2[m]) ? newLPdPr2[m][0] : newLPdPr[m][t];// NEW8
	      if(VERB && (VERB>=2 || (I==maxerrI && maxerr > MDEBUG_ERR) || (I==MDEBUG_S && m==MDEBUG_M))){
		printf("I=%d,m=%d(id=%lld):wt=%0.10f,mLPA2[m]=%0.10f,bestLPA2[m]=%0.10f,newLPd2[m][I]=%0.10f,trueLPA[m]=%0.10f(err=%0.10f)",
		       I,m,gmap[pcontig->contig[m].mapid]->id,TBwtm,newLPA2[m],bestLPA2[m],newLPd2mt,testLPA[m],newLPd2mt-testLPA[m]);
		if(testLPA[m] <= newLPA2[m] - LP_DROP && newLPd2mt <= newLPA2[m])
		  printf(":ignored");
		if(MDEBUG && newLPdPr2mt)
		  printf(":reduced precision");
		printf("\n");
		fflush(stdout);
	      }
	      if(DEBUG) assert(newLPd2mt > -1e98); 
	      sumLPdIm += newLPd2mt * TBwtm;
	      sumtest += testLPA[m] * TBwtm;
	      if((testLPA[m] > newLPA2[m] - LP_DROP*0.1 || newLPd2mt > newLPA2[m] || maxerr > MDEBUG_ERR) && fabs(newLPd2mt-testLPA[m]) * TBwtm > ErrMax && (!MDEBUG_NEGERR || newLPd2mt < testLPA[m])){
		ErrMax = fabs(newLPd2mt-testLPA[m]);
		trueLP = testLPA[m];
		maxS = I;
		maxM = m;
	      }
	    }
	    if(DEBUG && ErrMax >= 0.0) assert(maxS >= 0 && maxM >= 0);
	    if(DEBUG && !(fabs(sumLPdIm - newN2*SITE_PEN - LPdel2[I]) < 1e-8 && fabs(sumtest-newN2*SITE_PEN -qLP) < 1e-8)){
	      printf("WARNING:sum(newLPd2[m=0..%d][I])=%0.10f(newN2=%d,SITE_PEN=%0.6f),LPdel2[I]=%0.10f(err=%0.10f)\n",MD-1,sumLPdIm, newN2,SITE_PEN,LPdel2[I],(sumLPdIm - newN2*SITE_PEN - LPdel2[I]));
	      fflush(stdout);

	      double sum1=0.0,sum2=0.0, sum3=0.0;
	      for(int m = 0; m < MD; m++){
		double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
		int i = (!VMEM_MINIMIZE && I < DminM2[m]) ? 0 : min(DmaxM2[m],I);// NEW8
		double newLPd2mi = (VMEM_MINIMIZE && I < DminM2[m]) ? newLPd20[m] : newLPd2[m][i];// NEW8
		int newLPdPr2mi = !MDEBUG ? 0 : (VMEM_MINIMIZE && I < DminM2[m]) ? newLPdPr2[m][0] : newLPdPr2[m][i];// NEW8
		sum1 += newLPd2mi * TBwtm;
		sum2 += testLPA[m] * TBwtm;
		sum3 += newLPA2[m] * TBwtm;
		printf("I=%d,m=%d(id=%lld):wt=%0.10f,newLPd2[m][I]=%0.10f(cum=%0.10f),testLPA[m]=%0.10f(cum=%0.10f):err=%0.10f(cum=%0.10f):mLPA2[m]=%0.10f(cum=%0.10f):",
		       I,m,gmap[pcontig->contig[m].mapid]->id,TBwtm,newLPd2mi,sum1,testLPA[m],sum2,newLPd2mi-testLPA[m],sum1-sum2, newLPA2[m], sum3);
		if(testLPA[m] <= newLPA2[m] - LP_DROP && newLPd2mi <= newLPA2[m])
		  printf(":ignored");
		if(MDEBUG && newLPdPr2mi)
		  printf(":reduced precision");
		printf("\n");
	      }
	      fflush(stdout);
	      assert(fabs(sumLPdIm - newN2*SITE_PEN - LPdel2[I]) < 1e-8);
	      assert(fabs(sumtest-newN2*SITE_PEN - qLP) < 1e-8);
	    }

	    if(ErrMax >= 0.0 && ((MDEBUG_S > 0 && MDEBUG_F >= 0 && newN2 == MDEBUG_N-1) /* || ErrMax >= MDEBUG_ERR*/)){
	      int maxs = (!VMEM_MINIMIZE && maxS < DminM2[maxM]) ? 0 : min(DmaxM2[maxM],maxS);
	      double newLPd2ms = (VMEM_MINIMIZE && maxS < DminM2[maxM]) ? newLPd20[maxM] : newLPd2[maxM][maxs];// NEW8
	      int newLPdPr2ms = !MDEBUG ? 0 : (VMEM_MINIMIZE && maxS < DminM2[maxM]) ? newLPdPr2[maxM][0] : newLPdPr2[maxM][maxs];// NEW8
	      if(MDEBUG && newLPdPr2ms)
		printf("S=%d:Site/map with worst deletion error so far is S=%d(%0.3f),m=%d(id=%lld),N2=%d:mLP2[m]=%0.10f,newLPd2[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10e:reduced precision(excluding when LP drops by %0.3f or more)\n",
		       I,maxS,Y2[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N2,newLPA2[maxM],newLPd2ms,trueLP,ErrMax, LP_DROP*0.1);
	      else
		printf("S=%d:Site/map with worst deletion error so far is S=%d(%0.3f),m=%d(id=%lld),N2=%d:mLP2[m]=%0.10f,newLPd2[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10e(excluding when LP drops by %0.3f or more)\n",
		       I,maxS,Y2[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N2,newLPA2[maxM],newLPd2ms,trueLP,ErrMax, LP_DROP*0.1);

#if 0	    
	      printf("Calling mprobeval(%d..%d)=%0.3f..%0.3f (after deleting site Y2[%d]=%0.3f):",imin,imax,Hcuts2[imin],Hcuts2[imax],maxS,Y2[maxS]);
	      fflush(stdout);

	      double mLP2 = mprobeval(n,Hcuts2,newN2,Y2,MD,MX,X,lc,rc,map2,mapK2,nmap2[MD],TBmapWT,testLPA,0 /*bestLPA2*/,-1.0/*Hcuts2[imin]*/,-1.0/*Hcuts2[imax]*/,0,addloc2,0,0,LPdel2,0,0,0,newLPd2,newLPd20,newLPdPr2,DminM2,DmaxM2,newLPa2,newLPaPr2,TminM2,TmaxM2,newLPdelta2,Dcum2,AminM2,AmaxM2,pcontig,0);
	      printf("mLP2=%0.10f\n",mLP2);
	      fflush(stdout);

#endif
	      if(MDEBUG_S > 0 && MDEBUG_F >= 0 && newN2 == MDEBUG_N-1)
		exit(1);
	      if(DEBUG) assert(ErrMax < MDEBUG_ERR);
	    }
	  }

	  Hdel2[i] = 0;
	}

	if(MDEBUG_T < 0 && MDEBUG_TS < 0 && MDEBUG_TT < 0){
	  if(maxerr >= 0.0)
	    printf("Max site deletion error =%0.10e at I=%d(excluding when LP drops by %0.3f or more)\n",maxerr,maxerrI,LP_DROP);
	  if(ErrMax >= 0.0){
	    int maxs = (!VMEM_MINIMIZE && maxS < DminM2[maxM]) ? 0 : min(DmaxM2[maxM],maxS);
	    double newLPd2ms = (VMEM_MINIMIZE && maxS < DminM2[maxM]) ? newLPd20[maxM] : newLPd2[maxM][maxs];// NEW8
	    int newLPdPr2ms = !MDEBUG ? 0 : (VMEM_MINIMIZE && maxS < DminM2[maxM]) ? newLPdPr2[maxM][0] : newLPdPr2[maxM][maxs];// NEW8
	    if(MDEBUG && newLPdPr2ms)
	      printf("Site/map with worst deletion error is S=%d(%0.3f),m=%d(id=%lld),N2=%d:mLP2[m]=%0.10f,newLPd2[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10e:reduced precision (excluding when LP drops by %0.3f or more)\n",
		     maxS,Y2[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N2,newLPA2[maxM],newLPd2ms,trueLP,ErrMax,LP_DROP*0.1);
	    else
	      printf("Site/map with worst deletion error is S=%d(%0.3f),m=%d(id=%lld),N2=%d:mLP2[m]=%0.10f,newLPd2[m][S]=%0.10f,trueLP=%0.10f,|err|=%0.10e (excluding when LP drops by %0.3f or more)\n",
		     maxS,Y2[maxS],maxM,gmap[pcontig->contig[maxM].mapid]->id,N2,newLPA2[maxM],newLPd2ms,trueLP,ErrMax,LP_DROP*0.1);
	    fflush(stdout);
	    if(DEBUG) assert(ErrMax < MDEBUG_ERR);
	  }
	}
	if(DEBUG) assert(maxerr < MDEBUG_ERR);

	int restoredN = setmap(n,Hcuts2,Hdel2,Y2,map2[MD],nmap2[MD]);/* compute Y2[] and nmap2[MD][0..N+1] and map2[MD][0..n+1] */
	score_init(N2,Y2,MD,MX,X);/* precompute likelihood scoring constants/terms */
	if(MDEBUG_M < 0){
	  double qLP = qprobeval(n,Hcuts2,N2,Y2,MD,MX,X,lc,rc,map2,mapK2,limit2,nmap2,0,TBmapWT,testLPA,mapWT2,0,0.0,0.0,0,0,pcontig);
    
	  printf("Restored qLP=%0.10f,N2=%d(%d)\n",qLP,restoredN,N2);
	  fflush(stdout);
	}
	if(DEBUG) assert(restoredN == N2);
	delete [] testLPA;
      } // MDEBUG && (MDEBUG_DEL || ...)

      if(MDEBUG && !HINDELITER(iter) && (MDEBUG_ADD || (MDEBUG_T >= 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0)) && 
	 !(MDEBUG_T < 0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0) && !(MDEBUG_T < 0 && MDEBUG_S >= 0 && MDEBUG_F >= 0) && !HINDELITER(iter)){
	double *testLPA = new double[MD];

	/* check LPadd2[0..addloc-1] values vs qprobeval */
	double maxerr = -1000.0;/* worst error for any single site addition for LP sum over all maps */
	int maxerrS = -1; /* Existing site in Y[] left of added site */
	int maxerrT = -1; /* Added site in addloc[] corresponding to worst error */
      
	double ErrMax = -1000.0;/* worst error for any single site addition for any single map */
	double trueLP = -1000.0;
	int maxM = -1;
	int maxS = -1;
	int maxT = -1;
	int maxTT = -1;

	int T = 0, S = 0, TT = 0;
	int L = 0;
	for(int i = 1; i <= imax; i++){
	  if((HapSite[i-1] & 2))
	    L = i-1;

	  if(!Hdel2[i]){
	    S++;
	    TT = 0;
	    continue;
	  }

	  if(i < imin)
	    continue;
	  if(skip[i] > 0)
	    continue;

	  if(DELTA_STOP >= 2 && iter >= HMIN_ITER && (SKIPMAP_ADD>=2 || !HapSite[i])){
	    int IN = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
	    if(DEBUG) assert(0 <= IN && IN <= maxIN);
	    if(DELTA_RANGE[IN] <= 0)
	      continue;
	  }

	  if(DUP_FIX && !HapSite[i]){ /* also check that no existing site is at the same location as Hcuts[i] */
	    int t = i;
	    while(--t > 0)
	      if(HapSite[t] || Hcuts[t] + 1e-3 < Hcuts[i])
		break;
	    if(Hcuts[t] + 1e-6 >= Hcuts[i] && HapSite[t])
	      continue;
	    for(t = i; ++t <= n;)
	      if(HapSite[t] || Hcuts[t] > Hcuts[i] + 1e-3)
		break;
	    if(Hcuts[t] <= Hcuts[i] + 1e-6 && HapSite[t])
	      continue;
	  }

	  if((HapSite[L]&2)){
	    double hapdelta = 0.0, delta = 0.0;
	    for(int t = L; t < i; t++){
	      hapdelta += HapDelta[t];
	      delta += Delta[t];
	    }
	    if(Hcuts[i] - Hcuts[L] + delta - hapdelta < (HapSite[i] ? minKB : minKBadd))
	      continue;
	  }

	  int R = i+1;
	  while(R < n && !(HapSite[R] & 2))
	    R++;
	  if(DEBUG) assert(R <= n || i >= n);
	  if((HapSite[R] & 2)){
	    double hapdelta = 0.0, delta = 0.0;	
	    for(int t = i; t < R; t++){
	      hapdelta += HapDelta[t];
	      delta += Delta[t];
	    }
	    if(Hcuts[R] - Hcuts[i] + delta - hapdelta < (HapSite[i] ? minKB : minKBadd))
	      continue;
	  }

	  if(DEBUG && !(T < addcnt2 && addid2[T] == i)){
	    printf("T=%d,addcnt2=%d,i=%d:Hcuts2[i]=%0.3f,addloc2[T]=%0.3f,addid2[T]=%d\n",
		   T,addcnt2,i,Hcuts2[i],addloc2[T],addid2[T]);
	    fflush(stdout);
	    assert(T < addcnt2 && addid2[T] == i);
	  }
	  if(DEBUG) assert(imin <= i && i <= imax);

	  Hdel2[i] = 0;
	
	  if(MDEBUG_S < 0 && (MDEBUG_T <= 0 || T==MDEBUG_T) && T < addcnt2){
	    int newN2 = setmap(n,Hcuts2,Hdel2,Y2,map2[MD],nmap2[MD]);/* compute Y2[] and nmap2[MD][] and map2[MD][] */
	    if(DEBUG) assert(newN2 == N2+1);
	    score_init(newN2,Y2,MD,MX,X);/* precompute likelihood scoring constants/terms */
	  
	    printf("i=%d,S=%d,T=%d:Added Hcuts2[i]=%0.3f,addloc2[T]=%0.3f,Y2[S]=%0.3f..%0.3f:", i, S, T, Hcuts2[i],addloc2[T], Y2[S],Y2[S+2]);
	    fflush(stdout);

	    double qLP = qprobeval(n,Hcuts2,newN2,Y2,MD,MX,X,lc,rc,map2,mapK2,limit2,nmap2,0,TBmapWT,testLPA,mapWT2,0/*bestLPA2*/,0.0/*Hcuts2[imin]*/,0.0/*Hcuts2[imax]*/,0,0,pcontig);
	    if(qLP > LP2 - LP_DROP || LPadd2[T] > LP2)
	      printf("qLP=%0.10f,LPadd2[T]=%0.10f (error=%0.10f)\n",qLP,LPadd2[T],LPadd2[T]-qLP);
	    else
	      printf("qLP=%0.10f,LPadd2[T]=%0.10f (error=%0.10f:ignored) LP2=%0.6f\n",qLP,LPadd2[T],LPadd2[T]-qLP, LP2);
	    if((qLP > LP2-LP_DROP || LPadd2[T] > LP2) && fabs(LPadd2[T]-qLP) > maxerr){
	      maxerr = fabs(LPadd2[T]-qLP);
	      maxerrS = S;
	      maxerrT = T;
	    }

	    double sumLPaTm = 0.0, sumtest = 0.0;
	    for(int m = 0; m < MD; m++){
	      int t = (T < TminM2[m]) ? TminM2[m] : (T > TmaxM2[m]) ? TmaxM2[m] : T;
	      double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
	      sumLPaTm += newLPa2[m][t] * TBwtm;
	      sumtest += testLPA[m] * TBwtm;
	      if(VERB && (VERB>=2 || (T==maxerrT && S==maxerrS && maxerr > MDEBUG_ERR) || (T==MDEBUG_T && m==MDEBUG_M) 
			  /* || ((testLPA[m] > newLPA[m]-LP_DROP*0.1 || newLPa[m][T] > newLPA[m]) && fabs(newLPa[m][T]-testLPA[m]) *TBwtm > MDEBUG_ERR)*/ )){
		printf("S=%d,T=%d,m=%d(id=%lld):wt=%0.10f,mLPA2[m]=%0.10f,bestLPA2[m]=%0.10f,newLPa2[m][T]=%0.10f,testLPA[m]=%0.10f(err=%0.10f, cumwt=%0.1f0)",
		       S,T,m,gmap[pcontig->contig[m].mapid]->id,TBwtm,newLPA2[m],bestLPA2[m],newLPa2[m][t], testLPA[m],newLPa2[m][t] - testLPA[m], sumLPaTm - sumtest);
		if(testLPA[m] <= newLPA2[m] - LP_DROP && newLPa2[m][t] <= newLPA2[m])
		  printf(":ignored");
		if(MDEBUG && newLPaPr2[m][t])
		  printf(":reduced precision");
		printf("\n");
		fflush(stdout);
	      }
	      if(DEBUG) assert(newLPa2[m][t] > -1e98); 
	      if((testLPA[m] > newLPA2[m] - LP_DROP*0.1 || newLPa2[m][t] > newLPA2[m] || maxerr > MDEBUG_ERR) && fabs(newLPa2[m][t]-testLPA[m]) * TBwtm > ErrMax && (!MDEBUG_NEGERR || newLPa2[m][t] < testLPA[m])){
		ErrMax = fabs(newLPa2[m][t]-testLPA[m]) * TBwtm;
		trueLP = testLPA[m];
		maxS = S;
		maxT = T;
		maxTT = TT;
		maxM = m;
	      }
	    }
	    if(DEBUG && ErrMax >= 0.0) assert(maxT >= 0 && maxM >= 0);
	    
	    if(ErrMax >= 0.0 && ((MDEBUG_T > 0 && MDEBUG_TS >= 0 && newN2 == MDEBUG_N+1) /* || ErrMax >= MDEBUG_ERR*/)){
	      int maxt = (maxT < TminM2[maxM]) ? TminM2[maxM] : (maxT > TmaxM2[maxM]) ? TmaxM2[maxM] : maxT;
	      if(MDEBUG && newLPaPr2[maxM][maxt])
		printf("T=%d:Site/map with worst site addition error so far is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N2=%d:mLP2[m]=%0.10f,newLPa2[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e:reduced precision(excluding when LP drops by %0.3f or more)\n",
		       T,maxS,Y2[maxS],Y2[maxS+2],maxT,addloc2[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N2,newLPA2[maxM],newLPa2[maxM][maxt],trueLP,ErrMax, LP_DROP*0.1);
	      else
		printf("T=%d:Site/map with worst site addition error so far is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N2=%d:mLP2[m]=%0.10f,newLPa2[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e(excluding when LP drops by %0.3f or more)\n",
		       T,maxS,Y2[maxS],Y2[maxS+2],maxT,addloc2[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N2,newLPA2[maxM],newLPa2[maxM][maxT],trueLP,ErrMax, LP_DROP*0.1);
	      fflush(stdout);
	      
#if 0
	      printf("Calling mprobeval(%d..%d)=%0.3f..%0.3f (after adding site addloc2[%d]=%0.3f):",imin,imax,Hcuts2[imin],Hcuts2[imax],maxT,addloc2[maxT]);
	      fflush(stdout);

	      double mLP2 = mprobeval(n,Hcuts2,newN2,Y2,MD,MX,X,lc,rc,map2,mapK2,nmap2[MD],TBmapWT,testLPA,0/*bestLPA2*/,-1.0/*Hcuts2[imin]*/,-1.0/*Hcuts2[imax]*/,0,addloc2,0,0,LPdel2,0,0,0,newLPd2,newLPd20,newLPdPr2,DminM2,DmaxM2,newLPa2,newLPaPr2,TminM2,TmaxM2,newLPdelta2,Dcum2,AminM2,AmaxM2,pcontig,0);
	      printf("mLP2=%0.10f\n",mLP2);
	      fflush(stdout);
#endif

	      if(MDEBUG_T > 0 && MDEBUG_TS >= 0 && newN2 == MDEBUG_N+1)
		exit(1);
	      assert(ErrMax < MDEBUG_ERR);
	    }
	  }
	  T++;
	  TT++;
	  Hdel2[i] = 1;
	}

	if(MDEBUG_T < 0 && MDEBUG_TS < 0 && MDEBUG_TT < 0){
	  if(maxerr >= 0.0)
	    printf("Worst site addition error =%0.10e at T=%d(%0.3f) interval S=%d(%0.3f..%0.3f)(excluding when LP drops by %0.3f or more)\n",
		   maxerr,maxerrT,addloc2[maxerrT],maxerrS,Y2[maxerrS],Y2[maxerrS+1],LP_DROP);
	  if(ErrMax >= 0.0){
	    int maxt = (maxT < TminM2[maxM]) ? TminM2[maxM] : (maxT > TmaxM2[maxM]) ? TmaxM2[maxM] : maxT;
	    if(MDEBUG && newLPaPr2[maxM][maxt])
	      printf("Site/map with worst site addition error is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N2=%d:mLP[m]=%0.10f,newLPa2[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e:reduced precision(excluding when LP drops by %0.3f or more)\n",
		     maxS,Y2[maxS],Y2[maxS+1],maxT,addloc2[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N2,newLPA2[maxM],newLPa2[maxM][maxt],trueLP,ErrMax, LP_DROP*0.1);
	    else
	      printf("Site/map with worst site addition error is TS=%d(%0.3f..%0.3f),T=%d(%0.3f),TT=%d,m=%d(id=%lld),N2=%d:mLP[m]=%0.10f,newLPa2[m][T]=%0.10f,trueLP=%0.10f,|err|=%0.10e(excluding when LP drops by %0.3f or more)\n",
		     maxS,Y2[maxS],Y2[maxS+1],maxT,addloc2[maxT],maxTT,maxM,gmap[pcontig->contig[maxM].mapid]->id,N2,newLPA2[maxM],newLPa2[maxM][maxt],trueLP,ErrMax, LP_DROP*0.1);
	    fflush(stdout);
	    if(DEBUG) assert(ErrMax < MDEBUG_ERR * 100.0);
	  }
	  fflush(stdout);
	}

	if(DEBUG) assert(maxerr < MDEBUG_ERR);

	int restoredN = setmap(n,Hcuts2,Hdel2,Y2,map2[MD],nmap2[MD]);
	score_init(N2,Y2,MD,MX,X);
	if(MDEBUG_M < 0){
	  double qLP = qprobeval(n,Hcuts2,N2,Y2,MD,MX,X,lc,rc,map2,mapK2,limit2,nmap2,0,TBmapWT,testLPA,mapWT2,0,0.0,0.0,0,0,pcontig);
    
	  printf("Restored qLP=%0.10f,N2=%d(%d)\n",qLP,restoredN,N2);
	  fflush(stdout);
	}
	if(DEBUG) assert(restoredN == N2);
	delete [] testLPA;
      } /* MDEBUG */

      if(MDEBUG && HINDELITER(iter) && (MDEBUG_DELTA || (MDEBUG_TS >= 0 &&  MDEBUG_TT >= 0)) && MDEBUG_T < 0 && MDEBUG_S < 0 && HINDELITER(iter)){/* check newLPdelta[][][] */
	double *testLPA = new double[MD];
	double *fixY = new double[N2+2];
	double *fixYdel = new double[N2+2];
	double *fixHcuts = new double[n+2];
	double *fixHcutsDel = new double[n+2];

	fixY[0] = fixYdel[0] = 0.0;
	for(int I=1; I <= N2+1; I++){
	  fixY[I] = Y2[I];
	  fixYdel[I] = Y2[I] - Y2[I-1];
	}

	fixHcuts[0] = fixHcutsDel[0] = 0.0;
	for(int i = 1; i <= n+1; i++){
	  fixHcuts[i] = Hcuts2[i];
	  fixHcutsDel[i] = Hcuts2[i] - Hcuts2[i-1];
	}

	double maxerr = -1000.0;/* worst error for any single interval change for LP sum over all maps */
	int maxerrT = -1;/* interval left site, corresponding to worst error */
	int maxerrD = -1;/* change value index, corresponding to worse error */

	double ErrMax = -1000.0;/* worst error for any single interval change for any single map */
	double trueLP = -1000.0;
	int maxM = -1;/* map index */
	int maxT = -1;/* interval left site */
	int maxD = -1;/* change value index */

	for(register int Q=1; Q < N2; Q++){
	  //	  if(Q != 2941)  continue;

	  if(D2[Q] <= 0)
	    continue;

	  double origval = fixYdel[Q+1];
	  if(DEBUG) assert(origval > 0.0);

	  int q0 = nmap2[MD][Q];
	  int q1 = nmap2[MD][Q+1];
	  /*	fixHcuts[q0..q1] corresponds to fixY[Q..Q+1] */
	  if(DEBUG && !(fabs(fixHcuts[q0] - fixY[Q]) < 1e-8 && fabs(fixHcuts[q1] - fixY[Q+1]) < 1e-8)){
	    printf("iter=%d:Q=%d,N2=%d,D2[Q]=%d, origval=%0.8f,q0=%d,q1=%d,fixY[Q]=%0.8f,fixY[Q+1]=%0.8f,fixHcuts[q0]=%0.8f,fixHcuts[q1]=%0.8f\n",
		   iter,Q,N2,D2[Q],origval,q0,q1,fixY[Q],fixY[Q+1],fixHcuts[q0],fixHcuts[q1]);
	    fflush(stdout);
	    assert(fabs(fixHcuts[q0] - fixY[Q]) < 1e-8);
	    assert(fabs(fixHcuts[q1] - fixY[Q+1]) < 1e-8);
	  }

	  for(register int t = 0; t < D2[Q]; t++){
	    if((MDEBUG_TS < 0 || Q==MDEBUG_TS) && (MDEBUG_TT < 0 || t==MDEBUG_TT) && MDEBUG_T < 0 && MDEBUG_S < 0){
	      register double testLP = LPdelta2[Q][t];
	      register double val = delta2[Q][t] + origval;
	      double ratio = val/origval;
	      if(DEBUG) assert(fabs(fixYdel[Q+1] - origval) < 1e-8);
	      fixYdel[Q+1] = val;
	      for(int q = q0+1; q <= q1; q++){
		if(DEBUG) assert(fabs(fixHcutsDel[q] - (Hcuts2[q] - Hcuts2[q-1])) < 1e-8);
		fixHcutsDel[q] *= ratio;
	      }
	      double cum = 0.0;
	      fixY[0] = cum;
	      for(int I = 1; I <= N2+1; I++){
		cum += fixYdel[I];
		fixY[I] = cum;
	      }
	      fixHcuts[0] = cum = 0.0;
	      for(int q = 1; q <= n+1; q++){
		cum += fixHcutsDel[q];
		fixHcuts[q] = cum;
	      }
	      if(DEBUG && !(fabs(fixHcuts[q0] - fixY[Q]) < 1e-8 && fabs(fixHcuts[q1] - fixY[Q+1]) < 1e-8)){
		printf("iter=%d:Q=%d,N2=%d,t=%d,D2[Q]=%d, delta2[Q][t]=%0.8f,origval=%0.8f,ratio=%0.8f,q0=%d,q1=%d,Y2[Q]=%0.8f->%0.8f,Y2[Q+1]=%0.8f->%0.8f,Hcuts2[q0]=%0.8f->%0.8f,Hcuts2[q1]=%0.8f->%0.8f\n",
		       iter,Q,N2,t,D2[Q], delta2[Q][t], origval, ratio, q0,q1,Y2[Q],fixY[Q],Y2[Q+1],fixY[Q+1],Hcuts2[q0],fixHcuts[q0],Hcuts2[q1],fixHcuts[q1]);
		for(int q = q0+1; q <= q1; q++)
		  printf("\t q=%d:fixHcutsDel[q]= %0.8f -> %0.8f, Hcuts2[q]= %0.8f -> %0.8f\n",q, Hcuts2[q] - Hcuts2[q-1], fixHcutsDel[q], Hcuts2[q], fixHcuts[q]);
		fflush(stdout);
		assert(fabs(fixHcuts[q0] - fixY[Q]) < 1e-8);
		assert(fabs(fixHcuts[q1] - fixY[Q+1]) < 1e-8);
	      }

	      score_init(N2,fixY,MD,MX,X);

#if 0
	      if(MDEBUG && t==120) {
		rverb = 2;
		printf("Validating Q=%d,t=%d,Y2[Q..Q+1]=%0.8f -> %0.8f (delta2[Q][t]= %0.8f)\n", Q,t, Y2[Q+1]-Y2[Q],Y2[Q+1]-Y2[Q]+delta2[Q][t],delta2[Q][t]);
		fflush(stdout);
	      }
#endif
	      double qLP2 = qprobeval(n,fixHcuts,N2,fixY,MD,MX,X,lc,rc,map2,mapK2,limit2,nmap2,0,TBmapWT,testLPA,mapWT2,bestLPA2,fixY[Q],fixY[Q+1],0,0,pcontig);
	      //	      rverb = 0;

	      if(VERB){
		if(qLP2 > LP2 - LP_DROP || testLP > LP2)
		  printf("    Y[%d..%d]=%0.6f->%0.6f(t=%d/%d): testLP=%0.10f (delta=%0.10f), qLP2=%0.10f (err = %0.10f)\n", 
			 Q,Q+1, origval, val, t, D2[Q], testLP, testLP - LP2, qLP2, testLP - qLP2);
		else
		  printf("    Y[%d..%d]=%0.6f->%0.6f(t=%d/%d): testLP=%0.10f (delta=%0.10f), qLP2=%0.10f (err = %0.10f:ignored)\n", 
			 Q,Q+1,origval, val, t, D2[Q], testLP, testLP - LP2, qLP2, testLP - qLP2);
		fflush(stdout);
	      }
	      if((qLP2 > LP2 - LP_DROP || testLP > LP2) && fabs(testLP-qLP2) > maxerr && (!MDEBUG_NEGERR || testLP < qLP2)){
		maxerr = fabs(testLP - qLP2);
		maxerrT = Q;
		maxerrD = t;
	      }

	      double sumLPmQt = 0.0, sumtest = 0.0;
	      for(int m = 0; m < MD; m++){
		double newLPmQt = (Q >= AminM2[m] && Q <= AmaxM2[m]) ? newLPdelta2[m][Dcum2[Q]-Dcum2[AminM2[m]]+t] : newLPA2[m];
		double TBwtm = TBmapWT ? TBmapWT[m] : 1.0;
		sumLPmQt += newLPmQt * TBwtm;
		sumtest += testLPA[m] * TBwtm;
		if(VERB && (VERB>=2 || (MDEBUG && t==120) || (Q==MDEBUG_TS && t==MDEBUG_TT && m==MDEBUG_M))){
		  printf("Q=%d,t=%d,m=%d(id=%lld):mLP2[m]=%0.10f,newLPdelta2[m][S,d]=%0.10f,testLPA[m]=%0.10f(err=%0.10f)",
			 Q,t,m,gmap[pcontig->contig[m].mapid]->id, newLPA2[m], newLPmQt, testLPA[m], newLPmQt - testLPA[m]);
		  if(testLPA[m] <= newLPA2[m] - LP_DROP*0.1 && newLPdelta2[m][Dcum[Q]-Dcum[AminM2[m]]+t] <= newLPA2[m])
		    printf(":ignored");
		  printf("\n");
		  fflush(stdout);
		}
		if(DEBUG) assert(newLPmQt > LARGE_NEGATIVE * 0.9);
		if((testLPA[m] > newLPA2[m] - LP_DROP*0.1 || newLPmQt > newLPA2[m]) && fabs(newLPmQt-testLPA[m]) * TBwtm > ErrMax && (!MDEBUG_NEGERR || newLPmQt < testLPA[m])){
		  ErrMax = fabs(newLPmQt - testLPA[m]) * TBwtm;
		  trueLP = testLPA[m];
		  maxT = Q;
		  maxD = t;
		  maxM = m;
		}
	      }
	      if(DEBUG) assert(fabs(sumLPmQt - N2*SITE_PEN - testLP) < 1e-8);
	      if(DEBUG) assert(fabs(sumtest - N2*SITE_PEN - qLP2) < 1e-8);

	      if(ErrMax >= 0.0 && MDEBUG_TS >= 0 && MDEBUG_TT >= 0 && N2 == MDEBUG_N && maxT >= 0){
		double newLPmQt = (maxT >= AminM2[maxM] && maxT <= AmaxM2[maxM]) ? newLPdelta2[maxM][Dcum2[maxT]-Dcum2[AminM2[maxM]]+maxD] : newLPA2[maxM];
		printf("Interval/Delta/map with worst error so far is Q=%d(%0.3f),t=%d(%0.3f),m=%d(id=%lld):mLP2[m]=%0.10f,newLPdelta2[m][Q,t]=%0.10f,trueLP=%0.10f,|err|=%0.10e\n",
		       maxT,fixYdel[maxT],maxD,delta2[maxT][maxD],maxM,gmap[pcontig->contig[maxM].mapid]->id,newLPA2[maxM],newLPmQt,trueLP,ErrMax);
		fflush(stdout);
		if(DEBUG) assert(maxT >= 0 && maxM >= 0 && maxD >= 0);

#if 0
		double mLP2 = mprobeval(n,fixHcuts,N2,fixY,MD,MX,X,lc,rc,map2,mapK2,nmap2[MD],TBmapWT,testLPA,0/*bestLPA2*/,-1.0/*fixY[Q]*/,-1.0/*fixY[Q+1]*/,0,0,0,delta2,LPdel2,0,0,0,/* newLPd2*/0, /*newLPd20*/ 0, /*newLPdPr2*/ 0, DminM2,DmaxM2,newLPa2,newLPaPr2,TminM2,TmaxM2,newLPdelta2,Dcum2,AminM2,AmaxM2,pcontig,0);
		printf("mLP2=%0.10f\n",mLP2);
		fflush(stdout);
#endif

		if(MDEBUG_TS >= 0 && MDEBUG_TT >= 0 && N2 == MDEBUG_N)
		  exit(1);
		assert(ErrMax < MDEBUG_ERR);
	      }

	      /* restore original value of fixYdel[Q+1] and fixHcutsDel[q0+1..q1] */
	      fixYdel[Q+1] = origval;
	      for(int q = q0+1; q <= q1; q++)
		fixHcutsDel[q] = Hcuts2[q] - Hcuts2[q-1];
	    }
	  } /* t = 0 .. D2[Q] - 1 */
	} /* Q = 1 .. N2-1 */
	if(MDEBUG_T < 0){
	  if(maxerr >= 0.0){
	    printf("Max interval change error =%0.10e at Q=%d,t=%d(%0.3f) (excluding when LP drops by %0.3f or more)\n",maxerr,maxerrT,maxerrD,delta2[maxerrT][maxerrD],LP_DROP);
	    fflush(stdout);
	    if(DEBUG) assert(maxerrT >= 0 && maxerrD >= 0);
	  }
	  if(ErrMax >= 0.0){
	    double newLPmQt = (maxT >= AminM2[maxM] && maxT <= AmaxM2[maxM]) ? newLPdelta2[maxM][Dcum2[maxT]-Dcum2[AminM2[maxM]]+maxD] : newLPA2[maxM];
	    printf("Interval/change/map with worst interval change error is Q=%d(%0.3f),t=%d(%0.3f),m=%d(id=%lld),N2=%d:mLP2[m]=%0.10f,newLPdelta2[m][Q,t]=%0.10f,trueLP=%0.10f,|err|=%0.10e(excluding when LP drops by %0.3f or more)\n",
		   maxT,fixYdel[maxT+1],maxD,delta2[maxT][maxD],maxM,gmap[pcontig->contig[maxM].mapid]->id,N2,newLPA2[maxM],newLPmQt,trueLP,ErrMax,LP_DROP*0.1);
	    fflush(stdout);
	    if(DEBUG) assert(maxT >= 0 && maxD >= 0 && maxM >= 0);
	    if(DEBUG) assert(ErrMax < MDEBUG_ERR);
	  }
	}

	delete [] testLPA;
	delete [] fixY;
	delete [] fixYdel;
	delete [] fixHcuts;
	delete [] fixHcutsDel;
      } /* if(MDEBUG ...)  */

      //      MDEBUG = 1;

      /* restore HapDelta[],Delta[] so all values are 0 if HapSite[] is 0 */
      memcpy(HapDelta,startHapDelta,(n+2)*sizeof(double));
      memcpy(Delta,startDelta,(n+2)*sizeof(double));
      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
      if(DEBUG>=1+RELEASE /* HERE >= 2*/){/* check that all Delta[i] and HapDelta[i] values are zero if HapSite[i]==0 */
	for(int i = 1; i <= n; i++)
	  if(!HapSite[i] && (Delta[i] || HapDelta[i])){
	    printf("i=%d,n=%d:HapSite[i]=%d,Delta[i]=%0.3f,HapDelta[i]=%0.3f\n",i,n,HapSite[i],Delta[i],HapDelta[i]);
	    fflush(stdout);
	    assert(!(Delta[i] || HapDelta[i]));
	  }
      }

      if(VERB){
	/* compute DelCum[i+1] = Sum(Delta[0..i]) */
	double DeltaCum = 0.0;
	for(int i = 0; i <= n; i++){
	  DeltaCum += Delta[i];
	  DelCum[i+1] = DeltaCum;
	}
      }

      if(IndelCnt > 0 || iter >= HMIN_ITER){/* compute HapDeltaMerged[1..n] */
	for(int i = 0; i <= n; i++){
	  if(i <= 0 || HapSite[i] == 3){
	    int RR = i+1;
	    while(RR <= n && HapSite[RR] != 3)
	      RR++;

	    double sum = 0.0, abssum = 0.0;
	    for(int t = i; t < RR; t++){
	      sum += HapDelta[t];
	      abssum += fabs(HapDelta[t]);
	    }
	    if(abssum < MIN_INDEL_SIZE)
	      abssum = sum = 0.0;// WAS7 abssum = 0.0;
	    else if(fabs(sum) < MIN_INDEL_SIZE)
	      sum = copysign(MIN_INDEL_SIZE,sum);

	    for(int t = i; t < RR; t++)
	      HapDeltaMerged[t] = sum;
	  
	    i = RR-1;
	  }
	}
      }

      if(HSNP_FAST && !HINDELITER(iter)){/* compute LP[h=0..3][i=imin..imax] as the difference from LPstart when HapSite[i] is changed to h */
	int LPTthreads = numthreads;/* may need to throttle back threads, since LPT memory (delmem) is proportional to number of threads */
	long long threadsiz = 0;
	if(HEAP_MINIMIZE){
	  delete [] delmem;
	  threadsiz = ((8ul * (n + 1ul) * sizeof(double) + (PAGE-1)) & ~(PAGE-1))/sizeof(double);/* add some padding after each thread's memory to round to nearest page size */
	  delmemsiz = LPTthreads * threadsiz * sizeof(double);
	  if(DEBUG) assert(delmemsiz >= 0);

	  long long maxmem = MaxMem * 1000000000;
	  if(delmemsiz > maxmem / 4){/* may need to reduce LPTthreads */
	    getmem(VmSize,VmRSS, VmSwap);
	    
	    int maxthreads = max(maxmem/4 , maxmem - VmRSS) /* WAS (maxmem - VmRSS) */ / (threadsiz * sizeof(double));
	    maxthreads = min(max(1,maxthreads), LPTthreads);
	    if(VERB){
	      printf("Reducing number of threads for LPT from %d to %d: MaxMem=%0.1f,threadsiz=%0.4f,VmRSS=%0.4f, VmSwap= %0.4f, VmSize=%0.4f GB\n",
		     LPTthreads, maxthreads, MaxMem, threadsiz * sizeof(double) * 1e-9, VmRSS * 1e-9, VmSwap * 1e-9, VmSize * 1e-9);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(maxthreads >= 1);
	    LPTthreads = maxthreads;
	    delmemsiz = LPTthreads * threadsiz * sizeof(double);
	  }
	  if(TIME_VERBOSE){
	    printf("threadsiz= %0.4f G, LPTthreads=%d : estimated memory for LPT= %0.4f G\n", threadsiz * sizeof(double) * 1e-9, LPTthreads, delmemsiz * 1e-9);
	    fflush(stdout);
	  }

	  char *ptr = (char *)mmap(NULL, delmemsiz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	  if(ptr == MAP_FAILED){
	    int eno = errno;
	    char *err = strerror(eno);
	    printf("mmap of %lld bytes for delmem failed:errno=%d:%s\n",delmemsiz,eno,err);
	    dumpmemmap();
	    fflush(stdout);exit(1);
	  }

	  delmem = (double *)ptr;

	  for(int tid = 0; tid < LPTthreads; tid++){
	    LPT[tid] = &delmemp[tid*8];
	    LP1mT[tid] = &delmemp[tid*8 + 4];
	    LP2mT[tid] = &delmemp[tid*8 + 6];
	    for(int h = 0; h <= 3; h++)
	      LPT[tid][h] = &delmem[tid * threadsiz + h * (n + 1ul)];
	    for(int h = 0; h <= 1; h++){
	      LP1mT[tid][h] = &delmem[tid * threadsiz + (4 + h) * (n + 1ul)];
	      LP2mT[tid][h] = &delmem[tid * threadsiz + (6 + h) * (n + 1ul)];
	    }
	  }  
	  LP = LPT[0];
	}

	/* NOTE : LP[h][i] == LPT[0][h][i] */

	start = mtime(); wstart = wtime();

	int nthreads = 1;
	int block = 1;

#ifdef _OPENMP      
	if(!(SNP_TRACE && iter==ITER_ID && SITE_ID >= 0))
	  nthreads = min((MD+block-1)/block,LPTthreads);/* NOTE : comment this out to disable multi-threading of below loop */

	while(block < 16 && MD > nthreads * block * 8)
	  block *= 2;
#endif

	if(TIME_VERBOSE){
	  getmem(VmSize,VmRSS, VmSwap, &VmHWM, &VmPeak);
	  printf("iter=%d:After Re-Allocation of LPT*[tid][] for n=%d,block=%d,MD=%d: VmRSS=%0.3f(HWM=%0.3f),VmSwap=%0.3f,VmSize= %0.3f(Peak=%0.3f): cum wall= %0.6f\n", 
		 iter,n, block,MD, VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9,VmSize*1e-9,VmPeak*1e-9,wtime());
	  if(VERB/* HERE HERE >= 2*/)
	    printf("nthreads=%d,block=%d,imin=%d,imax=%d,n=%d:LPT=%p, numthreads=%d\n",nthreads,block,imin,imax,n,LPT, numthreads);
	  fflush(stdout);
	}

	if(VERB>=3){
	  printf("startLPA1[1]=%0.8f,startLPA2[1]=%0.8f\n",startLPA1[1],startLPA2[1]);
	  printf("startLPA1[491]=%0.8f,startLPA2[491]=%0.8f\n",startLPA1[491],startLPA2[491]);
	  fflush(stdout);
	}

	long long irangeSum = 0, Rsum = 0;

	int LoopCnt = 0;
        #pragma omp parallel num_threads(nthreads) if(nthreads > 1)
	{
	  int myLoopCnt = 0;
	  long long myirangeSum = 0;
	  double **LP1m, **LP2m, **LPm;

	  int tid = -1;/* not the usual tid : based on static scheduler iteration modulo nthreads */

          #pragma omp for schedule(static,block)
	  for(int m = 0; m < MD; m++){
	    if(OMP_DEBUG) myLoopCnt++;

	    if(tid < 0){
	      tid = (m/block) % nthreads;
	      if(DEBUG) assert(tid >= 0);

	      LP1m = LP1mT[tid];
	      LP2m = LP2mT[tid];
	      LPm = LPT[tid];
	      for(int h = 0; h <= 3; h++)
	      	memset(&LPm[h][imin], 0, (imax-imin+1)*sizeof(double));
	    } else if(DEBUG>=2){/* verify static scheduler is working as expected */
	      int ntid = (m/block) % nthreads;
	      if(DEBUG && !(ntid == tid)){
		#pragma omp critical
		{
		  printf("m=%d/%d:tid=%d,ntid=%d,nthreads=%d,block=%d\n",m,MD,tid,ntid,nthreads,block);
		  fflush(stdout);
		  assert(ntid == tid);
		}
	      }
	    }

	    double TBmapWTm = TBmapWT[m];
	    if(TBmapWTm <= 0.0)
	      continue;

	    //	    int iL1 = min(((addcnt1 <= 0 || TmaxM[m] <= TminM[m]+1) ? imax : addid1[TminM[m]]), (DminM[m] > DmaxM[m]) ? imax : delid1[DminM[m]]);// NEW3
	    //	    int iR1 = max(((addcnt1 <= 0 || TmaxM[m] <= TminM[m]+1) ? imin : addid1[TmaxM[m]]), (DminM[m] > DmaxM[m]) ? imin : delid1[DmaxM[m]]);// NEW3
	    //	    int iL2 = min(((addcnt2 <= 0 || TmaxM2[m] <= TminM2[m]+1) ? imax : addid2[TminM2[m]]), (DminM2[m] > DmaxM2[m]) ? imax : delid2[DminM2[m]]);// NEW3
	    //	    int iR2 = max(((addcnt2 <= 0 || TmaxM2[m] <= TminM2[m]+1) ? imin : addid2[TmaxM2[m]]), (DminM2[m] > DmaxM2[m]) ? imin : delid2[DmaxM2[m]]);// NEW3
	    if(DEBUG>=2 && addcnt1 > 0 && !(TmaxM[m] <= TminM[m] && TminM[m]==0)) assert(TminM[m] <= TmaxM[m] && TmaxM[m] < addcnt1);// NEW10
	    if(DEBUG>=2 && addcnt2 > 0 && !(TmaxM2[m] <= TminM2[m] && TminM2[m]==0)) assert(TminM2[m] <= TmaxM2[m] && TmaxM2[m] < addcnt2);// NEW10
	    if(DEBUG>=2 && 0 < DminM[m] && !(DminM[m] <= DmaxM[m] && DmaxM[m] <= N1)){
	      printf("m=%d:DminM[m]=%d,DmaxM[m]=%d,N1=%d,n=%d\n",m,DminM[m],DmaxM[m],N1,n);
	      fflush(stdout);
	      assert(DminM[m] <= DmaxM[m] && DmaxM[m] <= N1);// NEW10
	    }
	    if(DEBUG>=2 && 0 < DminM2[m] && !(DminM2[m] <= DmaxM2[m] && DmaxM2[m] <= N2)){
	      printf("m=%d:DminM2[m]=%d,DmaxM2[m]=%d,N2=%d,n=%d\n",m,DminM2[m],DmaxM2[m],N2,n);
	      fflush(stdout);
	      assert(DminM2[m] <= DmaxM2[m] && DmaxM2[m] <= N2);// NEW10
	    }
	    int iL1 = min(((addcnt1 <= 0 || (TmaxM[m] <= TminM[m] && TminM[m]==0)) ? imax : addid1[TminM[m]]), (DminM[m] <= 0/* NEW10 */) ? imax : delid1[DminM[m]]);// NEW6
	    int iR1 = max(((addcnt1 <= 0 || (TmaxM[m] <= TminM[m] && TminM[m]==0)) ? imin : addid1[TmaxM[m]]), (DminM[m] <= 0/* NEW10 */) ? imin : delid1[DmaxM[m]]);// NEW6
	    int iL2 = min(((addcnt2 <= 0 || (TmaxM2[m] <= TminM2[m] && TminM2[m]==0)) ? imax : addid2[TminM2[m]]), (DminM2[m] <= 0/* NEW10 */) ? imax : delid2[DminM2[m]]);// NEW6
	    int iR2 = max(((addcnt2 <= 0 || (TmaxM2[m] <= TminM2[m] && TminM2[m]==0)) ? imin : addid2[TmaxM2[m]]), (DminM2[m] <= 0/* NEW10 */) ? imin : delid2[DmaxM2[m]]);// NEW6

	    iL1 = max(imin,iL1);
	    iR1 = min(imax,iR1);
	    iL2 = max(imin,iL2);
	    iR2 = min(imax,iR2);
	    
	    if(iL1 > iR1 && iL2 > iR2)// NEW3
	      continue;

	    if(DEBUG>=2) assert(!(TminM[m]+1 >= TmaxM[m] && DminM[m] > DmaxM[m] && TminM2[m]+1 >= TmaxM2[m] && DminM2[m] > DmaxM2[m]));// NEW3

	    /* compute LP1m[h1=0..1][i=IL1..IR1] from newLPa[m][] and newLPd[m][] and startLPA1[m] */
	    double startLP1m = startLPA1[m];
	    for(int i = iL1; i <= iR1; i++){/* set defaults so cases not checked by mprobeval() (eg due to skip[i] or masked regions) are handled */
	      LP1m[0][i] = Hdel1[i] ? startLP1m : startLP1m - BigPen;
	      LP1m[1][i] = Hdel1[i] ? startLP1m - BigPen : startLP1m;
	    }

	    if(SNP_TRACE && iter==ITER_ID && (iL1 <= SITE_ID && SITE_ID <= iR1)){
	      #pragma omp critical
	      {
		printf("m=%d/%d(id=%lld):iL1=%d(addid1[%d]=%d,delid1[%d]=%d),iR1=%d(addid1[%d]=%d,delid1[%d]=%d),startLP1m= %0.6f:\n", m,MD,gmap[pcontig->contig[m].mapid]->id,
		       iL1, TminM[m], ((addcnt1 <= 0 || (TmaxM[m] <= TminM[m] && TminM[m]==0)/*NEW10*/) ? imax : addid1[TminM[m]]), DminM[m], delid1[DminM[m]], 
		       iR1, TmaxM[m], ((addcnt1 <= 0 || (TmaxM[m] <= TminM[m] && TminM[m]==0)/*NEW10*/) ? imin : addid1[TmaxM[m]]), DmaxM[m], delid1[DmaxM[m]], startLP1m);
		for(int i = iL1; i <= iR1; i++)
		  if(i==SITE_ID)
		    printf("\t i=%d:LP1m[0][i] = %0.6f, LP1m[1][i] = %0.6f, Hdel1[i]=%d, skip[i]=%d, Hcuts[i]=%0.6f,resKB=%0.6f\n", i, LP1m[0][i], LP1m[1][i], Hdel1[i], skip[i], Hcuts[i], resKB);
		fflush(stdout);
	      }
	    }

	    if(addcnt1 > 0 && /* NEW6 */ !(TmaxM[m] <= TminM[m] && TminM[m]==0)){
	      for(int T1 = TminM[m]; T1 <= TmaxM[m]; T1++){
		if(DEBUG>=2) assert(0 <= T1 && T1 < addcnt1);
		int i = addid1[T1];
		if(i < imin || i > imax)
		  continue;

    	        if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:T1=%d,addid1[T1]=i=%d,newLPa[m][T1]=%0.6f,startLP1m=%0.6f (delta=%0.6f):LP1m[1][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,T1,i,newLPa[m][T1],startLP1m,newLPa[m][T1]-startLP1m,i,LP1m[1][i],newLPa[m][T1]);
		  fflush(stdout);
		}
		if(DEBUG>=2) assert(iL1 <= i && i <= iR1);
		LP1m[1][i] = newLPa[m][T1];
	      }

	      // NEW2 : correct default values for LP1m[1][i] outside of the range i = addid1[TminM[m]..TmaxM[m] (but within range iL1..iR1)
	      double LPleft = newLPa[m][TminM[m]];
	      double LPright = newLPa[m][TmaxM[m]];

	      for(int T1 = TminM[m]; --T1 >= 0;){
		int i = addid1[T1];
		if(i < iL1)
		  break;
		if(!Hdel1[i])
		  continue;
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:T1=%d,addid1[T1]=%d,newLPa[m][%d]=%0.6f,startLP1m=%0.6f (delta=%0.6f):LP1m[1][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,T1,i,TminM[m],LPleft,startLP1m,LPleft-startLP1m,i,LP1m[1][i],LPleft);
		  fflush(stdout);
		}
		LP1m[1][i] = LPleft;
	      }
		
	      for(int T1 = TmaxM[m]; ++T1 < addcnt1;){
		int i = addid1[T1];
		if(i > iR1)
		  break;
		if(!Hdel1[i])
		  continue;
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:T1=%d,addid1[T1]=%d,newLPa[m][%d]=%0.6f,startLP1m=%0.6f (delta=%0.6f):LP1m[1][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,T1,i,TmaxM[m],LPright,startLP1m,LPright-startLP1m,i,LP1m[1][i],LPright);
		  fflush(stdout);
		}
		LP1m[1][i] = LPright;
	      }
	    } // addcnt1 > 0

	    if(DminM[m] > 0){
	      for(int I1 = DminM[m]; I1 <= DmaxM[m]; I1++){
		int i = delid1[I1];
		if(i < imin || i > imax)
		  continue;

		if(DEBUG>=2 && !(iL1 <= i && i <= iR1)){
                  #pragma omp critical
		  {
		    printf("m=%d/%d:iL1=%d,iR1=%d,startLP1m= %0.6f,I1=%d(DminM[m]=%d,DmaxM[m]=%d),delid1[I1]=i=%d:\n",m,MD,iL1,iR1,startLP1m,I1,DminM[m],DmaxM[m],delid1[I1]);
		    for(int t = iL1; t <= iR1; t++)
		      printf("\t t=%d:LP1m[0][t] = %0.6f, LP1m[1][t] = %0.6f, Hdel1[t]=%d, skip[t]=%d, Hcuts[t]=%0.6f,resKB=%0.6f\n", t, LP1m[0][t], LP1m[1][t], Hdel1[t], skip[t], Hcuts[t], resKB);
		    fflush(stdout);
		    assert(iL1 <= i && i <= iR1);
		  }
		}
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:I1=%d,delid1[I1]=i=%d,newLPd1[m][I1]=%0.6f,startLP1m=%0.6f (delta=%0.6f):LP1m[0][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,I1,i,newLPd[m][I1],startLP1m,newLPd[m][I1]-startLP1m,i,LP1m[0][i],newLPd[m][I1]);
		  fflush(stdout);
		}

		LP1m[0][i] = newLPd[m][I1];
	      }
	    
	      // NEW2 : correct default values for LP1m[0][i] outside of the range i = delid1[DminM[m]..DmaxM[m]] (but within range iL1..iR1)
	      double LPleft = VMEM_MINIMIZE ? newLPd0[m] : newLPd[m][0];
	      double LPright = newLPd[m][DmaxM[m]];
	      
	      for(int I1 = DminM[m]; --I1 > 0;){
		int i = delid1[I1];
		if(i < iL1)
		  break;
		if(Hdel1[i])
		  continue;
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:I1=%d,delid1[I1]=i=%d,newLPd1[m][0]=%0.6f,startLP1m=%0.6f (delta=%0.6f):LP1m[0][%d]=%0.6f->%0.6f\n",
		    iter,m,MD,I1,i,LPleft,startLP1m,LPleft-startLP1m,i,LP1m[0][i],LPleft);
		  fflush(stdout);
		}
		LP1m[0][i] = LPleft;
	      }

	      for(int I1 = DmaxM[m]; ++I1 <= N1;){
		int i = delid1[I1];
		if(i > iR1)
		  break;
		if(Hdel1[i])
		  continue;
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:I1=%d,delid1[I1]=i=%d,newLPd1[m][%d]=%0.6f,startLP1m=%0.6f (delta=%0.6f):LP1m[0][%d]=%0.6f->%0.6f\n",
		    iter,m,MD,I1,i,DmaxM[m],LPright,startLP1m,LPright - startLP1m,i,LP1m[0][i],LPright);
		  fflush(stdout);
		}
		LP1m[0][i] = LPright;
	      }
	    } // if (DminM[m] > 0)

	    /* compute LP2m[h2=0..1][i=IL2..IR2] from newLPa2[m][] and newLPd2[m][] and startLPA2[m] */
	    double startLP2m = startLPA2[m];
	    for(int i = iL2; i <= iR2; i++){/* set defaults so cases not checked by mprobeval() (eg due to skip[i]) are handled */
 	      LP2m[0][i] = Hdel2[i] ? startLP2m : startLP2m - BigPen;
	      LP2m[1][i] = Hdel2[i] ? startLP2m - BigPen : startLP2m;
	    }
	    if(SNP_TRACE && iter==ITER_ID && (iL2 <= SITE_ID && SITE_ID <= iR2)){
	      #pragma omp critical
	      {
		printf("m=%d/%d:iL2=%d(addid2[%d]=%d,delid2[%d]=%d),iR2=%d(addid2[%d]=%d,delid2[%d]=%d),startLP1m= %0.6f:\n", m,MD,
		       iL2, TminM[m], ((addcnt2 <= 0 || (TmaxM2[m] <= TminM2[m] && TminM2[m]==0)/* NEW10*/) ? imax : addid2[TminM[m]]), DminM[m], delid2[DminM[m]], 
		       iR2, TmaxM[m], ((addcnt2 <= 0 || (TmaxM2[m] <= TminM2[m] && TminM2[m]==0)/* NEW10*/) ? imin : addid2[TmaxM[m]]), DmaxM[m], delid2[DmaxM[m]], startLP1m);
		for(int i = iL2; i <= iR2; i++)
		  if(i==SITE_ID)
		    printf("\t i=%d:LP2m[0][i] = %0.6f, LP2m[1][i] = %0.6f, Hdel2[i]=%d, skip[i]=%d, Hcuts[i]=%0.6f,resKB=%0.6f\n", i, LP2m[0][i], LP2m[1][i], Hdel2[i], skip[i], Hcuts[i], resKB);
		fflush(stdout);
	      }
	    }

	    if(addcnt2 && /* NEW6 */ !(TmaxM2[m] <= TminM2[m] && TminM2[m]==0)){
	      for(int T2 = TminM2[m]; T2 <= TmaxM2[m]; T2++){
		if(DEBUG>=2) assert(0 <= T2 && T2 < addcnt2);
		int i = addid2[T2];
		if(i < imin || i > imax)// NEW
		  continue;

    	        if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:T2=%d,addid2[T2]=%d,newLPa2[m][T2]=%0.6f,startLP2m=%0.6f (delta=%0.6f):LP2m[1][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,T2,i,newLPa2[m][T2],startLP2m,newLPa2[m][T2]-startLP2m,i,LP2m[1][i],newLPa2[m][T2]);
		  fflush(stdout);
		}
		if(DEBUG>=2 && !(iL2 <= i && i <= iR2)){
	          printf("iter=%d,m=%d/%d:T2=%d(TminM2[m]=%d,TmaxM2[m]=%d),addid2[T2]=i=%d,iL2=%d,iR2=%d,newLPa2[m][T2]=%0.6f,startLP2m=%0.6f (delta=%0.6f):LP2m[1][%d]=%0.6f->%0.6f,imin=%d,imax=%d\n",
	            iter,m,MD,T2,TminM2[m],TmaxM2[m],i,iL2,iR2,newLPa2[m][T2],startLP2m,newLPa2[m][T2]-startLP2m,i,LP2m[1][i],newLPa2[m][T2],imin,imax);
		  printf("\t addcnt2=%d\n",addcnt2);
		  fflush(stdout);
	          assert(iL2 <= i && i <= iR2);
	        }
		LP2m[1][i] = newLPa2[m][T2];
	      }

	      // NEW2 : correct default values of LP2m[1][i] outside of the range i = addid2[TminM2[m]..TmaxM2[m]] (but within range iL2..iR2)
	      double LPleft = newLPa2[m][TminM2[m]];
	      double LPright = newLPa2[m][TmaxM2[m]];

	      for(int T2 = TminM2[m]; --T2 >= 0;){
		int i = addid2[T2];
		if(i < iL2)
		  break;
		if(!Hdel2[i])
		  continue;
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:T2=%d,addid2[T2]=%d,newLPa2[m][%d]=%0.6f,startLP2m=%0.6f (delta=%0.6f):LP2m[1][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,T2,i,TminM2[m],LPleft,startLP2m,LPleft-startLP2m,i,LP2m[1][i],LPleft);
		  fflush(stdout);
		}
		LP2m[1][i] = LPleft;
	      }
	      for(int T2 = TmaxM2[m]; ++T2 < addcnt2;){
		int i = addid2[T2];
		if(i > iR2)
		  break;
		if(!Hdel2[i])
		  continue;
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:T2=%d,addid2[T2]=%d,newLPa2[m][%d]=%0.6f,startLP2m=%0.6f (delta=%0.6f):LP2m[1][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,T2,i,TmaxM2[m],LPright,startLP2m,LPright-startLP2m,i,LP2m[1][i],LPright);
		  fflush(stdout);
		}
		LP2m[1][i] = LPright;
	      }
	    }

	    if(DminM2[m] > 0){
	      for(int I2 = DminM2[m]; I2 <= DmaxM2[m]; I2++){
		int i = delid2[I2];
		if(i < imin || i > imax)// NEW
		  continue;

		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:I2=%d,delid2[I2]=i=%d,newLPd2[m][I2]=%0.6f,startLP2m=%0.6f (delta=%0.6f):LP2m[0][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,I2,i,newLPd2[m][I2],startLP2m,newLPd2[m][I2]-startLP2m,i,LP2m[1][i],newLPd2[m][I2]);
		  fflush(stdout);
		}

		if(DEBUG>=2) assert(iL2 <= i && i <= iR2);
		LP2m[0][i] = newLPd2[m][I2];
	      }

	      // NEW2 : correct default values for LP2m[0][i] outside of the range i = delid2[DminM2[m]..DmaxM2[m]] (but within range iL2..iR2)
	      double LPleft = VMEM_MINIMIZE ? newLPd20[m] : newLPd2[m][0];
	      double LPright = newLPd2[m][DmaxM2[m]];
	      
	      for(int I2 = DminM2[m]; --I2 > 0;){
		int i = delid2[I2];
		if(i < iL2)
		  break;
		if(Hdel2[i])
		  continue;
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:I2=%d,delid2[I2]=i=%d,newLPd2[m][0]=%0.6f,startLP2m=%0.6f (delta=%0.6f):LP2m[0][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,I2,i,LPleft,startLP2m,LPleft-startLP2m,i,LP2m[0][i],LPleft);
		  fflush(stdout);
		}
		LP2m[0][i] = LPleft;
	      }

	      for(int I2 = DmaxM2[m]; ++I2 <= N2;){
		int i = delid2[I2];
		if(i > iR2)
		  break;
		if(Hdel2[i])
		  continue;
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID){
		  printf("iter=%d,m=%d/%d:I2=%d,delid2[I2]=i=%d,newLPd2[m][%d]=%0.6f,startLP2m=%0.6f (delta=%0.6f):LP2m[0][%d]=%0.6f->%0.6f\n",
			 iter,m,MD,I2,i,DmaxM2[m],LPright,startLP2m,LPright - startLP2m,i,LP2m[0][i],LPright);
		  fflush(stdout);
		}
		LP2m[0][i] = LPright;
	      }
	    } // if(DminM2[m] > 0)

	    int iL = min(iL1,iL2), iR = max(iR1,iR2);
	    /* Update LPm[h=0..3][i= iL .. iR] based on LP1m[h1][i],LP2[h2][i] */
	    myirangeSum += iR-iL+1;

	    if((VERB>=3 && iter==0) || (DEBUG>=2 && Hcuts[iR] - Hcuts[iL] > gmap[pcontig->contig[m].mapid]->len * 50.0)){
	      #pragma omp critical
	      {
		Rsum += iR-iL+1;
		printf("WARNING:m=%d:tid=%d,T1=%d..%d(i=%d..%d),T2=%d..%d(i=%d..%d)\n\t D1=%d..%d(i=%d..%d),D2=%d..%d(i=%d..%d)\n]\t iL1=%d,iR1=%d,iL2=%d,iR2=%d,iL=%d,iR=%d: Hcuts[iR]=%0.3f,Hcuts[iL]=%0.3f,len=%0.3f:Rsum= %lld\n",
		       m,tid,TminM[m],TmaxM[m],addid1[TminM[m]],addid1[TmaxM[m]],TminM2[m],TmaxM2[m],addid2[TminM2[m]],addid2[TmaxM2[m]],
		       DminM[m],DmaxM[m],delid1[DminM[m]],delid1[DmaxM[m]],DminM2[m],DmaxM2[m],delid2[DminM2[m]],delid2[DmaxM2[m]],
		       iL1,iR1,iL2,iR2,iL,iR,Hcuts[iR],Hcuts[iL],gmap[pcontig->contig[m].mapid]->len,Rsum);
		fflush(stdout);
		//		if(DEBUG>=1+RELEASE) assert(Hcuts[iR] - Hcuts[iL] <= gmap[pcontig->contig[m].mapid]->len * 50.0);
	      }
	    }

	
	    double newLPAm = newLPA[m];
	    if(DEBUG>=2){
	      double LP1 = startLP1m;
	      double LP2 = startLP2m;
	      double LP12 = HapLP(LP1,LP2,logH);
	      if(!(fabs(LP12 - newLPAm) < 1e-7)){
                #pragma omp critical
		{
		  printf("m=%d/%d:startLPA1[m]=%0.8f,startLPA2[m]=%0.8f,newLPA[m]=%0.8f,TBmapWT[m]=%0.8f,LP12=%0.8f(err=%0.8f)\n",
			 m,MD,startLPA1[m],startLPA2[m],newLPA[m],TBmapWT[m],LP12,LP12-newLPAm);
		  fflush(stdout);
		  assert(fabs(LP12 - newLPAm) < 1e-7);
		}
	      }
	    }

	    for(int h1 = 0; h1 <= 1; h1++){
	      for(int h2 = 0; h2 <= 1; h2++){
		int h = h1 | (h2<<1);
		for(int i = iL; i <= iR; i++){/* NOTE : this range is usually a small subset of the full range i= imin..imax and this is the main source of speedup */
		  double LP1 = (iL1 <= i && i <= iR1) ? LP1m[h1][i] : startLP1m;
		  double LP2 = (iL2 <= i && i <= iR2) ? LP2m[h2][i] : startLP2m;
		  double LP12 = HapLP(LP1,LP2,logH);

		  LPm[h][i] += (LP12 - newLPAm) * TBmapWTm;
		  if(SNP_TRACE && iter==ITER_ID && i==SITE_ID /* HERE HERE && h==SNP_ID */ /*  && (h==0 || h==3)*/){
		    printf("m=%d/%d(id=%lld):iter=%d,i=%d,h=%d:LP1=%0.8f,LP2=%0.8f,LP12=%0.8f,TBmapWT=%0.6f,newLPA[m]=%0.8f (change=%0.8f, LP[h][i]=cumwt=%0.8f):iL1=%d,iR1=%d,iL2=%d,iR2=%d\n",
		          m,MD,gmap[pcontig->contig[m].mapid]->id,iter,i,h,LP1,LP2,LP12,TBmapWTm,newLPAm,(LP12-newLPAm), LP[h][i],iL1,iR1,iL2,iR2);
		    fflush(stdout);
		  }
		}
	      }
	    }
	  }/* omp for m = 0..MD-1 */

	  if(OMP_DEBUG && myLoopCnt > 0){
	    #pragma omp atomic update
	    LoopCnt += myLoopCnt;
	  }

	  #pragma omp atomic update
          irangeSum += myirangeSum;

	  /* compute ntheadsP2 as smallest power of 2 that is >= nthreads */
	  int nthreadsP2 = 1;
	  while(nthreadsP2 < nthreads)
	    nthreadsP2 <<= 1;

	  if(DEBUG && !(tid >= 0)){
	    #pragma omp critical
	    {
	      printf("tid= %d, MD= %d, nthreads= %d, numthreads= %d, block= %d: actual thread=%d\n",tid, MD, nthreads, numthreads, block, omp_get_thread_num());
	      fflush(stdout);
	      assert(tid >= 0);
	    }
	  }

	  /* add LPT[1..nthreads-1][h][i] to LPT[0][h][i] */
	  for(int P2 = nthreadsP2; P2 > 1;){/* This loop has Log2(nthreadsP2) iterations */
	    P2 >>= 1;
	    int tidP2 = tid + P2;
	    if(tid < P2 && tidP2 < nthreads)  /* add LPT[tidP2][h][i] to LPT[tid][h][i] */
	      for(int h = 0; h <= 3; h++)
		for(int i = imin; i <= imax; i++)
		  LPT[tid][h][i] += LPT[tidP2][h][i];
            #pragma omp barrier
	  }
	}// parallel
	if(OMP_DEBUG) assert(LoopCnt == MD);

	if(TIME_VERBOSE){
	  double wt = wtime();
	  getmem(VmSize,VmRSS, VmSwap,&VmHWM,&VmPeak);
	  printf("Pre-processed LPT values for all sites, iter=%d:MD=%d,iSum=%lld(av=%0.1f), VmRSS=%0.3f(HWM=%0.3f),VmSwap=%0.3f,VmSize=%0.3f(Peak=%0.3f): time=%0.6f, wall time=%0.6f (cum=%0.6f)\n", 
		 iter, MD, irangeSum, ((double)irangeSum)/MD, VmRSS*1e-9,VmHWM*1e-9,VmSwap*1e-9,VmSize*1e-9,VmPeak*1e-9,mtime()-start, wt-wstart, wt);
	  fflush(stdout);
	}

	if(HEAP_MINIMIZE){// call madvise to free up most of the delmem[] memory, keep only the memory for the 1st thread which corresponts to LPT[0][h][i] == LP[h][i]
	  if(madvise(&delmem[threadsiz], delmemsiz - threadsiz*sizeof(double), MADV_DONTNEED)){
	    int eno = errno;
	    char *err = strerror(eno);
	
	    printf("madvise(%p,%llu,MADV_DONTNEED) failed:errno=%d:%s\n",&delmem[threadsiz],delmemsiz - threadsiz*sizeof(double),eno,err);
	    fflush(stdout);exit(1);
	  } else if(TIME_VERBOSE){
	    getmem(VmSize,VmRSS, VmSwap);
	    printf("After freeing most LPT memory with madvise(DONTNEED): VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: cum wall time=%0.6f\n", VmRSS*1e-9,VmSwap*1e-9,VmSize*1e-9,wtime());
	    fflush(stdout);
	  }
	}

	/* add change in SITE_PEN and HapSitePvalue penalty for LP[h=0..3][i] vs baseline (HapSite[i]) at site i */
	/* NOTE : LPstart includes the SITE_PEN and HapSitePvalue penalties for the baseline over all sites */
	double HapSitePen[4] = {0.0,logHapSitePvalue - 0.5*SITE_PEN, logHapSitePvalue - 0.5*SITE_PEN, -SITE_PEN};      /* penalty as function of h or HapSite[i] */
	if(VERB>=2 && iter==0){
	  printf("logHapSitePvalue = %0.6f,SITE_PEN= %0.6f\n",logHapSitePvalue, SITE_PEN);
	  for(int h = 0; h <= 3; h++)
	    printf("HapSitePen[h=%d]= %0.6f\n", h, HapSitePen[h]);
	  fflush(stdout);
	}

	for(int h = 0; h <= 3; h++){
	  double newpen = HapSitePen[h];
	  for(int i = imin; i <= imax; i++){
	    double origLPhi = LP[h][i];
	    LP[h][i] += newpen - HapSitePen[HapSite[i]];
	    if(SNP_TRACE && iter==ITER_ID && i==SITE_ID /* && h==SNP_ID */ /* && iter==0 && (1854 <= i && i <= 1947)*/){
	      printf("h=%d,i=%d:newpen=%0.8f,skip[i]=%d,HapSite[i]=%d,HapSitePen[HapSite[i]]=%0.8f,LP[h][i]=%0.8f -> %0.8f\n",
		     h,i,newpen,skip[i],HapSite[i],HapSitePen[HapSite[i]],origLPhi,LP[h][i]);
	      fflush(stdout);
	    }
	  }
	}

	if(IndelCnt > 0){/* add corrections for LP[h][i] if h != HapSite[i] && HapDelta[i] != 0 AND/OR nearest left HapSite[L] != 0 */
	  int L = 0;
	  for(int i = 1; i <= imax; i++){
	    if(i < imin){
	      if(HapSite[i])
		L = i;/* track nearest L < i with HapSite[i] */
	      continue;
	    }
	    if(HINDEL_SPLIT_FIX==0 && HapDelta[L] && HapSite[i] <= 2){/* add correction for LP[h=3][i] due to splitting of HapDelta's */
	      for(int h = 3; h <= 3; h++){
		if(DEBUG) assert(h > HapSite[i]);
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID /* && h==SNP_ID */ /* && iter==0 && (2329 <= i && i <= 2331)*/){
		  printf("i=%d,L=%d,h=%d:HapDelta[L]=%0.4e,HapSite[L,i]=%d,%d,LP[h][i]=%0.6f -> %0.6f\n",
			 i,L,h,HapDelta[L],HapSite[L],HapSite[i],LP[h][i],LP[h][i]+logHapIndelPvalue);
		  fflush(stdout);
		}
		LP[h][i] += logHapIndelPvalue;
	      }
	    }

	    if(HapDelta[i] && HapDelta[L] && HapSite[i]==3){  /* add correction for LP[0][i] due to merging of HapDelta's */
	      for(int h = 0; h <= 2; h++){	    /* Also add correction for LP[h=1,2][i] */
		if(DEBUG) assert(h < HapSite[i]);
		if(SNP_TRACE && iter==ITER_ID && i==SITE_ID /* && h==SNP_ID */ /* && iter==0 && (2329 <= i && i <= 2331)*/){
		  printf("i=%d,L=%d,h=%d:HapDelta[L,i]=%0.4e,%0.4e,HapSite[L,i]=%d,%d,LP[h][i]=%0.6f -> %0.6f\n",
			 i,L,h,HapDelta[L],HapDelta[i],HapSite[L],HapSite[i],LP[h][i],LP[h][i]-logHapIndelPvalue);
		  fflush(stdout);
		}
		LP[h][i] -= logHapIndelPvalue;
		if(fabs(HapDeltaMerged[L] + HapDeltaMerged[i]) < MIN_INDEL_SIZE){/* both Indels cancel out */
		  LP[h][i] -= logHapIndelPvalue;
		  if(SNP_TRACE && iter==ITER_ID && i==SITE_ID /* && h==SNP_ID && iter==0 && (2329 <= i && i <= 2331)*/){
		    printf("i=%d,L=%d,h=%d:HapDelta[L,i]=%0.4e,%0.4e(tot=%0.4e),HapSite[L,i]=%d,%d,LP[h][i]=%0.6f -> %0.6f\n",
			   i,L,h,HapDelta[L],HapDelta[i],HapDeltaMerged[L]+HapDeltaMerged[i],HapSite[L],HapSite[i],LP[h][i],LP[h][i]-logHapIndelPvalue);
		    fflush(stdout);
		  }
		}
	      }
	    }

	    if(SNP_TRACE && iter==ITER_ID && i==SITE_ID /* && iter==0 && (2329 <= i && i <= 2331)*/){
	      printf("i=%d,L=%d:HapDelta[i]=%0.4e(tot=%0.4e),Delta[i]=%0.4e,HapSite[i]=%d,LP[0][i]=%0.6f\n",
		       i,L,HapDelta[i],HapDeltaMerged[i],Delta[i],HapSite[i],LP[0][i]);
	      fflush(stdout);
	    }

	    if(L==0 && HapDelta[i] && HapSite[i]) {/* cannot remove HapSite[i] without removing HapDelta[i] since HapDelta[0] is not supported */
	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID /* && 0==SNP_ID && iter==0 && (2329 <= i && i <= 2331)*/){
	        printf("i=%d,L=%d:HapDelta[i]=%0.4e(tot=%0.4e),Delta[i]=%0.4e,HapSite[i]=%d,LP[0][i]=%0.6f -> %0.6e (HapDelta[0] not supported)\n",
		       i,L,HapDelta[i],HapDeltaMerged[i],Delta[i],HapSite[i],LP[0][i], LP[0][i]-BigPen);
		fflush(stdout);
	      }
	  
	      LP[0][i] -= BigPen;
            }

	    if(HapSite[i])
	      L = i;/* track nearest L < i with HapSite[i] */
	  }
	}

	/* NOTE : LP[h=0..3][i=imin..imax] + LPstart is the LP value needed (to search for values that improve on LPstart) */
	if(VERB>=2 || SPEEDCHECK){
	  double wt = wtime();
	  getmem(VmSize,VmRSS, VmSwap);
	  printf("Pre-processed SNP LP values for all sites, iter=%d: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: time=%0.6f, wall time=%0.6f (cum=%0.6f)\n", iter, VmRSS*1e-9,VmSwap*1e-9,VmSize*1e-9,mtime()-start, wt-wstart, wt);
	  fflush(stdout);
	}
      }

      if(DEBUG/* HERE >=2 */ && SNP_TRACE && iter==ITER_ID && SITE_ID <= n){
	/* check that hprobeval() is not changed from un-spreading HapDelta[], Delta[] */
	double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			       TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,testLPA,pcontig,numthreads,SNPs,Indels,0);
	if(DEBUG && !(fabs(hLP - LPstart) < 1e-6 && SNPcnt == SNPs && IndelCnt == Indels)){
	  printf("WARNING:After restoring HapDelta[],Delta[] hLP=%0.6f(SNPs=%d,Indels=%d),LPstart=%0.6f(err=%0.6f),SNPcnt=%d,IndelCnt=%d\n",
		 hLP,SNPs,Indels,LPstart,hLP-LPstart,SNPcnt,IndelCnt);
	  fflush(stdout);
	  //	assert(fabs(hLP - LPstart) < 1e-3);// program can recover from this error
	}
      
	LPstart = newLP = hLP;
	SNPcnt = SNPs;
	IndelCnt = Indels;

	double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
	tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;

	if(SNP_TRACE && iter==ITER_ID && 0 <= SITE_ID && SITE_ID <= n){
	  printf("Before changing label at HapSite[%d]= %d, Hcuts[%d]= %0.4f:\n",SITE_ID,HapSite[SITE_ID],SITE_ID,Hcuts[SITE_ID]);
	  fflush(stdout);

	  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */

	  rverb = 1;
	  double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
	    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[SITE_ID],Hcuts1[SITE_ID],Hcuts2[SITE_ID],Hcuts2[SITE_ID],0,0,0,0,testLPA,pcontig,numthreads,SNPs,Indels,0);
	  rverb = 0;

	  printf("hLP= %0.6f,SNPs=%d,Indels=%d\n",hLP,SNPs,Indels);
	  printf("After changing HapSite[%d] = %d -> %d at Hcuts[%d]= %0.4f\n",SITE_ID, HapSite[SITE_ID],SNP_ID,SITE_ID,Hcuts[SITE_ID]);
	  fflush(stdout);

	  int origHapSite = HapSite[SITE_ID];
	  HapSite[SITE_ID] = SNP_ID;

	  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */

	  rverb = 1;
	  double hLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
	    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[SITE_ID],Hcuts1[SITE_ID],Hcuts2[SITE_ID],Hcuts2[SITE_ID],0,0,0,0,testLPA,pcontig,numthreads,SNPs,Indels,0);
	  rverb = 0;

	  printf("hLP= %0.6f,SNPs=%d,Indels=%d\n",hLP2,SNPs,Indels);
	  fflush(stdout);

	  HapSite[SITE_ID] = origHapSite;

	  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	}
      }
      double orignewLP = newLP;
      if(HINDEL_FAST)
	memcpy(startLP,newLPA,MD*sizeof(double));

      /* keep track of locally best improvement to LP values */
      double LPbest = LPstart;/* best LP value so far since last change (at site ibest), during following main i=1..imax+1 loop */
      int ibest = -1, Lbest = -1, Rbest = -1;/* site i value corresponding to LPbest (and previous and next site with HapSite[] != 0) */
      int LLbest = -1, RRbest = -1;/* corresponding LL and RR values (see HINDEL_MERGE >= 2) */
      int tbest = -1;/* Type of LPbest : 0 == nHapSite[ibest] changed, 1 == nHapDelta[ibest] change, 2 == nDelta[ibest] change (non HaploType interval size change for Hcuts[ibest..ibest+1]) */
      double range1best = 0.0, range2best = 0.0;/* value of range1,range2 corresponding to ibest (if tbest > 0) : only used with tbest == 1 to reverse phase of new Indel (to check if this is valid) */
      int ileft = 0;

      /* Use the saved per map LP values to score HaploType changes */
      int I1 = 0, I2 = 0;/* Number of real sites encoutered on HaploType 1 and 2 respectively : used to access site deletion LP values newLPd2[m][I2 < DminM2[m] ? 0 : min(DmaxM2[m],I2)] */
      int T1 = -1, T2 = -1;/* addloc2[T2] is last missing site encountered on HaploType 2 : used to access site addition LP values newLPa2[m][T2 < TminM2[m] ? TminM2[m] : min(TmaxM2[m],T2)] */
      double LPsnp[4];/* LPsnp[h=0..3] is used to save LP values for HapSite[i] = h */

      if(DEBUG>=2 && HINDELITER(iter)){
	int I1 = 0, I2 = 0;
	for(int i = 1; i <= n; i++){
	  if(!Hdel1[i])
	    I1++;
	  if(!Hdel2[i])
	    I2++;
	  if(DEBUG) assert(Hdel1[i]==0 || Hdel1[i]==1);
	  if(DEBUG) assert(Hdel2[i]==0 || Hdel2[i]==1);
	  if(DEBUG) assert(D1[I1] >= DR1[I1]);
	  if(DEBUG && !(D2[I2] >= DR2[I2])){
	    printf("iter=%d:I2=%d,D2[I2]=%d,DR2[I2]=%d\n",iter,I2,D2[I2],DR2[I2]);
	    fflush(stdout);
	    assert(D2[I2] >= DR2[I2]);
	  }
	}
	if(DEBUG) assert(I1 == N1);
	if(DEBUG) assert(I2 == N2);
      }

      for(int i = imin; i <= imax; i++)
	if(HapSite[i])
	  skip[i] = 0;

      /* keep track of largest indel or interval size that was beneficial, so the Initial_Delta[] array can be adjusted downwards for greater precision (or upwards for faster convergence) */
      double rawLPstart = LPstart;
      if(HINDEL_FAST){
	rawLPstart += 0.5*(startN1+startN2)*SITE_PEN;
	rawLPstart -= logHapSitePvalue * startSNPcnt + logHapIndelPvalue * startIndelCnt;
      }

      if(!HINDELITER(iter))
	hapsitecnt = 0;/* number of changes above LP_SITE_MINDELTA made for HapSite[] (for this value of iter) */
      else {
	hapdeltacnt = 0;/* number of changes above LP_INDEL_MINDELTA made for HapDelta[] (for this value of iter) */
	deltacnt = 0;/* number of changes above LP_INTERVAL_MINDELTA made for Delta[] (for this value of iter) */
      }

      int ipbest = 1;
      int activecnt = 0;/* number of active or reactived intervals in current iteration */
      int newactivecnt = 0;/* number of newly active intervals that were previously inactive : can only happen if neighboring intervals is active */

      if(HINDELITER(iter))
	for(int IN = 0; IN <= maxIN; IN++)
	  biggestD1[IN] = -1;

      double lastVmRSS = 0.0;

      if(HINDELITER(iter) && FAST_HPROBEVAL >= 5 && iter >= HMIN_ITER + 2*FAST_INDEL && !(DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
        memcpy(origHapSite,HapSite,(n+2)*sizeof(int));
        memcpy(origHapDelta,HapDelta,(n+2)*sizeof(double));
        memcpy(origDelta,Delta,(n+2)*sizeof(double));
	/* need to backup map1[],map2[] */
	int block = 1;
	while(block < 16 && MD > numthreads * block)
	  block *= 2;

        #pragma omp parallel for schedule(static,block) num_threads(numthreads)
	for(int m = 0; m < MD; m++){
	  int M = MX[m];
	  memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
	  memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
	  memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
	  memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
        }

	if(DEBUG>=2){/* verify original LP */
	  //	  rverb = (iter==8) ? 1: 0;
	  if(rverb){
	    printf("Calling hprobeval before Testing simultaneous HapDelta changes\n");
	    fflush(stdout);
	  }
	  double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
	    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  //	  rverb = 0;
	  printf("%sBefore Testing simultaneous HapDelta,Delta changes: LP= %0.8f (should be %0.8f) (err= %0.8f), SNPcnt= %d, IndelCnt= %d: cum wall= %0.6f\n",
	    (fabs(LP-newLP) > 1e-5|| SNPs != SNPcnt || Indels != IndelCnt) ? "WARNING:" : "", LP, newLP, LP-newLP,SNPs,Indels, wtime());
	  fflush(stdout);
	  if(DEBUG) assert(fabs(LP-newLP) <= 1e-5);
	}
        
	double wt1 = TIME_VERBOSE ? wtime() : 0.0;

	// apply all HapDelta & Delta changes at once
	fastHapDelta(iter,imin,imax,n,initHapIndelPvalue, origHapIndelPvalue,startN1,startN2,
	  maxIN,DELTA_OVERSAMPLE,DELTA_SCAN,DELTA_RANGE,DELTA_INTERVALS,DELTA_INTERVAL,activecnt,newactivecnt,Initial_Delta,
	  ID1,ID2,Dcum,Dcum2,Filtered,Deresed,threadsize,HtrimL1,HtrimR1,HtrimL2,HtrimR2,numthreads,
	  Hcuts,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,startY1,startY2,skip,TBmapWT,startLP,
	  HapSite,HapDelta,Delta,prevHapSite,prevHapDelta,prevDelta,nHapDelta,nHapDelta2,nDelta,DelCum,HapDelCum,HapDeltaScore,
          startHdel1,startHdel2,addid1,addid2,LPstart,BigPen,logH,rawLPstart,logHapSitePvalue,logHapIndelPvalue,
	  startSNPcnt,startIndelCnt,startLPA1,startLPA2,
	  LPindel,LPdelta,newLPdelta,newLPdelta2,D1,D2,DR1,DR2,biggestD1,
          AminM,AminM2,AmaxM,AmaxM2,LPddT,LPdd,LPddmem,d1List,d2List,pvLP1,pvLP2,prLP,
	  delta1,delta2,HapDeltaMerged,pBlock1,pBlock2,Label,Index,Hremap,
	  changes,tchanges,progress,changecnt,hapdeltacnt,deltacnt,spreadHapDelta,spreadDelta,
	  map1,map2,mapK1,mapK2,nmap1,nmap2,MX,MD);

	double wt2 = TIME_VERBOSE ? wtime() : 0.0;
	if(TIME_VERBOSE){
	   printf("iter=%d:Made %d + %d simultaneous HapDelta[] + Delta[] changes(activecnt=%d,new=%d): wall= %0.6f (cum= %0.6f)\n",iter,hapdeltacnt,deltacnt,activecnt,newactivecnt,wt2-wt1,wt2);
	  fflush(stdout);
	}

	bool confirmed = true;
	if(hapdeltacnt > 0 || deltacnt > 0){ /* confirm newLP and update bestLPA[] */
  	  confirmed = false;

	  int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	  if(err){
	    if(VERB/* HERE >=2 */){
              printf("\t WARNING:hsetmap failed\n");
	      fflush(stdout);
	    }
	  } else {
	    double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				  TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    if(VERB){
	      double wt = wtime();
	      printf("iter=%d:After %d + %d simultaneous HapDelta[] + Delta[] changes: LP= %0.6f -> %0.6f (delta= %0.6f, SNPcnt=%d,IndelCnt=%d): wall= %0.6f(cum=%0.6f)\n",iter,hapdeltacnt,deltacnt,newLP, LP, LP-newLP, SNPs,Indels,wt-wt2,wt);
	      fflush(stdout);
	    }
	    if(LP > newLP){
	      confirmed = true;

	      LPstart = newLP = LP;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;
	      double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;
	    }
	  }

	  if(!confirmed){/* revert HapSite,HapDelta,Delta etc */
	    memcpy(HapSite,origHapSite,(n+2)*sizeof(int));
	    memcpy(HapDelta,origHapDelta,(n+2)*sizeof(double));
	    memcpy(Delta,origDelta,(n+2)*sizeof(double));
	    /* need to restore map1[],map2[] */
	    int block = 1;
	    while(block < 16 && MD > numthreads * block)
	      block *= 2;
	    
            #pragma omp parallel for schedule(static,block) num_threads(numthreads)
	    for(int m = 0; m < MD; m++){
	      int M = MX[m];
	      memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
	      memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
	      memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
	      memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
	    }	  

	    (void) hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	    if(DEBUG/* HERE >=2 */){/* verify that original LP was restored */
	      //	    rverb = 1;
	      if(rverb){
	        printf("Calling hprobeval after reverting %d + %d simultaneous (HapDelta + Delta) changes\n",hapdeltacnt,deltacnt);
		fflush(stdout);
	      }
	      double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      //	    rverb = 0;

	      printf("%sAfter reverting %d + %d (HapDelta + Delta) changes: LP= %0.8f (should be %0.8f) (err= %0.8f), SNPcnt= %d, IndelCnt= %d: cum wall= %0.6f\n",
	      (fabs(LP-newLP) > 1e-5|| SNPs != SNPcnt || Indels != IndelCnt) ? "WARNING:" : "", hapdeltacnt,deltacnt, LP, newLP, LP-newLP,SNPs,Indels, wtime());
	      fflush(stdout);
	      if(DEBUG>=1+RELEASE) assert(fabs(LP-newLP) <= 1e-5);

	      LPstart = newLP = LP;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;
	      double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;
	    }
	    hapdeltacnt = deltacnt = 0;
	    newactivecnt = activecnt = progress = 0;

	    if(HINDELITER(iter))
	      for(int IN = 0; IN <= maxIN; IN++)
		biggestD1[IN] = -1;
	  }
	  
	  if(VERB>=1+RELEASE /* HERE >= 2 */){  /* compute DelCum[i+1] = Sum(Delta[0..i]) and HapDelCum[] */
	    double DeltaCum = 0.0, HapDeltaCum = 0.0;
	    for(int i = 0; i <= n; i++){
	      HapDelCum[i+1] = HapDeltaCum += HapDelta[i];
	      DelCum[i+1] = DeltaCum += Delta[i];
	    }
	  }
	}

	if(confirmed) // If no change OR progress is made jump ahead over the normal verification of each change, else fall back on normal verification of each change
	  goto LskipFullCheck;
      }

      if(!HINDELITER(iter) && FAST_HPROBEVAL >= 4 && iter >= FAST_SNPS + startiter && !(DEBUG_CONVERGE && iter>=DEBUG_CONVERGE) && !(SNP_TRACE && iter==ITER_ID)){
        memcpy(origHapSite,HapSite,(n+2)*sizeof(int));
        memcpy(origHapDelta,HapDelta,(n+2)*sizeof(double));
        memcpy(origDelta,Delta,(n+2)*sizeof(double));

	if(DEBUG>=2){/* verify original LP */
	  //	  rverb = (iter==8) ? 1: 0;
	  if(rverb){
	    printf("Calling hprobeval before Testing simultaneous HapSite changes\n");
	    fflush(stdout);
	  }
	  double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
	    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  //	  rverb = 0;
	  printf("%sBefore Testing simultaneous HapSite[] changes: LP= %0.8f (should be %0.8f) (err= %0.8f), SNPcnt= %d, IndelCnt= %d: cum wall= %0.6f\n",
	    (fabs(LP-newLP) > 1e-5|| SNPs != SNPcnt || Indels != IndelCnt) ? "WARNING:" : "", LP, newLP, LP-newLP,SNPs,Indels, wtime());
	  fflush(stdout);
	  if(DEBUG) assert(fabs(LP-newLP) <= 1e-5);
	}

	double mt1= TIME_VERBOSE ? mtime() : 0.0, wt1 = TIME_VERBOSE ? wtime() : 0.0;

	// apply all SNP changes at once
	fastHapSite(iter,imin,imax,n,startN1,startN2,maxIN,DELTA_OVERSAMPLE,DELTA_SCAN,DELTA_RANGE,DELTA_INTERVALS,DELTA_INTERVAL,activecnt,Initial_Delta,
		    ID1, ID2, Filtered,Deresed,HtrimL1,HtrimR1,HtrimL2,HtrimR2,Lfrozen,Hcuts,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,startY1,startY2,skip,HapSite,nHapSite,prevHapSite,HapDelta,Delta,
		    prevHapDelta,prevDelta,DelCum, startHdel1,startHdel2,addid1,addid2,addcnt1,addcnt2,LPstart,BigPen,LPsite,LP,HapSiteScore,SiteScore,
		    changes,tchanges,progress,changecnt,hapsitecnt,spreadHapDelta,spreadDelta,map1,map2,nmap1,nmap2,MD);

	double mt2 = TIME_VERBOSE ? mtime() : 0.0, wt2 = wtime();
	if(TIME_VERBOSE){
	  printf("iter=%d:Made %d simultaneous HapSite[] changes (activecnt=%d): CPU= %0.6f, wall= %0.6f (cum= %0.6f)\n",iter,hapsitecnt,activecnt,mt2-mt1,wt2-wt1,wt2);
	  fflush(stdout);
	}

	bool confirmed = true;
	if(hapsitecnt > 0){ /* confirm newLP and update bestLPA[] */
	  confirmed = false;

	  int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	  if(err){
	    if(VERB/* HERE >=2 */){
	      printf("\t WARNING:hsetmap failed\n");
	      fflush(stdout);
	    }
	  } else {
	    double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				  TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    if(VERB){
	      double wt = wtime();
	      printf("iter=%d:After %d simultaneous HapSite changes: LP= %0.6f -> %0.6f (delta= %0.6f, SNPcnt=%d,IndelCnt=%d): wall= %0.6f(cum=%0.6f)\n",iter,hapsitecnt,newLP, LP, LP-newLP, SNPs,Indels,wt-wt2,wt);
	      fflush(stdout);
	    }
	    if(LP > newLP){
	      confirmed = true;
	      
	      LPstart = newLP = LP;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;
	      double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;
	    }
	  }
	  
	  if(!confirmed){/* revert HapSite,HapDelta,Delta etc */
	    memcpy(HapSite,origHapSite,(n+2)*sizeof(int));
	    memcpy(HapDelta,origHapDelta,(n+2)*sizeof(double));
	    memcpy(Delta,origDelta,(n+2)*sizeof(double));
	    (void) hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	    if(DEBUG/* HERE >=2 */){/* verify that original LP was restored */
	      //	    rverb = 1;
	      if(rverb){
		printf("Calling hprobeval after reverting %d simultaneous HapSite changes\n",hapsitecnt);
		fflush(stdout);
	      }
	      double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      //	    rverb = 0;

	      printf("%sAfter reverting %d HapSite changes: LP= %0.8f (should be %0.8f) (err= %0.8f), SNPcnt= %d, IndelCnt= %d: cum wall= %0.6f\n",
		     (fabs(LP-newLP) > 1e-5|| SNPs != SNPcnt || Indels != IndelCnt) ? "WARNING:" : "", hapsitecnt, LP, newLP, LP-newLP,SNPs,Indels, wtime());
	      fflush(stdout);
	      if(DEBUG) assert(fabs(LP-newLP) <= 1e-5);
	    }
	    hapsitecnt = 0;
	    activecnt = progress = 0;
	  }
	
	  if(VERB>=1+RELEASE /* HERE >= 2 */){  /* compute DelCum[i+1] = Sum(Delta[0..i]) and HapDelCum[] */
	    double DeltaCum = 0.0, HapDeltaCum = 0.0;
	    for(int i = 0; i <= n; i++){
	      HapDelCum[i+1] = HapDeltaCum += HapDelta[i];
	      DelCum[i+1] = DeltaCum += Delta[i];
	    }
	  }
	}
	if(confirmed) // If no change OR progress is made jump ahead over the normal verification of each change, else fall back on normal verification of each change
	  goto LskipFullCheck;
      }

      if(LEFTEXT_FIX){/* locate current leftmost non-Haplotype site */
	for(ileft = 1; ileft <= imax; ileft++)
	  if(HapSite[ileft] == 3)
	    break;

	if(SNP_TRACE){
	  printf("ileft=%d, HapSite[ileft]=%d, Hcuts[ileft]= %0.4f\n",ileft,HapSite[ileft],Hcuts[ileft]);
	  fflush(stdout);
	}
      }

      for(int i = 1; i <= imax+1; i++){// main i loop */
	int L,R;
	int LL = -1;/* previous site with HapSite[LL] == 3 (or 0 if none) */
	int RR = -1;/* next site with HapSite[RR] == 3 (or n+1 if none) */

	double range1 = -1.0,range2 = -1.0;
	int IN1 = -1, IN2 = -1;
	if(i > imax){
	  if(ibest >= 1)
	    goto Lcheckbest;/* need to check last improvement */
	  break;
	}

	if(VERB>=2 && i >= 961){
	  printf("i=%d/%d: HapDelta[959]= %0.6f, HapDelta[961]= %0.6f\n",i,imax,HapDelta[959],HapDelta[961]);
	  fflush(stdout);
	}

	if(DEBUG>=2 && HINDELITER(iter)){
	  for(int I1 = 1; I1 < startN1; I1++)
	    assert(D1[I1] >= DR1[I1]);
	  for(int I2 = 1; I2 < startN2; I2++){
	    if(DEBUG && !(D2[I2] >= DR2[I2])){
	      printf("iter=%d,i=%d:I2=%d,D2[I2]=%d,DR2[I2]=%d,startN2=%d\n",iter,i,I2,D2[I2],DR2[I2],startN2);
	      fflush(stdout);
	      assert(D2[I2] >= DR2[I2]);
	    }
	  }
	}

	I1 += 1 - startHdel1[i];
	I2 += 1 - startHdel2[i];
	if(DEBUG && !(I1 <= startN1 && I2 <= startN2 && startY1[I1] <= startY1[I1+1] && startY2[I2] <= startY2[I2+1])){
	  printf("i=%d,n=%d,imax=%d:I1=%d,N1=%d,Y1[I1]=%0.3f,Y1[I1+1]=%0.3f,Hdel1[i]=%d\n",i,n,imax,I1,startN1,startY1[I1],startY1[I1+1],startHdel1[i]);
	  printf("i=%d,n=%d,imax=%d:I2=%d,N2=%d,Y2[I2]=%0.3f,Y2[I2+1]=%0.3f,Hdel2[i]=%d\n",i,n,imax,I2,startN2,startY2[I2],startY2[I2+1],startHdel2[i]);
	  fflush(stdout);
	  assert(I1 <= startN1);
	  assert(startY1[I1] <= startY1[I1+1]);
	  assert(I2 <= startN2);
	  assert(startY2[I2] <= startY2[I2+1]);
	}
	if(DEBUG) assert(startHdel1[i]==0 || startHdel1[i]==1);
	if(DEBUG) assert(startHdel2[i]==0 || startHdel2[i]==1);
	if(DEBUG) assert(i <= n);

	if(!HINDELITER(iter)){
	  if(DEBUG && skip[i]){
	    assert(startHdel1[i] && startHdel2[i]);
	    assert(T1 >= addcnt1-1 || addid1[T1+1] > i);
	    assert(T2 >= addcnt2-1 || addid2[T2+1] > i);
	  }
	  if(startHdel1[i]){
	    if(DEBUG && !(T1 >= addcnt1-1 || addid1[T1+1] >= i)){
	      if(T1 < addcnt1-1)
		printf("i=%d,n=%d,imin=%d,imax=%d:I1=%d,N1=%d,Hdel1[i]=%d,T1=%d,addcnt1=%d,addid1[T1]=%d,addid1[T1+1]=%d\n",
		       i,n,imin,imax,I1,N1,startHdel1[i],T1,addcnt1,addid1[T1],addid1[T1+1]);
	      else
		printf("i=%d,n=%d,imin=%d,imax=%d:I1=%d,N1=%d,Hdel1[i]=%d,T1=%d,addcnt1=%d,addid1[T1]=%d\n",
		       i,n,imin,imax,I1,N1,startHdel1[i],T1,addcnt1,addid1[T1]);
	      fflush(stdout);
	      assert(T1 >= addcnt1-1 || addid1[T1+1] >= i);
	    }
	    if(T1 < addcnt1-1 &&/*NEW10*/ addid1[T1+1] == i)
	      T1++;
	  }
	  if(startHdel2[i]){
	    if(DEBUG) assert(T2 >= addcnt2-1 || addid2[T2+1] >= i);
	    if(T2 < addcnt2-1 &&/*NEW10*/ addid2[T2+1] == i)
	      T2++;
	  }
	}
      
	if(i <= imin)
	  continue;

	L = i - 1;/* previous site with HapSite[L] */
	while(L >= 1 && !HapSite[L])
	  L--;
	R = i+1;/* next site with HapSite[R] */
	while(R <= n && !HapSite[R])
	  R++;

	if(VERB>=2 && iter==7 && i==4081){
	  printf("iter=%d:i=%d,L=%d,R=%d,n=%d(imin=%d,imax=%d)\n",iter,i,L,R,n,imin,imax);
	  fflush(stdout);
	}

	LL = i;
	while(LL >= 1 && HapSite[LL] != 3)
	  LL--;
	RR = R;
	while(RR <= n && HapSite[RR] != 3)
	  RR++;

	if(DEBUG>=2 && IndelCnt > 0){// NOTE : HapDeltaMerged[i] was previously computed and will only change when HapDelta[] changes
	  double origHapDeltaMerged = HapDeltaMerged[i];
	  HapDeltaMerged[i] = 0.0;

	  double abssum = 0.0;
	  for(int t = LL; t < RR; t++){
	    HapDeltaMerged[i] += HapDelta[t];
	    abssum += fabs(HapDelta[t]);
	  }
	  if(abssum < MIN_INDEL_SIZE)
	    HapDeltaMerged[i] = 0.0;
	  else if(fabs(HapDeltaMerged[i]) < MIN_INDEL_SIZE)
	    HapDeltaMerged[i] = copysign(MIN_INDEL_SIZE,HapDeltaMerged[i]);
	  if(VERB && HapDeltaMerged[i] && HapSite[i] && (VERB>=2 || fabs(origHapDeltaMerged-HapDeltaMerged[i]) >= 1e-6)){
	    printf("iter=%d,i=%d:Hcuts[%d..%d]=%0.4f..%0.4f:HapSite[i]=%d,HapDeltaMerged[i]=%0.6f,origHapDeltaMerged=%0.6f\n",
		   iter,i,LL,RR,Hcuts[LL],Hcuts[RR],HapSite[i],HapDeltaMerged[i],origHapDeltaMerged);
	    fflush(stdout);
	  }

	  if(DEBUG) assert(fabs(origHapDeltaMerged-HapDeltaMerged[i]) < 1e-6);
	  HapDeltaMerged[i] = origHapDeltaMerged;
	}

	LPsite[i] = LPstart - BigPen;/* default value == no improvement possible */
	nHapSite[i] = HapSite[i];

	LPindel[i] = LPstart - BigPen;/* default value == no improvement possible */
	nHapDelta[i] = 0.0;/* nHapDelta[i] is the change in HapDelta[i] during the current iteration */
	nHapDelta2[i] = 0.0;/* nHapDelta2[i] is the change in Delta[i] that goes along with nHapDelta[i] (typically 0.0, unless there are outliers) */

	LPdelta[i] = LPstart - BigPen;/* default value == no improvement possible */
	nDelta[i] = 0.0;/* nDelta[i] is the change in Delta[i] during the current iteration */

	if(VERB>=4 && N1 > 30 && iter==25 && HINDELITER(iter)){
	  int IN1 = ID1[30];
	  printf("i=%d(%d..%d):I1=%d,I2=%d,L=%d,R=%d,LL=%d,RR=%d,HapSite[i]=%d: D1[30]=%d,DR1[30]=%d,IN1[30]=%d,DELTA_RANGE[IN1]=%d\n",
		 i,imin,imax,I1,I2,L,R,LL,RR,HapSite[i],D1[30],DR1[30],ID1[30],DELTA_RANGE[IN1]);
	  for(int t = 0; t < D1[30]; t++){
	    printf("  delta1[30][%d] = %0.6f\n", t, delta1[30][t]);
	    fflush(stdout);
	    if(DEBUG && t < DR1[30] && t >= DELTA_RANGE[IN1]) assert(delta1[30][t] < 0.0);
	  }
	  fflush(stdout);
	}

	if(!HINDELITER(iter)){   /* check adding/deleting sites at Hcuts[i] */

	  if(skip[i]){// skip sites in frozen region
            if(SNP_TRACE && iter==ITER_ID){
              printf("iter=%d:i=%d:Hcuts[i]= %0.3f, HapSite[i]= %d, skip[i]= %d\n",iter,i,Hcuts[i],HapSite[i],skip[i]);
              fflush(stdout);
	    }
	    goto Lcheckbest;
          }

	  if(SKIPMAP_ADD>=2 && DELTA_STOP >= 2 && iter >= HMIN_ITER){/* skip sites that fall in inactive regions */
	    int IN = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5);/* index into Initial_Delta[] and DELTA_RANGE[] */
	    if(DEBUG/* HERE >=2 */) assert(0 <= IN && IN <= maxIN);
	    if(DELTA_RANGE[IN] <= 0)
	      goto Lcheckbest;
	  }

	  if(HSNP_FAST>=2){  /* use previously computed LP[h=0..3][i] */
	    for(int h = 0; h <= 3; h++)
	      LPsnp[h] = LP[h][i] + LPstart;
	  } else {/* HSNP_FAST < 2 : older slower method : If HSNP_FAST==1 validate new faster method */
	    for(int h = 0; h <= 3; h++){/* compute LPsnp[h] */
	      double origLPsnp = LPstart;
	      int h1 = h & 1;/* If site i is present in HaploType 1 */
	      int h2 = (h >> 1); /* If site i is present in HaploType 2 */

	      if(HapSite[i] == h) {
		LPsnp[h] = LPstart;
	      } else {
		LPsnp[h] = 0.0;

		double LParray[numthreads];
		for(int tid = 0; tid < numthreads; tid++)
		  LParray[tid] = 0.0;

		int LoopCnt = 0;
                #pragma omp parallel num_threads(numthreads) if(!(VERB>=3 && (iter==0 && i==595 && h==1)))
		{
		  int myLoopCnt = 0;
		  int tid = 0;
#ifdef _OPENMP
		  tid = omp_get_thread_num ();
#endif

		  double myLPsnp = 0.0;
		  double oldLPsnp = 0.0;// only used for debugging

                  #pragma omp for schedule(static,1)
		  for(int m = 0; m < MD; m++){
		    if(OMP_DEBUG) myLoopCnt++;

		    if(TBmapWT[m] <= 0.0)
		      continue;

		    if(DEBUG>=2 && addcnt1 > 0 && !(TmaxM[m] <= TminM[m] && TminM[m]==0)) assert(TminM[m] <= TmaxM[m] && TmaxM[m] < addcnt1);// NEW10
		    if(DEBUG>=2 && addcnt2 > 0 && !(TmaxM2[m] <= TminM2[m] && TminM2[m]==0)) assert(TminM2[m] <= TmaxM2[m] && TmaxM2[m] < addcnt2);// NEW10
		    if(DEBUG>=2 && 0 < DminM[m]) assert(DminM[m] <= DmaxM[m] && DmaxM[m] <= N1);// NEW10
		    if(DEBUG>=2 && 0 < DminM2[m]) assert(DminM2[m] <= DmaxM2[m] && DmaxM2[m] <= N2);// NEW10
		    int iL1 = min(((addcnt1 <= 0 || TmaxM[m] <= TminM[m]+1) ? imax : addid1[TminM[m]]), (DminM[m] <= 0/* NEW10 */) ? imax : delid1[DminM[m]]);// NEW3
		    int iR1 = max(((addcnt1 <= 0 || TmaxM[m] <= TminM[m]+1) ? imin : addid1[TmaxM[m]]), (DminM[m] <= 0/* NEW10 */) ? imin : delid1[DmaxM[m]]);// NEW3
		    int iL2 = min(((addcnt2 <= 0 || TmaxM2[m] <= TminM2[m]+1) ? imax : addid2[TminM2[m]]), (DminM2[m] <= 0/* NEW10 */) ? imax : delid2[DminM2[m]]);// NEW3
		    int iR2 = max(((addcnt2 <= 0 || TmaxM2[m] <= TminM2[m]+1) ? imin : addid2[TmaxM2[m]]), (DminM2[m] <= 0/* NEW10 */) ? imin : delid2[DmaxM2[m]]);// NEW3

		    iL1 = max(imin,iL1);
		    iR1 = min(imax,iR1);
		    iL2 = max(imin,iL2);
		    iR2 = min(imax,iR2);
	    
		    if(iL1 > iR1 && iL2 > iR2)// NEW3
		      continue;

		    if(DEBUG/* HERE >=2 */) assert(!(TminM[m]+1 >= TmaxM[m] && DminM[m] > DmaxM[m] && TminM2[m]+1 >= TmaxM2[m] && DminM2[m] > DmaxM2[m]));// NEW3

		    /* first compute LP of map m for HaploType 1 with site i present IFF h1 */
		    double LP1 = startLPA1[m];/* LP value for map m with no change in HaploType 1 */
		    if(Hdel1[i] == h1){/* Allele 1 changed */
		      if(iL1 <= i && i <= iR1)/* NOTE : i values outside this region in Allele 1 are assumed not to be affected by molecule m */
			LP1 = startLPA1[m] - BigPen;/* set defaults so cases not checked by mprobeval() (eg due to skip[i] or masked regions) are handled */
		      if(h1){/* site i needs to be added to HaploType 1 */
			if(DEBUG>=2) assert(addcnt1 > 0);
			if(T1 >= 0 && addid1[T1] == i /* Else : site i was not checked by mprobeval : cannot add site i to HaploType 1 (eg due to nearby site already present within minKBadd) */
			   && TminM[m] <= T1 && T1 <= TmaxM[m])
			  LP1 = newLPa[m][T1];
			if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
			  int t = max(TminM[m],min(TmaxM[m],T1));
			  printf("m=%d/%d:i=%d,Hdel1[i]=%d,Hcuts[i]=%0.4f,T1=%d,TminM[m]=%d,TmaxM[m]=%d,newLPa[m][t=%d]=LP1= %0.8f,addloc1[t]=%0.4f,Hcuts1[i]=%0.4f\n\t (LPsnp[h=%d]=%0.8f), startLPA1[m]=%0.8f,TBmapWT[m]=%0.8f\n",
				 m,MD,i,Hdel1[i],Hcuts[i],T1,TminM[m],TmaxM[m],t,newLPa[m][t],addloc1[t],Hcuts1[i],h,LPsnp[h]+myLPsnp, startLPA1[m], TBmapWT[m]);
			  fflush(stdout);
			}
		      } else {/* site i needs to be deleted from HaploType 1 */
			if(DEBUG && !progress && !(fabs(Hcuts1[i] - Y1[I1]) < 1e-6)){
			  printf("iter=%d,i=%d:h=%d,h1=%d,h2=%d,I1=%d,I2=%d:Hcuts1[i]=%0.6f,Y1[I1]=%0.6f\n",
				 iter,i,h,h1,h2,I1,I2,Hcuts1[i],Y1[I1]);
			  fflush(stdout);
			  assert(fabs(Hcuts1[i] - Y1[I1]) < 1e-6);
			}
			if(DminM[m] <= I1 && I1 <= DmaxM[m])
			  LP1 = newLPd[m][I1];
			if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
			  int t = (I1 < DminM[m]) ? 0 : min(DmaxM[m],I1);
			  printf("m=%d/%d:i=%d,Hdel1[i]=%d,I1=%d,DminM[m]=%d,DmaxM[m]=%d,newLPd[m][t=%d]=LP1= %0.8f(LPsnp[h=%d]=%0.8f),startLPA1[m]=%0.8f\n",m,MD,i,Hdel1[i],I1,DminM[m],DmaxM[m],t,LP1,h,LPsnp[h]+myLPsnp, startLPA1[m]);
			  fflush(stdout);
			}
		      }
		    } else if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
		      printf("m=%d/%d:i=%d,Hdel1[i]=%d,Hcuts[i]=%0.4f: LP1=%0.8f(LPsnp[h=%d]=%0.8f),startLPA1[m]=%0.8f,TBmapWT[m]=%0.6f\n",
			     m,MD,i,Hdel1[i],Hcuts[i],LP1,h,LPsnp[h]+myLPsnp, startLPA1[m],TBmapWT[m]);
		      fflush(stdout);
		    }

		    if(HSNP_FAST && DEBUG && T1 >= 0 && addid1[T1]==i){
		      if(i < iL1 || i > iR1){
			if(DEBUG && !(fabs(LP1 - startLPA1[m]) < 1e-5)){
                          #pragma omp critical
			  {
			    printf("i=%d(imin=%d,imax=%d,n=%d):h=%d,m=%d:TminM[m]=%d,TmaxM[m]=%d,addcnt1=%d,DminM[m]=%d,DmaxM[m]=%d,N1=%d:LP1=%0.8f,startLPA1[m]=%0.8f\n",
				   i,imin,imax,n,h,m,TminM[m],TmaxM[m],addcnt1,DminM[m],DmaxM[m],N1,LP1,startLPA1[m]);
			    printf("\t addid1[TminM[m]]=%d,addid1[TmaxM[m]]=%d,delid1[DminM[m]]=%d,delid1[DmaxM[m]]=%d\n",
				   addid1[TminM[m]],addid1[TmaxM[m]],delid1[DminM[m]],delid1[DmaxM[m]]);
			    printf("\t newLPd[m][0] = %0.8f, newLPa[m][TminM[m]] = %0.8f, newLPd[m][DmaxM[m]]=%0.8f, newLPa[TmaxM[m]] = %0.8f\n",
				   VMEM_MINIMIZE ? newLPd0[m] : newLPd[m][0], newLPa[m][TminM[m]], newLPd[m][DmaxM[m]], newLPa[m][TmaxM[m]]);
			    if(MDEBUG)
			      printf("\t newLPaPr[m][TminM[m]] = %d\n",newLPaPr[m][TminM[m]]);
			    fflush(stdout);
			    assert(fabs(LP1 - startLPA1[m]) < 1e-5);
			  }
			}
		      }
		    }

		    /* next compute LP of map m for HaploType 2 with site i present IFF h2 */
		    double LP2 = startLPA2[m];/* LP value for map m with no change in HaploType 2 */
		    if(Hdel2[i] == h2){
		      if(iL2 <= i && i <= iR2) /* NOTE : i values outside this region in Allele 1 are assumed not to be affected by molecule m */
			LP2 = startLPA2[m] - BigPen;/* set defaults so cases not checked by mprobeval() (eg due to skip[i] or masked regions) are handled */
		      if(h2){/* site i needs to be added to HaploType 2 */
			if(T2 >= 0 && addid2[T2] == i /* Else : site i was not checked by mprobeval : cannot add site i to HaploType 2 (eg due to nearby site already present within minKB) */
			    && TminM2[m] <= T2 && T2 <= TmaxM2[m])
			  LP2 = newLPa2[m][T2];
			if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
			  int t = max(TminM2[m],min(TmaxM2[m],T2));
			  printf("m=%d/%d:i=%d,Hdel2[i]=%d,Hcuts[i]=%0.4f,T2=%d,TminM2[m]=%d,TmaxM2[m]=%d,newLPa2[m][t=%d]=LP2=%0.8f,addloc2[t]=%0.4f,Hcuts2[i]=%0.4f\n\t (LPsnp[%d]=%0.8f), startLPA2[m]=%0.8f\n",m,MD,i,Hdel2[i],Hcuts[i],T2,TminM2[m],TmaxM2[m],t,LP2,addloc2[t],Hcuts2[i],h,LPsnp[h]+myLPsnp, startLPA2[m]);
			  fflush(stdout);
			}
		      } else {/* site i needs to be deleted from HaploType 2 */
			if(DEBUG && !progress) assert(fabs(Hcuts2[i] - Y2[I2]) < 1e-6);
			if(DminM2[m] <= I2 && I2 <= DmaxM2[m])
			  LP2 = newLPd2[m][I2];
			if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
			  int t = (I2 < DminM2[m]) ? 0 : min(DmaxM2[m],I2);
			  printf("m=%d/%d:i=%d,Hdel2[i]=%d,I2=%d,DminM2[m]=%d,DmaxM2[m]=%d,newLPd2[m][t=%d]=LP2=%0.8f(LPsnp[%d]=%0.8f),startLPA2[m]=%0.8f\n",
				 m,MD,i,Hdel2[i],I2,DminM2[m],DmaxM2[m],t,LP2,h,LPsnp[h] + myLPsnp, startLPA2[m]);
			  fflush(stdout);
			}
		      }
		    } else if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
		      printf("m=%d/%d:i=%d,Hdel2[i]=%d,Hcuts[i]=%0.4f: LP2=%0.8f(LPsnp[%d]=%0.8f),startLPA2[m]=%0.8f\n",m,MD,i,Hdel2[i],Hcuts[i],LP2,h,LPsnp[h]+myLPsnp, startLPA2[m]);
		      fflush(stdout);
		    }

		    if(HSNP_FAST && DEBUG && T2 >= 0 && addid2[T2]==i){
		      if(i < iL2 || i > iR2){
			if(DEBUG && !(fabs(LP2 - startLPA2[m]) < 1e-5)){
                          #pragma omp critical
			  {
			    printf("i=%d(imin=%d,imax=%d,n=%d):h=%d,m=%d:TminM2[m]=%d,TmaxM2[m]=%d,addcnt2=%d,DminM2[m]=%d,DmaxM2[m]=%d,N2=%d:LP2=%0.8f,startLPA2[m]=%0.8f\n",
				   i,imin,imax,n,h,m,TminM2[m],TmaxM2[m],addcnt2,DminM2[m],DmaxM2[m],N2,LP2,startLPA2[m]);
			    printf("\t addid2[TminM2[m]]=%d,addid2[TmaxM2[m]]=%d,delid2[DminM2[m]]=%d,delid2[DmaxM2[m]]=%d\n",
				   addid2[TminM2[m]],addid2[TmaxM2[m]],delid2[DminM2[m]],delid2[DmaxM2[m]]);
			    printf("\t newLPd2[m][0] = %0.8f, newLPa2[m][TminM2[m]] = %0.8f, newLPd2[m][DmaxM2[m]]=%0.8f, newLPa2[TmaxM2[m]] = %0.8f\n",
				   VMEM_MINIMIZE ? newLPd20[m] : newLPd2[m][0], newLPa2[m][TminM2[m]], newLPd2[m][DmaxM2[m]], newLPa2[m][TmaxM2[m]]);
			    if(MDEBUG)
			      printf("\t newLPaPr2[m][TminM2[m]] = %d\n",newLPaPr2[m][TminM2[m]]);
			    fflush(stdout);
			    assert(fabs(LP2 - startLPA2[m]) < 1e-5);
			  }
			}
		      }
		    }

		    double LP = HapLP(LP1,LP2,logH);

		    myLPsnp += LP * TBmapWT[m];

		    if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
		      double oLP = HapLP(startLPA1[m],startLPA2[m],logH);
		      oldLPsnp += oLP * TBmapWT[m];
		      printf("m=%d/%d:iter=%d,i=%d,h=%d:LP1=%0.8f,LP2=%0.8f,TBmapWT=%0.6f,LP=%0.8f,LPsnp[h]= %0.6f (orig:LP1=%0.8f,LP2=%0.8f,LP=%0.8f,sum=%0.8f:change=%0.8f,cumchange=%0.8f),bestLPA:LP1=%0.8f,LP2=%0.8f\n",
			     m,MD,iter,i,h,LP1,LP2,TBmapWT[m], LP, myLPsnp, startLPA1[m], startLPA2[m], oLP, oldLPsnp, LP-oLP, myLPsnp - oldLPsnp, bestLPA1[m],bestLPA2[m]);
		      fflush(stdout);
		    }
		  } /* m = 0 .. MD-1 */
		  if(OMP_DEBUG && myLoopCnt > 0){
                    #pragma omp critical
		    {
		      LoopCnt += myLoopCnt;
		    }
		  }
	    
		  LParray[tid] = myLPsnp;
		} // omp parallel
		if(OMP_DEBUG) assert(LoopCnt == MD);

		qsort(LParray, numthreads, sizeof(double), (intcmp *)doubleInc);  
		for(int tid = 0; tid < numthreads; tid++)
		  LPsnp[h] += LParray[tid];

		origLPsnp = LPsnp[h];
		LPsnp[h] -= 0.5*(startN1 + startN2)*SITE_PEN;/* original total site penalty */
		LPsnp[h] += logHapSitePvalue * startSNPcnt + logHapIndelPvalue * startIndelCnt;/* original haplotype penalty */

		LPsnp[h] -= 0.5*(h1+h2)*SITE_PEN;/* add new site penalty for site i */
		LPsnp[h] += 0.5*((HapSite[i]&1) + (HapSite[i]>>1))*SITE_PEN;/* subtract original site penalty for site i */

		if(HapSite[i]==1 || HapSite[i]==2)
		  LPsnp[h] -= logHapSitePvalue;/* remove haplotype penalty for original SNP at site i */
		if(h==1 || h==2)
		  LPsnp[h] += logHapSitePvalue;/* add haplotype penalty for new SNP at site i */

		if(HINDEL_SPLIT_FIX==0 && HapDelta[L] && HapSite[i] <= 2 && h >= 3){/* check if Indel was split by new label at Hcuts[i] */
		  if(DEBUG) assert(h > HapSite[i]);
		  if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
		    printf("i=%d,L=%d,h=%d:HapDelta[L]=%0.4e,HapSite[L,i]=%d,%d,LPsnp[h]=%0.6f -> %0.6f\n",
			   i,L,h,HapDelta[L],HapSite[L],HapSite[i],LPsnp[h],LPsnp[h]+logHapIndelPvalue);
		    fflush(stdout);
		  }
		  LPsnp[h] += logHapIndelPvalue;
		}

		if(HINDEL && HapDelta[i] && HapDelta[L] && h <= 2 && HapSite[i] >= 3){/* check if Indel needs to be merged with previous Indel */
		  if(DEBUG) assert(h < HapSite[i]);
		  if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
		    printf("i=%d,L=%d,h=%d:HapDelta[L,i]=%0.4e,%0.4e,HapSite[L,i]=%d,%d,LPsnp[h]=%0.6f -> %0.6f\n",
			   i,L,h,HapDelta[L],HapDelta[i],HapSite[L],HapSite[i],LPsnp[h],LPsnp[h]-logHapIndelPvalue);
		    fflush(stdout);
		  }
		  LPsnp[h] -= logHapIndelPvalue;
		  if(fabs(HapDeltaMerged[L]+HapDeltaMerged[i]) < MIN_INDEL_SIZE){/* both Indels cancel out */
		    if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
		      printf("i=%d,L=%d,h=%d:HapDelta[L,i]=%0.4e,%0.4e(tot=%0.4e),HapSite[L,i]=%d,%d,LPsnp[h]=%0.6f -> %0.6f\n",
			     i,L,h,HapDelta[L],HapDelta[i],HapDeltaMerged[L]+HapDeltaMerged[i],HapSite[L],HapSite[i],LPsnp[h],LPsnp[h]-logHapIndelPvalue);
		      fflush(stdout);
		    }
		    LPsnp[h] -= logHapIndelPvalue;
		  }
		}

		if(L==0 && h==0 && HapDelta[i] && HapSite[i]){/* cannot remove HapSite[i] without removing HapDelta[i] since HapDelta[0] is not supported */
		  if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
		    printf("i=%d,L=%d:HapDelta[i]=%0.4e(tot=%0.4e),Delta[i]=%0.4e,HapSite[i]=%d,LP[0][i]=%0.6f -> %0.6e (HapDelta[0] not supported)\n",
			   i,L,HapDelta[i],HapDeltaMerged[i],Delta[i],HapSite[i],LPsnp[0], LPsnp[0]-BigPen);
		    fflush(stdout);
		  }

		  LPsnp[h] -= BigPen;
		}
	      } // HapSite[i] != h

	      if(SNP_TRACE && iter==ITER_ID && i==SITE_ID && h==SNP_ID){
		int newN1 = startN1 + h1 - (HapSite[i]&1);
		int newN2 = startN2 + h2 - (HapSite[i]>>1);
		int newSNPcnt = startSNPcnt + ((h==1||h==2)?1:0) - ((HapSite[i]==1 || HapSite[i]==2)?1:0); 
		printf("i=%d:N1=%d->%d,N2=%d->%d,SNPcnt=%d->%d,IndelCnt=%d,h1=%d,h2=%d,HapSite[i]=%d,SITE_PEN=%0.6f,logHapSitePV=%0.6f,logHapIndelPV=%0.6f:Final LPsnp[h]=%0.6f->%0.6f\n",
		       i,startN1,newN1,startN2,newN2,startSNPcnt,newSNPcnt,startIndelCnt,h1,h2,HapSite[i], SITE_PEN, logHapSitePvalue, logHapIndelPvalue,origLPsnp, LPsnp[h]);
		printf("\t L=%d:HapSite[L]=%d,HapDelta[i]=%0.3f,Delta[i]=%0.3f,HapDelta[L]=%0.3f,Delta[L]=%0.3f\n",L,HapSite[L],HapDelta[i],Delta[i],HapDelta[L],Delta[L]);
		
		if(h==3){
		  printf("\tHcuts[i]=%0.3f+%0.3f,Hcuts[L=%d]=%0.3f,Hcuts[R=%d]=%0.3f,HapSite[L]=%d,HapSite[R]=%d\n",Hcuts[i],DelCum[i],L,Hcuts[L],R,Hcuts[R],HapSite[L],HapSite[R]);
		  printf("\tI1=%d,N1=%d,Y1[I1]=%0.3f,Y1[N1]=%0.3f,I2=%d,N2=%d,Y2[I2]=%0.3f,Y2[N2]=%0.3f\n",I1,N1,Y1[I1],Y1[N1],I2,N2,Y2[I2],Y2[N2]);
		  printf("\tT1=%d,addid1[T1]=%d,T2=%d,addid2[T2]=%d\n",T1,addid1[T1],T2,addid2[T2]);
		}
		fflush(stdout);
	      }
	      if(HSNP_FAST && DEBUG 
		 && (!(fabs(LPsnp[h] - (LP[h][i] + LPstart)) < (h==HapSite[i] ? 1e-8 : max(1e-5, LPstart * 1e-9))) || (VERB>=3 && (i==33351 && h==0))) &&
		 (((!(h1 && Hdel1[i]) || (T1 >= 0 && addid1[T1]==i)) && (!(h2 && Hdel2[i]) || (T2 >= 0 && addid2[T2]==i))) || !(LPsnp[h] < LPstart && LP[h][i] < 0.0) )){
		printf("iter=%d:i=%d(imin=%d,imax=%d,n=%d),h=%d:HapSite[i]=%d,LPsnp[h]=%0.8f,LP[h][i]=%0.8f,LPstart=%0.8f(err=%0.8f), addid1[T1=%d]=%d,addid1[T1+1]=%d,addid2[T2=%d]=%d,addid2[T2+1]=%d,delid1[I1=%d]=%d,delid2[I2=%d]=%d,Hcuts[i]=%0.3f\n",
		       iter,i,imin,imax,n,h,HapSite[i],LPsnp[h],LP[h][i],LPstart,fabs(LPsnp[h]-(LP[h][i]+LPstart)),T1,addid1[T1],addid1[min(addcnt1-1,T1+1)],T2,addid2[T2],addid2[min(addcnt2-1,T2+1)],I1,delid1[I1],I2,delid2[I2],Hcuts[i]);
		fflush(stdout);
		if(DEBUG){
		  if((!(h1 && Hdel1[i]) || (T1 >= 0 && addid1[T1]==i)) && (!(h2 && Hdel2[i]) || (T2 >= 0 && addid2[T2]==i)))
		    assert(fabs(LPsnp[h]-(LP[h][i]+LPstart)) < (h==HapSite[i] ? 1e-8 : max(1e-5, LPstart * 1e-9)));
		  else
		    assert(LPsnp[h] < LPstart && LP[h][i] < 0.0);
		}
	      }
	      LPsnp[h] = LP[h][i] + LPstart;
	    }/* h = 0..3 */
	  } /* HSNP_FAST < 2 */
 
	  /* compute Pvalue of best HaploType hypothesis (1 or 2) vs best non-HaploType hypothesis (0 or 3) : do this before suppressing sites due to minKB, Filtered=1 or Deresed=1 */
	  HapSiteScore[i] = max(LPsnp[1],LPsnp[2]) - max(LPsnp[0],LPsnp[3]);
	  SiteScore[i] = LPsnp[3] - LPsnp[0];

	  if((SNP_TRACE && iter == ITER_ID && (SITE_ID < 0 || i == SITE_ID)) || (SNPverbose  && ((1 <= HapSite[i] && HapSite[i] <= 2) /* || (iter==0 && (1854 <= i && i <= 1947))*/ /* || HapSiteScore[i] > 0.0*/))){
	    if(HSNP_FAST>=2)
	      printf("iter=%d,i=%d,L=%d,R=%d,ibest=%d:Hcuts[i]=%0.3f,%0.3f,HapSite[i]=%d,HapDelta[i]=%0.3f,Delta[i]=%0.3f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f:\n\t LPsnp[0,1,2,3]=%0.6f,%0.6f,%0.6f,%0.6f(%0.6f,%0.6f,%0.6f,%0.6f)\n",
		     iter,i,L,R,ibest,Hcuts[i],Hcuts[i]+DelCum[i],HapSite[i],HapDelta[i],Delta[i],HapSiteScore[i],SiteScore[i],LPsnp[0],LPsnp[1],LPsnp[2],LPsnp[3],LP[0][i],LP[1][i],LP[2][i],LP[3][i]);
	    else
	      printf("iter=%d,i=%d,L=%d,R=%d,ibest=%d:Hcuts[i]=%0.3f,%0.3f,HapSite[i]=%d,HapDelta[i]=%0.3f,Delta[i]=%0.3f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f:\n\t LPsnp[0,1,2,3]=%0.6f,%0.6f,%0.6f,%0.6f\n",
		     iter,i,L,R,ibest,Hcuts[i],Hcuts[i]+DelCum[i],HapSite[i],HapDelta[i],Delta[i],HapSiteScore[i],SiteScore[i],LPsnp[0],LPsnp[1],LPsnp[2],LPsnp[3]);
	    fflush(stdout);
	  }

	  // NOTE : most label OR SNP additions within minKBadd of another label have already been suppressed if HapSite[i]==0 : However if labels were added this iteration, we may need to recheck
	  if(minKBadd > 0.0 && !(HapSite[i]==1 || HapSite[i]==2)){	    /* suppress adding new SNPs very near another site */
	    /* check each Allele seperately so nearby opposite phase SNPs are NOT blocked */
	    /* NOTE : this is tricky to get right without unnecessarily blocking sites from being added, so just rely on later merging of nearby sites with REMOVE_CLOSE_SITES
	       However this risks creating spurious SNPs that block nearby actual SNPs due to phasing incompatibility. Possible solution : see SNP_DELAY below */
	  }

	  if(SNP_DELAY && iter < SNP_ITER && (HapSiteResA/*NEW97*/ ? !HapSite[i] : !(HapSite[i]==1 || HapSite[i]==2))){
	    if(Hcuts[i]-Hcuts[L] < SNP_DELTA_KB){
	      if(SNP_DELAY>=2)
		LPsnp[1] = LPsnp[2] = LPstart - BigPen;
	      else {
		if(HapSite[L] & 1){
		  LPsnp[1] = LPstart - BigPen;
		}
		if(HapSite[L] & 2)
		  LPsnp[2] = LPstart - BigPen;
	      }
	    }
	    if (Hcuts[R]-Hcuts[i] < SNP_DELTA_KB){
	      if(SNP_DELAY>=2)
		LPsnp[1] = LPsnp[2] = LPstart - BigPen;
	      else {
		if(HapSite[R] & 1)
		  LPsnp[1] = LPstart - BigPen;
		if(HapSite[R] & 2)
		  LPsnp[2] = LPstart - BigPen;
	      }
	    }
	  }

	  if(Filtered && (HapSite[i]==0 || HapSite[i]==3)) /* suppress adding new HapSite (1 or 2), but OK to change to 0 (or 3 if !Deresed) */
	    for(int h = 1; h <= 2; h++)
	      LPsnp[h] = LPstart - BigPen;
	  if(Filtered && !(HapSite[i] & 1) &&  (Hcuts1[i] < HtrimL1 || Hcuts1[i] > Hcuts1[n+1] - HtrimR1)){/* suppress adding label to Allele1 in trimmed region */
	    LPsnp[1] = LPstart - BigPen;
	    LPsnp[3] = LPstart - BigPen;
	  }	    
	  if(Filtered && !(HapSite[i] & 2) && (Hcuts2[i] < HtrimL2 || Hcuts2[i] > Hcuts2[n+1] - HtrimR2)){/* suppress adding label to Allele2 in trimmed region */
	    LPsnp[2] = LPstart - BigPen;
	    LPsnp[3] = LPstart - BigPen;
	  }	    
	  if(Deresed /* WAS && HapSite[i] */)/* suppress any change other than changing to 0 */
	    for(int h = 1; h <= 3; h++)
	      if(h != HapSite[i])
		LPsnp[h] = LPstart - BigPen;

	  if(SNP_TRACE && iter == ITER_ID /* && (SITE_ID < 0 || i == SITE_ID) */ /* && (1854 <= i && i <= 1947) */ /* && HapSite[i]==3 && i <= 1000 */){
	    printf("i=%d:Hcuts[i]=%0.3f,%0.3f,HapSite[i]=%d,HapDelta[i]=%0.3f,Delta[i]=%0.3f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f,LPsnp[]=%0.3f,%0.3f,%0.3f,%0.3f:iter=%d (ibest=%d,tbest=%d,LPbest=%0.6f)\n",
		   i,Hcuts[i],Hcuts[i]+DelCum[i],HapSite[i],HapDelta[i],Delta[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i],LPsnp[0],LPsnp[1],LPsnp[2],LPsnp[3],iter,ibest,tbest,LPbest);
	    fflush(stdout);
	  }

	  if(DEBUG && !(fabs(LPsnp[HapSite[i]] - LPstart) < 1e-8)){
	    printf("i=%d:HapSite[i]=%d,LPsnp[HapSite[i]]= %0.8f, LPstart=%0.8f\n",i,HapSite[i],LPsnp[HapSite[i]], LPstart);
	    fflush(stdout);
	    assert(fabs(LPsnp[HapSite[i]] - LPstart) < 1e-8);
	  }

	  /* locate best LPsnp[h=0..3] and see if best h is different from HapSite[i] */
	  int maxh = HapSite[i];
	  if(DEBUG) assert(startN1 >= 1 && startN2 >= 1);
	  for(int h = 0; h <= 3; h++){
	    int newN1 = startN1 + (h & 1) - (HapSite[i] & 1);
	    int newN2 = startN2 + (h >> 1) - (HapSite[i] >> 1);
	    if(newN1 <= 0 || newN2 <= 0)
	      continue;/* make sure at least one label remains in each Allele */
	    if(LPsnp[h] > LPsnp[maxh])
	      maxh = h;
	  }
	  LPsite[i] = LPsnp[maxh];
	  nHapSite[i] = maxh;
	  if(SNP_TRACE && iter == ITER_ID /* && i == SITE_ID */ /* && (149836 <= i && i <= 150082) */ /*  && (maxh >= 1 && maxh <= 2) && iter==0 */){
	    printf("HapSite[i=%d]=%d:I1=%d,I2=%d,Hcuts1[i]=%0.4f(%0.4f),Hcuts2[i]=%0.4f(%0.4f), Hcuts[i]=%0.4f(%0.4f), LP=%0.6f, LPsnp[0..3]=%0.6f %0.6f %0.6f %0.6f, maxh=%d, ibest=%d(type=%d), progress=%d(%d,%d), changes=%d, iter=%d,skip[i]=%d,RR=%d,RRbest=%d\n", 
		   i,HapSite[i], I1, I2, startHcuts1[i], Hcuts[i]+DelCum[i]+HapDelCum[i],startHcuts2[i],Hcuts[i]+DelCum[i]-HapDelCum[i], 
		  Hcuts[i], Hcuts[i]+DelCum[i], LPsnp[0], LPstart, LPsnp[1], LPsnp[2], LPsnp[3], maxh, ibest, tbest, progress, hapdeltacnt, deltacnt, changecnt, iter,skip[i],RR,RRbest);
	    fflush(stdout);
	  }

	  /* update LPbest, ibest, tbest */
	  if(LPsite[i] > LPstart + HLP_MINDELTA){
	    if(DELTA_STOP){/* mark current interval(s) as active for HapIndel changes */
	      if(DEBUG) assert(0 <= I1 && I1 <= startN1);
	      if(DEBUG) assert(0 <= I2 && I2 <= startN2);
	      IN1 = ID1[I1];
	      IN2 = ID2[I2];
	      if(DEBUG) assert(0 <= IN1 && IN1 <= maxIN);
	      if(DEBUG) assert(0 <= IN2 && IN2 <= maxIN);

	      int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

	      int Tmin = max(0, min(IN1,IN2)-DELTA_SCAN);
	      int Tmax = min(maxIN, max(IN1,IN2) + DELTA_SCAN);
	      if(Tmax > Tmin + 100){
		printf("WARNING: single HapSite[%d]=%d -> %d (LP= %0.6f -> %0.6f) activating %d intervals (%d .. %d) out of %d:I1=%d,I2=%d,N1=%d,N2=%d,IN1=%d,IN2=%d\n", 
		       i,HapSite[i],maxh,LPstart,LPsite[i],Tmax-Tmin+1,Tmin,Tmax,maxIN+1,I1,I2,N1,N2,IN1,IN2);
		fflush(stdout);
	      }

	      for(int T = Tmin; T <= Tmax; T++){
		if(DELTA_RANGE[T] <= 0){
		  activecnt++;
		  DELTA_RANGE[T] = min_DELTA;
		  for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
		    Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
		  if(HAPSTOP_DEBUG || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		    printf("Re-Activating region T=%d (%0.3f..%0.3f,IN1=%d,IN2=%d,I1=%d,I2=%d) with IDelta[%d]=%0.3f..%0.3f:HapSite[i=%d]=%d -> %d: LP=%0.8f -> %0.8f Hcuts[i]=%0.3f(%0.3f),Y1[I1..I1+1]=%0.3f..%0.3f,Y2[I2..I2+1]=%0.3f..%0.3f\n",
		  T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL,IN1,IN2,I1,I2,DELTA_RANGE[T],Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],i,HapSite[i],maxh, LPstart, LPsite[i],Hcuts[i],Hcuts[i]+DelCum[i],startY1[I1],startY1[I1+1],startY2[I2],startY2[I2+1]);
		    fflush(stdout);
		  }
	        } else if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		  printf("Region T=%d (%0.3f..%0.3f,IN1=%d,IN2=%d,I1=%d,I2=%d) already active with IDelta[%d]=%0.3f .. %0.3f:HapSite[i=%d]=%d -> %d:Hcuts[i]=%0.3f(%0.3f),Y1[I1..I1+1]=%0.3f..%0.3f,Y2[I2..I2+1]=%0.3f..%0.3f\n",
		    T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,IN2,I1,I2,DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],
		    i,HapSite[i],maxh,Hcuts[i],Hcuts[i]+DelCum[i],startY1[I1],startY1[I1+1],startY2[I2],startY2[I2+1]);
		  fflush(stdout);
		}
	      }
	    }

	    if(SNP_TRACE && iter == ITER_ID && HapSite[i] > 0){
	      printf("HapSite[i=%d]=%d -> %d: LP=%0.8f -> %0.8f Hcuts1[i]=%0.3f(%0.3f),Hcuts2=%0.3f(%0.3f), Hcuts[i]=%0.3f(%0.3f), LPsnp[0..3]=%0.6f %0.6f %0.6f %0.6f),ibest=%d(type=%d,LP=%0.6f), progress=%d(%d,%d), changes=%d, iter=%d\n", 
		     i, HapSite[i], maxh, LPstart, LPsnp[maxh], startHcuts1[i], Hcuts[i]+DelCum[i]+HapDelCum[i], startHcuts2[i], Hcuts[i]+DelCum[i]-HapDelCum[i],
		     Hcuts[i], Hcuts[i]+DelCum[i], LPsnp[0], LPsnp[1], LPsnp[2], LPsnp[3],ibest,tbest, LPbest, progress, hapsitecnt, hapdeltacnt, changecnt, iter);
	      fflush(stdout);
	    }

	    if(DEBUG) assert(maxh != HapSite[i]);
	    if(DEBUG && ibest > 0) assert(tbest == 0);// since we only check one SNPs if we are here 

	    if((LPsite[i] > LPbest + 2e-9 ||
		(LEFTEXT_FIX /* && LPsite[i] > LPstart + HLP_MINDELTA */ && i < ileft && ibest > 0 && Hcuts[i] - Hcuts[ibest] >= HSCANRANGE*Xlambda))
	       /* && !(SNP_TRACE && iter==ITER_ID && i <= 200)*/){
	      if(DEBUG) assert(!skip[i]);
	      ibest = i;
	      Lbest = L;
	      Rbest = R;
	      LLbest = LL;
	      RRbest = RR;
	      tbest = 0;
	      LPbest = LPsite[i];
	    }
	  }
	  goto Lcheckbest;
	}// try adding/deleting SNP at site i

	/* compute current sizes of Hcuts1[] and Hcuts2[] intervals that include changes from the current iteration so far : This may differ from what existed when mprobeval() was called */
	range1 = (1 <= I1 && I1 < startN1) ? (Y1[I1+1] - Y1[I1]) : Hcuts[R] - Hcuts[i] + HapDelta[i] + Delta[i];
	range2 = (1 <= I2 && I2 < startN2) ? (Y2[I2+1] - Y2[I2]) : Hcuts[R] - Hcuts[i] - HapDelta[i] + Delta[i];

	if(VERB>=2 && iter==11 && i==3617){
	  printf("I1=%d,I2=%d:i=%d,R=%d:range1=%0.4f,range2=%0.4f\n",I1,I2,i,R,range1,range2);
	  fflush(stdout);
	}

	if(HINDEL_FAST && HINDELITER(iter) && HapSite[i] && R <= n){

	  if(DEBUG) assert(0 <= I1 && I1 <= startN1);
	  if(DEBUG) assert(0 <= I2 && I2 <= startN2);
	  IN1 = ID1[I1];
	  IN2 = ID2[I2];
	  if(DEBUG) assert(0 <= IN1 && IN1 <= maxIN);
	  if(DEBUG) assert(0 <= IN2 && IN2 <= maxIN);

	  /* precompute LPdd[d1][d2] for list of (d1,d2) pairs that will be needed  by both HINDEL and HSIZES.
	     Speedup can be obtained by only computing the change in LP for molecules m with (AminM[m] <= I1 && I1 <= AmaxM[m]) || (AminM2[m] <= I2 && I2 <= AmaxM2[m]) */

	  /* (re)allocate LPdd[d1][d2] and LPddT[tid][d1][d2] */
	  size_t memcnt = 0, tmemcnt = 0;
	  for(int d1 = -1; d1 < D1[I1]; d1++){
	    LPdd[d1] = &LPddmem[1 + memcnt];
	    memcnt += 1 + D2[I2];
	  }
	  if(DEBUG) assert(memcnt <= tmemcnt + threadsize);
	  memcnt = tmemcnt += threadsize;
	  if(!HAPSTOP_FIX || D1[I1] > 0 || D2[I2] > 0){
	    for(int tid = 0; tid < numthreads; tid++){
	      for(int d1 = -1; d1 < D1[I1]; d1++){
		LPddT[tid][d1] = &LPddmem[1 + memcnt];
		memcnt += 1 + D2[I2];
	      }
	      assert(memcnt <= tmemcnt + threadsize);
	      memcnt = tmemcnt += threadsize;
	    }
	  }
	  if(DEBUG) assert(tmemcnt <= (numthreads+1) * threadsize);

	  if(DEBUG>=2)
	    for(int d1 = -1; d1 < D1[I1]; d1++)
	      for(int d2 = -1; d2 < D2[I2]; d2++)
		LPdd[d1][d2] = aNaN;

	  /* initialize d1List[0..ddcnt-1],d2List[0..ddcnt-1] */
	  // HERE HERE HERE : add handling of cases with d1 == -1 or d2 == -1 (meaning no change in delta1 or delta2)
	  int ddcnt = 0;
	  if(DR1[I1] > 0 && DR2[I2] > 0){
	    for(int d1 = 0; d1 < DR1[I1]; d1++){
	      int d2 = min(d1,DR2[I2]-1);
	      while(d2 < DR2[I2]-1 && delta1[I1][d1] - delta2[I2][d2] >= MIN_INDEL_SIZE)
		d2++;
	      while(d2 > 0 && delta2[I2][d2] - delta1[I1][d1] >= MIN_INDEL_SIZE)
		d2--;
	      if(DEBUG) assert(0 <= d2 && d2 < DR2[I2]);
	      if(fabs(delta1[I1][d1] - delta2[I2][d2]) < MIN_INDEL_SIZE){
		if(range1 + delta1[I1][d1] < minKB)
		  continue;
		d1List[ddcnt] = d1;
		d2List[ddcnt++] = d2;
	      }
	    }
	  }

	  if((HINDEL_UPDATE || HapDelta[i] == 0.0)){
	    if(DEBUG) assert(HINDEL_NONSYMETRIC);// otherwise symmetric case below is more complicated
	    for(int d1 = 0; d1 < D1[I1]; d1++){
	      int d2;
	      if(d1 >= DR1[I1]){/* check for indel reversals and terminate d1 loop */
		if(!(HapDelta[i] && (HINDEL_PHASED == 0.0 || HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)))
		  break;
		/* locate d1 value corresponding to HapDelta[i] == -delta1[I1][d1] */
		while(d1 < D1[I1] && fabs(HapDeltaMerged[i] + delta1[I1][d1]) >= MIN_INDEL_SIZE)
		  d1++;
		if(d1 >= D1[I1])
		  continue;
		d2 = DR2[I2];
		for(; d2 < D2[I2]; d2++)
		  if(fabs(HapDeltaMerged[i] - delta2[I2][d2]) < MIN_INDEL_SIZE)
		    break;
		if(d2 >= D2[I2])
		  continue;
		if(DEBUG) assert(fabs(HapDeltaMerged[i] + delta1[I1][d1]) < MIN_INDEL_SIZE &&
				 fabs(HapDeltaMerged[i] - delta2[I2][d2]) < MIN_INDEL_SIZE);
	      } else if(d1 >= DELTA_RANGE[IN1]){
		d2 = d1 - DELTA_RANGE[IN1];// NOTE : this may not always be the symmetric case, but will be included in HINDEL_NONSYMETRIC branch below
	      } else {
		d2 = d1 + DELTA_RANGE[IN2];// NOTE : this may not always be the symmetric case, but will be included in HINDEL_NONSYMETRIC branch below
	      }

	      if(DEBUG) assert(d2 >= 0);
	      double incDelta = (d2 >= D2[I2]) ? 0.0 : 0.5 * (delta1[I1][d1] + delta2[I2][d2]);
	      double incHapDelta = (d2 >= D2[I2]) ? 0.0 : 0.5 * (delta1[I1][d1] - delta2[I2][d2]);

	      double origHapDelta = HapDeltaMerged[i];
	      if((Filtered /* NEW157 */|| (Deresed && cresHapMaxLPdrop > 0.0)) && d1 < DR1[I1] && fabs(origHapDelta) < MIN_INDEL_SIZE && fabs(origHapDelta + incHapDelta) >= MIN_INDEL_SIZE)
		continue;// Avoid adding new Hap Indel

	      if(d1 >= DR1[I1] || (d2 < DR2[I2] && (d1 < DELTA_RANGE[IN1] || d2 < DELTA_RANGE[IN2]) && fabs(incHapDelta) >= MIN_INDEL_SIZE && 
		  (range1 + incDelta + incHapDelta >= minKB && range2 + incDelta - incHapDelta >= minKB))){
		d1List[ddcnt] = d1;
		d2List[ddcnt++] = d2;
	      }
	      if(HINDEL_NONSYMETRIC && d1 < DR1[I1]){
		int origd2 = d2;
		for(d2 = 0; d2 < DR2[I2]; d2++){
		  incHapDelta = 0.5 * (delta1[I1][d1] - delta2[I2][d2]);
		  if(fabs((RefineFix ? 1.0 : 2.0) * incHapDelta) < MIN_INDEL_SIZE || d2 == origd2)
		    continue;
		  if((Filtered /* NEW157 */|| (Deresed && cresHapMaxLPdrop > 0.0)) && fabs(origHapDelta) < MIN_INDEL_SIZE && fabs(origHapDelta + incHapDelta) >= MIN_INDEL_SIZE)
		    continue;// Avoid adding new Hap Indel
		  incDelta = 0.5 * (delta1[I1][d1] + delta2[I2][d2]);
		  if(range1 + incDelta + incHapDelta < minKB || range2 + incDelta - incHapDelta < minKB)
		    continue;
		  d1List[ddcnt] = d1;
		  d2List[ddcnt++] = d2;
		}
	      }
	    }
	    if(DEBUG) assert(ddcnt <= (2*INITIAL_DELTA_RANGE + MAX_INDEL)*(2*INITIAL_DELTA_RANGE + MAX_INDEL));
	  }/* if(HINDEL) */

	  if(VERB>=3 && iter >= 13 && i == 435){
	    printf("iter=%d:i=%d,ddcnt=%d\n",iter,i,ddcnt);
	    fflush(stdout);
	  }

	  if(!HAPSTOP_FIX || ddcnt > 0){

	    int nthreads = numthreads;
	    if(VERB>=3 && iter>=13 && i==435 && 25 <= D1[I1] && 25 <= D2[I2] && i==945){
	      nthreads = 1;
	      int d1 = 25, d2 = 25;
	      printf("Checking mprobeval() prediction for delta1[I1=%d][d1=%d]= %0.4f, delta2[I2=%d][d2=%d]=%0.4f (DR1[I1]=%d,D1[I1]=%d,DR2[I2]=%d,D2[I2]=%d,Y1[I1,I1+1]=%0.4f,%0.4f,Y2[I2,I2+2]=%0.4f,%0.4f):ddcnt=%d,Hcuts1[i=%d]= %0.3f,Hcuts2[i]=%0.3f,Hcuts[i]= %0.3f\n",
		     I1,d1,delta1[I1][d1], I2,d2,delta2[I2][d2],DR1[I1],D1[I1],DR2[I2],D2[I2],startY1[I1],startY1[I1+1],startY2[I2],startY2[I2+1],ddcnt,i,Hcuts1[i],Hcuts2[i],Hcuts[i]);
	      fflush(stdout);
	    }

	    /* Now precompute LPdd[d1][d2] for all (d1,d2) values in d1List[0..ddcnt-1],d2List[0..ddcnt-1] */
	    for(int d = 0; d < ddcnt; d++){
	      int d1 = d1List[d], d2 = d2List[d];
	      LPdd[d1][d2] = 0.0;
	    }
	  
	    if(MPROBEVAL_LAZYRESTORE >= 2 && blockListLen >= 1000 && blockListSwapped * 100 < blockListLen * LAZYRESTORE_MIN){
	      double wt = wtime();
	      if(wt > lastVmRSS + 1.0){
	        getmem(VmSize,VmRSS,VmSwap);
	        lastVmRSS = wt;
	      }

	      if(VmRSS + VmSwap > MaxMem * (double) (0.01 * VMRSS_MIN)) { 
	        SwappedAllocations_DONTNEED(blockListLen * LAZYRESTORE_MAX / 100);

                #pragma omp flush // make sure the swapout fields have been written out to memory before the next parallel section (to avoid having other threads seeing stale data and doing unnecessary critical sections to verify)
	      }
	    }

	    //	    double cum = 0.0;/* only used for debugging */

	    int block = 1;/* note most molecules m have valid1 == valid2 == false */
	    /* if(nthreads > 1){
	      while(block < 16 && MD > nthreads * block * 8)
		block *= 2;
		}*/

            #pragma omp parallel num_threads(nthreads) if(!(VERB>=3 && iter>= 13 /* && i==3617*/))
	    {
	      int tid = 0;
#ifdef _OPENMP
	      tid = omp_get_thread_num ();
#endif

	      // allocate per-thread memory for vectorized code
	      size_t ddcnt_align = (ddcnt + (VALIGN/sizeof(double)) - 1) & ~((VALIGN/sizeof(double)) - 1);
	      double *rLP = &prLP[ddcnt_align * tid];
	      double *vLP1 = &pvLP1[ddcnt_align * tid];
	      double *vLP2 = &pvLP2[ddcnt_align * tid];

	      for(int d = 0; d < ddcnt; d++)
		LPddT[tid][d1List[d]][d2List[d]] = 0.0;
	  
              #pragma omp for schedule(dynamic,block) 
	      for(int m = 0; m < MD; m++){
		int valid1 = (AminM[m] <= I1 && I1 <= AmaxM[m]);
		int valid2 = (AminM2[m] <= I2 && I2 <= AmaxM2[m]);
		if(!valid1 && !valid2)
		  continue;

		if(MPROBEVAL_LAZYRESTORE){
	          CdoubleBlock *p;

	          if(valid1 && (p = pBlock1[m])->swapout > 0){
                    #pragma omp critical(blockList)
	            {
	              if(p->swapout > 0){
			int origswapout = p->swapout;
	                int origswapcnt = blockListSwapped;
   	                if(DEBUG>=2) assert(blockListSwapped == SwappedAllocations_swapcnt());

			p->readin();
			blockListSwapped--;

			if((DEBUG && !(0 <= blockListSwapped && p->swapout < 0)) || (DEBUG>=2 && !(blockListSwapped == SwappedAllocations_swapcnt()))){
            	          printf("WARNING:m=%d/%d,swapout=%d->%d,blockListSwapped=%d->%d(correct value=%d),blockListLen=%d,blockListMax=%d\n",m,MD,origswapout,(int)p->swapout,origswapcnt,blockListSwapped,SwappedAllocations_swapcnt(),blockListLen,blockListMax);
			  fflush(stdout);

	                  assert(0 <= blockListSwapped && p->swapout < 0);
			  assert(blockListSwapped == SwappedAllocations_swapcnt());
                        }
	              }
	            }
	          }
	          if(valid2 && (p = pBlock2[m])->swapout > 0){
                    #pragma omp critical(blockList)
	            {
	              if(p->swapout > 0){
			int origswapout = p->swapout;
	                int origswapcnt = blockListSwapped;
	                if(DEBUG>=2) assert(blockListSwapped == SwappedAllocations_swapcnt());

			p->readin();
			blockListSwapped--;

			if((DEBUG && !(0 <= blockListSwapped && p->swapout < 0)) || (DEBUG>=2 && !(blockListSwapped == SwappedAllocations_swapcnt()))){
	                  printf("WARNING:m=%d/%d,swapout=%d->%d,blockListSwapped=%d->%d(correct value=%d),blockListLen=%d,blockListMax=%d\n",m,MD,origswapout,(int)p->swapout,origswapcnt,blockListSwapped,SwappedAllocations_swapcnt(),blockListLen,blockListMax);
			  fflush(stdout);

	                  assert(0 <= blockListSwapped && p->swapout < 0);
			  assert(blockListSwapped == SwappedAllocations_swapcnt());
                        }
	              }
	            }
	          }
	        }

		double origLP = startLP[m];
		int Doffset1 = Dcum[I1] - Dcum[AminM[m]];
		int Doffset2 = Dcum2[I2] - Dcum2[AminM2[m]];

#if 0 // OLD CODE (not vectorized)
		for(int d = 0; d < ddcnt; d++){
		  int d1 = d1List[d];
		  int d2 = d2List[d];
		  double LP1 = valid1 ? newLPdelta[m][Doffset1 + d1] : startLPA1[m];
		  double LP2 = valid2 ? newLPdelta2[m][Doffset2 + d2] : startLPA2[m];
		  double nLP = HapLP(LP1,LP2,logH);

		  LPddT[tid][d1][d2] += (nLP - origLP) * TBmapWT[m];
		  if(VERB>=3 && iter==11 && i==3617 && R==3622 && (d1==121 && d2==97)){
		    double oLP = HapLP(startLPA1[m],startLPA2[m],logH);
                    #pragma omp critical
		    {
		      cum += nLP * TBmapWT[m];
		      printf("m=%d/%d(id=%lld):i=%d,d1=%d,d2=%d:LP1=%0.6f,LP2=%0.6f,nLP=%0.6f,TBmapWT=%0.6f,origLP=%0.6f(change=%0.6f),cum=%0.6f(change=%0.6f) (orig:LP1=%0.6f,LP2=%0.6f,LP=%0.6f:change=%0.6f),valid1=%d,valid2=%d,index1=%d,index2=%d\n",
			       m,MD,gmap[pcontig->contig[m].mapid]->id,i,d1,d2,LP1,LP2,nLP,TBmapWT[m],origLP,nLP-origLP,cum,LPddT[tid][d1][d2],startLPA1[m],startLPA2[m],oLP,nLP-oLP,valid1,valid2,Doffset1+d1,Doffset2+d2); 
		      fflush(stdout);
		    }
		  }
	        }
#else // NEW CODE with vectorized (simd) calls to log() and exp() : requires per thread memory vLP1[],vLP2[],rLP[]
		double wt = TBmapWT[m];
		double *pLPdelta1 = &newLPdelta[m][Doffset1];
		double *pLPdelta2 = &newLPdelta2[m][Doffset2];

		// vectorize the calls to log() and exp() by accumulating vectors of LP1, LP2 and computing vector result rLP == (nLP - origLP) * wt
		if(valid1){
		  if(valid2){// valid1 && valid2

		    for(int d = 0; d < ddcnt; d++){// #pragma no vector // pLPdelta1[] and pLPdelta2[] are unaligned
		      int d1 = d1List[d];
		      int d2 = d2List[d];
		      vLP1[d] = pLPdelta1[d1];
		      vLP2[d] = pLPdelta2[d2];// segfault on this line ?
		    }

                    #pragma omp simd aligned(vLP1,vLP2,rLP : VALIGN)
		    for(int d = 0; d < ddcnt; d++){
		      double LP1 = vLP1[d];
		      double LP2 = vLP2[d];
		      double nLP = HapLP(LP1,LP2,logH);

		      rLP[d] = (nLP - origLP) * wt;
		    }  
		  } else {// valid1 && !valid2
		    double LP2 = startLPA2[m];

		    for(int d = 0; d < ddcnt; d++){
		      int d1 = d1List[d];
		      vLP1[d] = pLPdelta1[d1];
		    }

                    #pragma omp simd aligned(vLP1,rLP : VALIGN)
		    for(int d = 0; d < ddcnt; d++){
		      double LP1 = vLP1[d];
		      double nLP = HapLP(LP1,LP2,logH);

		      rLP[d] = (nLP - origLP) * wt;
		    }
		  }
		} else { // !valid1 && valid2
		  if(DEBUG>=2) assert(valid2);

		  double LP1 = startLPA1[m];

		  for(int d = 0; d < ddcnt; d++){
		    int d2 = d2List[d];
		    vLP2[d] = pLPdelta2[d2];
		  }

                  #pragma omp simd aligned(vLP2,rLP : VALIGN)
		  for(int d = 0; d < ddcnt; d++){
		    double LP2 = vLP2[d];
		    double nLP = HapLP(LP1,LP2,logH);

		    rLP[d] = (nLP - origLP) * wt;
		  }
		}

		for(int d = 0; d < ddcnt; d++){
		  int d1 = d1List[d];
		  int d2 = d2List[d];
		  LPddT[tid][d1][d2] += rLP[d];
		}
#endif // NEW CODE
	      } // omp for
	  
#pragma omp barrier

	      /* add up the results from the different threads */

              #pragma omp for schedule(static,1)
	      for(int d = 0; d < ddcnt; d++){
		int d1 = d1List[d];
		int d2 = d2List[d];
		for(int tid = 0; tid < nthreads; tid++)
		  LPdd[d1][d2] += LPddT[tid][d1][d2];
	      }// omp for
	    }// omp parallel
	  }// if(ddcnt > 0)
	}// if(HINDEL_FAST ...)

	/* next check adding an indel in interval Hcuts[i..i+1] */
	/* only check for indels if left end of interval has a site in at least one of the 2 Alleles */
	if(HINDELITER(iter) && HapSite[i] && R <= n && (HINDEL_UPDATE || HapDelta[i] == 0.0) && D1[I1] > 0){
	  if(DEBUG) assert(0 <= IN1 && IN1 <= maxIN);
	  if(DEBUG) assert(0 <= IN2 && IN2 <= maxIN);

	  //	  double LPd[INITIAL_DELTA_RANGE*2];/* LPd[d1 = 0..D1[I1]-1] */
	  //	  int LPd2[INITIAL_DELTA_RANGE*2];/* LPd2[d1] is the corresponding d2 value with the best score */

	  /* check intervals Y1[I1..I1+1] and Y2[I2..I2+1] for presence of Indel */
	  int d1, d2;/* index into delta1[I1][d1=0..D1[I1]-1] & delta2[I2][d2=0..D2[I2]-1] respectively : 
			used to access indel LP values : (AminM2[m] <= I2 <= AmaxM2[m]) ? newLPdelta2[m][I2,d2] : startLPA2[m] */
	  if(DEBUG) assert(i < R && R <=n && HapSite[R]);
	  if(VERB>=3 && iter>=13 && i == 3617){
	    printf("i=%d,R=%d,DR1[I1=%d]=%d,D1[I1]=%d,DR2[I2=%d]=%d,D2[I2]=%d,HapDelta[i]=%0.4f\n",i,R,I1,DR1[I1],D1[I1],I2,DR2[I2],D2[I2],HapDelta[i]);
	    fflush(stdout);
	  }

	  for(d1 = 0; d1 < D1[I1]; d1++){
	    LPd[d1] = LPstart - BigPen;/* bad value as default for unhandled cases */
	    LPd2[d1] = -1;
	  }

	  for(d1 = 0; d1 < D1[I1]; d1++){
	    if(d1 >= DR1[I1]){/* check for indel reversals and terminate d1 loop */
	      if(!(HapDelta[i] && (HINDEL_PHASED == 0.0 || HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)))
		break;
	      /* locate d1 value corresponding to HapDelta[i] == -delta1[I1][d1] */
	      while(d1 < D1[I1] && fabs(HapDeltaMerged[i] + delta1[I1][d1]) >= MIN_INDEL_SIZE)
		d1++;
	      if(d1 >= D1[I1])	// NOTE : this can also happen if I1 <= 0 or I1 >= N1 (hence no sizing changes considered) because the end label became Heterozygous after the HapDelta next to it was introduced
		continue;
	      for(d2 = DR2[I2]; d2 < D2[I2]; d2++)
		if(fabs(HapDeltaMerged[i] - delta2[I2][d2]) < MIN_INDEL_SIZE)
		  break;
	      if(d2 >= D2[I2])	// NOTE : this can also happen if I2 <= 0 or I2 >= N2 (hence no sizing changes considered) because the end label became Heterozygous after the HapDelta next to it was introduced
		continue;
	      if(DEBUG && !(fabs(HapDeltaMerged[i] + delta1[I1][d1]) < MIN_INDEL_SIZE &&
			    fabs(HapDeltaMerged[i] - delta2[I2][d2]) < MIN_INDEL_SIZE)){
		printf("d1=%d,d2=%d,I1=%d,I2=%d,delta1[I1][d1]=%0.3f,delta2[I2][d2]=%0.3f,D1[I1]=%d,D2[I2]=%d\n",
		       d1,d2,I1,I2,delta1[I1][d1],delta2[I2][d2],D1[I1],D2[I2]);
		fflush(stdout);
		assert(fabs(HapDeltaMerged[i] + delta1[I1][d1]) < MIN_INDEL_SIZE &&
		       fabs(HapDeltaMerged[i] - delta2[I2][d2]) < MIN_INDEL_SIZE);
	      }
	    } else if(d1 >= DELTA_RANGE[IN1]){
	      d2 = d1 - DELTA_RANGE[IN1];// NOTE : this may not always be the symmetric case, but will be included in HINDEL_NONSYMETRIC branch below
	      if(DEBUG && d2 < DR2[I2] && d2 < DELTA_RANGE[IN2] && !(delta1[I1][d1] < 0.0 && delta2[I2][d2] > 0.0)){
		printf("d1=%d,d2=%d,IN1=%d,IN2=%d,DELTA_RANGE[IN1]=%d,DELTA_RANGE[IN2]=%d,I1=%d,I2=%d,DR1[I1]=%d,D1[I1]=%d,DR2[I2]=%d,D2[I2]=%d:delta1[I1][d1]= %0.4f,delta2[I2][d2]=%0.4f\n",
		       d1,d2,IN1,IN2,DELTA_RANGE[IN1],DELTA_RANGE[IN2],I1,I2,DR1[I1],D1[I1],DR2[I2],D2[I2],delta1[I1][d1],delta2[I2][d2]);
		for(int t = 0; t < D1[I1]; t++)
		  printf("delta1[I1][%d]= %0.6f\n",t,delta1[I1][t]);
		for(int t = 0; t < D2[I2]; t++)
		  printf("delta2[I2][%d]= %0.6f\n",t,delta2[I2][t]);
		for(int t = 0; t < DELTA_RANGE[IN1]; t++)
		  printf("Initial_Delta[IN1][%d] = %0.6f\n",t, Initial_Delta[IN1][t]);
		for(int t = 0; t < DELTA_RANGE[IN2]; t++)
		  printf("Initial_Delta[IN2][%d] = %0.6f\n",t, Initial_Delta[IN1][t]);
		printf("localINTIAL_DELTA_RANGE=%d, DELTA_RANGE[IN1]=%d, DELTA_RANGE[IN2]=%d, I1=%d,d1=%d,I2=%d,d2=%d\n",localINITIAL_DELTA_RANGE,DELTA_RANGE[IN1],DELTA_RANGE[IN2],I1,d1,I2,d2);
		fflush(stdout);
		assert(delta1[I1][d1] < 0.0 && delta2[I2][d2] > 0.0);
	      }
	    } else {
	      d2 = d1 + DELTA_RANGE[IN2];// NOTE : this may not always be the symmetric case, but will be included in HINDEL_NONSYMETRIC branch below
	      if(DEBUG && d2 < DR2[I2] && !(delta1[I1][d1] > 0.0 && delta2[I2][d2] < 0.0)){	    
		printf("i=%d:d1=%d,d2=%d,I1=%d,I2=%d,delta1[I1][d1]=%0.3f,delta2[I2][d2]=%0.3f,D1[I1]=%d,D2[I2]=%d,DELTA_RANGE[%d,%d]=%d,%d,R=%d,HapSite[i,R]=%d,%d\n",
		       i,d1,d2,I1,I2,delta1[I1][d1],delta2[I2][d2],D1[I1],D2[I2],IN1,IN2,DELTA_RANGE[IN1],DELTA_RANGE[IN2],R,HapSite[i],HapSite[R]);
		for(int d = 0; d < D1[I1]; d++)
		  printf("delta1[I1][%d]=%0.3f\n",d,delta1[I1][d]);
		for(int d = 0; d < D2[I2]; d++)
		  printf("delta2[I2][%d]=%0.3f\n",d,delta2[I2][d]);
		for(int t = i; t < R; t++)
		  if(HapDelta[t] || Delta[t])
		    printf("HapDelta[%d]=%0.3f,Delta[%d]=%0.3f\n",t,HapDelta[t],t,Delta[t]);
		fflush(stdout);
		assert(delta1[I1][d1] > 0.0 && delta2[I2][d2] < 0.0);	    
	      }
	    }

	    double LParray[numthreads];

	    if(DEBUG) assert(d2 >= 0);
	    double incDelta = (d2 >= D2[I2]) ? 0.0 : 0.5 * (delta1[I1][d1] + delta2[I2][d2]);
	    double incHapDelta = (d2 >= D2[I2]) ? 0.0 : 0.5 * (delta1[I1][d1] - delta2[I2][d2]);
	    double origHapDelta = HapDeltaMerged[i];
	    if((Filtered /* NEW157 */|| (Deresed && cresHapMaxLPdrop > 0.0)) && d1 < DR1[I1] && fabs(origHapDelta) < MIN_INDEL_SIZE && fabs(origHapDelta + incHapDelta) >= MIN_INDEL_SIZE)
	      continue;// Avoid adding new Hap Indel

	    if((LL <= 0 || RR > n) && Hcuts[R] - Hcuts[i] + Delta[i] + incDelta - fabs(HapDelta[i]+incHapDelta) < minKB)
	      continue;

	    if(d1 >= DR1[I1] || (d2 < DR2[I2] && (d1 < DELTA_RANGE[IN1] || d2 < DELTA_RANGE[IN2]) && fabs(incHapDelta) >= MIN_INDEL_SIZE && 
		  !(range1 + delta1[I1][d1] < minKB || range2 + delta2[I2][d2] < minKB))){
	      if(HINDEL_FAST>=2){
		if(DEBUG>=2) assert(isfinite(LPdd[d1][d2]));
		LPd[d1] = rawLPstart + LPdd[d1][d2];
	      } else {
		for(int tid = 0; tid < numthreads; tid++)
		  LParray[tid] = 0.0;

		int ID1 = Dcum[I1]+d1;
		int ID2 = Dcum2[I2]+d2;

		int LoopCnt = 0;

                #pragma omp parallel num_threads(numthreads) // if(!(VERB>=3 && iter==27 && i==736 && d1==16 && d2==4))
		{
		  int myLoopCnt = 0;
		  int tid = 0;
#ifdef _OPENMP
		  tid = omp_get_thread_num ();
#endif

		  double myLPd = 0.0;
		  double oldLPd = 0.0;/* only used for debugging */

                  #pragma omp for schedule(static,1)
		  for(int m = 0; m < MD; m++){
		    if(OMP_DEBUG) myLoopCnt++;

		    /* compute LP of map m for HaploType 1 with Y1[I1..I1+1] increased by delta1[I1][d1] */
		    double LP1 = (AminM[m] <= I1 && I1 <= AmaxM[m]) ? newLPdelta[m][ID1 - Dcum[AminM[m]]] : startLPA1[m];
	    
		    /* compute LP of map m for HaploType 2 with Y2[I2..I2+1] increased by delta2[I2][d2] == -delta1[I1][d1] */
		    double LP2 = (AminM2[m] <= I2 && I2 <= AmaxM2[m]) ? newLPdelta2[m][ID2 - Dcum2[AminM2[m]]] : startLPA2[m];

		    double nLP = HapLP(LP1,LP2,logH);

		    myLPd += nLP * TBmapWT[m];

		    if(VERB>=3 && iter==27 && i==736 && d1==16 && d2==4){
		      double oLP = HapLP(startLPA1[m],startLPA2[m],logH);
		      oldLPd += oLP * TBmapWT[m];
		      printf("m=%d/%d:i=%d,d1=%d,d2=%d:LP1=%0.6f,LP2=%0.6f,TBmapWT=%0.6f,nLP=%0.6f,wsum=%0.6f (orig:LP1=%0.6f,LP2=%0.6f,LP=%0.6f,wsum=%0.8f:change=%0.6f,cumchange=%0.6f)\n",
			     m,MD,i,d1,d2,LP1,LP2,TBmapWT[m],nLP,myLPd,startLPA1[m],startLPA2[m],oLP,oldLPd,nLP-oLP, myLPd - oldLPd);
		      fflush(stdout);
		    }
		  } /* m = 0..MD-1 */
	    
		  LParray[tid] += myLPd;
		  if(OMP_DEBUG && myLoopCnt > 0){
		    #pragma omp critical
		    {
		      LoopCnt += myLoopCnt;
		    }
		  }
		} // omp parallel
		if(OMP_DEBUG) assert(LoopCnt == MD);

		qsort(LParray, numthreads, sizeof(double), (intcmp *)doubleInc);  
		LPd[d1] = 0.0;
		for(int tid = 0; tid < numthreads; tid++)
		  LPd[d1] += LParray[tid];
	      
		if(HINDEL_FAST && !(fabs(LPd[d1] - (rawLPstart + LPdd[d1][d2])) < 1e-6)){
		  printf("i=%d:d1=%d,d2=%d:HapDelta[i]=%0.3f->%0.3f,Delta[i]=%0.3f,Hcuts[i]=%0.3f:LPd[d1]=%0.6f,rLPstart+LPdd[d1][d2]=%0.6f(err=%0.6f,LPdd[d1][d2]=%0.6f,rLPstart=%0.6f)\n",
			 i,d1,d2,HapDelta[i],HapDelta[i]+delta1[I1][d1],Delta[i],Hcuts[i],LPd[d1],rawLPstart+LPdd[d1][d2],LPstart+LPdd[d1][d2]-LPd[d1],LPdd[d1][d2],rawLPstart);
		  fflush(stdout);
		  assert(fabs(LPd[d1] - (rawLPstart + LPdd[d1][d2])) < 1e-6);
		}
	      }/* HINDEL_FAST <=1 */

	      LPd[d1] -= 0.5*(startN1+startN2)*SITE_PEN;
	      LPd[d1] += logHapSitePvalue * startSNPcnt + logHapIndelPvalue * startIndelCnt;
	      LPd[d1] += logHapIndelPvalue * ((fabs(HapDeltaMerged[i] + incHapDelta) >= MIN_INDEL_SIZE ? 1 : 0) - (HapDeltaMerged[i] ? 1 : 0));
	      LPd2[d1] = d2;
	      if(VERB>=3 && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE) && iter>=13 && i==3617 && R==3622
		  /* && (fabs(Hcuts[i] - (10760.43+11206.614)*0.5-304.98) < 1000.0 && fabs(Hcuts[RR]-Hcuts[i] - 28.1) < 1.0  || fabs(Hcuts[RR]-Hcuts[i]-23.65) < 0.2 )*/){ /* show Indel removal score */
		if(d1 >= DR1[I1] && !(fabs(HapDeltaMerged[i] + incHapDelta) >= MIN_INDEL_SIZE)){
		  printf("i=%d:d1=%d/%d,d2=%d/%d:I1=%d,I2=%d,HapDelta[i]=%0.6f->%0.6f(LL=%d,RR=%d,tot=%0.6f->%0.6f),Delta[i]=%0.6f->%0.6f,Hcuts[i]=%0.3f,Hcuts[i..%d]=%0.3f:LP=%0.6f->%0.6f(change=%0.6f) Indel removal\n",
		    i,d1,DR1[I1],d2,DR2[I2],I1,I2,HapDelta[i],HapDelta[i]+incHapDelta,LL,RR,HapDeltaMerged[i],HapDeltaMerged[i]+incHapDelta,Delta[i],Delta[i]+incDelta,Hcuts[i],R,Hcuts[R]-Hcuts[i],LPstart,LPd[d1],LPd[d1]-LPstart);
		} else {
		  printf("i=%d:d1=%d/%d,d2=%d/%d:I1=%d,I2=%d,HapDelta[i]=%0.6f->%0.6f(LL=%d,RR=%d,tot=%0.6f->%0.6f),Delta[i]=%0.6f->%0.6f,Hcuts[i]=%0.3f,Hcuts[i..%d]=%0.3f:LP=%0.6f->%0.6f(change=%0.6f)\n",
		    i,d1,DR1[I1],d2,DR2[I2],I1,I2,HapDelta[i],HapDelta[i]+incHapDelta,LL,RR,HapDeltaMerged[i],HapDeltaMerged[i]+incHapDelta,Delta[i],Delta[i]+incDelta,Hcuts[i],R,Hcuts[R]-Hcuts[i],LPstart,LPd[d1],LPd[d1]-LPstart);
		}
		fflush(stdout);
	      }

	      /* update HapDeltaScore[i] */
	      if(d1 >= DR1[I1] && HapDelta[i] && (HINDEL_PHASED == 0.0 || HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE))
		HapDeltaScore[i] = LPstart - LPd[d1];
	    }

	    // HERE HERE : should include changing only one Allele in the following section : encode no change as d1= -1 or d2= -1
	    if(HINDEL_NONSYMETRIC && d1 < DR1[I1]){/* check for alternate d2 values */
	      /* HERE :  precompute Doffset[m] = Dcum[AminM[m]] & Doffset2[m] = Dcum2[AminM2[m]] */

	      int origd2 = d2;
	      #pragma novector
	      for(d2 = 0; d2 < DR2[I2]; d2++){
		incHapDelta = 0.5 * (delta1[I1][d1] - delta2[I2][d2]);
		if(fabs((RefineFix ? 1.0 : 2.0) * incHapDelta) < MIN_INDEL_SIZE || d2 == origd2)
		  continue;
		if((Filtered /* NEW157 */|| (Deresed && cresHapMaxLPdrop > 0.0)) && fabs(origHapDelta) < MIN_INDEL_SIZE && fabs(origHapDelta + incHapDelta) >= MIN_INDEL_SIZE)
		  continue;// Avoid adding new Hap Indel
		incDelta = 0.5 * (delta1[I1][d1] + delta2[I2][d2]);
		if(range1 + delta1[I1][d1] < minKB || range2 + delta2[I2][d2] < minKB)
		  continue;

		if((LL <= 0 || RR > n) && Hcuts[R] - Hcuts[i] + Delta[i] + incDelta - fabs(HapDelta[i]+incHapDelta) < minKB)
		  continue;
	      
		double LPd1 = 0.0;
		if((HINDEL_FAST>=2  && !(VERB>=3 && iter==11 && i==1527 && d1==0 && d2==140))){
		  if(DEBUG>=2) assert(isfinite(LPdd[d1][d2]));
		  LPd1 = rawLPstart + LPdd[d1][d2];
		} else {
		  for(int tid = 0; tid < numthreads; tid++)
		    LParray[tid] = 0.0;

		  int ID1 = Dcum[I1] + d1;
		  int ID2 = Dcum2[I2] + d2;

		  int LoopCnt = 0;

                  #pragma omp parallel num_threads(numthreads) // if(!(VERB>=3 && iter==11 && i==1527 && d1==0 && d2==140))
		  {
		    int myLoopCnt = 0;
		    int tid = 0;
#ifdef _OPENMP
		    tid = omp_get_thread_num ();
#endif

		    double myLPd = 0.0;
		    double oldLPd = 0.0;/* only used for debugging */

                    #pragma omp for schedule(static,16)
		    for(int m = 0; m < MD; m++){
		      if(OMP_DEBUG) myLoopCnt++;
		      /* compute LP of map m for HaploType 1 with Y1[I1..I1+1] increased by delta1[I1][d1] */
		      double LP1 = (AminM[m] <= I1 && I1 <= AmaxM[m]) ? newLPdelta[m][ID1 - Dcum[AminM[m]]] : startLPA1[m];
		  
		      /* compute LP of map m for HaploType 2 with Y2[I2..I2+1] increased by delta2[I2][d2] == -delta1[I1][d1] */
		      double LP2 = (AminM2[m] <= I2 && I2 <= AmaxM2[m]) ? newLPdelta2[m][ID2 - Dcum2[AminM2[m]]] : startLPA2[m];
		  
		      double nLP = HapLP(LP1,LP2,logH);

		      myLPd += nLP * TBmapWT[m];

		      if(VERB>=3 && iter==11 && i==1527 && d1==0 && d2==140){
			double oLP = HapLP(startLPA1[m],startLPA2[m],logH);
			oldLPd += oLP * TBmapWT[m];
			if(fabs(nLP-oLP) > 0.001)// only display if LP changed by at least 0.001 for molecule m
			  printf("m=%d/%d:i=%d,d1=%d,d2=%d:LP1=%0.6f,LP2=%0.6f,TBmapWT=%0.6f,nLP=%0.6f,wsum=%0.6f (orig:LP1=%0.6f,LP2=%0.6f,LP=%0.6f,wsum=%0.8f:change=%0.6f,cumchange=%0.6f)\n",
				 m,MD,i,d1,d2,LP1,LP2,TBmapWT[m],nLP,myLPd,startLPA1[m],startLPA2[m],oLP,oldLPd,nLP-oLP, myLPd - oldLPd);
			fflush(stdout);
		      }
		    } /* m = 0..MD-1 */
		
		    LParray[tid] += myLPd;
		    if(OMP_DEBUG && myLoopCnt > 0){
		      #pragma omp critical
		      {
			LoopCnt += myLoopCnt;
		      }
		    }
		  } // omp parallel
		  if(OMP_DEBUG) assert(LoopCnt == MD);

		  qsort(LParray, numthreads, sizeof(double), (intcmp *)doubleInc);  
		  for(int tid = 0; tid < numthreads; tid++)
		    LPd1 += LParray[tid];
		
		  if(HINDEL_FAST && !(fabs(rawLPstart + LPdd[d1][d2] - LPd1) < 1e-6)){
		    printf("i=%d:d1=%d,d2=%d->%d:HapDelta[i]=%0.3f->%0.3f,Delta[i]=%0.3f->%0.3f,Hcuts[i]=%0.3f:LPd[d1]=%0.6f,LPstart+LPdd[d1][d2]=%0.6f(err=%0.6f,LPdd[d1][d2]=%0.6f,rLPstart=%0.6f)\n",
			   i,d1,LPd2[d1],d2,HapDelta[i]+delta1[I1][d1],HapDelta[i]+incHapDelta,Delta[i],Delta[i]+incDelta,Hcuts[i],LPd[d1],rawLPstart+LPdd[d1][d2],LPstart+LPdd[d1][d2]-LPd[d1],LPdd[d1][d2],rawLPstart);
		    fflush(stdout);
		    assert(fabs(LPd1 - (rawLPstart + LPdd[d1][d2])) < 1e-6);
		  }
		}/* HINDEL_FAST <=1 */

		LPd1 -= 0.5*(startN1+startN2)*SITE_PEN;
		LPd1 += logHapSitePvalue * startSNPcnt + logHapIndelPvalue * startIndelCnt;
		LPd1 += logHapIndelPvalue * ((fabs(HapDeltaMerged[i] + incHapDelta) >= MIN_INDEL_SIZE ? 1 : 0) - (HapDeltaMerged[i] ? 1 : 0));

		if(VERB>=3 && LPd1 > LPd[d1] && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE) && iter == 25 && Hcuts[i] >= 5800.0
		    && Hcuts[R]-Hcuts[i] >= 25.0 && fabs(HapDelta[i] + incHapDelta) >= 63.0 && fabs(HapDelta[i] + incHapDelta) <= 64.0 /* && fabs(Delta[i]+incDelta) >= 63.0 && fabs(Delta[i]+incDelta) <= 64.0 */
		   /* && (fabs(Hcuts[i] - (10760.43+11206.614)*0.5-304.98) < 1000.0 && fabs(Hcuts[RR]-Hcuts[i] - 28.1) < 1.0 || fabs(Hcuts[RR]-Hcuts[i]-23.65) < 0.2 )*/){
		  printf("i=%d:d1=%d/%d,d2=%d/%d:I1=%d,I2=%d,HapDelta=%0.8f->%0.8f(tot=%0.6f),Delta=%0.8f->%0.8f,Hcuts[i]=%0.3f,Hcuts[i..%d]=%0.3f:LP=%0.6f->%0.6f(change=%0.6f),minKB=%0.3f,wt=%0.6f\n",
			 i,d1,DR1[I1],d2,DR2[I2],I1,I2,HapDelta[i],HapDelta[i]+incHapDelta,HapDeltaMerged[i],Delta[i],Delta[i]+incDelta,Hcuts[i],R,Hcuts[R]-Hcuts[i],LPstart,LPd1,LPd1-LPstart,minKB,wtime());
		  fflush(stdout);
		}

		if(LPd1 > LPd[d1]){
		  LPd[d1] = LPd1;
		  LPd2[d1] = d2;
		}
	      }/* d2 = 0 .. DR2[I2] - 1 */
	    }/* if(HINDEL_NONSYMMETRIC) */
	  } /* d1 = 0 .. D1[I1] - 1 */

	  /* locate best indel value LPd[d1 = 0..D1[I1]-1] and see if it is better than LPstart */
	  int maxd1 = -1, maxd2 = -1;
	  if(DEBUG>=2 && !(I1 <= N1 && N1 <= n && D1[I1] <= INITIAL_DELTA_RANGE*2 + MAX_INDEL - 1)){
	    printf("I1=%d,N1=%d,n=%d,D1[I1]=%d,INITIAL_DELTA_RANGE = %d\n",I1,N1,n,D1[I1],INITIAL_DELTA_RANGE);
	    fflush(stdout);
	    assert(I1 <= N1 && N1 <= n && D1[I1] <= INITIAL_DELTA_RANGE*2 + MAX_INDEL - 1);
	  }

#pragma novector
	  for(int d1 = 0; d1 < D1[I1]; d1++){
	    if(maxd1 < 0 || LPd[d1] > LPd[maxd1]){
	      maxd1 = d1;
	      maxd2 = LPd2[d1];
	      if(DEBUG>=2 && maxd2 >= 0 && LPd[maxd1] > LPstart + HLP_MINDELTA){
		nHapDelta[i] = 0.5*(delta1[I1][maxd1]-delta2[I2][maxd2]);
		nHapDelta2[i] = 0.5*(delta1[I1][maxd1]+delta2[I2][maxd2]);
		if(range1 + delta1[I1][maxd1] < minKB || range2 + delta2[I2][maxd2] < minKB){
		  printf("iter=%d:i=%d,R=%d,n=%d:d1=%d,d2=%d,LPd[d1]=%0.8f,LPstart=%0.8f:Hcuts[i]=%0.4f,Hcuts[R]=%0.4f,range=%0.4f,%0.4f,HapSite[i]=%d,HapSite[R]=%d,Delta[i]=%0.4f,nDelta=%0.4f,HapDelta[i]=%0.4f,nHapDelta=%0.4f,nHapDelta2[i]=%0.4f,minKB=%0.4f\n",
			 iter,i,R,n,maxd1,maxd2,LPd[maxd1],LPstart,Hcuts[i],Hcuts[R],range1,range2,HapSite[i],HapSite[R],Delta[i],nHapDelta2[i],HapDelta[i],nHapDelta[i],nHapDelta2[i],minKB);
		  fflush(stdout);
		  assert( !(range1 + delta1[I1][maxd1] < minKB || range2 + delta2[I2][maxd2] < minKB));
		}
	      }
	    }
	  }

	  if(VERB>=3 && iter==25){
	    printf("i=%d:maxd1=%d,maxd2=%d:Hcuts[i]= %0.3f,R=%d,Hcuts[i..R]= %0.3f,HapSite[i,R]=%d,%d : best HapDelta LP=%0.6f -> %0.6f(change= %0.6f): wt=%0.6f\n",
		   i,maxd1,maxd2,Hcuts[i],R,Hcuts[R]-Hcuts[i],HapSite[i],HapSite[R],LPstart,max(LPd[maxd1],LPstart),max(0.0,LPd[maxd1]-LPstart),wtime());
	    fflush(stdout);
	  }

	  LPindel[i] = LPstart;
	  nHapDelta[i] = 0.0;
	  nHapDelta2[i] = 0.0;

	  if(maxd1 >= 0 && maxd2 >= 0){// NEW93 : this can happen near ends (eg if I1==0 or I2==0 or I1==N1 or I2==N2) when only one allele can be adjusted (which is currently not supported)
	    if(DEBUG && !(0 <= maxd1 && maxd1 < D1[I1] && 0 <= maxd2 && maxd2 < D2[I2])){
	      printf("i=%d: I1=%d,I2=%d,D1[I1]=%d,D2[I2]=%d,N1=%d,N2=%d : maxd1= %d, maxd2= %d\n",i, I1,I2,D1[I1],D2[I2],N1,N2,maxd1, maxd2);
	      fflush(stdout);
	      assert(0 <= maxd1 && maxd1 < D1[I1]);
	      assert(0 <= maxd2 && maxd2 < D2[I2]);
	    }

	    LPindel[i] = max(LPd[maxd1],LPstart);
	    nHapDelta[i] = ((LPd[maxd1] > LPstart + HLP_MINDELTA) ? 0.5*(delta1[I1][maxd1]-delta2[I2][maxd2]) : 0.0);
	    nHapDelta2[i] = ((LPd[maxd1] > LPstart + HLP_MINDELTA) ? 0.5*(delta1[I1][maxd1]+delta2[I2][maxd2]) : 0.0);

	    if(VERB>=3 && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE) && iter >= 13 && i==3617 && R==3622
	       /* && (fabs(Hcuts[i] - (10760.43+11206.614)*0.5-304.98) < 1000.0 && fabs(Hcuts[RR]-Hcuts[i] - 28.1) < 1.0 || fabs(Hcuts[RR]-Hcuts[i]-23.65) < 0.2 )*/){
	      double nHapDeltai = 0.5*(delta1[I1][maxd1]-delta2[I2][maxd2]);
	      double nHapDelta2i = 0.5*(delta1[I1][maxd1]+delta2[I2][maxd2]);
	      printf("HapDelta[i=%d]=%0.6f->%0.6f(tot=%0.6f->%0.6f),Delta[i]=%0.6f->%0.6f,(maxd1=%d/%d,maxd2=%d/%d,D1[%d]=%d,D2[%d]=%d,delta=%0.6f,%0.6f):\n\t LP=%0.8f -> %0.8f (Hcuts[i]=%0.3f,%0.3f,Hcuts[i..R]=%0.6f,L=%d,R=%d,HapSite[L,i,R]=%d,%d,%d)\n",
		     i,HapDelta[i], HapDelta[i] + nHapDeltai, HapDeltaMerged[i], HapDeltaMerged[i] + nHapDeltai, Delta[i], Delta[i]+nHapDelta2i, 
		     maxd1,DR1[I1],maxd2,DR2[I2],I1,D1[I1],I2,D2[I2],delta1[I1][maxd1],delta2[I2][maxd2],LPstart, LPd[maxd1], Hcuts[i], Hcuts[i]+DelCum[i], Hcuts[R]-Hcuts[i],L,R,HapSite[L],HapSite[i],HapSite[R]);
	      printf("   I1=%d,maxd1=%d,D1[I1]=%d,I2=%d,maxd2=%d,D2[I2]=%d:delta1[I1][maxd1]=%0.6f,delta2[I2][maxd2]=%0.6f\n",
		     I1,maxd1,D1[I1],I2,maxd2,D2[I2],delta1[I1][maxd1],delta2[I2][maxd2]);
	      fflush(stdout);
	    }
	    if(DEBUG>=1+RELEASE) assert(fabs(nHapDelta[i]) < 1000.0 && fabs(nHapDelta2[i]) < 1000.0);

	    /* initialize HapDeltaScore[i] */
	    if(!HapDelta[i] && nHapDelta[i] && fabs(nHapDelta2[i]) < MIN_INDEL_SIZE)
	      HapDeltaScore[i] = LPindel[i] - LPstart;

	    if(VERB>=2 && (LPd[maxd1] > LPstart + HLP_MINDELTA || (HapIndelPvalue == origHapIndelPvalue && HapDelta[i] != 0.0))){
	      if(LPd[maxd1] > LPstart + HLP_MINDELTA)
		printf("HapDelta[i=%d]=%0.4f -> %0.4f(tot=%0.4f->%0.4f),Delta[i]=%0.4f->%0.4f,(d1=%d/%d,maxd2=%d/%d,D1[%d]=%d,D2[%d]=%d): LP=%0.8f -> %0.8f (Hcuts[i]=%0.3f,%0.3f,Hcuts[i..R]=%0.3f,L=%d,R=%d,HapSite[L,i,R]=%d,%d,%d)\n",
		       i,HapDelta[i], HapDelta[i] + nHapDelta[i], HapDeltaMerged[i], HapDeltaMerged[i] + nHapDelta[i], Delta[i], Delta[i]+nHapDelta2[i], 
		       maxd1,DR1[I1],maxd2,DR2[I2],I1,D1[I1],I2,D2[I2],LPstart, LPd[maxd1], Hcuts[i], Hcuts[i]+DelCum[i], Hcuts[R]-Hcuts[i],L,R,HapSite[L],HapSite[i],HapSite[R]);
	      else
		printf("HapDelta[i=%d]=%0.4f unchanged (maxd1=%d,D1[%d]=%d,D2[%d]=%d): (Hcuts[i]=%0.3f,%0.3f,Hcuts[i..R]=%0.3f,L=%d,R=%d,HapSite[L,i,R]=%d,%d,%d)\n",
		       i,HapDelta[i], maxd1, I1,D1[I1],I2,D2[I2], Hcuts[i],Hcuts[i]+DelCum[i],Hcuts[R]-Hcuts[i],L,R,HapSite[L],HapSite[i],HapSite[R]);
	      printf("\t ibest=%d(type=%d,LP=%0.6f),progress=%d(%d,%d), changes=%d, iter=%d, SNPs=%d,IndelCnt=%d->%d\n",
		     ibest,tbest,LPbest,progress,hapdeltacnt,deltacnt,changecnt, iter, SNPcnt, IndelCnt, 
		     IndelCnt + (fabs(HapDeltaMerged[i] + nHapDelta[i]) >= MIN_INDEL_SIZE ? 1 : 0) - (HapDeltaMerged[i] ? 1 : 0));
	      if(DEBUG>=2){
		fflush(stdout);
		assert(range1 + nHapDelta2[i] + nHapDelta[i] >= minKB && range2 + nHapDelta2[i] - nHapDelta[i] >= minKB);
	      }
	      if(VERB>=2 && i==945){
		double origHapDelta = HapDelta[i];
		for(int d1 = 0; d1 < D1[I1]; d1++){
		  int d2 = LPd2[d1];
		  if(d2 < 0)
		    continue;
		  printf("d1=%2d,d2=%2d:HapDelta[i]->%6.3f(change=%6.3f,nDelta=%0.3f), LPd[d1]=%0.6f(change=%9.6f)\n",
			 d1,d2, origHapDelta + 0.5*(delta1[I1][d1]-delta2[I2][d2]), delta1[I1][d1], 0.5*(delta1[I1][d1] + delta2[I2][d2]), LPd[d1], LPd[d1] - LPstart);
		}
	      }
	      fflush(stdout);
	    }

	    if(HAPSTOP_DEBUG && maxd1 >= 0 && (HAPSTOP_DEBUG>=2 || LPd[maxd1] > LPstart + LP_INDEL_MINDELTA)){
	      printf("i=%d:HapDelta[i]=%0.4f->%0.4f,Hcuts[i]=%0.3f,%0.3f,R=%d,Hcuts[i..R]=%0.4f->%0.4f:LP=%0.6f->%0.6f:ibest=%d(type=%d,LP=%0.6f) cum=%0.6f\n",
		     i, HapDelta[i], HapDelta[i] + nHapDelta[i], Hcuts[i], Hcuts[i] + DelCum[i], R,Hcuts[R]-Hcuts[i] + Delta[i], Hcuts[R]-Hcuts[i] + Delta[i] + nHapDelta2[i], 
		     LPstart, LPd[maxd1], ibest, tbest, LPbest, wtime());
	      fflush(stdout);
	    }

	    if(VERB>=3 && iter==25 && i > 19658 /* && (HapDelta[i] || HapDeltaMerged[i] || delta1[I1][maxd1] != delta2[I2][maxd2])*/){
	      double nHapDeltai = 0.5*(delta1[I1][maxd1]-delta2[I2][maxd2]);
	      double nHapDelta2i = 0.5*(delta1[I1][maxd1]+delta2[I2][maxd2]);
	      if(fabs(nHapDeltai) >= 50.0 || fabs(nHapDelta2i) >= 50.0){
		printf("i=%d:maxd1=%d,maxd2=%d:HapDelta[i]=%0.6f->%0.6f(tot=%0.6f),Hcuts[i]=%0.3f,%0.3f,R=%d,Hcuts[i..R]=%0.4f->%0.4f:LP=%0.6f->%0.6f(delta=%0.6f):ibest=%d(type=%d,LP=%0.6f)\n",
		       i, maxd1,maxd2,HapDelta[i], HapDelta[i] + nHapDeltai, HapDeltaMerged[i], Hcuts[i], Hcuts[i] + DelCum[i], R,Hcuts[R]-Hcuts[i] + Delta[i], Hcuts[R]-Hcuts[i] + Delta[i] + nHapDelta2i, 
		       LPstart, LPd[maxd1], LPd[maxd1]-LPstart,ibest, tbest, LPbest);
		fflush(stdout);
	      }
	    }

	    if(DEBUG) assert(maxd1 >= 0);

	    /* update LPbest, ibest, tbest */
	    if(LPd[maxd1] > LPstart + HLP_MINDELTA){
	      if(LPd[maxd1] > LPstart + LP_INDEL_MINDELTA){
		if(maxd1 < DR1[I1]){
		  int biggestD = maxd1 % DELTA_RANGE[IN1];
		  for(int T = max(0,IN1-DELTA_SCAN); T <= IN1 + DELTA_SCAN && T <= maxIN; T++){
		    if(DELTA_SCAN_FIX && biggestD1[T] < 0){
		      activecnt++;
		      if(DELTA_RANGE[T] <= 0){		      // copy Initial_Delta[T] from Initial_Delta[IN1]
			newactivecnt++;
			if(DEBUG) assert(T != IN1);
			for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
			  Initial_Delta[T][k] = Initial_Delta[IN1][k];
			// WAS50 biggestD1[T] = biggestD;
		      } // WAS50 else
		      biggestD1[T] = 0;// NOTE : exact value is determined below 

		      if(HAPSTOP_DEBUG || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
			if(DELTA_RANGE[T] > 0)
			  printf("Activating region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) with IDelta[%d]=%0.3f..%0.3f: HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y1[I1]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
				 T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1, DELTA_RANGE[T], Initial_Delta[T][0], Initial_Delta[T][DELTA_RANGE[T]-1], i, HapDelta[i], HapDelta[i] + nHapDelta[i], 
				 nHapDelta2[i], maxd1,DR1[I1],maxd2,DR2[I2], HapSite[i],Hcuts[i], Hcuts[i]+DelCum[i], startY1[I1+1]-startY1[I1], LPstart, LPd[maxd1], DELTA_RANGE[T]);
			else
			  printf("Re-Activating region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) with IDelta[0]=%0.3f..: HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y1[I1]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
				 T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1, Initial_Delta[T][0], i, HapDelta[i], HapDelta[i] + nHapDelta[i], 
				 nHapDelta2[i], maxd1,DR1[I1],maxd2,DR2[I2], HapSite[i],Hcuts[i], Hcuts[i]+DelCum[i], startY1[I1+1]-startY1[I1], LPstart, LPd[maxd1], DELTA_RANGE[T]);
			fflush(stdout);
		      }
		    } else if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		      printf("Region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) active:biggestD1[T]=%d,HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y1[I1+]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			     T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1,biggestD1[T],i,HapDelta[i], HapDelta[i] + nHapDelta[i], nHapDelta2[i], maxd1,DR1[I1],maxd2,DR2[I2],
			     HapSite[i],Hcuts[i], Hcuts[i]+DelCum[i], startY1[I1+1]-startY1[I1], LPstart, LPd[maxd1], DELTA_RANGE[T]);
		      fflush(stdout);
		    }
		  
		    /* increase biggestD1[T], if needed, to match biggestD */
		    if(DELTA_SCAN_FIX && T != IN1 && fabs(Initial_Delta[IN1][0] - Initial_Delta[T][0]) > MIN_DELTA * 0.001){
		      while(biggestD1[T] < localINITIAL_DELTA_RANGE - 1 && Initial_Delta[T][biggestD1[T]] + MIN_DELTA*0.001 < Initial_Delta[IN1][biggestD])
			biggestD1[T]++;
		    } else if(biggestD > biggestD1[T])
		      biggestD1[T] = biggestD;
		    if(DEBUG) assert(0 <= biggestD1[T] && biggestD1[T] < localINITIAL_DELTA_RANGE && DELTA_RANGE[T] <= localINITIAL_DELTA_RANGE);
		  }
		} // maxd1 < DR1[I1]

		if(maxd2 < DR2[I2]){
		  int biggestD = maxd2 % DELTA_RANGE[IN2];
		  for(int T = max(0,IN2-DELTA_SCAN); T <= IN2 + DELTA_SCAN && T <= maxIN; T++){
		    if(DELTA_SCAN_FIX && biggestD1[T] < 0){
		      activecnt++;
		      if(DELTA_RANGE[T] <= 0){		      // copy Initial_Delta[T] from Initial_Delta[IN2]
			newactivecnt++;
			if(DEBUG) assert(T != IN2);
			for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
			  Initial_Delta[T][k] = Initial_Delta[IN2][k];
			// WAS50 biggestD1[T] = biggestD;
		      } // WAS50 else
		      biggestD1[T] = 0;

		      if(HAPSTOP_DEBUG || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
			if(DELTA_RANGE[T] > 0)
			  printf("Activating region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) with IDelta[%d]=%0.3f..%0.3f: HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y2[I2]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
				 T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2, DELTA_RANGE[T], Initial_Delta[T][0], Initial_Delta[T][DELTA_RANGE[T]-1], i, HapDelta[i], HapDelta[i] + nHapDelta[i], 
				 nHapDelta2[i], maxd1,DR1[I1],maxd2,DR2[I2], HapSite[i],Hcuts[i], Hcuts[i]+DelCum[i], startY2[I2+1] - startY2[I2], LPstart, LPd[maxd1], DELTA_RANGE[T]);
			else
			  printf("Re-Activating region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) with IDelta[0]=%0.3f..: HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y2[I2]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
				 T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2, Initial_Delta[T][0], i, HapDelta[i], HapDelta[i] + nHapDelta[i], 
				 nHapDelta2[i], maxd1,DR1[I1],maxd2,DR2[I2], HapSite[i],Hcuts[i], Hcuts[i]+DelCum[i], startY2[I2+1] - startY2[I2], LPstart, LPd[maxd1], DELTA_RANGE[T]);
			fflush(stdout);
		      }
		    } else if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		      printf("Region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) active:biggestD1[T]=%d,HapDelta[i=%d]=%0.4f->%0.4f,nDelta[i]=%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y2[I2+]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			     T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2, biggestD1[T], i,HapDelta[i], HapDelta[i] + nHapDelta[i], nHapDelta2[i], maxd1,DR1[I1],maxd2, DR2[I2],
			     HapSite[i],Hcuts[i], Hcuts[i]+DelCum[i], startY2[I2+1]-startY2[I2], LPstart, LPd[maxd1], DELTA_RANGE[T]);
		      fflush(stdout);
		    }

		    /* increase biggestD1[T], if needed, to match biggestD */
		    if(DELTA_SCAN_FIX && T != IN2 && fabs(Initial_Delta[IN2][0] - Initial_Delta[T][0]) > MIN_DELTA * 0.001){
		      while(biggestD1[T] < localINITIAL_DELTA_RANGE - 1 && Initial_Delta[T][biggestD1[T]] + MIN_DELTA*0.001 < Initial_Delta[IN2][biggestD])
			biggestD1[T]++;
		    } else if(biggestD > biggestD1[T])
		      biggestD1[T] = biggestD;
		    if(DEBUG) assert(0 <= biggestD1[T] && biggestD1[T] < localINITIAL_DELTA_RANGE && DELTA_RANGE[T] <= localINITIAL_DELTA_RANGE);
		  } 
		}
	      }

	      if(VERB && (HAPSTOP_DEBUG || (VERB>=2 && iter == 25 && (/* fabs(Hcuts[i] - 4100) < 10.0 */ i > 19658 || fabs(nHapDelta[i]) > 60.0)))){
		printf("i=%d:HapDelta[i]=%0.4f -> %0.4f,Hcuts[i]=%0.3f,%0.3f,R=%d,Hcuts[i..R]=%0.4f->%0.4f:LP=%0.6f->%0.6f:ibest=%d(type=%d,LP=%0.6f), progress=%d(%d,%d), iter=%d,SNPcnt=%d,Indelcnt=%d(cum=%0.6f)\n",
		       i, HapDelta[i], HapDelta[i] + nHapDelta[i], Hcuts[i], Hcuts[i] + DelCum[i], R,Hcuts[R]-Hcuts[i] + Delta[i], Hcuts[R]-Hcuts[i] + Delta[i] + nHapDelta2[i], 
		       LPstart, LPd[maxd1], ibest, tbest, LPbest, progress, hapdeltacnt,deltacnt, iter,  SNPcnt, IndelCnt, wtime());
		fflush(stdout);
	      }

	      if(LPd[maxd1] > LPbest + 2e-9){
		ibest = i;
		Lbest = L;
		Rbest = R;
		LLbest = LL;
		RRbest = RR;
		tbest = 1;
		LPbest = LPd[maxd1];
		range1best = range1;
		range2best = range2;
	      }
	      if(DEBUG) assert(ibest >= 1);
	    }
	  } // if(maxd1 >= 0 && maxd2 >= 0)
	} // if(HINDELITER(iter) && HapSite[i] && (HINDEL_UPDATE || HapDelta[i]==0.0))

	/* next check changing Hcuts[i..i+1] by changing Delta[i], provided HapSite[i] != 0 */
	if(HINDELITER(iter) && HapSite[i] && R <= n && DR1[I1] > 0 && DR2[I2] > 0){
	  if(DEBUG) assert(0 <= IN1 && IN1 <= maxIN);
	  if(DEBUG) assert(0 <= IN2 && IN2 <= maxIN);

	  double LPd[INITIAL_DELTA_RANGE*2];
	  int LPd2[INITIAL_DELTA_RANGE*2];/* LPd2[d1] is the corresponding d2 value with the best score */

	  /* increase intervals Y1[I1..I1+1] and Y2[I2..I2+1] by same amount */
	  int d1;/* index into delta1[I1][d1=0..min(D1[I1],D2[I2])-1] == delta2[I2][d2=0..min(D1[I1],D2[I2])-1] : 
		    used to access indel LP values : (AminM2[m] <= I2 <= AmaxM2[m]) ? newLPdelta2[m][I2,d2] : startLPA2[m] */
	  if(DEBUG) assert(i < R && R <= n && HapSite[R]);

	  for(d1 = 0; d1 < D1[I1]; d1++){
	    LPd[d1] = LPstart - BigPen;/* bad value as default for unhandled cases */
	    LPd2[d1] = -1;
	  }

	  for(d1 = 0; d1 < DR1[I1]; d1++){
	    int d2 = min(d1,DR2[I2]-1);
	    while(d2 < DR2[I2]-1 && delta1[I1][d1] - delta2[I2][d2] >= MIN_INDEL_SIZE)
	      d2++;
	    while(d2 > 0 && delta2[I2][d2] - delta1[I1][d1] >= MIN_INDEL_SIZE)
	      d2--;
	    if(DEBUG) assert(0 <= d2 && d2 < DR2[I2]);
	    if(!(fabs(delta1[I1][d1] - delta2[I2][d2]) < MIN_INDEL_SIZE))
	      continue;

	    if(DEBUG && !(fabs(delta1[I1][d1] - delta2[I2][d2]) < MIN_INDEL_SIZE && D1[I1] >= DR1[I1] && D2[I2] >= DR2[I2]) ){
	      printf("d1=%d,d2=%d:I1=%d/%d,I2=%d/%d,DR1[I1]=%d,D1[I1]=%d,DR2[I2]=%d,D2[I2]=%d,delta1[I1][d1]=%0.6f,delta2[I2][d2]=%0.6f\n",
		     d1,d2,I1,startN1,I2,startN2,DR1[I1],D1[I1],DR2[I2],D2[I2],delta1[I1][d1],delta2[I2][d2]);
	      printf("i=%d,R=%d:Hcuts[i,R]=%0.3f,%0.3f,HapSite[i,R]=%d,%d,startN1=%d,startN2=%d\n",i,R,Hcuts[i],Hcuts[R],HapSite[i],HapSite[R],startN1,startN2);
	      for(int t = i; t < R; t++)
		if(HapDelta[t] || Delta[t])
		  printf("  t=%d:HapDelta[t]=%0.3f,Delta[t]=%0.3f\n",t,HapDelta[t],Delta[t]);
	      for(int t = 0; t < DR1[I1]; t++)
		printf("d1=%d:delta1[I1][d1]=%0.6f\n",t,delta1[I1][t]);
	      for(int t = 0; t < DR2[I2]; t++)
		printf("d2=%d:delta2[I2][d2]=%0.6f\n",t,delta2[I2][t]);
	      fflush(stdout);
	      assert(fabs(delta1[I1][d1] - delta2[I2][d2]) < MIN_INDEL_SIZE && D1[I1] >= DR1[I1] && D2[I2] >= DR2[I2]);
	    }

	    if(range1 + delta1[I1][d1] < minKB || range2 + delta2[I2][d2] < minKB)
	      continue;

	    double LParray[numthreads];

	    if(HINDEL_FAST>=2 && !(VERB>=3 && i==435 && iter==23 && d1==25 && d2==25)){
	      if(DEBUG>=2) assert(isfinite(LPdd[d1][d2]));
	      LPd[d1] = rawLPstart + LPdd[d1][d2];
	    } else {/* HINDEL_FAST <= 1 */
	      for(int tid = 0; tid < numthreads; tid++)
		LParray[tid] = 0.0;
	  
	      int ID1 = Dcum[I1] + d1;
	      int ID2 = Dcum2[I2] + d2;

	      int nthreads = numthreads;
	      if(VERB>=3 && iter==23 && i==435 && d1==25 && d2==25)
		nthreads = 1;

	      int LoopCnt = 0;

              #pragma omp parallel num_threads(nthreads)
	      {
	        int myLoopCnt = 0;
		int tid = 0;
#ifdef _OPENMP
		tid = omp_get_thread_num ();
#endif

		double myLPd = 0.0, cumchange = 0.0;

                #pragma omp for schedule(static,1)
		for(int m = 0; m < MD; m++){
	          if(OMP_DEBUG) myLoopCnt++;
		  int valid1 = (AminM[m] <= I1 && I1 <= AmaxM[m]);
		  int valid2 = (AminM2[m] <= I2 && I2 <= AmaxM2[m]);

		  if(MPROBEVAL_LAZYRESTORE){
	            CdoubleBlock *p;

		    if(valid1 && (p = pBlock1[m])->swapout > 0){
	              #pragma omp critical(blockList)
	              {
	                if(p->swapout > 0){
		          int origswapout = p->swapout;
			  int origswapcnt = blockListSwapped;
			  if(DEBUG/* HERE >=2 */) assert(blockListSwapped == SwappedAllocations_swapcnt());

			  p->readin();
			  blockListSwapped--;

			  if((DEBUG && !(0 <= blockListSwapped && p->swapout < 0)) || (DEBUG/* HERE >=2 */ && !(blockListSwapped == SwappedAllocations_swapcnt()))){
	                    printf("WARNING:m=%d/%d,swapout=%d->%d,blockListSwapped=%d->%d(correct value=%d),blockListLen=%d,blockListMax=%d\n",m,MD,origswapout,(int)p->swapout,origswapcnt,blockListSwapped,SwappedAllocations_swapcnt(),blockListLen,blockListMax);
			    fflush(stdout);

			    assert(0 <= blockListSwapped && p->swapout < 0);
			    assert(blockListSwapped == SwappedAllocations_swapcnt());
		         }
		        }
		      }
	            }
		    if(valid2 && (p = pBlock2[m])->swapout > 0){
                      #pragma omp critical(blockList)
		      {
			if(p->swapout > 0){
			  int origswapout = p->swapout;
			  int origswapcnt = blockListSwapped;
			  if(DEBUG/* HERE >=2 */) assert(blockListSwapped == SwappedAllocations_swapcnt());
			  
			  p->readin();
			  blockListSwapped--;

			  if((DEBUG && !(0 <= blockListSwapped && p->swapout < 0)) || (DEBUG/* HERE >=2 */ && !(blockListSwapped == SwappedAllocations_swapcnt()))){
			    printf("WARNING:m=%d/%d,swapout=%d->%d,blockListSwapped=%d->%d(correct value=%d),blockListLen=%d,blockListMax=%d\n",m,MD,origswapout,(int)p->swapout,origswapcnt,blockListSwapped,SwappedAllocations_swapcnt(),blockListLen,blockListMax);
			    fflush(stdout);

			    assert(0 <= blockListSwapped && p->swapout < 0);
			    assert(blockListSwapped == SwappedAllocations_swapcnt());
			  }
			}
		      }
		    }
	          }

		  /* compute LP of map m for HaploType 1 with Y1[I1..I1+1] increased by delta1[I1][d] */
		  double LP1 = valid1 ? newLPdelta[m][ID1 - Dcum[AminM[m]]] : startLPA1[m];
		
		  /* compute LP of map m for HaploType 2 with Y2[I2..I2+1] increased by delta2[I2][d] == delta1[I1][d] */
		  double LP2 = valid2 ? newLPdelta2[m][ID2 - Dcum2[AminM2[m]]] : startLPA2[m];	      
		
		  double nLP = HapLP(LP1,LP2,logH);

		  myLPd += nLP * TBmapWT[m];
		
		  if(VERB>=3 && iter==23 && i==435 && d1==25 && d2==25){
		    cumchange += (nLP-startLP[m]) * TBmapWT[m];
		    printf("m=%d/%d:i=%d,d1=%d,d2=%d:LP1=%0.6f,LP2=%0.6f,nLP=%0.6f,TBmapWT=%0.6f,origLP=%0.6f(change=%0.6f),cum=%0.6f,(change=%0.6f),valid1=%d,valid2=%d,index1=%d,index2=%d\n",
			   m,MD,i,d1,d2,LP1,LP2,nLP,TBmapWT[m],startLP[m],nLP-startLP[m], myLPd, cumchange,valid1,valid2,ID1-Dcum[AminM[m]],ID2 - Dcum2[AminM2[m]]);
		    fflush(stdout);
		  }
		} /* m = 0..MD-1 */

		LParray[tid] += myLPd;
		if(OMP_DEBUG && myLoopCnt > 0){
                  #pragma omp critical
		  {
		    LoopCnt += myLoopCnt;
		  }
		}
	      } // omp parallel
	      if(OMP_DEBUG && !(LoopCnt == MD)){
	        printf("iter=%d,i=%d:LoopCnt=%d,MD=%d,nthreads=%d\n",iter,i,LoopCnt,MD,nthreads);
		fflush(stdout);
	        assert(LoopCnt == MD);
	      }

	      LPd[d1] = 0.0;
	      qsort(LParray, numthreads, sizeof(double), (intcmp *)doubleInc);  
	      for(int tid = 0; tid < numthreads; tid++)
		LPd[d1] += LParray[tid];
	      if(HINDEL_FAST && !(fabs(rawLPstart + LPdd[d1][d2] - LPd[d1]) < 1e-6)){
		printf("i=%d,d1=%d,d2=%d:Delta[i]=%0.3f->%0.3f:LPstart=%0.6f,LPd[d1]=%0.6f,rLPstart+LPdd[d1][d2]=%0.6f(err=%0.6f,LPdd[d1][d2]=%0.6f,rLPstart=%0.6f)\n",
		       i,d1,d2,Delta[i],Delta[i]+delta1[I1][d1],LPstart,LPd[d1],rawLPstart+LPdd[d1][d2],rawLPstart+LPdd[d1][d2]-LPd[d1],LPdd[d1][d2],rawLPstart);
		fflush(stdout);
		assert(fabs(rawLPstart + LPdd[d1][d2] - LPd[d1]) < 1e-6);
	      }
	    } // HINDEL_FAST <= 1

	    LPd[d1] -= 0.5*(startN1+startN2)*SITE_PEN;
	    LPd[d1] += logHapSitePvalue * startSNPcnt + logHapIndelPvalue * startIndelCnt;
	    LPd2[d1] = d2;

	    if(VERB>=3 && iter == 25 && i==3617 && R==3622 /* && d1==25 && d2==25 */
		/* && (fabs(Hcuts[i] - 4374.0) < 10.0 || fabs(Hcuts[RR]-Hcuts[i] - 39.9) < 0.2 || fabs(Hcuts[RR]-Hcuts[i]-23.65) < 0.2) && LPd[d1] > LPstart + HLP_MINDELTA */){
	      printf("i=%d:d1=%d,d2=%d:HapDelta=%0.4f,Delta=%0.4f->%0.4f,Hcuts[i]=%0.3f,Hcuts[i..%d]=%0.4f:LP=%0.6f->%0.6f(change=%0.6f),minKB=%0.3f\n",
		     i,d1,d2,HapDelta[i],Delta[i],Delta[i]+delta1[I1][d1],Hcuts[i],R,Hcuts[R]-Hcuts[i],LPstart,LPd[d1],LPd[d1]-LPstart,minKB);
	      fflush(stdout);
	    }
	  } /* d1 = 0 .. min(D1[I1],D2[I2])-1 */

	  /* locate best value LPd[d1 = 0..D1[I1]-1] and see if it is better than LPstart */
	  int maxd1 = -1, maxd2 = -1;
	  for(int d1 = 0; d1 < DR1[I1]; d1++)
	    if(maxd1 < 0 || LPd[d1] > LPd[maxd1]){
	      maxd1 = d1;
	      maxd2 = LPd2[d1];
	    }

	  LPdelta[i] = LPstart;
	  nDelta[i] = 0.0;
	  
	  if(VERB>=3 && iter==25){
	    printf("i=%d:maxd1=%d,maxd2=%d:Hcuts[i]= %0.3f : best Delta LP=%0.6f -> %0.6f(change= %0.6f): wt=%0.6f\n",
			i,maxd1,maxd2,Hcuts[i],LPstart,max(LPd[maxd1],LPstart),max(0.0,LPd[maxd1]-LPstart),wtime());
	    fflush(stdout);
	  }

	  if(maxd1 >= 0 && maxd2 >= 0){// NEW93 : this can happen near ends (eg if I1==0 or I2==0 or I1==N1 or I2==N2) when only one allele can be adjusted (which is currently not supported)

	    LPdelta[i] = max(LPd[maxd1],LPstart);
	    nDelta[i] = (LPd[maxd1] > LPstart + HLP_MINDELTA) ? delta1[I1][maxd1] : 0.0;
	
	    /* update LPbest, ibest, tbest */
	    if(LPd[maxd1] > LPstart + HLP_MINDELTA){
	      if(LPd[maxd1] > LPstart + LP_INTERVAL_MINDELTA){
		if(DEBUG) assert(maxd1 < DR1[I1]);
		int biggestD = maxd1 % DELTA_RANGE[IN1];
		for(int T = max(0,IN1-DELTA_SCAN); T <= IN1 + DELTA_SCAN && T <= maxIN; T++){
		  if(DELTA_SCAN_FIX && biggestD1[T] < 0){
		    activecnt++;
		    if(DELTA_RANGE[T] <= 0){		      // copy Initial_Delta[T] from Initial_Delta[IN1]
		      newactivecnt++;
		      if(DEBUG) assert(T != IN1);
		      for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
			Initial_Delta[T][k] = Initial_Delta[IN1][k];
		      // WAS50 biggestD1[T] = biggestD;
		    } // WAS50 else
		    biggestD1[T] = 0;// updated below
		    
		    if(HAPSTOP_DEBUG || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		      if(DELTA_RANGE[T] > 0)
			printf("Activating region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) with IDelta[%d]=%0.3f..%0.3f:Delta[i=%d]=%0.4f->%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y1[I1+]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1,DELTA_RANGE[T],Initial_Delta[T][0], Initial_Delta[T][DELTA_RANGE[T]-1],i, Delta[i], Delta[i] + nDelta[i], 
			maxd1,DR1[I1],maxd2, DR2[I2], HapSite[i],Hcuts[i],Hcuts[i]+DelCum[i], startY1[I1+1]-startY1[I1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		      else
			printf("Re-Activating region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) with IDelta[0]=%0.3f..:Delta[i=%d]=%0.4f->%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y1[I1+]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1,Initial_Delta[T][0],i, Delta[i], Delta[i] + nDelta[i], 
			maxd1,DR1[I1],maxd2, DR2[I2], HapSite[i],Hcuts[i],Hcuts[i]+DelCum[i], startY1[I1+1]-startY1[I1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		      fflush(stdout);
		    }
		  } else if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		    printf("Region T=%d (%0.3f..%0.3f,IN1=%d,I1=%d) active:biggestD1[T]=%d,Delta[i=%d]=%0.4f->%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y1[I1+]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN1,I1,biggestD1[T], i, Delta[i], Delta[i] + nDelta[i], maxd1,DR1[I1],maxd2,DR2[I2],
			HapSite[i], Hcuts[i],Hcuts[i]+DelCum[i], startY1[I1+1]-startY1[I1],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		    fflush(stdout);
	          }

		  /* increase biggestD1[T], if needed, to match biggestD */
		  if(DELTA_SCAN_FIX && T != IN1 && fabs(Initial_Delta[IN1][0] - Initial_Delta[T][0]) > MIN_DELTA * 0.001){
		    while(biggestD1[T] < localINITIAL_DELTA_RANGE - 1 && Initial_Delta[T][biggestD1[T]] + MIN_DELTA*0.001 < Initial_Delta[IN1][biggestD])
		      biggestD1[T]++;
		  } else if(biggestD > biggestD1[T])
		    biggestD1[T] = biggestD;
		  if(DEBUG) assert(0 <= biggestD1[T] && biggestD1[T] < localINITIAL_DELTA_RANGE && DELTA_RANGE[T] <= localINITIAL_DELTA_RANGE);
		}

		if(DEBUG) assert(maxd2 < DR2[I2]);
		biggestD = maxd2 % DELTA_RANGE[IN2];	      
		for(int T = max(0,IN2-DELTA_SCAN); T <= IN2 + DELTA_SCAN && T <= maxIN; T++){
		  if(DELTA_SCAN_FIX && biggestD1[T] < 0){
		    activecnt++;
		    if(DELTA_RANGE[T] <= 0){		      // copy Initial_Delta[T] from Initial_Delta[IN2]
		      newactivecnt++;
		      if(DEBUG) assert(T != IN1);
		      for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
			Initial_Delta[T][k] = Initial_Delta[IN2][k];
		      // WAS50 biggestD1[T] = biggestD;
		    } // WAS50 else
		    biggestD1[T] = 0;// updated below

		    if(HAPSTOP_DEBUG || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		      if(DELTA_RANGE[T] > 0)
			printf("Activating region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) with Delta[=%0.3f..%0.3f: Delta[i=%d]=%0.4f->%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y2[I2]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			       T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2,Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],i, Delta[i], Delta[i] + nDelta[i], 
			       maxd1,DR1[I1],maxd2, DR2[I2], HapSite[i],Hcuts[i],Hcuts[i]+DelCum[i], startY2[I2+1]-startY2[I2],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		      else
			printf("Re-Activating region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) with IDelta[0]=%0.3f..: Delta[i=%d]=%0.4f->%0.4f(d1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y2[I2]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			       T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2,Initial_Delta[T][0],i, Delta[i], Delta[i] + nDelta[i], 
			       maxd1,DR1[I1],maxd2, DR2[I2], HapSite[i],Hcuts[i],Hcuts[i]+DelCum[i], startY2[I2+1]-startY2[I2],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		      fflush(stdout);
		    }
		  } else if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		    printf("Region T=%d (%0.3f..%0.3f,IN2=%d,I2=%d) active:biggestD1[T]=%d,Delta[i=%d]=%0.4f->%0.4f(maxd1=%d/%d,d2=%d/%d),HapSite[i]=%d,Hcuts[i]=%0.3f,%0.3f,Y2[I2+]=%0.3f:LP=%0.6f->%0.6f,DELTA_RANGE[T]=%d\n",
			   T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, IN2,I2,biggestD1[T],i, Delta[i], Delta[i] + nDelta[i], maxd1,DR1[I1],maxd2, DR2[I2],
			   HapSite[i],Hcuts[i],Hcuts[i]+DelCum[i], startY2[I2+1]-startY2[I2],LPstart, LPd[maxd1], DELTA_RANGE[T]);
		    fflush(stdout);
		  }
		  
		  /* increase biggestD1[T], if needed, to match biggestD */
		  if(DELTA_SCAN_FIX && T != IN2 && fabs(Initial_Delta[IN2][0] - Initial_Delta[T][0]) > MIN_DELTA * 0.001){
		    while(biggestD1[T] < localINITIAL_DELTA_RANGE - 1 && Initial_Delta[T][biggestD1[T]] + MIN_DELTA*0.001 < Initial_Delta[IN2][biggestD])
		      biggestD1[T]++;
		  } else if(biggestD > biggestD1[T])
		    biggestD1[T] = biggestD;
		  if(DEBUG) assert(0 <= biggestD1[T] && biggestD1[T] < localINITIAL_DELTA_RANGE && DELTA_RANGE[T] <= localINITIAL_DELTA_RANGE);
		}
	      }
	      if(HAPSTOP_DEBUG>=2 || (DEBUG_CONVERGE && iter>=DEBUG_CONVERGE)){
		printf("i=%d:Delta[i]= %0.4f -> %0.4f(d1=%d/%d,d2=%d/%d,D1[I1=%d]=%d,D2[I2=%d]=%d) : LP=%0.8f -> %0.8f (Hcuts[i]=%0.4f,%0.4f,Hcuts[i..R]=%0.4f,L=%d,R=%d),HapSite[L,i,R]=%d,%d,%d\n",
		       i,Delta[i], Delta[i] + nDelta[i], maxd1, DR1[I1],maxd2,DR2[I2],I1, D1[I1],I2,D2[I2], LPstart, LPd[maxd1], Hcuts[i],Hcuts[i]+DelCum[i],Hcuts[R]-Hcuts[i],L,R,HapSite[L],HapSite[i],HapSite[R]);
		printf("\t IN1=%d(%0.3f..%0.3f),IN2=%d(%0.3f..%0.3f):Y1[I1+]=%0.3f,Y2[I2+]=%0.3f, biggestD1[IN1,IN2]=%d,%d,DELTA_RANGE[IN1,IN2]=%d,%d\n",
		       IN1,(IN1-0.5)*DELTA_INTERVAL, (IN1+0.5)*DELTA_INTERVAL,IN2,(IN2-0.5)*DELTA_INTERVAL,(IN2+0.5)*DELTA_INTERVAL,startY1[I1+1]-startY1[I1],startY2[I2+1]-startY2[I2],
		       biggestD1[IN1],biggestD1[IN2],DELTA_RANGE[IN1],DELTA_RANGE[IN2]);
		printf("\t ibest=%d(type=%d,LP=%0.8f), progress=%d(%d,%d), iter=%d(LPbest=%0.8f,tbest=%d),cum=%0.6f\n",
		       ibest,tbest,LPbest,progress,hapdeltacnt,deltacnt, iter,LPbest,tbest,wtime());
		if(VERB>=2){
		  double origDelta = Delta[i];
		  for(int d1 = 0; d1 < DR1[I1]; d1++){
		    int d2 = LPd2[d1];
		    if(d1 < 0)
		      continue;
		    if(DEBUG) assert(fabs(delta1[I1][d1] - delta2[I2][d2]) < MIN_INDEL_SIZE);
		    if(range1 + delta1[I1][d1] < minKB || range2 + delta1[I2][d2] < minKB)
		      continue;
		    if(VERB>=4 && iter==11){
		      Delta[i] += delta1[I1][d1];
		      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		      double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[L],Hcuts1[R],Hcuts2[L],Hcuts2[R],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		      printf("d1=%2d,d2=%2d:Hcuts[i..R]->%6.3f(change=%6.3f), LPd[d1]=%0.8f(change=%0.8f):hLP=%0.8f(err=%0.8f),SNPs=%d,Indels=%d\n", 
			     d1, d2, delta1[I1][d1] + Delta[i] + Hcuts[R] - Hcuts[i], delta1[I1][d1], LPd[d1], LPd[d1] - LPstart, hLP, LPd[d1]-hLP, SNPs,Indels);
		      Delta[i] = origDelta;
		    } else
		      printf("d1=%2d,d2=%2d:Hcuts[i..R]->%6.4f(change=%6.4f), LPd[d1]=%0.8f(change=%0.8f)\n", d1, d2, delta1[I1][d1] + Delta[i] + Hcuts[R] - Hcuts[i], delta1[I1][d1], LPd[d1], LPd[d1] - LPstart);
		  }
		}
		fflush(stdout);
	      }
	      if(LPd[maxd1] > LPbest + 2e-9){
		ibest = i;
		Lbest = L;
		Rbest = R;
		LLbest = LL;
		RRbest = RR;
		tbest = 2;
		LPbest = LPd[maxd1];
		range1best = range1;
		range2best = range2;
	      }
	    }
	  } // if(maxd1 >=0 && maxd2 >= 0)
	} // if(Hsizes && HINDELITER(iter) && HapSite[i])

        if(VERB>=3 && iter==11 && i==3617){/* call hprobeval() for a specific HapDelta change */
	  int LL = 3617, RR = 3622;
	  int ibest = i;
	  //	  int Lbest = LL;
	  int Rbest = RR;
	  double origHapDelta = HapDelta[ibest];
	  //	  double origHapDeltaL = HapDelta[Lbest];
	  double origDelta = Delta[ibest];
	  //	  double origDeltaL = Delta[Lbest];


	  int remapped = 0;
	  memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	  memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	  memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));

	  int block = 1;
	  while(block < 16 && MD > numthreads * block)
	    block *= 2;

	  /* need to backup map1[],map2[] */
#pragma omp parallel for schedule(static,block) num_threads(numthreads)
	  for(int m = 0; m < MD; m++){
	    int M = MX[m];
	    memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
	    memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
	    memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
	    memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
	  }
	  
	  //	  for(double nHapDeltai = -4.474; nHapDeltai < 5.0; nHapDeltai += 8.958){
	  //	  int I1 = 3022, I2 = 2941, d1=0, d2= 120;
	  //	  double incHapDelta = 0.5 * (delta1[I1][d1] - delta2[I2][d2]);
	  //	  double incDelta = 0.5 *  (delta1[I1][d1] + delta2[I2][d2]);

          double nHapDeltaV[7] = {-0.145, -0.1555, -0.165, -0.175, -0.185, -0.195, -0.205};
	  double incDelta[3] = {-0.224, -0.225, -0.226};

	  for(int t = 0; t < 7; t++){
	   for(int u = 0; u < 3; u++){
            double nHapDeltai = nHapDeltaV[t];
	    double nHapDelta2i = incDelta[u];

	    HapDelta[ibest] = origHapDelta + nHapDeltai;
	    Delta[ibest] = origDelta + nHapDelta2i;
	
	    if(VERB/* HERE >=2 */){
	      printf("Testing%d HapDelta[%d]=%0.8f->%0.8f (tot=%0.6f->%0.6f), Delta=%0.8f->%0.8f, Hcuts[%d..%d]=%0.4f->%0.4f:\n\t\t progress=%d(%d,%d),changes=%d,iter=%d,SNPcnt=%d,Indelcnt=%d->%d,minKB=%0.3f\n",
		     t,ibest, origHapDelta, HapDelta[ibest], HapDeltaMerged[ibest], HapDeltaMerged[ibest] + nHapDeltai, origDelta, Delta[ibest],
	        ibest,Rbest,Hcuts[Rbest]-Hcuts[ibest]+origDelta, Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest], 
	        progress, hapdeltacnt, deltacnt, changecnt, iter, SNPcnt, IndelCnt, 
	        IndelCnt + (fabs(HapDeltaMerged[ibest] + nHapDelta[ibest]) >= MIN_INDEL_SIZE ? 1 : 0) - (HapDeltaMerged[ibest] ? 1 : 0), minKB);
	      fflush(stdout);
	    }
	  
	    if(HapDeltaSpread(n,LLbest,RRbest,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){/* can happen due to combination of two valid HapDelta changes */
	      printf("HapDeltaSpread() failed\n");
	      fflush(stdout);
	    } else {
	      remapped |= correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,LLbest,RRbest,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);

	      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */	 
	    
	      rverb = 2;
	      double nLP1 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				      TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2, Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    
	      rverb = 0;
	      printf("\t test hprobeval after changing HapDelta[%d]=%0.8f -> %0.8f:nLP1=%0.8f(delta=%0.8f,SNPs=%d,Indels=%d)\n",
		     ibest, origHapDelta, origHapDelta + nHapDeltai, nLP1, nLP1-newLP,SNPs, Indels);
	      fflush(stdout);
	    }

	    /* restore original values */
	    memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		
	    if(remapped){ /* need to restore map1[],map2[] */
	      int block = 1;
	      while(block < 16 && MD > numthreads * block)
		block *= 2;

#pragma omp parallel for schedule(static,block) num_threads(numthreads)
	      for(int m = 0; m < MD; m++){
	        int M = MX[m];
		memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
	      }
	      remapped = 0;
	    }
	   }
	  }
	}

      Lcheckbest:
	/* check if previous best improvment is far enough back that it can be confirmed as locally optimal */
	if(ibest >= 1 && (i >= imax || (Hcuts[i] - Hcuts[(SNP_SCAN_FIX && !tbest) ? ibest : RRbest] >= HSCANRANGE*Xlambda && (!LEFTEXT_FIX || i >= ileft)))){
	  changes[progress] = ibest;
	  tchanges[progress++] = tbest;

	  if(VERB>=3  && ibest==7746 && iter == 2){
	    printf("iter=%d:i=%d,imax=%d,ibest=%d,tbest=%d,Lbest=%d,Rbest=%d,LLbest=%d,RRbest=%d,changecnt=%d,HapDeltaMerged[ibest]=%0.6f,nHapDelta[ibest]=%0.6f,LPbest=%0.6f,SNPcnt=%d,IndelCnt=%d,hapsitecnt=%d,cum=%0.6f\n",
		   iter,i,imax,ibest,tbest,Lbest,Rbest,LLbest,RRbest,changecnt,HapDeltaMerged[ibest],nHapDelta[ibest],LPbest,SNPcnt,IndelCnt,hapsitecnt,wtime());
	    fflush(stdout);
	  }

	  int origchangecnt = changecnt;
	  double origLP = newLP;/* in case we cannot confirm change */
	  int scorecorrected = 0;

	  /* now make the change and validate the actual LP value */
	  if(changecnt <= 0 || tbest >= 2 || (tbest ? (fabs(HapDeltaMerged[ibest] + nHapDelta[ibest]) < MIN_INDEL_SIZE) : 
					      (nHapSite[ibest]==0 || nHapSite[ibest]==3))){/* no need to check phasing of new HaploType */
	    int origHapSite = HapSite[ibest];
	    double origHapDelta = HapDelta[ibest];
	    double origDelta = Delta[ibest];
	    double origHapDeltaL = HapDelta[Lbest];/* original value of HapDelta[Lbest] before being merged with HapDelta[ibest] */
	    double origDeltaL = Delta[Lbest];/* original value of Delta[Lbest] before being merged with Delta[ibest] */
	    int remapped = 0;/* 1 IFF map1,map2,mapK1,mapK2 were changed due to HapDeltaSpread & correctmapH */

	    /* need to save all HapDelta[LLbest .. RRbest-1] and Delta[LLbest .. RRbest-1] */
	    int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	    memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	    memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));
	    
	    int block = 1;
	    while(block < 16 && MD > numthreads * block)
	      block *= 2;
	    
	    /* need to backup map1[],map2[] */
            #pragma omp parallel for schedule(static,block) num_threads(numthreads)
	    for(int m = 0; m < MD; m++){
	      int M = MX[m];
	      memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
	      memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
	      memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
	      memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
	    }

	    if(VERB>=3 && ibest==7746){
	      printf("After saving HapDelta[%d..%d] and Delta[%d..%d] : cum=%0.6f\n",LLbest,RRbest,LLbest,RRbest,wtime());
	      fflush(stdout);
	    }

	    changecnt++;/* If changecnt was 0 : should be no need to confirm since this is the first change since mprobeval() was called */

	    if(VERB>=3 && (iter==ITER_ID && ibest==SITE_ID && tbest==0 && origHapSite==1 && nHapSite[ibest]==SNP_ID)){/* display hprobeval before changing HapSite[ibest] */
	      printf("Before Changing HapSite[%d]=%d -> %d (LP = %0.6f -> %0.6f), HapDelta[ibest]=%0.3f : i=%d,Hcuts[ibest]=%0.3f,Hcuts[i]=%0.3f progress=%d(%d),changes=%d,iter=%d,SNPcnt=%d,IndelCnt=%d:\n",
		     ibest,HapSite[ibest],nHapSite[ibest], LPstart, LPsite[ibest], HapDelta[ibest], i, Hcuts[ibest],Hcuts[i],progress,hapdeltacnt,changecnt,iter,SNPcnt,IndelCnt);
	      fflush(stdout);

	      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	      rverb = 1;
	      double LPb = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
	                     TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2, /* 0  */bestLPA1, /* 0  */bestLPA2, 0.0, Y1[N1+1], 0.0, Y2[N2+1], 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      rverb = 0;
	      printf("\t hprobeval=%0.6f,SNPs=%d,Indels=%d\n",LPb,SNPs,Indels);
	    
	      fflush(stdout);
	      rverb = 0;
	    }

	    if(tbest==0){/* change in HapSite[ibest] */
	      if(DEBUG) assert(LPsite[ibest] > LPstart);
	      if(VERB){
		printf("Changing HapSite[%d]= %d -> %d (LP= %0.8f -> %0.8f) : i=%d,Hcuts[ibest]=%0.4f,%0.4f,Hcuts[i]=%0.4f, progress=%d(%d,%d),changes=%d,iter=%d,SNPcnt=%d, IndelCnt=%d\n",
		       ibest,HapSite[ibest],nHapSite[ibest], LPstart, LPsite[ibest], i, Hcuts[ibest],Hcuts[ibest]+DelCum[ibest],Hcuts[i],progress,hapdeltacnt,deltacnt,changecnt,iter,SNPcnt, IndelCnt);
		if(VERB/* HERE >=2 */)
	          printf("\t Lbest=%d,Rbest=%d,n=%d:Hcuts[Lbest]=%0.4f,Hcuts[Rbest]=%0.4f,Hcuts[n+1]=%0.4f,LLbest=%d,RRbest=%d,HapSite[%d,%d,%d,%d,%d]=%d,%d,%d,%d,%d,Delta[Lbest]=%0.4f,HapDelta[Lbest]=%0.4f\n",
		    Lbest,Rbest,n,Hcuts[Lbest],Hcuts[Rbest],Hcuts[n+1],LLbest,RRbest,LLbest,Lbest,ibest,Rbest,RRbest,HapSite[LLbest],HapSite[Lbest],HapSite[ibest],HapSite[Rbest],HapSite[RRbest],Delta[Lbest],HapDelta[Lbest]);
		//		printf("\t HapDelta[959]= %0.6f, HapDelta[961]= %0.6f\n",HapDelta[959],HapDelta[961]);
		fflush(stdout);
	      }
	      HapSite[ibest] = nHapSite[ibest];
	      newLP = origLP + (LPsite[ibest] - LPstart);
	      if(HPROBEVAL_SPREAD <= 1 && HapSite[ibest] && !origHapSite){
		if(DEBUG && !(Hcuts[Rbest]-Hcuts[Lbest]+origDeltaL - fabs(origHapDeltaL) >= 0.0)){
		  printf("Lbest=%d,Rbest=%d,HapSite[Lbest,Rbest]=%d,%d,Hcuts[Lbest]=%0.6f,Hcuts[Rbest]=%0.6f,origDeltaL=%0.6f,origHapDeltaL=%0.6f,minKB=%0.6f\n",
			 Lbest,Rbest,HapSite[Lbest],HapSite[Rbest],Hcuts[Lbest],Hcuts[Rbest],origDeltaL,origHapDeltaL,minKB);
		  fflush(stdout);
		  assert(Hcuts[Rbest]-Hcuts[Lbest] + origDeltaL - fabs(origHapDeltaL) >= 0.0);
		}

		if(Delta[Lbest] /* && Rbest <= n */){/* divide Delta[Lbest] across 2 intervals */
		  if(DEBUG && Rbest <= n) assert(HapSite[Rbest]);
		  double scale = origDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
		  Delta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
		  Delta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
		  if(VERB){
		    printf("\t Splitting Delta[Lbest=%d]=%0.8f -> %0.8f + Delta[ibest=%d]=%0.8f (Hcuts[Lbest]=%0.8f,Hcuts[ibest]=%0.8f,Hcuts[Rbest=%d]=%0.8f)\n",
			   Lbest,origDeltaL,Delta[Lbest], ibest, Delta[ibest], Hcuts[Lbest],Hcuts[ibest],Rbest,Hcuts[Rbest]);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(fabs(Delta[Lbest] + Delta[ibest] - origDeltaL) < MIN_INDEL_SIZE);
		}
		if(HapDelta[Lbest] /* && Rbest <= n */){/* divide HapDelta[Lbest] across 2 intervals */
		  if(DEBUG && Rbest <= n) assert(HapSite[Rbest]);
		  if(DEBUG) assert(Lbest < ibest && Hcuts[Lbest] < Hcuts[ibest]);
		  if(DEBUG) assert(ibest < Rbest && Hcuts[ibest] < Hcuts[Rbest]);

		  double scale = origHapDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
		  HapDelta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
		  HapDelta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
		  if(VERB){
		    printf("\t Splitting HapDelta[Lbest=%d]=%0.8f -> %0.8f + HapDelta[ibest=%d]=%0.8f (Hcuts[Lbest]=%0.8f,Hcuts[ibest]=%0.8f,Hcuts[Rbest=%d]=%0.8f)\n",
			   Lbest,origHapDeltaL,HapDelta[Lbest], ibest, HapDelta[ibest], Hcuts[Lbest],Hcuts[ibest],Rbest,Hcuts[Rbest]);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(fabs(HapDelta[Lbest] + HapDelta[ibest] - origHapDeltaL) < MIN_INDEL_SIZE);
		}
		if(DEBUG && !(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) >= 0.0)){
		  printf("\nLbest=%d,ibest=%d,Rbest=%d,n=%d,HapSite[Lbest,ibest,Rbest]=%d,%d,%d,Hcuts[ibest]=%0.8f,Hcuts[Rbest]=%0.8f,Delta[ibest]=%0.8e,HapDelta[ibest]=%0.8e,minKB=%0.6f\n",
			 Lbest,ibest,Rbest,n,HapSite[Lbest],HapSite[ibest],HapSite[Rbest],Hcuts[ibest],Hcuts[Rbest],Delta[ibest],HapDelta[ibest],minKB);
		  printf("\n\t Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) = %0.8e, Hcuts[Rbest]-Hcuts[ibest]= %0.8e\n",
			 Hcuts[Rbest]-Hcuts[ibest]+Delta[ibest]-fabs(HapDelta[ibest]), Hcuts[Rbest]-Hcuts[ibest]);
		  printf("\n\t origDeltaL= %0.8f, origHapDeltaL= %0.8f\n", origDeltaL, origHapDeltaL);
		  fflush(stdout);
		  assert(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) >= -1e-10);
		}
		if(DEBUG && !(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) >= 0.0)){
		  printf("\nLbest=%d,ibest=%d,HapSite[Lbest,ibest]=%d,%d,Hcuts[Lbest]=%0.6f,Hcuts[ibest]=%0.6f,Delta[Lbest]=%0.6f,HapDelta[Lbest]=%0.6f,minKB=%0.6f\n",
			 Lbest,ibest,HapSite[Lbest],HapSite[ibest],Hcuts[Lbest],Hcuts[ibest],Delta[Lbest],HapDelta[Lbest],minKB);
		  fflush(stdout);
		  assert(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) >= -1e-10);
		}
		/* other ways to divide HapDelta[Lbest] will be handled later (Is this really needed, since the spread method is the one seen by mprobeval ?) */
	      }

	      if(HPROBEVAL_SPREAD <= 1 && !HapSite[ibest]){
		if(DEBUG>=2){
		  int Lb = ibest - 1;
		  while(Lb >= 1 && !HapSite[Lb])
		    Lb--;
		  if(DEBUG && !(Lb>= 1 && HapSite[Lb] && Lb == Lbest)){
		    printf("i=%d,ibest=%d:HapSite[ibest]=%d->%d,Lb=%d,Lbest=%d,HapSite[Lb]=%d,HapSite[Lbest]=%d\n",i,ibest,origHapSite,HapSite[ibest],Lb,Lbest,HapSite[Lb],HapSite[Lbest]);
		    fflush(stdout);
		    if(DEBUG) assert(Lb == Lbest);
		    if(DEBUG) assert(Lb <= 0 || HapSite[Lb]);
		  }
		}

		if(HapDelta[ibest]){/* Indel HapDelta[ibest] needs to be moved/merged with HapDelta[Lbest] */
		  if(DEBUG && !(Lbest > 0 && HapSite[Lbest])){
		    printf("tbest=%d:ibest=%d,Lbest=%d,Rbest=%d,n=%d(imin=%d,imax=%d):HapSite[Lbest,ibest,Rbest]=%d,%d,%d,HapDelta[ibest]=%0.6e\n",
			   tbest,ibest,Lbest,Rbest,n,imin,imax,HapSite[Lbest],HapSite[ibest],HapSite[Rbest],HapDelta[ibest]);
		    fflush(stdout);
		    assert(Lbest > 0 && HapSite[Lbest]);
		  }
		  HapDelta[Lbest] += HapDelta[ibest];
		  if(fabs(HapDelta[Lbest]) < MIN_INDEL_SIZE)
		    HapDelta[Lbest] = 0.0;
		  if(VERB){
		    printf("\t Merging HapDelta[ibest=%d]=%0.4f with HapDelta[Lbest=%d]=%0.4f -> %0.4f\n",ibest,HapDelta[ibest],Lbest, origHapDeltaL, HapDelta[Lbest]);
		    fflush(stdout);
		  }
		  HapDelta[ibest] = 0.0;
		}
		if(Delta[ibest]){/* Delta[ibest] needs to be moved/merged with Delta[Lbest] */
		  Delta[Lbest] += Delta[ibest];
		  if(VERB){
		    printf("\t Merging Delta[ibest=%d]=%0.4f with Delta[Lbest=%d]=%0.4f -> %0.4f\n",ibest,Delta[ibest],Lbest, origDeltaL, Delta[Lbest]);
		    fflush(stdout);
		  }
		  Delta[ibest] = 0.0;
		}
	      }
	    } else if(tbest==1){ /* first HapDelta change (to HapDelta[ibest]) in this iteration (or HapDelta[ibest] is being reset to 0) */
	      if(DEBUG) assert(LPindel[ibest] > LPstart);
	      if(DEBUG) assert(HapSite[ibest]);
	      if(DEBUG) assert(isfinite(HapDeltaMerged[ibest]));
	      if(VERB){
		if(VERB>=3 && (iter==97 && fabs(origHapDelta+nHapDelta[ibest] - (-0.3959)) < 0.0001)){
		  printf("Before Changing HapDelta[%d]=%0.4f->%0.4f:SNPs=%d,Indels=%d\n",
			 ibest,HapDelta[ibest],origHapDelta+nHapDelta[ibest],SNPcnt,IndelCnt);

		  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		  //		  rverb = 1;
		  double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0 /* bestLPA1*/,0 /*bestLPA2*/,0.0,Y1[N1+1],0.0,Y2[N2+1],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  //		  rverb = 0;
		  printf("hprobeval=%0.8f,origLP=%0.8f(err=%0.8f),SNPs=%d,Indels=%d\n",hLP,origLP,hLP-origLP,SNPs,Indels);
		  fflush(stdout);
		}
		printf("Changing HapDelta[ib=%d]=%0.4f->%0.4f(tot=%0.4f->%0.4f),Delta[ib]=%0.4f->%0.4f,Hcuts[ib..%d]=%0.3f->%0.3f(LP=%0.6f->%0.6f):Hcuts[ib]=%0.3f,%0.3f,Hcuts[i=%d]=%0.3f,progress=%d(%d,%d),changes=%d,iter=%d,SNPs=%d,Indels=%d->%d,LL=%d,RR=%d,HapSite[LL,RR]=%d,%d\n", 
			 ibest, origHapDelta, origHapDelta+nHapDelta[ibest], HapDeltaMerged[ibest], HapDeltaMerged[ibest]+nHapDelta[ibest],
			 origDelta, origDelta+nHapDelta2[ibest], Rbest, Hcuts[Rbest]-Hcuts[ibest]+origDelta, Hcuts[Rbest]-Hcuts[ibest]+origDelta+nHapDelta2[ibest],
			 LPstart, LPindel[ibest], Hcuts[ibest], Hcuts[ibest]+DelCum[ibest], i, Hcuts[i], progress, hapdeltacnt, deltacnt, changecnt, iter, SNPcnt,IndelCnt,
			 IndelCnt + ((fabs(HapDeltaMerged[ibest]+nHapDelta[ibest]) >= MIN_INDEL_SIZE) ? 1 : 0) - ((HapDeltaMerged[ibest] != 0.0) ? 1 : 0),
			 LLbest,RRbest,HapSite[LLbest],HapSite[RRbest]);
	      
		fflush(stdout);
	      }
	      HapDelta[ibest] = origHapDelta + nHapDelta[ibest];
	      Delta[ibest] = origDelta + nHapDelta2[ibest];
	      if(HapDeltaSpread(n,LLbest,RRbest,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){/* Should never happen : give up */
		changecnt--;
		newLP = origLP;

		int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
		memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		

		tbest = ibest = -1;
		LPbest = LPstart;
		continue;
	      }
	      remapped |= correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,LLbest,RRbest,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);

	      newLP = origLP + (LPindel[ibest] - LPstart);
	    } else {/* change in Delta[ibest] */
	      if(DEBUG) assert(tbest==2);
	      if(DEBUG) assert(LPdelta[ibest] > LPstart);
	      if(VERB){
		if(DEBUG>=2){
		  int Rb = ibest+1;
		  while(Rb <= n && !HapSite[Rb])
		    Rb++;
		  if(DEBUG) assert(Rb > n || HapSite[Rb]);
		  if(DEBUG) assert(Rb == Rbest);
		}

		printf("Changing Hcuts[%d..%d]= %0.4f -> %0.4f (LP= %0.6f -> %0.6f, delta=%0.8f) : i=%d,Hcuts[ibest]=%0.4f,%0.4f,Hcuts[Rbest]=%0.4f,%0.4f,Hcuts[i]=%0.3f\n\t\t HapDelta[ibest]=%0.4f,HapSite[ibest,Rbest]=%d,%d,progress=%d(%d,%d),changes=%d,iter=%d,SNPs=%d,Indels=%d\n",
		       ibest,Rbest, Hcuts[Rbest]-Hcuts[ibest]+Delta[ibest], Hcuts[Rbest]-Hcuts[ibest]+Delta[ibest] + nDelta[ibest], LPstart, LPdelta[ibest], LPdelta[ibest]-LPstart, i, Hcuts[ibest], Hcuts[ibest]+DelCum[ibest], 
	      Hcuts[Rbest], Hcuts[Rbest] + DelCum[Rbest], Hcuts[i], HapDelta[ibest], HapSite[ibest], HapSite[Rbest], progress, hapdeltacnt, deltacnt, changecnt, iter,SNPcnt,IndelCnt);
		if((VERB>=3 && iter==127 && fabs(Hcuts[Rbest] - Hcuts[ibest]+Delta[ibest] - 2.7977) < 0.001 /*ibest==9787*/) || DEBUG>=2){
		  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		  //		  if(iter==33 && fabs(Hcuts[Rbest] - Hcuts[ibest]+Delta[ibest] - 21.6904) < 0.001 /*ibest==9787*/) rverb = 1;
		  double LPb = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2, 0 /*bestLPA1*/, 0 /*bestLPA2*/, 0.0, Y1[N1+1], 0.0, Y2[N2+1], 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if((DEBUG && !(fabs(LPb - origLP) < max(1e-6, 1e-9 * fabs(origLP)))) || VERB/* HERE >=3 */){
		    printf("\t WARNING: Original hprobeval=%0.8f,origLP=%0.8f(err=%0.8f),SNPs=%d,Indels=%d\n",LPb,origLP,LPb-origLP,SNPs,Indels);
		    fflush(stdout);
		  }
		  //		  if(DEBUG /* && rverb */) assert(LPb >= origLP - max(1e-5, 1e-6 * fabs(origLP)));/* this can fail because a previous update did not do a complete hprobeval */
		  //		  rverb = 0;
		}

		fflush(stdout);
	      }

	      Delta[ibest] += nDelta[ibest];
	      if(HapDeltaSpread(n,LLbest,RRbest,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){/* Should never happen : give up */
		changecnt--;
		newLP = origLP;

		int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
		memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		

		tbest = ibest = -1;
		LPbest = LPstart;
		continue;
	      }
	      remapped |= correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,LLbest,RRbest,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);

	      newLP = origLP + (LPdelta[ibest] - LPstart);
	    } // change in Delta[ibest]

	    double wstart = wtime();// HERE HERE

	    /* confirm newLP and update bestLPA[] */
	    int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	    if(VERB>=3){
	      double wt = wtime();
	      printf("After hsetmap: wall= %0.6f (cum= %0.6f)\n",wt-wstart,wt);
	      fflush(stdout);
	    }
	    if(err){
	      if(VERB/* HERE >=2 */){
		printf("\t WARNING:hsetmap failed (eg when trying to divide an interval that is already close to minKB = %0.6f on one Allele)\n",minKB);
		fflush(stdout);
	      }

	      newLP = origLP;
	      HapSite[ibest] = origHapSite;

	      /* change could be due to tbest == 0, 1 or 2 */
	      int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	      memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		
	      if(DEBUG) assert(HapSite[ibest] == origHapSite);
	      if(remapped){ /* need to restore map1[],map2[] */
	        int block = 1;
	        while(block < 16 && MD > numthreads * block)
		  block *= 2;
	      
                #pragma omp parallel for schedule(static,block) num_threads(numthreads)
	        for(int m = 0; m < MD; m++){
		  int M = MX[m];
		  memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		  memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		  memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		  memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
	        }
	        remapped = 0;
	      }

	      if(DEBUG/* HERE >=2 */){/* verify that LP is restored to original value */
		hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */	    
		int SNPs,Indels;
		//		rverb = (iter==ITER_ID && ibest==SITE_ID) ? 1 : 0;
		double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				       TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2, bestLPA1, bestLPA2,Hcuts1[Lbest],Hcuts1[Rbest],Hcuts2[Lbest],Hcuts2[Rbest],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		int LPerr = (fabs(nLP - origLP) < max(1e-6, 1e-8 * fabs(origLP)) && SNPs == SNPcnt && Indels == IndelCnt) ? 0 : 1;
		if(LPerr || VERB>=1+RELEASE){
		  //		  rverb = (iter==33) ? 1 : 0;
		  double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					  TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  printf("%sFailed to restore origLP=%0.8f: nLP=%0.8f (err=%0.8f), nLP2=%0.8f (err=%0.8f), SNPs=%d -> %d, Indels=%d -> %d(iter=%d,ibest=%d,rverb=%d)\n",
			 LPerr ? "WARNING: Failed to restore " : "Restored ", origLP,nLP,nLP-origLP,nLP2,nLP2-origLP,SNPcnt,SNPs,IndelCnt,Indels,iter,ibest,rverb);
		  
		  for(int m = 0; m < MD; m++){
		    if(fabs(testLPA1[m]-bestLPA1[m]) >= 1e-6)
		      printf("WARNING:m=%d:testLPA1[m]= %0.6f,bestLPA1[m]=%0.6f(err=%0.6f),newLPA1[m]=%0.6f\n",m,testLPA1[m],bestLPA1[m],testLPA1[m]-bestLPA1[m],newLPA1[m]);
		    if(fabs(testLPA2[m]-bestLPA2[m]) >= 1e-6)
		      printf("WARNING:m=%d:testLPA2[m]= %0.6f,bestLPA2[m]=%0.6f(err=%0.6f),newLPA2[m]=%0.6f\n",m,testLPA2[m],bestLPA2[m],testLPA2[m]-bestLPA2[m],newLPA2[m]);
		  }
		  fflush(stdout);

		  if(!RELEASE) assert(fabs(nLP - origLP) < max(1e-5 , 1e-7*fabs(origLP)) && SNPs == SNPcnt && Indels == IndelCnt);
		  
		  origLP = newLP = nLP2;
		  SNPcnt = SNPs;
		  IndelCnt = Indels;
		  /* swap newLPA,bestLPA (to improve accuracy of bestLPA) */
		  double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp; // WAS5 bestLPA1 = tmp;
		  tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;
		}
		//		rverb = 0;
	      }

	      tbest = ibest = -1;// NEW45
	      LPbest = LPstart;// NEW45

	      continue;
	    }
	    if(VERB>=3){
	      printf("N1=%d,N2=%d\n",N1,N2);
	      for(int t = 1; t <= n; t++)
		printf("i=%d:HapSite[i]=%d,Hdel1[i]=%d,Hdel2[i]=%d,Hcuts2[i]=%0.3f\n",t,HapSite[t],Hdel1[t],Hdel2[t],Hcuts2[t]);
	      fflush(stdout);
	    }

	    if(DEBUG>=3 && changecnt <= 1){
	      for(int m = 0; m < MD; m++){
		if(!(fabs(bestLPA1[m]-startLPA1[m]) < 1e-6)){
		  {
		    printf("m=%d:bestLPA1[m]=%0.8f,startLPA1[m]=%0.8f\n",m,bestLPA1[m],startLPA1[m]);
		    fflush(stdout);
		    assert(fabs(bestLPA1[m]-startLPA1[m]) < 1e-6);
		  }
		}
		if(!(fabs(bestLPA2[m]-startLPA2[m]) < 1e-6)){
		  {
		    printf("m=%d:bestLPA2[m]=%0.8f,startLPA2[m]=%0.8f\n",m,bestLPA2[m],startLPA2[m]);
		    fflush(stdout);
		    assert(fabs(bestLPA1[m]-startLPA1[m]) < 1e-6);
		  }
		}
	      }
	    }

	    if(VERB>=3 && iter==127 && fabs(Hcuts[Rbest]-Hcuts[ibest]+Delta[ibest]+nDelta[ibest] - 2.7977) < 0.001 /* && ibest==9616 */ /* && origHapSite==3 && HapSite[ibest]==1*/) rverb = 1;

	    /* NOTE : cannot use Y1[I1]..Y1[I1+1] as range of changes since Y1[] has been previously updated and I1 indexes the original startY1[0..startN1+1] */
	    if(DEBUG) assert(Lbest <= ibest && Rbest >= ibest);
	    if(SNP_TRACE && iter==ITER_ID && (ibest== SITE_ID /* || best==247*/))
	      rverb = 1;
	    //	    rverb = (iter >= ITER_ID && ibest == SITE_ID) ? 1 : 0;
	    //	    tverb = 2;
	    double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[Lbest],Hcuts1[Rbest],Hcuts2[Lbest],Hcuts2[Rbest],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    rverb = 0;

	    if((DEBUG>=2 && iter==ITER_ID && ibest==SITE_ID) /*||(iter==ITER_ID && tbest >= 1 && nLP > origLP + HLP_MINDELTA) */ || nLP > newLP + 1.0
	       || (!FAST_HPROBEVAL && tbest <= 1 && nLP > origLP + HLP_MINDELTA) 
	       || (DEBUG>=2 && changecnt <= 1 && !(tbest==0 && HapSite[ibest] && HapDelta[Lbest]) && !(fabs(nLP - newLP) < max(1e-5, 1e-7 * fabs(newLP))))){
	      /* check full hprobeval(), without using bestLPA1[],bestLPA2[] */
	      //	      if(iter==36 && ibest==772 && origHapSite==2 && HapSite[ibest]==0)	rverb = 1;
	      double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      rverb = 0;
	      if(VERB){
		if(fabs(nLP-LP) >= 1e-6 || (changecnt <= 1 && !(tbest==0 && HapSite[ibest] && HapDelta[Lbest]) && !(fabs(LP - newLP) < max(1e-5, 1e-10 * fabs(newLP)))))
		  printf("\t WARNING:hprobeval after change:nLP=%0.8f, LP=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), expected newLP=%0.8f(err=%0.8f),origLP=%0.8f,LRANGE=%d\n",
			 nLP,LP, fabs(nLP-LP), SNPs,Indels,newLP,LP-newLP,origLP, LRANGE);
		else
		  printf("\t hprobeval after change:nLP=%0.8f, LP=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), expected newLP=%0.8f(err=%0.8f),origLP=%0.8f,LRANGE=%d\n",
		         nLP,LP, fabs(nLP-LP), SNPs,Indels,newLP,LP-newLP,origLP, LRANGE);
		if(VERB>=3 && iter==35 && tbest >= 1 && 212 < MD)
		  for(int m = 212; m <= 212; m++)
		    printf("\t    m=%d:newLPA1[m]= %0.6f, testLPA1[m]= %0.6f (err= %0.6f), bestLPA1[m]= %0.6f\n",m, newLPA1[m], testLPA1[m], newLPA1[m]-testLPA1[m],bestLPA1[m]);
		fflush(stdout);
	      }
#if 1
	      nLP = LP;
	      /* swap testLPA & newLPA1 */
	      double *tmp = testLPA1; testLPA1 = newLPA1; newLPA1 = tmp;
	      tmp = testLPA2; testLPA2 = newLPA2; newLPA2 = tmp;
#endif
	    } else if(VERB/* HERE >=2 */){
	      double w = wtime();
	      printf("\t quick hprobeval after change:nLP=%0.8f(SNPs=%d,Indels=%d), expected newLP=%0.8f(err=%0.8f) origLP=%0.8f,LRANGE=%d, (wall=%0.6f, cum=%0.6f sec)\n",
		     nLP, SNPs,Indels, newLP, nLP-newLP, origLP, LRANGE, w-wstart,w);
//	      printf("\t HapDelta[959]= %0.6f, HapDelta[961]= %0.6f\n",HapDelta[959],HapDelta[961]);
	      fflush(stdout);
	    }

	    if(DEBUG && changecnt <= 1 && !(tbest==0 && HapSite[ibest] && HapDelta[Lbest]) && !(fabs(nLP - newLP) < max(1e-5, 1e-7 * fabs(newLP)))){
	      //	      changecnt--;
	      if(tbest <= 1)
		printf("\t Failed to confirm HaploType change with newLP=%0.8f : nLP=%0.8f(err=%0.8f), origLP=%0.8f (progress=%d(%d,%d),changes=%d,iter=%d)\n",
		       newLP, nLP, nLP-newLP, origLP, progress, hapdeltacnt, deltacnt, changecnt, iter);
	      else
		printf("\t Failed to confirm interval change with newLP=%0.8f : nLP=%0.8f(err=%0.8f) (progress=%d(%d,%d),changes=%d,iter=%d)\n",
		       newLP, nLP, nLP-newLP, progress, hapdeltacnt, deltacnt, changecnt, iter);
	      printf("\t   N1=%d,Y1[N1]=%0.3f,N2=%d,Y2[N2]=%0.3f,Hcuts[ibest]=%0.3f,Hcuts1[ibest]=%0.3f,Hcuts2[ibest]=%0.3f\n",
		     N1,Y1[N1],N2,Y2[N2],Hcuts[ibest],Hcuts1[ibest],Hcuts2[ibest]);
	      printf("\t   Lbest=%d,Rbest=%d,Hcuts[Lbest]=%0.3f,Hcuts[Rbest]=%0.3f\n",Lbest,Rbest,Hcuts[Lbest],Hcuts[Rbest]);
	    
	      if(nLP < origLP)
		for(int t = LLbest; t <= RRbest; t++)
		  printf("\t   t=%d:HapSite[t]=%d,HapDelta[t]=%0.3f,Delta[t]=%0.3f,Hcuts[t]=%0.3f\n",t,HapSite[t],HapDelta[t],Delta[t],Hcuts[t]);
	      fflush(stdout);

	      //	      if(DEBUG>=3) assert(fabs(nLP - newLP) < (HPROBEVAL_SPREAD ? 1e-7 : 1e-2) * fabs(newLP));

	      //	      changecnt++;

	      //	    if(MDEBUG) exit(1);
	    }

	    if(tbest==0 && HSNP_FAST && fabs(nLP - newLP) > 1e-6){/* update LP[][ibest] and HapSiteScore[ibest],SiteScore[ibest] */
	      for(int h = 0; h <= 3; h++)
		LPsnp[h] = LP[h][ibest] + LPstart;
	      int h = nHapSite[ibest];
	      LPsnp[h] = LPsnp[origHapSite] + nLP - origLP;

	      /* no need to check for HapSiteRes, since it was already checked previously for ibest to be considered here */

	      for(int t = 0; t <= 3; t++){// NEW137 : make sure LPsnp[h] is the best scoring option
		LPsnp[t] = min(LPsnp[h],LPsnp[t]);
		LP[t][ibest] = LPsnp[t] - LPstart;
	      }

	      double origHapSiteScore = HapSiteScore[ibest];
	      double origSiteScore = SiteScore[ibest];
	      HapSiteScore[ibest] = max(LPsnp[1],LPsnp[2]) - max(LPsnp[0],LPsnp[3]);
	      SiteScore[ibest] = LPsnp[3] - LPsnp[0];

	      scorecorrected = 1;

	      if(VERB/* HERE >=2 */){
		printf("\t Updated HapSiteScore[%d] = %0.6f -> %0.6f, SiteScore[%d] = %0.6f -> %0.6f (LPsnp[0,1,2,3]=%0.6f,%0.6f,%0.6f,%0.6f,LPstart=%0.6f)\n\t HapSite[%d]=%d -> %d, LP=%0.6f -> %0.6f\n",
		       ibest, origHapSiteScore,HapSiteScore[ibest], ibest, origSiteScore, SiteScore[ibest], LPsnp[0],LPsnp[1],LPsnp[2],LPsnp[3],LPstart,ibest,origHapSite,HapSite[ibest], origLP, nLP);
		fflush(stdout);
	      }
	    }

	    if(HapSite[ibest] && !origHapSite && HapDelta[Lbest]){/* try alternate ways of distributing origHapDeltaL */
	      if(DEBUG>=2){
		assert(tbest==0);
		for(int t = Lbest+1; t < Rbest; t++)
		  if(t != ibest && !(HapDelta[t] == 0.0)){
		    printf("iter=%d:i=%d,ibest=%d,tbest=%d,origHapSite=%d,HapSite[ibest]=%d,Lbest=%d,Rbest=%d,HapDelta[Lbest]=%0.4f,HapDelta[t=%d]=%0.4f\n",
			   iter,i,ibest,tbest,origHapSite,HapSite[ibest],Lbest,Rbest,HapDelta[Lbest],t,HapDelta[t]);
		    fflush(stdout);
		    assert(HapDelta[t] == 0.0);
		  }
	      }

	      int SNPs2,Indels2;
	      double nLP2 = nLP;

	      /* first try distributing origHapDeltaL as much as possible on left side */
	      // NOTE : the following minKB check is too stringent, since it does not verify which Allele is involved
	      // WAS	      HapDelta[Lbest] = copysign(min(fabs(origHapDeltaL),Hcuts[ibest] - Hcuts[Lbest] + Delta[Lbest] - minKB), origHapDeltaL) ;
	      if(HapSite[Lbest] & HapSite[ibest]){/* NEW69 : Hcuts[Lbest] & Hcuts[ibest] share same Allele, so need to enforce minKB */
		HapDelta[Lbest] = copysign(min(fabs(origHapDeltaL),max(0.0,Hcuts[ibest] - Hcuts[Lbest] + Delta[Lbest] - minKB)), origHapDeltaL) ;
	      } else {/* Hcuts[Lbest] & Hcuts[ibest] do not share same Allele, so NO need to enforce minKB */
		HapDelta[Lbest] = copysign(min(fabs(origHapDeltaL),max(0.0,Hcuts[ibest] - Hcuts[Lbest] + Delta[Lbest])), origHapDeltaL) ;
	      }
	      HapDelta[ibest] = origHapDeltaL - HapDelta[Lbest];
	      if(VERB){
		//		printf("\t origHapDeltaL=%0.6f,Hcuts[ibest]=%0.6f,Hcuts[Lbest]=%0.6f,Delta[Lbest]=%0.6f,minKB=%0.6f\n",origHapDeltaL,Hcuts[ibest],Hcuts[Lbest],Delta[Lbest],minKB);
		printf("\t Alternately splitting leftmost HapDelta[Lbest=%d]=%0.4f -> %0.4f + HapDelta[ibest=%d]=%0.4f:",
		       Lbest,origHapDeltaL, HapDelta[Lbest], ibest,HapDelta[ibest]);
		fflush(stdout);
	      }
	      if(DEBUG) assert(HapDelta[Lbest] * HapDelta[ibest] >= 0.0);
	      if(DEBUG && !(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) >= 0.0)){
		printf("\nLbest=%d,ibest=%d,HapSite[Lbest,ibest]=%d,%d,Hcuts[Lbest]=%0.6f,Hcuts[ibest]=%0.6f,Delta[Lbest]=%0.6f,HapDelta[Lbest]=%0.6f,minKB=%0.6f\n",
		       Lbest,ibest,HapSite[Lbest],HapSite[ibest],Hcuts[Lbest],Hcuts[ibest],Delta[Lbest],HapDelta[Lbest],minKB);
		fflush(stdout);
		assert(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) >= -1e-10);
	      }
	      if(!(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) >= 0.0)){
		printf("Invalid split\n");
		fflush(stdout);
		nLP2 = nLP - BigPen;
	      } else {
		double wstart = wtime();// HERE HERE
		hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */	    
		nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				 TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[Lbest],Hcuts1[Rbest], Hcuts2[Lbest], Hcuts2[Rbest], 0,0,0,0,newLPA,pcontig,numthreads,SNPs2,Indels2,0);
		if(VERB){
		  double w = wtime();
		  printf("quick hprobeval=%0.6f(SNPs=%d,Indels=%d) (wall=%0.6f, cum=%0.6f)%c\n",nLP2,SNPs2,Indels2, w-wstart,w,(nLP2 > nLP) ? '!':' ');
		  //		  printf("\t HapDelta[959]= %0.6f, HapDelta[961]= %0.6f\n",HapDelta[959],HapDelta[961]);
		  fflush(stdout);
		}
		if(DEBUG>=2 || (!FAST_HPROBEVAL && nLP2 > nLP && nLP2 > origLP + HLP_MINDELTA)){
		  double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB){
		    printf("\t hprobeval after change:nLP2=%0.8f, LP=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), origLP=%0.8f,LRANGE=%d\n",nLP2,LP, fabs(nLP2-LP), SNPs,Indels, origLP, LRANGE);
		    fflush(stdout);
		  }
		  if(DEBUG>=2) assert(fabs(LP - nLP2) < 1e-6);
		  nLP2 = LP;
		}
	      }
	      if(nLP2 > nLP){   /* swap testLPA,newLPA */
		//		if(nLP2 > nLP + 1e-4){// this case has been verified 
		//		  printf("WARNING: Alternate distribution of HapDelta[] improved LP=%0.8f to %0.8f (delta=%0.8f)!\n", newLP, nLP2, nLP2-newLP);
		//		  fflush(stdout);
		  //		assert(0);
		//		}
		double *tmp = testLPA1; testLPA1 = newLPA1; newLPA1 = tmp;
		tmp = testLPA2; testLPA2 = newLPA2; newLPA2 = tmp;
	      }

	      int SNPs3,Indels3;
	      double nLP3 = nLP;

	      /* next try distributing origHapDeltaL as much as possible on the right side */
	      // NOTE : the following minKB check is too stringent, since it does not verify which Allele is involved
	      if(HapSite[Rbest] & HapSite[ibest]){/* NEW69: Hcuts[Rbest] & Hcuts[ibest] share same Allele, so need to enforce minKB */
		HapDelta[ibest] = copysign(min(fabs(origHapDeltaL),max(0.0,Hcuts[Rbest] - Hcuts[ibest] + Delta[ibest] - minKB)), origHapDeltaL);
	      } else {/* Hcuts[Rbest] & Hcuts[ibest] do not share same Allele, so NO need to enforce minKB */
		HapDelta[ibest] = copysign(min(fabs(origHapDeltaL),max(0.0,Hcuts[Rbest] - Hcuts[ibest] + Delta[ibest])), origHapDeltaL);
	      }

	      HapDelta[Lbest] = origHapDeltaL - HapDelta[ibest];
	      if(VERB){
		printf("\t Alternately splitting rightmost HapDelta[Lbest=%d]=%0.4f -> %0.4f + HapDelta[ibest=%d]=%0.4f:",
		       Lbest,origHapDeltaL, HapDelta[Lbest], ibest,HapDelta[ibest]);
		fflush(stdout);
	      }
	      if(DEBUG && !(HapDelta[Lbest] * HapDelta[ibest] >= 0.0)){
		printf("HapDelta[Lbest]=%0.8e, HapDelta[ibest]= %0.8e, Hcuts[Rbest=%d]=%0.6f,Hcuts[ibest]=%0.6f,Delta[ibest]=%0.6f,minKBadd=%0.6f\n",
		       HapDelta[Lbest],HapDelta[ibest],Rbest,Hcuts[Rbest],Hcuts[ibest],Delta[ibest],minKBadd);
		fflush(stdout);
		assert(HapDelta[Lbest] * HapDelta[ibest] >= 0.0);
	      }
	      if(DEBUG && !(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) >= 0.0)){
		printf("ibest=%d,Rbest=%d,HapSite[ibest,Rbest]=%d,%d,Hcuts[ibest]=%0.6f,Hcuts[Rbest]=%0.6f,Delta[ibest]=%0.6f,HapDelta[ibest]=%0.6f,minKB=%0.6f\n",
		       ibest,Rbest,HapSite[ibest],HapSite[Rbest],Hcuts[ibest],Hcuts[Rbest],Delta[ibest],HapDelta[ibest],minKB);
		fflush(stdout);
		assert(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) > -1e-10);
	      }
	      if(!(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) > 0.0)){
		printf("Invalid split\n");
		fflush(stdout);
		nLP3 = nLP - BigPen;
	      } else {

		double wstart = wtime();// HERE HERE

		hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */	    
		nLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				 TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[Lbest],Hcuts1[Rbest],Hcuts2[Lbest],Hcuts2[Rbest],0,0,0,0,newLPA,pcontig,numthreads,SNPs3,Indels3,0);
		if(VERB){
		  double w = wtime();
		  printf("quick hprobeval=%0.6f(SNPs=%d,Indels=%d), (wall=%0.6f,cum=%0.6f)%c\n",nLP3,SNPs3,Indels3, w-wstart,w,(nLP3 > nLP2 && nLP3 > nLP) ? '!' : ' ');
		  //		  printf("\t HapDelta[959]= %0.6f, HapDelta[961]= %0.6f\n",HapDelta[959],HapDelta[961]);
		  fflush(stdout);
		}
		if(DEBUG>=2 || (!FAST_HPROBEVAL && nLP3 > nLP && nLP3 > nLP2 && nLP3 > origLP + HLP_MINDELTA)){
		  double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB){
		    printf("\t hprobeval after change:nLP3=%0.8f, LP=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), origLP=%0.8f,LRANGE=%d\n",nLP3,LP, fabs(nLP3-LP), SNPs,Indels, origLP, LRANGE);
		    fflush(stdout);
		  }
		  if(DEBUG>=2) assert(fabs(LP - nLP3) < 1e-6);
		  nLP3 = LP;
		}
	      }
	      if(nLP3 > nLP2 && nLP3 > nLP){
		//		if(nLP3 > nLP + 1e-4){// verified
		//		  printf("WARNING:Alternate distribution of HapDelta[] improved LP=%0.8f to %0.8f (delta=%0.8f)!\n", newLP, nLP3, nLP3-newLP);
		//		  fflush(stdout);
		//		assert(0);
		//		}

		double *tmp = testLPA1; testLPA1 = newLPA1; newLPA1 = tmp;
		tmp = testLPA2; testLPA2 = newLPA2; newLPA2 = tmp;
	      }

	      /* No need to correct for HINDEL_MERGE since only HapDelta[Lbest] is involved in the range Hcuts[Lbest .. Rbest] */
	      if(nLP3 > nLP2){
		if(nLP3 <= nLP){/* restore proportional split */
		  double scale = origHapDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
		  HapDelta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
		  HapDelta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
		  if(VERB>=1+RELEASE){
		    printf("\tConfirming proportional split: HapDelta[Lbest=%d]= %0.6f, HapDelta[ibest=%d]= %0.6f\n",Lbest,HapDelta[Lbest],ibest,HapDelta[ibest]);
		    //		    printf("\t HapDelta[959]= %0.6f, HapDelta[961]= %0.6f\n",HapDelta[959],HapDelta[961]);
		    fflush(stdout);
		  }
		} else {/* leave at rightmost split */
		  nLP = nLP3;
		  SNPs = SNPs3;
		  Indels = Indels3;
		  if(VERB>=1+RELEASE){
		    printf("\t Confirming rightmost split: HapDelta[Lbest=%d]= %0.6f, HapDelta[ibest=%d]= %0.6f\n",Lbest,HapDelta[Lbest],ibest,HapDelta[ibest]);
		    //		    printf("\t HapDelta[959]= %0.6f, HapDelta[961]= %0.6f\n",HapDelta[959],HapDelta[961]);
		  }
		}
	      } else {
		if(nLP2 < nLP){/* restore proportional split */
		  double scale = origHapDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
		  HapDelta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
		  HapDelta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
		  if(VERB>=1+RELEASE){
		    printf("\t Confirming proportional split: HapDelta[Lbest=%d]= %0.6f, HapDelta[ibest=%d]= %0.6f\n",Lbest,HapDelta[Lbest],ibest,HapDelta[ibest]);
		    //		    printf("\t HapDelta[959]= %0.6f, HapDelta[961]= %0.6f\n",HapDelta[959],HapDelta[961]);
		  }
		} else {/* restore leftmost split */
		  nLP = nLP2;
		  SNPs = SNPs2;
		  Indels = Indels2;
		  //		  HapDelta[Lbest] = copysign(min(fabs(origHapDeltaL), /*NEW69*/max(0.0, Hcuts[ibest] - Hcuts[Lbest] + Delta[Lbest] - minKB)), origHapDeltaL) ;
		  if(HapSite[Lbest] & HapSite[ibest]){/* NEW69 : Hcuts[Lbest] & Hcuts[ibest] share same Allele, so need to enforce minKB */
		    HapDelta[Lbest] = copysign(min(fabs(origHapDeltaL),max(0.0,Hcuts[ibest] - Hcuts[Lbest] + Delta[Lbest] - minKB)), origHapDeltaL) ;
		  } else {/* Hcuts[Lbest] & Hcuts[ibest] do not share same Allele, so NO need to enforce minKB */
		    HapDelta[Lbest] = copysign(min(fabs(origHapDeltaL),max(0.0,Hcuts[ibest] - Hcuts[Lbest] + Delta[Lbest])), origHapDeltaL) ;
		  }
		  HapDelta[ibest] = origHapDeltaL - HapDelta[Lbest];
		  if(VERB>=1+RELEASE){
		    //		    printf("\t origHapDeltaL=%0.6f,Hcuts[ibest]=%0.6f,Hcuts[Lbest]=%0.6f,Delta[Lbest]=%0.6f,minKB=%0.6f\n",origHapDeltaL,Hcuts[ibest],Hcuts[Lbest],Delta[Lbest],minKB);
		    printf("\t Confirming leftmost split: HapDelta[Lbest=%d]= %0.6f, HapDelta[ibest=%d]= %0.6f\n",Lbest,HapDelta[Lbest],ibest,HapDelta[ibest]);
		    //		    printf("\t HapDelta[959]= %0.6f, HapDelta[961]= %0.6f\n",HapDelta[959],HapDelta[961]);
		  }
		}
	      }
	    }

	    if(nLP <= origLP + HLP_MINDELTA){/* failed to confirm change : should be rare if HSCANRANGE is large enough */
	      changecnt--;
	      if(VERB){
		if(changecnt > 0)
		  printf("WARNING:Failed to confirm non-HaploType change with newLP=%0.8f : nLP=%0.8f(err=%0.8f), reverting to origLP=%0.8f (progress=%d(%d,%d),changes=%d,iter=%d)\n",
			 newLP, nLP, nLP-newLP, origLP, progress, hapdeltacnt, deltacnt, changecnt, iter);
		else
		  printf("WARNING:Failed to confirm HaploType change with newLP=%0.8f : nLP=%0.8f(err=%0.8f), reverting to origLP=%0.8f (progress=%d(%d,%d),changes=%d,iter=%d)\n",
			 newLP, nLP, nLP-newLP, origLP, progress, hapdeltacnt, deltacnt, changecnt, iter);
		fflush(stdout);
	      }
	      newLP = origLP;
	      HapSite[ibest] = origHapSite;

	      /* change could be due to tbest == 0, 1 or 2 */
	      int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	      memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		
	      if(DEBUG) assert(HapSite[ibest] == origHapSite);
	      if(remapped){ /* need to restore map1[],map2[] */
	        int block = 1;
		while(block < 16 && MD > numthreads * block)
		  block *= 2;

                #pragma omp parallel for schedule(static,block) num_threads(numthreads)
		for(int m = 0; m < MD; m++){
	          int M = MX[m];
		  memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		  memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		  memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		  memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
		}
		remapped = 0;
	      }

	      if(DEBUG>=2){/* verify that LP is restored to original value (otherwise will be verified only at next HapDelta change) */
	        hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */	    
		int SNPs,Indels;
		//		rverb = (iter==33 && ibest==9787) ? 1 : 0;
		double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				       TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[Lbest],Hcuts1[Rbest],Hcuts2[Lbest],Hcuts2[Rbest],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		if(!(fabs(nLP - origLP) < max(1e-6, 1e-10*fabs(origLP)) && SNPs == SNPcnt && Indels == IndelCnt) || VERB>=2){
		  //		  rverb = (iter==33) ? 1 : 0;
		  double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					  TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  printf("WARNING: Failed to restore origLP=%0.8f: nLP=%0.8f (err=%0.8f), nLP2=%0.8f (err=%0.8f), SNPs=%d -> %d, Indels=%d -> %d(iter=%d,ibest=%d,rverb=%d)\n",
			 origLP,nLP,nLP-origLP,nLP2,nLP2-origLP,SNPcnt,SNPs,IndelCnt,Indels,iter,ibest,rverb);
		  
		  for(int m = 0; m < MD; m++){
		    if(fabs(newLPA1[m]-bestLPA1[m]) >= 1e-6)
		      printf("m=%d:testLPA1[m]= %0.6f,bestLPA1[m]=%0.6f(err=%0.6f),newLPA1[m]=%0.6f\n",m,testLPA1[m],bestLPA1[m],testLPA1[m]-bestLPA1[m],newLPA1[m]);
		    if(fabs(newLPA2[m]-bestLPA2[m]) >= 1e-6)
		      printf("m=%d:testLPA2[m]= %0.6f,bestLPA2[m]=%0.6f(err=%0.6f),newLPA2[m]=%0.6f\n",m,testLPA2[m],bestLPA2[m],testLPA2[m]-bestLPA2[m],newLPA2[m]);
		  }
		  fflush(stdout);
		  if(!RELEASE && HMAP_TMPFIX) assert(nLP >= origLP - max(1e-5, 1e-6 * fabs(origLP)));/* this can fail because a previous update did not do a complete hprobeval */
		  origLP = newLP = nLP;
		  SNPcnt = SNPs;
		  IndelCnt = Indels;

		  /* swap newLPA,bestLPA (to improve accuracy of bestLPA) */
		  double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		  tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		}
		//		rverb = 0;
	      }
	    } else { /* confirm change : swap newLPA and bestLPA */
	      if(tbest == 0 && nLP > origLP + LP_SITE_MINDELTA)
		hapsitecnt++;
	      if(tbest == 1 && nLP > origLP + LP_INDEL_MINDELTA)
		hapdeltacnt++;
	      if(tbest == 2 && nLP > origLP + LP_INTERVAL_MINDELTA)
		deltacnt++;

	      newLP = nLP;
	      /* swap bestLPA and newLPA */
	      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;

	      SNPcnt = SNPs;
	      IndelCnt = Indels;
	    }
	  } else {/* changecnt >= 1 && tbest<=1 : need to check phasing of new HaploType it may interact with previous changes due to phase linkage */
	    int origHapSite = HapSite[ibest];
	    double origHapDelta = HapDelta[ibest];
	    double origHapDeltaL = HapDelta[Lbest];
	    double origDelta = Delta[ibest];
	    double origDeltaL = Delta[Lbest];

	    if(tbest==0){/* HapSite[ibest] change */
	      if(DEBUG) assert(nHapSite[ibest] == 1 || nHapSite[ibest] == 2);

	      int bestHapSite = HapSite[ibest];
	      double bestHapDelta = HapDelta[ibest];
	      double bestHapDeltaL = HapDelta[Lbest];
	      double bestDelta = Delta[ibest];
	      double bestDeltaL = Delta[Lbest];
	      int bestSNPcnt = SNPcnt;
	      int bestIndelCnt = IndelCnt;

	      if(VERB/* HERE HERE >=3 */ && (SNP_TRACE && iter==ITER_ID && (ibest== SITE_ID /*||ibest==247*/) /* && origHapSite==0*/)){/* display hprobeval before changing HapSite[ibest] */
		printf("Before Changing HapSite[%d]=%d -> %d (LP = %0.6f -> %0.6f) : i=%d,Hcuts[ibest]=%0.3f,Hcuts[i]=%0.3f, progress=%d(%d,%d),changes=%d,iter=%d:\n",
		       ibest,HapSite[ibest],nHapSite[ibest], LPstart, LPsite[ibest], i, Hcuts[ibest],Hcuts[i],progress,hapdeltacnt,deltacnt,changecnt,iter);
		fflush(stdout);

		hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		rverb = 1;
		(void)hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0/*bestLPA1*/,0/*bestLPA2*/,0.0,Y1[N1+1],0.0,Y2[N2+1],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		rverb = 0;
	      }

	      /* recompute LP with HapSite[ibest] = nHapSite[ibest] */
	      HapSite[ibest] = nHapSite[ibest];
	      if(DEBUG) assert(HapSite[ibest] != 0);/* no need to handle indel merger */

	      int HapDelCnt = 1;
	      if(HPROBEVAL_SPREAD <= 1 && !origHapSite){
		if((DEBUG && !(Hcuts[Rbest]-Hcuts[Lbest]+origDeltaL - fabs(origHapDeltaL) > 0.0)) /* || (iter==26 && ibest==981 && IndelCnt==1 && SNPcnt == 10)*/){
		  printf("WARNING:Before testing HapSite[%d]=%d -> %d (LP= %0.8f -> %0.8f): progress=%d(%d,%d),changes=%d,iter=%d,SNPcnt=%d->%d,Indelcnt=%d\n",
			 ibest, origHapSite, nHapSite[ibest], LPstart, LPsite[ibest], progress, hapdeltacnt, deltacnt, changecnt, iter,
			 SNPcnt, SNPcnt + ((1<=HapSite[ibest] && HapSite[ibest]<=2)?1:0) +((1<=origHapSite && origHapSite<=2)?1:0),IndelCnt);
		  for(int t = Lbest; t <= Rbest; t++)
		    if(HapSite[t] || HapDelta[t] || Delta[t])
		      printf("  t=%d:HapSite[t]=%d,Hcuts[t]=%0.6f,Delta[t]=%0.6f,HapDelta[t]=%0.6f\n",t,HapSite[t],Hcuts[t],Delta[t],HapDelta[t]);
		  printf("ibest=%d,Lbest=%d,Rbest=%d,n=%d:HapSite[Lbest,ibest,Rbest]=%d,%d->%d,%d,Hcuts[Lbest]=%0.6f,Hcuts[ibest]=%0.6f,Hcuts[Rbest]=%0.6f,origDeltaL=%0.6f,origHapDeltaL=%0.6f,minKB=%0.6f\n",
			 ibest,Lbest,Rbest,n,HapSite[Lbest],origHapSite,nHapSite[ibest],HapSite[Rbest],Hcuts[Lbest],Hcuts[ibest],Hcuts[Rbest],origDeltaL,origHapDeltaL,minKB);
		  printf("\t Hcuts[Rbest] - Hcuts[Lbest] + origDeltaL - fabs(origHapDeltaL) = %0.6e\n",Hcuts[Rbest] - Hcuts[Lbest] + origDeltaL - fabs(origHapDeltaL));
		  fflush(stdout);
		  assert(Hcuts[Rbest] - Hcuts[Lbest] + origDeltaL - fabs(origHapDeltaL) > -1e-8 /* WAS 0.0 */);
		}
		if(Delta[Lbest] /* && Rbest <= n */){/* divide Delta[Lbest] across 2 intervals */
		  if(DEBUG && Rbest <= n) assert(HapSite[Rbest]);
		  double scale = origDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
		  Delta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
		  Delta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
		  if(VERB>=2){
		    printf("\t Splitting Delta[Lbest=%d]=%0.8f -> %0.8f + Delta[ibest=%d]=%0.8f (Hcuts[Lbest]=%0.8f,Hcuts[ibest]=%0.8f,Hcuts[Rbest=%d]=%0.8f)\n",
			   Lbest,origDeltaL,Delta[Lbest], ibest, Delta[ibest], Hcuts[Lbest],Hcuts[ibest],Rbest,Hcuts[Rbest]);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(fabs(Delta[Lbest] + Delta[ibest] - origDeltaL) < MIN_INDEL_SIZE);
		}
		if(HapDelta[Lbest] /* && Rbest <= n */){
		  if(DEBUG && Rbest <= n && !HapSite[Rbest]){
		    printf("Before testing HapSite[%d]=%d -> %d (LP= %0.8f -> %0.8f): progress=%d(%d,%d),changes=%d,iter=%d,SNPcnt=%d->%d,Indelcnt=%d\n",
			 ibest, origHapSite, nHapSite[ibest], LPstart, LPsite[ibest], progress, hapdeltacnt, deltacnt, changecnt, iter,
			 SNPcnt, SNPcnt + ((1<=HapSite[ibest] && HapSite[ibest]<=2)?1:0) +((1<=origHapSite && origHapSite<=2)?1:0),IndelCnt);
		    printf("    i=%d,ibest=%d,Lbest=%d,Rbest=%d,n=%d,HapSite[Rbest]=%d\n",i,ibest,Lbest,Rbest,n,HapSite[Rbest]);
		    for(int t = Lbest; t <= n; t++)
		      printf("t=%d:HapSite[t]=%d,Hcuts[t]=%0.4f,Delta[t]=%0.4f,HapDelta[t]=%0.4f\n",t,HapSite[t],Hcuts[t],Delta[t],HapDelta[t]);
		    fflush(stdout);
		    assert(HapSite[Rbest]);
		  }
		  double scale = origHapDeltaL / (Hcuts[Rbest]-Hcuts[Lbest]);
		  HapDelta[Lbest] = scale * (Hcuts[ibest]-Hcuts[Lbest]);
		  HapDelta[ibest] = scale * (Hcuts[Rbest]-Hcuts[ibest]);
		  if(VERB){
		    printf("\t Splitting HapDelta[Lbest=%d]=%0.8f -> %0.8f + HapDelta[ibest=%d]=%0.8f (Hcuts[Lbest]=%0.8f,Hcuts[ibest]=%0.8f,Hcuts[Rbest=%d]=%0.8f)\n",
			   Lbest,origHapDeltaL,HapDelta[Lbest], ibest, HapDelta[ibest], Hcuts[Lbest],Hcuts[ibest],Rbest,Hcuts[Rbest]);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(fabs(HapDelta[Lbest] + HapDelta[ibest] - origHapDeltaL) < MIN_INDEL_SIZE);
		  HapDelCnt = (FAST_HPROBEVAL>=3) ? 1 : 3;	      /* other ways to divide HapDelta[Lbest] will be handled later (if 3) */
		}
		if(DEBUG && !(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) >= 0.0)){
		  printf("ibest=%d,Rbest=%d,HapSite[ibest,Rbest]=%d,%d,Hcuts[ibest]=%0.6f,Hcuts[Rbest]=%0.6f,Delta[ibest]=%0.6f,HapDelta[ibest]=%0.6f,minKB=%0.6f\n",
			 ibest,Rbest,HapSite[ibest],HapSite[Rbest],Hcuts[ibest],Hcuts[Rbest],Delta[ibest],HapDelta[ibest],minKB);
		  fflush(stdout);
		  assert(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) > -1e-10);
		}
		if(DEBUG && !(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) >= 0.0)){
		  printf("Lbest=%d,ibest=%d,HapSite[Lbest,ibest]=%d,%d,Hcuts[Lbest]=%0.6f,Hcuts[ibest]=%0.6f,Delta[Lbest]=%0.6f,HapDelta[Lbest]=%0.6f,minKB=%0.6f\n",
			 Lbest,ibest,HapSite[Lbest],HapSite[ibest],Hcuts[Lbest],Hcuts[ibest],Delta[Lbest],HapDelta[Lbest],minKB);
		  fflush(stdout);
		  assert(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) > -1e-10);
		}
	      }

	      for(int HDcnt = 1; HDcnt <= HapDelCnt; HDcnt++){
		HapSite[ibest] = nHapSite[ibest];// reset necessary for later iterations

		if(VERB/* HERE >=2 */){
		  if(VERB>=3 && SNP_TRACE && iter==ITER_ID && ibest==SITE_ID && origHapSite==3)
		    rverb = 1;
		  printf("Testing HapSite[ibest=%d]=%d -> %d (LP= %0.8f -> %0.8f): Hcuts[ibest]= %0.4f,%0.4f,Hcuts[i]=%0.4f, progress=%d(%d,%d),changes=%d,iter=%d,SNPcnt=%d->%d,Indelcnt=%d(HDcnt=%d)\n",
			 ibest, origHapSite, HapSite[ibest], LPstart, LPsite[ibest], Hcuts[ibest],Hcuts[ibest]+DelCum[ibest],Hcuts[i],progress, hapdeltacnt, deltacnt, changecnt, iter,
			 SNPcnt, SNPcnt + ((1<=HapSite[ibest] && HapSite[ibest]<=2)?1:0) +((1<=origHapSite && origHapSite<=2)?1:0),IndelCnt,HDcnt);
		  fflush(stdout);
		}

		if(HDcnt==1 && HPROBEVAL_SPREAD <= 1){
		  if(VERB){
		    if(origDeltaL)
		      printf("\t Splitting Delta[Lbest=%d]=%0.4f -> %0.4f + Delta[ibest=%d]=%0.4f (Hcuts[Lbest]=%0.4f,%0.4f,Hcuts[ibest]=%0.4f,%0.4f,Hcuts[Rbest=%d]=%0.4f,%0.4f,HapSite[Lbest,ibest,Rbest]=%d,%d,%d)\n",
			     Lbest,origDeltaL,Delta[Lbest], ibest, Delta[ibest], Hcuts[Lbest],Hcuts[Lbest]+DelCum[Lbest],Hcuts[ibest],Hcuts[ibest]+DelCum[ibest],Rbest,Hcuts[Rbest],Hcuts[Rbest]+DelCum[Rbest],
			     HapSite[Lbest],HapSite[ibest],HapSite[Rbest]);
		    if(origHapDeltaL)
		      printf("\t Splitting HapDelta[Lbest=%d]=%0.4f -> %0.4f + HapDelta[ibest=%d]=%0.4f (Hcuts[Lbest]=%0.4f,%0.4f,Hcuts[ibest]=%0.4f,%0.4f,Hcuts[Rbest=%d]=%0.4f,%0.4f,HapSite[Lbest,ibest,Rbest]=%d,%d,%d)\n",
			     Lbest,origHapDeltaL,HapDelta[Lbest], ibest, HapDelta[ibest], Hcuts[Lbest],Hcuts[Lbest]+DelCum[Lbest],Hcuts[ibest],Hcuts[ibest]+DelCum[ibest],Rbest,Hcuts[Rbest],Hcuts[Rbest]+DelCum[Rbest],
			     HapSite[Lbest],HapSite[ibest],HapSite[Rbest]);
		    fflush(stdout);
		  }
		}
		if(HDcnt==2){/* split HapDelta[Lbest] as much as possible on left side */
		  // WAS HapDelta[Lbest] = copysign(min(fabs(origHapDeltaL),Hcuts[ibest] - Hcuts[Lbest] + Delta[Lbest] - minKB), origHapDeltaL);
		  HapDelta[Lbest] = copysign(min(fabs(origHapDeltaL),max(0.0,Hcuts[ibest] - Hcuts[Lbest] + Delta[Lbest] - minKB)), origHapDeltaL) ;
		  HapDelta[ibest] = origHapDeltaL - HapDelta[Lbest];
		  if(VERB){
		    printf("\t Alternately splitting HapDelta[Lbest=%d]=%0.4f -> %0.4f + HapDelta[ibest=%d]=%0.4f\n",
			   Lbest,origHapDeltaL, HapDelta[Lbest], ibest,HapDelta[ibest]);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(HapDelta[Lbest] * HapDelta[ibest] >= 0.0);
		  if(DEBUG && !(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) >= 0.0)){
		    printf("Lbest=%d,ibest=%d,HapSite[Lbest,ibest]=%d,%d,Hcuts[Lbest]=%0.6f,Hcuts[ibest]=%0.6f,Delta[Lbest]=%0.6f,HapDelta[Lbest]=%0.6f,minKB=%0.6f\n",
			   Lbest,ibest,HapSite[Lbest],HapSite[ibest],Hcuts[Lbest],Hcuts[ibest],Delta[Lbest],HapDelta[Lbest],minKB);
		    fflush(stdout);
		    assert(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) > -1e-10);
		  }
		  if(!(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) > 0.0)){
		    printf("Invalid split:ibest=%d,Rbest=%d,HapSite[ibest,Rbest]=%d,%d,Hcuts[ibest]=%0.6f,Hcuts[Rbest]=%0.6f,Delta[ibest]=%0.6f,HapDelta[ibest]=%0.6f,minKB=%0.6f\n",
			   ibest,Rbest,HapSite[ibest],HapSite[Rbest],Hcuts[ibest],Hcuts[Rbest],Delta[ibest],HapDelta[ibest],minKB);
		    fflush(stdout);
		    continue;
		  }
		}
		if(HDcnt==3){	    /* next try distributing origHapDeltaL as much as possible on the right side */
		  // WAS HapDelta[ibest] = copysign(min(fabs(origHapDeltaL),Hcuts[Rbest] - Hcuts[ibest] + Delta[ibest] - minKB), origHapDeltaL);
		  HapDelta[ibest] = copysign(min(fabs(origHapDeltaL),max(0.0,Hcuts[Rbest] - Hcuts[ibest] + Delta[ibest] - minKB)), origHapDeltaL);
		  HapDelta[Lbest] = origHapDeltaL - HapDelta[ibest];
		  if(VERB){
		    printf("\t Alternately splitting HapDelta[Lbest=%d]=%0.4f -> %0.4f + HapDelta[ibest=%d]=%0.4f\n",
			   Lbest,origHapDeltaL, HapDelta[Lbest], ibest,HapDelta[ibest]);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(HapDelta[Lbest] * HapDelta[ibest] >= 0.0);
		  if(DEBUG && !(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) >= 0.0)){
		    printf("ibest=%d,Rbest=%d,HapSite[ibest,Rbest]=%d,%d,Hcuts[ibest]=%0.6f,Hcuts[Rbest]=%0.6f,Delta[ibest]=%0.6f,HapDelta[ibest]=%0.6f,minKB=%0.6f\n",
			   ibest,Rbest,HapSite[ibest],HapSite[Rbest],Hcuts[ibest],Hcuts[Rbest],Delta[ibest],HapDelta[ibest],minKB);
		    fflush(stdout);
		    assert(Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] - fabs(HapDelta[ibest]) > -1e-10);
		  }
		  if(!(Hcuts[ibest]-Hcuts[Lbest] + Delta[Lbest] - fabs(HapDelta[Lbest]) > 0.0)){
		    printf("Invalid split:Lbest=%d,ibest=%d,HapSite[Lbest,ibest]=%d,%d,Hcuts[Lbest]=%0.6f,Hcuts[ibest]=%0.6f,Delta[Lbest]=%0.6f,HapDelta[Lbest]=%0.6f,minKB=%0.6f\n",
			   Lbest,ibest,HapSite[Lbest],HapSite[ibest],Hcuts[Lbest],Hcuts[ibest],Delta[Lbest],HapDelta[Lbest],minKB);
		    fflush(stdout);
		    continue;
		  }
	        }

		if(DEBUG) assert(Lbest <= ibest && Rbest >= ibest);
		double nLP1 = newLP;

		double wstart = wtime(), mstart = mtime();// HERE HERE

		// NOTE there is a small chance minKB restriction is violated due to previous change being too close to current change
		int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		if(VERB>=2){
		  double wt = wtime(),mt = mtime();
		  printf("hsetmap=%d: CPU= %0.6f, wall= %0.6f (cum= %0.6f)\n", err, mt - mstart, wt - wstart, wt);
		  fflush(stdout);
		}
		if(err){
		  if(VERB/* HERE >=2 */){
		    printf("\t hprobeval failed due to hsetmap\n");
		    fflush(stdout);
		  }
		  continue;// next HDcnt value : for(HDcnt = 1; HDcnt <= HapDelCnt; HDcnt++)
		}

		//		tverb = 2;

		if(VERB/* HERE HERE >=3 */ && SNP_TRACE && iter==ITER_ID && (ibest== SITE_ID /* ||ibest==247*/) ){
		  printf("After Changing HapSite[%d]= %d -> %d calling hprobeval\n",ibest,origHapSite,nHapSite[ibest]);
		  fflush(stdout);

		  rverb = 1;
		}

		nLP1 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[Lbest],Hcuts1[Rbest],Hcuts2[Lbest],Hcuts2[Rbest],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		rverb = 0;
		if(DEBUG>=2 /* ||(iter==35 && tbest >= 1 && nLP1 > newLP + HLP_MINDELTA) */
		   || (!FAST_HPROBEVAL && nLP1 > newLP + HLP_MINDELTA)){/* check full hprobeval(), without using bestLPA1[],bestLPA2[] */
		  double LP1 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB){
		    if(fabs(LP1-nLP1) >= 1e-6)
		      printf("\t WARNING:hprobeval after changing HapSite[%d]=%d -> %d:nLP1=%0.8f, LP1=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), newLP=%0.8f,LRANGE=%d\n", 
			     ibest, origHapSite,HapSite[ibest],nLP1, LP1, fabs(nLP1 - LP1), SNPs, Indels, newLP,LRANGE);
		    else
		      printf("\t hprobeval after changing HapSite[%d]=%d -> %d:nLP1=%0.8f, LP1=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), newLP=%0.8f,LRANGE=%d\n", 
			     ibest, origHapSite,HapSite[ibest],nLP1, LP1, fabs(nLP1 - LP1), SNPs, Indels, newLP,LRANGE);
		    fflush(stdout);
		  }
		  nLP1 = LP1;
		} else if(VERB/* HERE >=2 */){
		  double wt = wtime(), mt = mtime();
		  if(HDcnt==1)
		    printf("\t quick hprobeval after change:nLP1=%0.8f(SNPs=%d,Indels=%d), predicted=%0.8f, origLP=%0.8f,LRANGE=%d, CPU= %0.6f, wall= %0.6f (cum= %0.6f secs)\n",
			   nLP1, SNPs, Indels, origLP + LPsite[ibest] - LPstart, origLP, LRANGE, mt-mstart,wt-wstart, wt);
		  else
		    printf("\t quick hprobeval after change:nLP1=%0.8f(SNPs=%d,Indels=%d), newLP=%0.8f, origLP=%0.8f,LRANGE=%d, CPU= %0.6f, wall= %0.6f (cum= %0.6f)\n",
			   nLP1, SNPs,Indels, newLP, origLP, LRANGE, mt-mstart,wt-wstart, wt);
		  fflush(stdout);
		}

		if(nLP1 > newLP + HLP_MINDELTA){
		  //		  if(HDcnt > 1 && nLP1 > newLP + 1e-4){// verified : proof that alternate arrangement of HapDelta[] or Delta[] is needed
		  //		    printf("WARNING:Alternate distribution of HapDelta[] and/or Delta[] improved LP=%0.8f to %0.8f (delta=%0.8f)!\n", newLP, nLP1, nLP1-newLP);
		  //		    fflush(stdout);
		    //		  assert(0);
		  //		  }		  

		  bestHapSite = nHapSite[ibest];
		  bestHapDelta = HapDelta[ibest];
		  bestHapDeltaL = HapDelta[Lbest];
		  bestDelta = Delta[ibest];
		  bestDeltaL = Delta[Lbest];
		  bestSNPcnt = SNPs;
		  bestIndelCnt = Indels;

		  newLP = nLP1;
		  /* swap newLPA and bestLPA */
		  double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		  tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		}

		double nLP2 = nLP1;
		if(nHapSite[ibest]==1 || nHapSite[ibest]==2){/* try opposite phasing : there is a risk that the minKB restriction is now violated */
		  HapSite[ibest] = 3 - nHapSite[ibest];

		  if(VERB/* HERE >=2 */){
		    printf("Reversing HapSite[%d]=%d -> %d : progress=%d(%d,%d),changes=%d,iter=%d,SNPcnt=%d->%d,IndelCnt=%d\n",
			   ibest, origHapSite, HapSite[ibest], progress, hapdeltacnt, deltacnt, changecnt, iter,
			   SNPcnt, SNPcnt + ((1<=HapSite[ibest] && HapSite[ibest]<=2)?1:0) +((1<=origHapSite && origHapSite<=2)?1:0),IndelCnt);
		    fflush(stdout);
		  }
		  if(DEBUG) assert(Lbest <= ibest && Rbest >= ibest);

		  double wstart = wtime();// HERE HERE
		  int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		  if(err) {
		    if(VERB/* HERE >=2 */){
		      printf("\t hprobeval failed due to hsetmap\n");
		      fflush(stdout);
		    }
		    nLP2 = newLP - BigPen;
		  } else {
		    if((VERB>=3 && ((ibest==1378 && origHapSite==3) || (ibest==1251 && origHapSite==0))) ||
		         (SNP_TRACE && iter==ITER_ID && (ibest== SITE_ID /* ||ibest==247*/))){
		      printf("After Changing HapSite[%d]= %d -> %d calling hprobeval\n",ibest,origHapSite,HapSite[ibest]);
		      fflush(stdout);
		      
		      rverb = 1;
		    }

		    nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[Lbest],Hcuts1[Rbest],Hcuts2[Lbest],Hcuts2[Rbest],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    rverb = 0;
		    if(DEBUG>=2 /*|| (iter==35 && tbest >= 1 && nLP2 > newLP + HLP_MINDELTA) */
		       || (!FAST_HPROBEVAL && nLP2 > newLP + HLP_MINDELTA)){/* check full hprobeval(), without using bestLPA1[],bestLPA2[] */
		      double LP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		      if(VERB){
			if(fabs(nLP2-LP2) >= 1e-6)
			  printf("\t WARNING:hprobeval after changing HapSite[%d]=%d -> %d:nLP2=%0.8f, LP2=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), newLP=%0.8f,LRANGE=%d\n",
				 ibest, origHapSite, HapSite[ibest], nLP2, LP2, fabs(nLP2 - LP2), SNPs, Indels, newLP, LRANGE);
			else
			  printf("\t hprobeval after changing HapSite[%d]=%d -> %d:nLP2=%0.8f, LP2=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), newLP=%0.8f,LRANGE=%d\n",
				 ibest, origHapSite, HapSite[ibest], nLP2, LP2, fabs(nLP2 - LP2), SNPs, Indels, newLP, LRANGE);
			fflush(stdout);
		      }
	      
		      nLP2 = LP2;
		    } else if(VERB/* HERE >=2 */){
		      double w = wtime();
		      printf("\t quick hprobeval after change:nLP2=%0.8f(SNPs=%d,Indels=%d), newLP=%0.8f, origLP=%0.8f,LRANGE=%d (wall=%0.6f, cum=%0.6f secs)\n",
			     nLP2, SNPs,Indels,newLP,origLP, LRANGE, w-wstart,w);
		      fflush(stdout);
		    }
		  }

		  if(nLP2 > newLP + HLP_MINDELTA){/* improvement can be substantial if previous nearby snip  was added in this iteration, which is phased with current SNP */
		    /*		  if(nLP2 > newLP + 1e-4){
				  printf("Alternate phasing of new HapSite improved LP=%0.8f to %0.8f (delta=%0.8f)!\n", newLP,nLP2, nLP2-newLP);
				  fflush(stdout);
				  }*/
		    bestHapSite = 3 - nHapSite[ibest];
		    bestHapDelta = HapDelta[ibest];
		    bestHapDeltaL = HapDelta[Lbest];
		    bestDelta = Delta[ibest];
		    bestDeltaL = Delta[Lbest];
		    bestSNPcnt = SNPs;
		    bestIndelCnt = Indels;

		    newLP = nLP2;

		    /* swap newLPA and bestLPA */
		    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		  }
		}
	      }

	      HapSite[ibest] = origHapSite;
	      HapDelta[ibest] = origHapDelta;
	      HapDelta[Lbest] = origHapDeltaL;
	      Delta[ibest] = origDelta;
	      Delta[Lbest] = origDeltaL;

	      if(HSNP_FAST){/* NEW137 : update LP[][ibest] and HapSiteScore[ibest],SiteScore[ibest] to be consitent with newLP as best LP */
		for(int h = 0; h <= 3; h++)
		  LPsnp[h] = LP[h][ibest] + origLP;

		int h = bestHapSite;
		LPsnp[h] = newLP;
		
		// make sure LPsnp[h] is the best scoring option
		for(int t = 0; t <= 3; t++) {
		  LPsnp[t] = min(LPsnp[h],LPsnp[t]);
		  LP[t][ibest] = LPsnp[t] - LPstart;
	        }

		double origHapSiteScore = HapSiteScore[ibest];
		double origSiteScore = SiteScore[ibest];
		HapSiteScore[ibest] = max(LPsnp[1],LPsnp[2]) - max(LPsnp[0],LPsnp[3]);
		SiteScore[ibest] = LPsnp[3] - LPsnp[0];

		if(fabs(HapSiteScore[ibest] - origHapSiteScore) >= 1e-6 || fabs(SiteScore[ibest] - origSiteScore) >= 1e-6)
		  scorecorrected = 1;
		
		if(VERB/* HERE >=2 */){
		  printf("\t Updated HapSiteScore[%d] = %0.6f -> %0.6f, SiteScore[%d] = %0.6f -> %0.6f (LPsnp[0,1,2,3]=%0.6f,%0.6f,%0.6f,%0.6f,LPstart=%0.6f)\n",
		    ibest, origHapSiteScore,HapSiteScore[ibest], ibest, origSiteScore, SiteScore[ibest], LPsnp[0],LPsnp[1],LPsnp[2],LPsnp[3],LPstart);
		  fflush(stdout);
	        }
	      }

	      if(bestHapSite != origHapSite){
		changecnt++;
		if(newLP > origLP + LP_SITE_MINDELTA)
		  hapsitecnt++;

		HapSite[ibest] = bestHapSite;
		HapDelta[ibest] = bestHapDelta;
		HapDelta[Lbest] = bestHapDeltaL;
		Delta[ibest] = bestDelta;
		Delta[Lbest] = bestDeltaL;
		SNPcnt = bestSNPcnt;
		IndelCnt = bestIndelCnt;

		if(VERB){
		  printf("Changing HapSite[%d]= %d -> %d (LP = %0.8f -> %0.8f) : i=%d,Hcuts[ibest]=%0.3f,%0.3f,Hcuts[i]=%0.3f,progress=%d(%d,%d),changes=%d,iter=%d,SNPs=%d,Indels=%d\n", 
			 ibest, origHapSite, bestHapSite, origLP, newLP, i, Hcuts[ibest], Hcuts[ibest]+DelCum[ibest], Hcuts[i], progress, hapdeltacnt, deltacnt, changecnt, iter,SNPcnt, IndelCnt);
		  fflush(stdout);
		}
		if(DEBUG) assert(newLP > origLP);
	      } else if(VERB){
		printf("Failed to change HapSite[%d]= %d -> %d (LP = %0.8f) : i=%d,Hcuts[ibest]=%0.3f,%0.3f,Hcuts[i]=%0.3f, progress=%d(%d,%d), changes=%d,iter=%d,SNPs=%d,Indels=%d\n", 
		       ibest, origHapSite, nHapSite[ibest], origLP, i, Hcuts[ibest],Hcuts[ibest]+DelCum[ibest],Hcuts[i],progress,hapdeltacnt, deltacnt, changecnt,iter,SNPcnt,IndelCnt);
		fflush(stdout);
	      }
	    } else {/* indel HaploType */
	      if(DEBUG) assert(tbest==1);
	      if(DEBUG) assert(nHapDelta[ibest] != 0.0);
	      if(DEBUG) assert(HapSite[ibest]);

	      if(VERB>=3 && iter==35 && ibest==4517){
		printf("Before Changing HapDelta[%d]=%0.4f->%0.4f:SNPs=%d,Indels=%d\n",
		       ibest,HapDelta[ibest],origHapDelta+nHapDelta[ibest],SNPcnt,IndelCnt);

		if(VERB>=3 && iter==35){
		  printf("\t map1[m=212][J=63]= %d, mapK1[m=212][J=63]= %d, map1[MD][4563]= %d)\n", map1[212][63], mapK1[212][63], map1[MD][4563]);
		  fflush(stdout);
		}

		hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		//		rverb = 1;
		double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				       TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		//		rverb = 0;
		printf("hprobeval=%0.8f,origLP=%0.8f(err=%0.8f),SNPs=%d,Indels=%d\n",hLP,origLP,hLP-origLP,SNPs,Indels);
		if(212 < MD)
		  for(int m = 212; m <= 212; m++)
		    printf("\t    m=%d:testLPA1[m]= %0.6f, bestLPA1[m]= %0.6f\n",m, testLPA1[m], bestLPA1[m]);
		fflush(stdout);
	      }

	      int remapped = 0;
	      /* need to save all HapDelta[LLbest .. RRbest-1] and Delta[LLbest .. RRbest-1] */
	      int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
	      if(DEBUG) assert(LL <= ibest && ibest < RR);
	      memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	      memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));

	      int block = 1;
	      while(block < 16 && MD > numthreads * block)
		block *= 2;

	      /* need to backup map1[],map2[] */
              #pragma omp parallel for schedule(static,block) num_threads(numthreads)
	      for(int m = 0; m < MD; m++){
	        int M = MX[m];
		memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
		memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
		memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
		memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
	      }

	      double bestHapDelta = origHapDelta;
	      double bestHapDelta2 = origDelta;
	    
	      double range1 = range1best;
	      double range2 = range2best;

	      /* recompute LP with HapDelta[ibest] = origHapDelta + nHapDelta[ibest] or -(origHapDelta + nHapDelta[ibest]) */
	      double incHapDelta = nHapDelta[ibest];
	      double incDelta = nHapDelta2[ibest];

	      HapDelta[ibest] = origHapDelta + incHapDelta;
	      Delta[ibest] = origDelta + incDelta;

	      if(VERB/* HERE >=2 */){
	        printf("Testing HapDelta[%d]=%0.4f -> %0.4f (tot=%0.4f -> %0.4f)(LP= %0.6f -> %0.6f, delta=%0.8f) Hcuts[%d..%d]=%0.4f->%0.4f,Hcuts[%d..%d]=%0.4f->%0.4f,Hcuts[%d]=%0.4f+-%0.4f:\n\t\t progress=%d(%d,%d),changes=%d,iter=%d,SNPcnt=%d,Indelcnt=%d->%d,minKB=%0.3f,range1=%0.4f,range2=%0.4f\n",
		       ibest, origHapDelta, origHapDelta + nHapDelta[ibest], HapDeltaMerged[ibest], HapDeltaMerged[ibest] + nHapDelta[ibest], LPstart,LPbest,LPbest-LPstart,
		       ibest,Rbest,Hcuts[Rbest]-Hcuts[ibest]+origDelta, Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest], 
		       LLbest,RRbest,Hcuts[RRbest]+DelCum[RRbest]-Hcuts[LLbest]-DelCum[LLbest],Hcuts[RRbest]+DelCum[RRbest]-Hcuts[LLbest]-DelCum[LLbest] + Delta[ibest]-origDelta,
		       ibest, Hcuts[ibest] + DelCum[ibest], HapDelCum[i+1],
		       progress, hapdeltacnt, deltacnt, changecnt, iter, SNPcnt, IndelCnt, 
		       IndelCnt + (fabs(HapDeltaMerged[ibest] + nHapDelta[ibest]) >= MIN_INDEL_SIZE ? 1 : 0) - (HapDeltaMerged[ibest] ? 1 : 0), minKB, range1,range2);
		
		if(VERB>=3 && iter==11 && ibest==103287){
		  for(int t = LL; t < RR; t++)
		    if(HapSite[t] || HapDelta[t] || Delta[t] || prevHapSite[t] || prevHapDelta[t] || prevDelta[t])
		      printf("t=%d:HapDelta[t]= %0.6f, prevHapDelta[t]= %0.6f, Delta[t]= %0.6f, prevDelta[t]= %0.6f, HapSite[t]= %d, prevHapSite[t]= %d\n",
			     t, HapDelta[t],prevHapDelta[t],Delta[t],prevDelta[t],HapSite[t],prevHapSite[t]);
		  fflush(stdout);
	        }

		fflush(stdout);
	      }

	      if(DEBUG >= 1+RELEASE) assert(range1 + incDelta + incHapDelta >= minKB && range2 + incDelta - incHapDelta >= minKB);

	      //	      rverb = 1;
	      //	      rverb = fabs(origHapDelta + nHapDelta[ibest]) > 999.0) ? 1 : 0;
	      if(HapDeltaSpread(n,LLbest,RRbest,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){/* can happen due to combination of two valid HapDelta changes */
	        //	        rverb = 0;
	        //		int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
		memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		

		tbest = ibest = -1;
		LPbest = LPstart;
		if(DEBUG) assert(remapped == 0);
		continue;
	      }
	      //	      rverb = 0;

	      remapped |= correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,LLbest,RRbest,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);

	      if(VERB>=3 && iter==35){
		printf("\t After HapDeltaSpread: map1[m=212][J=63]= %d, mapK1[m=212][J=63]= %d, map1[MD][4563]= %d)\n", map1[212][63], mapK1[212][63], map1[MD][4563]);
		fflush(stdout);
	      }
	      if(VERB>=3 && iter==11 && ibest==103287){
		printf("\t After HapDeltaSpread:\n");
		for(int t = LL; t < RR; t++)
		  if(HapSite[t] || HapDelta[t] || Delta[t] || prevHapSite[t] || prevHapDelta[t] || prevDelta[t])
		    printf("t=%d:HapDelta[t]= %0.6f, prevHapDelta[t]= %0.6f, Delta[t]= %0.6f, prevDelta[t]= %0.6f, HapSite[t]= %d, prevHapSite[t]= %d\n",
			   t, HapDelta[t],prevHapDelta[t],Delta[t],prevDelta[t],HapSite[t],prevHapSite[t]);
		fflush(stdout);
	      }

	      //	      rverb = 0;
	      if(DEBUG >= 1+RELEASE) assert(fabs(HapDelta[ibest]) < 1000.0);

	      double wstart = wtime();// HERE HERE
	      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	      if(DEBUG) assert(Lbest <= ibest && Rbest >= ibest);

	      if(VERB>=3 && iter==25){
		printf("\t After hsetmap: wt= %0.6f\n",wtime());
		fflush(stdout);
	      }

#if 0
	      rverb = (iter==11 && ibest==103287) ? 2 : 0;
	      if(VERB && rverb){
	        printf("Calling hprobeval() to test HapDelta[%d]: LL=%d,RR=%d,Hcuts1[LL,RR]=%0.6f,%0.6f,Hcuts2[LL,RR]=%0.6f,%0.6f,Hcuts[LL,RR]=%0.6f,%0.6f\n",
		ibest,LL,RR,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],Hcuts[LL],Hcuts[RR]);
	        fflush(stdout);
	      }
#endif

	      double nLP1 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				      TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      //	      rverb = 0;

	      if(DEBUG>=2 /*|| (iter==35 && tbest >= 1 && nLP1 >= newLP + HLP_MINDELTA) */
		 || (!FAST_HPROBEVAL && nLP1 > newLP + HLP_MINDELTA)){/* check full hprobeval(), without using bestLPA1[],bestLPA2[] */

		//		rverb = (iter==35 && ibest==4517) ? 1 : 0;
		double LP1 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				       TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		//		rverb = 0;

		if(VERB){
		  if(fabs(LP1-nLP1) >= 1e-6){
		    printf("\t WARNING:hprobeval after changing HapDelta[%d]=%0.4f -> %0.4f:nLP1=%0.8f, LP1=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), origLP=%0.8f,newLP=%0.8f,LRANGE=%d\n",
			   ibest, origHapDelta,origHapDelta + nHapDelta[ibest],nLP1, LP1, nLP1 - LP1, SNPs, Indels, origLP,newLP,LRANGE);
		    if(fabs(LP1-nLP1) >= 1.0){
		      for(int m = 0; m < MD; m++){
			if(fabs(testLPA1[m]-newLPA1[m]) >= 1e-6)
			  printf("\t   m=%d:newLPA1[m]= %0.6f, testLPA1[m]= %0.6f (err= %0.6f), bestLPA1[m]= %0.6f\n",m, newLPA1[m],testLPA1[m],newLPA1[m]-testLPA1[m], bestLPA1[m]);
			if(fabs(testLPA2[m]-newLPA2[m]) >= 1e-6)
			  printf("\t   m=%d:newLPA2[m]= %0.6f, testLPA2[m]= %0.6f (err= %0.6f), bestLPA2[m]= %0.6f\n",m, newLPA2[m],testLPA2[m],newLPA2[m]-testLPA2[m],bestLPA2[m]);
		      }
		      //		      if(iter==35) assert(fabs(LP1-nLP1) < 1.0);
		    }
		  } else
		    printf("\t hprobeval after changing HapDelta[%d]=%0.4f -> %0.4f:nLP1=%0.8f, LP1=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), origLP=%0.8f,newLP=%0.8f,LRANGE=%d\n",
			   ibest, origHapDelta,origHapDelta + nHapDelta[ibest],nLP1, LP1, nLP1 - LP1, SNPs, Indels, origLP,newLP,LRANGE);
		  fflush(stdout);
		}

		nLP1 = LP1;
		/* swap newLPA and testLPA */
		double *tmp = newLPA1; newLPA1 = testLPA1; testLPA1 = tmp;// WAS5 bestLPA1 = tmp;
		tmp = newLPA2; newLPA2 = testLPA2; testLPA2 = tmp;

	      } else if(VERB/* HERE >=2 */){
		double w = wtime();
		printf("\t quick hprobeval after changing HapDelta[%d]=%0.4f -> %0.4f:nLP1=%0.8f(SNPs=%d,Indels=%d), origLP=%0.8f,newLP=%0.8f,LRANGE=%d (wall=%0.6f, cum=%0.6f secs)\n",
		       ibest, origHapDelta, origHapDelta + nHapDelta[ibest], nLP1, SNPs, Indels, origLP, newLP,LRANGE,w-wstart,w);
		fflush(stdout);
	      }

	      if(nLP1 > newLP + HLP_MINDELTA){
		bestHapDelta = origHapDelta + nHapDelta[ibest];// NOTE cannot use HapDelta[ibest] since the value may be "spread" out by now
		bestHapDelta2 = origDelta + nHapDelta2[ibest];
		newLP = nLP1;
		IndelCnt = Indels;
		SNPcnt = SNPs;

		/* swap newLPA and bestLPA */
		double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	      }

	      // skip opposite phasing if iter > HMIN_ITER OR this is not a new HapIndel and rely on later phase reversal or on re-check next iteration
	      double nLP2 = nLP1;
	      int HapPhased = 0;/* 1 IFF If both phases of HapDelta were tried */

	      incHapDelta = -(origHapDelta + nHapDelta[ibest]) - origHapDelta;
	      incDelta = nHapDelta2[ibest];

	      if(INDEL_REVERSE && iter <= INDEL_REVERSE && origHapDelta == 0.0 && nHapDelta[ibest] != 0.0 && 
		 (range1 + incDelta + incHapDelta >= minKB && range2 + incDelta - incHapDelta >= minKB)){
		HapPhased = 1;

		/* first restore HapDelta and map */
		//		int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
		memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
		if(remapped){ /* need to restore map1[],map2[] */
                  #pragma omp parallel for schedule(static,block) num_threads(numthreads)
		  for(int m = 0; m < MD; m++){
	            int M = MX[m];
		    memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		    memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		    memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		    memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
	          }
		  remapped = 0;
		}

		if(VERB>=3 && iter==11 && ibest==103287){
		  printf("\t After restoring HapDelta & map[]:LL=%d,RR=%d\n",LL,RR);
		  for(int t = LL; t < RR; t++)
		    if(HapSite[t] || HapDelta[t] || Delta[t] || prevHapSite[t] || prevHapDelta[t] || prevDelta[t])
		      printf("t=%d:HapDelta[t]= %0.6f, prevHapDelta[t]= %0.6f, Delta[t]= %0.6f, prevDelta[t]= %0.6f, HapSite[t]= %d, prevHapSite[t]= %d\n",
		         t, HapDelta[t],prevHapDelta[t],Delta[t],prevDelta[t],HapSite[t],prevHapSite[t]);
		  fflush(stdout);
	        }

		HapDelta[ibest] = origHapDelta + incHapDelta;
		Delta[ibest] = origDelta + incDelta;

		if(VERB/* HERE >=2 */){
		  printf("Testing HapDelta[%d]=%0.4f -> %0.4f (tot=%0.4f -> %0.4f): Delta[ibest]= %0.4f,progress=%d(%d,%d),changes=%d,iter=%d,SNPcnt=%d,Indelcnt=%d->%d,minKB=%0.3f,range1=%0.4f,range2=%0.4f\n",
		    ibest, origHapDelta, HapDelta[ibest], HapDeltaMerged[ibest], HapDeltaMerged[ibest] + HapDelta[ibest] - origHapDelta, Delta[ibest],
		    progress, hapdeltacnt, deltacnt, changecnt, iter, SNPcnt, IndelCnt, 
		    IndelCnt + (fabs(HapDeltaMerged[ibest] + nHapDelta[ibest]) >= MIN_INDEL_SIZE ? 1 : 0) - (HapDeltaMerged[ibest] ? 1 : 0), minKB,range1,range2);
		
		  if(VERB>=3 && iter==11 && ibest==103287)
		    for(int t = LL; t < RR; t++)
		      if(HapSite[t] || HapDelta[t] || Delta[t] || prevHapSite[t] || prevHapDelta[t] || prevDelta[t])
			printf("t=%d:HapDelta[t]= %0.6f, prevHapDelta[t]= %0.6f, Delta[t]= %0.6f, prevDelta[t]= %0.6f, HapSite[t]= %d, prevHapSite[t]= %d\n",
		              t, HapDelta[t],prevHapDelta[t],Delta[t],prevDelta[t],HapSite[t],prevHapSite[t]);
		  fflush(stdout);
		}
		
		//		rverb = 1;
		//	      rverb = fabs(origHapDelta + nHapDelta[ibest]) > 999.0) ? 1 : 0;
		if(HapDeltaSpread(n,LLbest,RRbest,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){/* can happen due to combination of two valid HapDelta changes */
		  //		rverb = 0;
		  //		  changecnt--;
		  //		  newLP = origLP;
		  //		  int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
		  memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		
		  
		  if(DEBUG) assert(remapped == 0);
		} else {
		  //		  rverb = 0;

		  remapped |= correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,LLbest,RRbest,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);
		  
		  if(VERB>=3 && iter==11 && ibest==103287){
		    printf("\t After spreading HapDelta for opposite orientation:LL=%d,RR=%d\n",LL,RR);
		    for(int t = LL; t < RR; t++)
		      if(HapSite[t] || HapDelta[t] || Delta[t] || prevHapSite[t] || prevHapDelta[t] || prevDelta[t])
			printf("t=%d:HapDelta[t]= %0.6f, prevHapDelta[t]= %0.6f, Delta[t]= %0.6f, prevDelta[t]= %0.6f, HapSite[t]= %d, prevHapSite[t]= %d\n",
		          t, HapDelta[t],prevHapDelta[t],Delta[t],prevDelta[t],HapSite[t],prevHapSite[t]);
		    fflush(stdout);
	          }

		  double wstart = wtime();// HERE HERE
		  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		  if(DEBUG) assert(Lbest <= ibest && Rbest >= ibest);

		  if(VERB>=2){
		    printf("\t After hsetmap: wt= %0.6f\n",wtime());
		    fflush(stdout);
		  }

		  //	      rverb = (iter==35 && ibest==4517) ? 1 : 0;
		  nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		                   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  //	      rverb = 0;

		  if(DEBUG>=2 /*|| (iter==35 && tbest >= 1 && nLP1 >= newLP + HLP_MINDELTA) */
		     || (!FAST_HPROBEVAL && nLP1 > newLP + HLP_MINDELTA)){/* check full hprobeval(), without using bestLPA1[],bestLPA2[] */

		    //		rverb = (iter==35 && ibest==4517) ? 1 : 0;
		    double LP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					   TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    //		rverb = 0;

		    if(VERB){
		      if(fabs(LP2 - nLP2) >= 1e-6){
			printf("\t WARNING:hprobeval after changing HapDelta[%d]=%0.4f -> %0.4f:nLP2=%0.8f, LP2=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), origLP=%0.8f,newLP=%0.8f,LRANGE=%d\n",
		             ibest, origHapDelta,-(origHapDelta + nHapDelta[ibest]),nLP1, LP1, nLP1 - LP1, SNPs, Indels, origLP,newLP,LRANGE);
			if(fabs(LP2 - nLP2) >= 1.0){
			  for(int m = 0; m < MD; m++){
			    if(fabs(testLPA1[m]-newLPA1[m]) >= 1e-6)
			      printf("\t   m=%d:newLPA1[m]= %0.6f, testLPA1[m]= %0.6f (err= %0.6f), bestLPA1[m]= %0.6f\n",m, newLPA1[m],testLPA1[m],newLPA1[m]-testLPA1[m], bestLPA1[m]);
			    if(fabs(testLPA2[m]-newLPA2[m]) >= 1e-6)
			      printf("\t   m=%d:newLPA2[m]= %0.6f, testLPA2[m]= %0.6f (err= %0.6f), bestLPA2[m]= %0.6f\n",m, newLPA2[m],testLPA2[m],newLPA2[m]-testLPA2[m],bestLPA2[m]);
			  }
			  //		      if(iter==35) assert(fabs(LP1-nLP1) < 1.0);
			}
		      } else
			printf("\t hprobeval after changing HapDelta[%d]=%0.4f -> %0.4f:nLP2=%0.8f, LP2=%0.8f (err=%0.8f,SNPs=%d,Indels=%d), origLP=%0.8f,newLP=%0.8f,LRANGE=%d\n",
 		                ibest, origHapDelta,-(origHapDelta + nHapDelta[ibest]),nLP2, LP2, nLP2 - LP2, SNPs, Indels, origLP,newLP,LRANGE);
		      fflush(stdout);
		    }

		    nLP2 = LP2;
		    /* swap newLPA and testLPA */
		    double *tmp = newLPA1; newLPA1 = testLPA1; testLPA1 = tmp;// WAS5 bestLPA1 = tmp;
		    tmp = newLPA2; newLPA2 = testLPA2; testLPA2 = tmp;
		  } else if(VERB/* HERE >=2 */){
		    double w = wtime();
		    printf("\t quick hprobeval after changing HapDelta[%d]=%0.4f -> %0.4f:nLP2=%0.8f(SNPs=%d,Indels=%d), origLP=%0.8f,newLP=%0.8f,LRANGE=%d (wall=%0.6f, cum=%0.6f secs)%s\n",
			   ibest, origHapDelta, -(origHapDelta + nHapDelta[ibest]), nLP2, SNPs, Indels, origLP, newLP,LRANGE,w-wstart,w, (nLP2 > newLP + HLP_MINDELTA) ? "!!!" : "");
		    fflush(stdout);
		  }

		  if(nLP2 > newLP + HLP_MINDELTA){
		    bestHapDelta = -(origHapDelta + nHapDelta[ibest]);// NOTE : cannot use HapDelta[ibest] since the value has been spread out
		    bestHapDelta2 = origDelta + nHapDelta2[ibest];// NOTE : cannot use Delta[ibest] since the value has been spread out
		    newLP = nLP2;
		    IndelCnt = Indels;
		    SNPcnt = SNPs;

		    HapPhased = 0;// no need to restore HapDelta[ibest] etc NOT VERIFIED

		    /* swap newLPA and bestLPA */
		    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		  } 
		}// !HapDeltaSpread()
	      } // check opposite phase HapDelta

	      if(bestHapDelta != origHapDelta){
		changecnt++;

		if(newLP > origLP + LP_INDEL_MINDELTA)
		  hapdeltacnt++;

		if(HapPhased){/* switch to correct phasing */
		  /* reset HapDelta,Delta,HapSite,map1 etc */
		  int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
		  memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
		  if(remapped){ /* need to restore map1[],map2[] */
		    int block = 1;
		    while(block < 16 && MD > numthreads * block)
		      block *= 2;
		    
#pragma omp parallel for schedule(static,block) num_threads(numthreads)
		    for(int m = 0; m < MD; m++){
	              int M = MX[m];
		      memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		      memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		      memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		      memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
	            }
		    remapped = 0;
		  }

		  HapDelta[ibest] = bestHapDelta;
		  Delta[ibest] = bestHapDelta2;
		  
		  if(VERB>=3 && iter==11 && ibest==103287){
		    printf("\t After restoring HapDelta & map[] and switching back to bestHapDelta=%0.6f,bestHapDelta2=%0.6f:LL=%d,RR=%d\n",bestHapDelta,bestHapDelta2,LL,RR);
		    for(int t = LL; t < RR; t++)
		      if(HapSite[t] || HapDelta[t] || Delta[t] || prevHapSite[t] || prevHapDelta[t] || prevDelta[t])
			printf("t=%d:HapDelta[t]= %0.6f, prevHapDelta[t]= %0.6f, Delta[t]= %0.6f, prevDelta[t]= %0.6f, HapSite[t]= %d, prevHapSite[t]= %d\n",
			       t, HapDelta[t],prevHapDelta[t],Delta[t],prevDelta[t],HapSite[t],prevHapSite[t]);
		    fflush(stdout);
	          }

		  if(HapDeltaSpread(n,LLbest,RRbest,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap)){/* should never happen */
		    printf("HapDeltaSpread() failed on 2nd attempt!\n");
		    fflush(stdout);
		    assert(0);
		  }
		  remapped |= correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,LLbest,RRbest,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);		  

		  if(VERB>=3 && iter==11 && ibest==103287){
		    printf("\t After calling HapDeltaSpread:LL=%d,RR=%d\n",LL,RR);
		    for(int t = LL; t < RR; t++)
		      if(HapSite[t] || HapDelta[t] || Delta[t] || prevHapSite[t] || prevHapDelta[t] || prevDelta[t])
			printf("t=%d:HapDelta[t]= %0.6f, prevHapDelta[t]= %0.6f, Delta[t]= %0.6f, prevDelta[t]= %0.6f, HapSite[t]= %d, prevHapSite[t]= %d\n",
			       t, HapDelta[t],prevHapDelta[t],Delta[t],prevDelta[t],HapSite[t],prevHapSite[t]);
		    fflush(stdout);
	          }

		  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		}/* both phases were tried */

		if(VERB){
	          printf("\tConfirming HapDelta[ib=%d]=%0.4f->%0.4f(tot=%0.4f->%0.4f),Delta[ib]=%0.4f->%0.4f,Hcuts[ib..%d]=%0.3f->%0.3f(LP=%0.6f->%0.6f):\n\t\tLP1=%0.8f,LP2=%0.8f,Hcuts[ib]=%0.3f,%0.3f,Hcuts[i=%d]=%0.3f,progress=%d(%d,%d),changes=%d,iter=%d,SNPs=%d,Indels=%d\n", 
			   ibest, origHapDelta, bestHapDelta, HapDeltaMerged[ibest], HapDeltaMerged[ibest] + HapDelta[ibest] - origHapDelta,
			   origDelta, Delta[ibest], Rbest,Hcuts[Rbest]-Hcuts[ibest]+origDelta+origHapDelta, Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest] + HapDelta[ibest], 
			   origLP, newLP, nLP1, nLP2, Hcuts[ibest], Hcuts[ibest]+DelCum[ibest], i, Hcuts[i], progress, hapdeltacnt, deltacnt, changecnt, iter,SNPcnt,IndelCnt);
		  fflush(stdout);
		}
		if(DEBUG) assert(newLP > origLP);

		if(DEBUG /* HERE >=2 */){/* confirm LP : use quick hprobeval unless discrepancy is noticed */
#if 0
		  rverb = (iter==11 && ibest == 103287) ? 2 : 0;
		  if(VERB && rverb){
		    printf("Calling hprobeval() to confirm LP: LL=%d,RR=%d,Hcuts1[LL,RR]=%0.6f,%0.6f,Hcuts2[LL,RR]=%0.6f,%0.6f,Hcuts[LL,RR]=%0.6f,%0.6f\n",
			   LL,RR,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],Hcuts[LL],Hcuts[RR]);
		    fflush(stdout);
		  }
#endif

		  double qLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  rverb = 0;

		  if(!(fabs(qLP - newLP) < max(1e-6, 1e-10*fabs(newLP)) && SNPcnt == SNPs && IndelCnt == Indels) || VERB>=2){
		    double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    printf("WARNING: Failed to confirm newLP= %0.8f: qLP=%0.8f (err=%0.8f), nLP= %0.8f(err= %0.8f), SNPs= %d -> %d, Indels= %d -> %d\n",
			   newLP, qLP, qLP-newLP, nLP, nLP-newLP, SNPcnt,SNPs,IndelCnt,Indels);
		    double sum = 0.0, bsum = 0.0, logH = -log(2.0), LP,bLP;
		    for(int m = 0; m < MD; m++){
		      if(fabs(newLPA1[m] - bestLPA1[m]) > 1e-6 || fabs(newLPA2[m] - bestLPA2[m]) > 1e-6){
			sum += LP = HapLP(newLPA1[m],newLPA2[m],logH);
			bsum += bLP = HapLP(bestLPA1[m],bestLPA2[m],logH);

			printf("m=%d:newLPA1[m]=%0.6f,newLPA2[m]=%0.6f(nLP=%0.6f,err=%0.6f): bestLPA1[m]=%0.6f,bestLPA2[m]=%0.6f,bLP=%0.6f(cum:sum=%0.6f,bsum=%0.6f,err=%0.6f)\n",
			       m,newLPA1[m],newLPA2[m],LP,LP-bLP,bestLPA1[m],bestLPA2[m],bLP,sum,bsum,sum-bsum);
		      }
		    }
		    fflush(stdout);
		    
		    if(nLP <= origLP){
		      printf("\t Undoing HapDelta changes\n");
		      fflush(stdout);
		      changecnt--;
		      goto LHapDeltaFailed;
		    }

		    newLP = nLP;
		    SNPcnt = SNPs;
		    IndelCnt = Indels;
		    /* swap newLPA,bestLPA (to improve accuracy of bestLPA) */
		    double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;// WAS5 bestLPA1 = tmp
		    tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;	
		  } else if(VERB/* HERE >=2 */) {
		    printf("\tConfirmed qLP= %0.8f (err= %0.8f), SNPs= %d, Indels= %d\n",qLP,qLP-newLP,SNPs,Indels);
		    fflush(stdout);
		  }
		}
              } else {
		if(VERB){
		  printf("Failed to change HapDelta[%d]=%0.4f->%0.4f,Hcuts[%d..%d]=%0.3f->%0.3f (origLP=%0.8f) : LP1=%0.8f LP2=%0.8f i=%d,Hcuts[ibest]=%0.3f,%0.3f,Hcuts[i]=%0.3f,progress=%d(%d,%d),changes=%d,iter=%d,SNPs=%d,Indels=%d\n", 
		       ibest, origHapDelta, origHapDelta + nHapDelta[ibest], ibest,Rbest,Hcuts[Rbest]-Hcuts[ibest] + origDelta, Hcuts[Rbest]-Hcuts[ibest] + Delta[ibest], 
		       origLP, nLP1, nLP2, i, Hcuts[ibest], Hcuts[ibest]+DelCum[ibest], Hcuts[i], progress, hapdeltacnt, deltacnt, changecnt, iter,SNPcnt, IndelCnt);
		  fflush(stdout);
		}
LHapDeltaFailed:
		int LL = min(LLbest,Lbest), RR = max(RRbest,Rbest);
		memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
		if(remapped){ /* need to restore map1[],map2[] */
	          int block = 1;
		  while(block < 16 && MD > numthreads * block)
		    block *= 2;

                  #pragma omp parallel for schedule(static,block) num_threads(numthreads)
		  for(int m = 0; m < MD; m++){
	            int M = MX[m];
		    memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		    memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		    memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		    memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
	          }
		  remapped = 0;
		}

		if(DEBUG /* HERE >=2 */){/* check if LP was restored correctly : use quick hprobeval unless discrepancy is noticed */
		  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */

		  if(VERB>=3 && iter==127) {
		    printf("Calling quick hprobeval with rverb=1\n");
		    fflush(stdout);

		    rverb = 1;
		  }
		  double nLP1 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					  TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[Lbest],Hcuts1[Rbest],Hcuts2[Lbest],Hcuts2[Rbest],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  SNPcnt = SNPs;
		  IndelCnt = Indels;
		  if(!(fabs(nLP1 - origLP) < max(1e-6, 1e-10*fabs(origLP))) || VERB>=2){
		    double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    printf("WARNING: Failed to restore origLP=%0.8f : nLP1=%0.8f (err=%0.8f), nLP2=%0.8f(err=%0.8f),SNPs=%d -> %d,Indels=%d -> %d\n",
			   origLP,nLP1,nLP1-origLP,nLP2,nLP2-origLP,SNPcnt,SNPs,IndelCnt,Indels);
		    printf("Before swapping bestLPA1,bestLPA2 and newLPA1,newLPA2: bestLPA1= %p, bestLPA2= %p, newLPA1=%p, newLPA2= %p\n",bestLPA1,bestLPA2,newLPA1,newLPA2);
		    for(int t = 0; t < 3; t++)
		      printf("\t t=%d:newLPA1[t]= %0.8f, newLPA2[t]= %0.8f, bestLPA1[t]= %0.8f bestLPA2= %0.8f\n",t,newLPA1[t],newLPA2[t],bestLPA1[t],bestLPA2[t]);
		    fflush(stdout);
		    //		    if(DEBUG >= 1+RELEASE) assert(nLP1 >= origLP - max(1e-5, 1e-6 * fabs(origLP)));

		    origLP = newLP = nLP2;
		    SNPcnt = SNPs;
		    IndelCnt = Indels;
		    /* swap newLPA,bestLPA (to improve accuracy of bestLPA) */
		    double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;// WAS5 bestLPA1 = tmp
		    tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;	

		    if(VERB>=2){
		      printf("Updated bestLPA1,bestLPA2 from newLPA1,newLPA2: bestLPA1= %p, bestLPA2= %p, newLPA1=%p, newLPA2= %p\n",bestLPA1,bestLPA2,newLPA1,newLPA2);
		      for(int t = 0; t < 3; t++)
			printf("\t t=%d:newLPA1[t]= %0.8f, newLPA2[t]= %0.8f, bestLPA1[t]= %0.8f bestLPA2= %0.8f\n",t,newLPA1[t],newLPA2[t],bestLPA1[t],bestLPA2[t]);
		      fflush(stdout);
		    }
		  } else if(VERB/* HERE >=2 */){
		    printf("\tRestored LP= %0.6f (err= %0.6f), origLP= %0.6f\n",nLP1, nLP1 - origLP, origLP);
		    fflush(stdout);
		  }
		  rverb = 0;
		}
	      }/* Change not confirmed */
	    } /* tbest==1 : HapDelta[ibest] change */
	  } /* changecnt >= 1 */
	
	  if(HINDEL_SPLIT_FIX){
	    // NOTE : failure to confirm LP increase predicted by mprobeval should not occur if origchangecnt == 0 (unless HINDEL_SPLIT_FIX), but if it does, we may never check nearby other changes for
	    //        which mprobeval predicted smaller increase in LP
	    if(changecnt == origchangecnt){/* failed to confirm change : rewind i to recheck nearby alternate changes */
	      if(DEBUG) assert(newLP <= origLP);
	      int inext = scorecorrected ? ipbest : ibest;
	    
	      if(VERB/* HERE >=2 */){
		printf("Rewinding i=%d to %d due to failure to confirm change (ibest=%d,ipbest=%d,I1=%d,I2=%d,T1=%d,T2=%d)\n",i,inext,ibest,ipbest,I1,I2,T1,T2);
		fflush(stdout);
	      }

	      // need to rewind I1,I2,T1,T2
	      I1 = I2 = 0;
	      T1 = T2 = -1;
	      for(int t = 1; t <= inext; t++){
		I1 += 1 - startHdel1[t];
		I2 += 1 - startHdel2[t];
		if(!HINDELITER(iter)){
		  if(startHdel1[t] && T1 < addcnt1-1/*NEW10 */ && addid1[T1+1] == t)
		    T1++;
		  if(startHdel2[t] && T2 < addcnt2-1/*NEW10*/ && addid2[T2+1] == t)
		    T2++;
		}
	      }
	      i = inext;
	      if(VERB/* HERE >=2 */){
		printf("After rewinding: I1=%d,I2=%d,T1=%d,T2=%d\n",I1,I2,T1,T2);
		fflush(stdout);
	      }
	    } else
	      ipbest = i; // NOTE: We are not saving ibest, since normally i+1 (NOT ibest+1) is the next label checked after ibest
	  }

	  /* reset LPbest, ibest, tbest */
	  tbest = ibest = -1;
	  LPbest = LPstart;

	  if(VERB >= 1+RELEASE /* HERE >=2 */){  /* compute DelCum[i+1] = Sum(Delta[0..i]) and HapDelCum[] */
	    double DeltaCum = 0.0, HapDeltaCum = 0.0;
	    for(int i = 0; i <= n; i++){
	      HapDelCum[i+1] = HapDeltaCum += HapDelta[i];
	      DelCum[i+1] = DeltaCum += Delta[i];
	    }
	  }
	} /* previous best improvement rechecked/confirmed */

	if(DEBUG>=3 && (iter==0 && i >= 91923)){/* check full hprobeval() without using bestLPA1[],bestLPA2[] */
	  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	
	  if(!(fabs(nLP-newLP) < 1e-6)){
	    printf("\nWARNING:After full hprobeval:i=%d:newLP=%0.8f -> %0.8f, SNPs=%d->%d,Indels=%d->%d\n", i, newLP, nLP,SNPcnt, SNPs, IndelCnt, Indels);
	    fflush(stdout);
	  }
	  newLP = nLP;
	  SNPcnt = SNPs;
	  IndelCnt = Indels;

	  /* swap newLPA,bestLPA (to improve accuracy of bestLPA) */
	  double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;// WAS5 bestLPA1 = tmp;
	  tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;
	}
      }/* i = imin .. imax */

LskipFullCheck:

      if(DELTA_STOP && VERB/* HERE >=2 && activecnt > 0 */){
	if(HINDELITER(iter))
	  printf("HapDelta updates found %d out of %d active intervals (previously %d intervals active, %d newly active)\n",activecnt,maxIN+1,maxIN+1-inactivecnt, newactivecnt);
	else
	  printf("HapSite upates activated %d new intervals (previously %d of %d intervals active)\n",activecnt,maxIN+1-inactivecnt,maxIN+1);
	fflush(stdout);
      }

      /* free up memory not needed till next iteration */
      if(deltamem) {
	free(deltamem);
	deltamem = NULL;
      }
      D1 = DR1 = D2 = DR2 = NULL;
      delta1 = LPdelta1 = delta2 = LPdelta2 = NULL;
      delta1mem = LPdelta1mem = delta2mem = LPdelta2mem = NULL;

      if(HEAP_MINIMIZE){
        if(!VMEM_MINIMIZE){
	  delete [] newLPd[0]; newLPd[0] = NULL;
	  delete [] newLPd2[0]; newLPd2[0] = NULL;
	}
	if(MDEBUG){
	  delete [] newLPdPr[0]; newLPdPr[0] = NULL;
	  delete [] newLPdPr2[0]; newLPdPr2[0] = NULL;
	}
	delete [] Dcum; Dcum = NULL;
	delete [] Dcum2; Dcum2 = NULL;
	
	NmaxLP = 0;

	if(delmem && munmap(delmem, delmemsiz)){
	  int eno = errno;
	  char *err = strerror(eno);
	  printf("munmap(%p,%lld) failed: errno=%d:%s\n",delmem,delmemsiz,eno,err);
	  fflush(stdout);exit(1);
	}
	delmem = NULL;
      }
      if(VMEM_MINIMIZE)
	DoubleAllocations_free();

      if(TIME_VERBOSE){
	getmem(VmSize,VmRSS, VmSwap);
	double InvGB = 1e-9;	
	printf("iter=%d:After De-Allocation of delta[],newLPd[],delmem(LPT*),DoubleAllocations: VmRSS= %0.4f, VmSwap= %0.4f, VmSize= %0.4f: cum wall= %0.6f\n", iter, VmRSS*InvGB,VmSwap*InvGB,VmSize*InvGB,wtime());
	fflush(stdout);
      }

      // NOTE : Changes to Delta[] in intervals bounded by opposite Allele SNPs, may result in out of order labels
      // This should be caught earlier by calling HapDeltaSpread() when changing Delta[] (even when not changing HapDelta[]), so the following check is not needed

      if(1){/* check Delta[],Hcuts[] for consistency */
	/* compute DelCum[i+1] = Sum(Delta[0..i]) */
	double DeltaCum = 0.0;
	for(int i = 0; i <= n; i++){
	  DeltaCum += Delta[i];
	  DelCum[i+1] = DeltaCum;
	}
	int error = 0;
	int L = 0;
	for(int i=1; i <= n; i++){
	  if(HapSite[i+1]){
	    if(!(Hcuts[i+1]+DelCum[i+1] >= Hcuts[L]+DelCum[L])){
	      printf("At end of iter=%d:\n",iter);
	      printf("WARNING: i=%d,L=%d:Hcuts[L]+DelCum[L]=%0.6f,Hcuts[i+1]+DelCum[i+1]=%0.6f,HapSite[L,i+1]=%d,%d\n",
		     i,L,Hcuts[L]+DelCum[L],Hcuts[i+1]+DelCum[i+1],HapSite[L],HapSite[i+1]);
	      fflush(stdout);
	      error++;
	      break;
	    }
	    L = i+1;
	  }
	}
	if(!error && !(Hcuts[n+1]+DelCum[n+1] >= Hcuts[L]+DelCum[L])){
	  printf("At end of iter=%d:\n",iter);
	  printf("WARNING: n=%d,L=%d:Hcuts[L]+DelCum[L]=%0.6f,Hcuts[n+1]+DelCum[n+1]=%0.6f,HapSite[L]=%d\n",
		 n,L,Hcuts[L]+DelCum[L],Hcuts[n+1]+DelCum[n+1],HapSite[L]);
	  fflush(stdout);
	  error++;
	}

	if(error){/* try to fix errors using HapDeltaSpread() */
	  int L = 0;
	  for(int R = 1; R <= n; R++){
	    if(HapSite[R] != 3)
	      continue;
	    if(L > 0){
	      int invalid = HapDeltaSpread(n,L,R,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap);
	      if(invalid){
		printf("At end of iter=%d:\n",iter);
		printf("WARNING: Unable to adjust HapDelta[],Delta[] in interval Hcuts[%d,%d]=%0.4f,%0.4f,HapDeltaMerged[L]=%0.4f\n", L,R,Hcuts[L],Hcuts[R],HapDeltaMerged[L]);
		fflush(stdout);
		assert(!invalid);
	      }
	      (void)correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,L,R,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);
	    }
	    L = R;
	  }
	}
      }

      if(HINDELITER(iter) /* HERE && (iter >= HMIN_ITER + 2 * (HapIndelHiRes-1))*/ ){
	if(VERB/* >=2 */){
	  printf("iter=%d:progress=%d:hapdeltacnt=%d,deltacnt=%d,changes=%d,SNPcnt=%d,IndelCnt=%d:elapsed wall time= %0.6f\n",
		 iter,progress,hapdeltacnt,deltacnt,changecnt,SNPcnt,IndelCnt, wtime());
	  fflush(stdout);
	}

	/* Update DELTA_RANGE[] and Initial_Delta[] based on biggestD1[] */

	if(!DELTA_STOP){
          if(VERB>=2){
	    printf("Filling holes in biggestD1[IN=0..%d][]:\n",maxIN);
	    fflush(stdout);
	  }

	  /* First check for any values of biggestD1[] that are unknown and set them to the nearest known value (or 0 if none within HapLocalScan2 bins) */
	  int cnt1 = 0, cnt2 = 0;
	  for(int IN = 0; IN <= maxIN; IN++){
	    if(biggestD1[IN] < 0){
	      cnt1++;
	      for(int T = 0; T < HapLocalScan2; T++){
		if(IN-T >= 0 && biggestD1[IN-T] >= 0){
		  biggestD1[IN] = biggestD1[IN-T];
		  if(DELTA_SCAN_FIX){/* copy the Initial_Delta[IN] from Initial_Delta[IN-T] */
		    for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
		      Initial_Delta[IN][k] = Initial_Delta[IN-T][k];
		  }
		  if(DEBUG)assert(0 <= biggestD1[IN] && biggestD1[IN] < localINITIAL_DELTA_RANGE && DELTA_RANGE[IN] <= localINITIAL_DELTA_RANGE);
		  break;
		}
		if(IN+T <= maxIN && biggestD1[IN+T] >= 0){
		  biggestD1[IN] = biggestD1[IN+T];
		  if(DELTA_SCAN_FIX){/* copy the Initial_Delta[IN] from Initial_Delta[IN+T] */
		    for(int k = 0; k < localINITIAL_DELTA_RANGE; k++)
		      Initial_Delta[IN][k] = Initial_Delta[IN+T][k];
		  }
		  if(DEBUG)assert(0 <= biggestD1[IN] && biggestD1[IN] < localINITIAL_DELTA_RANGE && DELTA_RANGE[IN] <= localINITIAL_DELTA_RANGE);
		  break;
		}
	      }
	      if(biggestD1[IN] < 0){
		cnt2++;
		biggestD1[IN] = 0;
	      }
	    }
	  }
	  if((VERB/* HERE >=2 */ || HAPSTOP_DEBUG) && cnt1 > 0){
	    printf("Filled %d holes in biggestD1[IN=0..%d][]: %d holes had no neighboring values within 16 bins and were set to 0\n",cnt1,maxIN,cnt2);
	    printf("Updating Initial_Delta[IN=0..%d][]:\n",maxIN);
	    fflush(stdout);
	  }
	}// if(!DELTA_STOP)

	if(DEBUG) assert(LOW_VALUES >= 1 && HIGH_VALUES >= 1);

	int inactivecnt = 0;/* number of intervals originally inactive */
	int startcnt = 0;/* number of inactive intervals changed to active */
	int stopcnt = 0;/* number of active intervals (with minimum delta size) changed to inactive */
	int minimized = 0;/* number of active intervals originally with minimum delta size */
	int downcnt = 0;/* number of active intervals changed to minimum delta size */
	int upcnt = 0;/* number of active intervals change from minimum delta size to non-minimum delta size */

	// #pragma omp parallel for schedule(static,4)
	for(int IN = 0; IN <= maxIN; IN++){
	  if(DELTA_RANGE[IN] <= 0){
	    inactivecnt++;
	    //	    if(DEBUG>=1+RELEASE) assert(Initial_Delta[IN][0] <= MIN_DELTA);
	  } else if(Initial_Delta[IN][0] <= MIN_DELTA)
	    minimized++;
		  
	  if(biggestD1[IN] < 0){
	    if(Initial_Delta[IN][0] <= MIN_DELTA){
	      if(DELTA_RANGE[IN] > 0) 
		stopcnt++;
	      DELTA_RANGE[IN] = 0;
	      continue;
	    }
	    biggestD1[IN] = 0;
	  }

	  int origDELTA_RANGE = DELTA_RANGE[IN];
	  double origDelta = Initial_Delta[IN][0];

	  /* adjust Initial_Delta[IN][0..DELTA_RANGE[IN]-1] */
	  if(DEBUG && !(0 <= biggestD1[IN] && biggestD1[IN] < localINITIAL_DELTA_RANGE && DELTA_RANGE[IN] <= localINITIAL_DELTA_RANGE)){
	    printf("IN=%d:biggestD1[IN]=%d,DELTA_RANGE[IN]=%d,localINITIAL_DELTA_RANGE=%d\n",
		   IN,biggestD1[IN],DELTA_RANGE[IN],localINITIAL_DELTA_RANGE);
	    fflush(stdout);
	    assert(0 <= biggestD1[IN] && biggestD1[IN] < localINITIAL_DELTA_RANGE && DELTA_RANGE[IN] <= localINITIAL_DELTA_RANGE);
	  }

	  if(biggestD1[IN] < LOW_VALUES){
	    double ratio = Initial_Delta[IN][0]/Initial_Delta[IN][1];
	    while(Initial_Delta[IN][0] > MIN_DELTA && biggestD1[IN] < LOW_VALUES){/* shift values down */
	      if(DELTA_RANGE[IN] < localINITIAL_DELTA_RANGE){
		if(HAPSTOP_DEBUG>=2){
		  printf("Extending down Initial_Delta[IN=%d][0..%d..%d]=%0.4f,%0.4f .. %0.4f,%0.4f..%0.4f,%0.4f -> %0.4f,%0.4f .. %0.4f,%0.4f,Initial_Delta[IN][biggestD1->%d]=%0.4f (ratio=%0.4f)\n",
			 IN,DELTA_RANGE[IN]-1,localINITIAL_DELTA_RANGE-1,Initial_Delta[IN][0],Initial_Delta[IN][1],Initial_Delta[IN][DELTA_RANGE[IN]-2],Initial_Delta[IN][DELTA_RANGE[IN]-1],
			 Initial_Delta[IN][localINITIAL_DELTA_RANGE-2],Initial_Delta[IN][localINITIAL_DELTA_RANGE-1],
			 Initial_Delta[IN][0]*ratio,Initial_Delta[IN][0],Initial_Delta[IN][DELTA_RANGE[IN]-2],Initial_Delta[IN][DELTA_RANGE[IN]-1], biggestD1[IN]+1,Initial_Delta[IN][biggestD1[IN]],ratio);
		  fflush(stdout);
		}
		DELTA_RANGE[IN]++;
	      } else {
		if(HAPSTOP_DEBUG>=2){
		  printf("Reducing Initial_Delta[IN=%d][0..%d]=%0.4f,%0.4f .. %0.4f -> %0.4f,%0.4f .. %0.4f,Initial_Delta[IN][biggestD1->%d]=%0.4f\n",
			 IN,DELTA_RANGE[IN]-1,Initial_Delta[IN][0],Initial_Delta[IN][1],Initial_Delta[IN][DELTA_RANGE[IN]-1],
			 Initial_Delta[IN][0]*ratio,Initial_Delta[IN][0],Initial_Delta[IN][DELTA_RANGE[IN]-2], biggestD1[IN]+1,Initial_Delta[IN][biggestD1[IN]]);
		  fflush(stdout);
		}
	      }
	      for(int t = localINITIAL_DELTA_RANGE; --t > 0;)
		Initial_Delta[IN][t] = Initial_Delta[IN][t-1];
	      Initial_Delta[IN][0] *= ratio;

	      if(DEBUG>=1+RELEASE){
		for(int d = 0; d < DELTA_RANGE[IN]; d++){
		  if(!(fabs(Initial_Delta[IN][d]) < 1000.0)){
		    printf("Initial_Delta[IN=%d][d=%d] = %0.4f is too large\n",IN,d,Initial_Delta[IN][d]);
		    fflush(stdout);
		    assert(fabs(Initial_Delta[IN][d] < 1000.0));
		  }
		  if(d > 0 && !(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0)){
		    printf("Initial_Delta[IN=%d][d=%d,%d] = %0.8f,%0.8f ratio is larger than 2.0 (ratio= %0.6f, DELTA_RANGE[IN]=%d/%d, OVERSAMPLE=%d/%d)\n",
			   IN,d-1,d,Initial_Delta[IN][d-1],Initial_Delta[IN][d],ratio,DELTA_RANGE[IN],localINITIAL_DELTA_RANGE,DELTA_OVERSAMPLE, MAX_DELTA_OVERSAMPLE);
		    for(int t = 0; t < localINITIAL_DELTA_RANGE; t++)
		      printf("\t Initial_Delta[IN=%d][d=%d] = %0.8f\n", IN, t, Initial_Delta[IN][t]);
		    fflush(stdout);
		    assert(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0);
		  }
		}
	      }

	      biggestD1[IN]++;
	    } 
	  }

	  if(biggestD1[IN] > LOW_VALUES){
	    double ratio = Initial_Delta[IN][localINITIAL_DELTA_RANGE-1]/Initial_Delta[IN][localINITIAL_DELTA_RANGE-2];
	    while(Initial_Delta[IN][0] < MAX_DELTA && biggestD1[IN] > LOW_VALUES){/* shift values up */
	      if(HAPSTOP_DEBUG){
		printf("Increasing Initial_Delta[IN=%d][0..%d(..%d)]=%0.4f,%0.4f .. %0.4f,%0.4f( .. %0.4f,%0.4f) -> %0.4f,%0.4f ..%0.4f,%0.4f, Initial_Delta[IN][biggestD1[IN]-> %d]= %0.4f (ratio=%0.4f)\n",
		       IN,DELTA_RANGE[IN]-1,localINITIAL_DELTA_RANGE-1,Initial_Delta[IN][0],Initial_Delta[IN][1],Initial_Delta[IN][DELTA_RANGE[IN]-2],Initial_Delta[IN][DELTA_RANGE[IN]-1], 
		       Initial_Delta[IN][localINITIAL_DELTA_RANGE-2],Initial_Delta[IN][localINITIAL_DELTA_RANGE-1],  Initial_Delta[IN][1], Initial_Delta[IN][2], Initial_Delta[IN][DELTA_RANGE[IN]-1],
		       DELTA_RANGE[IN] < localINITIAL_DELTA_RANGE ? Initial_Delta[IN][DELTA_RANGE[IN]] : Initial_Delta[IN][DELTA_RANGE[IN]-1]*ratio,biggestD1[IN]-1,Initial_Delta[IN][biggestD1[IN]],ratio);
		fflush(stdout);
	      }
	      for(int t = 0; t < localINITIAL_DELTA_RANGE - 1; t++)
		Initial_Delta[IN][t] = Initial_Delta[IN][t+1];
	      Initial_Delta[IN][localINITIAL_DELTA_RANGE-1] *= ratio;

	      if(DEBUG>=1+RELEASE){
		for(int d = 0; d < DELTA_RANGE[IN]; d++){
		  if(!(fabs(Initial_Delta[IN][d]) < 1000.0)){
		    printf("Initial_Delta[IN=%d][d=%d] = %0.4f is too large\n",IN,d,Initial_Delta[IN][d]);
		    fflush(stdout);
		    assert(fabs(Initial_Delta[IN][d] < 1000.0));
		  }
		  if(d > 0 && !(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0)){
		    printf("Initial_Delta[IN=%d][d=%d,%d] = %0.4f,%0.4f ratio is too large\n",IN,d-1,d,Initial_Delta[IN][d-1],Initial_Delta[IN][d]);
		    fflush(stdout);
		    assert(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0);
		  }
		}
	      }

	      biggestD1[IN]--;
	    }
	  }

	  if(/* NEW41 */DELTA_OVERSAMPLE <= 0 && biggestD1[IN] < DELTA_RANGE[IN] - 1 - HIGH_VALUES){
	    if(HAPSTOP_DEBUG){
	      printf("Truncating down: Initial_Delta[IN=%d][0..%d->%d]= %0.4f,%0.4f .. %0.4f, Initial_Delta[IN][biggestD1=%d]=%0.4f\n",
		     IN,DELTA_RANGE[IN]-1,biggestD1[IN] + HIGH_VALUES,Initial_Delta[IN][0],Initial_Delta[IN][1],Initial_Delta[IN][biggestD1[IN]+HIGH_VALUES],biggestD1[IN],Initial_Delta[IN][biggestD1[IN]]);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(DELTA_RANGE[IN] > 0);
	    DELTA_RANGE[IN] = biggestD1[IN] + 1 + HIGH_VALUES;
	    if(DEBUG) assert(DELTA_RANGE[IN] > 0);

	    if(DEBUG>=1+RELEASE){
	      for(int d = 0; d < DELTA_RANGE[IN]; d++){
		if(!(fabs(Initial_Delta[IN][d]) < 1000.0)){
		  printf("Initial_Delta[IN=%d][d=%d] = %0.4f is too large\n",IN,d,Initial_Delta[IN][d]);
		  fflush(stdout);
		  assert(fabs(Initial_Delta[IN][d] < 1000.0));
		}
		if(d > 0 && !(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0)){
		  printf("Initial_Delta[IN=%d][d=%d,%d] = %0.4f,%0.4f ratio is too large\n",IN,d-1,d,Initial_Delta[IN][d-1],Initial_Delta[IN][d]);
		  fflush(stdout);
		  assert(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0);
		}
	      }
	    }
	  }

	  if(biggestD1[IN] > DELTA_RANGE[IN] - 1 - HIGH_VALUES){
	    while(DELTA_RANGE[IN] < localINITIAL_DELTA_RANGE-1 && biggestD1[IN] > DELTA_RANGE[IN] - 1 - HIGH_VALUES){
	      if(HAPSTOP_DEBUG>=2){
		printf("Extending up: Initial_Delta[IN=%d][0..%d->%d..%d]=%0.4f,%0.4f .. %0.4f,%0.4f .. %0.4f,%0.4f, Initial_Delta[IN][biggestD1=%d]= %0.4f\n",
		       IN,DELTA_RANGE[IN]-1,DELTA_RANGE[IN],localINITIAL_DELTA_RANGE,Initial_Delta[IN][0],Initial_Delta[IN][1],Initial_Delta[IN][DELTA_RANGE[IN]-1],Initial_Delta[IN][DELTA_RANGE[IN]],
		       Initial_Delta[IN][localINITIAL_DELTA_RANGE-2],Initial_Delta[IN][localINITIAL_DELTA_RANGE-1], biggestD1[IN],Initial_Delta[IN][biggestD1[IN]]);
		fflush(stdout);
	      }
	      DELTA_RANGE[IN]++;
	    }
	    if(DEBUG>=1+RELEASE){
	      for(int d = 0; d < DELTA_RANGE[IN]; d++){
		if(!(fabs(Initial_Delta[IN][d]) < 1000.0)){
		  printf("Initial_Delta[IN=%d][d=%d] = %0.4f is too large\n",IN,d,Initial_Delta[IN][d]);
		  fflush(stdout);
		  assert(fabs(Initial_Delta[IN][d] < 1000.0));
		}
		if(d > 0 && !(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0)){
		  printf("Initial_Delta[IN=%d][d=%d,%d] = %0.4f,%0.4f ratio is too large\n",IN,d-1,d,Initial_Delta[IN][d-1],Initial_Delta[IN][d]);
		  fflush(stdout);
		  assert(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0);
		}
	      }
	    }
	  }

	  if(origDelta > MIN_DELTA && Initial_Delta[IN][0] <= MIN_DELTA)
	    downcnt++;
	  if(origDelta <= MIN_DELTA && Initial_Delta[IN][0] > MIN_DELTA)
	    upcnt++;
	  if(origDELTA_RANGE <= 0 && DELTA_RANGE[IN] > 0)
	    startcnt++;

	  if(HAPSTOP_DEBUG && (HAPSTOP_DEBUG>=2 || (origDELTA_RANGE <= 0 && DELTA_RANGE[IN] > 0) || (origDELTA_RANGE > 0 && (DELTA_RANGE[IN] <= 0 || Initial_Delta[IN][0] <= MIN_DELTA)))){
	    printf("IN=%d:RANGE=%d->%d:Initial_Delta[IN][0..RANGE-1]=%0.4f,%0.4f .. %0.4f, Initial_Delta[IN][biggestD1=%d]=%0.4f,Hcuts=%0.4f..%0.4f\n",
		   IN,origDELTA_RANGE,DELTA_RANGE[IN]-1,Initial_Delta[IN][0],Initial_Delta[IN][1],Initial_Delta[IN][DELTA_RANGE[IN]-1],
		   biggestD1[IN],Initial_Delta[IN][biggestD1[IN]], (IN - 0.5)*DELTA_INTERVAL, (IN + 0.5)*DELTA_INTERVAL);
	    fflush(stdout);
	  }

	  if(DEBUG && !(0 <= biggestD1[IN] && biggestD1[IN] < localINITIAL_DELTA_RANGE && DELTA_RANGE[IN] <= localINITIAL_DELTA_RANGE)){
	    printf("IN=%d:biggestD1[IN]=%d,DELTA_RANGE[IN]=%d,localINITIAL_DELTA_RANGE=%d\n",
		   IN,biggestD1[IN],DELTA_RANGE[IN],localINITIAL_DELTA_RANGE);
	    fflush(stdout);
	    assert(0 <= biggestD1[IN] && biggestD1[IN] < localINITIAL_DELTA_RANGE && DELTA_RANGE[IN] <= localINITIAL_DELTA_RANGE);
	  }
	}
	if(VERB /* && stopcnt > 0 */){
	  if(HAPSTOP_DEBUG || VERB>=1+RELEASE){
	    int newinactivecnt = 0;
	    int newminimized = 0;
	    for(int IN = 0; IN <= maxIN; IN++){
	      if(DELTA_RANGE[IN] <= 0)
		newinactivecnt++;
	      else if(Initial_Delta[IN][0] <= MIN_DELTA)
		newminimized++;
	    }
	    printf("HapDelta optimization stopped in %d of %d regions, restarted= %d, minimized= %d -> %d(up=%d,down=%d), inactive regions= %d -> %d (MIN_DELTA= %0.4f)\n",
		   stopcnt,maxIN+1,startcnt,minimized,newminimized,upcnt,downcnt,inactivecnt,newinactivecnt,MIN_DELTA);
	  } else
	    printf("HapDelta optimization stopped in %d of %d regions, restarted= %d, original minimized= %d (up=%d,down=%d), original inactive regions= %d (MIN_DELTA= %0.4f)\n",
		   stopcnt,maxIN+1,startcnt,minimized,upcnt,downcnt,inactivecnt,MIN_DELTA);
	    
	  fflush(stdout);
	}
      }

      if(DEBUG){ /* verify that changes to HaploType have improved overall LP */ 
	hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	//	rverb = (iter==12) ? 1 : 0;
	double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			       TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	//	rverb = 0;
	if(!(fabs(nLP - newLP) < 1e-6) || !(nLP >= orignewLP - 1e-4) || VERB/* HERE >=2 */){
	  printf("%sAfter Checking for HaploType SNPs or indels: LP=%0.6f -> %0.6f SNPs=%d,Indels=%d) err=%0.6f,orignewLP=%0.6f:iter=%d,SNPcnt=%d,IndelCnt=%d\n",
		 !(fabs(nLP - newLP) < 1e-6 && (nLP >= orignewLP - 1e-4)) ? "WARNING:" : "", newLP,nLP,SNPs,Indels,nLP-newLP,orignewLP,iter,SNPcnt,IndelCnt);
	  if(VERB>=2){
	    int hap = 0;
	    for(int i = 1; i <= n; i++){
	      if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
		printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	      if(hap && HapSite[i]==3)
		hap = 0;
	      if(HapDelta[i])
		hap = 1;
	    }
	  }
	  fflush(stdout);
	  //	assert(nLP >= newLP - 1.0);// The code can recover from this failure, provided nLP >= orignewLP
	}
	if(DEBUG>=2 || !(nLP >= orignewLP - 1e-4)){ /* check that testLPA1[],testLPA2[] matches bestLPA1[],bestLPA2[] */
	  //        #pragma omp parallel for num_threads(numthreads) schedule(static,16)
	  for(int m = 0; m < MD; m++){
	    if(!(fabs(testLPA1[m]-bestLPA1[m]) < 1e-6)){
              #pragma omp critical
	      {
	        printf("WARNING:m=%d:testLPA1[m]=%0.6f,bestLPA1[m]=%0.6f(delta= %0.6f)\n",m,testLPA1[m],bestLPA1[m], testLPA1[m]-bestLPA1[m]);
		fflush(stdout);
		//    assert(fabs(testLPA1[m]-bestLPA1[m]) < 1e-4);// this assertion will occasionally fail and the code can recover from this failure
	      }
	    }
	    if(!(fabs(testLPA2[m]-bestLPA2[m]) < 1e-6)){
              #pragma omp critical
	      {
	        printf("WARNING:m=%d:testLPA2[m]=%0.6f,bestLPA2[m]=%0.6f(delta= %0.6f)\n",m,testLPA2[m],bestLPA2[m],testLPA2[m]-bestLPA2[m]);
		fflush(stdout);
		//	      assert(fabs(testLPA1[m]-bestLPA1[m]) < 1e-4);// this assertion will occasionally fail and the code can recover from this failure
	      }
	    }
	  }
	}

	if(DEBUG>=2) assert(nLP >= orignewLP - 1e-3);// NOTE :  this assertion can fail occasionally

	newLP = nLP;
	SNPcnt = SNPs;
	IndelCnt = Indels;
	/* swap testLPA,bestLPA (to improve accuracy of bestLPA) */
	double *tmp = bestLPA1; bestLPA1 = testLPA1; testLPA1 = tmp; // WAS5 bestLPA1 = tmp;
	tmp = bestLPA2; bestLPA2 = testLPA2; testLPA2 = tmp;
      }

      if(DEBUG) assert(logHapIndelPvalue < 0.0);
      if(DEBUG) assert(logHapSitePvalue < 0.0);

      if(/* && HINDELITER(iter) */ IndelCnt > 0 && (-logHapIndelPvalue) > 2.0 * (-logHapSitePvalue) /* NEW157 */ && !(Deresed/* >= HAP_MAX_DERES*/ && cresHapMaxLPdrop > 0.0)){/* try to merge neighboring HapDelta intervals bounded by HapSite==3 */

	hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);

	/* NOTE avoid expensive full hprobeval() following cleanmapH(), but be prepared to revert if cleanHmap() is needed after all */
	int cleaned = 0;
	if(iter <= HMIN_ITER){
	LcleanmapH:
	  cleanmapH(n,MD,MX,map1,map2,mapK1,mapK2,HapSite,numthreads);
	  cleaned = 1;
	  //	  rverb = (iter==44) ? 1 : 0;
  	  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels, 0);
	  //	  rverb = 0;
	  if(VERB/* HERE>=2*/){
	    if(nLP < newLP - 1e-6){
	      printf("WARNING:After cleaning up map1,map2: LP=%0.8f -> %0.8f (delta=%0.8f),SNPs=%d,Indels=%d:elapsed wall time=%0.6f\n",newLP, nLP, nLP-newLP, SNPs, Indels,wtime());
	      double logH = -log(2.0);
	      for(int m= 0; m < MD; m++){
	        double testLP = HapLP(testLPA1[m],testLPA2[m],logH);
		double bestLP = HapLP(bestLPA1[m],bestLPA2[m],logH);
		if(fabs(testLP - bestLP) > 1e-6)
		  printf("\t m=%d:testLP[m]= %0.6f, bestLP[m]= %0.6f (delta= %0.6f): testLPA1[m]=%0.6f,testLPA2[m]=%0.6f,bestLPA1[m]=%0.6f,bestLPA2[m]=%0.6f\n",
	              m, testLP, bestLP, testLP - bestLP, testLPA1[m],testLPA2[m],bestLPA1[m],bestLPA2[m]);
  	      }
	    } else
	      printf("After cleaning up map1,map2: LP=%0.8f -> %0.8f (delta=%0.8f),SNPs=%d,Indels=%d:elapsed wall time=%0.6f\n",newLP, nLP, nLP-newLP, SNPs, Indels,wtime());
	    fflush(stdout);
	  }
	  newLP = nLP;
	  SNPcnt = SNPs;
	  IndelCnt = Indels;

	  /* swap testLPA,bestLPA */
	  double *tmp = bestLPA1; bestLPA1 = testLPA1; testLPA1 = tmp; // WAS5 bestLPA1 = tmp;
	  tmp = bestLPA2; bestLPA2 = testLPA2; testLPA2 = tmp;
        }
	  
	int block = 1;
	while(block < 16 && MD > numthreads * block)
	  block *= 2;

	/* save original HapDelta[],Delta[],HapSite[] and map1,map2 in case all merges below needs to be backed out */
	int origIndelCnt = IndelCnt;
	//	int origSNPcnt = SNPcnt;
	double origLP = newLP;
	memcpy(origHapDelta,HapDelta,(n+2)*sizeof(double));
	memcpy(origDelta,Delta,(n+2)*sizeof(double));
	memcpy(origHapSite,HapSite,(n+2)*sizeof(int));

	int LoopCnt = 0;

        #pragma omp parallel num_threads(numthreads)
	{
	  int myLoopCnt = 0;

          #pragma omp for schedule(static,block)
	  for(int m = 0; m < MD; m++){
	    if(OMP_DEBUG) myLoopCnt++;
	    int M = MX[m];

	    memcpy(map1a[m],map1[m],(M+2)*sizeof(int));
	    memcpy(map2a[m],map2[m],(M+2)*sizeof(int));
	    memcpy(mapK1a[m],mapK1[m],(M+2)*sizeof(int));
	    memcpy(mapK2a[m],mapK2[m],(M+2)*sizeof(int));
	  }
	  if(OMP_DEBUG && myLoopCnt > 0){
            #pragma omp atomic
	    LoopCnt += myLoopCnt;
          }
	}
  	if(OMP_DEBUG) assert(LoopCnt == MD);

// HERE HERE HERE : try to merge nearby HapDelta[] by converting multiple seperating Labels (HapSite=3) each into 2 HapSites=1,2 on opposite Alleles
//             For HapDelta[] near end of contigs (few HapSite=3 till end), try removing HapDelta by converting HapSite=3 to HapSites=1,2 on opposite Alleles

        /* maximum number of seperating Labels that can be converted into pairs of HapSites to avoid one HapIndel */
	//	int MaxLabels = floor((-logHapIndelPvalue) * 0.5 / (-logHapSitePvalue));

        /* maximum number of seperating Labels that can be converted into pairs of HapSites to avoid both HapIndels (if the two original HapIndels cancel each other) */
	//  int MaxLabels2 = floor((-logHapIndelPvalue)/(-logHapSitePvalue));

	for(int i = 0; i < n; i++){
	  if(!(HapSite[i] == 3 && HapDelta[i]))
	    continue;
	  int LL = i+1;
	  while(LL < n && HapSite[LL] != 3)
	    LL++;
	  if(!(LL < n && HapDelta[LL]))
	    continue;
	  int RR = LL+1;
	  while(RR <= n && HapSite[RR] != 3)
	    RR++;
	  if(RR > n)
	    continue;

	  if(DEBUG) assert(HapSite[i]==3 && HapSite[LL]==3 && HapSite[RR]==3 && 1 <= i && i < LL && LL < RR && RR <= n);
	  double sum1 = 0.0, sum2 = 0.0;
	  for(int t = i; t < LL; t++)
	    sum1 += HapDelta[t];
	  for(int t = LL; t < RR; t++)
	    sum2 += HapDelta[t];
	  if(!(fabs(sum1) >= MIN_INDEL_SIZE && fabs(sum2) >= MIN_INDEL_SIZE)){
	    if(VERB >= 2){
	      printf("WARNING: i=%d,n=%d,LL=%d,RR=%d: HapDelta[i..LL-1] = sum1= %0.6f, HapDelta[LL..RR-1] = sum2 = %0.6f, MIN_INDEL_SIZE = %0.6f\n",
		     i,n,LL,RR,sum1,sum2,MIN_INDEL_SIZE);
	      for(int t = i; t <= RR; t++)
		printf("t=%d:HapSite[t]= %d, Hcuts[t]= %0.4f, HapDelta[t]= %0.6e, Delta[t]= %0.6e\n",t,HapSite[t],Hcuts[t],HapDelta[t],Delta[t]);
	      fflush(stdout);
	    }
	    continue;
	    //	    assert(fabs(sum1) >= MIN_INDEL_SIZE && fabs(sum2) >= MIN_INDEL_SIZE);
	  }

	  // NOTE : Labels with same Hcuts[] value cannot have more than one with duplicate (intersecting) HapSite[] values. Take care to avoid this happening 

	  /* locate sites L,R (i < L < LL, LL < R < RR) nearest to LL that have HapSite[L,R]==0, but Hcuts[L,R] do not match any existing label (we only need either L or R) */
	  int L = LL-1, R = LL+1;
	  while(L > i && Hcuts[L] >= Hcuts[LL] && !HapSite[L])
	    L--;
	  while(R < RR && Hcuts[R] <= Hcuts[LL] && !HapSite[R])
	    R++;

	  /* find furthest label before L or after R that has same Hcuts value : stop at nearest one with HapSite != 0 (In this case we cannot insert a new label on that side) */
	  int pL = L, pR = R;
	  while(pL > i && Hcuts[pL-1] >= Hcuts[pL] && !HapSite[pL])
	    pL--;
	  while(pR < RR && Hcuts[pR+1] <= Hcuts[pR] && !HapSite[pR])
	    pR++;

	  //	  rverb = (iter==46) ? 1 : 0;

	  if(VERB>=1+RELEASE/* HERE >=2 */){
	    printf("Trying to merge HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f:HapSite[%d,%d,%d,%d,%d,%d,%d]=%d,%d,%d,%d,%d,%d,%d,Hcuts=%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,%0.4f,%0.4f:wall=%0.6f\n",
		   i,LL,sum1,LL,RR,sum2,i,pL,L,LL,R,pR,RR,HapSite[i],HapSite[pL],HapSite[L],HapSite[LL],HapSite[R],HapSite[pR],HapSite[RR],Hcuts[i],Hcuts[pL],Hcuts[L],Hcuts[LL],Hcuts[R],Hcuts[pR],Hcuts[RR],wtime());
	    if(VERB>=3 && rverb)
	      for(int t = i; t <= RR; t++)
		printf("\t t=%d:Hcuts[t]=%0.6f,HapSite[t]=%d,HapDelta[t]=%0.6f,Delta[t]=%0.6f\n",
		       t,Hcuts[t],HapSite[t],HapDelta[t],Delta[t]);
	    fflush(stdout);
	  }

	  if(DEBUG) assert(Hcuts[L] < Hcuts[LL]);
	  if(DEBUG) assert(Hcuts[LL] < Hcuts[R]);

	  if((HapSite[R] || HapSite[pR]) && (HapSite[L] || HapSite[pL])){/* failed to find valid L or R */
	    if(VERB>=1+RELEASE/* HERE >=2 */){
	      printf("Unable to merge HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f: HapSite[pL=%d,L=%d,R=%d,pR=%d]=%d,%d,%d,%d\n",
		     i,LL,sum1,LL,RR,sum2,pL,L,R,pR,HapSite[pL],HapSite[L],HapSite[R],HapSite[pR]);
	      fflush(stdout);
	    }
	    continue;
	  }

	  if(DEBUG>=2){/* Save original Y1,Y2,N1,N2 and check they are not changed by changes in HapDelta[],Delta[],HapSite[] */
	    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);
	    memcpy(startY1,Y1,(N1+2)*sizeof(double));
	    memcpy(startY2,Y2,(N2+2)*sizeof(double));
	    startN1 = N1;
	    startN2 = N2;
	  }

	  memcpy(&prevHapDelta[i],&HapDelta[i],(RR-i)*sizeof(double));
	  memcpy(&prevDelta[i],&Delta[i],(RR-i)*sizeof(double));
	  memcpy(&prevHapSite[i],&HapSite[i],(RR-i)*sizeof(int));
	  if(HPROBEVAL_SPREAD){  /* need to backup map1[],map2[] */
	    int LoopCnt = 0;

            #pragma omp parallel num_threads(numthreads)
	    {
	      int myLoopCnt = 0;

              #pragma omp for schedule(static,block)
	      for(int m = 0; m < MD; m++){
	        if(OMP_DEBUG) myLoopCnt++;
	        int M = MX[m];

	        memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
	        memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
	        memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
	        memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
	      }
	      if(OMP_DEBUG && myLoopCnt > 0){
                #pragma omp critical
		{
		  LoopCnt += myLoopCnt;
	        }
	      }
	    }
  	    if(OMP_DEBUG) assert(LoopCnt == MD);

	    if(TIME_VERBOSE){
	      printf("Saved map1,map2 (numthreads=%d,block=%d): cum wall= %0.6f\n",numthreads,block,wtime());
	      fflush(stdout);
	    }
	  }

	  // HERE HERE : continue adding LoopCnt to debug parallel loops

	  /* chose label L or R */
	  if(HapSite[R] == 0 && HapSite[pR] == 0){/* Use HapSite[R] == 0 */

	    if(VERB>=3 && iter==15){
	      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);

	      for(int m = 0; m < MD; m++){
		//		if(m != 38 || m != 83)
		//		  continue;
		int M = MX[m];
		printf("m=%d/%d: Before remapping using Hremap[i..RR]:\n",m,MD);
		for(int J = 1; J <= M; J++){
		  int i = map1[m][J];
		  if(i < 0)
		    continue;
		  int k = mapK1[m][J];
		  int I = map1[MD][i];
		  if(I < 0)
		    continue;
		  int K = map1[MD][i-k];
		  printf("J=%d:map1[m][J]=i=%d,mapK1[m][J]=k=%d:map1[MD][i]=I=%d,Y1[I]=%0.4f,map1[MD][i-k]=K=%d,Y1[K]=%0.4f\n",J,i,k,I,Y1[I],K,Y1[K]);
		}
	      }
	      fflush(stdout);
	    }

	    /* first shift Hcuts[R] + Delta[LL] left until it is at the same location as Hcuts[LL] */
	    double shift = Hcuts[R] - Hcuts[LL] + Delta[LL];
	    Delta[R] += shift;
	    Delta[LL] -= shift;
	    HapDelta[R] += HapDelta[LL];
	    HapDelta[LL] = 0.0;

	    HapSite[LL] = 1;
	    HapSite[R] = 2;

	    double nLP = newLP - BigPen;

	    // rverb = (iter==15) ? 1 : 0;
	    if(HapDeltaSpread(n, i, RR, HapDelta, Delta, Hcuts, HapSite, Label, Index, Hremap)){
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("Unable to merge HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f (HapDeltaSpread failed)\n",i,LL,sum1,LL,RR,sum2);
		fflush(stdout);
	      }
	      //	      rverb = 0;
	    } else {
	      //	      rverb = 0;
	      int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);
	      if(err){
		if(VERB>=1+RELEASE/* HERE >=2 */){
		  printf("Unable to merge HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f (hsetmap failed)\n",i,LL,sum1,LL,RR,sum2);
		  fflush(stdout);
		}
	      } else {
		if(DEBUG>=2){/* verify that Y1,Y2,N1,N2 are unchanged after changing HapDelta[],Delta[],HapSite[] */
		  assert(N1 == startN1);
		  assert(N2 == startN2);
		  for(int I1 = 0; I1 <= N1+1; I1++)
		    assert(fabs(Y1[I1] - startY1[I1]) < 1e-10);
		  for(int I2 = 0; I2 <= N2+1; I2++)
		    assert(fabs(Y2[I2] - startY2[I2]) < 1e-10);
		}

		if(HPROBEVAL_SPREAD){  /* need to update map1[],map2[] : For map2, first remap LL to R. Then apply Hremap[]. Also delete all mappings to Hcuts[i] that are not actual labels */
		  int block = 1;
		  while(block < 16 && MD > numthreads * block)
		    block *= 2;

		  int cleanfailed = 0;

		  #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		  for(int m = 0; m < MD; m++){
		    int M = MX[m];

		    int lastI = -1, lastK,lastJ;
		    if(DEBUG) lastK = lastJ = -1;

		    for(int J = 1; J <= M; J++){
		      int I = map1[m][J];
		      if(I < 0)
			continue;
		      int K = mapK1[m][J];
		      if(DEBUG) assert(0 <= K && K < I);
		      K = I-K;

		      int origI = I;
		      int origK = K;

		      if(i <= I && I <= RR){
			if(DEBUG>=1+RELEASE && !(0 < Hremap[I] && Hremap[I] <= n)){
			  printf("m=%d/%d:J=%d,M=%d,map1[m][J]=I=%d,mapK1[m][J]=%d,K=%d,Hremap[I]= %d\n",
				 m,MD,J,M,I,mapK1[m][J],K,Hremap[I]);
			  for(int t = i; t <= RR; t++)
			    printf("t=%d:Hcuts[t]=%0.4f,prevHapSite[t]=%d,HapSite[t]=%d,Hremap[t]=%d\n",t,Hcuts[t],prevHapSite[t],HapSite[t],Hremap[t]);
			  fflush(stdout);
			  assert(0 < Hremap[I] && Hremap[I] <= n);
			}
			if(VERB>=3 && iter==15 && m==83 && I != Hremap[I]){
			  printf("map1[%d][%d] = %d -> %d due to Hremap\n",m,J, I, Hremap[I]);
			  fflush(stdout);
			}
			I = Hremap[I];
		      }
		      if(i <= K && K <= RR){
			if(DEBUG>=1+RELEASE) assert(0 < Hremap[K] && Hremap[K] <= n /* WAS I*/); // NOTE : Hremap[K] <= I may fail since some labels may be unmapped due to previous merges
			if(VERB>=3 && iter==15 && m==83 && K != Hremap[K]){
			  printf("m=%d,J=%d : I=%d, K= %d -> Hremap[K]=%d\n",m,J,I, K, Hremap[K]);
			  fflush(stdout);
			}
			K = Hremap[K];
		      }
		      if(K > I){/* swap I & K */
			int tmp = I;
			I = K;
			K = tmp;
		      }

#if 0 // HERE HERE : the following code is untested and not really needed due to recovery code (see cleanfailed below)
		      /* correct if I or K are unmapped labels */
		      while(I > K && I > lastI + 1 && !(HapSite[I] & 1))
			I--;
		      if(!(HapSite[I] & 1)){/* remove mapping of label J */
		        if(VERB>=2 && m== MDEBUG_M){
		          printf("m=%d:J=%d,map1[m][J]=I=%d,mapK1[m][J]=K=%d, lastI=%d: HapSite[I]=%d : removing mapping for label J\n",
				 m,J,I,K,lastI,HapSite[I]);
			  fflush(stdout);
		        }
		        map1[m][J] = -1;
			continue;
		      }
		      while(K < I && (K <= lastI || !(HapSite[I] & 1)))
			K++;
		      if(DEBUG) assert((HapSite[I] & 1) != 0);
		      if(DEBUG) assert(K > lastI);
		      if(K <= lastI){// fix error by unmapping J : not clear how this can happen
		        map1[m][J] = -1;
		        continue;
		      }
#endif
		      K = I-K;

		      if(DEBUG){
			if(lastI >= 0 && !(I-K > lastI)){
			  #pragma omp critical
			  {
			    if(cleaned && DEBUG < 1+RELEASE){
			      printf("map1:m=%d,J=%d,I=%d->%d->%d,K=%d->%d->%d:lastJ=%d,lastI=%d,lastK=%d:i=%d,L=%d,R=%d,RR=%d\n",m,J,map1[m][J],origI,I,mapK1[m][J],origI-origK,K,lastJ,lastI,lastK,i,L,R,RR);
			      if(i <= origI && origI <= RR)
				printf("\t Hremap[%d] = %d\n", origI, Hremap[origI]);
			      if(i <= origK && origK <= RR)
				printf("\t Hremap[%d] = %d\n", origK, Hremap[origK]);
			      fflush(stdout);
			    }

			    if(!cleaned)
			      cleanfailed |= 1;
			    else if(DEBUG>=1+RELEASE)
			      assert(I-K > lastI);
			  }
			}
			lastK = K;
			lastJ = J;
		      }
		      lastI = I;

		      map1[m][J] = I;
		      mapK1[m][J] = K;
		    }

		    if(VERB>=3 && m==38 && iter==15){
		      printf("m=%d/%d: After remapping using Hremap[i..RR]:\n",m,MD);
		      for(int J = 1; J <= M; J++){
			int i = map1[m][J];
			if(i < 0)
			  continue;
			int k = mapK1[m][J];
			int I = map1[MD][i];
			printf("J=%d:map1[m][J]=i=%d,mapK1[m][J]=k=%d:map1[MD][i]=I=%d,Y1[I]=%0.4f\n",J,i,k,I,Y1[I]);
		      }
		      fflush(stdout);
		    }

		    lastI = -1;
		    if(DEBUG) lastK = lastJ = -1;

		    for(int J = 1; J <= M; J++){
		      int I = map2[m][J];
		      if(I < 0)
			continue;
		      int K = mapK2[m][J];
		      if(DEBUG) assert(0 <= K && K < I);
		      K = I-K;

		      /* Apply mapping from LL to R */
		      if(I==LL)	I = R;
		      if(K==LL) K = R;

		      int origK = K;
		      int origI = I;

		      /* Apply Hremap[] */
		      if(i <= I && I <= RR){
			if(DEBUG>=1+RELEASE && !(0 < Hremap[I] && Hremap[I] <= n)){
			  #pragma omp critical
			  {
			    printf("m=%d/%d:J=%d,M=%d,map2[m][J]=%d,I=%d->%d,mapK2[m][J]=%d,K=%d->%d,Hremap[I]= %d: i=%d,LL=%d,L=%d,R=%d,RR=%d\n",
		                m,MD,J,M,map2[m][J],origI,I,mapK2[m][J],mapK2[m][J],origK,K,Hremap[I],i,LL,R,RR);
			    for(int t = i; t <= RR; t++)
			      printf("t=%d:Hcuts[t]=%0.4f,prevHapSite[t]=%d,HapSite[t]=%d,Hremap[t]=%d\n",t,Hcuts[t],prevHapSite[t],HapSite[t],Hremap[t]);
			    fflush(stdout);
			    assert(0 < Hremap[I] && Hremap[I] <= n);
			  }
			}
			I = Hremap[I];
		      }
		      if(i <= K && K <= RR){
			if(DEBUG>=1+RELEASE && !(0 < Hremap[K] && Hremap[K] <= n /* WAS I */)){// NOTE : Hremap[K] <= I can fail since some labels may be unmapped due to previous merges 
			  #pragma omp critical
			  {
			    printf("m=%d/%d:J=%d,M=%d,map2[m][J]=%d,I=%d->%d,mapK2[m][J]=%d,I-K=%d->%d,Hremap[I-K]= %d: i=%d,LL=%d,R=%d,RR=%d\n",
		                   m,MD,J,M,map2[m][J],origI,I,mapK2[m][J],origK,K,Hremap[K],i,LL,R,RR);
			    for(int t = i; t <= RR; t++)
			      printf("t=%d:Hcuts[t]=%0.4f,prevHapSite[t]=%d,HapSite[t]=%d,Hremap[t]=%d\n",t,Hcuts[t],prevHapSite[t],HapSite[t],Hremap[t]);
			    fflush(stdout);
			    assert(0 < Hremap[K] && Hremap[K] <= I);
			  }
			}
			K = Hremap[K];
		      }
		      if(K > I){/* swap I & K */
			int tmp = I;
			I = K;
			K = tmp;
		      }

#if 0 // HERE HERE : the following code is untested and not really needed due to recovery code (see cleanfailed below)
		      /* correct if I or K are unmapped labels */
		      while(I > K && I > lastI + 1 && !(HapSite[I] & 2))
			I--;
		      if(!(HapSite[I] & 2)){/* remove mapping of label J */
		        if(VERB>=2 && m== MDEBUG_M){
		          printf("m=%d:J=%d,map2[m][J]=I=%d,mapK2[m][J]=K=%d, lastI=%d: HapSite[I]=%d : removing mapping for label J\n",
				 m,J,I,K,lastI,HapSite[I]);
			  fflush(stdout);
		        }
		        map2[m][J] = -1;
			continue;
		      }
		      while(K < I && (K <= lastI || !(HapSite[I] & 2)))
			K++;
		      if(DEBUG) assert((HapSite[I] & 2) != 0);
		      if(DEBUG) assert(K > lastI);

		      if(K <= lastI){// fix error by unmapping J : not clear how this can happen
		        map2[m][J] = -1;
		        continue;
		      }
#endif

		      K = I-K;

		      if(DEBUG){
			if(lastI >= 0 && !(I-K > lastI)){
			  #pragma omp critical
			  {
			    if(cleaned && DEBUG < 1+RELEASE){
			      printf("map2:m=%d,J=%d,I=%d->%d->%d,K=%d->%d->%d:lastJ=%d,lastI=%d,lastK=%d:i=%d,L=%d,R=%d,RR=%d\n",m,J,map2[m][J],origI,I,mapK2[m][J],origI-origK,K,lastJ,lastI,lastK,I,L,R,RR);
			      if(i <= origI && origI <= RR)
				printf("\t Hremap[%d] = %d\n", origI, Hremap[origI]);
			      if(i <= origK && origK <= RR)
				printf("\t Hremap[%d] = %d\n", origK, Hremap[origK]);
			      fflush(stdout);
			    }

			    if(!cleaned)
			      cleanfailed |= 1;
			    else if(DEBUG>=1+RELEASE)
			      assert(I-K > lastI);
			  }
			}
			lastK = K;
			lastJ = J;
		      }
		      lastI = I;

		      map2[m][J] = I;
		      mapK2[m][J] = K;
		    }
		  }// parallel for m = 0 .. MD-1

		  if(TIME_VERBOSE){
		    printf("Modified/fixed map1,map2 (numthreads=%d, block=%d): cum wall= %0.6f\n",numthreads,block,wtime());
		    fflush(stdout);
		  }
		  if(cleanfailed){/* try to recover by calling cleanmapH() */
		    if(VERB){
		      printf("WARNING: invalid map1/map2 (cleanfailed=%d): will try to fix by calling cleanmapH()\n",cleanfailed);
		      fflush(stdout);
		    }
		    memcpy(HapDelta,origHapDelta,(n+2)*sizeof(double));
		    memcpy(Delta,origDelta,(n+2)*sizeof(double));
		    memcpy(HapSite,origHapSite,(n+2)*sizeof(int));

                    #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		    for(int m = 0; m < MD; m++){
		       int M = MX[m];

		       memcpy(map1[m],map1a[m],(M+2)*sizeof(int));
		       memcpy(map2[m],map2a[m],(M+2)*sizeof(int));
		       memcpy(mapK1[m],mapK1a[m],(M+2)*sizeof(int));
		       memcpy(mapK2[m],mapK2a[m],(M+2)*sizeof(int));
		    }
		
		    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);
		    goto LcleanmapH;
		  }
		}

		/* verify that LP has improved due to HapDelta merger (due to change in SNPs,Indels only, since maps Y1,Y2 are unchanged) */
		//		rverb = (iter==13 && i==5038 && LL==5210 && RR==5323) ? 1 : 0;
		nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		rverb = 0;

		if(DEBUG){/* verify that change in LP was due to change in SNPs, Indels only */
		  double pLP = newLP + 2.0 * logHapSitePvalue - logHapIndelPvalue;
		  double HapDeltaMerge1 = 0.0, HapDeltaMerge2 = 0.0;
		  for(int t = i; t < LL; t++)
		    HapDeltaMerge1 += HapDelta[t];
		  for(int t = LL; t < RR; t++)
		    HapDeltaMerge2 += HapDelta[t];
		  if(!(fabs(pLP - nLP) < 1e-5 && SNPs == SNPcnt + 2 && Indels == IndelCnt - 1) || VERB>=2 || TIME_VERBOSE){
		    printf("%sAfter merging HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f(A): LP= %0.8f -> %0.8f,SNPs=%d->%d,Indels=%d->%d, expected LP=%0.8f (err=%0.8f),SNPs=%d,Indels=%d:logHapSitePvalue=%0.8f,logHapIndelPvalue=%0.8f:cum wall=%0.6f\n",
			   !(fabs(pLP-nLP) < 1e-5 && SNPs==SNPcnt+2 && Indels == IndelCnt - 1)  ? "WARNING:":"",i,LL,sum1,LL,RR,sum2,newLP,nLP,SNPcnt,SNPs,IndelCnt,Indels,pLP,nLP-pLP,SNPcnt+2,IndelCnt-1,logHapSitePvalue,logHapIndelPvalue,wtime());
		    printf("\t i=%d,LL=%d,RR=%d,n=%d:HapDelta[i..LL]-> %0.6f,HapDelta[LL..RR]-> %0.6f,HapDelta[i..RR]=%0.6f,MIN_INDEL_SIZE= %0.6f\n",i,LL,RR,n,HapDeltaMerge1,HapDeltaMerge2,HapDeltaMerge1+HapDeltaMerge2,MIN_INDEL_SIZE);
		    if(nLP <= pLP - 100.0){// investigate serious discrepancy
		      rverb = 1;
		      double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		      rverb = 0;

		      double logH = -log(2.0);
		      double cumtestLP = 0.0, cumbestLP = 0.0, cumdelta = 0.0;
		      for(int m= 0; m < MD; m++){
	                double testLP = HapLP(testLPA1[m],testLPA2[m],logH);
			double bestLP = HapLP(bestLPA1[m],bestLPA2[m],logH);
			cumtestLP += testLP;
			cumbestLP += bestLP;
			cumdelta = testLP - bestLP;
			if(fabs(testLP - bestLP) > 1e-6)
			  printf("\t m=%d:testLP[m]= %0.6f, bestLP[m]= %0.6f (delta= %0.6f, cum= %0.6f): testLPA1[m]=%0.6f,testLPA2[m]=%0.6f,bestLPA1[m]=%0.6f,bestLPA2[m]=%0.6f,cumtest=%0.6f,cumbest=%0.6f\n",
		      m, testLP, bestLP, testLP - bestLP, cumdelta, testLPA1[m],testLPA2[m],bestLPA1[m],bestLPA2[m],cumtestLP,cumbestLP);
		      }
		      printf("nLP2= %0.6f, previous nLP= %0.6f (which triggered this error)\n",nLP2,nLP);
		      fflush(stdout);
		    }
		    fflush(stdout);
		    assert(SNPs == SNPcnt + 2);
		    assert(Indels <= IndelCnt - 1);// Two indels could cancel each other
		    if(DEBUG>=1+RELEASE) assert(nLP > pLP - 100.0);// HERE : comment out to undo failed merge below
		    //		    assert(nLP > pLP - 1.0);
		  }
		}
	      }
            }

	    if(nLP > newLP){
	      if(VERB/* HERE >=2 */){
		printf("Merged HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f: LP= %0.8f -> %0.8f, SNPs=%d, Indels=%d: cum wall=%0.6f\n",i,LL,sum1,LL,RR,sum2, newLP, nLP, SNPs, Indels,wtime());
		fflush(stdout);
	      }
	      newLP = nLP;
	      IndelCnt = Indels;
	      SNPcnt = SNPs;

	      /* swap testLPA,bestLPA */
	      double *tmp = bestLPA1; bestLPA1 = testLPA1; testLPA1 = tmp; // WAS5 bestLPA1 = tmp;
	      tmp = bestLPA2; bestLPA2 = testLPA2; testLPA2 = tmp;

	      if(DELTA_STOP){/* activate intervals overlapping this HapIndel + DELTA_SCAN neighboring intervals */
		DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		int IN1 = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		int IN2 = floor((Hcuts[RR] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		IN1 = max(0, IN1);
		IN2 = min(maxIN, IN2);
		if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
		  printf("After merging HapDelta:Hcuts[i=%d,RR=%d]= %0.4f,%0.4f, IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			 i,RR,Hcuts[i],Hcuts[RR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		  fflush(stdout);
		  assert(0 <= IN1 && IN1 <= maxIN);
		}
		if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
		  printf("After merging HapDelta:Hcuts[i=%d,RR=%d]= %0.4f,%0.4f: IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			 i,RR,Hcuts[i],Hcuts[RR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		  fflush(stdout);
		  assert(0 <= IN2 && IN2 <= maxIN);
		}
		if(DEBUG) assert(IN1 <= IN2);
		  
		int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		int origactivecnt = activecnt;

		for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
		  if(DELTA_RANGE[T] <= 0){
		    activecnt++;
		    DELTA_RANGE[T] = min_DELTA;
		    for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
		      Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
		    if(HAPSTOP_DEBUG){
		      printf("Re-Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to merging of HapDelta at Hcuts[%d..%d]=%0.4f..%0.4f\n",
			     T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
		             DELTA_RANGE[T],Initial_Delta[T][0], Initial_Delta[T][DELTA_RANGE[T]-1], i, RR, Hcuts[i], Hcuts[RR]);
		      fflush(stdout);
		    }
		  } else if(HAPSTOP_DEBUG>=2){
		    printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after merging of HapDelta with IDelta[%d]=%0.3f .. %0.3f\n",
			   T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			   DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1]);
		    fflush(stdout);
		  }
		}

		if(VERB && activecnt > origactivecnt){
		  if(VERB>=2 || HAPSTOP_DEBUG){
		    int inactivecnt = 0;
		    for(int IN = 0; IN <= maxIN; IN++)
		      if(DELTA_RANGE[IN] <= 0)
		        inactivecnt++;

		    printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f : inactive intervals = %d/%d\n",
			   activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, RR, Hcuts[i], Hcuts[RR], inactivecnt,maxIN+1);
		  } else
		    printf("Activated %d/%d intervals due to merging Hapdelta at Hcuts[%d..%d] = %0.4f..%0.4f\n",
		         activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, RR, Hcuts[i], Hcuts[RR]);
		  fflush(stdout);
		}
	      }

	      i--;/* recheck HapDelta[i..] in case another HapDelta can be merged */

	    } else {
	      if(VERB/* HERE >=2 */ && nLP > newLP - BigPen + 10.0){
		printf("WARNING:Failed to merge HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f: LP= %0.8f -> %0.8f (delta= %0.8f), SNPs=%d, Indels=%d\n",
		       i,LL,sum1,LL,RR,sum2, newLP, nLP, nLP-newLP, SNPs, Indels);
		fflush(stdout);
	      }

	      if(/* HERE HERE */0 && nLP < newLP - 10.0 && !cleaned){   // Try to revert to before start of HapDelta merging and call cleanmapH 
		if(VERB){
		  printf("WARNING: large discrepancy after merging HapDelta[] : will try to fix by calling cleanmapH() and starting over\n");
		  fflush(stdout);
		}
		memcpy(HapDelta,origHapDelta,(n+2)*sizeof(double));
		memcpy(Delta,origDelta,(n+2)*sizeof(double));
		memcpy(HapSite,origHapSite,(n+2)*sizeof(int));

                #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		for(int m = 0; m < MD; m++){
		  int M = MX[m];

		  memcpy(map1[m],map1a[m],(M+2)*sizeof(int));
		  memcpy(map2[m],map2a[m],(M+2)*sizeof(int));
		  memcpy(mapK1[m],mapK1a[m],(M+2)*sizeof(int));
		  memcpy(mapK2[m],mapK2a[m],(M+2)*sizeof(int));
	        }
		
		hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);
		goto LcleanmapH;
	      }

	      //	      double orignLP = nLP;

	      memcpy(&HapDelta[i],&prevHapDelta[i],(RR-i)*sizeof(double));
	      memcpy(&Delta[i],&prevDelta[i],(RR-i)*sizeof(double));
	      memcpy(&HapSite[i],&prevHapSite[i],(RR-i)*sizeof(int));
	      if(HPROBEVAL_SPREAD){  /* need to restore map1[],map2[] */
		int block = 1;
		while(block < 16 && MD > numthreads * block)
		  block *= 2;

                #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		for(int m = 0; m < MD; m++){
		  int M = MX[m];

		  memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		  memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		  memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		  memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
		}
		
		if(TIME_VERBOSE){
		  printf("Restored map1,map2 (block=%d): cum wall= %0.6f\n",block,wtime());
		  fflush(stdout);
	        }
	      }

  	      if(DEBUG>=2){/* verify that LP was restored */
		hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);

		//		rverb = (iter==13 && i==5038 && LL==5210 && RR==5323) ? 1 : 0;
		nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		rverb = 0;

		if(!(fabs(nLP - newLP) < 1e-6 && SNPs==SNPcnt && Indels==IndelCnt) || VERB/* HERE >=2 */){
		  if(!(fabs(nLP - newLP) < 1e-6))
		    printf("WARNING: After restoring HapDelta: nLP=%0.8f(err=%0.8f),Indels=%d, SNPs=%d\n",nLP,nLP-newLP,Indels,SNPs);
		  else
		    printf("After restoring HapDelta: nLP=%0.8f(err=%0.8f),Indels=%d, SNPs=%d\n",nLP,nLP-newLP,Indels,SNPs);
		  fflush(stdout);
		  assert(fabs(nLP - newLP) < 1e-5 && Indels == IndelCnt && SNPs==SNPcnt);
		}
	      }

	      //	      if(DEBUG>=1+RELEASE) assert(orignLP >= newLP - 1e-6);
	    }

         } else {/* Use Hapsite[L] == 0 */
	    if(DEBUG) assert(HapSite[L]==0 && HapSite[pL]==0);

	    /* first shift Hcuts[L] right until is at the same location as Hcuts[LL] + Delta[L] */	    
	    if(DEBUG) assert(HapDelta[L] == 0.0);
	    if(DEBUG) assert(Delta[L] == 0.0);
	    double shift = Hcuts[LL] - Hcuts[L];
	    /* locate previous label t (i <= t < L), with HapSite[t] != 0 */
	    int t = L-1;
	    while(t > i && !HapSite[t])
	      t--;

	    Delta[t] += shift;
	    Delta[L] = -shift;

	    HapSite[L] = 1;
	    HapSite[LL] = 2;

	    double nLP = newLP - BigPen;

	    if(HapDeltaSpread(n, i, RR, HapDelta, Delta, Hcuts, HapSite, Label, Index, Hremap)){
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("Unable to merge HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f (HapDeltaSpread failed)\n",i,LL,sum1,LL,RR,sum2);
		fflush(stdout);
	      }
	    } else {
	      int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);
	      if(err){
		if(VERB>=1+RELEASE/* HERE >=2 */){
		  printf("Unable to merge HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f (hsetmap failed)\n",i,LL,sum1,LL,RR,sum2);
		  fflush(stdout);
		}
	      } else {
		if(DEBUG>=2){/* verify that Y1,Y2,N1,N2 are unchanged after changing HapDelta[],Delta[],HapSite[] */
		  assert(N1 == startN1);
		  assert(N2 == startN2);
		  for(int I1 = 0; I1 <= N1+1; I1++)
		    assert(fabs(Y1[I1] - startY1[I1]) < 1e-8);
		  for(int I2 = 0; I2 <= N2+1; I2++)
		    assert(fabs(Y2[I2] - startY2[I2]) < 1e-8);
		}

		if(HPROBEVAL_SPREAD){    /* need to update map1[],map2[] based on map1[][]==LL->L and then Hremap[]. Also delete all mappings to Hcuts[i] that are not actual labels */
		  int block = 1;
		  while(block < 16 && MD > numthreads * block)
		    block *= 2;

		  int cleanfailed = 0;

		  #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		  for(int m = 0; m < MD; m++){
		    int M = MX[m];

		    int lastI = -1,lastK,lastJ;
		    if(DEBUG) lastK = lastJ = -1;

		    for(int J = 1; J <= M; J++){
		      int I = map1[m][J];
		      if(I < 0)
			continue;
		      int K = mapK1[m][J];
		      if(DEBUG>=1+RELEASE) assert(0 <= K && K < I);
		      K = I-K;
		      

		      /* Apply mapping from LL to L */
		      if(I==LL) I = L;
		      if(K==LL) K = L;
		      
		      int origI = I;
		      int origK = K;

		      if(i <= I && I <= RR){
			if(DEBUG>=1+RELEASE) assert(0 < Hremap[I] && Hremap[I] <= n);
			I = Hremap[I];
		      }
		      if(i <= K && K <= RR){
			if(DEBUG>=1+RELEASE) assert(0 < Hremap[K] && Hremap[K] <= n/* WAS I */);// NOTE : Hremap[K] <= I can fail since some labels may be unmapped due to previous merges 
			K = Hremap[K];
		      }
		      if(K > I){/* swap I & K */
			int tmp = I;
			I = K;
			K = tmp;
		      }

#if 0 // HERE HERE : the following code is untested and not really needed due to recovery code (see cleanfailed below)
		      /* correct if I or K are unmapped labels */
		      while(I > K && I > lastI + 1 && !(HapSite[I] & 1))
			I--;
		      if(!(HapSite[I] & 1)){/* remove mapping of label J */
		        if(VERB>=2 && m== MDEBUG_M){
		          printf("m=%d:J=%d,map1[m][J]=I=%d,mapK1[m][J]=K=%d, lastI=%d: HapSite[I]=%d : removing mapping for label J\n",
		            m,J,I,K,lastI,HapSite[I]);
			  fflush(stdout);
		        }
		        map1[m][J] = -1;
			continue;
		      }
		      while(K < I && (K <= lastI || !(HapSite[I] & 1)))
			K++;
		      if(DEBUG>=1+RELEASE) assert((HapSite[I] & 1) != 0);
		      if(DEBUG>=1+RELEASE) assert(K > lastI);
		      if(K <= lastI){// fix error by unmapping J : not clear how this can happen
		        map1[m][J] = -1;
		        continue;
		      }
#endif
		      K = I-K;

		      if(DEBUG){
			if(lastI >= 0 && !(I-K > lastI)){
			  #pragma omp critical
			  {
			    if(cleaned && DEBUG < 1+RELEASE){
			      printf("map1:m=%d,J=%d,I=%d->%d->%d,K=%d->%d->%d:lastJ=%d,lastI=%d,lastK=%d:i=%d,L=%d,R=%d,RR=%d\n",m,J,map1[m][J],origI,I,mapK1[m][J],origI-origK,K,lastJ,lastI,lastK,i,L,R,RR);
			      if(i <= origI && origI <= RR)
				printf("\t Hremap[%d] = %d\n", origI, Hremap[origI]);
			      if(i <= origK && origK <= RR)
				printf("\t Hremap[%d] = %d\n", origK, Hremap[origK]);
			      fflush(stdout);
			    }

			    if(!cleaned)
			      cleanfailed |= 1;
			    else if(DEBUG>=1+RELEASE)
			      assert(I-K > lastI);
			  }
			}
			lastK = K;
			lastJ = J;
		      }
		      lastI = I;

		      map1[m][J] = I;
		      mapK1[m][J] = K;
		    }

		    lastI = -1;
		    if(DEBUG) lastK = lastJ = -1;

		    for(int J = 1; J <= M; J++){
		      int I = map2[m][J];
		      if(I < 0)
			continue;
		      int K = mapK2[m][J];
		      if(DEBUG>=1+RELEASE) assert(0 <= K && K < I);
		      K = I-K;

		      int origK = K;
		      int origI = I;

		      if(i <= I && I <= RR){
			if(DEBUG>=1+RELEASE) assert(0 < Hremap[I] && Hremap[I] <= n);
			I = Hremap[I];
		      }
		      if(i <= K && K <= RR){
			if(DEBUG>=1+RELEASE) assert(0 < Hremap[K] && Hremap[K] <= n/*WAS I */);// NOTE : Hremap[K] <= I can fail since some labels may be unmapped due to previous merges 
			K = Hremap[K];
		      }
		      if(K > I){/* swap I & K */
			int tmp = I;
			I = K;
			K = tmp;
		      }

#if 0 // HERE HERE : the following code is untested and not really needed due to recovery code (see cleanfailed below)
		      /* correct if I or K are unmapped labels */
		      while(I > K && I > lastI + 1 && !(HapSite[I] & 2))
			I--;
		      if(!(HapSite[I] & 2)){/* remove mapping of label J */
		        if(VERB>=2 && m== MDEBUG_M){
		          printf("m=%d:J=%d,map2[m][J]=I=%d,mapK2[m][J]=K=%d, lastI=%d: HapSite[I]=%d : removing mapping for label J\n",
				 m,J,I,K,lastI,HapSite[I]);
			  fflush(stdout);
		        }
		        map2[m][J] = -1;
			continue;
		      }
		      while(K < I && (K <= lastI || !(HapSite[I] & 2)))
			K++;
		      if(DEBUG>=1+RELEASE) assert((HapSite[I] & 2) != 0);
		      if(DEBUG>=1+RELEASE) assert(K > lastI);

		      if(K <= lastI){// fix error by unmapping J : not clear how this can happen
		        map2[m][J] = -1;
		        continue;
		      }
#endif
		      K = I-K;

		      if(DEBUG){
			if((lastI >= 0 && !(I-K > lastI)) || (VERB>=2 && (m == 8674 || m==938) && (I!=map2[m][J] || K!=mapK2[m][J]))){
			  #pragma omp critical
			  {
			    if(cleaned && DEBUG < 1+RELEASE){
			      printf("map2:m=%d,J=%d,I=%d->%d->%d,K=%d->%d->%d:lastJ=%d,lastI=%d,lastK=%d:i=%d,L=%d,R=%d,RR=%d\n",m,J,map2[m][J],origI,I,mapK2[m][J],origI-origK,K,lastJ,lastI,lastK,I,L,R,RR);
			      if(i <= origI && origI <= RR)
				printf("\t Hremap[%d] = %d\n", origI, Hremap[origI]);
			      if(i <= origK && origK <= RR)
				printf("\t Hremap[%d] = %d\n", origK, Hremap[origK]);
			      fflush(stdout);
			    }

			    if(!cleaned)
			      cleanfailed |= 2;
			    else if(DEBUG>=1+RELEASE)
			      assert(I-K > lastI);
			  }
			}
			lastK = K;
			lastJ = J;
		      }
		      lastI = I;

		      map2[m][J] = I;
		      mapK2[m][J] = K;
		    }
		  }
		  if(TIME_VERBOSE){
		    printf("Modified/fixed map1,map2 (block=%d): cum wall= %0.6f\n",block,wtime());
		    fflush(stdout);
		  }
		  if(cleanfailed){/* try to recover by calling cleanmapH() */
		    if(VERB){
		      printf("WARNING: invalid map1/map2 (cleanfailed=%d): will try to fix by calling cleanmapH()\n",cleanfailed);
		      fflush(stdout);
		    }

		    memcpy(HapDelta,origHapDelta,(n+2)*sizeof(double));
		    memcpy(Delta,origDelta,(n+2)*sizeof(double));
		    memcpy(HapSite,origHapSite,(n+2)*sizeof(int));

                    #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		    for(int m = 0; m < MD; m++){
		       int M = MX[m];

		       memcpy(map1[m],map1a[m],(M+2)*sizeof(int));
		       memcpy(map2[m],map2a[m],(M+2)*sizeof(int));
		       memcpy(mapK1[m],mapK1a[m],(M+2)*sizeof(int));
		       memcpy(mapK2[m],mapK2a[m],(M+2)*sizeof(int));
		    }
		
		    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);
		    
		    goto LcleanmapH;
		  }
		}

		/* verify that LP has improved due to HapDelta merger */
		//		rverb = (iter==13 && i==320 && LL==339 && RR==345) ? 1 : 0;
		nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		//		rverb = 0;
		if(DEBUG>=1+RELEASE/* HERE >=2 */){/* verify that change in LP was due to change in SNPs, Indels only */
		  double pLP = newLP + 2.0 * logHapSitePvalue - logHapIndelPvalue;
		  double HapDeltaMerge1 = 0.0, HapDeltaMerge2 = 0.0;
		  for(int t = i; t < LL; t++)
		    HapDeltaMerge1 += HapDelta[t];
		  for(int t = LL; t < RR; t++)
		    HapDeltaMerge2 += HapDelta[t];
		  if(!(fabs(pLP - nLP) < 1e-5 && SNPs == SNPcnt + 2 && Indels == IndelCnt - 1) || VERB>=2 || TIME_VERBOSE){
		    printf("%sAfter merging HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f(B): LP= %0.8f -> %0.8f,SNPs=%d->%d,Indels=%d->%d, expected LP=%0.8f (err=%0.8f),SNPs=%d,Indels=%d:logHapSitePvalue=%0.8f,logHapIndelPvalue=%0.8f:cum wall=%0.6f\n",
			   !(fabs(pLP-nLP) < 1e-5 && SNPs==SNPcnt+2 && Indels == IndelCnt - 1)  ? "WARNING:":"",i,LL,sum1,LL,RR,sum2,newLP,nLP,SNPcnt,SNPs,IndelCnt,Indels,pLP,nLP-pLP,SNPcnt+2,IndelCnt-1,logHapSitePvalue,logHapIndelPvalue,wtime());
		    printf("\t i=%d,LL=%d,RR=%d,n=%d:HapDelta[i..LL]-> %0.6f,HapDelta[LL..RR]-> %0.6f,HapDelta[i..RR]=%0.6f,MIN_INDEL_SIZE= %0.6f\n",i,LL,RR,n,HapDeltaMerge1,HapDeltaMerge2,HapDeltaMerge1+HapDeltaMerge2,MIN_INDEL_SIZE);
		    if(nLP <= pLP - 1000.0){
		      double logH = -log(2.0);
		      for(int m= 0; m < MD; m++){
	                double testLP = HapLP(testLPA1[m],testLPA2[m],logH);
			double bestLP = HapLP(bestLPA1[m],bestLPA2[m],logH);
			if(fabs(testLP - bestLP) > 1e-6)
			  printf("\t m=%d:testLP[m]= %0.6f, bestLP[m]= %0.6f (delta= %0.6f): testLPA1[m]=%0.6f,testLPA2[m]=%0.6f,bestLPA1[m]=%0.6f,bestLPA2[m]=%0.6f\n",
				 m, testLP, bestLP, testLP - bestLP, testLPA1[m],testLPA2[m],bestLPA1[m],bestLPA2[m]);
		      }
		      fflush(stdout);
		    }

		    fflush(stdout);
		    if(DEBUG>=1+RELEASE) assert(nLP > pLP - 1000.0);
		    //		    assert(nLP > pLP - 1.0);
		    assert(SNPs == SNPcnt + 2);
		    assert(Indels <= IndelCnt - 1);// Two indels could cancel each other
		  }
		  rverb = 0;
		}
	      }
	    }

	    if(nLP > newLP){
	      if(VERB/* HERE >=2 */){
		printf("Merged HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f: LP= %0.8f -> %0.8f, SNPs=%d, Indels=%d:cum wall= %0.6f\n",i,LL,sum1,LL,RR,sum2, newLP, nLP, SNPs, Indels,wtime());
		fflush(stdout);
	      }
	      newLP = nLP;
	      IndelCnt = Indels;
	      SNPcnt = SNPs;

	      /* swap testLPA,bestLPA */
	      double *tmp = bestLPA1; bestLPA1 = testLPA1; testLPA1 = tmp; // WAS5 bestLPA1 = tmp;
	      tmp = bestLPA2; bestLPA2 = testLPA2; testLPA2 = tmp;

	      i--;/* recheck HapDelta[i..] in case another HapDelta can be merged */

	    } else {
	      if(VERB/* HERE >=2 */ && nLP > newLP - BigPen + 10.0){
		printf("WARNING:Failed to merge HapDelta[%d..%d]= %0.4f and HapDelta[%d..%d]= %0.4f: LP= %0.8f -> %0.8f (delta= %0.8f), SNPs=%d, Indels=%d\n",
		       i,LL,sum1,LL,RR,sum2, newLP, nLP, nLP-newLP, SNPs, Indels);
		fflush(stdout);
	      }

	      //	      double orignLP = nLP;

	      memcpy(&HapDelta[i],&prevHapDelta[i],(RR-i)*sizeof(double));
	      memcpy(&Delta[i],&prevDelta[i],(RR-i)*sizeof(double));
	      memcpy(&HapSite[i],&prevHapSite[i],(RR-i)*sizeof(int));
	      if(HPROBEVAL_SPREAD){  /* need to restore map1[],map2[] */
		int block = 1;
		while(block < 16 && MD > numthreads * block)
		  block *= 2;

                #pragma omp parallel for num_threads(numthreads) schedule(static,block)
		for(int m = 0; m < MD; m++){
		  int M = MX[m];

		  memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
		  memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
		  memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
		  memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
		}
		if(TIME_VERBOSE){
		  printf("Restored map1,map2 (block=%d): cum wall= %0.6f\n",block,wtime());
		  fflush(stdout);
	        }
	      }

	      if(DEBUG>=2){/* verify that LP was restored */
		hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);
		//		rverb = (iter==13 && i==320 && LL==339 && RR==345 && !(orignLP >= newLP - 1e-6)) ? 1 : 0;
		nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		//		rverb = 0;
		if(!(fabs(nLP - newLP) < 1e-6 && SNPs==SNPcnt && Indels==IndelCnt) || VERB/* HERE >=2 */){
		  if(!(fabs(nLP - newLP) < 1e-6))
		    printf("WARNING: After restoring HapDelta: nLP=%0.8f(err=%0.8f),Indels=%d, SNPs=%d\n",nLP,nLP-newLP,Indels,SNPs);
		  else
		    printf("After restoring HapDelta: nLP=%0.8f(err=%0.8f),Indels=%d, SNPs=%d\n",nLP,nLP-newLP,Indels,SNPs);
		  assert(fabs(nLP - newLP) < 1e-5 && Indels == IndelCnt && SNPs==SNPcnt);
		}
	      }

	      //	      if(DEBUG>=1+RELEASE) assert(orignLP >= newLP - 1e-6);
	    }
	  }
        } // for i = 0 .. n-1
	if(VERB>=1+RELEASE){
	  printf("iter=%d/%d:After trying to merge neighboring HapDelta intervals:LP= %0.8f -> %0.8f (delta= %0.8f): cum wall time=%0.6f\n",iter,maxiter,origLP,newLP, newLP-origLP, wtime());
	  fflush(stdout);
	}
	if(DEBUG && origIndelCnt != IndelCnt){	// verify full LP  and revert to original state if LP is worse than original value
	  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);
	  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		  TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  if(VERB>=1+RELEASE){
	    printf("iter=%d/%d:  Full LP= %0.8f (err= %0.8f): cum wall time= %0.6f\n", iter, maxiter, nLP, nLP-newLP, wtime());
	    fflush(stdout);
	  }
	  if(nLP < origLP - 1e-5){
	    printf("WARNING: Full LP= %0.8f is worse than original LP= %0.8f : undoing all HapDelta interval merges\n", nLP, origLP);
	    fflush(stdout);

	    memcpy(HapDelta,origHapDelta,(n+2)*sizeof(double));
	    memcpy(Delta,origDelta,(n+2)*sizeof(double));
	    memcpy(HapSite,origHapSite,(n+2)*sizeof(int));

            #pragma omp parallel for num_threads(numthreads) schedule(static,block)
	    for(int m = 0; m < MD; m++){
	      int M = MX[m];

	      memcpy(map1[m],map1a[m],(M+2)*sizeof(int));
	      memcpy(map2[m],map2a[m],(M+2)*sizeof(int));
	      memcpy(mapK1[m],mapK1a[m],(M+2)*sizeof(int));
	      memcpy(mapK2[m],mapK2a[m],(M+2)*sizeof(int));
	    }
		
	    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);
	    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);

	    if(nLP < origLP - 1e-5){
	      printf("\t After undoing merged HapDelta: LP= %0.8f (err= %0.8f), Indels=%d, SNPs=%d: cum wall time= %0.6f\n",nLP, nLP-origLP, Indels,SNPs,wtime());
	      fflush(stdout);
	      if(DEBUG>=1+RELEASE) assert(nLP >= origLP - 1e-5);
	    } else
	      printf("\t After undoing merged HapDelta: LP= %0.8f (err= %0.8f), Indels=%d, SNPs=%d: cum wall time= %0.6f\n",nLP, nLP-origLP, Indels,SNPs,wtime());
	    fflush(stdout);
	  }

	  newLP = nLP;
	  IndelCnt = Indels;
	  SNPcnt = SNPs;

	  /* swap newLPA,bestLPA */
	  double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;
	  tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;
	}
      }

      if(VERB>=2){
	printf("Haplotype Labels and Indels at end of iter=%d: SNPcnt=%d,IndelCnt=%d, imin=%d,imax=%d,n=%d\n",iter, SNPcnt, IndelCnt, imin, imax, n);
	int hap = 0;
	for(int i = 1; i <= n; i++){
	  if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
	    printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		   i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	  if(hap && HapSite[i]==3)
	    hap = 0;
	  if(HapDelta[i])
	    hap = 1;
	}
	if(hap)
	  printf("i=%d:n=%d,hap=%d\n",n+1,n,hap);

	fflush(stdout);
      }

      if(IndelCnt > 0){
	// Update all HapDeltaMerged[] 
	//  Also try to reverse HapDeltaMerged[] group unless they are bounded by Hcuts[0] or Hcuts[n+1] (that case is also handled by mprobeval()) 

	if(HINDEL_PHASED != 0.0 && HINDEL_ANNEAL != 0.0 && HINDELITER(iter) && HapIndelPvalue != initHapIndelPvalue){
	  double startHapIndelPvalue = HapIndelPvalue;
	  double startHapSitePvalue = HapSitePvalue;

	  if(DEBUG) assert(HINDEL_ANNEAL < 1.0);
	  HapIndelPvalue = max(HapIndelPvalue * HINDEL_ANNEAL, origHapIndelPvalue);
	  HapSitePvalue = max(HapSitePvalue * HINDEL_ANNEAL, origHapSitePvalue);

	  logHapIndelPvalue = log(max(HapIndelPvalue,1e-300));
	  logHapSitePvalue = log(max(HapSitePvalue, 1e-300));

	  if(startHapIndelPvalue != HapIndelPvalue || startHapSitePvalue != HapSitePvalue){
	    double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    if(VERB){
	      printf("iter=%d:Adjusted HapIndelPvalue = %0.3e -> %0.3e, HapSitePvalue = %0.3e -> %0.3e, newLP= %0.6f -> %0.6f, SNPs=%d,Indels=%d\n",
                      iter,startHapIndelPvalue, HapIndelPvalue, startHapSitePvalue, HapSitePvalue, newLP, nLP, SNPs, Indels);
	      fflush(stdout);
	    }
	    newLP = nLP;
	    SNPcnt = SNPs;
	    IndelCnt = Indels;

	    /* swap newLPA,bestLPA */
	    double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;
	    tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;

	    LPhwm = newLP;
	    LPdrop_count = 0;
	    
	    if(HAP_INDEL_SKIP_FIX)
	      HapIndelDelSkipcnt = 0;
	  }
	}

	start = mtime(); wstart = wtime();

	// check if this iteration may be the last one : will be used to force re-scoring HapDeltaScore[]
	int nHapSizeOnlyCnt = HapSizeOnlyCnt;
	if(HINDELITER(iter) && HapIndelPvalue == origHapIndelPvalue){
	  if(!hapdeltacnt && !hapsitecnt)
	    nHapSizeOnlyCnt++;
	  else
	    nHapSizeOnlyCnt = 0;
	}
	int termination = (!changecnt || (HINDELITER(iter) && !hapdeltacnt && ((HINDEL_PHASED != 0.0 && HapIndelPvalue != origHapIndelPvalue && HapIndelPvalue == initHapIndelPvalue) ||
									       (!hapsitecnt && (deltacnt <= 0 || (MAX_DELTA_ITER && nHapSizeOnlyCnt >= MAX_DELTA_ITER)))))
	      || (!HINDELITER(iter) && hapsitecnt <= 0)) ? (iter >= HMIN_ITER+2 && HINDELITER(iter) && iter > lastiter + 1 ? 1 : 0) : 0;
	if(!termination && DELTA_STOP >= 2 && SKIPMAP_ADD >= 2 && inactivecnt >= maxIN + 1)
	  termination = (iter >= HMIN_ITER + 2 && HINDELITER(iter)) ? 1 : 0;
	if(!termination && (iter >= maxiter-1 || (HINDELITER(iter) && iter >= maxiter-2)))
	  termination = 1;

	int HapIndelDelete = (HINDELITER(iter) && (HapIndelDelSkipcnt <= 0 || /* NEW75 */termination) && 
		    (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)) ? 1 : 0;

	if(VERB>=1+RELEASE){
	  printf("iter=%d,HapIndelDelSkipcnt=%d,termination=%d,HapIndelPvalue= %0.3e, origHapIndelPvalue= %0.3e, initHapIndelPvalue= %0.3e\n",
		 iter,HapIndelDelSkipcnt,termination,HapIndelPvalue,origHapIndelPvalue, initHapIndelPvalue);
	  printf("\t hapdeltacnt=%d,hapsitecnt=%d,deltacnt=%d,HapSizeOnlyCnt=%d/%d,lastiter=%d,inactivecnt=%d,maxIN=%d,maxiter=%d\n",
		 hapdeltacnt,hapsitecnt,deltacnt,HapSizeOnlyCnt,MAX_DELTA_ITER,lastiter,inactivecnt,maxIN,maxiter);
	  fflush(stdout);
	}

	// NEW55
	double startOutlierLambda = outlierLambda;
	int startOutlierType = OutlierType;
	double startPoutlier = Poutlier;
	double startPoutlierEnd = PoutlierEnd;
	double startLRbias = LRbias;
	double startSF = SF[0];
	double startSR = SR[0];

	if(HapIndelDelete){
	  HapIndelDelIter = iter;
	  
	  if(IndelScore){ /* NEW55 : adjust outlierLambda, OutlierType, Poutlier, PoutlierEnd and LRbias (if specified by -IndelScore) */
	    if(IndelDelOutlierLambda != 0.0)
	      outlierLambda = IndelDelOutlierLambda;
	    if(IndelDelOutlierType != -1)
	      OutlierType = IndelDelOutlierType;
	    if(IndelDelPoutlier >= 0.0)
	      Poutlier = IndelDelPoutlier;
	    if(IndelDelPoutlierEnd >= 0.0)
	      PoutlierEnd = IndelDelPoutlierEnd;
	    if(IndelDelLRbias != 0.0)
	      LRbias = IndelDelLRbias;
	    if(MinSFIndelDel != 0.0)
	      SF[0] = max(origSF, MinSFIndelDel);
	    if(MinSRIndelDel != 0.0)
	      SR[0] = max(origSR, MinSFIndelDel);

	    if(OutlierType != startOutlierType || outlierLambda != startOutlierLambda || Poutlier != startPoutlier || PoutlierEnd != startPoutlierEnd || LRbias != startLRbias || 
	       SF[0] != startSF || SR[0] != startSR){
	      if(VERB>=2){
		printf("Calling hprobeval() after adjusting parameters PoutlierEnd etc\n");
		fflush(stdout);
	      }
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      
	      if(VERB/* HERE >=2 */){
		printf("Adjusted OutlierType=%d to %d,Lambda=%0.2e->%0.2e,Poutlier=%0.2e->%0.2e,PoutlierEnd=%0.2e->%0.2e,LRbias=%0.2e->%0.2e,sf=%0.2f->%0.2f,sr=%0.4f->%0.4f: LP= %0.8f -> %0.8f, SNPs=%d, Indels=%d: Cum wall time= %0.6f\n",
		       startOutlierType,OutlierType,startOutlierLambda,outlierLambda,startPoutlier,Poutlier,startPoutlierEnd,PoutlierEnd,startLRbias,LRbias,startSF,SF[0],startSR,SR[0],
		       newLP, nLP, SNPs, Indels, wtime());
		fflush(stdout);
	      }
	      newLP = nLP;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;

	      /* swap newLPA,bestLPA */
	      double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;
	      tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;
	    }
	  }// If(IndelScore)
	}

	if(VERB){
	  if(HapIndelDelete)
	    printf("Scoring and trying to remove compound Indels: HapSiteConf= %0.2f, HapIndelConf= %0.2f, LP=%0.6f (Skipcnt=%d/%d): elapsed wall time=%0.6f\n", 
		    -logHapSitePvalue/log(10.0), -logHapIndelPvalue/log(10.0),newLP, HapIndelDelSkipcnt, HapIndelDelskip, wstart);
	  else
	    printf("Updating HapDeltaMerge[] at end of iter=%d: HapSiteConf= %0.2f, HapIndelConf= %0.2f, LP=%0.6f (Skipcnt=%d/%d): elapsed wall time=%0.6f\n", 
		    iter,-logHapSitePvalue/log(10.0), -logHapIndelPvalue/log(10.0),newLP, HapIndelDelSkipcnt, HapIndelDelskip,wstart);
	  if(VERB>=2){
	    int hap = 0;
	    for(int i = 1; i <= n; i++){
	      if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
		printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	      if(hap && HapSite[i]==3)
		hap = 0;
	      if(HapDelta[i])
		hap = 1;
	    }
	    if(hap)
	      printf("i=%d:n=%d,hap=%d\n",n+1,n,hap);
	  }
	  if(VERB>=3){
	    rverb = 1;
	    printf("Calling hprobeval with rverb = %d\n",rverb);
	    fflush(stdout);

	    double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				   TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    rverb = 0;
	    printf("nLP = %0.6f\n", nLP);
	    fflush(stdout);
	  }

	  fflush(stdout);
	}

	double orig_newLP = newLP;

	for(int i = 0; i <= n; i++){
	  if(i <= 0 || HapSite[i] == 3){
	    int RR = i+1;
	    while(RR <= n && HapSite[RR] != 3)
	      RR++;

	    /* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
	    double sum = 0.0, abssum = 0.0;
	    for(int t = i; t < RR; t++){
	      sum += HapDelta[t];
	      abssum += fabs(HapDelta[t]);
	    }
	    if(abssum < MIN_INDEL_SIZE)
	      abssum = sum = 0.0;
	    else if(fabs(sum) < MIN_INDEL_SIZE)
	      sum = copysign(MIN_INDEL_SIZE,sum);

	    for(int t = i; t < RR; t++)
	      HapDeltaMerged[t] = sum;

	    if(abssum == 0.0){
	      for(int t = i; t < RR; t++)
		HapDeltaScore[t] = 0.0;
	      continue;
	    }

	    double origHapDelta = HapDelta[i];

	    if(HapIndelDelete){

	      /* try to remove each Haplotype group HapDelta[i..RR-1] by calling hprobeval() and update the corresponding HapDeltaScore[] values */
	      memcpy(&prevHapDelta[i],&HapDelta[i],(RR-i)*sizeof(double));
	      memcpy(&prevDelta[i],&Delta[i],(RR-i)*sizeof(double));
	      if(HAPINDELDELETE_FIX)
		memcpy(&prevHapSite[i+1],&HapSite[i+1],(RR-i-1)*sizeof(int));

	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("Testing removal of HapIndel[%d..%d] = %0.6f (Hcuts= %0.4f .. %0.4f)\n", i, RR, HapDeltaMerged[i],Hcuts[i],Hcuts[RR]);
		fflush(stdout);
	      }

	      double bestLP = newLP - BigPen, nLP;
	      int bestAllele = 3;
	      int bestSNPs = SNPcnt, bestIndels = IndelCnt;

	      for(int t = i; t < RR; t++)
		HapDelta[t] = 0.0;

	      int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
	      if(err){
                if(VERB>=1+RELEASE/* HERE >=2 */){
		  printf("Averaged removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
		  fflush(stdout);
		}
		bestAllele = -1;
	      } else {
		nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
                if(VERB/* HERE >=2 */){
		  printf("Averaged removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs = %d, Indels=%d: wtime= %0.6f\n", 
			 i, RR, HapDeltaMerged[i], nLP, nLP > newLP ? '!':' ', nLP-newLP, SNPs, Indels,wtime());
		  fflush(stdout);
		}
		bestLP = nLP;
		bestSNPs = SNPs;
		bestIndels = Indels;
		if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){
		  /* swap newLPA and bestLPA */
		  double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		  tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		}
	      }

	      /* next try changing only Allele 1 */
	      for(int t = i; t < RR; t++)
		Delta[t] = prevDelta[t] - prevHapDelta[t];
	      if(HAPINDELDELETE_FIX){ // need to also change HapSite[i+1..RR-1] to match Allele 2 : HapSite 1 -> 0, 2 -> 3 
		for(int t = i+1; t < RR; t++){
		  if(HapSite[t] == 1)
		    HapSite[t] = 0;
		  else if(HapSite[t] == 2)
		    HapSite[t] = 3;
		}
		for(int t = RR; --t > i;){
		  if(!HapSite[t]){
		    Delta[t-1] += Delta[t];
		    Delta[t] = 0.0;
		  }
		}
	      }

	      err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
	      if(err){
		if(VERB>=1+RELEASE/* HERE >=2 */){
		  printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
		  fflush(stdout);
		}
	      } else {
		//		rverb = (iter >= 11 && i==32675 && RR==32787) ? 1 : 0;
		nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		rverb = 0;
		if(VERB/* HERE >=2 */){
		  printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime=%0.6f\n",
			 i,RR,HapDeltaMerged[i], nLP, nLP > max(bestLP,newLP) ? '!':' ',nLP - newLP, SNPs,Indels,wtime());
		  //		  printf("\t Hcuts1[%d..%d]=%0.3f .. %0.3f, Hcuts2[%d..%d]=%0.3f..%0.3f\n",i,RR,Hcuts1[i],Hcuts1[RR],i,RR,Hcuts2[i],Hcuts2[RR]);
		  fflush(stdout);
		}
		if(nLP > bestLP || bestAllele == -1){
		  bestLP = nLP;
		  bestSNPs = SNPs;
		  bestIndels = Indels;
		  bestAllele = 1;
		  if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
		    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		  }
		}
	      }

	      /* next try changing only Allele 2 */
	      for(int t = i; t < RR; t++)
		Delta[t] = prevDelta[t] + prevHapDelta[t];
	      if(HAPINDELDELETE_FIX){	      // need to also change HapSite[i+1..RR-1] to match Allele 1 : HapSite 1 -> 3, 2 -> 0 
		for(int t = i+1; t < RR; t++){
		  HapSite[t] = prevHapSite[t];
		  if(HapSite[t] == 1)
		    HapSite[t] = 3;
		  else if(HapSite[t] == 2)
		    HapSite[t] = 0;
		}
		for(int t = RR; --t > i;){
		  if(!HapSite[t]){
		    Delta[t-1] += Delta[t];
		    Delta[t] = 0.0;
		  }
		}
	      }

	      err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
	      if(err){
		if(VERB>=1+RELEASE/* HERE >=2 */){
		  printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
		  fflush(stdout);
		}
	      } else {
		//	        rverb = 0;// ((i==40956 && RR==40991) || (i==41391 && RR==41431)) ? 1 : 0;
		if(VERB && rverb){
		  printf("After Allele2 only removal of HapIndel[%d..%d] = %0.6f\n",i,RR,HapDeltaMerged[i]);
		  fflush(stdout);
		}

		nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		rverb = 0;
		if(VERB/* HERE >=2 */){
		  printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
			 i,RR,HapDeltaMerged[i], nLP, nLP > max(bestLP,newLP) ? '!' : ' ', nLP - newLP, SNPs,Indels,wtime());
		  fflush(stdout);
		}
		if(nLP > bestLP || bestAllele == -1){
		  bestLP = nLP;
		  bestSNPs = SNPs;
		  bestIndels = Indels;
		  bestAllele = 2;

		  if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
		    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		  }
		}
	      }

	      HapDeltaScore[i] = newLP - bestLP;

	      if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* confirm change & swap newLPA and bestLPA */
		if(VERB){
		  printf("Removed HapDelta[%d..%d]= %0.4f .. %0.6f = %0.6f (HapDelta[i]=%0.6f): LP=%0.6f -> %0.6f, IndelCnt=%d -> %d, SNPs=%d\n", 
			 i,RR, Hcuts[i],Hcuts[RR],HapDeltaMerged[i], origHapDelta, newLP, bestLP, IndelCnt, bestIndels, bestSNPs);
		  fflush(stdout);
		}
		if(DEBUG) assert(bestAllele != -1);
		
		hapdeltacnt++;// this is a change that might trigger additional changes.

		if(DELTA_STOP){/* activate intervals overlapping this HapIndel + DELTA_SCAN neighboring intervals */
		  DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		  int IN1 = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		  int IN2 = floor((Hcuts[RR] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		  IN1 = max(0, IN1);
		  IN2 = min(maxIN, IN2);
		  if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
		    printf("After removing HapDelta[%d..%d]= %0.6f(%0.6f,%0.6f): IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			   i,RR,HapDeltaMerged[i],Hcuts[i],Hcuts[RR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		    fflush(stdout);
		    assert(0 <= IN1 && IN1 <= maxIN);
		  }
		  if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
		    printf("After removing HapDelta[%d..%d]= %0.6f(%0.6f,%0.6f): IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			   i,RR,HapDeltaMerged[i],Hcuts[i],Hcuts[RR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		    fflush(stdout);
		    assert(0 <= IN2 && IN2 <= maxIN);
		  }
		  if(DEBUG) assert(IN1 <= IN2);
		  
		  int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		  int origactivecnt = activecnt;

		  for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
		    if(DELTA_RANGE[T] <= 0){
		      activecnt++;
		      DELTA_RANGE[T] = min_DELTA;
		      for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
			Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
		      if(HAPSTOP_DEBUG){
			printf("Re-Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to Removal of HapDelta[%d..%d] = %0.6f at Hcuts=%0.4f..%0.4f\n",
			       T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			       DELTA_RANGE[T],Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],i, RR, HapDeltaMerged[i], Hcuts[i], Hcuts[RR]);
			fflush(stdout);
		      }
		    } else if(HAPSTOP_DEBUG>=2){
		      printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after Removal of HapDelta with IDelta[%d]=%0.3f .. %0.3f\n",
			     T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			     DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1]);
		      fflush(stdout);
		    }
		  }

		  if(VERB && activecnt > origactivecnt){
		    if(VERB>=2 || HAPSTOP_DEBUG){
		      int inactivecnt = 0;
		      for(int IN = 0; IN <= maxIN; IN++)
			if(DELTA_RANGE[IN] <= 0)
			  inactivecnt++;

		      printf("Activated %d/%d intervals due to Removal of HapDelta[%d..%d] = %0.6f at Hcuts=%0.4f..%0.4f : inactive intervals= %d/%d\n",
		         activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, RR, HapDeltaMerged[i], Hcuts[i], Hcuts[RR], inactivecnt, maxIN+1);
		    } else
		      printf("Activated %d/%d intervals due to Removal of HapDelta[%d..%d] = %0.6f at Hcuts=%0.4f..%0.4f\n",
		         activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, RR, HapDeltaMerged[i], Hcuts[i], Hcuts[RR]);
		    fflush(stdout);
		  }
		}

		newLP = bestLP;
		IndelCnt = bestIndels;
		SNPcnt = bestSNPs;
		for(int t = i; t < RR; t++)
		  HapDeltaMerged[t] = 0.0;
		if(bestAllele != 2){
		  if(bestAllele == 1){
		    for(int t = i; t < RR; t++)
		      Delta[t] = prevDelta[t] - prevHapDelta[t];
		    if(HAPINDELDELETE_FIX){
		      for(int t = i+1; t < RR; t++){
			HapSite[t] = prevHapSite[t];
			if(HapSite[t] == 1)
			  HapSite[t] = 0;
			else if(HapSite[t] == 2)
			  HapSite[t] = 3;
		      }
		      for(int t = RR; --t > i;){
			if(!HapSite[t]){
			  Delta[t-1] += Delta[t];
			  Delta[t] = 0.0;
			}
		      }
		    }
		  } else {
		    for(int t = i; t < RR; t++)
		      Delta[t] = prevDelta[t];
		    if(HAPINDELDELETE_FIX)
		      for(int t = i+1; t < RR; t++)
			HapSite[t] = prevHapSite[t];
		  }
		}
		
		if(DEBUG>=2){/* verify LP is now equal to newLP */
		  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		  //		  rverb = (iter >= 11 && i==32675 && RR==32787) ? 1 : 0;
		  double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  rverb = 0;
		  if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) ||VERB/* HERE >=2 */){
		    if(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt)
		      printf("\t After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);		    
		    else
		      printf("WARNING: After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);
		    fflush(stdout);
		    if(DEBUG>=1+RELEASE) assert(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt);
		  }
		  if(DEBUG){/* verify full LP */
		    double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					  TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2, 0, 0, 0.0, 0.0, 0.0, 0.0, 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    if(!(fabs(LP - newLP) < 1e-6 && SNPs == SNPcnt && Indels == IndelCnt)){
		      printf("WARNING: After switching to Allele=%d: LP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,LP,newLP,LP-newLP, SNPs, Indels);
		      for(int m = 0; m < MD; m++){
			if(fabs(testLPA1[m] - bestLPA1[m]) > 1e-6)
			  printf("m=%d:qLPA1[m]= %0.8f, fLPA1[m]= %0.8f (err=%0.8f)\n",m, bestLPA1[m],testLPA1[m],bestLPA1[m]-testLPA1[m]);
			if(fabs(testLPA2[m] - bestLPA2[m]) > 1e-6)
			  printf("m=%d:qLPA2[m]= %0.8f, fLPA2[m]= %0.8f (err=%0.8f)\n",m, bestLPA2[m],testLPA2[m],bestLPA2[m]-testLPA2[m]);
		      }
		      fflush(stdout);
		      //		    assert(fabs(LP - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt); // this happens with id17 in NA12878A_*r4632/output/contigs/exp_refineFinal1/
		    }
		    newLP = LP;
		    IndelCnt = Indels;
		    SNPcnt = SNPs;

		    /* swap testLPA and bestLPA */
		    double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
		    tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;
		  }
		}
	      } else { /* restore original HapDelta */
		memcpy(&HapDelta[i],&prevHapDelta[i], (RR - i)*sizeof(double));
		memcpy(&Delta[i],&prevDelta[i],(RR-i)*sizeof(double));
		if(HAPINDELDELETE_FIX)
		  memcpy(&HapSite[i+1],&prevHapSite[i+1],(RR-i-1)*sizeof(int));

		if(DEBUG>=2){
		  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB>=3 || fabs(nLP - newLP) > 1e-6 || SNPcnt != SNPs || IndelCnt != Indels){
		    printf("WARNING:After restoring HapDelta[%d..%d]= %0.4f: nLP=%0.8f, expected newLP=%0.8f (err=%0.8f), SNPs=%d,Indels=%d\n",i,RR,HapDeltaMerged[i], nLP,newLP,nLP-newLP,SNPs,Indels);
		    fflush(stdout);
		    //		  assert(fabs(nLP-newLP) < 1e-5);
		    assert(nLP > orig_newLP - 1e-6);
		  }
		  SNPcnt = SNPs;
		  IndelCnt = Indels;
		}
	      }

	      for(int t = i+1; t < RR; t++)
		HapDeltaScore[t] = HapDeltaScore[i];
	    } // rescale HapDeltaScore[]

	    if(VERB>=2){
	      double DeltaSum = 0.0;
	      for(int t = i; t < RR;t++)
		DeltaSum += Delta[t];
	      printf("L=%d,R=%d:HapSite[L,R]=%d,%d,Hcuts[L]=%0.4f,Hcuts[L,R]=%0.4f,Delta[L,R]=%0.4f,HapDelta[L]=%0.4f(tot=%0.4f),HapDeltaScore=%0.2f\n",
		     i,RR,HapSite[i],HapSite[RR],Hcuts[i],Hcuts[RR]-Hcuts[i],DeltaSum,HapDelta[i],HapDeltaMerged[i],HapDeltaScore[i]);
	      fflush(stdout);
	    }
	  }
	}// for int i = 0 .. n 

	if(HapIndelDelete){ /* verify full LP */
	  double wt1 = wtime();
	  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  if(VERB || nLP < newLP - 1e-6 || IndelCnt != Indels || SNPcnt != SNPs){
	    double wt2 = wtime();
	    printf("%sAfter computing HapDeltaScore[]: nLP=%0.6f(SNPs=%d,Indels=%d), expected newLP= %0.6f (err=%0.6f), orig LP=%0.6f, SNPcnt=%d,IndelCnt=%d: wall time=%0.6f(cum=%0.6f)\n",
		   (nLP < newLP - 1e-5 || IndelCnt != Indels || SNPcnt != SNPs) ? "WARNING: " : "" , nLP,SNPs, Indels, newLP,nLP-newLP,orig_newLP, SNPcnt,IndelCnt, wt2-wt1,wt2);
	    fflush(stdout);
	    //	  assert( nLP < newLP - 1e-5);
	    //    assert(nLP >= orig_newLP - 1e-6);
	  }

	  newLP = nLP;
	  SNPcnt = SNPs;
	  IndelCnt = Indels;

	  /* swap newLPA and bestLPA */
	  double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	  tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	}

	if(OutlierType != startOutlierType || Poutlier != startPoutlier || PoutlierEnd != startPoutlierEnd || outlierLambda != startOutlierLambda || 
	   LRbias != startLRbias || SF[0] != startSF || SR[0] != startSR){// NEW55
	  OutlierType = startOutlierType;
	  Poutlier = startPoutlier;
	  PoutlierEnd = startPoutlierEnd;
	  outlierLambda = startOutlierLambda;
	  LRbias = startLRbias;
	  SF[0] = startSF;
	  SR[0] = startSR;
	  if(VERB>=2){
	    printf("Calling hprobeval() after restoring parameters PoutlierEnd etc\n");
	    fflush(stdout);
	  }
	  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  if(VERB/* HERE >=2 */){
	    printf("Restored OutlierType=%d,outlierLambda=%0.2e,Poutlier=%0.2e,PoutlierEnd=%0.2e,LRbias=%0.2e,SF=%0.3f,SR=%0.5f: LP= %0.8f -> %0.8f, SNPs=%d, Indels=%d: Cum wall time= %0.6f\n",
		   OutlierType,outlierLambda,Poutlier,PoutlierEnd, LRbias, SF[0], SR[0], newLP, nLP, SNPs, Indels, wtime());
	    fflush(stdout);
	  }

	  newLP = nLP;
	  SNPcnt = SNPs;
	  IndelCnt = Indels;
	  
	  /* swap newLPA,bestLPA */
	  double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;
	  tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;
	}

	if(VERB>=2 && HapIndelDelSkipcnt <= 0 && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue)){
	  printf("Haplotype Labels and Indels at end of iter=%d/%d: HapSiteScoreIter=%d, HapIndelDelIter=%d : SNPcnt=%d,IndelCnt=%d\n",iter, maxiter, HapSiteScoreIter, HapIndelDelIter, SNPcnt, IndelCnt);
	  int hap = 0;
	  for(int i = 1; i <= n; i++){
	    if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3)){
	      int L = i-1;
	      while(L > 0 && !HapSite[L])
		L--;
	      int LL = i;
	      while(LL > 0 && HapSite[LL] != 3)
		LL--;
	      int RR = i+1;
	      while(RR <= n && HapSite[RR] != 3)
		RR++;
	      printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.6f(tot=%0.6f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f,LL=%d,L=%d,RR=%d,HapDelta[L]=%0.6f,HapSite[L]=%d\n",
		     i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i],LL,L,RR,HapDelta[L],HapSite[L]);
	      fflush(stdout);
	      if(DEBUG && HapDelta[i]) assert(HapSite[LL]==3);
	      if(DEBUG && HapDelta[i]) assert(HapSite[RR]==3);
	      if(DEBUG && HapDelta[i] && HapSite[i] != 3)
		assert(HapSite[i]);
	      if(hap && HapSite[i]==3)
		hap = 0;
	      if(HapDelta[i])
		hap = 1;
	    }
	  }
	  fflush(stdout);
	}
	if(VERB && HINDELITER(iter)){
	  double wt = wtime();
	  if(HapIndelDelSkipcnt <= 0 && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE))
	    printf("iter=%d/%d:After trying to remove compound Haplotype Indels: LP=%0.6f->%0.6f(delta=%0.6f) Skipcnt=%d: time=%0.6f, wall time=%0.6f (cum=%0.6f)\n",
                iter,maxiter,orig_newLP,newLP,newLP-orig_newLP, HapIndelDelSkipcnt, mtime()-start, wt-wstart, wt);
	  else
	    printf("iter=%d/%d:After updating HapDeltaMerge[] for Haplotype Indel (Skipcnt=%d): time=%0.6f, wall time=%0.6f (cum=%0.6f)\n", iter,maxiter,HapIndelDelSkipcnt,mtime()-start, wt-wstart, wt);
	  if(VERB>=2){
	    int hap = 0;
	    for(int i = 1; i <= n; i++){
	      if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
		printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	      if(hap && HapSite[i]==3)
		hap = 0;
	      if(HapDelta[i])
		hap = 1;
	    }
	  }
	  fflush(stdout);
	}
	if(HINDELITER(iter) && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE) && HapIndelDelSkipcnt-- <= 0){
	  if(newLP < orig_newLP + HapSkipEps + HapSkipEpsPermap * MD)
	    HapIndelDelSkipcnt = HapIndelDelskip;
	}
      }

      if(DEBUG>=2){/* validate HapDeltaMerged[1..n] */
	for(int i = 0; i <= n; i++){
	  if(i <= 0 || HapSite[i] == 3){
	    int RR = i+1;
	    while(RR <= n && HapSite[RR] != 3)
	      RR++;

	    /* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
	    double sum = 0.0, abssum = 0.0;
	    for(int t = i; t < RR; t++){
	      sum += HapDelta[t];
	      abssum += fabs(HapDelta[t]);
	    }
	    if(abssum < MIN_INDEL_SIZE)
	      abssum = sum = 0.0;
	    else if(fabs(sum) < MIN_INDEL_SIZE)
	      sum = copysign(MIN_INDEL_SIZE,sum);
	      
	    for(int t = i; t < RR; t++){
	      if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < 1e-6)){
		printf("Before checking Haplotype Indels in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f\n",
		       iter, i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		fflush(stdout);
		assert(fabs(HapDeltaMerged[t] - sum) < 1e-6);
		//		  HapDeltaMerged[t] = sum;
	      }
	    }
	  }
	}
      }
    }// end of region crossed by Lbreakout jump

  Lbreakout:

    SNPverbose = 0;

    if(1){/* re-compute HapDeltaMerged[1..n] : needed after jump to Lbreakout */
      for(int i = 0; i <= n; i++){
	if(i <= 0 || HapSite[i] == 3){
	  int RR = i+1;
	  while(RR <= n && HapSite[RR] != 3)
	    RR++;

	  /* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
	  double sum = 0.0, abssum = 0.0;
	  for(int t = i; t < RR; t++){
	    sum += HapDelta[t];
	    abssum += fabs(HapDelta[t]);
	  }
	  if(abssum < MIN_INDEL_SIZE)
	    abssum = sum = 0.0;
	  else if(fabs(sum) < MIN_INDEL_SIZE)
	    sum = copysign(MIN_INDEL_SIZE,sum);
	      
	  for(int t = i; t < RR; t++)
	    HapDeltaMerged[t] = sum;
	}
      }
    }

    if(VERB>=2){
      /* compute DelCum[i+1] = Sum(Delta[0..i]) */
      double DeltaCum = 0.0, HapDeltaCum = 0.0;
      int ileft = n+1, iright = 0;

      for(int i = 0; i <= n; i++){
	HapDelCum[i+1] = HapDeltaCum += HapDelta[i];
	DelCum[i+1] = DeltaCum += Delta[i];
	if(HapSite[i]){
	  ileft = min(i,ileft);
	  iright = max(i,iright);
	}
      }

      printf("List of HapSite and HapDelta values after iter=%d (HapSiteScoreIter=%d,HapIndelDelIter=%d,HapSiteConf= %0.2f, HapIndelConf= %0.2f, left=%0.4f(%0.4f,%0.4f),right=%0.4f(%0.4f,%0.4f)):wtime= %0.6f\n",
	     iter, HapSiteScoreIter, HapIndelDelIter, -log(max(HapSitePvalue,1e-300))/log(10.0), -log(max(HapIndelPvalue,1e-300))/log(10.0), 
	     Hcuts[ileft], Hcuts[ileft] + DelCum[ileft] + HapDelCum[ileft], Hcuts[ileft] + DelCum[ileft] - HapDelCum[ileft],
	     Hcuts[iright], Hcuts[iright] + DelCum[iright] + HapDelCum[iright], Hcuts[iright] + DelCum[iright] - HapDelCum[iright], wtime());
	  
      int hap = 1;// To force display of first label, even if NOT a SNP;
      int ilast = 0;
      for(int i = 1; i <= imax; i++){
	if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3) /* ||HapSite[i]*/){
	  printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		 i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],Hcuts[i]+DelCum[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	  if(VERB>=2 && HapSiteScore[i] < -0.001)
	    SNPverbose = 1;
	}
	if(HapSite[i])
	  ilast = i;
	if(hap && HapSite[i]==3)
	  hap = 0;
	if(HapDelta[i])
	  hap = 1;
      }
      if(ilast > 0 && HapSite[ilast]==3){
	int i = ilast;
	printf("i=%d:HapSite[i]=%d,Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
	       i,HapSite[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
      }

      fflush(stdout);
    }

    /* if no changes have been made, break out of while() loop : make sure at least 2 iterations have passed without changes */
    int breakout = 0;
    if(!HINDELITER(iter) && !changecnt && iter >= HMIN_ITER+3){
      if(VERB){
	printf("SNPfail=%d -> %d (will skip this many SNP iterations)\n",SNPfail,min(SNP_SKIP_LIMIT, SNPfail+1));
	fflush(stdout);
      }
      SNPfail = min(SNP_SKIP_LIMIT, SNPfail + 1);/* skip next iteration for SNPs */
    }

    int inactivecnt = 0;
    for(int IN = 0; IN <= maxIN; IN++)
      inactivecnt += (DELTA_RANGE[IN] <= 0) ? 1 : 0;

    if(HINDELITER(iter) && HapIndelPvalue == origHapIndelPvalue){
      if(!hapdeltacnt && !hapsitecnt)
	HapSizeOnlyCnt++;
      else
	HapSizeOnlyCnt = 0;
    }

    if(VERB/* HERE >=2 */){
      if(DELTA_STOP >= 2)
        printf("Checking termination after iter=%d/%d: changecnt=%d,hapdeltacnt=%d,deltacnt=%d,hapsitecnt=%d,lastiter=%d,SizeOnly=%d/%d,rcnt=%d/%d,Deresed=%d/%d,Filtered=%d,HapSiteScoreIter=%d,HapIndelDelIter=%d,%d,inactivecnt=%d/%d\n",
	       iter,maxiter,changecnt,hapdeltacnt,deltacnt,hapsitecnt,lastiter,HapSizeOnlyCnt,MAX_DELTA_ITER,reversalcnt,HREVERSAL,Deresed,HAP_MAX_DERES,Filtered,HapSiteScoreIter,
	       HapIndelDelIter,HapIndelDelSkipcnt, inactivecnt, maxIN+1);
      else
        printf("Checking termination after iter=%d/%d: changecnt=%d,hapdeltacnt=%d,deltacnt=%d,hapsitecnt=%d,lastiter=%d,rcnt=%d/%d,Deresed=%d/%d,Filtered=%d,HapSiteScoreIter=%d,HapIndelDelIter=%d,%d\n",
	       iter,maxiter,changecnt,hapdeltacnt,deltacnt,hapsitecnt,lastiter,reversalcnt,HREVERSAL,Deresed,HAP_MAX_DERES,Filtered,HapSiteScoreIter,HapIndelDelIter,HapIndelDelSkipcnt);
      printf("\t HINDEL_PHASED=%0.3e,HapIndelPvalue= %0.3e, origHapIndelPvalue= %0.3e, initHapIndelPvalue= %0.3e\n",HINDEL_PHASED,HapIndelPvalue, origHapIndelPvalue, initHapIndelPvalue);
      fflush(stdout);
    }

    // NOTE : only breakout if this is an indel iterations AND there has been no progress in current iteration (hapdeltacnt <= 0) AND previous iteration (hapsitecnt <= 0) for at least MAX_DELTA_ITER iterations
    if(!changecnt
       || (HINDELITER(iter) && !hapdeltacnt && ((HINDEL_PHASED != 0.0 && HapIndelPvalue != origHapIndelPvalue && HapIndelPvalue == initHapIndelPvalue) || 
						(!hapsitecnt && (deltacnt <= 0 || (MAX_DELTA_ITER && HapSizeOnlyCnt >= MAX_DELTA_ITER))))) 
       || (!HINDELITER(iter) && hapsitecnt <= 0) /* no progress made in this iterations */
       ){
      if(((iter >= HMIN_ITER+2 && HINDELITER(iter))) && iter > lastiter + 1){
	if(VERB){
	  printf("Considering terminating due to changedcnt=%d,hapdeltacnt=%d,hapsitecnt=%d,iter=%d,lastiter=%d,HapSizeOnlyCnt=%d/%d\n",
		 changecnt,hapdeltacnt,hapsitecnt,iter,lastiter,HapSizeOnlyCnt,MAX_DELTA_ITER);
	  fflush(stdout);
	}
	breakout = 1;
      } else if(iter < HMIN_ITER){
	int origiter = iter;

	if(SNP_DELAY && SNP_DELTA_KB > 0.0 && iter < SNP_ITER){// NEW430
	  iter = SNP_ITER - 1;
	  if(VERB && iter > origiter){
	    printf("Skipping iterations %d..%d to first iteration SNP_ITER=%d without -HapSiteResDelay %0.3f %d %d\n", origiter+1, iter, SNP_ITER, HapSiteResDelay, HapSiteResN, HapSiteResL);
	    fflush(stdout);
	  }
	} else {
	  iter = HMIN_ITER - 1;
	  while(!HINDELITER(iter+1))
	    iter++;

	  if(VERB && iter > origiter){
	    printf("Skipping iterations %d..%d to jump to first Indel iteration HMIN_ITER=%d\n", origiter+1, iter,HMIN_ITER);
	    fflush(stdout);
	  }
	}

#if 0
	int origSNPIterCnt = SNPIterCnt;
	if(MinSFSwitch && MinSFLabelIter > 0 && origSNPIterCnt < MinSFLabelIter && origiter + MinSFLabelIter - 1 - origSNPIterCnt < iter){
	  iter = origiter + MinSFLabelIter - 1 - origSNPIterCnt;
	  SNPIterCnt = max(origSNPIterCnt, MinSFLabelIter - 1);
	}
	if(MinSRSwitch && MinSRLabelIter > 0 && origSNPIterCnt < MinSRLabelIter && origiter + MinSRLabelIter - 1 - origSNPIterCnt < iter){
	  iter = origiter + MinSRLabelIter - 1 - origSNPIterCnt;
	  SNPIterCnt = max(origSNPIterCnt, MinSFLabelIter - 1);
	}
#endif
	lastiter = iter - 1;
      }
    } else {
      if(!HINDELITER(iter))
	SNPfail = SNPskip = 0;
      lastiter = iter;
      totchangecnt += changecnt;
    }

    if(!breakout && DELTA_STOP >= 2 && SKIPMAP_ADD >= 2 && inactivecnt >= maxIN + 1 && iter >= HMIN_ITER+2 && HINDELITER(iter)){// NEW3 : not possible to make any more progress while inactivecnt >= maxIN + 1
      if(VERB){
	printf("Considering terminating due to inactivecnt=%d, maxIN+1= %d\n",inactivecnt, maxIN+1);
	fflush(stdout);
      }
      breakout = 1;
    }

    if(!breakout && (iter >= maxiter-1 || (HINDELITER(iter) && iter >= maxiter-2))){// maximum number of iterations exceeeded
      if(VERB){
	printf("Considering terminating due to iter=%d,maxiter=%d\n",iter,maxiter);
	fflush(stdout);
      }
      breakout = 1;
    }

    if(!breakout && ((RefineSwitchFade && !SwitchFade) || 
		     (HINDEL_PHASED != 0.0 && HapIndelPvalue != origHapIndelPvalue && HapIndelPvalue == initHapIndelPvalue))
       && HINDELITER(iter) && iter >= HMIN_ITER + 2*(MAX_SWITCH_ITER - 1)){
      if(VERB){
	printf("Turning off *Switch options and restoring Hap Pvalue(s) due to iter=%d, MAX_SWITCH_ITER=%d\n",iter,MAX_SWITCH_ITER);
	fflush(stdout);
      }
      breakout = 1;
    }

    if(!breakout)
      continue;

    if(breakout){

      int activecnt = 0;
      int origreversalcnt = reversalcnt;

      if(VERB){
        printf("iter=%d/%d: lastiter=%d, progress=%d,hapdeltacnt=%d,deltacnt=%d,hapsitecnt=%d,SwitchFade=%d/%d: Consider terminating Haplotype updates\n", 
	       iter,maxiter,lastiter, progress,hapdeltacnt,deltacnt,hapsitecnt,SwitchFade,RefineSwitchFade);
	fflush(stdout);
      }

      if(iter >= maxiter - 1 && !HINDELITER(iter)){
	if(DEBUG>=1+RELEASE) assert(checkHapSite > 0);

	if(checkHapSite != 1){
	  if(VERB){
	    printf("Terminating Haplotype Updates after final iteration to update HapSiteScores\n");
	    fflush(stdout);
	  }
	  
	  break;
	}

	if(DEBUG) assert(checkHapSite == 1);
	
	if(VERB){
	  printf("Jumping ahead to filter SNPs/Indels and Trim Allele Ends, after iteration to update HapSiteScores:iter=%d,maxiter=%d -> %d\n",iter,maxiter,checkHapSiteMaxIter);
	  fflush(stdout);
	}
	maxiter = max(maxiter, checkHapSiteMaxIter);/* restore maxiter */
	if(ForceUnphased)
	  origreversalcnt = reversalcnt-1;
	ForceUnphased = 0;
	goto LcheckHapSite;
      }

      if(RefineSwitchFade && !SwitchFade){/* turn off *Switch options and use the original values */
	if(VERB>=2){
	  printf("Before Final Switch:\n");
	  for(int i = 1; i <= n; i++)
	    if(HapSite[i])
		printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	  fflush(stdout);
	}

	SwitchFade = RefineSwitchFade;

	int startDELTA_X = DELTA_X;
	int startDELTA_Y = DELTA_Y;
	int startRANGE_Y = RANGE_Y;
	int startRANGE = RANGE;
	int startOutlierType = OutlierType;
	double startOutlierLambda = outlierLambda;
	double startPoutlier = Poutlier;
	double startPoutlierEnd = PoutlierEnd;
	double startLRbias = LRbias;
	double startSF = SF[0];
	double startSR = SR[0];
	double startViterbi = HAP_VITERBI_WT;

	DELTA_X = origDELTA_X;
	DELTA_Y = origDELTA_Y;
	RANGE = origRANGE;
	if(RANGE_UPDATE)
	  RANGE = RANGE_UPDATE;
	RANGE_Y = HINDELITER(iter) ? RANGE_Y1 : RANGE_Y2;
	OutlierType = (SwitchFade == 1) ? origOutlierType : OutlierTypeLabel;
	outlierLambda = origOutlierLambda;
	Poutlier = gorigPoutlier;
	PoutlierEnd = gorigPoutlierEnd;
	LRbias = origLRbias;
	SF[0] = origSF;
	SR[0] = origSR;
	HAP_VITERBI_WT = origViterbi;// WAS116 1.0;

	double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			       TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	if(VERB){
	  printf("Final Switch");
	  if(startRANGE != RANGE)
	    printf(" RANGE=%d->%d", startRANGE,RANGE);
	  else
	    printf(" RANGE=%d", RANGE);
	  if(startRANGE_Y != RANGE_Y)
	    printf(", RANGE_Y=%d to %d", startRANGE_Y,RANGE_Y);
	  else
	    printf(", RANGE_Y=%d", RANGE_Y);
	  if(startDELTA_X != DELTA_X)
	    printf(", DELTA_X=%d to %d",startDELTA_X,DELTA_X);
	  else
	    printf(", DELTA_X=%d",DELTA_X);
	  if(startDELTA_Y != DELTA_Y)
	    printf(", DELTA_Y=%d to %d",startDELTA_Y,DELTA_Y);
	  else
	    printf(", DELTA_Y=%d",DELTA_Y);
	  if(startOutlierType != OutlierType)
	    printf(", OutlierType=%d to %d",startOutlierType,OutlierType);
	  else
	    printf(", OutlierType=%d",OutlierType);
	  if(startOutlierLambda != outlierLambda)
	    printf(", Lambda=%0.2e to %0.2e",startOutlierLambda,outlierLambda);
	  else
	    printf(", Lambda=%0.2e",outlierLambda);
	  if(startPoutlier != Poutlier)
	    printf(", outlier=%0.2e to %0.2e",startPoutlier,Poutlier);
	  else
	    printf(", outlier=%0.2e",Poutlier);
	  if(startPoutlierEnd != PoutlierEnd)
	    printf(", outlierEnd=%0.2e to %0.2e",startPoutlierEnd,PoutlierEnd);
	  else
	    printf(", outlierEnd=%0.2e",PoutlierEnd);
	  if(startLRbias != LRbias)
	    printf(", LRbias=%0.2e to %0.2e", startLRbias, LRbias);
	  else
	    printf(", LRbias=%0.2e",LRbias);
	  if(startSF != SF[0])
	    printf(", SF=%0.3f to %0.3f",startSF,SF[0]);
	  else
	    printf(", SF=%0.3f",SF[0]);
	  if(startSR != SR[0])
	    printf(", SR=%0.5f to %0.5f",startSR,SR[0]);
	  else
	    printf(", SR=%0.5f",SR[0]);
	  if(startViterbi != HAP_VITERBI_WT)
	    printf(", Vit=%0.2f to %0.2f",startViterbi,HAP_VITERBI_WT);
	  else
	    printf(", Vit=%0.2f",HAP_VITERBI_WT);

	  printf(": LP= %0.8f -> %0.8f, SNPs=%d, Indels=%d\n", newLP, nLP,SNPs,Indels);

	  fflush(stdout);
	}

	newLP = nLP;
	SNPcnt = SNPs;
	IndelCnt = Indels;

	/* swap newLPA and bestLPA */
	double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;

	/* NEW137 : reset LPhwm etc */
	LPhwm = newLP;
	LPdrop_count = 0;
	    
	if(HAP_INDEL_SKIP_FIX)
	  HapIndelDelSkipcnt = 0;

	if(DELTA_EXPAND){ /* increase range of Delta values to at least LOW_VALUES + HIGH_VALUES + 1 */
	  // HERE HERE : only apply to regions around phase reversal locations
	  int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);
	  for(int IN = 0; IN <= maxIN; IN++){
	    DELTA_RANGE[IN] = max(min_DELTA, DELTA_RANGE[IN]);
	    // HERE : add option to reset Initial_Delta[IN][d] values to (larger) original values (starting at START_DELTA)
	    /* for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
	      Initial_Delta[IN][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE-DELTA_OVERSAMPLE)))] * 0.125;
	     */
	  }
	  if(VERB/* HERE >=2 */){
	    printf("Re-activated all %d ranges:Sizing Delta[0] values range from %0.4f to %0.4f kb:DELTA_RANGE[0]=%d,localINITIAL_DELTA_RANGE=%d,min_DELTA=%d,DELTA_OVERSAMPLE=%d\n",
		   maxIN+1,Initial_Delta[0][0], Initial_Delta[0][DELTA_RANGE[0]-1],DELTA_RANGE[0],localINITIAL_DELTA_RANGE,min_DELTA,DELTA_OVERSAMPLE);
	    fflush(stdout);
	  }

	  // make sure next iteration is NOT an Indel iteration, so that all SNPs are rechecked with new (Final) scoring function
	  if(HINDELITER(iter+1))
	    iter++;
	}

	if(!(HINDEL_PHASED != 0.0 && HapIndelPvalue != origHapIndelPvalue && HapIndelPvalue == initHapIndelPvalue)){
	  SNPfail = SNPskip = 0;
	  lastiter = iter;
	  int origmaxiter = maxiter;
	  maxiter = max(maxiter, iter + ITER_INC + (int)(max(N1,N2) * ITER_FRAC));
	  if(VERB){
	    printf("Resuming Haplotype refinement: increased maxiter= %d to %d, iter=%d\n",origmaxiter, maxiter, iter);
	    fflush(stdout);
	  }

	  continue;// next iter
	}
      }

      if(HINDEL_PHASED != 0.0 && HapIndelPvalue != origHapIndelPvalue && HapIndelPvalue == initHapIndelPvalue){/* switch or start gradual transition to 2nd phase with full HapSitePvalue applied */
	double startHapIndelPvalue = HapIndelPvalue;
	double startHapSitePvalue = HapSitePvalue;

	if(VERB){
	  /* compute DelCum[i+1] = Sum(Delta[0..i]) and HapDelCum[] */
	  double DeltaCum = 0.0, HapDeltaCum = 0.0;
	  int ileft = n+1, iright = 0;

	  for(int i = 0; i <= n; i++){
	    HapDelCum[i+1] = HapDeltaCum += HapDelta[i];
	    DelCum[i+1] = DeltaCum += Delta[i];
	    if(HapSite[i]){
	      ileft = min(i,ileft);
	      iright = max(i,iright);
	    }
	  }

	  printf("List of HapSite and HapDelta values at the end of Phase 1 (HapSiteConf= %0.2f, HapIndelConf= %0.2f, left=%0.4f(%0.4f,%0.4f),right=%0.4f(%0.4f,%0.4f)): wtime= %0.6f\n",
		 -log(max(HapSitePvalue,1e-300))/log(10.0), -log(max(HapIndelPvalue,1e-300))/log(10.0), 
		 Hcuts[ileft], Hcuts[ileft] + DelCum[ileft] + HapDelCum[ileft], Hcuts[ileft] + DelCum[ileft] - HapDelCum[ileft],
		 Hcuts[iright], Hcuts[iright] + DelCum[iright] + HapDelCum[iright], Hcuts[iright] + DelCum[iright] - HapDelCum[iright], wtime());
	  
	  for(int i = imin; i <= imax; i++){
	    if(!(HapSite[i] && (HapSite[i] <= 2 || HapDelta[i])))
	      continue;

	    int R = i+1,L = i-1;
	    while(R <= n && !HapSite[R])
	      R++;
	    while(L >= 1 && !HapSite[L])
	      L--;

	    printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f,%0.3f,Hcuts[%d..i]=%0.3f,Hcuts[i..%d]=%0.3f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		   i,HapSite[i],HapDelta[i],Hcuts[i],Hcuts[i]+DelCum[i],L,Hcuts[i]+DelCum[i]-Hcuts[L]-DelCum[L],R,Hcuts[R]+DelCum[R]-Hcuts[i]-DelCum[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	  }
	  fflush(stdout);
	}

	if(HINDEL_ANNEAL != 0.0){
	  if(DEBUG) assert(HINDEL_ANNEAL < 1.0);
	  if(!HINDEL_ANNEAL_FAST || IndelCnt > 0)
	    HapIndelPvalue = max(HapIndelPvalue * HINDEL_ANNEAL, origHapIndelPvalue);
	  else
	    HapIndelPvalue = origHapIndelPvalue;

	  if(HINDEL_ANNEAL_FAST && HapIndelPvalue * 0.999 < origHapIndelPvalue)
	    HapIndelPvalue = origHapIndelPvalue;

	  if(!HINDEL_ANNEAL_FAST || SNPcnt > 0)
	    HapSitePvalue = max(HapSitePvalue * HINDEL_ANNEAL, origHapSitePvalue);
	  else
	    HapSitePvalue = origHapSitePvalue;

	  if(HINDEL_ANNEAL_FAST && HapSitePvalue * 0.999 < origHapSitePvalue)
	    HapSitePvalue = origHapSitePvalue;

	} else {
	  HapIndelPvalue = origHapIndelPvalue;
	  HapSitePvalue = origHapSitePvalue;
	}

	logHapIndelPvalue = log(max(HapIndelPvalue,1e-300));
	logHapSitePvalue = log(max(HapSitePvalue, 1e-300));

	if(DELTA_EXPAND && !(DELTA_STOP>=3)){ /* increase range of Delta values to at least LOW_VALUES + HIGH_VALUES + 1 and (possibly) reset Initial_Delta[IN][d] values to original values (starting at START_DELTA) */
	  // HERE HERE : only apply to regions around phase reversal locations
	  int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);
	  for(int IN = 0; IN <= maxIN; IN++){
	    DELTA_RANGE[IN] = max(min_DELTA, DELTA_RANGE[IN]);
	    // HERE : add option to reset Initial_Delta[IN][d] values to (larger) original values
	    /* for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
	      Initial_Delta[IN][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE-DELTA_OVERSAMPLE)))] * 0.125;
	     */
	  }
	  if(VERB/* HERE >=2 */){
	    printf("Re-activated all %d ranges:Sizing Delta[0] values range from %0.4f to %0.4f kb:DELTA_RANGE[0]=%d,localINITIAL_DELTA_RANGE=%d,min_DELTA=%d,DELTA_OVERSAMPLE=%d\n",
		   maxIN+1,Initial_Delta[0][0], Initial_Delta[0][DELTA_RANGE[0]-1],DELTA_RANGE[0],localINITIAL_DELTA_RANGE,min_DELTA,DELTA_OVERSAMPLE);
	    fflush(stdout);
	  }
	}

	double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			       TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	if(VERB){
	  if(HapIndelPvalue == origHapIndelPvalue && HapSitePvalue == origHapSitePvalue)
	    printf("Restored HapIndelPvalue=%0.3e -> %0.3e, HapSitePvalue=%0.3e->%0.3e: newLP=%0.6f -> %0.6f,maxiter=%d->%d, SNPs=%d, Indels=%d\n",
		   startHapIndelPvalue, HapIndelPvalue, startHapSitePvalue, HapSitePvalue, newLP, nLP, maxiter, max(maxiter, iter + 16 + (max(N1,N2)/4)),SNPs, Indels);
	  else
	    printf("Gradually restoring HapIndelPvalue=%0.3e -> %0.3e, HapSitePvalue=%0.3e->%0.3e, ANNEAL=%0.4f: newLP=%0.6f -> %0.6f,maxiter=%d->%d, SNPs=%d, Indels=%d\n",
		   startHapIndelPvalue, HapIndelPvalue, startHapSitePvalue, HapSitePvalue, HINDEL_ANNEAL, newLP, nLP, maxiter, max(maxiter, iter + 16 + (max(N1,N2)/4)),SNPs, Indels);
	  fflush(stdout);
	}

	newLP = nLP;
	SNPcnt = SNPs;
	IndelCnt = Indels;

	// NEW137 : update LPhwm etc
	LPhwm = HINDELITER(iter) ? nLP : -BigPen;
	LPdrop_count = 0;
	if(HAP_INDEL_SKIP_FIX)
	  HapIndelDelSkipcnt = 0;

	if(DEBUG>=2){ /* check that testLPA1[],testLPA2[] matches bestLPA1[],bestLPA2[] */
	  for(int m = 0; m < MD; m++){
	    if(!(fabs(testLPA1[m]-bestLPA1[m]) < 1e-6)){
	      {
		printf("m=%d:testLPA1[m]=%0.6f,bestLPA1[m]=%0.6f\n",m,testLPA1[m],bestLPA1[m]);
		fflush(stdout);
		//    assert(fabs(testLPA1[m]-bestLPA1[m]) < 1e-4);// this assertion will occasionally fail and the code can recover from this failure
	      }
	    }
	    if(!(fabs(testLPA2[m]-bestLPA2[m]) < 1e-6)){
	      {
		printf("m=%d:testLPA2[m]=%0.6f,bestLPA2[m]=%0.6f\n",m,testLPA2[m],bestLPA2[m]);
		fflush(stdout);
		//	      assert(fabs(testLPA1[m]-bestLPA1[m]) < 1e-4);// this assertion will occasionally fail and the code can recover from this failure
	      }
	    }
	  }
	}

	SNPfail = SNPskip = 0;
	lastiter = iter;
	int origmaxiter = maxiter;
	maxiter = max(maxiter, iter + 16 + (max(N1,N2)/4));
	if(VERB){
	  printf("Resuming Haplotype refinement: increased maxiter= %d to %d, iter=%d\n",origmaxiter, maxiter, iter);
	  fflush(stdout);
	}

	continue;// next iter
      } // HINDEL_PHASED

      if(reversalcnt < /* WAS50 <= */ HREVERSAL || 
	 (FINAL_HREVERSAL && Deresed >= HAP_MAX_DERES - DERES_STOP && (Filtered || FILTER_STOP))){/* try reversing all SNPs/indels at or to the right of each site i : Update HapSitePhase[i],HapDeltaPhase[i] */

	if(DEBUG && HINDEL) assert(HINDELITER(iter));

	double start = mtime(), wstart = wtime();

	if(HFIX>=2 && HMAP_SWAP){
	  //	  rverb = (iter >= 87) ? 1 : 0;
	  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				 TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,2);
	  rverb = 0;

	  if(VERB){
	    double mt1= mtime(), wt1 = wtime();
	    printf("iter=%d:Updated map1,map2 before Phasing:LP=%0.8f -> %0.8f, SNPs=%d, Indels=%d: CPU= %0.6f, wall= %0.6f (cum= %0.6f)\n",
	      iter, newLP, nLP, SNPs, Indels,mt1-start,wt1-wstart,wt1);
	    fflush(stdout);
	    start = mt1;
	    wstart = wt1;
	  }
	  newLP = nLP;
	  SNPcnt = SNPs;
	  IndelCnt = Indels;
	  
	  if(DEBUG>=2){/* check if map1[] map2[] were correctly updated */
	    //	    rverb = 1;
	    double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				    TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    //	    rverb = 0;

	    if((fabs(nLP2 - newLP) > 1e-6 || SNPs != SNPcnt || Indels != IndelCnt) || VERB/* HERE >=2 */){
	      if(fabs(nLP2 - newLP) > 1e-6 || SNPs != SNPcnt || Indels != IndelCnt)
		printf("WARNING:After update of map1,map2: LP=%0.8f -> %0.8f (err= %0.8f),SNPs=%d,Indels=%d(SNPcnt=%d,IndelCnt=%d)\n",newLP, nLP2, nLP2 - newLP,SNPs,Indels,SNPcnt,IndelCnt);
	      else
		printf("After update of map1,map2: LP=%0.8f -> %0.8f (err= %0.8f),SNPs=%d,Indels=%d(SNPcnt=%d,IndelCnt=%d)\n",newLP, nLP2, nLP2 - newLP,SNPs,Indels,SNPcnt,IndelCnt);
	      fflush(stdout);
	      assert(fabs(nLP2-newLP) < 1e-5);
	    }
	  }
	}

	reversalcnt++;
	if(VERB){
	  printf("iter=%d/%d:Trying to flip HaploType phase(reversalcnt=%d/%d):Hcuts[n+1]=%0.3f,%0.3f\n",
		 iter,maxiter,reversalcnt,HREVERSAL,Hcuts[n+1],Hcuts[n+1]+DelCum[n+1]);
	  if(VERB>=2){
	    int hap = 0;
	    for(int i = 1; i <= n; i++){
	      if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
		printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	      if(hap && HapSite[i]==3)
		hap = 0;
	      if(HapDelta[i])
		hap = 1;
	    }
	  }
	  fflush(stdout);
	}

	double logPhasePvalue = -log(max(PhasePvalue, 1e-300));/* NOTE positive value, unlike previous use */
	int hcnt = 0, rcnt = 0, bcnt = 0, tSNPcnt = 0, tIndelCnt = 0;

	if(VERB){
	  /* compute DelCum[i+1] = Sum(Delta[0..i]) */
	  double DeltaCum = 0.0;
	  for(int i = 0; i <= n; i++){
	    DeltaCum += Delta[i];
	    DelCum[i+1] = DeltaCum;
	  }
	}

	if(DEBUG>=2){/* validate HapDeltaMerged[1..n] */
	  for(int i = 0; i <= n; i++){
	    if(i <= 0 || HapSite[i] == 3){
	      int RR = i+1;
	      while(RR <= n && HapSite[RR] != 3)
		RR++;

	      /* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
	      double sum = 0.0, abssum = 0.0;
	      for(int t = i; t < RR; t++){
		sum += HapDelta[t];
		abssum += fabs(HapDelta[t]);
	      }
	      if(abssum < MIN_INDEL_SIZE)
		abssum = sum = 0.0;
	      else if(fabs(sum) < MIN_INDEL_SIZE)
		sum = copysign(MIN_INDEL_SIZE,sum);
	      
	      for(int t = i; t < RR; t++){
		if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < 1e-6)){
		  printf("Before Phasing check in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f\n",
			 iter,i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		  fflush(stdout);
		  //		  HapDeltaMerged[t] = sum;
		}
	      }
	    }
	  }
	}

	// initialize all Phasing scores to 0
	for(int i = 0; i <= n; i++)
	  HapSitePhase[i] = HapDeltaPhase[i] = 0.0;

	for(int i = 0; i <= n; i++){
	  if(!(i > 0 && HapSite[i] && (HapSite[i] <= 2 || HapDeltaMerged[i]))
	     && !(i <= 0 && HapDeltaMerged[i]))
	    continue;

	  tSNPcnt += (HapSite[i] <= 2) ? 1 : 0;
	  if(HapSite[i]==3 || i <= 0)
	    tIndelCnt += (HapDeltaMerged[i] != 0.0) ? 1 : 0;
	  else
	    tIndelCnt += (HapDelta[i] != 0.0) ? 1 : 0;

	  int R = i+1, L = max(0, i-1);
	  while(R <= n && !HapSite[R])
	    R++;
	  while(L >= 1 && !HapSite[L])
	    L--;

	  int LL= -1, RR = -1;
	  LL = i;
	  while(LL > 0 && HapSite[LL] < 3)
	    LL--;
	  RR = R;
	  while(RR <= n && HapSite[RR] < 3)
	    RR++;

	  if(DEBUG && fabs(HapDelta[i]) >= MIN_INDEL_SIZE && !HapDeltaMerged[i]){
	    printf("WARNING: i=%d,HapDelta[i]=%0.4f,HapDeltaMerged[i]=%0.4f,LL=%d,L=%d,R=%d,RR=%d,HapSite[LL,L,i,R,RR]=%d,%d,%d,%d,%d\n",
		   i,HapDelta[i],HapDeltaMerged[i],LL,L,R,RR,HapSite[LL],HapSite[L],HapSite[i],HapSite[R],HapSite[RR]);
	    fflush(stdout);
	    assert(HapDeltaMerged[i]);
	  }

	  if(!hcnt || (i > 0 && HapSite[i] <= 2 && HapDeltaMerged[i-1] /* WAS2 && L > 0 */)){
	    if(i <= 0 && HapDeltaMerged[i])
	      HapDeltaPhase[i] = hcnt ? BigPen : 0.0;
	    else
	      HapSitePhase[i] = hcnt ? BigPen : 0.0;

	    if(VERB/* HERE >=2 */){
	      if(i <= 0 && HapDeltaMerged[i])
		printf("i=%d:HapDeltaPhase[i]=%0.6f,HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.3f,%0.3f,Hcuts[%d..i]=%0.3f,Hcuts[i..%d]=%0.3f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f,hcnt=%d:cum=%0.6f\n",
		       i,HapDeltaPhase[i],HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],Hcuts[i]+DelCum[i],L,Hcuts[i]+DelCum[i]-Hcuts[L]-DelCum[L],R,Hcuts[R]+DelCum[R]-Hcuts[i]-DelCum[i],
		       HapSiteScore[i],SiteScore[i],HapDeltaScore[i],hcnt,wtime());
	      else
		printf("i=%d:HapSitePhase[i]=%0.6f,HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.3f,%0.3f,Hcuts[%d..i]=%0.3f,Hcuts[i..%d]=%0.3f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f,hcnt=%d:cum=%0.6f\n",
		       i,hcnt ? BigPen : 0.0, HapSite[i],HapDelta[i], HapDeltaMerged[i],Hcuts[i],Hcuts[i]+DelCum[i],L,Hcuts[i]+DelCum[i]-Hcuts[L]-DelCum[L],R,Hcuts[R]+DelCum[R]-Hcuts[i]-DelCum[i],
		       HapSiteScore[i],SiteScore[i], HapDeltaScore[i], hcnt, wtime());
	      fflush(stdout);
	    }
	  }

	  if(DEBUG && HapSite[i] <= 2 && HapDeltaMerged[i-1] && L > 0 && !(hcnt > 0)){
	    printf("i=%d:L=%d,R=%d,LL=%d,RR=%d,HapSite[i]=%d,HapDeltaMerged[i-1]=%0.4f,HapDeltaMerged[i]=%0.4f,HapDeltaMerged[L]=%0.4f,hcnt=%d\n",
		   i,L,R,LL,RR,HapSite[i],HapDeltaMerged[i-1],HapDeltaMerged[i],HapDeltaMerged[L],hcnt);
	    fflush(stdout);
	    assert(hcnt > 0);
	  }

	  /* try reversing phase starting at SNP HapSite[i]) */
	  /* skip if in the middle of a Haplotype Indel */
	  if(i > 0 && HapSite[i] <= 2 && !HapDeltaMerged[i-1] && Hcuts[i] > Hcuts[L] && ++hcnt > 1){
	    //	    rverb = (iter >= 87 && i >= 367) ? 1 : 0;

	    if(VERB>=3){
	      printf("Trying to reverse phase starting at HapSite[i=%d]=%d -> %d,Hcuts[i]= %0.4f\n",i,HapSite[i],3-HapSite[i],Hcuts[i]);
	      fflush(stdout);

	      if(rverb){
	        (void) hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		double qLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,testLPA,pcontig,numthreads,SNPs,Indels,1);
		printf("Original Full hprobeval= %0.8f, newLP= %0.8f (err= %0.8f)\n", qLP3,newLP,qLP3 - newLP);
		if(fabs(qLP3 - newLP) > 1e-5){
		  for(int m = 0; m < MD; m++)
		    if(fabs(newLPA[m] - testLPA[m]) > 1e-6)
		      printf("m=%d/%d:bestLPA1= %0.6f,bestLPA2= %0.6f, newLPA[m]= %0.6f: testLPA1= %0.6f, testLPA2= %0.6f, testLPA[m]= %0.6f (err= %0.6f)\n",
			     m,MD,bestLPA1[m],bestLPA2[m],newLPA[m],testLPA1[m],testLPA2[m],testLPA[m],testLPA[m]-newLPA[m]);
		}
	      }
	      fflush(stdout);
	    }

	    HapSite[i] = 3 - HapSite[i];
	    int ilast = i;
	    for(int t = i+1; t <= n; t++){
	      if(HapDelta[t-1]){
		if(VERB>=3){
		  printf("  HapDelta[%d]= %0.4f ->  %0.4f\n",t-1,HapDelta[t-1],-HapDelta[t-1]);
		  fflush(stdout);
		}
		HapDelta[t-1] = -HapDelta[t-1];
		ilast = t;
	      }
	      HapDeltaMerged[t-1] = -HapDeltaMerged[t-1];

	      if(HapSite[t] && HapSite[t] <= 2){
		if(VERB>=3){
		  printf("  HapSite[%d]= %d -> %d\n",t,HapSite[t],3-HapSite[t]);
		  fflush(stdout);
		}
		HapSite[t] = 3 - HapSite[t];
		ilast = t;
	      }
	    }
	    if(DEBUG>=2) assert(HapDelta[n]==0.0);
	    HapDeltaMerged[n] = -HapDeltaMerged[n];

	    double wt0 = wtime();// HERE

	    double nLP3;
	    int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	    if(err){
	      nLP3 = newLP - BigPen;
	    } else {

	      double wt1 = 0.0; // wtime();

	      //	      rverb = (iter >= 87 && i >= 367) ? 1 : 0;
	      double qLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[i],Hcuts2[i],Hcuts2[i],0,0,0,0,testLPA,pcontig,numthreads,SNPs,Indels,1,forcemap);

	      if(DEBUG>=2){
		double wt2 = wtime();
		nLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		  TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,0.001 /* WAS Hcuts1[i] */,Hcuts1[n+1],0.001 /* WAS Hcuts2[i]*/,Hcuts2[n+1],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,1);
		double wt3 = wtime();// HERE HERE
		if(DEBUG && !(SNPs == SNPcnt && Indels == IndelCnt)){
	 	  printf("WARNING: SNPs=%d,Indels=%d (expected SNPcnt=%d,IndelCnt=%d)\n",SNPs,Indels,SNPcnt,IndelCnt);
		  fflush(stdout);
	        }
	        if(VERB>=3 || fabs(nLP3 - qLP3) > 1e-5){
		  printf("%sTesting phase reversal at HapSite[i=%d]=%d,Hcuts[i]= %0.4f: qLP3= %0.6f nLP3= %0.6f (err= %0.6f): wt1= %0.6f, wt2= %0.6f, wt3= %0.6f (cum= %0.6f)\n",
		     (fabs(nLP3 - qLP3) > 1e-5) ? "WARNING: ":"",i,HapSite[i],Hcuts[i],qLP3,nLP3,qLP3-nLP3,wt1-wt0,wt2-wt1,wt3-wt2,wt3);

		  double cumerr = 0.0, cumtestLPA = 0.0, cumnewLPA = 0.0;
		  if(rverb || (DEBUG >= 1+RELEASE && !(fabs(nLP3 - qLP3) <= 1e-5))){
	            for(int m = 0; m < MD; m++){
		      double err = testLPA[m] - newLPA[m];
		      cumerr += err;
		      cumtestLPA += testLPA[m];
		      cumnewLPA += newLPA[m];
		      if(fabs(newLPA[m] - testLPA[m]) > 1e-6){
	                printf("m=%d/%d: testLPA1[m]= %0.6f, testLPA2[m]= %0.6f, newLPA1[m]= %0.6f, newLPA2[m]= %0.6f, testLPA[m]= %0.6f, newLPA[m]= %0.6f(err= %0.6f), cum:testLPA= %0.6f, newLPA= %0.6f(err= %0.6f)\n",
	                    m,MD,testLPA1[m],testLPA2[m],newLPA1[m],newLPA2[m],testLPA[m],newLPA[m],err,cumtestLPA,cumnewLPA,cumerr);
			fflush(stdout);
	              }
		    }
		    printf("\t qLP3= %0.6f, nLP3= %0.6f, newLP= %0.6f\n",qLP3, nLP3, newLP);
		  }
		  fflush(stdout);
		  if(DEBUG>=1+RELEASE) assert(fabs(nLP3 - qLP3) <= 1e-5);
	        }
	      } // DEBUG>=2
	      else 
		nLP3 = qLP3;
	      rverb = 0;

	      if(DEBUG>=2 || nLP3 > newLP + 1e-5){
	        //		rverb = (iter >= 87 && i >= 367) ? 1 : 0;
		if(VERB>=2){
		  printf("rechecking full hprobeval() after reversing phase:rverb=%d\n",rverb);
		  fflush(stdout);
		}
		double hLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels, 1);
		if(VERB>=2 && rverb){
		  printf("nLP3=%0.6f, hLP3=%0.6f, SNPs=%d, Indels=%d (newLP=%0.6f)\n",nLP3,hLP3,SNPs,Indels,newLP);
		  fflush(stdout);
		}
		if(!(fabs(hLP3 - nLP3) < 1e-6) || (VERB>=2 && rverb)){
		  printf("%sWhile testing Phase reversal starting at HapSite[i=%d]=%d,HapDelta[i]=%0.3f,R=%d,ilast=%d,Hcuts[i,R,ilast]=%0.3f,%0.3f,%0.3f,origLP=%0.6f: nLP3=%0.6f,hLP3=%0.6f(err=%0.6f)\n",
			 (!(fabs(hLP3 - nLP3) < 1e-6)) ? "WARNING:":"",i,3-HapSite[i],-HapDelta[i],R,ilast,Hcuts[i],Hcuts[R],Hcuts[ilast],newLP,nLP3,hLP3,hLP3-nLP3);
		  fflush(stdout);
		  if(DEBUG>=2)	assert(fabs(hLP3 - nLP3) < 1e-3);
		}
		rverb = 0;
		nLP3 = hLP3;
	      } 
	    } // no hsetmap error

	    if(nLP3 > newLP + 1e-5){
	      HapSitePhase[i] = nLP3 - newLP;
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("Phase reversal starting at HapSite[%d]=%d to HapDelta[%d]=%0.4f,HapSite[%d]=%d: LP=%0.6f -> %0.6f (SNPs=%d,Indels=%d):cum= %0.6f\n",
		       i,3-HapSite[i],ilast,-HapDelta[ilast],ilast,3-HapSite[ilast], newLP,nLP3,SNPs,Indels,wtime());
		fflush(stdout);
	      }

	      if(DELTA_STOP && PHASE_DIST > 0.0){/* increase range of Delta values at Hcuts[i] and surrounding +- PHASE_DIST kb */
		DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		int IN1 = floor((Hcuts[i] - PHASE_DIST - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - HapLocalScan;
		int IN2 = floor((Hcuts[i] + PHASE_DIST - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + HapLocalScan;
				
                int cnt = 0;
		int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);
		for(int IN = max(0,IN1); IN <= min(maxIN, IN2); IN++){
		  DELTA_RANGE[IN] = max(min_DELTA, DELTA_RANGE[IN]);
		}

		if(VERB){
		  if(VERB >= 2){
		    int inactivecnt = 0;
		    for(int IN = 0; IN <= maxIN; IN++)
		      inactivecnt += (DELTA_RANGE[IN] <= 0) ? 1 : 0;
		    printf("\t Activated %d/%d intervals (total inactivecnt= %d/%d):cum= %0.6f\n",cnt, min(maxIN,IN2) - max(0,IN1)+1, inactivecnt, maxIN+1,wtime());
		  } else
		    printf("\t Activated %d/%d intervals: cum= %0.6f\n",cnt, min(maxIN,IN2) - max(0,IN1)+1, wtime());
		  fflush(stdout);
		}
	      }

	      rcnt++;

	      newLP = nLP3;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;
	      /* swap newLPA and bestLPA */
	      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	    } else {/* reset phase reversal */
	      HapSitePhase[i] = newLP - nLP3;
	      if(VERB>=3){
		printf("Undoing Phase reversal starting at HapSite[%d]=%d to HapDelta[%d]=%0.4f,HapSite[%d]=%d: LP=%0.6f -> %0.6f\n",i,3-HapSite[i],ilast,-HapDelta[ilast],ilast,3-HapSite[ilast], newLP,nLP3);
		fflush(stdout);
	      }
	      for(int t = i+1; t <= n; t++){
		if(HapDelta[t-1]){
		  if(VERB>=3){
		    printf("  HapDelta[%d]= %0.4f ->  %0.4f\n",t-1,HapDelta[t-1],-HapDelta[t-1]);
		    fflush(stdout);
		  }
		  HapDelta[t-1] = -HapDelta[t-1];
		}
		HapDeltaMerged[t-1] = -HapDeltaMerged[t-1];

		if(HapSite[t] && HapSite[t] <= 2){
		  if(VERB>=3){
		    printf("  HapSite[%d]= %d -> %d\n",t,HapSite[t],3-HapSite[t]);
		    fflush(stdout);
		  }
		  HapSite[t] = 3 - HapSite[t];
		}
	      }
	      if(DEBUG>=2) assert(HapDelta[n]==0.0);
	      HapDeltaMerged[n] = -HapDeltaMerged[n];

	      HapSite[i] = 3 - HapSite[i];

	      if(DEBUG>=2){/* check if hprobeval() has been correctly restored */
	        (void) hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */

		//		rverb = (iter >= 87 && i >= 367) ? 1 : 0;
		double  hLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,1);
		rverb = 0;
		if(VERB>=3 || (DEBUG && !(fabs(hLP3 - newLP) < 1e-6))){
		  printf("%sAfter undoing phase reversal from HapSite[i=%d]=%d : hLP=%0.6f,origLP=%0.6f(err=%0.6f). With Phase reversed nLP3= %0.6f, HapSitePhase[i]= %0.2f\n",
			 (DEBUG && !(fabs(hLP3 - newLP) < 1e-6)) ? "WARNING:" : "", i,HapSite[i],hLP3,newLP,hLP3-newLP, nLP3, HapSitePhase[i]);
		  fflush(stdout);
		  int mmax = -1;

		  double maxerr = 0.0;
		  for(int m = 0; m < MD; m++){
		    double err = fabs(newLPA1[m]-bestLPA1[m]);
		    if(!(err < 1e-6)){
		      printf("m=%d:newLPA1[m]=%0.8f,bestLPA1[m]=%0.8f(err= %0.8f)\n",m,newLPA1[m],bestLPA1[m],newLPA1[m]-bestLPA1[m]);
		      fflush(stdout);
		    }
		    if(err > maxerr){
		      maxerr = err;
		      mmax = m;
		    }

		    err = fabs(newLPA2[m]-bestLPA2[m]);
		    if(!(err < 1e-6)){
		      printf("m=%d:newLPA2[m]=%0.8f,bestLPA2[m]=%0.8f(err= %0.8f)\n",m,newLPA2[m],bestLPA2[m],newLPA2[m]-bestLPA2[m]);
		      fflush(stdout);
		    }
		    if(err > maxerr){
		      maxerr = err;
		      mmax = m;
		    }
		  }
		  if(maxerr > 0.0){
		    printf("largest absolute error = %0.8f for m=%d\n",maxerr,mmax);
		    fflush(stdout);
		  }
		  if(HMAP_TMPFIX) assert(fabs(hLP3 - newLP) < 1e-6);
		}
	      }
	    }
	    if(VERB/* HERE >= 2*/){
	      double wt5 = wtime();
	      printf("i=%d:HapSitePhase[i]=%0.6f,HapSite[i]=%d,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f,%0.3f,Hcuts[%d..i]=%0.3f,Hcuts[i..%d]=%0.3f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f:wall= %0.6f(cum=%0.6f)\n",
		     i,HapSitePhase[i],HapSite[i],HapDeltaMerged[i],Hcuts[i],Hcuts[i]+DelCum[i],L,Hcuts[i]+DelCum[i]-Hcuts[L]-DelCum[L],R,Hcuts[R]+DelCum[R]-Hcuts[i]-DelCum[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i],wt5-wt0,wt5);
	      fflush(stdout);
	    }
	    if(HapSitePhase[i] < logPhasePvalue)
	      bcnt++;
	  } // if HapSite[i] <= 2

	  /* try reversing starting at HapDelta[i] (not include SNP at HapSite[i], if any) */
	  /* skip if in the middle of a Haplotype Indel */
          if(HapDeltaMerged[i] && (i <= 0|| HapSite[i]==3) && ++hcnt > 1){
	    if(VERB>=3){
	      printf("Trying to reverse phase starting at HapDelta[%d..%d]= %0.4f, HapDeltaScore= %0.2f, HapSite[%d,%d]=%d,%d, Hcuts[%d,%d]= %0.4f,%0.4f\n",
		     i,RR-1,HapDeltaMerged[i],HapDeltaScore[i],i,RR,HapSite[i],HapSite[RR],i,RR,Hcuts[i],Hcuts[RR]);
	      fflush(stdout);
	    }

	    int ilast = i;
	    for(int t = i+1; t <= n; t++){
	      if(HapDelta[t-1]){
		HapDelta[t-1] = -HapDelta[t-1];
		ilast = t;
	      }
	      HapDeltaMerged[t-1] = -HapDeltaMerged[t-1];

	      if(HapSite[t] && HapSite[t] <= 2){
		HapSite[t] = 3 - HapSite[t];
		ilast = t;
	      }
	    }
	    if(DEBUG) assert(HapDelta[n]==0.0);
	    HapDeltaMerged[n] = -HapDeltaMerged[n];

	    int R = i+1;
	    while(R <= n && !HapSite[R])
	      R++;

	    wt0 = wtime();// HERE

	    double nLP3;
	    int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	    if(err)
	      nLP3 = newLP - BigPen;
	    else {

	      double wt1 = 0.0; //wtime();

	      //	      rverb = (iter >= 87 && i >= 367) ? 1 : 0;
	      double qLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,testLPA,pcontig,numthreads,SNPs,Indels,1,forcemap);

	      if(DEBUG>=2){
	        double wt2 = wtime();
		nLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			       TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,0.001 /* WAS Hcuts1[i] */,Hcuts1[n+1],0.001 /* WAS Hcuts2[i] */,Hcuts2[n+1],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,1);
		double wt3 = wtime();
		if(DEBUG && !(SNPs == SNPcnt && Indels == IndelCnt)){
	          printf("WARNING: SNPs=%d,Indels=%d (expected SNPcnt=%d,IndelCnt=%d)\n",SNPs,Indels,SNPcnt,IndelCnt);
		  fflush(stdout);
	        }
		if(VERB>=3 || fabs(nLP3 - qLP3) > 1e-5){
	          printf("%sTesting phase reversal at HapDelta[%d..%d]= %0.4f, HapDeltaScore= %0.2f, HapSite[%d,%d]=%d,%d: qLP3= %0.6f nLP3= %0.6f (err= %0.6f): wt1= %0.6f, wt2= %0.6f, wt3= %0.6f (cum= %0.6f)\n",
		       (fabs(nLP3 - qLP3) > 1e-5)? "WARNING: ":"",i,RR-1,HapDeltaMerged[i],HapDeltaScore[i],i,RR,HapSite[i],HapSite[RR],qLP3,nLP3,qLP3-nLP3,wt1-wt0,wt2-wt1,wt3-wt2,wt3);

		  double cumerr = 0.0, cumtestLPA = 0.0, cumnewLPA = 0.0;
		  if(rverb || (DEBUG >= 1+RELEASE && !(fabs(nLP3 - qLP3) <= 1e-5))){
	            for(int m = 0; m < MD; m++){
		      double err = testLPA[m] - newLPA[m];
		      cumerr += err;
		      cumtestLPA += testLPA[m];
		      cumnewLPA += newLPA[m];
		      if(fabs(newLPA[m] - testLPA[m]) > 1e-6){
	                printf("m=%d/%d: testLPA1[m]= %0.6f, testLPA2[m]= %0.6f, newLPA1[m]= %0.6f, newLPA2[m]= %0.6f, testLPA[m]= %0.6f, newLPA[m]= %0.6f(err= %0.6f), cum:testLPA= %0.6f, newLPA= %0.6f(err= %0.6f)\n",
	                    m,MD,testLPA1[m],testLPA2[m],newLPA1[m],newLPA2[m],testLPA[m],newLPA[m],err,cumtestLPA,cumnewLPA,cumerr);
		        fflush(stdout);
	              }
		    }
		    printf("\t qLP3= %0.6f, nLP3= %0.6f, newLP= %0.6f\n",qLP3, nLP3, newLP);
		  }
		  fflush(stdout);
		  if(DEBUG>=1+RELEASE) assert(fabs(nLP3 - qLP3) <= 1e-5);
	        }
	      } /* DEBUG>=2 */ else
	        nLP3 = qLP3;

	      rverb = 0;

	      if(DEBUG>=2 || nLP3 > newLP + 1e-5){
	        //		rverb = (iter >= 87 && i >= 367) ? 1 : 0;
		if(VERB>=2){
		  printf("rechecking full hprobeval() after reversing phase:rverb=%d\n",rverb);
		  fflush(stdout);
		}
		double hLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,1);
		rverb = 0;
		if(VERB>=2 && rverb){
		  printf("nLP3=%0.6f, hLP3=%0.6f, SNPs=%d, Indels=%d (newLP=%0.6f)\n",nLP3,hLP3,SNPs,Indels,newLP);
		  fflush(stdout);
		}
		if(!(fabs(hLP3 - nLP3) < 1e-6) || (VERB>=2 && rverb)){
		  printf("%sWhile testing Phase reversal starting at HapDelta[i=%d]=%0.3f,R=%d,ilast=%d,Hcuts[i,R,ilast]=%0.3f,%0.3f,%0.3f,origLP=%0.6f: nLP3=%0.6f,hLP3=%0.6f(err=%0.6f)\n",
			 (!(fabs(hLP3 - nLP3) < 1e-6)) ? "WARNING:":"",i,-HapDelta[i],R,ilast,Hcuts[i],Hcuts[R],Hcuts[ilast],newLP,nLP3,hLP3,hLP3-nLP3);
		  fflush(stdout);
		  if(DEBUG>=2)	assert(fabs(hLP3 - nLP3) < 1e-3);
		}
		rverb = 0;
		nLP3 = hLP3;
	      }
            } // no hsetmap error

	    if(nLP3 > newLP + 1e-5){
	      HapDeltaPhase[i] = nLP3 - newLP;
	      if(VERB/* HERE >=2 */){
		printf("Phase reversal starting at HapDelta[%d]=%0.4f to HapDelta[%d]=%0.4f,HapSite[%d]=%d: LP=%0.6f -> %0.6f (SNP=%d,Indels=%d)\n",
		       i, -HapDelta[i],ilast,-HapDelta[ilast],ilast,3-HapSite[ilast], newLP,nLP3,SNPs,Indels);
		fflush(stdout);
	      }

	      if(DELTA_STOP && PHASE_DIST > 0.0){/* increase range of Delta values at Hcuts[i] and surrounding +- PHASE_DIST kb */
		DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		int IN1 = floor((Hcuts[i] - PHASE_DIST - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - HapLocalScan;
		int IN2 = floor((Hcuts[i] + PHASE_DIST - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + HapLocalScan;
				
                int cnt = 0;
		int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);
		for(int IN = max(0,IN1); IN <= min(maxIN, IN2); IN++){
		  DELTA_RANGE[IN] = max(min_DELTA, DELTA_RANGE[IN]);
		}

		if(VERB){
		  if(VERB >= 2){
		    int inactivecnt = 0;
		    for(int IN = 0; IN <= maxIN; IN++)
		      inactivecnt += (DELTA_RANGE[IN] <= 0) ? 1 : 0;
		    printf("\t Activated %d/%d intervals (total inactivecnt= %d/%d):cum= %0.6f\n",cnt, min(maxIN,IN2) - max(0,IN1)+1, inactivecnt, maxIN+1,wtime());
		  } else
		    printf("\t Activated %d/%d intervals: cum= %0.6f\n",cnt, min(maxIN,IN2) - max(0,IN1)+1, wtime());
		  fflush(stdout);
		}
	      }

	      rcnt++;

	      newLP = nLP3;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;
	      /* swap newLPA and bestLPA */
	      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	    } else {/* reset phase reversal */
	      if(VERB>=3){
		printf("Undoing Phase reversal starting at HapDelta[%d]=%0.4f to HapDelta[%d]=%0.4f,HapSite[%d]=%d: LP=%0.6f -> %0.6f\n",
                   i, HapDeltaMerged[i], ilast,-HapDelta[ilast],ilast,3-HapSite[ilast], newLP,nLP3);
		fflush(stdout);
	      }
       
	      HapDeltaPhase[i] = newLP - nLP3;
	      for(int t = i+1; t <= n; t++){
		if(HapDelta[t-1]){
		  HapDelta[t-1] = -HapDelta[t-1];
		}
		HapDeltaMerged[t-1] = -HapDeltaMerged[t-1];

		if(HapSite[t] && HapSite[t] <= 2)
		  HapSite[t] = 3 - HapSite[t];
	      }
	      if(DEBUG>=2) assert(HapDelta[n]==0.0);
	      HapDeltaMerged[n] = -HapDeltaMerged[n];

	      if(DEBUG>=2){/* check if hprobeval() has been correctly restored */
		hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		if(VERB>=3){
		  printf("Checking hprobeval() after undoing Phase reversal\n");
		  fflush(stdout);
	        }
		//		rverb = 1;
		double hLP3 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,1);
		rverb = 0;
		if(VERB>=3 || (DEBUG && !(fabs(hLP3 - newLP) < 1e-6))){
                  printf("WARNING:After undoing phase reversal starting at HapDelta[%d]=%0.4f : hLP=%0.6f,origLP=%0.6f(err=%0.6f)\n",
			 ilast, HapDeltaMerged[i], hLP3,newLP,hLP3-newLP);
		  fflush(stdout);
		  if(HMAP_TMPFIX) assert(fabs(hLP3 - newLP) < 1e-6);// Without HMAP_TMPFIX this can happen periodically
		}
	      }
	    }
	    /* copy HapDeltaPhase[i] to all HapDeltaPhase[i+1..RR-1] */
	    for(int t = i+1; t < RR; t++)
	      HapDeltaPhase[t] = HapDeltaPhase[i];

	    if(VERB/* HERE >= 2 */){
	      double wt5 = wtime();
	      printf("i=%d:HapDeltaPhase[i]=%0.6f,HapSite[i]=%d,HapDelta[i]=%0.4f,Hcuts[i]=%0.3f,%0.3f,Hcuts[%d..i]=%0.3f,Hcuts[i..%d]=%0.3f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f,hcnt=%d:wall= %0.6f(cum=%0.6f)\n",
	      i,HapDeltaPhase[i],HapSite[i], HapDeltaMerged[i], Hcuts[i],Hcuts[i]+DelCum[i],L,Hcuts[i]+DelCum[i]-Hcuts[L]-DelCum[L],R,Hcuts[R]+DelCum[R]-Hcuts[i]-DelCum[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i],hcnt,wt5-wt0,wt5);
	      fflush(stdout);
	    }
	    if(HapDeltaPhase[i] < logPhasePvalue)
	      bcnt++;
	  }
	}/* for i = imin ... imax */

	hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			       TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,2);
	if(DEBUG && !(SNPs == SNPcnt && Indels == IndelCnt)){
	  printf("WARNING: SNPs=%d,Indels=%d (expected SNPcnt=%d,IndelCnt=%d)\n",SNPs,Indels,SNPcnt,IndelCnt);
	  fflush(stdout);
	}
	if(VERB){
	  double wt = wtime();
	  int inactivecnt = 0;
	  for(int IN = 0; IN <= maxIN; IN++)
	    inactivecnt += (DELTA_RANGE[IN] <= 0) ? 1 : 0;
	  printf("contig%lld: Found %d phase reversals, %d break points (rcnt=%d/%d),breakout=%d: LP=%0.6f,SNPs=%d,Indels=%d(inactivecnt=%d/%d): time=%0.6f, wall time=%0.6f (cum=%0.6f)\n", 
		 CMapID, rcnt, bcnt, reversalcnt, HREVERSAL, breakout, hLP, SNPs, Indels, inactivecnt,maxIN+1, mtime()-start, wt-wstart, wt);
	  fflush(stdout);
	}
	if(DEBUG && fabs(hLP - newLP) > 1e-5){
	  printf("WARNING: final hprobeval=%0.6f,newLP=%0.6f(err=%0.6f)\n",hLP,newLP,hLP-newLP);
	  fflush(stdout);
	}

	if(hLP < newLP){
	  // NEW137 : update LPhwm etc
	  LPhwm = HINDELITER(iter) ? hLP : -BigPen;
	  LPdrop_count = 0;
	  if(HAP_INDEL_SKIP_FIX)
	    HapIndelDelSkipcnt = 0;
	}

	newLP = hLP;
	SNPcnt = SNPs;
	IndelCnt = Indels;

	if(DEBUG>=2){/* check if map1[] map2[] were correctly updated */
	  //	  rverb = (iter==87) ? 1 : 0;
	  double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				  TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  rverb = 0;
	  if(fabs(nLP2 - newLP) > 1e-6 || VERB/* HERE >=2 */){
	    if(fabs(nLP2 - newLP) > 1e-6)
	      printf("WARNING:After swapping map1,map2: LP=%0.8f -> %0.8f (err= %0.8f)\n",newLP, nLP2, nLP2 - newLP);
	    else
	      printf("After swapping map1,map2: LP=%0.8f -> %0.8f (err= %0.8f)\n",newLP, nLP2, nLP2 - newLP);
	    fflush(stdout);
	    assert(fabs(nLP2-newLP) < 1e-5);
	  }
	}
	
	if(rcnt > 0 && (reversalcnt <= 1 || reversalcnt < HREVERSAL)){/* first time (or except last time) resume refinement */
	  if(DELTA_EXPAND && PHASE_DIST==0.0){	/* NEW3 : increase range of Delta values to at least LOW_VALUES + HIGH_VALUES + 1 and reset Initial_Delta[IN][d] values to original values (starting at 0.070) */
	    // NOTE : if PHASE_DIST > 0.0, select regions have already been activated

	    int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);
	    for(int IN = 0; IN <= maxIN; IN++){
	      DELTA_RANGE[IN] = max(min_DELTA, DELTA_RANGE[IN]);

	      // NOTE : it is faster if the Initial_Delta[IN][] are left at the previous values (which are typically the lowest possible values)
	      /*	    for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
			    Initial_Delta[IN][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;*/

	      if(DEBUG>=1+RELEASE){
		for(int d = 0; d < DELTA_RANGE[IN]; d++){
		  if(!(fabs(Initial_Delta[IN][d]) < 1000.0)){
		    printf("Initial_Delta[IN=%d][d=%d] = %0.4f is too large\n",IN,d,Initial_Delta[IN][d]);
		    fflush(stdout);
		    assert(fabs(Initial_Delta[IN][d] < 1000.0));
		  }
		  if(d > 0 && !(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0)){
		    printf("Initial_Delta[IN=%d][d=%d,%d] = %0.4f,%0.4f ratio is too large\n",IN,d-1,d,Initial_Delta[IN][d-1],Initial_Delta[IN][d]);
		    fflush(stdout);
		    assert(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0);
		  }
		}	
	      }
	    }
	    if(VERB/* HERE >=2 */){
	      printf("Re-activated all %d ranges:Sizing Delta[0] values range from %0.4f to %0.4f kb:DELTA_RANGE[0]=%d,localINITIAL_DELTA_RANGE=%d,min_DELTA=%d,DELTA_OVERSAMPLE=%d\n",
		     maxIN+1,Initial_Delta[0][0], Initial_Delta[0][DELTA_RANGE[0]-1],DELTA_RANGE[0],localINITIAL_DELTA_RANGE,min_DELTA,DELTA_OVERSAMPLE);
	      fflush(stdout);
	    }
	  }

	  if(HINDELITER(iter+1))
	    iter++;// NEW4 : make sure next interation checks for non-Indels, since Indel iteration will disable active intervals

	  breakout = 0;
	  SNPfail = SNPskip = 0;
	  lastiter = iter;
	  int origmaxiter = maxiter;
	  maxiter = max(maxiter, iter + (int)(ITER_INC + max(N1,N2) * ITER_FRAC) / 2);
	  HapUpdatemapSkipcnt = 0;
	  if(VERB){
	    printf("Resuming Haplotype refinement: increased maxiter= %d to %d, iter=%d\n",origmaxiter, maxiter, iter);
	    fflush(stdout);
	  }
	  
	  continue;/* next iter < maxiter */
	}
      }

      if(DEBUG>=2){/* validate HapDeltaMerged[1..n] */
	for(int i = 0; i <= n; i++){
	  if(i <= 0 || HapSite[i] == 3){
	    int RR = i+1;
	    while(RR <= n && HapSite[RR] != 3)
	      RR++;

	    /* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
	    double sum = 0.0, abssum = 0.0;
	    for(int t = i; t < RR; t++){
	      sum += HapDelta[t];
	      abssum += fabs(HapDelta[t]);
	    }
	    if(abssum < MIN_INDEL_SIZE)
	      abssum = sum = 0.0;
	    else if(fabs(sum) < MIN_INDEL_SIZE)
	      sum = copysign(MIN_INDEL_SIZE,sum);
	      
	    for(int t = i; t < RR; t++){
	      if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE)){
		printf("After Phasing check in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f\n",
		       iter,i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		fflush(stdout);
		//		  HapDeltaMerged[t] = sum;
		assert(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE);
	      }
	    }
	  }
	}
      }

      if(DEBUG>=1+RELEASE) assert(breakout);

      if(breakout){

	if(DEBUG>=2){/* validate HapDeltaMerged[1..n] */
	  for(int i = 0; i <= n; i++){
	    if(i <= 0 || HapSite[i] == 3){
	      int RR = i+1;
	      while(RR <= n && HapSite[RR] != 3)
		RR++;

	      /* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
	      double sum = 0.0, abssum = 0.0;
	      for(int t = i; t < RR; t++){
		sum += HapDelta[t];
		abssum += fabs(HapDelta[t]);
	      }
	      if(abssum < MIN_INDEL_SIZE)
		abssum = sum = 0.0;
	      else if(fabs(sum) < MIN_INDEL_SIZE)
		sum = copysign(MIN_INDEL_SIZE,sum);
	      
	      for(int t = i; t < RR; t++){
		if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE)){
		  printf("After Label Deres check in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f\n",
			 iter,i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		  fflush(stdout);
		  //		  HapDeltaMerged[t] = sum;
		  assert(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE);
		}
	      }
	    }
	  }
	}
	
	if(!FILTER_FIRST && HaploTypeDeres(Deresed,Filtered,SNPfail,SNPskip,lastiter,maxiter,HapUpdatemapSkipcnt,iter,numthreads,BigPen,newLP,LPhwm,LPdrop_count,n,Hcuts,HapDelta,HapDeltaMerged,HapSite,Delta,HapSiteScore,SiteScore,HapDeltaScore,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,MD,MX,X,lc,rc,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,TBmapWT,newLPA1,newLPA2,testLPA1,testLPA2,bestLPA1,bestLPA2,mapWT1,mapWT2,outlier1,outlier2,newLPA,pcontig,SNPcnt,IndelCnt,prevHapDelta,prevDelta,prevHapSite,spreadHapDelta,spreadDelta, Label, Index, Hremap, DELTA_OVERSAMPLE, maxIN,DELTA_RANGE,Initial_Delta,activecnt,DELTA_SCAN,Lfrozen,Rfrozen)){

	  // NEW137 : update LPhwm etc
	  LPhwm = -BigPen;
	  LPdrop_count = 0;
	  if(HAP_INDEL_SKIP_FIX)
	    HapIndelDelSkipcnt = 0;

	  if(1){/* update HapDeltaMerged[1..n] */
	    for(int i = 0; i <= n; i++){
	      if(i <= 0 || HapSite[i] == 3){
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;

		/* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
		double sum = 0.0, abssum = 0.0;
		for(int t = i; t < RR; t++){
		  sum += HapDelta[t];
		  abssum += fabs(HapDelta[t]);
		}
		if(abssum < MIN_INDEL_SIZE)
		  abssum = sum = 0.0;
		else if(fabs(sum) < MIN_INDEL_SIZE)
		  sum = copysign(MIN_INDEL_SIZE,sum);
	      
		for(int t = i; t < RR; t++){
		  if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE)){
		    printf("After Label Deres in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f : fixed\n",
			   iter,i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		    fflush(stdout);
		    HapDeltaMerged[t] = sum;
		    assert(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE);
		  }
		}
	      }
	    }
	  }

	  if(!(DERES_STOP && Deresed >= HAP_MAX_DERES)){ // don't resume after Final Deres
	    SNPfail = SNPskip = 0;
	    lastiter = iter;
	    int origmaxiter = maxiter;
	    maxiter = max(maxiter, iter + (int)(ITER_INC + max(N1,N2) * ITER_FRAC)/2);
	    HapUpdatemapSkipcnt = 0;
	    if(VERB){
	      printf("After -rres -cres : Resuming Haplotype refinement: increased maxiter= %d to %d, iter=%d\n",origmaxiter, maxiter, iter);
	      fflush(stdout);
	    }
	    
	    continue;/* next iter < maxiter */
	  }
	}

	if(DEBUG>=2){/* update HapDeltaMerged[1..n] */
	  for(int i = 0; i <= n; i++){
	    if(i <= 0 || HapSite[i] == 3){
	      int RR = i+1;
	      while(RR <= n && HapSite[RR] != 3)
		RR++;

	      /* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
	      double sum = 0.0, abssum = 0.0;
	      for(int t = i; t < RR; t++){
		sum += HapDelta[t];
		abssum += fabs(HapDelta[t]);
	      }
	      if(abssum < MIN_INDEL_SIZE)
		abssum = sum = 0.0;
	      else if(fabs(sum) < MIN_INDEL_SIZE)
		sum = copysign(MIN_INDEL_SIZE,sum);
	      
	      for(int t = i; t < RR; t++){
		if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE)){
		  printf("After Label Deres in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f : fixed\n",
			 iter,i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		  fflush(stdout);
		  //		  HapDeltaMerged[t] = sum;
		  assert(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE);
		}
	      }
	    }
	  }
	}

      LcheckHapSite:
	double wtstart = wtime();

	if(1){/* NEW142 : Seperate section to Filter Unphased SNPs that is run anytime Haplotype Phasing was updated */

	  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	  double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
				 TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,2/* WAS 0 */);
	  if(VERB){
	    printf("Before filtering unphased Hap Sites: (IndelCnt=%d,SNPcnt=%d,imin=%d,imax=%d,n=%d) LP=%0.6f -> %0.6f (delta=%0.6f), Indels=%d, SNPs=%d:wall time=%0.6f\n",
		   IndelCnt,SNPcnt,imin,imax,n, newLP, hLP, hLP - newLP, Indels, SNPs,wtstart);
	    if(VERB>=2){
	      int hap = 0;
	      for(int i = 1; i <= n; i++){
		if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3) /* ||HapSite[i] */)
		  printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
			 i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
		if(hap && HapSite[i]==3)
		  hap = 0;
		if(HapDelta[i])
		  hap = 1;
	      }
	    }
	    fflush(stdout);
	  }
	  newLP = hLP;
	  SNPcnt = SNPs;
	  IndelCnt = Indels;

	  if(iter > HapIndelDelIter && HINDELITER(iter)){/* recompute HapDeltaScore and reverse any Indels that score -ve : should not be needed since it should have been computed in current iteration */
	    if(VERB){
	      printf("WARNING: termination at iter=%d happened without recomputing HapDeltaScore : Will repeat computation of HapDeltaScore\n", iter);
	      fflush(stdout);	
	    }
	    HapIndelDelIter = iter;// NEW76 : in case this is not really the last iteration

	    // NEW55
	    int startOutlierType = OutlierType;
	    double startOutlierLambda = outlierLambda;
	    double startPoutlier = Poutlier;
	    double startPoutlierEnd = PoutlierEnd;
	    double startLRbias = LRbias;
	    double startSF = SF[0];
	    double startSR = SR[0];

	    if(IndelScore){ /* NEW55 : adjust outlierLambda, OutlierType, Poutlier, PoutlierEnd and LRbias (if specified by -IndelScore) */
	      if(IndelDelOutlierLambda != 0.0)
		outlierLambda = IndelDelOutlierLambda;
	      if(IndelDelOutlierType != -1)
		OutlierType = IndelDelOutlierType;
	      if(IndelDelPoutlier >= 0.0)
		Poutlier = IndelDelPoutlier;
	      if(IndelDelPoutlierEnd >= 0.0)
		PoutlierEnd = IndelDelPoutlierEnd;
	      if(IndelDelLRbias != 0.0)
		LRbias = IndelDelLRbias;
	      if(MinSFIndelDel != 0.0)
		SF[0] = max(origSF, MinSFIndelDel);
	      if(MinSRIndelDel != 0.0)
		SR[0] = max(origSR, MinSFIndelDel);

	      if(OutlierType != startOutlierType || outlierLambda != startOutlierLambda || Poutlier != startPoutlier || PoutlierEnd != startPoutlierEnd || LRbias != startLRbias ||
		 SF[0] != startSF || SR[0] != startSR){
		if(VERB>=2){
		  printf("Calling hprobeval() after switching parameters PoutlierEnd etc\n");
		  fflush(stdout);
		}
		double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				       TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      
		if(VERB/* HERE >=2 */){
		  printf("Switched OutlierType=%d to %d,Lambda=%0.2e->%0.2e,Poutlier=%0.2e->%0.2e,PoutlierEnd=%0.2e->%0.2e,LRbias=%0.2e->%0.2e,SF=%0.3f->%0.3f,SR=%0.3f->%0.3f: LP= %0.8f -> %0.8f, SNPs=%d, Indels=%d: Cum wall time= %0.6f\n",
			 startOutlierType,OutlierType,startOutlierLambda,outlierLambda,startPoutlier,Poutlier,startPoutlierEnd,PoutlierEnd,startLRbias,LRbias,startSF,SF[0],startSR,SR[0],newLP, nLP, SNPs, Indels, wtime());
		  fflush(stdout);
		}
		newLP = nLP;
		SNPcnt = SNPs;
		IndelCnt = Indels;

		/* swap newLPA,bestLPA */
		double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;
		tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;
	      }
	    }// if(IndelScore)

	    double orig_newLP = newLP;
	    for(int i = 0; i <= n; i++){
	      if(i <= 0 || HapSite[i] == 3){
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;

		/* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
		double sum = 0.0, abssum = 0.0;
		for(int t = i; t < RR; t++){
		  sum += HapDelta[t];
		  abssum += fabs(HapDelta[t]);
		}
		if(abssum < MIN_INDEL_SIZE)
		  abssum = sum = 0.0;
		else if(fabs(sum) < MIN_INDEL_SIZE)
		  sum = copysign(MIN_INDEL_SIZE,sum);

		for(int t = i; t < RR; t++)
		  HapDeltaMerged[t] = sum;

		if(abssum == 0.0){
		  for(int t = i; t < RR; t++)
		    HapDeltaScore[t] = 0.0;
		  continue;
		}

		double origHapDelta = HapDelta[i];

		/* try to remove each Haplotype group HapDelta[i..RR-1] by calling hprobeval() and update the corresponding HapDeltaScore[] values */
		memcpy(&prevHapDelta[i],&HapDelta[i],(RR-i)*sizeof(double));
		memcpy(&prevDelta[i],&Delta[i],(RR-i)*sizeof(double));
		if(HAPINDELDELETE_FIX)
		  memcpy(&prevHapSite[i+1],&HapSite[i+1],(RR-i-1)*sizeof(int));

		if(VERB>=1+RELEASE/* HERE >=2 */){
		  printf("Testing removal of HapIndel[%d..%d] = %0.6f (Hcuts= %0.4f .. %0.4f)\n", i, RR, HapDeltaMerged[i],Hcuts[i],Hcuts[RR]);
		  fflush(stdout);
		}

		double bestLP = newLP - BigPen, nLP;
		int bestAllele = 3;
		int bestSNPs = SNPcnt, bestIndels = IndelCnt;

		for(int t = i; t < RR; t++)
		  HapDelta[t] = 0.0;

		int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
		if(err){
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("Averaged removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
		    fflush(stdout);
		  }
		  bestAllele = -1;
		} else {
		  nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				  TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB/* HERE >=2 */){
		    printf("Averaged removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs = %d, Indels=%d: wtime= %0.6f\n", 
			   i, RR, HapDeltaMerged[i], nLP, nLP > newLP ? '!':' ',nLP-newLP, SNPs, Indels, wtime());
		    fflush(stdout);
		  }
		  bestLP = nLP;
		  bestSNPs = SNPs;
		  bestIndels = Indels;
		  if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
		    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		  }
		}

		/* next try changing only Allele 1 */
		for(int t = i; t < RR; t++)
		  Delta[t] = prevDelta[t] - prevHapDelta[t];
		if(HAPINDELDELETE_FIX){ // need to also change HapSite[i+1..RR-1] to match Allele 2 : HapSite 1 -> 0, 2 -> 3 
		  for(int t = i+1; t < RR; t++){
		    if(HapSite[t] == 1)
		      HapSite[t] = 0;
		    else if(HapSite[t] == 2)
		      HapSite[t] = 3;
		  }
		  for(int t = RR; --t > i;){
		    if(!HapSite[t]){
		      Delta[t-1] += Delta[t];
		      Delta[t] = 0.0;
		    }
		  }
		}

		err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
		if(err){
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
		    fflush(stdout);
		  }
		} else {
		  nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				  TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB/* HERE >=2 */){
		    printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
			   i,RR,HapDeltaMerged[i], nLP, nLP > max(newLP,bestLP) ? '!' : ' ', nLP - newLP, SNPs,Indels,wtime());
		    fflush(stdout);
		  }
		  if(nLP > bestLP || bestAllele == -1){
		    bestLP = nLP;
		    bestSNPs = SNPs;
		    bestIndels = Indels;
		    bestAllele = 1;
		    if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
		      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		    }
		  }
		}

		/* next try changing only Allele 2 */
		for(int t = i; t < RR; t++)
		  Delta[t] = prevDelta[t] + prevHapDelta[t];
		if(HAPINDELDELETE_FIX){	      // need to also change HapSite[i+1..RR-1] to match Allele 1 : HapSite 1 -> 3, 2 -> 0 
		  for(int t = i+1; t < RR; t++){
		    HapSite[t] = prevHapSite[t];
		    if(HapSite[t] == 1)
		      HapSite[t] = 3;
		    else if(HapSite[t] == 2)
		      HapSite[t] = 0;
		  }
		  for(int t = RR; --t > i;){
		    if(!HapSite[t]){
		      Delta[t-1] += Delta[t];
		      Delta[t] = 0.0;
		    }
		  }
		}

		err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
		if(err){
		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
		    fflush(stdout);
		  }
		} else {
		  nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				  TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB/* HERE >=2 */){
		    printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
			   i,RR,HapDeltaMerged[i], nLP, nLP > max(bestLP,newLP) ? '!':' ', nLP - newLP, SNPs,Indels,wtime());
		    fflush(stdout);
		  }
		  if(nLP > bestLP || bestAllele == -1){
		    bestLP = nLP;
		    bestSNPs = SNPs;
		    bestIndels = Indels;
		    bestAllele = 2;

		    if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
		      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		    }
		  }
		}

		HapDeltaScore[i] = newLP - bestLP;

		if(bestLP > newLP){/* confirm change & swap newLPA and bestLPA */
		  if(VERB){
		    printf("Removed HapDelta[%d..%d]= %0.6f (HapDelta[i]=%0.6f): LP=%0.6f -> %0.6f, IndelCnt=%d -> %d, SNPs=%d\n", 
			   i,RR, HapDeltaMerged[i], origHapDelta, newLP, bestLP, IndelCnt, bestIndels, bestSNPs);
		    fflush(stdout);
		  }
		  newLP = bestLP;
		  IndelCnt = bestIndels;
		  SNPcnt = bestSNPs;
		  for(int t = i; t < RR; t++)
		    HapDeltaMerged[t] = 0.0;
		  if(bestAllele != 2){
		    if(bestAllele == 1){
		      for(int t = i; t < RR; t++)
			Delta[t] = prevDelta[t] - prevHapDelta[t];
		      if(HAPINDELDELETE_FIX){
			for(int t = i+1; t < RR; t++){
			  HapSite[t] = prevHapSite[t];
			  if(HapSite[t] == 1)
			    HapSite[t] = 0;
			  else if(HapSite[t] == 2)
			    HapSite[t] = 3;
			}
			for(int t = RR; --t > i;){
			  if(!HapSite[t]){
			    Delta[t-1] += Delta[t];
			    Delta[t] = 0.0;
			  }
			}
		      }
		    } else {
		      for(int t = i; t < RR; t++)
			Delta[t] = prevDelta[t];
		      if(HAPINDELDELETE_FIX)
			for(int t = i+1; t < RR; t++)
			  HapSite[t] = prevHapSite[t];
		    }
		  }

		  if(DEBUG>=2){/* verify LP is now equal to newLP */
		    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		    double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) ||VERB/* HERE >=2 */){
		      if(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt)
			printf("\t After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);		    
		      else
			printf("WARNING: After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);
		      fflush(stdout);
		      if(DEBUG>=1+RELEASE) assert(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt);
		    }
		    if(DEBUG){/* verify full LP */
		      double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2, 0, 0, 0.0, 0.0, 0.0, 0.0, 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		      if(!(fabs(LP - newLP) < 1e-6 && SNPs == SNPcnt && Indels == IndelCnt)){
			printf("WARNING: After switching to Allele=%d: LP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,LP,newLP,LP-newLP, SNPs, Indels);
			for(int m = 0; m < MD; m++){
			  if(fabs(testLPA1[m] - bestLPA1[m]) > 1e-6)
			    printf("m=%d:qLPA1[m]= %0.8f, fLPA1[m]= %0.8f (err=%0.8f)\n",m, bestLPA1[m],testLPA1[m],bestLPA1[m]-testLPA1[m]);
			  if(fabs(testLPA2[m] - bestLPA2[m]) > 1e-6)
			    printf("m=%d:qLPA2[m]= %0.8f, fLPA2[m]= %0.8f (err=%0.8f)\n",m, bestLPA2[m],testLPA2[m],bestLPA2[m]-testLPA2[m]);
			}
			fflush(stdout);
			//		    assert(fabs(LP - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt); // this happens with id17 in NA12878A_*r4632/output/contigs/exp_refineFinal1/
		      }
		      newLP = LP;
		      IndelCnt = Indels;
		      SNPcnt = SNPs;

		      /* swap testLPA and bestLPA */
		      double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
		      tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;
		    }
		  }
		} else { /* restore original HapDelta */
		  memcpy(&HapDelta[i],&prevHapDelta[i], (RR - i)*sizeof(double));
		  memcpy(&Delta[i],&prevDelta[i],(RR-i)*sizeof(double));
		  if(HAPINDELDELETE_FIX)
		    memcpy(&HapSite[i+1],&prevHapSite[i+1],(RR-i-1)*sizeof(int));

		  if(DEBUG>=2){
		    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		    double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    if(VERB>=3 || fabs(nLP - newLP) > 1e-6 || SNPcnt != SNPs || IndelCnt != Indels){
		      printf("WARNING:After restoring HapDelta[%d..%d]= %0.4f: nLP=%0.8f, expected newLP=%0.8f (err=%0.8f), SNPs=%d,Indels=%d\n",i,RR,HapDeltaMerged[i], nLP,newLP,nLP-newLP,SNPs,Indels);
		      fflush(stdout);
		      //		  assert(fabs(nLP-newLP) < 1e-5);
		      assert(nLP > orig_newLP - 1e-6);
		    }
		    SNPcnt = SNPs;
		    IndelCnt = Indels;
		  }
		}

		for(int t = i+1; t < RR; t++)
		  HapDeltaScore[t] = HapDeltaScore[i];

		if(VERB/* HERE >=2 */){
		  double DeltaSum = 0.0;
		  for(int t = i; t < RR;t++)
		    DeltaSum += Delta[t];
		  printf("L=%d,R=%d:HapSite[L,R]=%d,%d,Hcuts[L]=%0.4f,Hcuts[L,R]=%0.4f,Delta[L,R]=%0.4f,HapDelta[L]=%0.4f(tot=%0.4f),HapDeltaScore=%0.2f\n",
			 i,RR,HapSite[i],HapSite[RR],Hcuts[i],Hcuts[RR]-Hcuts[i],DeltaSum,HapDelta[i],HapDeltaMerged[i],HapDeltaScore[i]);
		  fflush(stdout);
		}
	      }
	    }
	    if(1){/* verify full LP (and restore nmapK1,nmapK2) */
	      double wt1 = wtime();
	      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1, nmapK2,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB>=1+RELEASE/* HERE >=2 */ || nLP < newLP - 1e-6 || IndelCnt != Indels || SNPcnt != SNPs){
		double wt2 = wtime();
		printf("%sAfter computing HapDeltaScore[]: nLP=%0.6f(SNPs=%d,Indels=%d), expected newLP= %0.6f (err=%0.6f), orig LP=%0.6f, SNPcnt=%d,IndelCnt=%d: wall time=%0.6f(cum=%0.6f)\n",
		       (nLP < newLP - 1e-5 || IndelCnt != Indels || SNPcnt != SNPs) ? "WARNING: " : "" , nLP,SNPs, Indels, newLP,nLP-newLP,orig_newLP, SNPcnt,IndelCnt, wt2-wt1,wt2);
		fflush(stdout);
		//	  assert( nLP < newLP - 1e-5);
		//		if(DEBUG >= 1+RELEASE) assert(nLP > orig_newLP - 1e-3);
	      }

	      newLP = nLP;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;

	      /* swap newLPA and bestLPA */
	      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	    }

	    if(OutlierType != startOutlierType || Poutlier != startPoutlier || PoutlierEnd != startPoutlierEnd || outlierLambda != startOutlierLambda || 
	       LRbias != startLRbias || SF[0] != startSF || SR[0] != startSR){// NEW55
	      OutlierType = startOutlierType;
	      Poutlier = startPoutlier;
	      PoutlierEnd = startPoutlierEnd;
	      outlierLambda = startOutlierLambda;
	      LRbias = startLRbias;
	      SF[0] = startSF;
	      SR[0] = startSR;

	      if(VERB>=2){
		printf("Calling hprobeval() after restoring parameters PoutlierEnd etc\n");
		fflush(stdout);
	      }
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB/* HERE >=2 */){
		printf("Restored OutlierType=%d, Lambda=%0.2e, Poutlier=%0.2e, PoutlierEnd=%0.2e, LRbias= %0.2e, SF= %0.3f, SR= %0.5f: LP= %0.8f -> %0.8f, SNPs=%d, Indels=%d: Cum wall time= %0.6f\n",
		       OutlierType,outlierLambda,Poutlier,PoutlierEnd,LRbias, SF[0],SR[0],newLP, nLP, SNPs, Indels, wtime());
		fflush(stdout);
	      }

	      newLP = nLP;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;
	  
	      /* swap newLPA,bestLPA */
	      double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;
	      tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;
	    }
	  }

	  if(DEBUG>=2){/* validate HapDeltaMerged[1..n] */
	    for(int i = 0; i <= n; i++){
	      if(i <= 0 || HapSite[i] == 3){
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;

		/* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
		double sum = 0.0, abssum = 0.0;
		for(int t = i; t < RR; t++){
		  sum += HapDelta[t];
		  abssum += fabs(HapDelta[t]);
		}
		if(abssum < MIN_INDEL_SIZE)
		  abssum = sum = 0.0;
		else if(fabs(sum) < MIN_INDEL_SIZE)
		  sum = copysign(MIN_INDEL_SIZE,sum);
	      
		for(int t = i; t < RR; t++){
		  if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE)){
		    printf("After Indel Deletion check in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f\n",
			   iter,i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		    fflush(stdout);
		    //		  HapDeltaMerged[t] = sum;
		    assert(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE);
		  }
		}
	      }
	    }
	  }

	  if(VERB/* HERE >=2 */ && !(iter > HapSiteScoreIter+1)){
	    printf("iter=%d,HapSiteScoreIter=%d,SKIPMAP_ADD=%d: NOT recomputing HapSiteScore (LP = %0.6f)\n",iter,HapSiteScoreIter, SKIPMAP_ADD,newLP);
	    fflush(stdout);
	  }

	  //	  if(DEBUG) assert(iter <= HapSiteScoreIter + 1); // Can happend due to skipping SNP iterations if SNP_SKIP_LIMIT > 0
	  if(iter > HapSiteScoreIter + 1){// Recompute HapSiteScore[] and SiteScore[] : only do this if this was not done in the last iteration (eg due to skipping it OR SKIPMAP_ADD >=2)

	    if(SKIPMAP_ADD >= 2 && !(iter >= maxiter-2)){/* repeat one more iterations with SKIPMAP_ADD = 1, so HapSiteScore is updated */
	      /* NOTE : This is an ugly coding hack to speed up recomputing HapSiteScore[] and SiteScore[] using the regular iteration with mprobeval() : 
		 Should use a subrouting call instead */
	      if(VERB){
		printf("iter=%d: Forcing one more SNP iteration : maxiter= %d -> %d, HapSiteScoreIter=%d\n",iter,maxiter,iter+2,HapSiteScoreIter);
		fflush(stdout);
	      }
	      checkHapSiteMaxIter = maxiter;/* save original value of maxiter */
	      checkHapSite = 1;/* will force return to LcheckHapSite at end of next iteration */

	      maxiter = iter+2;// forces breakout == 1 after next (SNP) iteration : see condition above : if(!breakout && (iter >= maxiter-1 || ...))

	      ForceUnphased = 0;
	      if (HapSiteUnphasedSNR > 0 && reversalcnt > origreversalcnt)
		ForceUnphased = 1;/* will force -HapSiteUnphased check in next iteration */
	      continue; 
	    }

	    if(VERB){
	      printf("iter=%d,HapSiteScoreIter=%d: recomputing HapSiteScore (LP = %0.6f, N1=%d,N2=%d, SKIPMAP_ADD=%d: wtime= %0.6f)\n",iter,HapSiteScoreIter, newLP,N1,N2,SKIPMAP_ADD,wtime());
	      fflush(stdout);
	    }

	    SNPverbose = 0;
	    int SNPerrcnt = 0;/* count of SNPs with -ve score */

	    // For now just call hprobeval() : later convert to using mprobeval()
	    //	    double HapSitePen[4] = {0.0,logHapSitePvalue - 0.5*SITE_PEN, logHapSitePvalue - 0.5*SITE_PEN, -SITE_PEN};      /* penalty as function of h or HapSite[i] */
	    double SNPscore[4];

	    for(int i = 1; i <= n; i++){
	      if(HapSite[i] == 0 || HapSite[i] == 3)
		continue;

	      int L = i-1;
	      while(L >= 1 && !HapSite[L])
		L--;
	      int R = i+1;
	      while(R <= n && !HapSite[R])
		R++;
	      int LL = L, RR = R;
	      while(LL >= 1 && HapSite[LL] != 3)
		LL--;
	      while(RR <= n && HapSite[RR] != 3)
		RR++;

	      int origHapSite = HapSite[i];
	      //	      double origHapDelta = HapDelta[i];
	      //	      double origDelta = Delta[i];
	      //	      double origHapDeltaL = HapDelta[L];
	      //	      double origDeltaL = Delta[L];
	      /* need to save all HapDelta[LL .. RR-1] and Delta[LL .. RR-1] */
	      memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	      memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	      memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));

	      if(VERB>=3){
		printf("i=%d/%d:LL=%d,L=%d,R=%d,RR=%d:HapSite[i]=%d:Delta[L,i]=%0.3f,%0.3f,HapDelta[L,i]=%0.3f,%0.3f: recompute HapSiteScore[i]=%0.6f, SiteScore[i]=%0.6f,newLP=%0.6f\n",
		       i,n,LL,L,R,RR,HapSite[i],Delta[L],Delta[i],HapDelta[L],HapDelta[i],HapSiteScore[i],SiteScore[i],newLP);
		fflush(stdout);
	      }

	      double wt1 = wtime();

	      SNPscore[HapSite[i]] = newLP;
	      SNPscore[3-HapSite[i]] = newLP - 99999.999999;

	      for(int SNP = 0; SNP <= 3; SNP += 3){
		HapSite[i] = SNP;
		if(HINDEL && HPROBEVAL_SPREAD && !HapSite[i]){
		  Delta[L] += Delta[i];
		  HapDelta[L] += HapDelta[i];
		  HapDelta[i] = Delta[i] = 0.0;
		}

		// NOTE there is a small chance minKB restriction is violated due to previous change being too close to current change
		int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		//		rverb = (iter==35 && i==2639 && SNP==3) ? 1 : 0;
		double nLP = err ? newLP - 99999.999999 : 
		  hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		//		rverb = 0;
		if(VERB>=3 || err || (SNP == origHapSite && fabs(nLP - newLP) > 1e-6)){
		  printf("i=%d/%d:LL=%d,L=%d,R=%d,RR=%d,HapSite[i]=%d -> %d: LP= %0.6f -> %0.6f (err=%d, %0.6f)\n",i,n,LL,L,R,RR,origHapSite,HapSite[i],newLP, nLP,err, nLP - newLP);
		  fflush(stdout);
		}
		SNPscore[SNP] = nLP;// WAS  - HapSitePen[SNP];// NEW2

		if(HINDEL && !HapSite[i]){
		  memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		
		  if(DEBUG) assert(HapSite[i] == origHapSite);
		}
		HapSite[i] = origHapSite;
	      }
	      
	      double origHapSiteScore = HapSiteScore[i], origSiteScore = SiteScore[i];

	      HapSiteScore[i] = newLP - max(SNPscore[0], SNPscore[3]);
	      SiteScore[i] = SNPscore[3] - SNPscore[0];
	      if(VERB/* HERE >=2 */){
		double wt = wtime();
		printf("i=%d/%d:LL=%d,RR=%d:Hcuts[i]=%0.4f.HapSite[i]=%d: recomputed HapSiteScore[i]= %0.6f -> %0.6f, SiteScore[i]= %0.6f -> %0.6f (SNP=%0.6f,%0.6f,%0.6f,%0.6f, LP=%0.6f):wall= %0.6f (cum= %0.6f)\n",
		       i,n,LL,RR,Hcuts[i],HapSite[i],origHapSiteScore, HapSiteScore[i], origSiteScore, SiteScore[i], SNPscore[0],SNPscore[1],SNPscore[2],SNPscore[3],newLP,wt-wt1,wt);
		fflush(stdout);
	      }
	      if(HapSiteScore[i] < -0.001)
		SNPerrcnt++;
	    }
	    // restore values of N1,N2,Y1,Y2 (also need to make sure nmapK1,nmapK2 are still valid)
	    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate consensus map pair */

	    if(SNPerrcnt > 0){
	      printf("WARNING: %d/%d SNPs had -ve HapSiteScore\n",SNPerrcnt,SNPcnt);
	      fflush(stdout);
	      
	      if(VERB>=2)
		SNPverbose = 1;
	    }
	  }

	  if(DEBUG>=2){/* validate HapDeltaMerged[1..n] */
	    for(int i = 0; i <= n; i++){
	      if(i <= 0 || HapSite[i] == 3){
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;

		/* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
		double sum = 0.0, abssum = 0.0;
		for(int t = i; t < RR; t++){
		  sum += HapDelta[t];
		  abssum += fabs(HapDelta[t]);
		}
		if(abssum < MIN_INDEL_SIZE)
		  abssum = sum = 0.0;
		else if(fabs(sum) < MIN_INDEL_SIZE)
		  sum = copysign(MIN_INDEL_SIZE,sum);
	      
		for(int t = i; t < RR; t++){
		  if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE)){
		    printf("After Recomputing HapSiteScore in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f\n",
			   iter,i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		    fflush(stdout);
		    //		  HapDeltaMerged[t] = sum;
		    assert(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE);
		  }
		}
	      }
	    }
	  }

	  if(VERB>=2){
	    printf("Haplotype Labels and Indels before filtering them at end of iter=%d/%d: SNPcnt=%d,IndelCnt=%d\n",iter, maxiter, SNPcnt, IndelCnt);
	    int hap = 0;
	    for(int i = 1; i <= n; i++){
	      if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3) /* */|| (HapSite[i] && Hcuts[i] > 56000.0)){
		int L = i-1;
		while(L > 0 && !HapSite[L])
		  L--;
		int LL = i;
		while(LL > 0 && HapSite[LL] != 3)
		  LL--;
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;
		printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.6f(tot=%0.6f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f,LL=%d,L=%d,RR=%d,HapDelta[L]=%0.6f,HapSite[L]=%d\n",
		       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i],LL,L,RR,HapDelta[L],HapSite[L]);
		fflush(stdout);
		if(DEBUG && HapDelta[i]) assert(HapSite[LL]==3);
		if(DEBUG && HapDelta[i]) assert(HapSite[RR]==3);
		if(DEBUG && HapDelta[i] && HapSite[i] != 3)
		  assert(HapSite[i]);
		if(hap && HapSite[i]==3)
		  hap = 0;
		if(HapDelta[i])
		  hap = 1;
	      }
	    }
	    fflush(stdout);
	  }

	  if(HapSiteUnphasedSNR > 0.0 && reversalcnt == origreversalcnt){
	    printf("WARNING: Skipping -HapSiteUnphased check for Unphased SNPs since HapSitePhase[],HapDeltaPhase[] was not updated:Filtered=%d,Deresed=%d/%d,reversalcnt=%d->%d(max=%d,final=%d),DERES_STOP=%d)\n",
		   Filtered,Deresed,HAP_MAX_DERES,origreversalcnt,reversalcnt,HREVERSAL,FINAL_HREVERSAL,DERES_STOP);
	    if(!FINAL_HREVERSAL)
	      printf("\t 2nd value of -HapPhaseRev must be set to 1 for -HapSiteUnphased to work\n");
	    fflush(stdout);
	  }

	  //	  ZERO_MINKB = 0.001;
	  minKB = ZERO_MINKB ? ZERO_MINKB /* WAS45 0.001 * PixelLen */ : rres * 0.500;/* score_init() will now compute the same value, when called before mprobeval() */

	  if(HapSiteUnphasedSNR > 0.0 && reversalcnt > origreversalcnt /* NEW142 */&& reversalcnt >= HREVERSAL){

	    UnphasedCnt++;

	    if(VERB){
	      printf("Starting filtering unphased Hap Sites (UnphasedCnt= %d): (IndelCnt=%d,SNPcnt=%d,imin=%d,imax=%d,n=%d) LP=%0.6f -> %0.6f (delta=%0.6f), Indels=%d, SNPs=%d:wall time=%0.6f\n",
		     UnphasedCnt,IndelCnt,SNPcnt,imin,imax,n, newLP, hLP, hLP - newLP, Indels, SNPs,wtstart);
	      fflush(stdout);
	    }

	    if(MapSNR){/* compute SNR values for use with unphased HapSites */
	      for(int i = 1; i <= n; i++)
		SNRwtsum[i] = SNRsum[i] = 0.0;

	      for(int m = 0; m < MD; m++){
		double LP12 = newLPA[m];
		double wt = MapWeight[m] = TBmapWT[m] * (1.0 - LRbias * exp(-LP12));

		int M = MX[m];
		//    double *XM = X[m];
		int mapid = pcontig->contig[m].mapid;
		if(DEBUG) assert(0 <= mapid && mapid < nummaps);
		Cmap *pmap = gmap[mapid];
		if(DEBUG) assert(pmap->numsite[0] == M);
		int flip = pcontig->flip[m];

		/* compute geometric mean SNR values (for use with unphased HapSites)  */
		int I,K,J;
		int *nmapM, *nmapKM;

		nmapM = nmap1[m];
		nmapKM = nmapK1[m];
		for(J = 1; J <= M; J++){
		  if((I=nmapM[J]) > 0){
		    K = nmapKM[J];
		    if(DEBUG && !(K >= 0 && 1 <= I-K && I <= N1)){	
		      printf("m=%d,MD=%d:J=%d,M=%d: nmap1[m][J]= I= %d, nmapK1[m][J]= K= %d, N1=%d\n",
			     m,MD,J,M,I,K,N1);
		      fflush(stdout);
		      assert(K >= 0 && 1 <= I-K && I <= N1);	
		    }
		    for(int t = I-K; t <= I; t++){
		      int i = nmap1[MD][t];
		      if(DEBUG) assert(1 <= i && i <= n);
		      SNRwtsum[i] += wt;
		      double snr = pmap->SNR[0][flip ? M+1-J : J];
		      if(DEBUG>=2) assert(isfinite(snr) && snr > 0.0);
		      double lnsnr = log(snr);
		      if(DEBUG>=2) assert(isfinite(lnsnr));
		      SNRsum[i] += lnsnr * wt;
		      if(DEBUG>=2) assert(isfinite(SNRsum[i]));
		    }
		  }
		}
		nmapM = nmap2[m];
		nmapKM = nmapK2[m];
		for(J = 1; J <= M; J++){
		  if((I=nmapM[J]) > 0){
		    K = nmapKM[J];
		    if(DEBUG && !(K >= 0 && 1 <= I-K && I <= N2)){	
		      printf("m=%d/%d:id=%lld,M=%d,J=%d:nmap2[m][J]=I=%d,nmapK2[m][J]=K=%d,N2=%d\n",
			     m,MD,pmap->id,M,J,I,K,N2);
		      fflush(stdout);
		      assert(K >= 0 && 1 <= I-K && I <= N2);	
		    }
		    for(int t = I-K; t <= I; t++){
		      int i = nmap2[MD][t];
		      if(DEBUG) assert(1 <= i && i <= n);
		      SNRwtsum[i] += wt;
		      double snr = pmap->SNR[0][flip ? M+1-J : J];
		      if(DEBUG>=2) assert(isfinite(snr) && snr > 0.0);
		      double lnsnr = log(snr);
		      if(DEBUG>=2) assert(isfinite(lnsnr));
		      SNRsum[i] += lnsnr * wt;
		      if(DEBUG>=2) assert(isfinite(SNRsum[i]));
		    }
		  }
		}
	      }

	      /* compute mean SNR value of each label in Hcuts[1..n] */
	      for(int i = 1; i <= n; i++){
		double wt = max(0.1,SNRwtsum[i]);
		if(DEBUG) assert(isfinite(wt));
      
		double sum = SNRsum[i];
		if(DEBUG) assert(isfinite(sum));
		if(DEBUG && !(isfinite(exp(sum/wt)))){
		  printf("i=%d,n=%d:SNRwtsum[i]= %0.8e, SNRsum[i]=sum= %0.8e, wt= %0.8e, sum/wt= %0.8e, exp(sum/wt)= %0.8e\n",
			 i,n,SNRwtsum[i], SNRsum[i], wt, sum/wt, exp(sum/wt));
		  fflush(stdout);
		  assert(isfinite(exp(sum/wt)));
		}

		SNRsum[i] = exp(sum/wt);
	      }
	    }

	    double logHapSiteUnphasedPvalue = -log(max(HapSiteUnphasedPvalue, 1e-300)) + logHapSitePvalue;
	    double logPhasePvalue = -log(max(PhasePvalue, 1e-300));

	    /* Check unphased HapSites*/
	    for(int i = imin; i <= imax; i++){
	      if(!(HapSite[i]==1 || HapSite[i] == 2))
		continue;
	      if(HapSitePhase[i] >= logPhasePvalue){
		if(VERB/* HERE HERE >=2 */){
		  printf("i=%d:Hcuts[i]= %0.3f, HapSite[i]= %d, HapSitePhase[i]= %0.2f (logPhasePvalue= %0.2f) : phase linkage confirmed\n",i,Hcuts[i],HapSite[i],HapSitePhase[i],logPhasePvalue);
		  fflush(stdout);
		}
		continue;
	      }

	      /* locate next Hapsite or indel */
	      int R = i;
	      double nextphase = 0.0;
	      if(HapDelta[i]){
		if((nextphase = HapDeltaPhase[i]) >= logPhasePvalue){
		  if(VERB/* HERE HERE >=2 */){
		    printf("i=%d:Hcuts[i]= %0.3f, HapSite[i]= %d, HapSitePhase[i]= %0.2f,HapDeltaPhase[i]= %0.2f (logPhasePvalue= %0.2f) : nextphase linkage confirmed\n",
			   i,Hcuts[i],HapSite[i],HapSitePhase[i],HapDeltaPhase[i],logPhasePvalue);
		    fflush(stdout);
		  }
		  continue;
		}
	      } else {
		int j = i+1;
		for(; j <= imax; j++)
		  if(HapSite[j] && (HapSite[j] <= 2 || HapDelta[j])){
		    R = j;
		    break;
		  }
		if(j <= imax){
		  if(HapSite[j] <= 2){
		    if((nextphase = HapSitePhase[j]) >= logPhasePvalue){
		      if(VERB/* HERE HERE >=2 */){
			printf("i=%d,j=%d:Hcuts[i,j]= %0.3f,%0.3f, HapSite[i,j]= %d,%d HapSitePhase[i,j]= %0.2f,%0.2f (logPhasePvalue= %0.2f) : nextphase linkage confirmed\n",
			       i,j,Hcuts[i],Hcuts[j],HapSite[i],HapSite[j],HapSitePhase[i],HapSitePhase[j],logPhasePvalue);
			fflush(stdout);
		      }
		      R = i;
		      continue;
		    }
		  } else if(HapDelta[j]){
		    if((nextphase = HapDeltaPhase[j]) >= logPhasePvalue){
		      if(VERB/* HERE HERE >=2 */){
			printf("i=%d,j=%d:Hcuts[i,j]= %0.3f,%0.3f, HapSite[i,j]= %d,%d HapSitePhase[i]= %0.2f, HapDeltaPhase[j]= %0.2f (logPhasePvalue= %0.2f) : nextphase linkage confirmed\n",
			       i,j,Hcuts[i],Hcuts[j],HapSite[i],HapSite[j],HapSitePhase[i],HapDeltaPhase[j],logPhasePvalue);
			fflush(stdout);
		      }
		      R = i;
		      continue;
		    }
		  }
		}
	      }
    
	      if(VERB/* HERE HERE >=2 */){
		int j = R;
		printf("i=%d,j=%d:Hcuts[i,j]= %0.3f,%0.3f, HapSite[i,j]= %d,%d HapSitePhase[i,j]= %0.2f, HapDeltaPhase[j]= %0.2f (logPhasePvalue= %0.2f) : no phase linkage\n",
		       i,j,Hcuts[i],Hcuts[j],HapSite[i],HapSite[j],HapSitePhase[i],HapDeltaPhase[j],logPhasePvalue);
		printf("\t HapSiteScore[i]= %0.2f (logHapSiteUnphasedPvalue= %0.2f), SNRsum[i]= %0.2f (HapSiteUnphasedSNR= %0.2f)\n",
		       HapSiteScore[i],logHapSiteUnphasedPvalue, MapSNR ? SNRsum[i] : -1.0, HapSiteUnphasedSNR);
		fflush(stdout);
	      }

	      /* Hapsite[i] is not phased with any previous or subsequent HapSite[] or HapDelta[] */
	      if(HapSiteScore[i] < logHapSiteUnphasedPvalue || (MapSNR && SNRsum[i] < HapSiteUnphasedSNR)){
		//	    int origHapSite = HapSite[i];
		int L = i-1;
		while(L > 0 && !HapSite[L])
		  L--;
		int LL = L;
		while(LL > 0 && HapSite[LL] != 3)
		  LL--;
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;
		memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
		memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));

		if(SiteScore[i] > 0.0){
		  HapSite[i] = 3; 
		  if(HapDeltaMerged[i] /* WAS2 &&(LL > 0 && RR <= n) */){/* may have to split HapDeltaMerged[i] into two groups */
		    double sum = 0.0;
		    for(int t = LL; t < i; t++)
		      sum += HapDelta[t];
		    if(fabs(sum) >= MIN_INDEL_SIZE){
		      if(VERB/* HERE >=2 */){
			printf("Split HapDelta[%d..%d]=%0.4f into HapDelta[%d..%d]=%0.4f and HapDelta[%d..%d]=%0.4f\n",
			       LL,RR,HapDeltaMerged[i], LL,i,sum, i,RR,HapDeltaMerged[i]-sum);
			fflush(stdout);
		      }
		      for(int t = LL; t < i; t++)
			HapDeltaMerged[t] = sum;

		      sum = 0.0;
		      for(int t = i; t < RR; t++)
			sum += HapDelta[t];

		      for(int t = i; t < RR; t++)
			HapDeltaMerged[t] = sum;
		    }
		  }
		} else {
		  HapSite[i] = 0;
		  if(HapDelta[i] != 0.0){/* move to previous site L */
		    if(VERB/* HERE >=2 */){
		      printf("L=%d,i=%d:HapSite[i]=%d -> %d,HapDelta[L]=%0.6f->%0.6f,HapDelta[i]=%0.6f->0\n",
			     L,i,prevHapSite[i],HapSite[i],HapDelta[L],HapDelta[L]+HapDelta[i],HapDelta[i]);
		      fflush(stdout);
		    }
		    HapDelta[L] += HapDelta[i];
		    HapDelta[i] = 0.0;
		  }
		  if(Delta[i] != 0.0){/* move to previous site L */
		    if(VERB/* HERE >=2 */){
		      printf("L=%d,i=%d:HapSite[i]=%d -> %d,Delta[L]=%0.6f->%0.6f,Delta[i]=%0.6f->0\n",
			     L,i,prevHapSite[i],HapSite[i],Delta[L],Delta[L]+Delta[i],Delta[i]);
		      fflush(stdout);
		    }
		    Delta[L] += Delta[i];
		    Delta[i] = 0.0;
		  }
		}
		if(VERB/* HERE >=2 */){
		  if(MapSNR)
		    printf("Filtered out unphased HapSite[%d] = %d -> %d at Hcuts=%0.4f (HapSiteScore=%0.6f/%0.6f,SiteScore=%0.6f,SNR=%0.2f/%0.2f, PhaseScore=%0.6f/%0.6f(next=%0.6f at R=%d)\n", 
			   i, prevHapSite[i], HapSite[i], Hcuts[i], HapSiteScore[i], logHapSiteUnphasedPvalue, SiteScore[i],SNRsum[i],HapSiteUnphasedSNR, HapSitePhase[i],logPhasePvalue, nextphase,R);
		  else
		    printf("Filtered out unphased HapSite[%d] = %d -> %d at Hcuts=%0.4f (HapSiteScore=%0.6f/%0.6f,SiteScore=%0.6f,PhaseScore=%0.6f/%0.6f(next=%0.6f at R=%d)\n", 
			   i, prevHapSite[i], HapSite[i], Hcuts[i], HapSiteScore[i], logHapSiteUnphasedPvalue,SiteScore[i], HapSitePhase[i],logPhasePvalue,nextphase,R);
		  fflush(stdout);
		}
	  
		/* update LP and verify that no labels closer than minKB have been introduced */
		int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		if(err){
		  if(VERB){
		    printf("Removal of unphased HapSite[%d] failed due to hsetmap (labels closer than minKB=%0.4f, N1=%d, N2=%d)\n", i, minKB,N1,N2);
		    fflush(stdout);
		  }
		  memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
		} else {
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB/* HERE >=2 */){
		    printf("\t newLP= %0.6f -> %0.6f, SNPs=%d, Indels=%d: wtime= %0.6f\n",newLP,nLP,SNPs,Indels, wtime());
		    fflush(stdout);
		  }
		  newLP = nLP;
		  SNPcnt = SNPs;
		  IndelCnt = Indels;
		
		  if(DELTA_STOP >= 3){	      /* reactivate nearby intervals */
		    DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		    int IN1 = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		    int IN2 = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		    IN1 = max(0, IN1);
		    IN2 = min(maxIN, IN2);
		    if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
		      printf("After filtering SNP at Hcuts[i=%d]=%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			     i,Hcuts[i],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		      fflush(stdout);
		      assert(0 <= IN1 && IN1 <= maxIN);
		    }
		    if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
		      printf("After filtering SNP at Hcuts[i=%d]=%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			     i,Hcuts[i],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		      fflush(stdout);
		      assert(0 <= IN2 && IN2 <= maxIN);
		    }
		    if(DEBUG) assert(IN1 <= IN2);
		  
		    int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		    int origactivecnt = activecnt;

		    for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
		      if(DELTA_RANGE[T] <= 0){
			activecnt++;
			DELTA_RANGE[T] = min_DELTA;
			for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
			  Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
			if(HAPSTOP_DEBUG){
			  printf("Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to filtered SNP at Hcuts[%d]=%0.4f\n",
				 T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
				 DELTA_RANGE[T],Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1], i, Hcuts[i]);
			  fflush(stdout);
			}
		      } else if(HAPSTOP_DEBUG>=2){
			printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after filtering SNP at Hcuts[%d] with IDelta[%d]=%0.3f .. %0.3f\n",
			       T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			       i,DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1]);
			fflush(stdout);
		      }
		    }

		    if(VERB && activecnt > origactivecnt){
		      if(VERB>=2){
			int inactivecnt = 0;
			for(int IN = 0; IN <= maxIN; IN++)
			  if(DELTA_RANGE[IN] <= 0)
			    inactivecnt++;

			printf("Activated %d/%d intervals due to filtering SNP at Hcuts[%d] = %0.4f : inactive intervals = %d/%d\n",
			       activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, Hcuts[i], inactivecnt,maxIN+1);
		      } else 
			printf("Activated %d/%d intervals due to filtering SNP at Hcuts[%d] = %0.4f\n",
			       activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, Hcuts[i]);
		      fflush(stdout);
		    }
		  }// DELTA_STOP >= 3
		}
	      }
	    }
	  }// if(HapSiteUnphasedSNR > 0.0)

	}// if(1)

	if(!Filtered){/* Filter SNPs/Indels with unbalanced Allele ration and then Trim Allele ends */
	  Filtered = 1;

	  int origIndelCnt = IndelCnt, origSNPcnt = SNPcnt;

	  // For every HapIndel being filtered try two alternate ways of removing it : Make changes only to Allele 1 or Allele 2, and pick whichever scores best

	  double origPoutlierEnd = PoutlierEnd;
	  if(HAPMINCOV_ENDFIX && PoutlierEnd < PoutlierEndFinal)
	    PoutlierEnd = PoutlierEndFinal;

	  /* update nmap[], bestLPA1,bestLPA2 after filtering unphased SNPs */
	  if(SETLIMIT_CACHE)
	    for(int m = 0; m < MD; m++)
	      limit1[m].ileft = limit2[m].ileft = -1;// NEW26
	  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	  //	  rverb = (iter==45) ? 1 : 0;
	  hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			  TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,2);
	  //	  rverb = 0;

	  if(HAPMINCOV_ENDFIX && PoutlierEnd != origPoutlierEnd){
	    if(VERB){
	      printf("Before applying -HapMinCov: PoutlierEnd = %0.3e -> %0.3e:LP= %0.6f -> %0.6f\n",origPoutlierEnd,PoutlierEnd,newLP,hLP);
	      fflush(stdout);
	    }
	  }

	  if(DEBUG>=2){/* validate HapDeltaMerged[1..n] */
	    for(int i = 0; i <= n; i++){
	      if(i <= 0 || HapSite[i] == 3){
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;

		/* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
		double sum = 0.0, abssum = 0.0;
		for(int t = i; t < RR; t++){
		  sum += HapDelta[t];
		  abssum += fabs(HapDelta[t]);
		}
		if(abssum < MIN_INDEL_SIZE)
		  abssum = sum = 0.0;
		else if(fabs(sum) < MIN_INDEL_SIZE)
		  sum = copysign(MIN_INDEL_SIZE,sum);
	      
		for(int t = i; t < RR; t++){
		  if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE)){
		    printf("Before Filtering Hap Sites & Indels in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f\n",
			   iter,i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		    fflush(stdout);
		    //		  HapDeltaMerged[t] = sum;
		    assert(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE);
		  }
		}
	      }
	    }
	  }

	  if(VERB){
	    printf("Before filtering Hap Sites and Indels based on coverage: (IndelCnt=%d,SNPcnt=%d,imin=%d,imax=%d,n=%d): LP=%0.6f -> %0.6f ( delta=%0.6f), Indels=%d, SNPs=%d: wtime= %0.6f\n",
		   IndelCnt,SNPcnt,imin,imax,n,newLP, hLP, hLP - newLP, Indels, SNPs, wtime());
	    if(VERB && (VERB>=2 || rverb)){
	      int hap = 1;
	      int ilast = 0;
	      for(int i = 1; i <= n; i++){
		if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3) /* HERE HERE */||HapSite[i])
		  printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Delta[i]=%0.4f,Hcuts[i]=%0.4f(%0.4f,%0.4f),HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
			 i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Delta[i],Hcuts[i],Hcuts1[i],Hcuts2[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
		if(HapSite[i])
		  ilast = i;
		if(hap && HapSite[i]==3)
		  hap = 0;
		if(HapDelta[i])
		  hap = 1;
	      }
	      if(ilast > 0 && HapSite[ilast]==3){
		int i = ilast;
		printf("i=%d:HapSite[i]=%d,Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		       i,HapSite[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	      }
	    }
	    fflush(stdout);
	  }
	  newLP = hLP;
	  SNPcnt = SNPs;
	  IndelCnt = Indels;

	  /* compute DelCum[i+1] = Sum(Delta[0..i]) */
	  double DeltaCum = 0.0;
	  for(int i = 0; i <= n; i++){
	    DeltaCum += Delta[i];
	    DelCum[i+1] = DeltaCum;
	  }

	  /* compute covA[],covB[],covC[] & IcovA[],IcovB[],varA[],varB[],meanA[],meanB[] */
	  for(int i = 0; i <= n+1; i++)
	    covA[i] = covB[i] = covC[i] = IcovA[i] = IcovB[i] = IoutA[i] = IoutB[i] = varA[i] = varB[i] = meanA[i] = meanB[i] = 0.0;

	  double cnt1 = 0, cnt2 = 0, cnt3 = 0;

	  for(int m = 0; m < MD; m++){
	    double LP1 = bestLPA1[m];
	    double LP2 = bestLPA2[m];
	    pcontig->MapPhase[m] = 1.0/(1.0 + exp(LP2-LP1));

	    double LP12 = newLPA[m];
	    double wt = MapWeight[m] = TBmapWT[m] * (1.0 - LRbias * exp(-LP12));
	    if(wt <= 0.0)
	      continue;

	    int M = MX[m];
	    double *XM = X[m];
	    int mapid = pcontig->contig[m].mapid;
	    if(DEBUG) assert(0 <= mapid && mapid < nummaps);
	    Cmap *pmap = gmap[mapid];
	    if(DEBUG) assert(pmap->numsite[0] == M);
	    //	    int flip = pcontig->flip[m];

	    int I,K,J;
	    int *nmapM, *nmapKM;

	    int iL1 = -1,iR1 = n+1,iL2 = -1,iR2 = n+1, origiL1 = -1, origkL1 = -1, origiR1 = -1, origkR1= -1, origiL2 = -1,origkL2= -1, origiR2 = -1, origkR2= -1, JL1 = -1, JR1 = -1, JL2 = -1, JR2 = -1;
	    nmapM = nmap1[m];
	    nmapKM = nmapK1[m];
	    for(J = 1;J <= M; J++){
	      if((I = nmapM[J]) > 0){
		if(DEBUG) assert(1 <= I && I <= N1);
		K = nmapKM[J];
		if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N1);
		iL1 = nmap1[MD][I-K];
		if(DEBUG) assert(1 <= iL1 && iL1 <= n);

		JL1 = J;
		origiL1 = nmap1[MD][I];
		if(DEBUG) assert(1 <= origiL1 && origiL1 <= n);
		origkL1 = iL1;

		/* If end interval X[m][0..J] is not an endoutlier, reduce iL1 to include any labels in Hcuts1[] that overlap X[m][(HAPMINCOV_FIX?1:0)..J] */
		if(!(outlier1[m][0] & 2))// NEW
		  while(iL1 > 0 && Hcuts1[origkL1] - Hcuts1[iL1 - 1] <= XM[J] - XM[HAPMINCOV_FIX ? 1 : 0])
		    iL1--;

		break;
	      }
	    }
	    if(J > M){
	      if(VERB>=1+RELEASE && pcontig->MapPhase[m] > 0.10){
		printf("WARNING:m=%d,M=%d,n=%d:No alignment with nmap1[],nmapK1[] found : LP1=%0.8e, LP2=%0.8e, LP12=%0.8e : wt= %0.6f, MapPhase[m]= %0.6f\n",
		       m,M,n,LP1, LP2, LP12, wt, pcontig->MapPhase[m]);

		fflush(stdout);
	      }
	      iL1 = iR1 = -1;
	    }
	    //	    if(DEBUG) assert(J <= M);
      
	    for(J = M; J >= 1; J--){
	      if((I = nmapM[J]) > 0){
		if(DEBUG) assert(1 <= I && I <= N1);
		K = nmapKM[J];
		if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N1);
		iR1 = nmap1[MD][I];
		if(DEBUG) assert(origiL1 <= iR1 && iR1 <= n);
		
		JR1 = J;
		origiR1 = iR1;
		origkR1 = nmap1[MD][I-K];
		if(DEBUG) assert(origkL1 <= origkR1 && origkR1 <= origiR1);

		/* If end interval X[m][J .. M+1] is not an endoutlier, increase iR1 to include any labels in Hcuts1[] that overlap X[m][J..M+(HAPMINCOV_FIX ? 0 : 1)] */
		if(!(outlier1[m][M] & 2))// NEW
		  while(iR1 <= n && Hcuts1[iR1+1] - Hcuts1[origiR1] <= XM[M+(HAPMINCOV_FIX ? 0 : 1)] - XM[J])
		    iR1++;

		break;
	      }
	    }
	    if(DEBUG && iL1 > 0) assert(J >= 1);

	    nmapM = nmap2[m];
	    nmapKM = nmapK2[m];
	    for(J = 1;J <= M; J++){
	      if((I = nmapM[J]) > 0){
		if(DEBUG) assert(1 <= I && I <= N2);
		K = nmapKM[J];
		if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N2);
		iL2 = nmap2[MD][I-K];
		if(DEBUG) assert(1 <= iL2 && iL2 <= n);

		JL2 = J;
		origiL2 = nmap2[MD][I];
		if(DEBUG) assert(1 <= origiL2 && origiL2 <= n);
		origkL2 = iL2;

		/* If end interval X[m][0..J] is not an endoutlier, reduce iL1 to include any labels in Hcuts2[] that overlap X[m][(HAPMINCOV_FIX?1:0)..J] */
		if(!(outlier2[m][0] & 2))// NEW
		  while(iL2 > 0 && Hcuts2[origkL2] - Hcuts2[iL2 - 1] <= XM[J] - XM[HAPMINCOV_FIX ? 1 : 0])
		    iL2--;

		break;
	      }
	    }

	    if(J > M){
	      if(VERB>=1+RELEASE && pcontig->MapPhase[m] < 0.9){
		printf("WARNING:m=%d,M=%d,n=%d:No alignment with nmap2[],nmapK2[] found: LP1=%0.8e, LP2=%0.8e, LP12=%0.8e : wt= %0.6f, MapPhase[m]= %0.6f\n",
		       m,M,n, LP1, LP2, LP12, wt, pcontig->MapPhase[m]);
		fflush(stdout);
	      }
	      iL2 = iR2 = -1;
	    }
	    //	    if(DEBUG) assert(J <= M);
      
	    for(J = M; J >= 1; J--){
	      if((I = nmapM[J]) > 0){
		if(DEBUG) assert(1 <= I && I <= N2);
		K = nmapKM[J];
		if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N2);
		iR2 = nmap2[MD][I];
		if(DEBUG) assert(origiL2 <= iR2 && iR2 <= n);

		JR2 = J;
		origiR2 = iR2;
		origkR2 = nmap2[MD][I-K];
		if(DEBUG) assert(origkL2 <= origkR2 && origkR2 <= origiR2);

		/* If end interval X[m][J .. M+1] is not an endoutlier, increase iR2 to include any labels in Hcuts2[] that overlap X[m][J..M+(HAPMINCOV_FIX ? 0 : 1)] */
		if(!(outlier2[m][M] & 2))// NEW
		  while(iR2 <= n && Hcuts2[iR2+1] - Hcuts2[origiR2] <= XM[M+(HAPMINCOV_FIX ? 0 : 1)] - XM[J])
		    iR2++;

		if(VERB>=4 && rverb && iL2 <= 74394 && iR2 >= 74394){
		  printf("m=%d:J=%d,M=%d,I=%d,n=%d,origiR2=%d,iR2=%d,outlier2[0,M]=%d,%d,Hcuts2[origiR2]=%0.4f,Hcuts2[iR2]=%0.4f,Hcuts2[iR2+1]=%0.4f,X[m][J]=%0.4f,X[m][M+1]=%0.4f\n",
			 m,J,M,I,n,origiR2,iR2,outlier2[m][0],outlier2[m][M],Hcuts2[origiR2],Hcuts2[iR2],Hcuts2[min(n,iR2)+1],XM[J],XM[M+1]);
		  fflush(stdout);
		}

		break;
	      }
	    }
	    if(DEBUG && iL2 > 0) assert(J >= 1);

	    if(VERB>=4 && rverb && ((iL1 <= 150416 && iR1 >= 150416) || (iL2 <= 150416 && iR2 >= 150416))){
	      printf("m=%d(id=%lld):Phase=%0.3f,wt=%0.3f,LP1=%0.6f,LP2=%0.6f: iL1=%d,%d,iR1=%d,%d,iL2=%d,%d,iR2=%d,%d: outlier1[0,M]=%d,%d,outlier2[0,M]=%d,%d\n",
		     m,gmap[pcontig->contig[m].mapid]->id,pcontig->MapPhase[m],wt,LP1,LP2,iL1,origiL1,origiR1,iR1,iL2,origiL2,origiR2,iR2,outlier1[m][0],outlier1[m][M],outlier2[m][0],outlier2[m][M]);
	      fflush(stdout);
	    }

	    if(iL1 < 0 || iL2 < 0)
	      continue;

	    if(pcontig->MapPhase[m] > HapAlleleProb){/* Add MapWeight[m] to allele A's coverage (based on allignment to Allele A) */
	      cnt1 += wt;
	      for(int i = iL1; i <= iR1; i++)
		covA[i] += wt;
	      
	      if(VERB>=4 && rverb && iL1 <= 150416 && iR1 >= 150416){
	        printf("m=%d(id=%lld):Phase=%0.6f,wt=%0.3f,LP1=%0.6f,LP2=%0.6f:iL1=%d->%d,iR1=%d->%d,iL2=%d->%d,iR2=%d->%d:Hcuts[iL1..iR1]=%0.3f..%0.3f,covA[iL1..iR1] += wt,covA[150416]= %0.4f\n",
		       m,gmap[pcontig->contig[m].mapid]->id,pcontig->MapPhase[m],wt,LP1,LP2,origiL1,iL1,origiR1,iR1,origiL2,iL2,origiR2,iR2,Hcuts[iL1],Hcuts[iR1],covA[150416]);
		fflush(stdout);
              }

	      int IL1 = origiL1, KL1 = origkL1, IR1 = origiR1, KR1 = origkR1;
	      int origJL1 = JL1, origJR1 = JR1;

	      nmapM = nmap1[m];
	      nmapKM = nmapK1[m];
	      if(HapSite[IL1] != 3 && HapSite[KL1] != 3){/* increase JL1, until it maps to HapSite[] == 3 */
		while(++JL1 <= JR1){
		  if((I = nmapM[JL1]) > 0){
		    int K = nmapKM[JL1];
		    if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N1);
		    IL1 = nmap1[MD][I];
		    KL1 = nmap1[MD][I-K];
		    if(DEBUG && !(origiL1 <= KL1 && KL1 <= IL1 && IL1 <= IR1/* WAS KR1*/ && IR1 <= n)){		    
		      for(int tJL1 = origJL1; ++tJL1 <= JL1;){
			int tI = nmapM[tJL1];
			if(tI > 0){
			  int tK = nmapKM[tJL1];
			  int tIL1 = nmap1[MD][tI];
			  int tKL1 = nmap1[MD][tI-tK];
			  printf("JL1=%d:I=%d,K=%d,IL1=%d,KL1=%d,HapSite[IL1,KL1]=%d,%d\n",tJL1,tI,tK,tIL1,tKL1,HapSite[tIL1],HapSite[tKL1]);
			}
		      }
		      printf("origJL1=%d,origJR1=%d,origiL1=%d,origkL1=%d,origiR1=%d,origkR1=%d:JL1=%d(I=%d,K=%d,N1=%d),KL1=%d,IL1=%d,JR1=%d,KR1=%d,IR1=%d,n=%d\n",
			     origJL1,origJR1,origiL1,origkL1,origiR1,origkR1,JL1,I,K,N1,KL1,IL1,JR1,KR1,IR1,n);
		      fflush(stdout);
		      assert(origiL1 <= KL1 && KL1 <= IL1 && IL1 <= IR1 && IR1 <= n);		    
		    }
		    if(HapSite[IL1] == 3 || HapSite[KL1] == 3)
		      break;
		  }
		}
	      }
	      if(JL1 < JR1 && HapSite[IR1] != 3 && HapSite[KR1] != 3){/* decrease JR1, until it maps to HapSite[] == 3 */
		while(--JR1 >= JL1){
		  if((I = nmapM[JR1]) > 0){
		    int K = nmapKM[JR1];
		    if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N1);
		    IR1 = nmap1[MD][I];
		    KR1 = nmap1[MD][I-K];
		    if(DEBUG) assert(KL1 <= KR1 && KR1 <= IR1 && IR1 <= origiR1 && origiR1 <= n);
		    if(HapSite[IR1] == 3 || HapSite[KR1] == 3)
		      break;
		  }
		}
	      }

	      int startIL1 = IL1, startKL1 = KL1, startIR1 = IR1, startKR1 = KR1;
	      int startJL1 = JL1, startJR1 = JR1;

	      while(JL1 < JR1){
		if(DEBUG && !((HapSite[IL1] == 3 || HapSite[KL1]==3) && (HapSite[IR1] == 3 || HapSite[KR1] == 3) && KL1 <= IL1 && IL1 < KR1 && KR1 <= IR1)){
		  printf("m=%d:Phase=%0.6f,LP1=%0.6f,LP2=%0.6f:iL1=%d,iR1=%d,iL2=%d,iR2=%d:orig(iL1=%d,kL1=%d,iR1=%d,kR1=%d,JL1=%d,JR1=%d)\n",
			 m,pcontig->MapPhase[m],LP1,LP2,iL1,iR1,iL2,iR2,origiL1,origkL1,origiR1,origkR1,origJL1,origJR1);
		  printf("\t KL1=%d->%d,IL1=%d->%d,KR1=%d->%d,IR1=%d->%d,JL1=%d->%d,JR1=%d->%d, HapSite[KL1,IL1,KR1,IR1]=%d,%d,%d,%d,M=%d,n=%d,wt=%0.6f\n",
			 startKL1,KL1,startIL1,IL1,startKR1,KR1,startIR1,IR1,startJL1,JL1,startJR1,JR1,HapSite[KL1],HapSite[IL1],HapSite[KR1],HapSite[IR1],M,n,wt);
		  int IL = nmap1[m][JL1], IR = nmap1[m][JR1], KL = nmapK1[m][JL1], KR = nmapK1[m][JR1];
		  printf("\t nmap1[m][JL1,JR1]=(IL,IR)=(%d,%d),nmapK1[m][JL1,JR1]=(KL,KR)=(%d,%d),nmap1[MD][IL-KL,IL,IR-KR,IR]=%d,%d,%d,%d\n",
			 IL,IR,KL,KR,nmap1[MD][IL-KL],nmap1[MD][IL],nmap1[MD][IR-KR],nmap1[MD][IR]);
		  fflush(stdout);
		  assert((HapSite[IL1] == 3 || HapSite[KL1/* WAS50 IR1*/]==3) && (HapSite[IR1] == 3 || HapSite[KR1] == 3) && KL1 <= IL1 && IL1 < KR1 && KR1 <= IR1);
	        }

	        int J = JL1, I,K,i = -1, k = -1;
		while(++J <= JR1){
		  if((I = nmapM[J]) > 0){
		    K = nmapKM[J];
		    if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N1);
		    i = nmap1[MD][I];
		    k = nmap1[MD][I-K];
		    if(DEBUG) assert(1 <= k && k <= i && i <= IR1);
		    if(HapSite[i] == 3 || HapSite[k] == 3)
		      break;
		  }
		}

		if(DEBUG && !(J <= JR1)){
		  printf("m=%d:Phase=%0.6f,LP1=%0.6f,LP2=%0.6f:iL1=%d,iR1=%d,iL2=%d,iR2=%d:orig(iL1=%d,kL1=%d,iR1=%d,kR1=%d,JL1=%d,JR1=%d)\n",
			 m,pcontig->MapPhase[m],LP1,LP2,iL1,iR1,iL2,iR2,origiL1,origkL1,origiR1,origkR1,origJL1,origJR1);
		  printf("\t KL1=%d->%d,IL1=%d->%d,k=%d,i=%d,KR1=%d->%d,IR1=%d->%d,HapSite[KL1,IL1,k,i,KR1,IR1]=%d,%d,%d,%d,%d,%d,M=%d,n=%d,wt=%0.6f\n",
			 startKL1,KL1,startIL1,IL1,k,i,startKR1,KR1,startIR1,IR1,HapSite[KL1],HapSite[IL1],HapSite[k],HapSite[i],HapSite[KR1],HapSite[IR1],M,n,wt);
		  int IL = nmap1[m][JL1], I = nmap1[m][J], IR = nmap1[m][JR1], KL = nmapK1[m][JL1], K = nmapK1[m][J], KR = nmapK1[m][JR1];
		  printf("\t nmap1[m][JL1,J,JR1]=(IL,I,IR)=(%d,%d,%d),nmapK1[m][JL1,J,JR1]=(KL,K,KR)=(%d,%d,%d),nmap1[MD][IL-KL,IL,I-K,I,IR-KR,IR]=%d,%d,%d,%d,%d,%d\n",
			 IL,I,IR,KL,K,KR,nmap1[MD][IL-KL],nmap1[MD][IL],nmap1[MD][I-K],nmap1[MD][I],nmap1[MD][IR-KR],nmap1[MD][IR]);
		  fflush(stdout);

		  assert(J <= JR1);
		}

		/* XM[JL1 .. J] maps to Hcuts1[(KL1,IL1) .. (k,i)] && HapSite[KL1 or IL1] == 3 && HapSite[k or i] == 3 && HapSite[IL1+1 .. k-1] < 3 (or not mapped by X[m]) */
		int left = HapSite[IL1] == 3 ? IL1 : KL1;
		int right = HapSite[k] == 3 ? k : i;

		int outlier = outlier1[m][JL1];
		for(int j = JL1+1; j < J; j++)
		  outlier |= outlier1[m][j];

		if(outlier){
		  for(int t = left+1; t <= right; t++)
		    if(HapSite[t] == 3){
		      IoutA[left] += wt;
		      if(VERB>=3 && rverb && left == 150416){
			double x = XM[J] - XM[JL1];
			double y = Yc(Hcuts1,i,i-k) - Yc(Hcuts1,IL1,IL1-KL1);
			printf("\tm=%d(idl=%lld):wt=%0.3f,J=%d..%d,i1=%d..%d,k1=%d..%d,y=%0.4f,x=%0.4f:left=%d,t=%d:outlier=%d: IoutA[left]= %0.6f\n",
			       m,gmap[pcontig->contig[m].mapid]->id,wt,JL1,J,IL1,i,KL1,k,y,x,left,t,outlier,IoutA[left]);
			fflush(stdout);
		      }
		      left = t;
		    }
		} else {
		  double x = XM[J] - XM[JL1];
		  double y = Yc(Hcuts1,i,i-k) - Yc(Hcuts1,IL1,IL1-KL1);
		  double y3 = Hcuts1[right] - Hcuts1[left];
		  double scale = x / y3;
		  double scaleY = y / y3;
		  for(int t = left + 1; t <= right; t++){
		    if(HapSite[t] == 3){/* update for sub-interval Hcuts1[left .. t], with HapSite[left,t] == 3 and HapSite[left + 1 .. t-1] < 3 */
		      double y2 = Hcuts1[t] - Hcuts1[left];
		      double x1 = scale * y2;
		      double y1 = scaleY * y2;
		      double err = x1 - y1;
		      IcovA[left] += wt;
		      varA[left] += wt * err * err;
		      meanA[left] += wt * err;
		      if(VERB>=3 && rverb && left == 150416){
			printf("\tm=%d(id=%lld):wt=%0.3f,J=%d..%d,i1=%d..%d,k1=%d..%d:left=%d,t=%d:y=%0.4f/%0.4f,x=%0.4f/%0.4f,err= %0.6f: IcovA[left]= %0.6f, varA[left]=  %0.6f, meanA[left]= %0.6f\n",
			       m,gmap[pcontig->contig[m].mapid]->id,wt,JL1,J,IL1,i,KL1,k,left,t,y1,y,x1,x,err,IcovA[left],varA[left],meanA[left]);
			fflush(stdout);
		      }

		      left = t;
		    }
		  }
		}

		/* look for next interval */
		JL1 = J;
		IL1 = i;
		KL1 = k;
	      } // while(JL1 < JR1)

	    } else if(pcontig->MapPhase[m] < 1.0-HapAlleleProb){/* Add MapWeight[m] to allele B's coverage (based on allignement to Allele B) */
	      cnt2 += wt;
	      for(int i = iL2; i <= iR2; i++)
		covB[i] += wt;
	      if(VERB>=4 && rverb && iL2 <= 150416 && iR2 >= 150416){
		printf("m=%d(id=%lld):Phase=%0.6f,wt=%0.3f,LP1=%0.6f,LP2=%0.6f:iL1=%d,iR1=%d,iL2=%d,iR2=%d:Hcuts[iL2..iR2]=%0.3f..%0.3f, covB[iL2..iR2] += wt,covB[150416]= %0.4f\n",
		       m,gmap[pcontig->contig[m].mapid]->id,pcontig->MapPhase[m],wt,LP1,LP2,iL1,iR1,iL2,iR2,Hcuts[iL2],Hcuts[iR2],covB[150416]);
		fflush(stdout);
              }

	      int IL2 = origiL2, KL2 = origkL2, IR2 = origiR2, KR2 = origkR2;
	      int origJL2 = JL2, origJR2 = JR2;
	      
	      nmapM = nmap2[m];
	      nmapKM = nmapK2[m];
	      if(HapSite[IL2] != 3 && HapSite[KL2] != 3){/* increase JL2, until it maps to HapSite[] == 3 */
		while(++JL2 <= JR2){
		  if((I = nmapM[JL2]) > 0){
		    int K = nmapKM[JL2];
		    if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N2);
		    IL2 = nmap2[MD][I];
		    KL2 = nmap2[MD][I-K];
		    if(DEBUG) assert(origiL2 <= KL2 && KL2 <= IL2 && IL2 <= IR2 && IR2 <= n);		    
		    if(HapSite[IL2] == 3 || HapSite[KL2] == 3)
		      break;
		  }
		}
	      }
	      if(JL2 < JR2 && HapSite[IR2] != 3 && HapSite[KR2] != 3){/* decrease JR2, until it maps to HapSite[] == 3 */
		while(--JR2 >= JL2){
		  if((I = nmapM[JR2]) > 0){
		    int K = nmapKM[JR2];
		    if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N2);
		    IR2 = nmap2[MD][I];
		    KR2 = nmap2[MD][I-K];
		    if(DEBUG) assert(KL2 <= KR2 && KR2 <= IR2 && IR2 <= origiR2 && origiR2 <= n);
		    if(HapSite[IR2] == 3 || HapSite[KR2] == 3)
		      break;
		  }
		}
	      }

	      int startIL2 = IL2, startKL2 = KL2, startIR2 = IR2, startKR2 = KR2;
	      int startJL2 = JL2, startJR2 = JR2;

	      while(JL2 < JR2){/* subdivide range Hcuts2[i=IL2 .. IR2] into intervals bounded by HapSite[i] ==3 */
		if(DEBUG && !((HapSite[IL2] == 3 || HapSite[KL2] == 3) && (HapSite[IR2] == 3 || HapSite[KR2] == 3) && KL2 <= IL2 && IL2 < KR2 && KR2 <= IR2)){
		  printf("m=%d:Phase=%0.6f,LP1=%0.6f,LP2=%0.6f:iL1=%d,iR1=%d,iL2=%d,iR2=%d:orig(iL2=%d,kL2=%d,iR2=%d,kR2=%d,JL2=%d,JR2=%d)\n",
			 m,pcontig->MapPhase[m],LP1,LP2,iL1,iR1,iL2,iR2,origiL2,origkL2,origiR2,origkR2,origJL2,origJR2);
		  printf("\t KL2=%d->%d,IL2=%d->%d,KR2=%d->%d,IR2=%d->%d,JL2=%d->%d,JR2=%d->%d, HapSite[KL2,IL2,KR2,IR2]=%d,%d,%d,%d,M=%d,n=%d,wt=%0.6f\n",
			 startKL2,KL2,startIL2,IL2,startKR2,KR2,startIR2,IR2,startJL2,JL2,startJR2,JR2,HapSite[KL2],HapSite[IL2],HapSite[KR2],HapSite[IR2],M,n,wt);
		  int IL = nmap2[m][JL2], IR = nmap2[m][JR2], KL = nmapK2[m][JL2], KR = nmapK2[m][JR2];
		  printf("\t nmap2[m][JL2,JR2]=(IL,IR)=(%d,%d),nmapK2[m][JL2,JR2]=(KL,KR)=(%d,%d),nmap2[MD][IL-KL,IL,IR-KR,IR]=%d,%d,%d,%d\n",
			 IL,IR,KL,KR,nmap2[MD][IL-KL],nmap2[MD][IL],nmap2[MD][IR-KR],nmap2[MD][IR]);
		  fflush(stdout);
		  assert((HapSite[IL2] == 3 || HapSite[KL2/* WAS50 IR2 */] == 3) && (HapSite[IR2] == 3 || HapSite[KR2] == 3) && KL2 <= IL2 && IL2 < KR2 && KR2 <= IR2);
	        }

		int J = JL2, I,K, i = -1, k= -1;
		while(++J <= JR2){
		  if((I = nmapM[J]) > 0){
		    K = nmapKM[J];
		    if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N2);
		    i = nmap2[MD][I];
		    k = nmap2[MD][I-K];
		    if(DEBUG && !(1 <= k && k <= i && i <= IR2)){
		      printf("m=%d:Phase=%0.6f,LP1=%0.6f,LP2=%0.6f:iL1=%d,iR1=%d,iL2=%d,iR2=%d:orig(iL2=%d,kL2=%d,iR2=%d,kR2=%d,JL2=%d,JR2=%d)\n",
			     m,pcontig->MapPhase[m],LP1,LP2,iL1,iR1,iL2,iR2,origiL2,origkL2,origiR2,origkR2,origJL2,origJR2);
		      printf("\t KL2=%d->%d,IL2=%d->%d,k=%d,i=%d,KR2=%d->%d,IR2=%d->%d,HapSite[KL2,IL2,k,i,KR2,IR2]=%d,%d,%d,%d,%d,%d,M=%d,n=%d,wt=%0.6f\n",
			     startKL2,KL2,startIL2,IL2,k,i,startKR2,KR2,startIR2,IR2,HapSite[KL2],HapSite[IL2],HapSite[k],HapSite[i],HapSite[KR2],HapSite[IR2],M,n,wt);
		      int IL = nmap2[m][JL2], I = nmap2[m][J], IR = nmap2[m][JR2], KL = nmapK2[m][JL2], K = nmapK2[m][J], KR = nmapK2[m][JR2];
		      printf("\t nmap2[m][JL2,J,JR2]=(IL,I,IR)=(%d,%d,%d),nmapK2[m][JL2,J,JR2]=(KL,K,KR)=(%d,%d,%d),nmap2[MD][IL-KL,IL,I-K,I,IR-KR,IR]=%d,%d,%d,%d,%d,%d\n",
			     IL,I,IR,KL,K,KR,nmap2[MD][IL-KL],nmap2[MD][IL],nmap2[MD][I-K],nmap2[MD][I],nmap2[MD][IR-KR],nmap2[MD][IR]);
		      fflush(stdout);
		      
		      assert(1 <= k && k <= i && i <= IR2);
		    }
		    if(HapSite[i] == 3 || HapSite[k] == 3)
		      break;
		  }
		}

		if(DEBUG && !(J <= JR2 /* WAS50 JR1*/)){
		  printf("m=%d:Phase=%0.6f,LP1=%0.6f,LP2=%0.6f:iL1=%d,iR1=%d,iL2=%d,iR2=%d:orig(iL2=%d,kL2=%d,iR2=%d,kR2=%d,JL2=%d,JR2=%d)\n",
			 m,pcontig->MapPhase[m],LP1,LP2,iL1,iR1,iL2,iR2,origiL2,origkL2,origiR2,origkR2,origJL2,origJR2);
		  printf("\t KL2=%d->%d,IL2=%d->%d,k=%d,i=%d,KR2=%d->%d,IR2=%d->%d,HapSite[KL2,IL2,k,i,KR2,IR2]=%d,%d,%d,%d,%d,%d,M=%d,n=%d,wt=%0.6f\n",
			 startKL2,KL2,startIL2,IL2,k,i,startKR2,KR2,startIR2,IR2,HapSite[KL2],HapSite[IL2],HapSite[k],HapSite[i],HapSite[KR2],HapSite[IR2],M,n,wt);
		  int IL = nmap2[m][JL2], I = nmap2[m][J], IR = nmap2[m][JR2], KL = nmapK2[m][JL2], K = nmapK2[m][J], KR = nmapK2[m][JR2];
		  printf("\t nmap2[m][JL2,J,JR2]=(IL,I,IR)=(%d,%d,%d),nmapK2[m][JL2,J,JR2]=(KL,K,KR)=(%d,%d,%d),nmap2[MD][IL-KL,IL,I-K,I,IR-KR,IR]=%d,%d,%d,%d,%d,%d\n",
			 IL,I,IR,KL,K,KR,nmap2[MD][IL-KL],nmap2[MD][IL],nmap2[MD][I-K],nmap2[MD][I],nmap2[MD][IR-KR],nmap2[MD][IR]);
		  fflush(stdout);

		  assert(J <= JR2);
		}

		/* XM[JL2 .. J] maps to Hcuts2[(KL2,IL2) .. (k,i)] && HapSite[KL2 or IL2] == 3 && HapSite[k or i] == 3 && HapSite[IL2+1 .. k-1] < 3 (or not mapped by X[m]) */
		int left = HapSite[IL2] == 3 ? IL2 : KL2;
		int right = HapSite[k] == 3 ? k : i;

		int outlier = outlier2[m][JL2];
		for(int j = JL2+1; j < J; j++)
		  outlier |= outlier2[m][j];
		if(outlier){
		  for(int t = left+1; t <= right; t++)
		    if(HapSite[t] == 3){
		      IoutB[left] += wt;
		      if(VERB>=3 && rverb && left == 150416){
			double x = XM[J] - XM[JL2];
			double y = Yc(Hcuts2,i,i-k) - Yc(Hcuts2,IL2,IL2-KL2);
			printf("\tm=%d(idl=%lld):wt=%0.3f,J=%d..%d,i2=%d..%d,k2=%d..%d,y=%0.4f,x=%0.4f:left=%d,t=%d:outlier=%d: IoutB[left]= %0.6f\n",
			       m,gmap[pcontig->contig[m].mapid]->id,wt,JL2,J,IL2,i,KL2,k,y,x,left,t,outlier,IoutB[left]);
			fflush(stdout);
		      }
		      left = t;
		    }
		} else {
		  double x = XM[J] - XM[JL2];
		  double y = Yc(Hcuts2,i,i-k) - Yc(Hcuts2,IL2,IL2-KL2);
		  double y3 = Hcuts2[right] - Hcuts2[left];
		  double scale = x/y3;
		  double scaleY = y/y3;
		  for(int t = left + 1; t <= right; t++){
		    if(HapSite[t] == 3){/* update for sub-interval Hcuts2[left .. t], with HapSite[left,t] ==3 and HapSite[left + 1 .. t-1] < 3 */
		      double y2 = Hcuts2[t] - Hcuts2[left];
		      double x1 = scale * y2;
		      double y1 = scaleY * y2;
		      double err = x1 - y1;
		      IcovB[left] += wt;
		      varB[left] += wt * err*err;
		      meanB[left] += wt * (x1 - y1);
		      if(VERB>=3 && rverb && left == 150416){
			printf("\tm=%d(idl=%lld):wt=%0.3f,J=%d..%d,i2=%d..%d,k2=%d..%d:left=%d,t=%d:y=%0.4f/%0.4f,x=%0.4f/%0.4f,err= %0.6f: IcovB[left]= %0.6f, varB[left]=  %0.6f, meanB[left]= %0.6f\n",
			       m,gmap[pcontig->contig[m].mapid]->id,wt,JL2,J,IL2,i,KL2,k,left,t,y1,y,x1,x,err,IcovB[left],varB[left],meanB[left]);
			fflush(stdout);
		      }

		      left = t;
		    }
		  }
		}

		/* look for next interval */
		JL2 = J;
		IL2 = i;
		KL2 = k;
	      } // while(JL2 < JR2)

	    } else {/* Add MapWeight[m] to catch-all C's coverage (half each based on alignment to Allele A and B) */
	      cnt3 += wt;
	      if(VERB>=4 && rverb && ((iL1 <= 150416 && iR1 >= 150416) || (iL2 <= 150416 && iR2 >= 150416))){
	        printf("m=%d(id=%lld):Phase=%0.6f,wt=%0.4f,LP1=%0.6f,LP2=%0.6f:HapSite[iL1=%d,iR1=%d,iL2=%d,iR2=%d]=%d,%d,%d,%d:covC[iL1..iR1,iL2..iR2] += 0.5 * wt, covC[150416]= %0.4f\n",
		       m,gmap[pcontig->contig[m].mapid]->id,pcontig->MapPhase[m],wt,LP1,LP2,iL1,iR1,iL2,iR2,HapSite[iL1],HapSite[iR1],HapSite[iL2],HapSite[iR2],covC[150416]);
		fflush(stdout);
              }
	      wt *= 0.5;
	      for(int i = iL1; i <= iR1; i++)
		covC[i] += wt;
	      for(int i = iL2; i <= iR2; i++)
		covC[i] += wt;
	    }
	  }

	  /* Filter HapSite and HapIndel based on covA[],covB[] and covC[] using thresholds HapAlleleCoverage,HapAlleleProb */
	  /* HapIndel filtering can be overriden by option -HapMinCovPL, which is based on IcovA[],IcovB[],varA[],varB[] */
          /* HERE HERE HERE : also check 1-2 intervals (bounded by HapSite==3) next to HapIndel : if covA or covB is very low (1 or 2) try to adjust size of next interval to cancel out original Hap Indel
	     and replace intervening labels with SNPs */
	  double HapDeltaScoreThreshold = (HapMinCovPvalueL <= 0.0) ? 1e+10 : -log(max(HapMinCovPvalueL/* WAS73 HapMinCovPvalue */, 1e-300)) + /* WAS113 - */ /* WAS27 + */ logHapIndelPvalue;
	  double HapSiteScoreThreshold = (HapMinCovPvalue <= 0.0) ? 1e+10 : -log(max(HapMinCovPvalue, 1e-300)) + /* WAS113 - */ /* WAS27 + */ logHapSitePvalue;
	  if(VERB/* HERE >= 2*/){
	    printf("HapMinCov %0.2f %0.2f %0.2f %0.3f %0.2e %0.2f %0.2e %0.2f %0.1f %d (HapDeltaScore < %0.3f, HapSiteScore < %0.3f),logHapIndelPvalue=%0.3f,logHapSitePvalue=%0.3f\n",
		   HapMinCoverage,HapAlleleCoverage,HapAlleleProb,HapMinCovSize,HapMinCovPvalue,HapAlleleCovInt, HapMinCovPvalueL, HapMinCovAbs, HapMinCovAbsM, HapMinCovN,
		   HapDeltaScoreThreshold, HapSiteScoreThreshold,logHapIndelPvalue,logHapSitePvalue);
	    if(HapMinCovPL1 < 1.0 || HapMinCovPL2 > 0.0)
	      printf("\t HapMinCovPL %0.2e %0.2e %d %0.2f\n",HapMinCovPL1,HapMinCovPL2,HapMinCovL,HapMinCovCL);
	    fflush(stdout);
	  }
	  for(int i = imin; i <= imax; i++){
	    if(!(HapSite[i] && (HapSite[i] <= 2 || HapDelta[i] || HapDeltaMerged[i])))
	      continue;

	    if(VERB>=3){
	      printf("i=%d:Hcuts[i]=%0.4f,HapSite[i]=%d,HapDelta[i]=%0.6f,HapDeltaMerged[i]=%0.6f,SNPcnt=%d,IndelCnt=%d:Checking HapSite[i] and HapDelta[i]:\n",
		     i,Hcuts[i],HapSite[i],HapDelta[i],HapDeltaMerged[i],SNPcnt,IndelCnt);
	      fflush(stdout);
	    }

	    if(HapSite[i] <= 2 && (HAPFILTER_FIX <= 1 || !(HapDelta[i] || HapDeltaMerged[i]))){/* HapSite[i] */
	      if(VERB>=1+RELEASE/* HERE >=2 */){
		printf("\t i=%d:Hcuts[i]=%0.4f,HapSite[i]=%d,HapSiteScore[i]=%0.2f:totCov=%0.2f,minCov=%0.4f(covA[i]=%0.2f,covB[i]=%0.2f,covC[i]=%0.2f),HapSiteScore=%0.3f/%0.2f\n",
		       i,Hcuts[i],HapSite[i],HapSiteScore[i],covA[i]+covB[i]+covC[i],min(covA[i],covB[i])/(covA[i]+covB[i]+covC[i]),covA[i],covB[i],covC[i],HapSiteScore[i],HapSiteScoreThreshold);
		fflush(stdout);
	      }
	      if((covA[i] + covB[i] + covC[i] < HapMinCoverage || min(covA[i],covB[i]) < HapAlleleCoverage * (covA[i] + covB[i] + covC[i])) 
		 && HapSiteScore[i] < HapSiteScoreThreshold/* WAS HapDeltaScoreThreshold */){
		int L = i-1;
		while(L > 0 && !HapSite[L])
		  L--;
		int LL = L;
		while(LL > 0 && HapSite[LL] != 3)
		  LL--;
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;
		memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
		memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
		memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));

		if(SiteScore[i] > 0.0){
		  HapSite[i] = 3;
		  if(HapDeltaMerged[i] && (LL > 0 && RR <= n)){/* may have split HapDelta group into two groups */
		    double sum = 0.0;
		    for(int t = LL; t < i; t++)
		      sum += HapDelta[t];
		    if(fabs(sum) >= MIN_INDEL_SIZE){
		      if(VERB/* HERE >=2 */){
			printf("Split HapDelta[%d..%d]=%0.4f into HapDelta[%d..%d]=%0.4f and HapDelta[%d..%d]=%0.4f\n",
			       LL,RR,HapDeltaMerged[i], LL,i,sum, i,RR,HapDeltaMerged[i]-sum);
			fflush(stdout);
		      }
		      for(int t = LL; t < i; t++)
			HapDeltaMerged[t] = sum;

		      sum = 0.0;
		      for(int t = i; t < RR; t++)
			sum += HapDelta[t];

		      for(int t = i; t < RR; t++)
			HapDeltaMerged[t] = sum;
		    }
		  }
		} else { /* SiteScore[i] <= 0 */
		  HapSite[i] = 0;
		  if(HapDelta[i] != 0.0){/* move to previous site L */
		    if(VERB/* HERE >=2 */){
		      printf("L=%d,i=%d:HapSite[i]=%d -> %d,HapDelta[L]=%0.6f->%0.6f,HapDelta[i]=%0.6f->0.0\n",
			     L,i,prevHapSite[i],HapSite[i],HapDelta[L],HapDelta[L]+HapDelta[i],HapDelta[i]);
		      fflush(stdout);
		    }
		    HapDelta[L] += HapDelta[i];
		    HapDelta[i] = 0.0;
		  }
		  if(Delta[i] != 0.0){/* move to previous site L */
		    if(VERB/* HERE >=2 */){
		      printf("L=%d,i=%d:HapSite[i]=%d -> %d,Delta[L]=%0.6f->%0.6f,Delta[i]=%0.6f->0\n",
			     L,i,prevHapSite[i],HapSite[i],Delta[L],Delta[L]+Delta[i],Delta[i]);
		      fflush(stdout);
		    }
		    Delta[L] += Delta[i];
		    Delta[i] = 0.0;
		  }
		}
		if(VERB/* HERE >=2 */){
		  if(MapSNR && HapSiteUnphasedSNR > 0.0)
		    printf("Filtered out HapSite[%d] = %d -> %d at Hcuts= %0.4f due to -HapMinCov %0.2f %0.2f %0.2f %0.3f %0.2e %0.2f %0.2e %0.2f %0.1f %d: covA=%0.2f,covB=%0.2f,covC=%0.2f (HapSiteScore=%0.3f/%0.3f,SiteScore=%0.3f,SNR=%0.2f)\n", 
			   i, prevHapSite[i], HapSite[i], Hcuts[i], HapMinCoverage, HapAlleleCoverage, HapAlleleProb, HapMinCovSize, HapMinCovPvalue, HapAlleleCovInt, HapMinCovPvalueL, HapMinCovAbs,
			   HapMinCovAbsM, HapMinCovN, covA[i],covB[i],covC[i], HapSiteScore[i], HapSiteScoreThreshold,SiteScore[i],SNRsum[i]);
		  else
		    printf("Filtered out HapSite[%d] = %d -> %d at Hcuts= %0.4f due to -HapMinCov %0.2f %0.2f %0.2f %0.3f %0.2e %0.2f %0.2e %0.2f %0.1f %d: covA=%0.2f,covB=%0.2f,CovC=%0.2f (HapSiteScore=%0.3f/%0.3f,SiteScore=%0.3f)\n", 
			   i, prevHapSite[i], HapSite[i], Hcuts[i], HapMinCoverage, HapAlleleCoverage, HapAlleleProb, HapMinCovSize, HapMinCovPvalue, HapAlleleCovInt, HapMinCovPvalueL, HapMinCovAbs, 
			   HapMinCovAbsM, HapMinCovN, covA[i],covB[i],covC[i], HapSiteScore[i], HapSiteScoreThreshold,SiteScore[i]);
		  fflush(stdout);
		}

		/* update LP and verify that no labels closer than minKB have been introduced */
		int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		if(err){
		  if(VERB){
		    printf("Removal of HapSite[%d] due to -HapMinCov failed due to hsetmap (labels closer than minKB=%0.4f, N1=%d,N2=%d)\n", i, minKB,N1,N2);
		    fflush(stdout);
		  }
		  memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
		  memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));
		} else {
		  double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					 TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB/* HERE >=2 */){
		    printf("\t newLP= %0.6f -> %0.6f, SNPs=%d, Indels=%d\n",newLP,nLP,SNPs,Indels);
		    fflush(stdout);
		  }
		  newLP = nLP;
		  SNPcnt = SNPs;
		  IndelCnt = Indels;

		  if(DELTA_STOP >= 3){	      /* reactivate nearby intervals */
		    DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		    int IN1 = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		    int IN2 = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		    IN1 = max(0, IN1);
		    IN2 = min(maxIN, IN2);
		    if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
		      printf("After filtering SNP at Hcuts[i=%d]=%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			     i,Hcuts[i],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		      fflush(stdout);
		      assert(0 <= IN1 && IN1 <= maxIN);
		    }
		    if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
		      printf("After filtering SNP at Hcuts[i=%d]=%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			     i,Hcuts[i],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		      fflush(stdout);
		      assert(0 <= IN2 && IN2 <= maxIN);
		    }
		    if(DEBUG) assert(IN1 <= IN2);
		  
		    int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		    int origactivecnt = activecnt;

		    for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
		      if(DELTA_RANGE[T] <= 0){
			activecnt++;
			DELTA_RANGE[T] = min_DELTA;
			for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
			  Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
			if(HAPSTOP_DEBUG){
			  printf("Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to filtered SNP at Hcuts[%d]=%0.4f\n",
				 T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
				 DELTA_RANGE[T],Initial_Delta[T][0], Initial_Delta[T][DELTA_RANGE[T]-1], i, Hcuts[i]);
			  fflush(stdout);
			}
		      } else if(HAPSTOP_DEBUG>=2){
			printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after filtering SNP at Hcuts[%d] with IDelta[%d]=%0.3f .. %0.3f\n",
			       T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			       i,DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1]);
			fflush(stdout);
		      }
		    }

		    if(VERB && activecnt > origactivecnt){
		      if(VERB>=2){
			int inactivecnt = 0;
			for(int IN = 0; IN <= maxIN; IN++)
			  if(DELTA_RANGE[IN] <= 0)
			    inactivecnt++;

			printf("Activated %d/%d intervals due to filtering SNP at Hcuts[%d] = %0.4f : inactive intervals = %d/%d\n",
			       activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, Hcuts[i], inactivecnt,maxIN+1);
		      } else
			printf("Activated %d/%d intervals due to filtering SNP at Hcuts[%d] = %0.4f\n",
			       activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, Hcuts[i]);
		      fflush(stdout);
		    }
		  }// DELTA_STOP >= 3
		}

		continue;
	      }/* Filtered HapSite[i] */

	      if(VERB>=3){
		printf("i=%d:Hcuts[i]=%0.4f,HapSite[i]=%d,HapDelta[i]=%0.6f,HapDeltaMerged[i]=%0.6f,SNPcnt=%d,IndelCnt=%d:Checking HapDelta[i]:\n",
		       i,Hcuts[i],HapSite[i],HapDelta[i],HapDeltaMerged[i],SNPcnt,IndelCnt);
		fflush(stdout);
	      }
	    } /* HapSite[i] <= 2 */

	    if(VERB>=1+RELEASE/* HERE HERE >=2 */ && !HapDeltaMerged[i] && HapSite[i] == 3){
	      int L = i;
	      int R = i+1;
	      while(R <= n && HapSite[R] != 3)
		R++;

	      extern double ChiSqPvalue(int n, double chisq);
	      double wtA = max(0.001,IcovA[L]);
	      double wtB = max(0.001,IcovB[L]);
	      double biasA = meanA[L]/wtA;
	      double biasB = meanB[L]/wtB;
	      double yA = Hcuts1[R] - Hcuts1[i] + biasA;
	      double yB = Hcuts2[R] - Hcuts2[i] + biasB;
	      double VaryA = (SF[0]*SF[0] + yA * SD[0] * fabs(SD[0]) + yA * yA * SR[0]*SR[0]);
	      double VaryB = (SF[0]*SF[0] + yB * SD[0] * fabs(SD[0]) + yB * yB * SR[0]*SR[0]);
	      double InvVaryA = 1.0/VaryA;
	      double InvVaryB = 1.0/VaryB;
	      double VarA = max(1e-6, varA[L]/wtA);
	      double VarB = max(1e-6, varB[L]/wtB);
	      int nA = max(1.0, floor(wtA - 0.5));
	      int nB = max(1.0, floor(wtB - 0.5));
	      double pvA = ChiSqPvalue(nA, VarA * nA * InvVaryA);
	      double pvB = ChiSqPvalue(nB, VarB * nB * InvVaryB);
	      double pvA2 = ChiSqPvalue(nA, VarA * nA / (VarB * VaryA * InvVaryB));
	      double pvB2 = ChiSqPvalue(nB, VarB * nB / (VarA * VaryB * InvVaryA));

	      printf("    L=i=%d,R=%d:Hcuts[i]=%0.4f(Hcuts[i..R]=%0.4f,%0.4f),HapSite[L,R]=%d,%d:covA[L,R]=%0.2f,%0.2f,covB[L,R]=%0.2f,%0.2f,covC[L,R]=%0.2f,%0.2f, IcovA[L]= %0.2f+%0.2f(bias=%0.3f,sd=%0.3f/%0.3f,pv=%0.2e,%0.2e), IcovB[L]= %0.2f+%0.2f(bias=%0.3f,sd=%0.3f/%0.3f,pv=%0.2e,%0.2e)\n",
		     L,R,Hcuts[i],Hcuts1[R]-Hcuts1[i],Hcuts2[R]-Hcuts2[i],HapSite[L],HapSite[R],covA[L],covA[R],covB[L],covB[R],covC[L],covC[R],
		     IcovA[L], IoutA[L], biasA, sqrt(VarA), sqrt(VaryA), pvA,pvA2, 
		     IcovB[L], IoutB[L], biasB, sqrt(VarB), sqrt(VaryB), pvB,pvB2);
	      fflush(stdout);
	    }

	    if(HapDeltaMerged[i] && HapSite[i] == 3){
      
	      int L = i;
	      int R = i+1;
	      while(R <= n && HapSite[R] != 3)
		R++;
	      if(VERB>=2){
		printf("L=i=%d,R=%d:HapDelta[i,R-1]=%0.6f,%0.6f,HapSite[i,R]=%d,%d,SNPcnt=%d,IndelCnt=%d\n",i,R,HapDelta[i],HapDelta[R-1],HapSite[i],HapSite[R],SNPcnt,IndelCnt);
		fflush(stdout);
	      }

	      double maxinterval = 0.0;
	      int tlast = L;
	      for(int t = L+1; t <= R; t++){
		if(!HapSite[t])
		  continue;
		maxinterval = max(Hcuts[t] + DelCum[t] - Hcuts[tlast] - DelCum[tlast], maxinterval);
		tlast = t;
	      }

	      // NOTE : maxinterval adjustment models increased likelihood of encourtering DNA knots in large intervals
	      double HapIndelRelCov = HapAlleleCoverage + HapAlleleCovInt * /* WAS28 maxinterval / 100.0 */ min(1.0, (Hcuts[R] + DelCum[R] - Hcuts[L] - DelCum[L]) / 100.0);
	      if(2.0 * fabs(HapDeltaMerged[L]) >= 35.0) 	      // RL adjustment should be disabled for HapIndel size diff >= 35kb) since largest knots are 25kb
		HapIndelRelCov = HapAlleleCoverage;// NEW97

	      double minTotCov = 9999.0, minAlleleCov = 1.0;
	      double minAlleleCovAbs = minTotCov;// NEW68
	      int tmin = L, SNP = 0;
	      for(int t = L; t <= R; t++){
		if(!HapSite[t]) // NEW97
		  continue;
		double totcov = covA[t] + covB[t] + covC[t];
		minTotCov = min(minTotCov, totcov);

		double mincov = min(covA[t], covB[t]) / max(0.1,covA[t]+covB[t] /* WAS136 totcov */);
		if(mincov < minAlleleCov /* NEW97 */&& (t==L || t==R)){
		  tmin = t;
		  minAlleleCov = min(minAlleleCov, mincov);
		}
		minAlleleCovAbs = min(minAlleleCovAbs, min(covA[t], covB[t]));
		if(1 <= HapSite[t] && HapSite[t] <= 2)
		  SNP++;
	      }
	      if(DEBUG>=2) assert(minAlleleCovAbs >= 0.0);

	      if(DEBUG>=2) assert(L==i);

	      // NEW136 : Disable RL adjustment if minor Allele is the larger Allele (NOTE : applies even if -MinorIsBigger 0 is specified)
	      bool MinorIsBigger = (covA[tmin] < covB[tmin]) ^ (Hcuts1[R]-Hcuts1[L] < Hcuts2[R]-Hcuts2[L]);// NOTE : can ignore ties since then there is either no imbalance OR no Indel !
	      if(MinorIsBigger)
		 HapIndelRelCov = HapAlleleCoverage;

	      extern double ChiSqPvalue(int n, double chisq);
	      double wtA = max(0.001,IcovA[L]);
	      double wtB = max(0.001,IcovB[L]);
	      double biasA = meanA[L]/wtA;
	      double biasB = meanB[L]/wtB;
	      double yA = Hcuts1[R] - Hcuts1[i] + biasA;
	      double yB = Hcuts2[R] - Hcuts2[i] + biasB;
	      double VaryA = (SF[0]*SF[0] + yA * SD[0] * fabs(SD[0]) + yA * yA * SR[0]*SR[0]);
	      double VaryB = (SF[0]*SF[0] + yB * SD[0] * fabs(SD[0]) + yB * yB * SR[0]*SR[0]);
	      double InvVaryA = 1.0/VaryA;
	      double InvVaryB = 1.0/VaryB;
	      double VarA = max(1e-6, varA[L]/wtA);
	      double VarB = max(1e-6, varB[L]/wtB);
	      int nA = max(1.0, floor(wtA - 0.5));
	      int nB = max(1.0, floor(wtB - 0.5));
	      double pvA = ChiSqPvalue(nA, VarA * nA * InvVaryA);
	      double pvB = ChiSqPvalue(nB, VarB * nB * InvVaryB);
	      double pvA2 = ChiSqPvalue(nA, VarA * nA / (VarB * VaryA * InvVaryB));
	      double pvB2 = ChiSqPvalue(nB, VarB * nB / (VarA * VaryB * InvVaryA));

	      bool ChiSqPV1, ChiSqPV2;

	      /* IFF -MinorIsBigger 1, disable filtering Hap Indels in which Minor Allele is larger (unless total coverage is below HapMinCoverage) */
	      if(!checkMinorIsBigger)
		MinorIsBigger = false;

	      bool UseChiSq = ((covA[tmin] < covB[tmin] ? IcovA[L]+IoutA[L] : IcovB[L]+IoutB[L]) >= HapMinCovCL);/* OK to use ChiSq test if coverage of minor Allele (including outliers) is at least HapMinCovCL */

	      if(!HapMinCovL){
		ChiSqPV1 = ((covA[tmin] < covB[tmin] ? min(pvA,pvA2) : min(pvB,pvB2)) > HapMinCovPL1 || MinorIsBigger) && (minTotCov >= HapMinCoverage) && UseChiSq;
		ChiSqPV2 = (covA[tmin] < covB[tmin] ? max(pvA,pvA2) : max(pvB,pvB2)) < HapMinCovPL2 && !MinorIsBigger && UseChiSq;
	      } else if(HapMinCovL == 1){
		ChiSqPV1 = ((covA[tmin] < covB[tmin] ? pvA : pvB) > HapMinCovPL1 || MinorIsBigger) && (minTotCov >= HapMinCoverage) && UseChiSq;
		ChiSqPV2 = (covA[tmin] < covB[tmin] ? pvA : pvB) < HapMinCovPL2 && !MinorIsBigger && UseChiSq;
	      } else {
		ChiSqPV1 = ((covA[tmin] < covB[tmin] ? pvA2 : pvB2) > HapMinCovPL1 || MinorIsBigger) && (minTotCov >= HapMinCoverage) && UseChiSq;
		ChiSqPV2 = (covA[tmin] < covB[tmin] ? pvA2 : pvB2) < HapMinCovPL2 && !MinorIsBigger && UseChiSq;
	      }

	      double SNPdensity = SNP*100.0 / max(Hcuts1[R]-Hcuts1[i],Hcuts2[R]-Hcuts2[i]);

	      if(VERB>=1+RELEASE/* HERE >=3 */){
		printf("    L=i=%d,R=%d:Hcuts[i]=%0.4f,Hcuts[i..R]=%0.4f,%0.4f,HapDelta[L,R-1]=%0.4f,%0.4f,HapSite[L,R]=%d,%d,HapDeltaMerged[L,R-1]=%0.4f,%0.4f/%0.4f,Cov[L..R]:\n",
		       L,R,Hcuts[i],Hcuts1[R]-Hcuts1[i],Hcuts2[R]-Hcuts2[i],HapDelta[L],HapDelta[R-1],HapSite[L],HapSite[R],HapDeltaMerged[L],HapDeltaMerged[R-1],HapMinCovSize);
		printf("\t tot=%0.2f/%0.2f,minCov=%0.4f/%0.4f(t=%d,covA[L,t,R]=%0.2f,%0.2f,%0.2f,covB[L,t,R]=%0.2f,%0.2f,%0.2f,covC[L,t,R]=%0.2f,%0.2f,%0.2f),minCovAbs=%0.2f,SNPs=%d,%0.1f/100kb\n",
		       minTotCov,HapMinCoverage,minAlleleCov,HapIndelRelCov,tmin,covA[L],covA[tmin],covA[R],covB[L],covB[tmin],covB[R],covC[L],covC[tmin],covC[R],minAlleleCovAbs,SNP,SNPdensity);

		printf("\t maxInterval=%0.2f,HapDeltaScore[i]= %0.2f/ %0.2f, IcovA[L]= %0.2f+%0.2f(bias=%0.3f,sd=%0.3f/%0.3f,pv=%0.2e,%0.2e) IcovB[L]= %0.2f+%0.2f(bias=%0.3f,sd=%0.3f/%0.3f,pv=%0.2e,%0.2e),min Icov= %0.2f:%d,%d,%d\n",
		       maxinterval,HapDeltaScore[i],HapDeltaScoreThreshold * (HapIndelRelCov / HapAlleleCoverage),
		       IcovA[L], IoutA[L], biasA, sqrt(VarA), sqrt(VaryA), pvA,pvA2, 
		       IcovB[L], IoutB[L], biasB, sqrt(VarB), sqrt(VaryB), pvB,pvB2,HapMinCovCL,UseChiSq,ChiSqPV1,ChiSqPV2);
		fflush(stdout);
	      }
	      if((((((minTotCov < HapMinCoverage || (minAlleleCov < HapIndelRelCov && (HapMinCovSize <= 0.0 || fabs(HapDeltaMerged[i]) * 2.0 < HapMinCovSize)))
		     && HapDeltaScore[i] < HapDeltaScoreThreshold * (HapIndelRelCov / HapAlleleCoverage)) || minAlleleCovAbs < HapMinCovAbs) && !ChiSqPV1) || ChiSqPV2) && 
		 !(SNPdensity > HapMinCovAbsM && SNP > HapMinCovN)){

		memcpy(&prevHapDelta[L],&HapDelta[L],(R-L)*sizeof(double));
		memcpy(&prevDelta[L],&Delta[L],(R-L)*sizeof(double));
		memcpy(&prevHapSite[L],&HapSite[L],(R-L)*sizeof(int));

		double HapIndelTot = 0.0;
		for(int t = L; t < R; t++)
		  HapIndelTot += HapDelta[t];
		if(VERB/* HERE >=2 */){
		  printf("Filtering out HapIndel[%d..%d] = %0.6f(tot=%0.6f) due to -HapMinCov %0.2f %0.2f %0.2f %0.3f %0.2e %0.2f %0.2e %0.2f %0.1f %d (PL= %0.1e %0.1e): TotCov=%0.2f,AlleleCov=%0.4f (HapDeltaScore[%d]=%0.2f/%0.2e)\n",
			 L,R,HapIndelTot,HapDeltaMerged[i],HapMinCoverage,HapAlleleCoverage,HapAlleleProb, HapMinCovSize, HapMinCovPvalue, HapAlleleCovInt, HapMinCovPvalueL, HapMinCovAbs,
			 HapMinCovAbsM, HapMinCovN, HapMinCovPL1, HapMinCovPL2, minTotCov, minAlleleCov, i, HapDeltaScore[i],HapDeltaScoreThreshold);
		  if(VERB>=2)
		    for(int t = L; t < R; t++)
		      printf("t=%d:HapDelta[t]= %0.6f, Delta[t]= %0.6f, Hcuts[t]= %0.6f, HapSite[t]= %d: HapDeltaMerged[t]= %0.6f\n",t, HapDelta[t], Delta[t], Hcuts[t], HapSite[t], HapDeltaMerged[t]);
		  fflush(stdout);
		}
		if(DEBUG && L > 0 && R <= n && !(HapSite[L] == 3 && HapSite[R]==3 && fabs(HapIndelTot) > 0.0 && fabs(HapIndelTot - HapDeltaMerged[i]) < MIN_INDEL_SIZE)){
		  for(int t = L; t < R; t++)
		    printf("t=%d:HapDelta[t]= %0.6f, Delta[t]= %0.6f, Hcuts[t]= %0.6f, HapSite[t]= %d: HapDeltaMerged[t]= %0.6f\n",t, HapDelta[t], Delta[t], Hcuts[t], HapSite[t], HapDeltaMerged[t]);
		  printf("L=%d,R=%d:HapSite[L]=%d,HapSite[R]=%d,HapIndelTot= %0.6f, HapDeltaMerged[i=%d]= %0.6f, MIN_INDEL_SIZE= %0.6f\n",L,R,HapSite[L],HapSite[R],HapIndelTot, i, HapDeltaMerged[i], MIN_INDEL_SIZE);
		  fflush(stdout);

		  assert(HapSite[L] == 3 && HapSite[R]==3 && fabs(HapIndelTot) > 0.0 && fabs(HapIndelTot - HapDeltaMerged[i]) < MIN_INDEL_SIZE);
		}

		for(int t = L; t < R; t++)
		  HapDeltaMerged[t] = HapDelta[t] = 0.0;

		// NOTE : it is still possible that the resulting map will fail the minKB label distance requirement 
		int SNPs = SNPcnt, Indels = IndelCnt;
		double nLP = newLP - BigPen;
		int bestAllele = 3;

		int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		if(err){
		  if(VERB/* HERE >=2 */){
		    printf("Averaged removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",L,R,HapIndelTot);
		    fflush(stdout);
		  }
		  bestAllele = -1;
		} else {
		  nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				  TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		  if(VERB/* HERE >=2 */){
		    printf("\t Averaged removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n", L, R, HapIndelTot, nLP, nLP - newLP, SNPs, Indels,wtime());
		    fflush(stdout);
		  }
		}

		/* next try changing only Allele 1 */
		for(int t = L; t < R; t++)
		  Delta[t] = prevDelta[t] - prevHapDelta[t];
		if(HAPINDELDELETE_FIX){
		  for(int t = L+1; t < R; t++){
		    if(HapSite[t] == 1)
		      HapSite[t] = 0;
		    else if(HapSite[t] == 2)
		      HapSite[t] = 3;
		  }
		  for(int t = R; --t > L;){
		    if(!HapSite[t]){
		      Delta[t-1] += Delta[t];
		      Delta[t] = 0.0;
		    }
		  }
		}

		double nLP2 = nLP;
		err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		if(err){
		  if(VERB/* HERE >=2 */){
		    printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",L,R,HapIndelTot);
		    fflush(stdout);
		  }
		} else {
		  int SNPs2,Indels2;
		  nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs2,Indels2,0);
		  if(VERB/* HERE >=2 */){
		    printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
			   L,R,HapIndelTot, nLP2, nLP2 > nLP ? '!' : ' ', nLP2 - newLP, SNPs2,Indels2,wtime());
		    fflush(stdout);
		  }
		  if(nLP2 > nLP || bestAllele == -1){
		    nLP = nLP2;
		    SNPs = SNPs2;
		    Indels = Indels2;
		    bestAllele = 1;

		    /* swap newLPA and bestLPA */
		    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;

		  }	  
		}

		/* next try changing only Allele 2 */
		for(int t = L; t < R; t++)
		  Delta[t] = prevDelta[t] + prevHapDelta[t];
		if(HAPINDELDELETE_FIX){	      // need to also change HapSite[L+1..R-1] to match Allele 1 : HapSite 1 -> 3, 2 -> 0 
		  for(int t = L+1; t < R; t++){
		    HapSite[t] = prevHapSite[t];
		    if(HapSite[t] == 1)
		      HapSite[t] = 3;
		    else if(HapSite[t] == 2)
		      HapSite[t] = 0;
		  }
		  for(int t = R; --t > L;){
		    if(!HapSite[t]){
		      Delta[t-1] += Delta[t];
		      Delta[t] = 0.0;
		    }
		  }
		}
	      
		err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		if(err){
		  printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",L,R,HapIndelTot);
		} else {
		  int SNPs2,Indels2;
		  nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				   TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs2,Indels2,0);
		  if(VERB/* HERE >=2 */){
		    printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
			   L,R,HapIndelTot, nLP2, nLP2 > nLP ? '!' : ' ', nLP2 - newLP, SNPs2,Indels2,wtime());
		    fflush(stdout);
		  }
		  if(nLP2 > nLP || bestAllele == -1){
		    nLP = nLP2;
		    SNPs = SNPs2;
		    Indels = Indels2;
		    bestAllele = 2;

		    /* swap newLPA and bestLPA */
		    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		  }	  
		}
	      
		if(VERB && bestAllele == -1){
		  printf("\t Unable to remove HapIndel!\n");
		  fflush(stdout);
		}

		if(bestAllele != -1){
		  newLP = nLP;
		  SNPcnt = SNPs;
		  IndelCnt = Indels;
		  if(bestAllele != 2){
		    if(bestAllele == 1){
		      if(VERB){
			printf("\t Selecting Allele1 only removal of HapIndel\n");
			fflush(stdout);
		      }
		      for(int t = L; t < R; t++)
			Delta[t] = prevDelta[t] - prevHapDelta[t];
		      if(HAPINDELDELETE_FIX){
			for(int t = L+1; t < R; t++){
			  HapSite[t] = prevHapSite[t];
			  if(HapSite[t] == 1)
			    HapSite[t] = 0;
			  else if(HapSite[t] == 2)
			    HapSite[t] = 3;
			}
			for(int t = R; --t > L;){
			  if(!HapSite[t]){
			    Delta[t-1] += Delta[t];
			    Delta[t] = 0.0;
			  }
			}
		      }
		    } else {
		      if(VERB){
			printf("\t Selecting Averaged removal of HapIndel\n");
			fflush(stdout);
		      }
		      for(int t = L; t < R; t++)
			Delta[t] = prevDelta[t];
		      if(HAPINDELDELETE_FIX)
			for(int t = L; t < R; t++)
			  HapSite[t] = prevHapSite[t];
		    }
		  } else {
		    if(VERB){
		      printf("\t Selecting Allele2 only removal of HapIndel\n");
		      fflush(stdout);
		    }
		  }

		  if(DEBUG>=2){/* verify LP is now equal to newLP */
		    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		    nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) ||VERB/* HERE >=2 */){
		      if(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt)
			printf("\t After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);		    
		      else
			printf("WARNING: After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);
		      fflush(stdout);
		      assert(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt);
		    }
		  }

		  if(DELTA_STOP >= 3){	      /* reactivate nearby intervals */
		    DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		    int IN1 = floor((Hcuts[L] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		    int IN2 = floor((Hcuts[R] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		    IN1 = max(0, IN1);
		    IN2 = min(maxIN, IN2);
		    if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
		      printf("After filtering HapIndel at Hcuts[%d,%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			     L,R,Hcuts[L],Hcuts[R],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		      fflush(stdout);
		      assert(0 <= IN1 && IN1 <= maxIN);
		    }
		    if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
		      printf("After filtering HapIndel at Hcuts[%d,%d]=%0.4f,%0.4f : IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			     L,R,Hcuts[L],Hcuts[R],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
		      fflush(stdout);
		      assert(0 <= IN2 && IN2 <= maxIN);
		    }
		    if(DEBUG) assert(IN1 <= IN2);
		  
		    int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		    int origactivecnt = activecnt;

		    for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
		      if(DELTA_RANGE[T] <= 0){
			activecnt++;
			DELTA_RANGE[T] = min_DELTA;
			for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
			  Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
			if(HAPSTOP_DEBUG){
			  printf("Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to filtered HapIndel at Hcuts[%d,%d]=%0.4f,%0.4f\n",
				 T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
				 DELTA_RANGE[T],Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1],L,R, Hcuts[L],Hcuts[R]);
			  fflush(stdout);
			}
		      } else if(HAPSTOP_DEBUG>=2){
			printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after filtering HapIndel at Hcuts[%d,%d] with IDelta[%d]=%0.3f .. %0.3f\n",
			       T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
			       L,R,DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1]);
			fflush(stdout);
		      }
		    }

		    if(VERB && activecnt > origactivecnt){
		      if(VERB>=2 || HAPSTOP_DEBUG){
			int inactivecnt = 0;
			for(int IN = 0; IN <= maxIN; IN++)
			  if(DELTA_RANGE[IN] <= 0)
			    inactivecnt++;

			printf("Activated %d/%d intervals due to filtering HapIndel at Hcuts[%d,%d] = %0.4f,%0.4f : inactive intervals = %d/%d\n",
			       activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, L,R,Hcuts[L], Hcuts[R], inactivecnt,maxIN+1);
		      } else
			printf("Activated %d/%d intervals due to filtering HapIndel at Hcuts[%d,%d] = %0.4f,%0.4f\n",
			       activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, L,R,Hcuts[L], Hcuts[R]);
		      fflush(stdout);
		    }
		  }// DELTA_STOP >= 3
		}// if bestAllele != -1

		continue;
	      }/* Filtered out HapDelta[i] */
	    } /* if (HapDelta[i] != 0.0) */
	  } /* for i = imin .. imax */

	  if(VERB/* HERE >=2 */){
	    printf("After filtering Hap Sites and Indels: (IndelCnt=%d -> %d, SNPcnt=%d -> %d,imin=%d,imax=%d,n=%d):wtsumA=%0.2f,wtsumB=%0.2f,wtsumC=%0.2f:wtime=%0.6f\n",
		   origIndelCnt, IndelCnt, origSNPcnt, SNPcnt,imin,imax,n,cnt1,cnt2,cnt3,wtime());
	    if(VERB>=2){
	      int hap = 0;
	      for(int i = 1; i <= n; i++){
		if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
		  printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
			 i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
		if(hap && HapSite[i]==3)
		  hap = 0;
		if(HapDelta[i])
		  hap = 1;
	      }
	    }
	    fflush(stdout);
	  }

	  // NEW137 : update LPhwm etc
	  LPhwm = -BigPen;
	  LPdrop_count = 0;
	  if(HAP_INDEL_SKIP_FIX)
	    HapIndelDelSkipcnt = 0;

	  if(HAPMINCOV_ENDFIX && PoutlierEnd != origPoutlierEnd){
	    double sPoutlierEnd = PoutlierEnd;
	    PoutlierEnd = origPoutlierEnd;

	    if(!(!FILTER_STOP && HAPFILTER_FIX >= 1 && (origIndelCnt != IndelCnt || origSNPcnt != SNPcnt) && HINDELITER(iter))){/* recompute LP */
	      if(SETLIMIT_CACHE)
		for(int m = 0; m < MD; m++)
		  limit1[m].ileft = limit2[m].ileft = -1;// cannot rely on previous cache

	      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	    
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB){
		printf("Restoring PoutlierEnd = %0.3e -> %0.3e: LP= %0.6f -> %0.6f (SNPs=%d,Indels=%d)\n", sPoutlierEnd,origPoutlierEnd,newLP,nLP,SNPs,Indels);
		fflush(stdout);
	      }
	      newLP = nLP;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;

	      /* swap newLPA,bestLPA */
	      double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;
	      tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;

	      if(HINDELITER(iter))// NEW137
		LPhwm = newLP;
	    } else 	    if(VERB){
	      printf("Restoring PoutlierEnd = %0.3e -> %0.3e\n", sPoutlierEnd,origPoutlierEnd);
	      fflush(stdout);
	    }
	  }

	  if(DEBUG>=2){
	    /* NEW*/hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* needed to update N1,N2,Y1,Y2 etc */

	    /* check if map[MD] and nmap[MD] are consistent */

	    int I,i;
	    for(i = 1; i <= n; i++)
	      if((I = map1[MD][i]) >= 0){
		assert(nmap1[MD][I] == i);
		assert(fabs(Hcuts1[i] - Y1[I]) < 1e-6);
	      }
	    for(I = 1; I <= N1; I++)
	      if((i = nmap1[MD][I]) >= 0){
		assert(map1[MD][i] == I);
		assert(fabs(Hcuts1[i] - Y1[I]) < 1e-6);
	      }
	    for(i = 1; i <= n; i++)
	      if((I = map2[MD][i]) >= 0){
		assert(nmap2[MD][I] == i);
		assert(fabs(Hcuts2[i] - Y2[I]) < 1e-6);
	      }
	    for(I = 1; I <= N2; I++)
	      if((i = nmap2[MD][I]) >= 0){
		assert(map2[MD][i] == I);
		assert(fabs(Hcuts2[i] - Y2[I]) < 1e-6);
	      }

	    /* make sure map[] and mapK[] are consistent */
	    for(int m = 0; m < MD; m++){
	      int M = MX[m];

	      int lastJ = -1, lasti = -1, lastk = -1, i, k;
	      for(int J = 1; J <= M; J++){
                if((i = map1[m][J]) > 0 && (I = map1[MD][i]) > 0){
		  k = mapK1[m][J];
		  assert(0 <= k && k < i);
		  if(k > 0 && map1[MD][i-k] < 0)/* locally "clean up" mapK */
		    k = 0;
		  if(lasti >= 0 && !(i-k > lasti)){
		    printf("\nmap1:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel1[i,i-k]=%d,%d,HapSite[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel1[i],Hdel1[i-k],HapSite[i],HapSite[i-k]);
		    int K = map1[MD][i-k];
		    printf("    I=%d,K=%d:Hcuts1[i]=%0.4f,Y1[I]=%0.4f,Hcuts1[i-k]=%0.4f,Y1[K]=%0.4f\n",
			   I,K,Hcuts1[i],I < 0 ? -1.0 : Y1[I],Hcuts1[i-k], K < 0 ? -1.0 : Y1[K]);
		    if(VERB){
		      for(int j = 1; j <= M; j++){
			int i = map1[m][j];
			if(i < 0)
			  continue;
			int k = mapK1[m][j];
			printf("\t j=%d:map1[m][j]=%d,mapK1[m][j]=%d\n",j,i,k);
		      }
		    }
		    fflush(stdout);
		    assert(i-k > lasti);
		  }

		  lasti = i;
		  lastk = k;
		  lastJ = J;
		}
	      }

	      lastJ = -1, lasti = -1, lastk = -1;
	      for(int J = 1; J <= M; J++){
                if((i = map2[m][J]) > 0 && (I = map2[MD][i]) > 0){
		  k = mapK2[m][J];
		  assert(0 <= k && k < i);
		  if(k > 0 && map2[MD][i-k] < 0)/* locally "clean up" mapK */
		    k = 0;
		  if((lasti >= 0 && !(i-k > lasti))){
		    int K = map2[MD][i-k];
		    printf("\nmap2:m=%d,J=%d,i=%d,k=%d,I=%d,K=%d:lastJ=%d,lasti=%d,lastk=%d:Hdel2[i,i-k]=%d,%d,HapSite[i,i-k]=%d,%d\n",m,J,i,k,I,K,lastJ,lasti,lastk,Hdel2[i],Hdel2[i-k],HapSite[i],HapSite[i-k]);
		    if(VERB){
		      for(int j = 1; j <= M; j++){
			int i = map2[m][j];
			if(i < 0)
			  continue;
			int k = mapK2[m][j];
			printf("\t j=%d:map2[m][j]=%d,mapK2[m][j]=%d\n",j,i,k);
		      }
		    }
		    fflush(stdout);
		    assert(i-k > lasti);
		  }
		  lasti = i;
		  lastk = k;
		  lastJ = J;
		}
	      }
	    }
	  }

	  if(!FILTER_STOP && HAPFILTER_FIX >= 1 && (origIndelCnt != IndelCnt || origSNPcnt != SNPcnt)){// NEW26 :need to re-try deleting HapIndels AND rerun repositionH() to avoid slowdown due to poorly aligned molecules

	   if(!HINDELITER(iter)){// NEW76
	     if(DEBUG>=1+RELEASE) assert(checkHapSite);
	     /* instead force HapIndel rescoring in next iteration */
	     HapIndelDelSkipcnt = 0;
	   } else {

	    HapIndelDelIter = iter;

	    if(SETLIMIT_CACHE)
	      for(int m = 0; m < MD; m++)
		limit1[m].ileft = limit2[m].ileft = -1;// cannot rely on previous cache

	    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */

	    // NEW55
	    int startOutlierType = OutlierType;
	    double startOutlierLambda = outlierLambda;
	    double startPoutlier = Poutlier;
	    double startPoutlierEnd = PoutlierEnd;
	    double startLRbias = LRbias;
	    double startSF = SF[0];
	    double startSR = SR[0];

	    if(IndelScore){ /* NEW55 : adjust outlierLambda, OutlierType, Poutlier, PoutlierEnd and LRbias (if specified by -IndelScore) */
	      if(IndelDelOutlierLambda != 0.0)
		outlierLambda = IndelDelOutlierLambda;
	      if(IndelDelOutlierType != -1)
		OutlierType = IndelDelOutlierType;
	      if(IndelDelPoutlier >= 0.0)
		Poutlier = IndelDelPoutlier;
	      if(IndelDelPoutlierEnd >= 0.0)
		PoutlierEnd = IndelDelPoutlierEnd;
	      if(IndelDelLRbias != 0.0)
		LRbias = IndelDelLRbias;
	      if(MinSFIndelDel != 0.0)
		SF[0] = max(origSF, MinSFIndelDel);
	      if(MinSRIndelDel != 0.0)
		SR[0] = max(origSR, MinSFIndelDel);

	      if(OutlierType != startOutlierType || outlierLambda != startOutlierLambda || Poutlier != startPoutlier || PoutlierEnd != startPoutlierEnd || LRbias != startLRbias ||
		 SF[0] != startSF || SR[0] != startSR){
		if(VERB>=2){
		  printf("Calling hprobeval() after switching parameters PoutlierEnd etc\n");
		  fflush(stdout);
		}
		double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				       TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      
		if(VERB/* HERE >=2 */){
		  printf("Switched OutlierType=%d to %d,Lambda=%0.2e->%0.2e,Poutlier=%0.2e->%0.2e,PoutlierEnd=%0.2e->%0.2e,LRbias=%0.2e->%0.2e,SF=%0.3f->%0.3f,SR=%0.3f->%0.3f: LP= %0.8f -> %0.8f, SNPs=%d, Indels=%d: Cum wall time= %0.6f\n",
			 startOutlierType,OutlierType,startOutlierLambda,outlierLambda,startPoutlier,Poutlier,startPoutlierEnd,PoutlierEnd,startLRbias,LRbias,startSF,SF[0],startSR,SR[0],newLP, nLP, SNPs, Indels, wtime());
		  fflush(stdout);
		}
		newLP = nLP;
		SNPcnt = SNPs;
		IndelCnt = Indels;

		/* swap newLPA,bestLPA */
		double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;
		tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;
	      }
	    } else {/* ! IndelScore */

	      newLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    }

	    double orig_newLP = newLP;
	    double wstart = wtime();

	    if(VERB){
	      printf("Scoring and trying to remove compound Indels: HapSiteConf= %0.2f, HapIndelConf= %0.2f, LP=%0.6f, SNPs=%d, Indels=%d: elapsed wall time=%0.6f\n", 
		     -logHapSitePvalue/log(10.0), -logHapIndelPvalue/log(10.0),orig_newLP, SNPs, Indels, wstart);
	      fflush(stdout);
	    }

	    for(int i = 0; i <= n; i++){
	      if(i <= 0 || HapSite[i] == 3){
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;

		/* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
		double sum = 0.0, abssum = 0.0;
		for(int t = i; t < RR; t++){
		  sum += HapDelta[t];
		  abssum += fabs(HapDelta[t]);
		}
		if(abssum < MIN_INDEL_SIZE)
		  abssum = sum = 0.0;
		else if(fabs(sum) < MIN_INDEL_SIZE)
		  sum = copysign(MIN_INDEL_SIZE,sum);
		
		for(int t = i; t < RR; t++)
		  HapDeltaMerged[t] = sum;

		if(abssum == 0.0){
		  for(int t = i; t < RR; t++)
		    HapDeltaScore[t] = 0.0;
		  continue;
		}

		double origHapDelta = HapDelta[i];

		if(1){

		  /* try to remove each Haplotype group HapDelta[i..RR-1] by calling hprobeval() and update the corresponding HapDeltaScore[] values */
		  memcpy(&prevHapDelta[i],&HapDelta[i],(RR-i)*sizeof(double));
		  memcpy(&prevDelta[i],&Delta[i],(RR-i)*sizeof(double));
		  if(HAPINDELDELETE_FIX)
		    memcpy(&prevHapSite[i+1],&HapSite[i+1],(RR-i-1)*sizeof(int));

		  if(VERB>=1+RELEASE/* HERE >=2 */){
		    printf("Testing removal of HapIndel[%d..%d] = %0.6f (Hcuts= %0.4f .. %0.4f)\n", i, RR, HapDeltaMerged[i],Hcuts[i],Hcuts[RR]);
		    fflush(stdout);
		  }

		  double bestLP = newLP - BigPen, nLP;
		  int bestAllele = 3;
		  int bestSNPs = SNPcnt, bestIndels = IndelCnt;

		  for(int t = i; t < RR; t++)
		    HapDelta[t] = 0.0;

		  int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
		  if(err){
		    if(VERB>=1+RELEASE/* HERE >=2 */){
		      printf("Averaged removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
		      fflush(stdout);
		    }
		    bestAllele = -1;
		  } else {
		    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    if(VERB/* HERE >=2 */){
		      printf("Averaged removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs = %d, Indels=%d: wtime= %0.6f\n", 
			     i, RR, HapDeltaMerged[i], nLP, nLP > newLP ? '!':' ',nLP-newLP, SNPs, Indels,wtime());
		      fflush(stdout);
		    }
		    bestLP = nLP;
		    bestSNPs = SNPs;
		    bestIndels = Indels;
		    if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){
		      /* swap newLPA and bestLPA */
		      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		    }
		  }

		  /* next try changing only Allele 1 */
		  for(int t = i; t < RR; t++)
		    Delta[t] = prevDelta[t] - prevHapDelta[t];
		  if(HAPINDELDELETE_FIX){ // need to also change HapSite[i+1..RR-1] to match Allele 2 : HapSite 1 -> 0, 2 -> 3 
		    for(int t = i+1; t < RR; t++){
		      if(HapSite[t] == 1)
			HapSite[t] = 0;
		      else if(HapSite[t] == 2)
			HapSite[t] = 3;
		    }
		    for(int t = RR; --t > i;){
		      if(!HapSite[t]){
			Delta[t-1] += Delta[t];
			Delta[t] = 0.0;
		      }
		    }
		  }

		  err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
		  if(err){
		    if(VERB>=1+RELEASE/* HERE >=2 */){
		      printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
		      fflush(stdout);
		    }
		  } else {
		    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    if(VERB/* HERE >=2 */){
		      printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
			     i,RR,HapDeltaMerged[i], nLP, nLP > max(bestLP,newLP) ? '!':' ', nLP - newLP, SNPs,Indels,wtime());
		      fflush(stdout);
		    }
		    if(nLP > bestLP || bestAllele == -1){
		      bestLP = nLP;
		      bestSNPs = SNPs;
		      bestIndels = Indels;
		      bestAllele = 1;
		      if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
			double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
			tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		      }
		    }
		  }

		  /* next try changing only Allele 2 */
		  for(int t = i; t < RR; t++)
		    Delta[t] = prevDelta[t] + prevHapDelta[t];
		  if(HAPINDELDELETE_FIX){	      // need to also change HapSite[i+1..RR-1] to match Allele 1 : HapSite 1 -> 3, 2 -> 0 
		    for(int t = i+1; t < RR; t++){
		      HapSite[t] = prevHapSite[t];
		      if(HapSite[t] == 1)
			HapSite[t] = 3;
		      else if(HapSite[t] == 2)
			HapSite[t] = 0;
		    }
		    for(int t = RR; --t > i;){
		      if(!HapSite[t]){
			Delta[t-1] += Delta[t];
			Delta[t] = 0.0;
		      }
		    }
		  }

		  err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
		  if(err){
		    if(VERB>=1+RELEASE/* HERE >=2 */){
		      printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
		      fflush(stdout);
		    }
		  } else {
		    //		    rverb = 0;// ((i==40956 && RR==40991) || (i==41391 && RR==41431)) ? 1 : 0;
		    if(VERB && rverb){
		      printf("After Allele2 only removal of HapIndel[%d..%d] = %0.6f\n",i,RR,HapDeltaMerged[i]);
		      fflush(stdout);
		    }

		    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		    rverb = 0;
		    if(VERB/* HERE >=2 */){
		      printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
			     i,RR,HapDeltaMerged[i], nLP, nLP > max(bestLP,newLP) ? '!':' ', nLP - newLP, SNPs,Indels,wtime());
		      fflush(stdout);
		    }
		    if(nLP > bestLP || bestAllele == -1){
		      bestLP = nLP;
		      bestSNPs = SNPs;
		      bestIndels = Indels;
		      bestAllele = 2;

		      if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
			double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
			tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
		      }
		    }
		  }

		  HapDeltaScore[i] = newLP - bestLP;

		  if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* confirm change & swap newLPA and bestLPA */
		    if(VERB){
		      printf("Removed HapDelta[%d..%d]= %0.4f .. %0.6f = %0.6f (HapDelta[i]=%0.6f): LP=%0.6f -> %0.6f, IndelCnt=%d -> %d, SNPs=%d\n", 
			     i,RR, Hcuts[i],Hcuts[RR],HapDeltaMerged[i], origHapDelta, newLP, bestLP, IndelCnt, bestIndels, bestSNPs);
		      fflush(stdout);
		    }
		    if(DEBUG) assert(bestAllele != -1);
		
		    hapdeltacnt++;// this is a change that might trigger additional changes.

		    if(DELTA_STOP){/* activate intervals overlapping this HapIndel + DELTA_SCAN neighboring intervals */
		      DELTA_INTERVAL = (Hcuts[(Rfrozen ? Rfrozen : n+1)] - Hcuts[Lfrozen]) / maxIN;
		      int IN1 = floor((Hcuts[i] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) - DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		      int IN2 = floor((Hcuts[RR] - Hcuts[Lfrozen])/DELTA_INTERVAL + 0.5) + DELTA_SCAN;/* index into Initial_Delta[] and DELTA_RANGE[] */
		      IN1 = max(0, IN1);
		      IN2 = min(maxIN, IN2);
		      if(DEBUG &&  !(0 <= IN1 && IN1 <= maxIN)){
			printf("After removing HapDelta[%d..%d]= %0.6f(%0.6f,%0.6f): IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			       i,RR,HapDeltaMerged[i],Hcuts[i],Hcuts[RR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
			fflush(stdout);
			assert(0 <= IN1 && IN1 <= maxIN);
		      }
		      if(DEBUG &&  !(0 <= IN2 && IN2 <= maxIN)){
			printf("After removing HapDelta[%d..%d]= %0.6f(%0.6f,%0.6f): IN1=%d,IN2=%d,maxIN=%d,Hcuts[Lfrozen=%d]=%0.6f,Hcuts[Rfrozen=%d]=%0.6f,DELTA_INTERVAL=%0.6f\n",
			       i,RR,HapDeltaMerged[i],Hcuts[i],Hcuts[RR],IN1,IN2,maxIN,Lfrozen,Hcuts[Lfrozen],Rfrozen,Hcuts[(Rfrozen ? Rfrozen : n+1)],DELTA_INTERVAL);
			fflush(stdout);
			assert(0 <= IN2 && IN2 <= maxIN);
		      }
		      if(DEBUG) assert(IN1 <= IN2);
		  
		      int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);

		      int origactivecnt = activecnt;

		      for(int T = max(0, IN1); T <= min(maxIN, IN2); T++){
			if(DELTA_RANGE[T] <= 0){
			  activecnt++;
			  DELTA_RANGE[T] = min_DELTA;
			  for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
			    Initial_Delta[T][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;
			  if(HAPSTOP_DEBUG){
			    printf("Activating region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f with IDelta[%d]=%0.3f..%0.3f due to Removal of HapDelta[%d..%d] = %0.6f at Hcuts=%0.4f..%0.4f\n",
				   T, (T - 0.5) * DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
				   DELTA_RANGE[T],Initial_Delta[T][0], Initial_Delta[T][DELTA_RANGE[T]-1],i, RR, HapDeltaMerged[i], Hcuts[i], Hcuts[RR]);
			    fflush(stdout);
			  }
			} else if(HAPSTOP_DEBUG){
			  printf("Region T=%d (%0.3f..%0.3f) at %0.3f .. %0.3f already active after Removal of HapDelta with IDelta[%d]=%0.3f .. %0.3f\n",
				 T, (T - 0.5)* DELTA_INTERVAL, (T + 0.5) * DELTA_INTERVAL, (T - 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen], (T + 0.5) * DELTA_INTERVAL + Hcuts[Lfrozen],
				 DELTA_RANGE[T], Initial_Delta[T][0],Initial_Delta[T][DELTA_RANGE[T]-1]);
			  fflush(stdout);
			}
		      }

		      if(VERB && activecnt > origactivecnt){
			if(VERB>=2){
			  int inactivecnt = 0;
			  for(int IN = 0; IN <= maxIN; IN++)
			    if(DELTA_RANGE[IN] <= 0)
			      inactivecnt++;

			  printf("Activated %d/%d intervals due to Removal of HapDelta[%d..%d] = %0.6f at Hcuts=%0.4f..%0.4f : inactive intervals= %d/%d\n",
				 activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, RR, HapDeltaMerged[i], Hcuts[i], Hcuts[RR], inactivecnt, maxIN+1);
			} else
			  printf("Activated %d/%d intervals due to Removal of HapDelta[%d..%d] = %0.6f at Hcuts=%0.4f..%0.4f\n",
				 activecnt-origactivecnt,min(maxIN, IN2)-max(0,IN1)+1, i, RR, HapDeltaMerged[i], Hcuts[i], Hcuts[RR]);
			fflush(stdout);
		      }
		    }

		    newLP = bestLP;
		    IndelCnt = bestIndels;
		    SNPcnt = bestSNPs;
		    for(int t = i; t < RR; t++)
		      HapDeltaMerged[t] = 0.0;
		    if(bestAllele != 2){
		      if(bestAllele == 1){
			for(int t = i; t < RR; t++)
			  Delta[t] = prevDelta[t] - prevHapDelta[t];
			if(HAPINDELDELETE_FIX){
			  for(int t = i+1; t < RR; t++){
			    HapSite[t] = prevHapSite[t];
			    if(HapSite[t] == 1)
			      HapSite[t] = 0;
			    else if(HapSite[t] == 2)
			      HapSite[t] = 3;
			  }
			  for(int t = RR; --t > i;){
			    if(!HapSite[t]){
			      Delta[t-1] += Delta[t];
			      Delta[t] = 0.0;
			    }
			  }
			}
		      } else {
			for(int t = i; t < RR; t++)
			  Delta[t] = prevDelta[t];
			if(HAPINDELDELETE_FIX)
			  for(int t = i+1; t < RR; t++)
			    HapSite[t] = prevHapSite[t];
		      }
		    }

		    if(DEBUG>=2){/* verify LP is now equal to newLP */
		      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		      double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					      TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		      if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) ||VERB/* HERE >=2 */){
			if(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt)
			  printf("\t After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);		    
			else
			  printf("WARNING: After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);
			fflush(stdout);
			if(DEBUG>=1+RELEASE) assert(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt);
		      }
		      if(DEBUG){/* verify full LP */
			double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					      TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2, 0, 0, 0.0, 0.0, 0.0, 0.0, 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
			if(!(fabs(LP - newLP) < 1e-6 && SNPs == SNPcnt && Indels == IndelCnt)){
			  printf("WARNING: After switching to Allele=%d: LP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,LP,newLP,LP-newLP, SNPs, Indels);
			  for(int m = 0; m < MD; m++){
			    if(fabs(testLPA1[m] - bestLPA1[m]) > 1e-6)
			      printf("m=%d:qLPA1[m]= %0.8f, fLPA1[m]= %0.8f (err=%0.8f)\n",m, bestLPA1[m],testLPA1[m],bestLPA1[m]-testLPA1[m]);
			    if(fabs(testLPA2[m] - bestLPA2[m]) > 1e-6)
			      printf("m=%d:qLPA2[m]= %0.8f, fLPA2[m]= %0.8f (err=%0.8f)\n",m, bestLPA2[m],testLPA2[m],bestLPA2[m]-testLPA2[m]);
			  }
			  fflush(stdout);
			  //		    assert(fabs(LP - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt); // this happens with id17 in NA12878A_*r4632/output/contigs/exp_refineFinal1/
			}
			newLP = LP;
			IndelCnt = Indels;
			SNPcnt = SNPs;

			/* swap testLPA and bestLPA */
			double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
			tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;
		      }
		    }
		  } else { /* restore original HapDelta */
		    memcpy(&HapDelta[i],&prevHapDelta[i], (RR - i)*sizeof(double));
		    memcpy(&Delta[i],&prevDelta[i],(RR-i)*sizeof(double));
		    if(HAPINDELDELETE_FIX)
		      memcpy(&HapSite[i+1],&prevHapSite[i+1],(RR-i-1)*sizeof(int));

		    if(DEBUG>=2){
		      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
		      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
		      if(VERB>=3 || fabs(nLP - newLP) > 1e-6 || SNPcnt != SNPs || IndelCnt != Indels){
			printf("WARNING:After restoring HapDelta[%d..%d]= %0.4f: nLP=%0.8f, expected newLP=%0.8f (err=%0.8f), SNPs=%d,Indels=%d\n",i,RR,HapDeltaMerged[i], nLP,newLP,nLP-newLP,SNPs,Indels);
			fflush(stdout);
			//		  assert(fabs(nLP-newLP) < 1e-5);
			assert(nLP > orig_newLP - 1e-6);
		      }
		      SNPcnt = SNPs;
		      IndelCnt = Indels;
		    }
		  }

		  for(int t = i+1; t < RR; t++)
		    HapDeltaScore[t] = HapDeltaScore[i];
		} // rescale HapDeltaScore[]

		if(VERB>=2){
		  double DeltaSum = 0.0;
		  for(int t = i; t < RR;t++)
		    DeltaSum += Delta[t];
		  printf("L=%d,R=%d:HapSite[L,R]=%d,%d,Hcuts[L]=%0.4f,Hcuts[L,R]=%0.4f,Delta[L,R]=%0.4f,HapDelta[L]=%0.4f(tot=%0.4f),HapDeltaScore=%0.2f\n",
			 i,RR,HapSite[i],HapSite[RR],Hcuts[i],Hcuts[RR]-Hcuts[i],DeltaSum,HapDelta[i],HapDeltaMerged[i],HapDeltaScore[i]);
		  fflush(stdout);
		}
	      }
	    }// for int i = 0 .. n 

	    if(DEBUG/* HERE >=2 */){/* verify full LP */
	      double wt1 = wtime();
	      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB || nLP < newLP - 1e-6 || IndelCnt != Indels || SNPcnt != SNPs){
		double wt2 = wtime();
		printf("%sAfter computing HapDeltaScore[]: nLP=%0.6f(SNPs=%d,Indels=%d), expected newLP= %0.6f (err=%0.6f), orig LP=%0.6f, SNPcnt=%d,IndelCnt=%d: wall time=%0.6f(cum=%0.6f)\n",
		       (nLP < newLP - 1e-5 || IndelCnt != Indels || SNPcnt != SNPs) ? "WARNING: " : "" , nLP,SNPs, Indels, newLP,nLP-newLP,orig_newLP, SNPcnt,IndelCnt, wt2-wt1,wt2);
		fflush(stdout);
		//	  assert( nLP < newLP - 1e-5);
		//    assert(nLP >= orig_newLP - 1e-6);
	      }

	      newLP = nLP;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;

	      /* swap newLPA and bestLPA */
	      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	    }

	    if(OutlierType != startOutlierType || Poutlier != startPoutlier || PoutlierEnd != startPoutlierEnd || outlierLambda != startOutlierLambda || LRbias != startLRbias){// NEW55
	      OutlierType = startOutlierType;
	      Poutlier = startPoutlier;
	      PoutlierEnd = startPoutlierEnd;
	      outlierLambda = startOutlierLambda;
	      LRbias = startLRbias;
	      SF[0] = startSF;
	      SR[0] = startSR;

	      if(VERB>=2){
		printf("Calling hprobeval() after restoring parameters PoutlierEnd etc\n");
		fflush(stdout);
	      }
	      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				     TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(VERB/* HERE >=2 */){
		printf("Restored OutlierType=%d, Lambda=%0.2e, Poutlier=%0.2e, PoutlierEnd=%0.2e, LRbias= %0.2e, sf= %0.3f, sr= %0.5f: LP= %0.8f -> %0.8f, SNPs=%d, Indels=%d: Cum wall time= %0.6f\n",
		       OutlierType,outlierLambda,Poutlier,PoutlierEnd,LRbias,SF[0],SR[0],newLP, nLP, SNPs, Indels, wtime());
		fflush(stdout);
	      }

	      newLP = nLP;
	      SNPcnt = SNPs;
	      IndelCnt = Indels;
	  
	      /* swap newLPA,bestLPA */
	      double *tmp = bestLPA1; bestLPA1 = newLPA1; newLPA1 = tmp;
	      tmp = bestLPA2; bestLPA2 = newLPA2; newLPA2 = tmp;
	      
	      // NEW137 : update LPhwm etc
	      LPhwm = newLP;
	      LPdrop_count = 0;
	      if(HAP_INDEL_SKIP_FIX)
		HapIndelDelSkipcnt = 0;
	    }
           } /* else if HINDELITER(iter) */
	  } // if(HAPFILTER_FIX ...)

	  if(HapEndTrim > 0.0 && (IndelCnt > 0 || SNPcnt > 0)){
	    int TrimL1 = 0, TrimL2 = 0, TrimR1 = n+1, TrimR2 = n+1;

	    int origIndelCnt = IndelCnt;
	    int origSNPcnt = SNPcnt;

	    /* update nmap[], bestLPA1,bestLPA2 after filtering unphased SNPs */
	    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	    hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			    TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,2);

	    if(VERB){
	      printf("Before Trimming Allele ends based on coverage: (IndelCnt=%d,SNPcnt=%d,imin=%d,imax=%d,n=%d): LP=%0.6f -> %0.6f ( delta=%0.6f), Indels=%d, SNPs=%d\n",
		     IndelCnt,SNPcnt,imin,imax,n,newLP, hLP, hLP - newLP, Indels, SNPs);
	      if(VERB>=2){
		int hap = 0;
		double cumDelta = Delta[0];
		for(int i = 1; i <= n; i++){
		  if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
		    printf("i=%d:HapSite[i]=%d,Delta[i]=%0.4f,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f(cumDelta=%0.4f),HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
			   i,HapSite[i],Delta[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],cumDelta,HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
		  if(hap && HapSite[i]==3)
		    hap = 0;
		  if(HapDelta[i])
		    hap = 1;
		}
	      }
	      if(VERB>=2){
		for(int m = 0; m < MD; m++){
		  if(m != 163)
		    continue;
		  int M = MX[m];
		  printf("m=%d:M=%d,map1[m],mapK1[m]:\n",m,M);
		  for(int j = 1; j <= M; j++){
		    int i = map1[m][j];
		    if(i < 0)
		      continue;
		    int k = mapK1[m][j];
		    printf("\t j=%d:map1[m][j]=%d(HS=%d),mapK1[m][j]=%d(HS=%d)\n",j,i,HapSite[i],k,(k < 0) ? -1 : HapSite[i-k]);
		  }
		}
		for(int m = 0; m < MD; m++){
		  if(m != 163)
		    continue;
		  int M = MX[m];
		  printf("m=%d:M=%d,map2[m],mapK2[m]:\n",m,M);
		  for(int j = 1; j <= M; j++){
		    int i = map2[m][j];
		    if(i < 0)
		      continue;
		    int k = mapK2[m][j];
		    printf("\t j=%d:map2[m][j]=%d(HS=%d),mapK2[m][j]=%d(HS=%d)\n",j,i,HapSite[i],k,(k < 0) ? -1 : HapSite[i-k]);
		  }
		}
	      }
	      fflush(stdout);
	    }
	    newLP = hLP;
	    SNPcnt = SNPs;
	    IndelCnt = Indels;

	    /* re-compute covA[],covB[],covC[] */
	    for(int i = 0; i <= n+1; i++)
	      covA[i] = covB[i] = covC[i] = 0.0;

	    double cnt1 = 0, cnt2 = 0, cnt3 = 0;
	    for(int m = 0; m < MD; m++){
	      double LP1 = bestLPA1[m];
	      double LP2 = bestLPA2[m];
	      pcontig->MapPhase[m] = 1.0/(1.0 + exp(LP2-LP1));

	      double LP12 = newLPA[m];
	      double wt = MapWeight[m] = TBmapWT[m] * (1.0 - LRbias * exp(-LP12));
	      if(wt <= 0.0)
		continue;

	      int M = MX[m];
	      //    double *XM = X[m];
	      int mapid = pcontig->contig[m].mapid;
	      if(DEBUG) assert(0 <= mapid && mapid < nummaps);
	      Cmap *pmap = gmap[mapid];
	      if(DEBUG) assert(pmap->numsite[0] == M);
	      //	      int flip = pcontig->flip[m];

	      int I,K,J;
	      int *nmapM, *nmapKM;

	      int iL1 = -1,iR1 = n+1,iL2 = -1,iR2 = n+1;
	      nmapM = nmap1[m];
	      nmapKM = nmapK1[m];
	      for(J = 1;J <= M; J++){
		if((I=nmapM[J]) > 0){
		  K = nmapKM[J];
		  if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N1);
		  iL1 = nmap1[MD][I-K];
		  if(DEBUG) assert(1 <= iL1 && iL1 <= n);
		  break;
		}
	      }
	      if(J > M){
		if(VERB >= 2){
		  printf("WARNING:m=%d,M=%d,n=%d:No alignment with nmap1[],nmapK1[] found : LP1=%0.8e,LP2=%0.8e,LP12=%0.8e : wt= %0.6f, MapPhase[m] = %0.6f\n",
			 m,M,n,LP1,LP2,LP12,wt,pcontig->MapPhase[m]);
		  fflush(stdout);
		}
		iL1 = iR1 = -1;
	      }
	    //	      if(DEBUG) assert(J <= M);
      
	      for(J = M; J >= 1; J--){
		if((I=nmapM[J]) > 0){
		  if(DEBUG) assert(1 <= I && I <= N1);
		  iR1 = nmap1[MD][I];
		  if(DEBUG) assert(iL1 <= iR1 && iR1 <= n);
		  break;
		}
	      }
	      if(DEBUG && iL1 > 0) assert(J >= 1);

	      nmapM = nmap2[m];
	      nmapKM = nmapK2[m];
	      for(J = 1;J <= M; J++){
		if((I=nmapM[J]) > 0){
		  K = nmapKM[J];
		  if(DEBUG) assert(K >= 0 && 1 <= I-K && I <= N2);
		  iL2 = nmap2[MD][I-K];
		  if(DEBUG) assert(1 <= iL2 && iL2 <= n);
		  break;
		}
	      }
	      if(J > M){
		if(VERB >= 2){
		  printf("WARNING:m=%d,M=%d,n=%d:No alignment with nmap2[],nmapK2[] found: LP1=%0.8e, LP2=%0.8e, LP12=%0.8e : wt= %0.6f, MapPhase[m] = %0.6f\n",
			 m,M,n, LP1, LP2, LP12, wt, pcontig->MapPhase[m]);
		  fflush(stdout);
		}
		iL2 = iR2 = -1;
	      }
	    //	      if(DEBUG) assert(J <= M);
      
	      for(J = M; J >= 1; J--){
		if((I=nmapM[J]) > 0){
		  if(DEBUG) assert(1 <= I && I <= N2);
		  iR2 = nmap2[MD][I];
		  if(DEBUG) assert(iL2 <= iR2 && iR2 <= n);
		  break;
		}
	      }
	      if(DEBUG && iL2 > 0) assert(J >= 1);

	      if(iL1 < 0 || iL2 < 0)
		continue;// NEW NEW

	      if(pcontig->MapPhase[m] > HapAlleleProb){/* Add MapWeight[m] to allele A's coverage (based on allignment to Allele A) */
		cnt1 += wt;
		for(int i = iL1; i <= iR1; i++)
		  covA[i] += wt;
		if(VERB>=4 && iR1 >= 2700){
		  printf("m=%d:Phase=%0.6f,LP1=%0.6f,LP2=%0.6f:iL1=%d,iR1=%d,iL2=%d,iR2=%d:Hcuts[iL1..iR1]=%0.3f..%0.3f,covA[] += wt = %0.6f\n",
			 m,pcontig->MapPhase[m],LP1,LP2,iL1,iR1,iL2,iR2,Hcuts[iL1],Hcuts[iR1],wt);
		  fflush(stdout);
		}
	      } else if(pcontig->MapPhase[m] < 1.0-HapAlleleProb){/* Add MapWeight[m] to allele B's coverage (based on allignement to Allele B) */
		cnt2 += wt;
		for(int i = iL2; i <= iR2; i++)
		  covB[i] += wt;
		if(VERB>=4 && iR2 >= 2700){
		  printf("m=%d:Phase=%0.6f,LP1=%0.6f,LP2=%0.6f:iL1=%d,iR1=%d,iL2=%d,iR2=%d:Hcuts[iL2..iR2]=%0.3f..%0.3f, covB[] += wt = %0.6f\n",
			 m,pcontig->MapPhase[m],LP1,LP2,iL1,iR1,iL2,iR2,Hcuts[iL2],Hcuts[iR2],wt);
		  fflush(stdout);
		}
	      } else {/* Add MapWeight[m] to catch-all C's coverage (half each based on alignment to Allele A and B) */
		cnt3 += wt;
		if(VERB>=4 && (iR1 >= 2700 || iR2 >= 2700)){
		  printf("m=%d:Phase=%0.6f,LP1=%0.6f,LP2=%0.6f:iL1=%d,iR1=%d,iL2=%d,iR2=%d:covC[] += 0.5 * wt, wt = %0.6f\n",
			 m,pcontig->MapPhase[m],LP1,LP2,iL1,iR1,iL2,iR2,wt);
		  fflush(stdout);
		}
		wt *= 0.5;
		for(int i = iL1; i <= iR1; i++)
		  covC[i] += wt;
		for(int i = iL2; i <= iR2; i++)
		  covC[i] += wt;
	      }
	    }

	    if(VERB>=4){
	      printf("MD=%d,wtsumA=%0.1f,wtsumB=%0.1f,wtsumC=%0.1f,Hcuts[n+1]=%0.3f,N1=%d,N2=%d\n",MD,cnt1,cnt2,cnt3,Hcuts[n+1],N1,N2);
	      for(int i = 1; i <= n; i++){
		if(!HapSite[i])
		  continue;
		printf("i=%d/%d:covA[i]=%0.2f,covB[i]=%0.2f,covC[i]=%0.2f,Hcuts=%0.3f,Delta=%0.3f,HapDelta=%0.3f,Hcuts1=%0.3f,Hcuts2=%0.3f,HapSite[i]=%d\n",
		       i,n,covA[i],covB[i],covC[i],Hcuts[i],Delta[i],HapDelta[i],Hcuts1[i],Hcuts2[i],HapSite[i]);
	      }
	      fflush(stdout);
	    }
	    
	    //	    int origN1 = N1, origN2 = N2;

	    memcpy(&prevHapDelta[0],&HapDelta[0],(n+1)*sizeof(double));
	    memcpy(&prevDelta[0],&Delta[0],(n+1)*sizeof(double));
	    memcpy(&prevHapSite[0],&HapSite[0],(n+1)*sizeof(int));

	    int block = 1;
	    while(block < 16 && MD > numthreads * block)
	      block *= 2;

	    /* need to backup map1[],map2[] */
#pragma omp parallel for schedule(static,block) num_threads(numthreads)
	    for(int m = 0; m < MD; m++){
              int M = MX[m];
	      memcpy(map1b[m],map1[m],(M+2)*sizeof(int));
	      memcpy(map2b[m],map2[m],(M+2)*sizeof(int));
	      memcpy(mapK1b[m],mapK1[m],(M+2)*sizeof(int));
	      memcpy(mapK2b[m],mapK2[m],(M+2)*sizeof(int));
            }
	    int remapped = 0;

	    /* trim ends of Allele A until first Label Hcuts[i] with HapEndTrim < (covA[i] + m) * (covA[i]+covB[i]+covC[i] + 2m)/(covA[i]+covB[i] + 2m) - m */
	    /* trim ends of Allele B until first Label Hcuts[i] with HapEndTrim < (covB[i] + m) * (covA[i]+covB[i]+covC[i])/(covA[i]+covB[i] + 2m) - m, where m == HapEndTrimMin */

	    /* First trim from left end */
	    int cntA = 0, cntB = 0;
	    double maxA = 0.0, maxB = 0.0;
	    for(int i = 1; i < n; i++){
	      if(!HapSite[i])
		continue;
	      double covScale = (covA[i]+covB[i]+covC[i] + 2.0*HapEndTrimMin)/(covA[i]+covB[i] + 2.0*HapEndTrimMin);
	      double trimA = (covA[i]+HapEndTrimMin)*covScale - HapEndTrimMin;
	      double trimB = (covB[i]+HapEndTrimMin)*covScale - HapEndTrimMin;
	      if(VERB>=3){
		printf("i=%d/%d:covA[i]=%0.2f,covB[i]=%0.2f,covC[i]=%0.2f,Hcuts1=%0.3f,Hcuts2=%0.3f:TrimA=%0.2f,TrimB=%0.2f,maxA=%0.2f,maxB=%0.2f,cntA=%d,cntB=%d,HapEndTrim=%0.2f,%0.2f\n",
		       i,n,covA[i],covB[i],covC[i],Hcuts1[i],Hcuts2[i],trimA,trimB,maxA,maxB,cntA,cntB,HapEndTrim,HapEndTrimMin);
		fflush(stdout);
	      }
	      double HapEndThreshA = HapEndTrim;
	      double HapEndThreshB = HapEndTrim;
	      if(HapEndTrimRatio > 0.0){/* check if thresholds should be raised */
		double MaxCov = covScale;
		for(int j = i+1; j <= n; j++){
		  if(!HapSite[j])
		    continue;
		  if(min(Hcuts1[j] - Hcuts1[i], Hcuts2[j] - Hcuts2[i]) > HapEndTrimLen)
		    break;
		  double covScale = (covA[j]+covB[j]+covC[j] + 2.0*HapEndTrimMin)/(covA[j]+covB[j] + 2.0*HapEndTrimMin);
		  double trimA = (covA[j]+HapEndTrimMin)*covScale - HapEndTrimMin;
		  double trimB = (covB[j]+HapEndTrimMin)*covScale - HapEndTrimMin;
		  if(Hcuts1[j] - Hcuts1[i] <= HapEndTrimLen)
		    HapEndThreshA = max(HapEndThreshA, trimA * HapEndTrimRatio);
		  if(Hcuts2[j] - Hcuts2[i] <= HapEndTrimLen)
		    HapEndThreshB = max(HapEndThreshB, trimB * HapEndTrimRatio);
		}
	      }

	      maxA = max(maxA,trimA);
	      maxB = max(maxB,trimB);
	      if(maxA > HapEndThreshA && maxB > HapEndThreshB)
		break;
	      if(maxA <= HapEndThreshA){
		if(VERB>=2 && (HapSite[i] & 1)){
		  printf("Trimming off left end Allele1 label i=%d/%d:covA[i]=%0.2f,covB[i]=%0.2f,covC[i]=%0.2f,Hcuts=%0.3f,%0.3f:Trim=%0.2f,%0.2f,max=%0.2f,%0.2f,cntA=%d,cntB=%d,HapEndTrim=%0.2f,%0.2f,%0.2f,%0.2f,%0.1f,Thresh=%0.2f,%0.2f\n",
			 i,n,covA[i],covB[i],covC[i],Hcuts1[i],Hcuts2[i],trimA,trimB,maxA,maxB,cntA,cntB,HapEndTrim,HapEndTrimMin,HapEndTrimMaxFrac,HapEndTrimRatio,HapEndTrimLen,HapEndThreshA,HapEndThreshB);
		  fflush(stdout);
		}
		cntA += (HapSite[i] & 1) ? 1 : 0;
		HapSite[i] &= ~1;
		TrimL1 = i+1;
	      }
	      if(maxB <= HapEndThreshB){
		if(VERB>=2 && (HapSite[i] & 2)){
		  printf("Trimming off left end Allele2 label i=%d/%d:covA[i]=%0.2f,covB[i]=%0.2f,covC[i]=%0.2f,Hcuts=%0.3f,%0.3f:Trim=%0.2f,%0.2f,max=%0.2f,%0.2f,cntA=%d,cntB=%d,HapEndTrim=%0.2f,%0.2f,%0.2f,%0.2f,%0.1f,Thresh=%0.2f,%0.2f\n",
			 i,n,covA[i],covB[i],covC[i],Hcuts1[i],Hcuts2[i],trimA,trimB,maxA,maxB,cntA,cntB,HapEndTrim,HapEndTrimMin,HapEndTrimMaxFrac,HapEndTrimRatio,HapEndTrimLen,HapEndThreshA,HapEndThreshB);
		  fflush(stdout);
		}
		cntB += (HapSite[i] & 2) ? 1 : 0;
		HapSite[i] &= ~2;
		TrimL2 = i+1;
	      }
	    }
	    
	    /* next trim from right end */
	    maxA = maxB = 0.0;
	    for(int i = n; i > 1; i--){
	      if(!HapSite[i])
		continue;
	      double covScale = (covA[i]+covB[i]+covC[i] + 2.0*HapEndTrimMin)/(covA[i]+covB[i] + 2.0*HapEndTrimMin);
	      double trimA = (covA[i]+HapEndTrimMin)*covScale - HapEndTrimMin;
	      double trimB = (covB[i]+HapEndTrimMin)*covScale - HapEndTrimMin;
	      if(VERB>=3 && i > 1000){
		printf("i=%d,n=%d:covA[i]=%0.2f,covB[i]=%0.2f,covC[i]=%0.2f,Hcuts1=%0.3f,Hcuts2=%0.3f:TrimA=%0.2f,TrimB=%0.2f,maxA=%0.2f,maxB=%0.2f,cntA=%d,cntB=%d,HapEndTrim=%0.2f,%0.2f\n",
		       i,n,covA[i],covB[i],covC[i],Hcuts1[i],Hcuts2[i],trimA,trimB,maxA,maxB,cntA,cntB,HapEndTrim,HapEndTrimMin);
		fflush(stdout);
	      }
	      double HapEndThreshA = HapEndTrim;
	      double HapEndThreshB = HapEndTrim;
	      if(HapEndTrimRatio > 0.0){/* check if thresholds should be raised */
		double MaxCov = covScale;
		for(int j = i-1; j >= 1; j--){
		  if(!HapSite[j])
		    continue;
		  if(min(Hcuts1[i] - Hcuts1[j], Hcuts2[i]-Hcuts2[j]) > HapEndTrimLen)
		    break;
		  double covScale = (covA[j]+covB[j]+covC[j] + 2.0*HapEndTrimMin)/(covA[j]+covB[j] + 2.0*HapEndTrimMin);
		  double trimA = (covA[j]+HapEndTrimMin)*covScale - HapEndTrimMin;
		  double trimB = (covB[j]+HapEndTrimMin)*covScale - HapEndTrimMin;
		  if(Hcuts1[i] - Hcuts1[j] <= HapEndTrimLen)
		    HapEndThreshA = max(HapEndThreshA, trimA * HapEndTrimRatio);
		  if(Hcuts2[i] - Hcuts2[j] <= HapEndTrimLen)
		    HapEndThreshB = max(HapEndThreshB, trimB * HapEndTrimRatio);
		}
	      }

	      maxA = max(maxA,trimA);
	      maxB = max(maxB,trimB);
	      if(maxA > HapEndThreshA && maxB > HapEndThreshB)
		break;
	      if(maxA <= HapEndThreshA){
		if(VERB>=2 && (HapSite[i] & 1)){
		  printf("Trimming off right end Allelel1 label i=%d/%d:covA[i]=%0.2f,covB[i]=%0.2f,covC[i]=%0.2f,Hcuts=%0.3f,%0.3f:Trim=%0.2f,%0.2f,max=%0.2f,%0.2f,cntA=%d,cntB=%d,HapEndTrim=%0.2f,%0.2f,%0.2f,%0.2f,%0.1f,Thresh=%0.2f,%0.2f\n",
			 i,n,covA[i],covB[i],covC[i],Hcuts1[i],Hcuts2[i],trimA,trimB,maxA,maxB,cntA,cntB,HapEndTrim,HapEndTrimMin,HapEndTrimMaxFrac,HapEndTrimRatio,HapEndTrimLen,HapEndThreshA,HapEndThreshB);
		  fflush(stdout);
		}
		cntA += (HapSite[i] & 1) ? 1 : 0;
		HapSite[i] &= ~1;
		TrimR1 = i-1;
	      }

	      if(maxB <= HapEndThreshB){
		if(VERB>=2 && (HapSite[i] & 2)){
		  printf("Trimming off right end Allelel2 label i=%d/%d:covA[i]=%0.2f,covB[i]=%0.2f,covC[i]=%0.2f,Hcuts=%0.3f,%0.3f:Trim=%0.2f,%0.2f,max=%0.2f,%0.2f,cntA=%d,cntB=%d,HapEndTrim=%0.2f,%0.2f,%0.2f,%0.2f,%0.1f,Thresh=%0.2f,%0.2f\n",
			 i,n,covA[i],covB[i],covC[i],Hcuts1[i],Hcuts2[i],trimA,trimB,maxA,maxB,cntA,cntB,HapEndTrim,HapEndTrimMin,HapEndTrimMaxFrac,HapEndTrimRatio,HapEndTrimLen,HapEndThreshA,HapEndThreshB);
		  fflush(stdout);
		}
		cntB += (HapSite[i] & 2) ? 1 : 0;
		HapSite[i] &= ~2;
		TrimR2 = i-1;
	      }
	    }
	    
	    if(cntA || cntB){
	      while(TrimL1 <= n && !HapSite[TrimL1])
		TrimL1++;
	      while(TrimL2 <= n && !HapSite[TrimL2])
		TrimL2++;
	      while(TrimR1 >= 1 && !HapSite[TrimR1])
		TrimR1--;
	      while(TrimR2 >= 1 && !HapSite[TrimR2])
		TrimR2--;

	      if(VERB){
		printf("Trimmed %d of %d labels from ends of Allele1 (keeping Hcuts1[%d..%d]=%0.3f..%0.3f) and %d of %d labels from ends of Allele2 (keeping Hcuts2[%d..%d]=%0.3f .. %0.3f)\n",
		       cntA,N1,TrimL1,TrimR1,Hcuts1[TrimL1],Hcuts1[TrimR1],cntB,N2, TrimL2,TrimR2,Hcuts2[TrimL2],Hcuts2[TrimR2]);
		printf("\t Allele1 molwts= %0.3f, Allele2 molwts= %0.3f, Undecided molwts= %0.3f\n",cnt1,cnt2,cnt3);
		fflush(stdout);
	      }

	      if(cntA > N1 * HapEndTrimMaxFrac || cntA >= N1 || cntB > N2 * HapEndTrimMaxFrac || cntB >= N2){
		if(VERB){
		  printf("Undoing excessing per-Allele trimming (HapEndTrimMaxFrac= %0.3f)\n", HapEndTrimMaxFrac);
		  fflush(stdout);
		}
		memcpy(&HapDelta[0],&prevHapDelta[0],(n+1)*sizeof(double));
		memcpy(&Delta[0],&prevDelta[0],(n+1)*sizeof(double));
		memcpy(&HapSite[0],&prevHapSite[0],(n+1)*sizeof(int));
	      } else {

		/* save trimmed region sizes, in case labels get remapped by HapIndelSpread() */
		HtrimL1 = Hcuts1[TrimL1];
		HtrimL2 = Hcuts2[TrimL2];
		HtrimR1 = Hcuts1[n+1] - Hcuts1[TrimR1];
		HtrimR2 = Hcuts2[n+1] - Hcuts2[TrimR2];

		/* first relocate non-zero Delta[i] and HapDelta[i] values located at HapSite[i] == 0 to nearest site to the left */
		int k = 0;
		for(int t = 1; t <= n; t++){
		  if(HapSite[t]){
		    k = t;
		    continue;
		  }
		  if(Delta[t]){
		    Delta[k] += Delta[t];
		    Delta[t] = 0.0;
		  }
		  if(HapDelta[t]){
		    HapDelta[k] += HapDelta[t];
		    HapDelta[t] = 0.0;
		  }
		}

		/* locate first label on left end with HapSite[i] == 3 and apply HapDeltaSpread() to Hcuts[0..i] */
		int i = 1, err = 0;
		while(i <= n && HapSite[i] != 3)
		  i++;

		//		rverb = (iter >= 61) ? 1 : 0;
		if(VERB && rverb){
		  printf("Calling HapDeltaSpread on Hcuts[0..%d]\n",i);
		  fflush(stdout);
		}
		err = HapDeltaSpread(n,0,i,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap);
		//		rverb = 0;
		if(err){
		  if(VERB){
		    printf("HapDeltaSpread of Hcuts[0..%d] failed: undoing Trimming\n",i);
		    fflush(stdout);
		  }
		  memcpy(&HapDelta[0],&prevHapDelta[0],(n+1)*sizeof(double));
		  memcpy(&Delta[0],&prevDelta[0],(n+1)*sizeof(double));
		  memcpy(&HapSite[0],&prevHapSite[0],(n+1)*sizeof(int));
		}

		if(!err){
		  //		  rverb = (iter >= 61) ? 1 : 0;
		  if(VERB && rverb){
		    printf("remapping map1,map2 due to HapDeltaSpread of Hcuts[0..%d]\n",i);
		    fflush(stdout);
		  }
		  remapped |= correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,0,i,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);
		  //		  rverb = 0;
		}

		if(i <= n && !err){/* locate last label on right end with HapSite[i]==3 and apply HapDeltaSpread() to Hcuts[i..n+1] */
		  i = n;
		  while(i > 0 && HapSite[i] != 3)
		    i--;
		  if(i > 0){
		    //		    rverb = (iter >= 61) ? 1 : 0;
		    if(VERB && rverb){
		      printf("Calling HapDeltaSpread on Hcuts[%d..%d]\n",i,n+1);
		      fflush(stdout);
		    }
                    err = HapDeltaSpread(n,i,n+1,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap);
		    //		    rverb = 0;

		    if(err){
		      if(VERB){
			printf("\t HapDeltaSpread of Hcuts[%d..%d] failed: undoing Trimming\n", i, n+1);
			fflush(stdout);
		      }
		      memcpy(&HapDelta[0],&prevHapDelta[0],(n+1)*sizeof(double));
		      memcpy(&Delta[0],&prevDelta[0],(n+1)*sizeof(double));
		      memcpy(&HapSite[0],&prevHapSite[0],(n+1)*sizeof(int));
		      if(remapped){ /* need to restore map1[],map2[] */
			int block = 1;
			while(block < 16 && MD > numthreads * block)
			  block *= 2;

                        #pragma omp parallel for schedule(static,block) num_threads(numthreads)
                        for(int m = 0; m < MD; m++){
                          int M = MX[m];
			  memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
			  memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
			  memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
			  memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
                        }
			remapped = 0;
		      }
		    } 
		    
		    if(!err){
		      //		      rverb = (iter >= 61) ? 1 : 0;
		      if(VERB && rverb){
			printf("remapping map1,map2 due to HapDeltaSpread of Hcuts[%d..%d]\n",i,n+1);
			fflush(stdout);
		      }
		      remapped |= correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,i,n+1,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);
		      //		      rverb = 0;
		    }
		  }
		}
	      
		if(!err){
		  err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate consensus map pair */
		  if(err){
		    if(VERB){
		      printf("\t hsetmap failed: undoing Trimming\n");
		      fflush(stdout);
		    }
		    memcpy(&HapDelta[0],&prevHapDelta[0],(n+1)*sizeof(double));
		    memcpy(&Delta[0],&prevDelta[0],(n+1)*sizeof(double));
		    memcpy(&HapSite[0],&prevHapSite[0],(n+1)*sizeof(int));
		    if(remapped){ /* need to restore map1[],map2[] */
		      int block = 1;
		      while(block < 16 && MD > numthreads * block)
			block *= 2;

                      #pragma omp parallel for schedule(static,block) num_threads(numthreads)
                      for(int m = 0; m < MD; m++){
                        int M = MX[m];
			memcpy(map1[m],map1b[m],(M+2)*sizeof(int));
			memcpy(map2[m],map2b[m],(M+2)*sizeof(int));
			memcpy(mapK1[m],mapK1b[m],(M+2)*sizeof(int));
			memcpy(mapK2[m],mapK2b[m],(M+2)*sizeof(int));
                      }
		      remapped = 0;
                    }
		  } else {
		    int SNPs2,Indels2;
		    double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
					    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs2,Indels2,0);
		    if(VERB){
		      printf("\t LP=%0.6f -> %0.6f (delta=%0.6f), SNPs=%d, Indels=%d, N1=%d,N2=%d\n", newLP, nLP2, nLP2 - newLP, SNPs2, Indels2,N1,N2);
		      fflush(stdout);
		    }

		    newLP = nLP2;
		    SNPcnt = SNPs2;
		    IndelCnt = Indels2;

		    /* swap newLPA and bestLPA */
		    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;

		    /* HERE: reactive regions near trimmed ends ? */
		  }
		}
	      }
	    }

	    if(VERB/* HERE >=2 */){
	      printf("After Trimming Haplotype Ends: (IndelCnt=%d -> %d, SNPcnt=%d -> %d,imin=%d,imax=%d,n=%d)\n",
			origIndelCnt, IndelCnt, origSNPcnt, SNPcnt,imin,imax,n);
	      if(VERB>=2){
  	        int hap = 0;
		for(int i = 1; i <= n; i++){
		  if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
		    printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
			i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
		  if(hap && HapSite[i]==3)
		    hap = 0;
		  if(HapDelta[i])
		    hap = 1;
		}
	      }
	      fflush(stdout);
	    }
	  }

	  if(DEBUG>=1+RELEASE /* HERE >=2 */){/* verify LP value */
	    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate consensus map pair */
	    double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
				    TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2, 0, 0, 0.0, 0.0, 0.0, 0.0, 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) ||VERB/* HERE >=2 */){
	      printf("%snLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n", 
		     !(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) ? "WARNING: " : "",  nLP2,newLP,nLP2-newLP, SNPs, Indels);
	      fflush(stdout);
	      if(DEBUG>=1+RELEASE /* HERE HERE >=2 */) assert(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt);
	    }
	    newLP = nLP2;
	    SNPcnt = SNPs;
	    IndelCnt = Indels;
	  }

	  // NEW137 : update LPhwm etc
	  LPhwm = newLP;
	  LPdrop_count = 0;
	  if(HAP_INDEL_SKIP_FIX)
	    HapIndelDelSkipcnt = 0;

	  if(DEBUG>=2){/* check if map's are consistent */
	    /* NEW*/hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* needed to update N1,N2,Y1,Y2 etc */

	    /* check if map[MD] and nmap[MD] are consistent */
	    int I,i;
	    for(i = 1; i <= n; i++)
	      if((I = map1[MD][i]) >= 0){
		assert(nmap1[MD][I] == i);
		assert(fabs(Hcuts1[i] - Y1[I]) < 1e-6);
	      }
	    for(I = 1; I <= N1; I++)
	      if((i = nmap1[MD][I]) >= 0){
		assert(map1[MD][i] == I);
		assert(fabs(Hcuts1[i] - Y1[I]) < 1e-6);
	      }
	    for(i = 1; i <= n; i++)
	      if((I = map2[MD][i]) >= 0){
		assert(nmap2[MD][I] == i);
		assert(fabs(Hcuts2[i] - Y2[I]) < 1e-6);
	      }
	    for(I = 1; I <= N2; I++)
	      if((i = nmap2[MD][I]) >= 0){
		assert(map2[MD][i] == I);
		assert(fabs(Hcuts2[i] - Y2[I]) < 1e-6);
	      }

	    /* make sure map[] and mapK[] are consistent */
	    for(int m = 0; m < MD; m++){
	      int M = MX[m];

	      int lastJ = -1, lasti = -1, lastk = -1, i, k, I;
	      for(int J = 1; J <= M; J++){
		if((i = map1[m][J]) > 0 && (I = map1[MD][i]) > 0){
		  k = mapK1[m][J];
		  assert(0 <= k && k < i);
		  if(k > 0 && map1[MD][i-k] < 0)/* locally "clean up" mapK */
		    k = 0;
		  if(lasti >= 0 && !(i-k > lasti)){
		    printf("\nmap1:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel1[i,i-k]=%d,%d,HapSite[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel1[i],Hdel1[i-k],HapSite[i],HapSite[i-k]);
		    int K = map1[MD][i-k];
		    printf("    I=%d,K=%d:Hcuts1[i]=%0.4f,Y1[I]=%0.4f,Hcuts1[i-k]=%0.4f,Y1[K]=%0.4f\n",
			   I,K,Hcuts1[i],I < 0 ? -1.0 : Y1[I],Hcuts1[i-k], K < 0 ? -1.0 : Y1[K]);
		    if(VERB){
		      for(int j = 1; j <= M; j++){
			int i = map1[m][j];
			if(i < 0)
			  continue;
			int k = mapK1[m][j];
			printf("\t j=%d:map1[m][j]=%d(HS=%d),mapK1[m][j]=%d(HS=%d)\n",j,i,HapSite[i],k,(k < 0) ? -1 : HapSite[k]);
		      }
		    }
		    fflush(stdout);
		    assert(i-k > lasti);
		  }

		  lasti = i;
		  lastk = k;
		  lastJ = J;
		}
	      }

	      lastJ = -1, lasti = -1, lastk = -1;
	      for(int J = 1; J <= M; J++){
		if((i = map2[m][J]) > 0 && (I = map2[MD][i]) > 0){
		  k = mapK2[m][J];
		  assert(0 <= k && k < i);
		  if(k > 0 && map2[MD][i-k] < 0)/* locally "clean up" mapK */
		    k = 0;
		  if((lasti >= 0 && !(i-k > lasti))){
		    int K = map2[MD][i-k];
		    printf("\nmap2:m=%d,J=%d,i=%d,k=%d,I=%d,K=%d:lastJ=%d,lasti=%d,lastk=%d:Hdel2[i,i-k]=%d,%d,HapSite[i,i-k]=%d,%d\n",m,J,i,k,I,K,lastJ,lasti,lastk,Hdel2[i],Hdel2[i-k],HapSite[i],HapSite[i-k]);
		    if(VERB){
		      for(int j = 1; j <= M; j++){
			int i = map2[m][j];
			if(i < 0)
			  continue;
			int k = mapK2[m][j];
			printf("\t j=%d:map2[m][j]=%d(HS=%d),mapK2[m][j]=%d(HS=%d)\n",j,i,HapSite[i],k,(k < 0) ? -1 : HapSite[i-k]);
		      }
		    }
		    fflush(stdout);
		    assert(i-k > lasti);
		  }
		  lasti = i;
		  lastk = k;
		  lastJ = J;
		}
	      }
	    }
	  }

	  if(IndelCnt != origIndelCnt || SNPcnt != origSNPcnt){
	    LPhwm = newLP;
	    LPdrop_count = 0;

	    if(DELTA_EXPAND && !(DELTA_STOP >= 3)){/* increase range of Delta values to at least LOW_VALUES + HIGH_VALUES + 1 and reset Initial_Delta[IN][d] values to original values (starting at 0.050) */
	      int min_DELTA = min(LOW_VALUES + HIGH_VALUES + 7, localINITIAL_DELTA_RANGE);
	      for(int IN = 0; IN <= maxIN; IN++){
		DELTA_RANGE[IN] = max(min_DELTA, DELTA_RANGE[IN]);
		for(int d = 0; d < localINITIAL_DELTA_RANGE; d++)
		  Initial_Delta[IN][d] = Max_Initial_Delta[min(INITIAL_DELTA_RANGE-1,(d << (MAX_DELTA_OVERSAMPLE - DELTA_OVERSAMPLE)))] * 0.125;

		if(DEBUG>=1+RELEASE){
		  for(int d = 0; d < DELTA_RANGE[IN]; d++){
		    if(!(fabs(Initial_Delta[IN][d]) < 1000.0)){
		      printf("Initial_Delta[IN=%d][d=%d] = %0.4f is too large\n",IN,d,Initial_Delta[IN][d]);
		      fflush(stdout);
		      assert(fabs(Initial_Delta[IN][d] < 1000.0));
		    }
		    if(d > 0 && !(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0)){
		      printf("Initial_Delta[IN=%d][d=%d,%d] = %0.4f,%0.4f ratio is too large\n",IN,d-1,d,Initial_Delta[IN][d-1],Initial_Delta[IN][d]);
		      fflush(stdout);
		      assert(Initial_Delta[IN][d] < Initial_Delta[IN][d-1] * 2.0);
		    }
		  }	
		}
	      }
	      if(VERB/* HERE >=2 */){
		printf("Re-activated all %d ranges:Initial_Delta[0][0..%d..%d] -> %0.4f,%0.4f .. %0.4f,%0.4f .. %0.4f,%0.4f:DELTA_RANGE[0]=%d,localINITIAL_DELTA_RANGE=%d,min_DELTA=%d,DELTA_OVERSAMPLE=%d\n",
		       maxIN+1,DELTA_RANGE[0]-1,localINITIAL_DELTA_RANGE-1,Initial_Delta[0][0], Initial_Delta[0][1], Initial_Delta[0][DELTA_RANGE[0]-2],Initial_Delta[0][DELTA_RANGE[0]-1],
		       Initial_Delta[0][localINITIAL_DELTA_RANGE-2],Initial_Delta[0][localINITIAL_DELTA_RANGE-1],DELTA_RANGE[0],localINITIAL_DELTA_RANGE,min_DELTA,DELTA_OVERSAMPLE);
		fflush(stdout);
	      }
	    }

	    if(!FILTER_STOP){

	      if(HINDELITER(iter+1))
		iter++;// NEW4 : make sure next iteration checks for non-Indels, since Indel iteration will disable active intervals

	      SNPfail = SNPskip = 0;
	      lastiter = iter;
	      int origmaxiter = maxiter;
	      maxiter = max(maxiter, iter + (int)(ITER_INC + max(N1,N2) * ITER_FRAC)/2);
	      HapUpdatemapSkipcnt = 0;

	      if(VERB){
		double wt = wtime();
		printf("After filtering SNPs/Indels : Resuming Haplotype refinement (no new HapSites or HapIndels) : increased maxiter= %d to %d, iter=%d: wall time=%0.6f(cum= %0.6f)\n",
		       origmaxiter, maxiter, iter, wt - wtstart,wt);
		fflush(stdout);
	      }

	      continue;/* next iter < maxiter */
	    }
          }

	  if(VERB){
	    double wt = wtime();
	    printf("After trying to filter SNPs/Indels : iter=%d: wall time=%0.6f(cum= %0.6f)\n",
	        iter, wt - wtstart,wt);
	    fflush(stdout);
	  }
        }// if(!Filtered)

	if(FILTER_FIRST && HaploTypeDeres(Deresed,Filtered,SNPfail,SNPskip,lastiter,maxiter,HapUpdatemapSkipcnt,iter,numthreads,BigPen,newLP,LPhwm,LPdrop_count,n,Hcuts,HapDelta,HapDeltaMerged,HapSite,Delta,HapSiteScore,SiteScore,HapDeltaScore,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,MD,MX,X,lc,rc,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,TBmapWT,newLPA1,newLPA2,testLPA1,testLPA2,bestLPA1,bestLPA2,mapWT1,mapWT2,outlier1,outlier2,newLPA,pcontig,SNPcnt,IndelCnt,prevHapDelta,prevDelta,prevHapSite,spreadHapDelta,spreadDelta, Label, Index, Hremap, DELTA_OVERSAMPLE, maxIN,DELTA_RANGE,Initial_Delta,activecnt,DELTA_SCAN,Lfrozen,Rfrozen)){

	  // NEW137 : update LPhwm etc
	  LPhwm = -BigPen;
	  LPdrop_count = 0;
	  if(HAP_INDEL_SKIP_FIX)
	    HapIndelDelSkipcnt = 0;

	  if(1){/* update HapDeltaMerged[1..n] */
	    for(int i = 0; i <= n; i++){
	      if(i <= 0 || HapSite[i] == 3){
		int RR = i+1;
		while(RR <= n && HapSite[RR] != 3)
		  RR++;

		/* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
		double sum = 0.0, abssum = 0.0;
		for(int t = i; t < RR; t++){
		  sum += HapDelta[t];
		  abssum += fabs(HapDelta[t]);
		}
		if(abssum < MIN_INDEL_SIZE)
		  abssum = sum = 0.0;
		else if(fabs(sum) < MIN_INDEL_SIZE)
		  sum = copysign(MIN_INDEL_SIZE,sum);
	      
		for(int t = i; t < RR; t++){
		  if(DEBUG && !(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE)){
		    printf("After Label Deres in iter=%d:i=%d,RR=%d,HapSite[i,RR]=%d,%d:HapDelta[i..RR]=%0.6f,HapDeltaMerged[%d]=%0.6f : fixed\n",
			   iter,i,RR,HapSite[i],HapSite[RR],sum,t,HapDeltaMerged[t]);
		    fflush(stdout);
		    //		  HapDeltaMerged[t] = sum;
		    assert(fabs(HapDeltaMerged[t] - sum) < MIN_INDEL_SIZE);
		  }
		}
	      }
	    }
	  }

	  if(!(DERES_STOP && Deresed >= HAP_MAX_DERES)){ // don't resume after Final Deres
	    SNPfail = SNPskip = 0;
	    lastiter = iter;
	    int origmaxiter = maxiter;
	    maxiter = max(maxiter, iter + (int)(ITER_INC + max(N1,N2) * ITER_FRAC)/2);
	    HapUpdatemapSkipcnt = 0;
	    if(VERB){
	      printf("After -rres -cres : Resuming Haplotype refinement: increased maxiter= %d to %d, iter=%d\n",origmaxiter, maxiter, iter);
	      fflush(stdout);
	    }

	    continue;/* next iter < maxiter */
	  }
	}

	if(iter > HapSiteScoreIter + 1 && SKIPMAP_ADD >= 2 && !(iter >= maxiter-2)){/* repeat one more iterations with SKIPMAP_ADD = 1, so HapSiteScore is updated */
	  if(VERB){
	    printf("iter=%d: Forcing one more SNP iteration : maxiter= %d -> %d, HapSiteScoreIter=%d\n",iter,maxiter,iter+2,HapSiteScoreIter);
	    fflush(stdout);
	  }
	  maxiter = iter+2;// forces breakout == 1 after next (SNP) iteration : see condition above : if(!breakout && (iter >= maxiter-1 || ...))
	  checkHapSite = 2;// forces loop terminates at end of next iteration WITHOUT rerunning Filters
	  continue;
	}

	break;// break out of main iter loop
      } // if(breakout)

      if(DEBUG) assert(iter < maxiter-1);
    } // if(breakout)
  } /* for(iter=0; iter < maxiter; iter++) */

  if(HapSiteUnphasedSNR > 0.0 && !UnphasedCnt){
    printf("WARNING: Failed to perform check for Unphased SNPs:UnphasedCnt= %d, reversalcnt=%d/%d, FINAL_HREVERSAL=%d\n",UnphasedCnt,reversalcnt, HREVERSAL,FINAL_HREVERSAL);
    fflush(stdout);
    
    if(DEBUG>=1+RELEASE) assert(UnphasedCnt >= 0);
    /* NOTE: : If this assertion triggers something is wrong since check for Unphased SNPs
       should happen each time Haplotype Phasing is recomputed which should happen exactly 1 + FINAL_HREVERSAL times */
  } else if(VERB){
    printf("Unphased SNP filtering was performed %d times: reversalcnt=%d/%d, FINAL_HREVERSAL=%d\n",UnphasedCnt,reversalcnt, HREVERSAL,FINAL_HREVERSAL);
    fflush(stdout);
  }

  delete [] LPd;
  delete [] LPd2;

  int IndelCnt = 0, SNPcnt = 0;
  for(int i = 1; i <= n; i++)
    if(HapSite[i]==1 || HapSite[i]==2)
      SNPcnt++;
  for(int i = 0; i < n; i++){
    if(i <= 0 || HapSite[i]==3){
      if(VERB>=3 && iter==53 && HapDeltaMerged[i] != 0.0){
        printf("Indel at Hcuts[i=%d]=%0.4f:HapSite[i]=%d,HapDelta[i]=%0.4f(HapDeltaMerged[i]=%0.4f)\n",i,Hcuts[i],HapSite[i],HapDelta[i],HapDeltaMerged[i]);
	fflush(stdout);
      }
      IndelCnt += (HapDeltaMerged[i] != 0.0) ? 1 : 0;
    }
  }

  if(VERB>=2){
    printf("After haplotype refinement:\n");
    for(int i = 1; i <= n; i++)
      if(HapSite[i])
	printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
	       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
    fflush(stdout);
  }

  if(VERB){
    printf("HaploTypeR:N1=%d,N2=%d,Indels=%d,SNPs=%d,totchanges=%d:LP=%0.6f -> %0.6f\n",N1,N2,IndelCnt,SNPcnt,totchangecnt, hLP, newLP);
    fflush(stdout);
  }

  if(DELTA_X != prevDELTA_X || DELTA_Y != prevDELTA_Y || RANGE_Y != prevRANGE_Y || RANGE != prevRANGE || OutlierType != prevOutlierType || outlierLambda != prevOutlierLambda ||
     Poutlier != prevPoutlier || PoutlierEnd != prevPoutlierEnd || LRbias != prevLRbias || SF[0] != prevSF || SR[0] != prevSR){

    DELTA_X = prevDELTA_X;
    DELTA_Y = prevDELTA_Y;
    RANGE = prevRANGE;
    RANGE_Y = prevRANGE_Y;
    OutlierType = prevOutlierType;
    outlierLambda = prevOutlierLambda;
    Poutlier = prevPoutlier;
    PoutlierEnd = prevPoutlierEnd;
    LRbias = prevLRbias;
    SF[0] = prevSF;
    SR[0] = prevSR;

    // NOTE : hprobeval() calls score_init() 
    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
    double pLP = newLP;
    newLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		      TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
    if(VERB){
      printf("Restored DELTA=%d,%d,RANGE=%d,RANGE_Y=%d,OutlierType=%d,Lambda=%0.2e,outlier=%0.2e,outlierEnd=%0.2e,LRbias=%0.2e,sf=%0.3f,sr=%0.5f: hLP=%0.10f -> %0.10f, SNPs=%d,Indels=%d (SNPcnt=%d,IndelCnt=%d)\n",
	     DELTA_X,DELTA_Y,RANGE,RANGE_Y,OutlierType,outlierLambda, Poutlier, PoutlierEnd, LRbias,SF[0],SR[0],pLP, newLP, SNPs, Indels, SNPcnt, IndelCnt);
      fflush(stdout);
    }
    SNPcnt = SNPs;
    IndelCnt = Indels;
  }

  if(1){ /* recompute HapDeltaMerged[1..n] */
    for(int i = 0; i <= n; i++)
      HapDeltaMerged[i] = 0.0;

    for(int i = 0; i <= n; i++){
      if(i <= 0 || HapSite[i] == 3){
	int RR = i+1;
	while(RR <= n && HapSite[RR] != 3)
	  RR++;
	double sum = 0.0, abssum = 0.0;
	for(int t = i; t < RR; t++){
	  sum += HapDelta[t];
	  abssum += fabs(HapDelta[t]);
	}
	if(abssum >= MIN_INDEL_SIZE){
	  if(fabs(sum) < MIN_INDEL_SIZE)
	    sum = copysign(MIN_INDEL_SIZE,sum);
	  for(int t = i; t < RR; t++)
	    HapDeltaMerged[t] = sum;
	}
	if(VERB>=2 && abssum >= MIN_INDEL_SIZE){
	  printf("i=%d,RR=%d:HapSite[i,RR]=%d,%d,HapDelta[i]=%0.6f(tot=%0.6f,abs=%0.6f),Hcuts[i,RR]=%0.4f,%0.4f\n",
		 i,RR,HapSite[i],HapSite[RR],HapDelta[i],sum,abssum,Hcuts[i],Hcuts[RR]);
	  fflush(stdout);
	}
	 
	i = RR-1;
      }
    }
  }

  if(VERB/* HERE >=2 */){
    if(iter > HapSiteScoreIter + 1)
      printf("Last iter=%d,HapSiteScoreIter=%d: Recomputing HapSiteScore\n",iter,HapSiteScoreIter);
    else
      printf("Last iter=%d,HapSiteScoreIter=%d: NOT Recomputing HapSiteScore\n",iter,HapSiteScoreIter);
    fflush(stdout);
  }

  //	  if(DEBUG) assert(iter <= HapSiteScoreIter + 1); // Can happend due to skipping SNP iterations if SNP_SKIP_LIMIT > 0
  if(iter > HapSiteScoreIter + 1){// Recompute HapSiteScore[] and SiteScore[] : only do this if this was not done in the last iteration (eg due to skipping it), but also if SKIPMAP_ADD>=2

    // For now just call hprobeval() : later convert to using mprobeval()
    //    double HapSitePen[4] = {0.0,logHapSitePvalue - 0.5*SITE_PEN, logHapSitePvalue - 0.5*SITE_PEN, -SITE_PEN};      /* penalty as function of h or HapSite[i] */
    double SNPscore[4];

    for(int i = 1; i <= n; i++){
      if(HapSite[i] == 0 || HapSite[i] == 3)
	continue;

      int L = i-1;
      while(L >= 1 && !HapSite[L])
	L--;
      int R = i+1;
      while(R <= n && !HapSite[R])
	R++;
      int LL = L, RR = R;
      while(LL >= 1 && HapSite[LL] != 3)
	LL--;
      while(RR <= n && HapSite[RR] != 3)
	RR++;

      int origHapSite = HapSite[i];
      //      double origHapDelta = HapDelta[i];
      //      double origDelta = Delta[i];
      //      double origHapDeltaL = HapDelta[L];
      //      double origDeltaL = Delta[L];

      /* need to save all HapDelta[LL .. RR-1] and Delta[LL .. RR-1] */
      memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
      memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
      memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));

      if(VERB>=3){
	printf("i=%d/%d:LL=%d,L=%d,R=%d,RR=%d:HapSite[i]=%d:Delta[L,i]=%0.3f,%0.3f,HapDelta[L,i]=%0.3f,%0.3f: recomputing HapSiteScore[i]=%0.6f, SiteScore[i]=%0.6f\n",
	       i,n,LL,L,R,RR,HapSite[i],Delta[L],Delta[i],HapDelta[L],HapDelta[i],HapSiteScore[i],SiteScore[i]);
	fflush(stdout);
      }

      double wt1 = wtime();

      SNPscore[HapSite[i]] = newLP;
      SNPscore[3-HapSite[i]] = newLP - 99999.999999;

      for(int SNP = 0; SNP <= 3; SNP += 3){
	HapSite[i] = SNP;
	if(HINDEL && HPROBEVAL_SPREAD && !HapSite[i]){
	  Delta[L] += Delta[i];
	  HapDelta[L] += HapDelta[i];
	  HapDelta[i] = Delta[i] = 0.0;
	}

	// NOTE there is a small chance minKB restriction is violated due to previous change being too close to current change
	int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate consensus map pair */
	//		rverb = (iter==35 && i==2639 && SNP==3) ? 1 : 0;
	double nLP = err ? newLP - 99999.999999 : 
	  hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	//		rverb = 0;
	if(VERB>=3 || err){
	  printf("i=%d/%d:LL=%d,L=%d,R=%d,RR=%d,HapSite[i]=%d -> %d: LP= %0.6f -> %0.6f (err=%d)\n",i,n,LL,L,R,RR,origHapSite,HapSite[i],newLP, nLP,err);
	  fflush(stdout);
	}
	SNPscore[SNP] = nLP;// WAS  - HapSitePen[SNP];// NEW2

	if(HINDEL && !HapSite[i]){
	  memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	  memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	  memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		
	  if(DEBUG) assert(HapSite[i] == origHapSite);
	}
	HapSite[i] = origHapSite;
      }
	      
      double origHapSiteScore = HapSiteScore[i], origSiteScore = SiteScore[i];

      HapSiteScore[i] = newLP - max(SNPscore[0], SNPscore[3]);
      SiteScore[i] = SNPscore[3] - SNPscore[0];
      if(VERB/* HERE >=2 */){
	double wt = wtime();
	printf("i=%d/%d:LL=%d,RR=%d:Hcuts[i]=%0.4f, HapSite[i]=%d: recomputed HapSiteScore[i]=%0.6f -> %0.6f, SiteScore[i]=%0.6f -> %0.6f (SNPscore=%0.6f,%0.6f,%0.6f,%0.6f, newLP=%0.6f):wall= %0.6f ( cum= %0.6f)\n",
	       i,n,LL,RR,Hcuts[i],HapSite[i],origHapSiteScore,HapSiteScore[i],origSiteScore,SiteScore[i],SNPscore[0],SNPscore[1],SNPscore[2],SNPscore[3],newLP,wt-wt1,wt);
	fflush(stdout);
      }
    }
  }

  if(1){/* verify LP value and update nmap, bestLPA */
    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
    //    rverb = (iter==53) ? 1 : 0;
    double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2, 0, 0, 0.0, 0.0, 0.0, 0.0, 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
    //    rverb = 0;
    if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) ||VERB/* HERE >=2 */){
      if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt))
	printf("WARNING: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d->%d, Indels=%d->%d\n", nLP2,newLP,nLP2-newLP, SNPcnt,SNPs, IndelCnt,Indels);
      else
	printf("nLP= %0.6f, newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n", nLP2,newLP,nLP2-newLP, SNPs, Indels);
      printf("DELTA=%d,%d,RANGE=%d,RANGE_Y=%d,OutlierType=%d,outlierLambda=%0.3e,Poutlier=%0.4e,Poutlierend=%0.4e\n",
	     DELTA_X,DELTA_Y,RANGE,RANGE_Y,OutlierType,outlierLambda,Poutlier,PoutlierEnd);
      fflush(stdout);
      assert(fabs(nLP2 - newLP) < 1e-5 /* && SNPs == SNPcnt && Indels == IndelCnt */);
    }
    newLP = nLP2;
    SNPcnt = SNPs;
    IndelCnt = Indels;

    /* swap newLPA and bestLPA */
    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
  }

  if(DEBUG>=2){
    for(int i = 0; i <= n; i++){
      if(!isfinite(Delta[i])){
	printf("Before Rescoring all Hap Indels : i=%d,Delta[i]=%0.3f,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f\n",i,Delta[i],HapDelta[i],Hcuts[i]);
	fflush(stdout);
	assert(isfinite(Delta[i]));
      }
      if(!isfinite(HapDelta[i])){
	printf("Before Rescoring all Hap Indels : i=%d,Delta[i]=%0.3f,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f\n",i,Delta[i],HapDelta[i],Hcuts[i]);
	fflush(stdout);
	assert(isfinite(HapDelta[i]));
      }
    }
  }

  if((checkHapSite ? /*NEW76 */iter - 1 : iter) > HapIndelDelIter + 1){ /* recompute HapDeltaScore values */
    if(VERB){
      printf("\nFinal rescoring of all Hap Indels (iter=%d, HapIndelDelIter=%d, checkHapSite=%d):\n", iter, HapIndelDelIter, checkHapSite);
      fflush(stdout);
    }

    double orig_newLP = newLP;

    for(int i = 0; i <= n; i++)
      HapDeltaScore[i] = 0.0;

    for(int i = 0; i <= n; i++){
      if(i <= 0 || HapSite[i] == 3){
	int RR = i+1;
	while(RR <= n && HapSite[RR] != 3)
	  RR++;
	
	if(fabs(HapDeltaMerged[i]) <= 0.0)
	  continue;

	double origHapDelta = HapDelta[i];

	/* try to remove each Haplotype group HapDelta[i..RR-1] by calling hprobeval() and update the corresponding HapDeltaScore[] values */
	memcpy(&prevHapDelta[i],&HapDelta[i],(RR-i)*sizeof(double));
	memcpy(&prevDelta[i],&Delta[i],(RR-i)*sizeof(double));
	if(HAPINDELDELETE_FIX)
	  memcpy(&prevHapSite[i+1],&HapSite[i+1],(RR-i-1)*sizeof(int));

	if(VERB>=1+RELEASE/* HERE >=2 */){
	  printf("Testing removal of HapIndel[%d..%d] = %0.6f (Hcuts= %0.4f .. %0.4f)\n", i, RR, HapDeltaMerged[i],Hcuts[i],Hcuts[RR]);
	  fflush(stdout);
	}

	double bestLP = newLP - BigPen, nLP;
	int bestAllele = 3;
	int bestSNPs = SNPcnt, bestIndels = IndelCnt;

	for(int t = i; t < RR; t++)
	  HapDelta[t] = 0.0;

	int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	if(err){
	  if(VERB>=1+RELEASE/* HERE >=2 */){
	    printf("Averaged removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
	    fflush(stdout);
	  }
	  bestAllele = -1;
        } else {
	  nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  if(VERB/* HERE >=2 */){
	    printf("Averaged removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs = %d, Indels=%d: wtime= %0.6f\n", 
		   i, RR, HapDeltaMerged[i], nLP, nLP > newLP ? '!':' ',nLP-newLP, SNPs, Indels, wtime());
	    fflush(stdout);
	  }
	  bestLP = nLP;
	  bestSNPs = SNPs;
	  bestIndels = Indels;
	  if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
	    double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	    tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	  }
	}

	/* next try changing only Allele 1 */
	for(int t = i; t < RR; t++){
	  Delta[t] = prevDelta[t] - prevHapDelta[t];
	  if(DEBUG) assert(isfinite(Delta[t]));
	}
	if(HAPINDELDELETE_FIX){ // need to also change HapSite[i+1..RR-1] to match Allele 2 : HapSite 1 -> 0, 2 -> 3 
	  for(int t = i+1; t < RR; t++){
	    if(HapSite[t] == 1)
	      HapSite[t] = 0;
	    else if(HapSite[t] == 2)
	      HapSite[t] = 3;
	  }
	  for(int t = RR; --t > i;){
	    if(!HapSite[t]){
	      Delta[t-1] += Delta[t];
	      Delta[t] = 0.0;
	    }
	  }
	}

	err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
	if(err){
	  if(VERB>=1+RELEASE/* HERE >=2 */){
	    printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
	    fflush(stdout);
	  }
	} else {
	  nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  if(VERB/* HERE >=2 */){
	    printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
		   i,RR,HapDeltaMerged[i], nLP, nLP > max(bestLP,newLP) ? '!' : ' ', nLP - newLP, SNPs,Indels,wtime());
	    fflush(stdout);
	  }
	  if(nLP > bestLP || bestAllele == -1){
	    bestLP = nLP;
	    bestSNPs = SNPs;
	    bestIndels = Indels;
	    bestAllele = 1;
	    if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
	      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	    }
	  }
	}

	/* next try changing only Allele 2 */
	for(int t = i; t < RR; t++){
	  Delta[t] = prevDelta[t] + prevHapDelta[t];
	  if(DEBUG) assert(isfinite(Delta[t]));
	}
	if(HAPINDELDELETE_FIX){	      // need to also change HapSite[i+1..RR-1] to match Allele 1 : HapSite 1 -> 3, 2 -> 0 
	  for(int t = i+1; t < RR; t++){
	    HapSite[t] = prevHapSite[t];
	    if(HapSite[t] == 1)
	      HapSite[t] = 3;
	    else if(HapSite[t] == 2)
	      HapSite[t] = 0;
	  }
	  for(int t = RR; --t > i;){
	    if(!HapSite[t]){
	      Delta[t-1] += Delta[t];
	      Delta[t] = 0.0;
	    }
	  }
	}

	err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
	if(err){
	  if(VERB>=1+RELEASE/* HERE >=2 */){
	    printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
	    fflush(stdout);
	  }
	} else {
	  //	  rverb = (iter >= 31) ? 1 : 0;
	  nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  rverb = 0;
	  if(VERB/* HERE >=2 */){
	    printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
		   i,RR,HapDeltaMerged[i], nLP, nLP > max(bestLP,newLP) ? '!':' ', nLP - newLP, SNPs,Indels,wtime());
	    printf("\t Hcuts1[%d..%d]= %0.3f .. %0.3f, Hcuts2[%d..%d]= %0.3f .. %0.3f\n", i,RR,Hcuts1[i],Hcuts1[RR],i,RR,Hcuts2[i],Hcuts2[RR]);
	    fflush(stdout);
	  }
	  if(nLP > bestLP || bestAllele == -1){
	    bestLP = nLP;
	    bestSNPs = SNPs;
	    bestIndels = Indels;
	    bestAllele = 2;

	    if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
	      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	    }
	  }
	}

	if(!HINDELITER(iter))/* avoid undoing Indels after SNP iteration : unknown bug can cause loss of valid Indels */
	  bestLP = min(bestLP, newLP - 1e-6);

	HapDeltaScore[i] = newLP - bestLP;

	if(bestLP > newLP /* && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)*/){/* confirm change & swap newLPA and bestLPA */
	  if(VERB){
	    printf("Removed HapDelta[%d..%d]= %0.6f (HapDelta[i]=%0.6f): LP=%0.6f -> %0.6f, IndelCnt=%d -> %d, SNPs=%d (iter=%d)\n", 
		   i,RR, HapDeltaMerged[i], origHapDelta, newLP, bestLP, IndelCnt, bestIndels, bestSNPs, iter);
	    fflush(stdout);
	  }
	  if(DEBUG>=1+RELEASE) assert(HINDELITER(iter));

	  newLP = bestLP;
	  IndelCnt = bestIndels;
	  SNPcnt = bestSNPs;
	  for(int t = i; t < RR; t++)
	    HapDeltaMerged[t] = 0.0;
	  if(bestAllele != 2){
	    if(bestAllele == 1){
	      for(int t = i; t < RR; t++)
		Delta[t] = prevDelta[t] - prevHapDelta[t];
	      if(HAPINDELDELETE_FIX){
		for(int t = i+1; t < RR; t++){
		  HapSite[t] = prevHapSite[t];
		  if(HapSite[t] == 1)
		    HapSite[t] = 0;
		  else if(HapSite[t] == 2)
		    HapSite[t] = 3;
		}
		for(int t = RR; --t > i;){
		  if(!HapSite[t]){
		    Delta[t-1] += Delta[t];
		    Delta[t] = 0.0;
		  }
		}
	      }
	    } else {
	      for(int t = i; t < RR; t++)
		Delta[t] = prevDelta[t];
	      if(HAPINDELDELETE_FIX)
		for(int t = i+1; t < RR; t++)
		  HapSite[t] = prevHapSite[t];
	    }
	  }
	  if(VERB>=3 && iter>=31){
	    printf("Before aggregating Delta[%d..%d]:\n",i,RR-1);
	    fflush(stdout);
	    (void)hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate consensus map pair */
	    //	    rverb = (iter >= 31) ? 1 : 0;
	    double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    rverb = 0;
	    printf("\t After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);		    	    
	    fflush(stdout);
	  }

	  if(DEBUG>=1+RELEASE/* HERE >=2 */){/* verify LP is now equal to newLP */
	    (void)hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate consensus map pair */
	    // rverb = (iter >= 31) ? 1 : 0;
	    double nLP2 = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    rverb = 0;
	    if(!(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt) ||VERB/* HERE >=2 */){
	      if(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt)
	        printf("\t After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);		    
	      else
	        printf("WARNING: After switching to Allele=%d: nLP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,nLP2,newLP,nLP2-newLP, SNPs, Indels);
	      fflush(stdout);
	      if(DEBUG>=1+RELEASE) assert(fabs(nLP2 - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt);
	    }
	    if(DEBUG){/* verify full LP */
	      double LP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		    TBmapWT,testLPA1,testLPA2,mapWT1,mapWT2, 0, 0, 0.0, 0.0, 0.0, 0.0, 0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	      if(!(fabs(LP - newLP) < 1e-6 && SNPs == SNPcnt && Indels == IndelCnt)){
	        printf("WARNING: After switching to Allele=%d: LP= %0.6f, expected newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",bestAllele,LP,newLP,LP-newLP, SNPs, Indels);
	        for(int m = 0; m < MD; m++){
		  if(fabs(testLPA1[m] - bestLPA1[m]) > 1e-6)
		    printf("m=%d:qLPA1[m]= %0.8f, fLPA1[m]= %0.8f (err=%0.8f)\n",m, bestLPA1[m],testLPA1[m],bestLPA1[m]-testLPA1[m]);
		  if(fabs(testLPA2[m] - bestLPA2[m]) > 1e-6)
		    printf("m=%d:qLPA2[m]= %0.8f, fLPA2[m]= %0.8f (err=%0.8f)\n",m, bestLPA2[m],testLPA2[m],bestLPA2[m]-testLPA2[m]);
	        }
	        fflush(stdout);
	        //		    assert(fabs(LP - newLP) < 1e-5 && SNPs == SNPcnt && Indels == IndelCnt); // this happens with id17 in NA12878A_*r4632/output/contigs/exp_refineFinal1/
	      }
	      newLP = LP;
	      IndelCnt = Indels;
	      SNPcnt = SNPs;

	      /* swap testLPA and bestLPA */
	      double *tmp = testLPA1; testLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = testLPA2; testLPA2 = bestLPA2; bestLPA2 = tmp;
	    }
	  }
        } else { /* restore original HapDelta */
	  memcpy(&HapDelta[i],&prevHapDelta[i], (RR - i)*sizeof(double));
	  memcpy(&Delta[i],&prevDelta[i],(RR-i)*sizeof(double));
	  if(HAPINDELDELETE_FIX)
	    memcpy(&HapSite[i+1],&prevHapSite[i+1],(RR-i-1)*sizeof(int));

	  if(DEBUG>=2){
	    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
	    double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    if(VERB>=3 || fabs(nLP - newLP) > 1e-6 || SNPcnt != SNPs || IndelCnt != Indels){
	      printf("WARNING:After restoring HapDelta[%d..%d]= %0.4f: nLP=%0.8f, expected newLP=%0.8f (err=%0.8f), SNPs=%d,Indels=%d\n",i,RR,HapDeltaMerged[i], nLP,newLP,nLP-newLP,SNPs,Indels);
	      fflush(stdout);
	      //		  assert(fabs(nLP-newLP) < 1e-5);
	      assert(nLP > orig_newLP - 1e-6);
	    }
	    SNPcnt = SNPs;
	    IndelCnt = Indels;
	  }
        }

        for(int t = i+1; t < RR; t++)
	  HapDeltaScore[t] = HapDeltaScore[i];

        if(VERB/* HERE >=2 */){
           double DeltaSum = 0.0;
           for(int t = i; t < RR;t++)
    	     DeltaSum += Delta[t];
           printf("L=%d,R=%d:HapSite[L,R]=%d,%d,Hcuts[L]=%0.4f,Hcuts[L,R]=%0.4f,Delta[L,R]=%0.4f,HapDelta[L]=%0.4f(tot=%0.4f),HapDeltaScore=%0.2f\n",
	  	    i,RR,HapSite[i],HapSite[RR],Hcuts[i],Hcuts[RR]-Hcuts[i],DeltaSum,HapDelta[i],HapDeltaMerged[i],HapDeltaScore[i]);
           fflush(stdout);
	}
      }
    }
  }

  if(DEBUG>=2){
    for(int i = 0; i <= n; i++){
      if(!isfinite(Delta[i])){
	printf("After final computation of HapDeltaMerged[] : i=%d,Delta[i]=%0.3f,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f\n",i,Delta[i],HapDelta[i],Hcuts[i]);
	fflush(stdout);
	assert(isfinite(Delta[i]));
      }
      if(!isfinite(HapDelta[i])){
	printf("After final computation of HapDeltaMerged[] : i=%d,Delta[i]=%0.3f,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f\n",i,Delta[i],HapDelta[i],Hcuts[i]);
	fflush(stdout);
	assert(isfinite(HapDelta[i]));
      }
    }
  }

  if(VERB>=1+RELEASE /* HERE >=2 */){
    printf("After final computation of HapDeltaMerged[]: (imin=%d,imax=%d,n=%d) LP=%0.6f: wtime= %0.6f\n", imin,imax,n, newLP, wtime());

    if(VERB>=2){
      int hap = 0;
      for(int i = 0; i <= n; i++){
	if((i>0 && HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (i>0 && HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3))
	  printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Delta[i]=%0.4f,Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f,HapSitePhase[i]=%0.2f,HapDeltaPhase[i]=%0.2f\n",
		 i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Delta[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i],HapSitePhase[i],HapDeltaPhase[i]);
	if(hap && HapSite[i]==3)
	  hap = 0;
	if(HapDelta[i])
	  hap = 1;
      }
    }
    fflush(stdout);
  }
  if(1){/* check Delta[],Hcuts[] for consistency */
    /* compute DelCum[i+1] = Sum(Delta[0..i]) */
    double DeltaCum = 0.0;
    for(int i = 0; i <= n; i++){
      DeltaCum += Delta[i];
      DelCum[i+1] = DeltaCum;
    }
    int error = 0;
    int L = 0;
    for(int i=1; i <= n; i++){
      if(HapSite[i+1]){
	if(!(Hcuts[i+1]+DelCum[i+1] >= Hcuts[L]+DelCum[L])){
	  printf("Before spreading final HapDelta[] and Delta[] values:\n");
	  printf("WARNING: i=%d,L=%d:Hcuts[L]+DelCum[L]=%0.6f,Hcuts[i+1]+DelCum[i+1]=%0.6f,HapSite[L,i+1]=%d,%d\n",
		 i,L,Hcuts[L]+DelCum[L],Hcuts[i+1]+DelCum[i+1],HapSite[L],HapSite[i+1]);
	  fflush(stdout);
	  error++;
	  break;
	}
	L = i+1;
      }
    }
    if(!error && !(Hcuts[n+1]+DelCum[n+1] >= Hcuts[L]+DelCum[L])){
      printf("Before spreading final HapDelta[] and Delta[] values:\n");
      printf("WARNING: n=%d,L=%d:Hcuts[L]+DelCum[L]=%0.6f,Hcuts[n+1]+DelCum[n+1]=%0.6f,HapSite[L]=%d\n",
	     n,L,Hcuts[L]+DelCum[L],Hcuts[n+1]+DelCum[n+1],HapSite[L]);
      fflush(stdout);
      error++;
    }

    if(error){/* try to correct error */
      int L = 0;
      for(int R = 1; R <= n+1; R++){
	if(R <= n && HapSite[R] != 3)
	  continue;
	if(1 /* WAS L > 0 */){
          int invalid = HapDeltaSpread(n,L,R,HapDelta,Delta,Hcuts,HapSite,Label,Index,Hremap);
	  if(invalid){
	    printf("Before spreading final HapDelta[] and Delta[] values:\n");
	    printf("WARNING: Unable to adjust HapDelta[],Delta[] in interval Hcuts[%d,%d]=%0.4f,%0.4f,HapDeltaMerged[L]=%0.4f\n", L,R,Hcuts[L],Hcuts[R],HapDeltaMerged[L]);
	    fflush(stdout);
	    if(DEBUG) assert(!invalid);
	  }
	  (void)correctmapH(n,MD,MX,map1,map2,mapK1,mapK2,L,R,Hremap,HapSite,Hcuts,HapDelta,Delta,numthreads);
	}
	L = R;
      }
      if(VERB){
	printf("Adjusted HapDelta[],Delta[] in final map so Hcuts[] can be merged with Delta[]\n");
        fflush(stdout);
      }
    }
  }

  if(DEBUG>=2){
    for(int i = 0; i <= n; i++){
      if(!isfinite(Delta[i])){
	printf("Before spreading out HapDelta & Delta: i=%d,Delta[i]=%0.3f,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f\n",i,Delta[i],HapDelta[i],Hcuts[i]);
	fflush(stdout);
	assert(isfinite(Delta[i]));
      }
      if(!isfinite(HapDelta[i])){
	printf("Before spreading out HapDelta & Delta : i=%d,Delta[i]=%0.3f,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f\n",i,Delta[i],HapDelta[i],Hcuts[i]);
	fflush(stdout);
	assert(isfinite(HapDelta[i]));
      }
    }
  }

  /* spread out HapDelta[] and Delta[] so Hcuts[] remain monotonic (then revert just HapDelta[]) */
  memcpy(startHapDelta,HapDelta,(n+2)*sizeof(double));
  memcpy(startDelta,Delta,(n+2)*sizeof(double));
  int L = 0;
  for(int i = 0; i <= n; i++){
    if(i && !HapSite[i])
      continue;
    int R = i+1;
    while(R <= n && !HapSite[R])
      R++;

    if(DEBUG && !(Hcuts[R] >= Hcuts[i] && (!(HapSite[R] & HapSite[i]) || Hcuts[R] > Hcuts[i]))){
      printf("i=%d,R=%d,HapSite[i,R]=%d,%d,Hcuts[i,R]=%0.8f,%0.8f\n",i,R,HapSite[i],HapSite[R],Hcuts[i],Hcuts[R]);
      fflush(stdout);
      assert(Hcuts[R] >= Hcuts[i] && (!(HapSite[R] & HapSite[i]) || Hcuts[R] > Hcuts[i]));
    }
    if(DEBUG && !isfinite(HapDelta[i])){
      printf("i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
	     i,n,HapDelta[i],Delta[i],HapSite[i],R,HapSite[R]);
      fflush(stdout);
      assert(isfinite(HapDelta[i]));
    }

    if(HapDelta[i] && R > i+1){
      if(DEBUG && !(HapSite[i] || HapSite[R] || (i==0 && R==n+1))){
	printf("i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
	   i,n,HapDelta[i],Delta[i],HapSite[i],R,HapSite[R]);
	fflush(stdout);
	assert(HapSite[i] || HapSite[R] || (i==0 && R==n+1));
      }
      if(Hcuts[R] > Hcuts[i]){
	double scale = HapDelta[i] / (Hcuts[R]-Hcuts[i]);
	if(DEBUG) assert(isfinite(scale));
	  for(int t = i; t < R; t++)
	    HapDelta[t] = scale * (Hcuts[t+1] - Hcuts[t]);
      } else {
        double scale = HapDelta[i] / (R - i);
        if(DEBUG) assert(isfinite(scale));
          for(int t = i; t < R; t++)
            HapDelta[t] = scale;
      }
    }

    if(DEBUG && !isfinite(Delta[i])){
      printf("i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
	     i,n,HapDelta[i],Delta[i],HapSite[i],R,HapSite[R]);
      fflush(stdout);
      assert(isfinite(Delta[i]));
    }

    if(Delta[i] && R > i+1){
      if(DEBUG && !(HapSite[i] || HapSite[R] || (i==0 && R==n+1))){
	printf("iter=%d:i=%d,n=%d,HapDelta[i]=%0.4f,Delta[i]=%0.4f,HapSite[i]=%d,R=%d,HapSite[R]=%d\n",
	       iter,i,n,HapDelta[i],Delta[i],HapSite[i],R,HapSite[R]);
	fflush(stdout);
	assert(HapSite[i] || HapSite[R] || (i==0 && R==n+1));
      }
      if(Hcuts[R] > Hcuts[i]){
	double scale = Delta[i] / (Hcuts[R]-Hcuts[i]);
	if(DEBUG) assert(isfinite(scale));
	for(int t = i; t < R; t++)
	  Delta[t] = scale * (Hcuts[t+1] - Hcuts[t]);
      } else {
	double scale = Delta[i] / (R - i);
	if(DEBUG) assert(isfinite(scale));
	for(int t = i; t < R; t++)
	  Delta[t] = scale;
      }
    }
    L = i;
    i = R - 1;
  }

  if(DEBUG>=2){
    for(int i = 0; i <= n; i++){
      if(!isfinite(Delta[i])){
	printf("After spreading out HapDelta & Delta: i=%d,Delta[i]=%0.3f,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f\n",i,Delta[i],HapDelta[i],Hcuts[i]);
	fflush(stdout);
	assert(isfinite(Delta[i]));
      }
      if(!isfinite(HapDelta[i])){
	printf("After spreading out HapDelta & Delta : i=%d,Delta[i]=%0.3f,HapDelta[i]=%0.3f,Hcuts[i]=%0.3f\n",i,Delta[i],HapDelta[i],Hcuts[i]);
	fflush(stdout);
	assert(isfinite(HapDelta[i]));
      }
    }
  }

  if(DEBUG>=2){
    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,0,0);/* generate haplotype consensus map pair */

    //    rverb = 2;
    hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		    TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
    rverb = 0;
    if(VERB || fabs(hLP - newLP) > 1e-5){
      printf("After spreading final HapDelta[] and Delta[] values LP=%0.6f -> %0.6f (err=%0.6f),SNPs=%d,Indels=%d\n",newLP,hLP,hLP-newLP,SNPs,Indels);
      fflush(stdout);
      assert(fabs(hLP - newLP) <= 1e-5);
    }
    SNPcnt = SNPs;
    IndelCnt = Indels;
  }
  if(VERB>=2){
    printf("After spreading final HapDelta[] and Delta[] values: (IndelCnt=%d,SNPcnt=%d,imin=%d,imax=%d,n=%d), LP=%0.6f\n",
	   IndelCnt,SNPcnt,imin,imax,n, newLP);
    int hap = 0;
    double DeltaCum = Delta[0];
    if(DeltaCum)
      printf("\t Delta[0]= %0.4f\n",Delta[0]);
    for(int i = 1; i <= n; i++){
      if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3) /* ||Delta[i]||HapSite[i]*/)
	printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Delta[i]=%0.4f(cum=%0.4f),Hcuts[i]=%0.4f->%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
	       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Delta[i],DeltaCum,Hcuts[i],Hcuts[i] + DeltaCum, HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
      if(hap && HapSite[i]==3)
	hap = 0;
      if(HapDelta[i])
	hap = 1;
      DeltaCum += Delta[i];
    }
    fflush(stdout);
  }

  /* update Hcuts[] to reflect changes in Delta[] */
  double cumdelta = 0.0;
  L = 0;
  for(int i=0/* WAS8 1 */; i <= n; i++){
    cumdelta += Delta[i];
    Hcuts[i+1] += cumdelta;
    if(DEBUG && HapSite[i+1]){
      if(!(Hcuts[i+1] >= Hcuts[L])){
	printf("After merging Delta[] into Hcuts[]:\n");
	printf("i=%d,L=%d:Hcuts[L]=%0.6f,Hcuts[i+1]=%0.6f,Delta[i]=%0.6f,cumdelta=%0.6f\n",
	       i,L,Hcuts[L],Hcuts[i+1],Delta[i],cumdelta);
	fflush(stdout);
	assert(Hcuts[i+1] >= Hcuts[L]);
      }
      L = i+1;
    }
    Delta[i] = 0.0;
  }
  if(DEBUG && !(Hcuts[n+1] >= Hcuts[L])){
    printf("After merging Delta[] into Hcuts[]:\n");
    printf("n=%d,L=%d:Hcuts[L]=%0.6f,Hcuts[n+1]=%0.6f,cumdelta=%0.6f\n",
	   n,L,Hcuts[L],Hcuts[n+1],cumdelta);
    fflush(stdout);
    assert(Hcuts[n+1] >= Hcuts[L]);
  }
  // NOTE : if the above assertions fail, HapDeltaSpread() may need to be called over the entire map BEFORE spreading out HapDelta[] and Delta[] to reorder labels

  if(DEBUG/* HERE >=2 */){
    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,0,0);/* generate haplotype consensus map pair */
    //    rverb = 2;
    hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		    TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
    rverb = 0;
    if(VERB || fabs(hLP - newLP) > (USE_MFLOAT ? 1e-4 : 1e-5)){
      printf("%sAfter merging Delta[] into Hcuts[] : LP=%0.6f -> %0.6f (err=%0.6f), SNPs=%d,Indels=%d: wtime= %0.6f\n",
	     fabs(hLP - newLP) > (USE_MFLOAT ? 1e-4 : 1e-5) ? "WARNING:":"", newLP,hLP,hLP-newLP,SNPs,Indels,wtime());
      fflush(stdout);

      if(VERB>=2){
	int hap = 0;
	double DeltaCum = Delta[0];
	for(int i = 1; i <= n; i++){
	  if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3) /* ||Delta[i] || HapSite[i] || i <= 63*/)
	    printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Delta[i]=%0.4f(cum=%0.4f),Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		   i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Delta[i],DeltaCum,Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
	  if(hap && HapSite[i]==3)
	    hap = 0;
	  if(HapDelta[i])
	    hap = 1;
	  DeltaCum += Delta[i];
	}
	fflush(stdout);
      }

      if(DEBUG>=1+RELEASE) assert(fabs(hLP - newLP) <= (USE_MFLOAT ? 1e-3 : 1e-5));
    }
    SNPcnt = SNPs;
    IndelCnt = Indels;
  }
  if(VERB>=2){
    printf("After merging Delta[] into Hcuts[]: (IndelCnt=%d,SNPcnt=%d,imin=%d,imax=%d,n=%d) LP=%0.6f\n",
	   IndelCnt,SNPcnt,imin,imax,n, newLP);
    int hap = 0;
    for(int i = 1; i <= n; i++){
      if((HapSite[i] && HapSite[i] <= 2) || HapDelta[i] || (HapSite[i] && HapDeltaMerged[i]) || (hap && HapSite[i]==3) /*||Delta[i]*/)
	printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f(tot=%0.4f),Delta[i]=%0.4f,Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
	       i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Delta[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
      if(hap && HapSite[i]==3)
	hap = 0;
      if(HapDelta[i])
	hap = 1;
    }
    fflush(stdout);
  }

  /* restore HapDelta[] so there is only one value per actual site in .hmap */
  memcpy(HapDelta,startHapDelta,(n+2)*sizeof(double));  

  /* compute contig->MapPhase[0..MD-1] based on relative likelihoods */
  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
  //  rverb = 1;
  hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		  TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
  rverb = 0;
  if((DEBUG && fabs(hLP - newLP) > 1e-5) || VERB){
    printf("After restoring HapDelta[] final hprobeval=%0.6f, newLP=%0.6f (err=%0.6f), SNPs=%d, Indels=%d\n",hLP,newLP, hLP-newLP, SNPs, Indels);
    fflush(stdout);
  }
  newLP = hLP;
  SNPcnt = SNPs;
  IndelCnt = Indels;

  if(VERB>=2){
    printf("pcontig=%p,pcontig->HapDelta[0]=%p,n=%d,HapDelta=%p\n",pcontig,pcontig->HapDelta[0],n,HapDelta);
    fflush(stdout);
    for(int i = 1; i < n; i++)
      if(pcontig->HapDelta[0][i]){
	printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
	fflush(stdout);
      }
    fflush(stdout);
  }

  /* free up memory allocated for Hap filtering */
  delete [] covA;
#ifdef ASAN
  delete [] covB;
  delete [] covC;
  delete [] SNRwtsum;
  delete [] SNRsum;
  delete [] MapWeight;
  delete [] IcovA;
  delete [] IcovB;
  delete [] IoutA;
  delete [] IoutB;
  delete [] varA;
  delete [] varB;
  delete [] meanA;
  delete [] meanB;
#endif

  if(VERB>=2){
    printf("After deleting covA,covB etc : pcontig=%p,pcontig->HapDelta[0]=%p,n=%d\n",pcontig,pcontig->HapDelta[0],n);
    for(int i = 1; i < n; i++)
      if(pcontig->HapDelta[0][i])
	printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
    fflush(stdout);
  }

  /* Compute average coverage of each Allele based on maps assigned with 70% certainty */
  /* first locate first & last label spanned by both Alleles */
  int ifirst = n+1, ilast = 0;
  for(int i = 1, HS = 0; i <= n; i++){
    HS |= HapSite[i];
    if(HS == 3){
      ifirst = i;
      break;
    }
  }
  for(int i = n, HS = 0; i >= 1; i--){
    HS |= HapSite[i];
    if(HS == 3){
      ilast = i;
      break;
    }
  }
  if(DEBUG>=1+RELEASE) assert(ifirst <= ilast);

  int cnt1 = 0, cnt2 = 0;/* count how many maps can be assigned to one Allele with 90% certainty */
  int cnt3 = 0, cnt4 = 0;/* count how many maps can be assigned to one Allele with 70% certainty */
  double sumA = 0.0, sumB = 0.0;

  for(int m = 0; m < MD; m++){
    double LP1 = bestLPA1[m];
    double LP2 = bestLPA2[m];
    pcontig->MapPhase[m] = 1.0/(1.0 + exp(LP2-LP1));

    if(VERB>=2 && gmap[pcontig->contig[m].mapid]->id == 18585){
      printf("m=%d,id=%lld:LP1=%0.6f,LP2=%0.6f:MapPhase[m]=%0.6f\n",m,gmap[pcontig->contig[m].mapid]->id,LP1,LP2,pcontig->MapPhase[m]);
      fflush(stdout);
    }
    if(pcontig->MapPhase[m] < 0.1)
      cnt1++;
    if(pcontig->MapPhase[m] < 0.3)
      cnt3++;
    if(pcontig->MapPhase[m] > 0.9)
      cnt2++;
    if(pcontig->MapPhase[m] > 0.7)
      cnt4++;
    
    if(ifirst >= ilast || (pcontig->MapPhase[m] >= 0.3 && pcontig->MapPhase[m] <= 0.7))
      continue;

    if(pcontig->MapPhase[m] > 0.7/* WAS148 < 0.3 */){  /* locate range of aligned labels for map m in Allele1 */
      int first = n+1,last = 0;
      for(int j = 1; j <= MX[m]; j++){
	int I = nmap1[m][j];
	if(I < 0)
	  continue;
	int K = nmapK1[m][j];
	if(DEBUG) assert(K >= 0);
	int k = nmap1[MD][I-K];
	if(DEBUG) assert(1 <= k && k <= n);
	first = max(k,ifirst);
	break;
      }
      for(int j = MX[m]; j >= 1; j--){
	int I = nmap1[m][j];
	if(I < 0)
	  continue;
	int i = nmap1[MD][I];
	if(DEBUG) assert(1 <= i && i <= n);
	last = min(i,ilast);
	break;
      }
      if((VERB>=2 && gmap[pcontig->contig[m].mapid]->id == 18585) || (DEBUG>=2 && !(last>=first))){
	printf("m=%d,id=%lld:LP1=%0.6f,LP2=%0.6f:MapPhase[m]=%0.6f,M=%d\n",m,gmap[pcontig->contig[m].mapid]->id,LP1,LP2,pcontig->MapPhase[m],MX[m]);
	printf("\t Hcuts[(ifirst=%d)..(ilast=%d)] = %0.3f .. %0.3f\n",ifirst,ilast,Hcuts[ifirst],Hcuts[ilast]);
	printf("\t Hcuts[%d..%d]= %0.3f .. %0.3f : sumA = %0.3f -> %0.3f\n",first,last,Hcuts[first],Hcuts[last],sumA, sumA + Hcuts[last]-Hcuts[first]);
	for(int j = 1; j <= MX[m]; j++){
	  int I = nmap1[m][j];
	  if(I < 0)
	    continue;
	  int K = nmapK1[m][j];
	  int i = nmap1[MD][I];
	  int k = nmap1[MD][I-K];
	  printf("\tj=%d/%d:I=%d,K=%d:i=%d,k=%d,n=%d\n",j,MX[m],I,K,i,i-k,n);
	}
	fflush(stdout);
      }
      if(last >= first)
	sumA += Hcuts[last] - Hcuts[first];
    }
    if(pcontig->MapPhase[m] < 0.3 /* WAS149 > 0.7 */){  /* locate range of aligned labels for map m in Allele2 */
      int first = n+1,last = 0;
      for(int j = 1; j <= MX[m]; j++){
	int I = nmap2[m][j];
	if(I < 0)
	  continue;
	int K = nmapK2[m][j];
	if(DEBUG) assert(K >= 0);
	int k = nmap2[MD][I-K];
	if(DEBUG) assert(1 <= k && k <= n);
	first = max(k,ifirst);
	break;
      }
      for(int j = MX[m]; j >= 1; j--){
	int I = nmap2[m][j];
	if(I < 0)
	  continue;
	int i = nmap2[MD][I];
	if(DEBUG) assert(1 <= i && i <= n);
	last = min(i,ilast);
	break;
      }
      if((VERB>=2 && gmap[pcontig->contig[m].mapid]->id == 18585) || (DEBUG>=2 && !(last >= first))){
	printf("m=%d,id=%lld:LP1=%0.6f,LP2=%0.6f:MapPhase[m]=%0.6f,M=%d\n",m,gmap[pcontig->contig[m].mapid]->id,LP1,LP2,pcontig->MapPhase[m],MX[m]);
	printf("\t Hcuts[(ifirst=%d)..(ilast=%d)] = %0.3f .. %0.3f\n",ifirst,ilast,Hcuts[ifirst],Hcuts[ilast]);
	printf("\t Hcuts[(first=%d)..(last=%d)]= %0.3f .. %0.3f : sumB = %0.3f -> %0.3f\n",first,last,Hcuts[first],Hcuts[last],sumB, sumB + Hcuts[last]-Hcuts[first]);
	int tfirst = n+1, tlast = 0;
	for(int j = 1; j <= MX[m]; j++){
	  int I = nmap2[m][j];
	  if(I < 0)
	    continue;
	  int K = nmapK2[m][j];
	  int i = nmap2[MD][I];
	  int k = nmap2[MD][I-K];
	  tfirst = max(k,ifirst);
	  printf("\tj=%d/%d:I=%d,K=%d:i=%d,k=%d,n=%d:tfirst=%d\n",j,MX[m],I,K,i,i-k,n,tfirst);
	}
	printf("Repeating in reverse direction:\n");
	for(int j = MX[m]; j >= 1; j--){
	  int I = nmap2[m][j];
	  if(I < 0)
	    continue;
	  int i = nmap2[MD][I];
	  if(DEBUG) assert(1 <= i && i <= n);
	  tlast = min(i,ilast);
	  printf("\tj=%d/%d:I=%d,i=%d,n=%d: tlast=%d\n",j,MX[m],I,i,n,tlast);
	  break;
	}
	fflush(stdout);
      }
      if(last >= first)
	sumB += Hcuts[last] - Hcuts[first];
    }
  }
  double covAav = sumA / max(0.001,Hcuts[ilast] - Hcuts[ifirst]);
  double covBav = sumB / max(0.001,Hcuts[ilast] - Hcuts[ifirst]);

  if(VERB){
    printf("%d/%d maps could be phased with 90%% certainty or better to one of two alleles (cnt1=%d,cnt2=%d)\n",cnt1+cnt2,MD,cnt2,cnt1);
    printf("%d/%d maps could be phased with 70%% certainty or better to one of two alleles (cnt1=%d,cnt2=%d):covA= %0.2f, covB= %0.2f, Hcuts[%d..%d]=%0.3f..%0.3f\n",
	   cnt3+cnt4,MD,cnt4,cnt3,covAav,covBav,ifirst,ilast,Hcuts[ifirst],Hcuts[ilast]);
    if(VERB/* HERE >=2 */){
      printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
      printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    }
    fflush(stdout);
  }

  double origPoutlierEnd = PoutlierEnd;
  if(PoutlierEnd < PoutlierEndFinal){
    if(VERB){
      printf("Before Final UpdateMap() with HaploType: PoutlierEnd = %0.3e->%0.3e, RANGE_Y=%d\n", PoutlierEnd,PoutlierEndFinal,RANGE_Y2);
      fflush(stdout);
    }
    PoutlierEnd = PoutlierEndFinal;
    score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd & Poutlier */
  }
  if(biasWTrefine != biasWT){
    if(VERB){
      printf("Restored biasWT= %0.6f -> %0.6f for final UpdateMap()\n",biasWT,biasWTrefine);
      fflush(stdout);
    }
    biasWT = biasWTrefine;
    score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd, Poutlier OR biasWT */
  }

  if(VERB/* HERE >=2 */){
    printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same: cum wall time= %0.6f\n",HapSite, pcontig->HapSite[0],wtime());
    printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    fflush(stdout);
  }
  if(VERB>=2){
    printf("pcontig=%p,pcontig->HapDelta[0]=%p,n=%d\n",pcontig,pcontig->HapDelta[0],n);
    for(int i = 1; i < n; i++)
      if(pcontig->HapDelta[0][i])
	printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
    fflush(stdout);
  }

  hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
  if(VERB/* HERE >=2 */){
    printf("After hsetmap: HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
    printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    fflush(stdout);
  }

  //  rverb = 1;

  if(SETLIMIT_CACHE)// NEW140: reset cache
    for(int m = 0; m < MD; m++)
      limit1[m].ileft = limit2[m].ileft = -1;

  hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
		  TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,logPV1,logPV2,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
  rverb = 0;
  if(VERB/* HERE >=2 */){
    printf("After hprobeval: HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
    printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    fflush(stdout);
  }
  if(VERB){
    printf("Before Final UpdateMap with HaploType: hLP=%0.6f -> %0.6f (PoutlierEnd=%0.3e,PRbiasWT=%0.3e): cum wall= %0.6f\n",newLP,hLP,PoutlierEnd,PRbiasWT,wtime());
    fflush(stdout);
  }
  newLP = hLP;
  
  if(RefineEndOutlierThreshold < 2 && RefineEndOutlierWt < 1.0 && RefineEndOutlierType==0){/* recompute TBmapWT[] */
    printf("-Erefine not yet implemented with -Haplotype\n");
    exit(1);
  }

  if((DEBUG && !(HapSite == pcontig->HapSite[0])) || VERB>=2){
    printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
    printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    fflush(stdout);
    //    assert(HapSite == pcontig->HapSite[0]);// NOTE : fails on MIC for unknown reasons
  }

  int MinHapCovThreshPassed = min(covAav,covBav) >= MinHapCovThresh;
  int MinHapRelCovThreshPassed = min(covAav,covBav)/max(covAav+covBav,0.001) >= MinHapRelCovThresh;

  int HapSiteWinPassed = (SNPcnt < HapSiteWin) ? 0 : -1;
  int HapSiteWinMax = 0;
  if(CMapID && /* MinHapCovThreshPassed && MinHapRelCovThreshPassed && */HapSiteWin >= 2 && SNPcnt >= HapSiteWin){/* check if SNP Density threshold was exceeded based on at least HapSiteWin SNPs in some window of HapSiteWinSize kb */
    HapSiteWinPassed = 0;
    int HapSiteImax = -1;
    int HapSiteRmax = -1;

    /* check each interval starting at any SNP, but exclude end SNPs beyond the first or last non-SNP label */
    int ifirst = 1, ilast = n;
    if(HapIndelSkipEndSNP){
      for(;ifirst < ilast;ifirst++)
	if(HapSite[ifirst] == 3)
	  break;
      for(;ifirst < ilast;ilast--)
	if(HapSite[ilast] == 3)
	  break;
    }
      
    for(int i = ifirst; i <= ilast - HapSiteWin + 1; i++){
      if(HapSite[i]==0 || HapSite[i] == 3)
	continue;
      
      int cnt = 1, j = i+1, R = i;
      for(; j <= ilast && Hcuts[j] - Hcuts[i] < HapSiteWinSize; j++)
	if(HapSite[j]==1 || HapSite[j]==2){
	  R = j;
	  cnt++;
	}
      
      if(cnt > HapSiteWinMax){
	HapSiteWinMax = cnt;
	HapSiteImax = i;
	HapSiteRmax = R;
      }
      if(cnt >= HapSiteWin){
	HapSiteWinPassed = cnt;
	// WAS115	break;
      }
    }
    if(HapSiteWinMax > 0 && HapSiteImax >= 1){
      int i = HapSiteImax;
      int R = HapSiteRmax;
      int cnt = HapSiteWinMax;
      if(VERB/* HERE HERE >=2 */){
	printf("CMapID= %lld:Found %d SNPs within %0.1f kb from Hcuts[%d]= %0.4f to Hcuts[%d]= %0.4f (Hcuts[%d,%d,n+1]= %0.4f,%0.4f,%0.4f)\n",
	       CMapID, cnt, HapSiteWinSize, i, Hcuts[i], R, Hcuts[R], ifirst,ilast,Hcuts[ifirst],Hcuts[ilast],Hcuts[n+1]);
	for(int t = i; t <= R; t++)
	  if(HapSite[t]==1 || HapSite[t]==2)
	    printf("t=%d : Hcuts[t]= %0.4f, HapSite[t]=%d\n",t, Hcuts[t], HapSite[t]);
	fflush(stdout);
      }
    }
    if(VERB/* HERE HERE >=2 */ && HapSiteWinPassed==0){
      printf("CMapID= %lld: Did not find %d SNPs within %0.1f kb (Hcuts[n+1]= %0.4f): only %d SNPs found within that distance\n",
	     CMapID, HapSiteWin, HapSiteWinSize, Hcuts[n+1],HapSiteWinMax);
      fflush(stdout);
    }
  }
  
  double HapIndelAbsSum = 0.0;
  if(HapIndelMinSum > 0.0)
    for(int i = 0; i <= n;i++)
      HapIndelAbsSum += fabs(HapDelta[i]) * 2.0;

  if(VERB){
    printf("CMapID=%lld:SNPcnt=%d,IndelCnt=%d,HapSiteWinPassed= %d,max=%d HapIndelAbsSum= %0.4f(Len= %0.2f Mb),covA=%0.2f,covB=%0.2f(CovPassed=%d,RelCovPass=%d) : After -HapThresh %d %d %d %0.4f %0.4f %0.4f %0.3f %0.3f\n", 
	   CMapID,SNPcnt,IndelCnt,HapSiteWinPassed, HapSiteWinMax, HapIndelAbsSum, (Hcuts[Rfrozen ? Rfrozen : n+1]-Hcuts[Lfrozen])*0.001, covAav,covBav,MinHapCovThreshPassed,MinHapRelCovThreshPassed,
	   HapSiteMin, HapIndelMin,HapSiteWin,HapSiteWinSize, HapIndelMinSum, HapIndelMinDensity,MinHapCovThresh,MinHapRelCovThresh);
    if(VERB>=2){
      for(int i = 0; i <= n; i++)
	if(HapSite[i])
	  printf("i=%4d:HapSite=%d,HapDelta=%8.4f(tot=%8.4f),Delta=%8.4f,Hcuts=%9.4f,Hcuts1=%9.4f,Hcuts2=%9.4f,HapSiteScore=%7.2f,HapDeltaScore=%7.2f,HapSitePhase=%7.2f,HapDeltaPhase=%7.2f\n",
		 i,HapSite[i],HapDelta[i],HapDeltaMerged[i],Delta[i],Hcuts[i],Hcuts1[i],Hcuts2[i],HapSiteScore[i],HapDeltaScore[i],HapSitePhase[i],HapDeltaPhase[i]);
    }
    fflush(stdout);
  }


  if(CMapID && MinHapCovThreshPassed && MinHapRelCovThreshPassed && 
     ((SNPcnt >= HapSiteMin && HapSiteWinPassed) || (IndelCnt >= HapIndelMin && HapIndelAbsSum >= max(HapIndelMinSum, HapIndelMinDensity * (Hcuts[(Rfrozen ? Rfrozen : n+1)]-Hcuts[Lfrozen]) * 0.001)))){   /* output both alleles as CMAP along with HMAP */
  LbothAlleles:

    int *origHapSite = HapSite;
    HapSite = NULL;    /* hide HaploType information HapSite[] (as default to output separate Alleles) */
    if((DEBUG && !(HapSite == pcontig->HapSite[0])) || VERB>=2){
      printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
      printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
      fflush(stdout);
      assert(HapSite == pcontig->HapSite[0]);
    }

    /* save pcontig->sitemap[0],sitemapL[0] */
    int **origsitemap = pcontig->sitemap[0];
    int **origsitemapL = pcontig->sitemapL[0];
    int *origHdel = pcontig->Hdel[0];
    if(DEBUG && Hcuts != pcontig->site[0]){
      printf("Hcuts=%p, pcontig->site[0]=%p (they should be the same)\n",Hcuts,pcontig->site[0]);
      printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
      fflush(stdout);
      assert(Hcuts == pcontig->site[0]);
    }
    double *origsite = pcontig->site[0];
    int **outlier = pcontig->outlier[0];
    double *logPV = pcontig->logPV;

    /* save original coverage arrays sitecnt[],sitecntFN[],fragcnt[],fragcntT[] */
    float *origsitecnt = pcontig->sitecnt[0];
    float *origsitecntFN = pcontig->sitecntFN[0];
    float *origsitecntN1[MAX_CHIM];
    for(int t = 0; t < mCNT; t++)
      origsitecntN1[t] = pcontig->sitecntN1[0][t];
    float *origfragcnt = pcontig->fragcnt[0];
    float *origfragcntT = pcontig->fragcntT[0];
    float *origfragcntTnorm = 0, *origsitecntFNnorm = 0;
    if(CovNorm) origfragcntTnorm = pcontig->fragcntTnorm[0];
    if(TrimNorm>=0) origsitecntFNnorm = pcontig->sitecntFNnorm[0];

    float *sitecnt1 = new float[n+1];
    float *sitecnt2 = new float[n+1];
    float *sitecntFN1 = new float[n+2];
    float *sitecntFN2 = new float[n+2];
    float *sitecntN1_1[MAX_CHIM] = {NULL}, *sitecntN1_2[MAX_CHIM] = {NULL};
    if(mCNT > 0){
      sitecntN1_1[0] = new float[(n+2)*mCNT];
      sitecntN1_2[0] = new float[(n+2)*mCNT];
      for(int t = 1; t < mCNT; t++){
	sitecntN1_1[t] = sitecntN1_1[0] + (n+2)*t;
	sitecntN1_2[t] = sitecntN1_1[0] + (n+2)*t;
      }
    }
    float *fragcnt1 = new float[n+2];
    float *fragcnt2 = new float[n+2];
    float *fragcntT1 = new float[n+2];
    float *fragcntT2 = new float[n+2];
    float *fragcntTnorm1 = new float[n+2];
    float *fragcntTnorm2 = new float[n+2];
    float *sitecntFNnorm1 = new float[n+2];
    float *sitecntFNnorm2 = new float[n+2];

    /* Allele 1 */
    pcontig->sitemap[0] = map1;
    pcontig->sitemapL[0] = mapK1;
    for(int m = 0; m < MD; m++){
      if(HapMapWT>=3)
	pcontig->mapWT[m] = min(1.0, 2.0 * pcontig->MapPhase[m]);    /* Just use adjusted MapPhase[] */
      else if(HapMapWT>=2)
	pcontig->mapWT[m] = min(1.0, 2.0 * pcontig->MapPhase[m]) * mapWT1[m];    /* merge mapWT1[]  and adjusted MapPhase[] */
      else if(HapMapWT)
	pcontig->mapWT[m] = min(1.0, 2.0 * pcontig->MapPhase[m]) * mapWT1[m] * TBmapWT[m];    /* merge TBmapWT[] with mapWT1[]  and adjusted MapPhase[] */
      else
	pcontig->mapWT[m] = pcontig->MapPhase[m] * mapWT1[m] * TBmapWT[m];    /* merge TBmapWT[] with mapWT1[]  and MapPhase[]*/
      if(VERB>=2){
	printf("m=%d/%d:id=%lld,MapPhase[m]= %0.6f, mapWT1[m]= %0.6f, TBmapWT[m]= %0.6f: pcontig->mapWT[m]= %0.6f\n",m,MD,gmap[pcontig->contig[m].mapid]->id,pcontig->MapPhase[m],mapWT1[m],TBmapWT[m],pcontig->mapWT[m]);
	fflush(stdout);
      }
      if(DEBUG && !isfinite(pcontig->mapWT[m])){
	printf("m=%d/%d:mapWT1[m]= %0.6e, TBmapWT[m]= %0.6e, pcontig->MapPhase[m]= %0.6e : pcontig->mapWT[m]= %0.6e\n",
	       m,MD,mapWT1[m],TBmapWT[m],pcontig->MapPhase[m], pcontig->mapWT[m]);
	fflush(stdout);
	assert(isfinite(pcontig->mapWT[m]));
      }
    }
    pcontig->Hdel[0] = Hdel1;
    pcontig->site[0] = Hcuts1;
    
    pcontig->logPV = logPV1;
    pcontig->outlier[0] = outlier1;

    pcontig->sitecnt[0] = sitecnt1;
    pcontig->sitecntFN[0] = sitecntFN1;
    for(int t = 0; t < mCNT; t++)
      pcontig->sitecntN1[0][t] = sitecntN1_1[t];
    pcontig->fragcnt[0] = fragcnt1;
    pcontig->fragcntT[0] = fragcntT1;
    if(CovNorm) pcontig->fragcntTnorm[0] = fragcntTnorm1;
    if(TrimNorm>=0) pcontig->sitecntFNnorm[0] = sitecntFNnorm1;

    if(VERB/* HERE >=2 */){
      printf("Calling Final UpdateMap for Allele 1:\n");
      fflush(stdout);
    }

    //    updateVerb = 1; // HERE HERE 

    UpdateMap(n, N1, Y1, MD, MX, X, Hcuts1, Hdel1, map1, mapK1, limit1, nmap1, nmapK1, pcontig->mapWT, pcontig, FILL_HMAP);

    updateVerb = 0;
    if(DEBUG>=2){/* check that map1[m] and mapK1[m] only map to sites i with origHapSite[i] != 0 */
      for(int m = 0; m < MD; m++){
	int M = MX[m];
	for(int J = 1; J <= M; J++){
	  int i = map1[m][J];
	  if(i >= 0){
	    assert(origHapSite[i] != 0);
	    int k = mapK1[m][J];
	    assert(k >= 0 && i-k > 0 && origHapSite[i-k] != 0);
	  }
	}
      }
    }

    for(int k = 0; k < MD; k++)
      for(int j = 0; j <= MX[k]+1; j++)
	mapK1[k][j] = map1[k][j] - mapK1[k][j];
    output_draft(pcontig, -CMapID, draft_prefix, origLfrozen, origRfrozen, 1/* Allele*/);
    for(int k = 0; k < MD; k++)
      for(int j = 0; j <= MX[k]+1; j++)
	mapK1[k][j] = map1[k][j] - mapK1[k][j];

    /* Allele 2 */
    pcontig->sitemap[0] = map2;
    pcontig->sitemapL[0] = mapK2;
    for(int m = 0; m < MD; m++){
      if(HapMapWT>=3)
	pcontig->mapWT[m] = min(1.0, 2.0 * (1.0 - pcontig->MapPhase[m]));    /* just use adjusted MapPhase[]*/
      else if(HapMapWT>=2)
	pcontig->mapWT[m] = min(1.0, 2.0 * (1.0 - pcontig->MapPhase[m])) * mapWT2[m];    /* merge mapWT1[] and adjusted MapPhase[]*/
      else if(HapMapWT)
	pcontig->mapWT[m] = min(1.0, 2.0 * (1.0 - pcontig->MapPhase[m])) * mapWT2[m] * TBmapWT[m];    /* merge TBmapWT[] with mapWT1[] and adjusted MapPhase[]*/
      else
	pcontig->mapWT[m] = (1.0 - pcontig->MapPhase[m]) * mapWT2[m] * TBmapWT[m];    /* merge TBmapWT[] with mapWT1[] and MapPhase[]*/
      if(VERB>=2){
	printf("m=%d/%d:id=%lld:MapPhase[m]= %0.6f, mapWT2[m]= %0.6f, TBmapWT[m]= %0.6f: pcontig->mapWT[m]= %0.6f\n",m,MD,gmap[pcontig->contig[m].mapid]->id,pcontig->MapPhase[m],mapWT2[m],TBmapWT[m],pcontig->mapWT[m]);
	fflush(stdout);
      }
      if(DEBUG && !isfinite(pcontig->mapWT[m])){
	printf("m=%d/%d:mapWT2[m]= %0.6e, TBmapWT[m]= %0.6e, pcontig->MapPhase[m]= %0.6e : pcontig->mapWT[m]= %0.6e\n",
	       m,MD,mapWT2[m],TBmapWT[m],pcontig->MapPhase[m], pcontig->mapWT[m]);
	fflush(stdout);
	assert(isfinite(pcontig->mapWT[m]));
      }
    }
    pcontig->Hdel[0] = Hdel2;
    pcontig->site[0] = Hcuts2;
    pcontig->logPV = logPV2;
    pcontig->outlier[0] = outlier2;

    pcontig->sitecnt[0] = sitecnt2;
    pcontig->sitecntFN[0] = sitecntFN2;
    for(int t = 0; t < mCNT; t++)
      pcontig->sitecntN1[0][t] = sitecntN1_2[t];
    pcontig->fragcnt[0] = fragcnt2;
    pcontig->fragcntT[0] = fragcntT2;
    if(CovNorm) pcontig->fragcntTnorm[0] = fragcntTnorm2;
    if(TrimNorm>=0) pcontig->sitecntFNnorm[0] = sitecntFNnorm2;

    if(VERB/* HERE >=2 */){
      printf("Calling Final UpdateMap for Allele 2:\n");
      fflush(stdout);
    }

    //    updateVerb = 1;

    UpdateMap(n, N2, Y2, MD, MX, X, Hcuts2, Hdel2, map2, mapK2, limit2, nmap2, nmapK2, pcontig->mapWT, pcontig, FILL_HMAP);
    
    updateVerb = 0;
    if(DEBUG>=2){/* check that map2[m] and mapK2[m] only map to sites i with origHapSite[i] != 0 */
      for(int m = 0; m < MD; m++){
	int M = MX[m];
	for(int J = 1; J <= M; J++){
	  int i = map2[m][J];
	  if(i >= 0){
	    assert(origHapSite[i] != 0);
	    int k = mapK2[m][J];
	    assert(k >= 0 && i-k > 0 && origHapSite[i-k] != 0);
	  }
	}
      }
    }

    for(int k = 0; k < MD; k++)
      for(int j = 0; j <= MX[k]+1; j++)
	mapK2[k][j] = map2[k][j] - mapK2[k][j];
    output_draft(pcontig, -CMapID, draft_prefix, origLfrozen, origRfrozen, 2/* Allele*/);
    for(int k = 0; k < MD; k++)
      for(int j = 0; j <= MX[k]+1; j++)
	mapK2[k][j] = map2[k][j] - mapK2[k][j];

    HapSite = origHapSite;    /* restore HaploType information HapSite[] */
    if((DEBUG && !(HapSite == pcontig->HapSite[0])) || VERB>=2){
      printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
      printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
      fflush(stdout);
      assert(HapSite == pcontig->HapSite[0]);
    }

    /* restore pcontig->sitemap[0],sitemapL[0] */
    pcontig->sitemap[0] = origsitemap;
    pcontig->sitemapL[0] = origsitemapL;
    pcontig->Hdel[0] = origHdel;
    pcontig->site[0] = origsite;
    pcontig->logPV = logPV;
    pcontig->outlier[0] = outlier;

    pcontig->sitecnt[0] = origsitecnt;
    pcontig->sitecntFN[0] = origsitecntFN;
    for(int t = 0; t < mCNT; t++)
      pcontig->sitecntN1[0][t] = origsitecntN1[t];
    pcontig->fragcnt[0] = origfragcnt;
    pcontig->fragcntT[0] = origfragcntT;
    if(CovNorm) pcontig->fragcntTnorm[0] = origfragcntTnorm;
    if(TrimNorm>=0) pcontig->sitecntFNnorm[0] = origsitecntFNnorm;

    /* update map[],mapK[],mapWT[],outlier[] based on (updated) map1[],mapK1[],map2[],mapK2[] and which haplotype matches each molecule best : improves consensus HMAP output */
    for(int m = 0; m < MD; m++){
      int M = MX[m];
      pcontig->mapWT[m] = (pcontig->MapPhase[m]*mapWT1[m] + (1.0-pcontig->MapPhase[m])*mapWT2[m]) * TBmapWT[m];
      if(DEBUG && !isfinite(pcontig->mapWT[m])){
	printf("m=%d/%d:mapWT1[m]= %0.6e, mapWT2[m]= %0.6e, TBmapWT[m]= %0.6e, pcontig->MapPhase[m]= %0.6e : pcontig->mapWT[m]= %0.6e\n",
	       m,MD,mapWT1[m],mapWT2[m],TBmapWT[m],pcontig->MapPhase[m], pcontig->mapWT[m]);
	fflush(stdout);
	assert(isfinite(pcontig->mapWT[m]));
      }
      if(pcontig->MapPhase[m] >= 0.5){/* Allele == 1 */
	memcpy(pcontig->sitemap[0][m],map1[m],(M+2)*sizeof(int));
	memcpy(pcontig->sitemapL[0][m],mapK1[m],(M+2)*sizeof(int));
	memcpy(pcontig->outlier[0][m],outlier1[m],(M+2)*sizeof(int));
	if(DEBUG>=2){/* check that map[m] and mapK[m] only map to sites i with HapSite[0][i] != 0 */
	  for(int J = 1; J <= M; J++){
	    int i = pcontig->sitemap[0][m][J];
	    if(i >= 0){
	      assert(HapSite[i] != 0);
	      int k = pcontig->sitemapL[0][m][J];
	      assert(k >= 0 && i-k > 0 && HapSite[i-k] != 0);
	    }
	  }
	}
	memcpy(pcontig->outlier[0][m],outlier1[m],(M+1)*sizeof(int));
	pcontig->logPV[m] = logPV1[m];
	pcontig->LP[m] = bestLPA1[m];
      } else {/* Allele == 2 */
	memcpy(pcontig->sitemap[0][m],map2[m],(M+2)*sizeof(int));
	memcpy(pcontig->sitemapL[0][m],mapK2[m],(M+2)*sizeof(int));
	memcpy(pcontig->outlier[0][m],outlier2[m],(M+2)*sizeof(int));
	if(DEBUG>=2){/* check that map[m] and mapK[m] only map to sites i with HapSite[0][i] != 0 */
	  for(int J = 1; J <= M; J++){
	    int i = pcontig->sitemap[0][m][J];
	    if(i >= 0){
	      assert(HapSite[i] != 0);
	      int k = pcontig->sitemapL[0][m][J];
	      assert(k >= 0 && i-k > 0 && HapSite[i-k] != 0);
	    }
	  }
	}
	memcpy(pcontig->outlier[0][m],outlier2[m],(M+1)*sizeof(int));
	pcontig->logPV[m] = logPV2[m];
	pcontig->LP[m] = bestLPA2[m];
      }
    }

    for(int i = 1; i <= n; i++)
      pcontig->sitecnt[0][i] = sitecnt1[i] + sitecnt2[i];
    for(int i = 0; i <= n+1; i++){
      pcontig->sitecntFN[0][i] = sitecntFN1[i] + sitecntFN2[i];
      for(int t = 0; t < mCNT; t++)
	pcontig->sitecntN1[0][t][i] = sitecntN1_1[t][i] + sitecntN1_2[t][i];
      pcontig->fragcnt[0][i] = fragcnt1[i] + fragcnt2[i];
      pcontig->fragcntT[0][i] = fragcntT1[i] + fragcntT2[i];
      if(CovNorm){
	pcontig->fragcntTnorm[0][i] = fragcntTnorm1[i] + fragcntTnorm2[i];
	if(DEBUG) assert(isfinite(pcontig->fragcntTnorm[0][i]));
      }
      if(TrimNorm >= 0) pcontig->sitecntFNnorm[0][i] = sitecntFNnorm1[i] + sitecntFNnorm2[i];
    }
    
    delete [] sitecnt1;
    delete [] sitecnt2;
    delete [] sitecntFN1;
    delete [] sitecntFN2;
    if(mCNT > 0){
      delete [] sitecntN1_1[0];
      delete [] sitecntN1_2[0];
    }
    delete [] fragcnt1;
    delete [] fragcnt2;
    delete [] fragcntT1;
    delete [] fragcntT2;
    delete [] fragcntTnorm1;
    delete [] fragcntTnorm2;
    delete [] sitecntFNnorm1;
    delete [] sitecntFNnorm2;

    for(int k = 1; k <= n; k++)
      pcontig->Hdel[0][k] = (HapSite[k] ? 0 : 1);
    if((DEBUG && !(HapSite == pcontig->HapSite[0])) || VERB>=2){
      printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n",HapSite, pcontig->HapSite[0]);
      printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
      fflush(stdout);
      assert(HapSite == pcontig->HapSite[0]);
    }
    
    if(VERB>=2){
      printf("After Allele 1 & 2 output: pcontig=%p,pcontig->HapDelta[0]=%p,n=%d\n",pcontig,pcontig->HapDelta[0],n);
      for(int i = 1; i < n; i++)
	if(pcontig->HapDelta[0][i])
	  printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
      fflush(stdout);
    }
    if(0){/* concentrate HapDelta[] values next to Labels with HapSite[i] == 3 (MAY CAUSE PROBLEMS interpreting the .hmap file) */
      int cnt = 0;
      for(int i = imin; i <= imax; i++){
	if(HapSite[i] == 3 && HapDeltaMerged[i]){
	  cnt++;
	  HapDelta[i] = HapDeltaMerged[i];
	} else
	  HapDelta[i] = 0.0;
      }

      if(VERB){
	printf("Merged HapIndel[] values into %d Hap Indels\n", cnt);
	fflush(stdout);
      }

    }
    if(VERB>=2){
      printf("Before .hmap output:\n");
      for(int i = 1; i <= n; i++)
	if(HapSite[i] /* && (HapSite[i] <=  2 || HapDelta[i]) */)
	  printf("i=%d:HapSite[i]=%d,HapDelta[i]=%0.4f,Hcuts[i]=%0.4f,HapSiteScore[i]=%0.2f,SiteScore[i]=%0.2f,HapDeltaScore[i]=%0.2f\n",
		 i,HapSite[i],HapDelta[i],Hcuts[i],HapSiteScore[i],SiteScore[i],HapDeltaScore[i]);
      fflush(stdout);
    }
  } else { /* no Haplotype output : output just one CMAP */
    if(VERB){
      printf("Reverting to non-Haplotype output : due to SNPcnt=%d,IndelCnt=%d & (max %d SNPs per %0.4f kb), IndelAbsSum= %0.3f, covA=%0.2f,covB=%0.2f being below -HapThresh %d %d %d %0.4f %0.4f %0.4f %0.3f %0.3f\n", 
	     SNPcnt,IndelCnt,HapSiteWinMax,HapSiteWinSize, HapIndelAbsSum, covAav, covBav, 
	     HapSiteMin, HapIndelMin,HapSiteWin,HapSiteWinSize, HapIndelMinSum, HapIndelMinDensity,MinHapCovThresh,MinHapRelCovThresh);
      fflush(stdout);
    }

    if((DEBUG && !(HapSite == pcontig->HapSite[0])) || VERB>=2){
      printf("HapSite=%p, pcontig->HapSite[0]=%p :they should be the same\n",HapSite, pcontig->HapSite[0]);
      printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
      fflush(stdout);
      assert(HapSite == pcontig->HapSite[0]);
    }

    if(IndelCnt > 0){/* first need to undo Indels */
      if(VERB){
	printf("Removing %d Indels:\n",IndelCnt);
	fflush(stdout);
      }
      
      /* back up current results in case Indel removal fails in hsetmap() */
      int *origHapSite = new int[n+2];
      double *origHapDelta = new double[n+2];
      double *origDelta = new double[n+2];
      memcpy(origHapDelta,HapDelta,(n+2)*sizeof(double));
      memcpy(origDelta,Delta,(n+2)*sizeof(double));
      memcpy(origHapSite,HapSite,(n+2)*sizeof(int));      

      newLP = hLP;
      //      double orig_newLP = newLP;
      bool failed = false;

      for(int i = 0; i <= n; i++){
	if(i <= 0 || HapSite[i] == 3){
	  int RR = i+1;
	  while(RR <= n && HapSite[RR] != 3)
	    RR++;

	  /* recompute HapDeltaMerged[1..n] : Note that if (i==0 || RR==n+1) HapDelta[] may not all be the same sign */
	  double sum = 0.0, abssum = 0.0;
	  for(int t = i; t < RR; t++){
	    sum += HapDelta[t];
	    abssum += fabs(HapDelta[t]);
	  }
	  if(abssum < MIN_INDEL_SIZE)
	    abssum = sum = 0.0;
	  else if(fabs(sum) < MIN_INDEL_SIZE)
	    sum = copysign(MIN_INDEL_SIZE,sum);

	  for(int t = i; t < RR; t++)
	    HapDeltaMerged[t] = sum;

	  if(abssum == 0.0){
	    for(int t = i; t < RR; t++)
	      HapDeltaScore[t] = 0.0;
	    continue;
	  }

	  double origHapDelta = HapDelta[i];

	  /* try to remove each Haplotype group HapDelta[i..RR-1] by calling hprobeval() and update the corresponding HapDeltaScore[] values */
	  memcpy(&prevHapDelta[i],&HapDelta[i],(RR-i)*sizeof(double));
	  memcpy(&prevDelta[i],&Delta[i],(RR-i)*sizeof(double));
	  if(HAPINDELDELETE_FIX)
	    memcpy(&prevHapSite[i+1],&HapSite[i+1],(RR-i-1)*sizeof(int));

	  if(VERB>=1+RELEASE/* HERE >=2 */){
	    printf("Testing removal of HapIndel[%d..%d] = %0.6f (Hcuts= %0.4f .. %0.4f)\n", i, RR, HapDeltaMerged[i],Hcuts[i],Hcuts[RR]);
	    fflush(stdout);
	  }

	  double bestLP = newLP - BigPen, nLP;
	  int bestAllele = 3;
	  int bestSNPs = SNPcnt, bestIndels = IndelCnt;

	  for(int t = i; t < RR; t++)
	    HapDelta[t] = 0.0;

	  int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */
	  if(err){
	    if(VERB>=1+RELEASE/* HERE >=2 */){
	      printf("Averaged removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
	      fflush(stdout);
	    }
	    bestAllele = -1;
	  } else {
	    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    if(VERB/* HERE >=2 */){
	      printf("Averaged removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs = %d, Indels=%d: wtime= %0.6f\n", 
		     i, RR, HapDeltaMerged[i], nLP, nLP > newLP ? '!':' ', nLP-newLP, SNPs, Indels,wtime());
	      fflush(stdout);
	    }
	    bestLP = nLP;
	    bestSNPs = SNPs;
	    bestIndels = Indels;
	    if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){
	      /* swap newLPA and bestLPA */
	      double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
	      tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	    }
	  }

	  /* next try changing only Allele 1 */
	  for(int t = i; t < RR; t++)
	    Delta[t] = prevDelta[t] - prevHapDelta[t];
	  if(HAPINDELDELETE_FIX){ // need to also change HapSite[i+1..RR-1] to match Allele 2 : HapSite 1 -> 0, 2 -> 3 
	    for(int t = i+1; t < RR; t++){
	      if(HapSite[t] == 1)
		HapSite[t] = 0;
	      else if(HapSite[t] == 2)
		HapSite[t] = 3;
	    }
	    for(int t = RR; --t > i;){
	      if(!HapSite[t]){
		Delta[t-1] += Delta[t];
		Delta[t] = 0.0;
	      }
	    }
	  }

	  err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
	  if(err){
	    if(VERB>=1+RELEASE/* HERE >=2 */){
	      printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
	      fflush(stdout);
	    }
	  } else {
	    //		rverb = (iter >= 11 && i==32675 && RR==32787) ? 1 : 0;
	    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    rverb = 0;
	    if(VERB/* HERE >=2 */){
	      printf("\t Allele1 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime=%0.6f\n",
		     i,RR,HapDeltaMerged[i], nLP, nLP > max(bestLP,newLP) ? '!':' ',nLP - newLP, SNPs,Indels,wtime());
	      //		  printf("\t Hcuts1[%d..%d]=%0.3f .. %0.3f, Hcuts2[%d..%d]=%0.3f..%0.3f\n",i,RR,Hcuts1[i],Hcuts1[RR],i,RR,Hcuts2[i],Hcuts2[RR]);
	      fflush(stdout);
	    }
	    if(nLP > bestLP || bestAllele == -1){
	      bestLP = nLP;
	      bestSNPs = SNPs;
	      bestIndels = Indels;
	      bestAllele = 1;
	      if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
		double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	      }
	    }
	  }

	  /* next try changing only Allele 2 */
	  for(int t = i; t < RR; t++)
	    Delta[t] = prevDelta[t] + prevHapDelta[t];
	  if(HAPINDELDELETE_FIX){	      // need to also change HapSite[i+1..RR-1] to match Allele 1 : HapSite 1 -> 3, 2 -> 0 
	    for(int t = i+1; t < RR; t++){
	      HapSite[t] = prevHapSite[t];
	      if(HapSite[t] == 1)
		HapSite[t] = 3;
	      else if(HapSite[t] == 2)
		HapSite[t] = 0;
	    }
	    for(int t = RR; --t > i;){
	      if(!HapSite[t]){
		Delta[t-1] += Delta[t];
		Delta[t] = 0.0;
	      }
	    }
	  }

	  err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate haplotype map pair */	      
	  if(err){
	    if(VERB>=1+RELEASE/* HERE >=2 */){
	      printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f failed due to hsetmap\n",i,RR,HapDeltaMerged[i]);
	      fflush(stdout);
	    }
	  } else {
	    //	        rverb = 0;// ((i==40956 && RR==40991) || (i==41391 && RR==41431)) ? 1 : 0;
	    if(VERB && rverb){
	      printf("After Allele2 only removal of HapIndel[%d..%d] = %0.6f\n",i,RR,HapDeltaMerged[i]);
	      fflush(stdout);
	    }

	    nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
			    TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[i],Hcuts1[RR],Hcuts2[i],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	    rverb = 0;
	    if(VERB/* HERE >=2 */){
	      printf("\t Allele2 only removal of HapIndel[%d..%d] = %0.6f : nLP = %0.6f%c (delta = %0.6f), SNPs=%d, Indels=%d: wtime= %0.6f\n",
		     i,RR,HapDeltaMerged[i], nLP, nLP > max(bestLP,newLP) ? '!' : ' ', nLP - newLP, SNPs,Indels,wtime());
	      fflush(stdout);
	    }
	    if(nLP > bestLP || bestAllele == -1){
	      bestLP = nLP;
	      bestSNPs = SNPs;
	      bestIndels = Indels;
	      bestAllele = 2;

	      if(bestLP > newLP && (HapIndelPvalue == origHapIndelPvalue || HapIndelPvalue < initHapIndelPvalue || iter >= HINDEL_REVERSE)){/* swap newLPA and bestLPA */
		double *tmp = newLPA1; newLPA1 = bestLPA1; bestLPA1 = tmp;
		tmp = newLPA2; newLPA2 = bestLPA2; bestLPA2 = tmp;
	      }
	    }
	  }

	  HapDeltaScore[i] = newLP - bestLP;
	  for(int t = i+1; t < RR; t++)
	    HapDeltaScore[t] = HapDeltaScore[i];

	  if(bestAllele != -1){/* confirm change & swap newLPA and bestLPA */
	    if(VERB){
	      printf("Removing HapDelta[%d..%d]= %0.4f .. %0.6f = %0.6f (HapDelta[i]=%0.6f): LP=%0.6f -> %0.6f, IndelCnt=%d -> %d, SNPs=%d\n", 
		     i,RR, Hcuts[i],Hcuts[RR],HapDeltaMerged[i], origHapDelta, newLP, bestLP, IndelCnt, bestIndels, bestSNPs);
	      fflush(stdout);
	    }
	    if(DEBUG) assert(bestAllele != -1);

	    newLP = bestLP;
	    IndelCnt = bestIndels;
	    SNPcnt = bestSNPs;
	    for(int t = i; t < RR; t++)
	      HapDeltaMerged[t] = 0.0;
	    if(bestAllele != 2){
	      if(bestAllele == 1){
		for(int t = i; t < RR; t++)
		  Delta[t] = prevDelta[t] - prevHapDelta[t];
		if(HAPINDELDELETE_FIX){
		  for(int t = i+1; t < RR; t++){
		    HapSite[t] = prevHapSite[t];
		    if(HapSite[t] == 1)
		      HapSite[t] = 0;
		    else if(HapSite[t] == 2)
		      HapSite[t] = 3;
		  }
		  for(int t = RR; --t > i;){
		    if(!HapSite[t]){
		      Delta[t-1] += Delta[t];
		      Delta[t] = 0.0;
		    }
		  }
		}
	      } else {
		for(int t = i; t < RR; t++)
		  Delta[t] = prevDelta[t];
		if(HAPINDELDELETE_FIX)
		  for(int t = i+1; t < RR; t++)
		    HapSite[t] = prevHapSite[t];
	      }
	    }
	  } else { /* restore original HapDelta */
	    memcpy(&HapDelta[i],&prevHapDelta[i], (RR - i)*sizeof(double));
	    memcpy(&Delta[i],&prevDelta[i],(RR-i)*sizeof(double));
	    if(HAPINDELDELETE_FIX)
	      memcpy(&HapSite[i+1],&prevHapSite[i+1],(RR-i-1)*sizeof(int));
	    
	    failed = true;
	    break;
	  }

	  if(VERB>=2){
	    double DeltaSum = 0.0;
	    for(int t = i; t < RR;t++)
	      DeltaSum += Delta[t];
	    printf("L=%d,R=%d:HapSite[L,R]=%d,%d,Hcuts[L]=%0.4f,Hcuts[L,R]=%0.4f,Delta[L,R]=%0.4f,HapDelta[L]=%0.4f(tot=%0.4f),HapDeltaScore=%0.2f\n",
		   i,RR,HapSite[i],HapSite[RR],Hcuts[i],Hcuts[RR]-Hcuts[i],DeltaSum,HapDelta[i],HapDeltaMerged[i],HapDeltaScore[i]);
	    fflush(stdout);
	  }
	}
      }// for int i = 0 .. n 

      if(failed){/* restore original HapSite & HapDelta and go back to Haplotype output */
	memcpy(HapDelta,origHapDelta,(n+2)*sizeof(double));
	memcpy(Delta,origDelta,(n+2)*sizeof(double));
	memcpy(HapSite,origHapSite,(n+2)*sizeof(int));      
      }
      
      delete [] origHapSite;
      delete [] origHapDelta;
      delete [] origDelta;

      /* verify full LP and select map1[m] or map2[m], whichever is better for each m */
      double wt1 = wtime();
      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
      if(SETLIMIT_CACHE)// NEW278: reset cache
	for(int m = 0; m < MD; m++)
	  limit1[m].ileft = limit2[m].ileft = -1;
      //      rverb = 1;
      double nLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			     TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,logPV1,logPV2,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,/* NEW276 */ 2);
      rverb = 0;
      if(VERB){
	double wt2 = wtime();
	if(failed)
	  printf("After failing to Remove Indels: hLP = %0.6f -> %0.6f SNPs=%d->%d,IndelCnt=%d->%d: wall time=%0.6f (cum= %0.6f)\n",
		 newLP,nLP,SNPcnt,SNPs,IndelCnt,Indels,wt2-wt1,wt2);
	else
	  printf("After Removing Indels: hLP = %0.6f -> %0.6f SNPs=%d->%d,IndelCnt=%d->%d: wall time=%0.6f (cum= %0.6f)\n",
		 newLP,nLP,SNPcnt,SNPs,IndelCnt,Indels,wt2-wt1,wt2);
	fflush(stdout);
      }

      hLP = newLP = nLP;
      SNPcnt = SNPs;
      IndelCnt = Indels;

      if(failed){
	if(VERB){
	  printf("Reverting to output of both Alleles\n");
	  fflush(stdout);
	}
	goto LbothAlleles;
      }

      /* need to recompute HapSiteScore[] */
      if(VERB/* HERE >=2 */){
	printf("Recomputing HapSiteScore[] & SiteScore[] for remaining %d SNPs\n", SNPcnt);
	fflush(stdout);
      }
      //    double HapSitePen[4] = {0.0,logHapSitePvalue - 0.5*SITE_PEN, logHapSitePvalue - 0.5*SITE_PEN, -SITE_PEN};      /* penalty as function of h or HapSite[i] */
      double SNPscore[4];

      for(int i = 1; i <= n; i++){
	if(HapSite[i] == 0 || HapSite[i] == 3)
	  continue;

	int L = i-1;
	while(L >= 1 && !HapSite[L])
	  L--;
	int R = i+1;
	while(R <= n && !HapSite[R])
	  R++;
	int LL = L, RR = R;
	while(LL >= 1 && HapSite[LL] != 3)
	  LL--;
	while(RR <= n && HapSite[RR] != 3)
	  RR++;

	int origHapSite = HapSite[i];

	/* need to save all HapDelta[LL .. RR-1] and Delta[LL .. RR-1] */
	memcpy(&prevHapDelta[LL],&HapDelta[LL],(RR-LL)*sizeof(double));
	memcpy(&prevDelta[LL],&Delta[LL],(RR-LL)*sizeof(double));
	memcpy(&prevHapSite[LL],&HapSite[LL],(RR-LL)*sizeof(int));

	if(VERB>=3){
	  printf("i=%d/%d:LL=%d,L=%d,R=%d,RR=%d:HapSite[i]=%d:Delta[L,i]=%0.3f,%0.3f,HapDelta[L,i]=%0.3f,%0.3f: recomputing HapSiteScore[i]=%0.6f, SiteScore[i]=%0.6f\n",
		 i,n,LL,L,R,RR,HapSite[i],Delta[L],Delta[i],HapDelta[L],HapDelta[i],HapSiteScore[i],SiteScore[i]);
	  fflush(stdout);
	}

	double wt1 = wtime();

	SNPscore[HapSite[i]] = newLP;
	SNPscore[3-HapSite[i]] = newLP - 99999.999999;

	for(int SNP = 0; SNP <= 3; SNP += 3){
	  HapSite[i] = SNP;
	  if(HINDEL && HPROBEVAL_SPREAD && !HapSite[i]){
	    Delta[L] += Delta[i];
	    HapDelta[L] += HapDelta[i];
	    HapDelta[i] = Delta[i] = 0.0;
	  }

	  // NOTE there is a small chance minKB restriction is violated due to previous change being too close to current change
	  int err = hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],1,spreadHapDelta,spreadDelta);/* generate consensus map pair */
	  //		rverb = (iter==35 && i==2639 && SNP==3) ? 1 : 0;
	  double nLP = err ? newLP - 99999.999999 : 
	    hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,0,0,
		      TBmapWT,newLPA1,newLPA2,mapWT1,mapWT2,bestLPA1,bestLPA2,Hcuts1[LL],Hcuts1[RR],Hcuts2[LL],Hcuts2[RR],0,0,0,0,newLPA,pcontig,numthreads,SNPs,Indels,0);
	  //		rverb = 0;
	  if(VERB>=3 || err){
	    printf("i=%d/%d:LL=%d,L=%d,R=%d,RR=%d,HapSite[i]=%d -> %d: LP= %0.6f -> %0.6f (err=%d)\n",i,n,LL,L,R,RR,origHapSite,HapSite[i],newLP, nLP,err);
	    fflush(stdout);
	  }
	  SNPscore[SNP] = nLP;// WAS  - HapSitePen[SNP];// NEW2

	  if(HINDEL && !HapSite[i]){
	    memcpy(&HapDelta[LL],&prevHapDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&Delta[LL],&prevDelta[LL],(RR-LL)*sizeof(double));
	    memcpy(&HapSite[LL],&prevHapSite[LL],(RR-LL)*sizeof(int));		
	    if(DEBUG) assert(HapSite[i] == origHapSite);
	  }
	  HapSite[i] = origHapSite;
	}
	      
	double origHapSiteScore = HapSiteScore[i], origSiteScore = SiteScore[i];

	HapSiteScore[i] = newLP - max(SNPscore[0], SNPscore[3]);
	SiteScore[i] = SNPscore[3] - SNPscore[0];
	if(VERB/* HERE >=2 */){
	  double wt = wtime();
	  printf("i=%d/%d:LL=%d,RR=%d:Hcuts[i]=%0.4f, HapSite[i]=%d: recomputed HapSiteScore[i]=%0.6f -> %0.6f, SiteScore[i]=%0.6f -> %0.6f (SNPscore=%0.6f,%0.6f,%0.6f,%0.6f, newLP=%0.6f):wall= %0.6f ( cum= %0.6f)\n",
		 i,n,LL,RR,Hcuts[i],HapSite[i],origHapSiteScore,HapSiteScore[i],origSiteScore,SiteScore[i],SNPscore[0],SNPscore[1],SNPscore[2],SNPscore[3],newLP,wt-wt1,wt);
	  fflush(stdout);
	}
      } // for(int i = 1; i <= n; i++)

    }// If (IndelCnt > 0)

    // In case of SNPs should add label only if it is better than NOT adding label
    for(int k = 1; k <= n; k++){
      if(1 <= HapSite[k] && HapSite[k] <= 2)// NEW112
	pcontig->Hdel[0][k] = (SiteScore[k] > 0.0) ? 0 : 1;
      else
	pcontig->Hdel[0][k] = (HapSite[k] ? 0 : 1);
    }

    if(VERB>=3){
      for(int k = 1; k <= n; k++)
	if(HapSite[k] || !pcontig->Hdel[0][k])
	  printf("Hcuts[%d]= %0.3f: Hdel=%d, HapSite=%d, HapSiteScore= %0.2f, SiteScore= %0.2f\n",k,Hcuts[k],pcontig->Hdel[0][k],HapSite[k],HapSiteScore[k],SiteScore[k]);
      fflush(stdout);
    }
    
    // START NEW140
    for(int k = 1; k <= n; k++)
      HapSite[k] = pcontig->Hdel[0][k] ? 0 : 3;
    
    hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map2[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */
    if(SETLIMIT_CACHE)// reset cache
      for(int m = 0; m < MD; m++)
	limit1[m].ileft = limit2[m].ileft = -1;
    //    rverb = 1;
    double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,nmap1,nmap2,nmapK1,nmapK2,
			   TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,logPV1,logPV2,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
    rverb = 0;
    if(VERB){
      printf("After reverting to non-haplotype map: hLP= %0.6f -> %0.6f\n", newLP, hLP);
      if(VERB>=2)
	for(int m = 0; m < MD; m++)	
	  printf("m=%d(id=%lld): TBmapWT[m]= %0.6f, mapWT1[m]= %0.6f, mapWT2[m]= %0.6f\n",m,gmap[pcontig->contig[m].mapid]->id,TBmapWT[m],mapWT1[m],mapWT2[m]);
      fflush(stdout);
    }
    newLP = hLP;

    /* update map[],mapK[],mapWT[],outlier[] based on (updated) map1[],mapK1[],mapWT1[] (should match map2[],mapK2[],mapWT2[]) : UpdateMap will be called again in parent */
    UpdateMap(n, N1, Y1, MD, MX, X, Hcuts, Hdel1, map1, mapK1, limit1, nmap1, nmapK1, mapWT1, 0, FILL_HMAP);

    if(VERB>=2){
      hsetmap(n,Hcuts,HapDelta,HapSite,Delta,Hcuts1,Hcuts2,Hdel1,Hdel2,N1,N2,Y1,Y2,map1[MD],map1[MD],nmap1[MD],nmap2[MD],0,spreadHapDelta,spreadDelta);/* generate haplotype consensus map pair */

      printf("After UpdateMap() of map1: n=%d,N1=%d\n",n,N1);
      if(VERB>=2){
	for(int k = 1; k <= n; k++)
	  if(!Hdel1[k])
	    printf("Hcuts1[%d]= %0.3f\n",k, Hcuts1[k]);
	for(int I = 1; I <= N1; I++)
	  printf("Y1[%d]= %0.3f\n",I,Y1[I]);
      }
      fflush(stdout);

      //      rverb = 1;
      double hLP = hprobeval(n,Hcuts1,Hcuts2,N1,N2,Y1,Y2,HapDelta,HapSite,0,0,MD,MX,X,map1,map1,mapK1,mapK1,limit1,limit1,nmap1,nmap2,nmapK1,nmapK2,
			     TBmapWT,bestLPA1,bestLPA2,mapWT1,mapWT2,0,0,0.0,0.0,0.0,0.0,logPV1,logPV2,outlier1,outlier2,newLPA,pcontig,numthreads,SNPs,Indels,0);
      rverb = 0;

      printf("After UpdateMap for map1: hLP= %0.6f -> %0.6f\n", newLP, hLP);
      newLP = hLP;      
    }

    memcpy(pcontig->Hdel[0],Hdel1,(n+2)*sizeof(int));// NOTE : should not be needed, since Hdel should have been updated from HapSite[] previously
    memcpy(Hcuts,Hcuts1,(n+2)*sizeof(double));// NEW276 : required since Delta[] may not be zero
    
    for(int m = 0; m < MD; m++){
      int M = MX[m];
      pcontig->mapWT[m] = mapWT1[m] * TBmapWT[m];
      if((DEBUG && !isfinite(pcontig->mapWT[m])) || (VERB>=3)){
	printf("m=%d/%d:mapWT1[m]= %0.6e, mapWT2[m]= %0.6e, TBmapWT[m]= %0.6e : pcontig->mapWT[m]= %0.6e: logPV1[m]= %0.2f,logPV2[m]= %0.2f\n",
	       m,MD,mapWT1[m],mapWT2[m],TBmapWT[m],pcontig->mapWT[m],logPV1[m],logPV2[m]);
	fflush(stdout);
	assert(isfinite(pcontig->mapWT[m]));
      }
      memcpy(pcontig->sitemap[0][m],map1[m],(M+2)*sizeof(int));
      memcpy(pcontig->sitemapL[0][m],mapK1[m],(M+2)*sizeof(int));
      memcpy(pcontig->outlier[0][m],outlier1[m],(M+2)*sizeof(int));
      if(DEBUG>=2){/* check that map[m] and mapK[m] only map to sites i with HapSite[0][i] != 0 */
	for(int J = 1; J <= M; J++){
	  int i = pcontig->sitemap[0][m][J];
	  if(i >= 0){
	    assert(HapSite[i] != 0);
	    int k = pcontig->sitemapL[0][m][J];
	    assert(k >= 0 && i-k > 0 && HapSite[i-k] != 0);
	  }
	}
      }
      memcpy(pcontig->outlier[0][m],outlier1[m],(M+1)*sizeof(int));
      pcontig->logPV[m] = logPV1[m];
      pcontig->LP[m] = bestLPA1[m];
    }

    // END NEW140

    delete [] pcontig->HapSite[0]; pcontig->HapSite[0] = NULL;// HapSite is an alias to pcontig->HapSite[0]
    delete [] pcontig->HapDelta[0]; pcontig->HapDelta[0] = NULL;// HapDelta is an alias to pcontig->HapDelta[0]

    delete [] pcontig->HapSiteScore[0]; pcontig->HapSiteScore[0] = NULL;
    delete [] pcontig->HapDeltaScore[0]; pcontig->HapDeltaScore[0] = NULL;
    delete [] pcontig->HapSitePhase[0]; pcontig->HapSitePhase[0] = NULL;
    delete [] pcontig->HapDeltaPhase[0]; pcontig->HapDeltaPhase[0] = NULL;
  } /* no Haplotype output */

  if(MAX_INDEL_WARNING){
    printf("Increase MAX_INDEL in refine.h to %d or more\n", MAX_INDEL_WARNING);
    fflush(stdout);
  }

  delete [] Label;
  delete [] Index;
  delete [] Hremap;
  delete [] spreadHapDelta;
  delete [] spreadDelta;
  delete [] prevHapDelta;
  delete [] prevDelta;
  delete [] prevHapSite;
  delete [] origHapDelta;
  delete [] origDelta;
  delete [] origHapSite;

  delete [] Initial_Delta;
  delete [] Initial_Delta_Mem;
  delete [] DELTA_RANGE;
  delete [] biggestD1;

  /* free memory allocated in this function (except possibly globals like newLPd[], newLPa[], newLPdelta[]) */
  delete [] DelCum;
  delete [] HapDelCum;
  delete [] startY2;
  delete [] startY1;
  delete [] startHdel2;
  delete [] startHdel1;
  delete [] startHcuts2;
  delete [] startHcuts1;
  delete [] startDelta;
  delete [] startHapDelta;
  if(HSNP_FAST){
    if(delmem){
      if(!HEAP_MINIMIZE)
	delete [] delmem;
      else {
	if(munmap(delmem, delmemsiz)){
	  int eno = errno;
	  char *err = strerror(eno);
	  printf("munpap(%p,%lld) failed: errno=%d:%s\n",delmem,delmemsiz,eno,err);
	  fflush(stdout);exit(1);
	}
      }
    }
    delete [] delmemp;
    delete [] delid1;
    delete [] delid2;
  }
  delete [] LP2mT;
  delete [] LP1mT;
  delete [] LPT;

  if(VERB>=2){
    printf("End of HaplotypeR: freeing memory stage A: pcontig=%p,pcontig->HapDelta[0]=%p,n=%d\n",pcontig,pcontig->HapDelta[0],n);
    for(int i = 1; i < n; i++)
      if(pcontig->HapDelta[0][i])
	printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
    fflush(stdout);
  }

  delete [] tchanges;
  delete [] changes;
  delete [] nDelta;
  delete [] nHapDelta2;
  delete [] nHapDelta;
  delete [] HapDeltaMerged;
  delete [] nHapSite;
  delete [] LPdelta;
  delete [] LPindel;
  delete [] LPsite;

  if(VERB>=2){
    printf("End of HaplotypeR: freeing memory stage B: pcontig=%p,pcontig->HapDelta[0]=%p,n=%d,newLPa2[0]=%p\n",pcontig,pcontig->HapDelta[0],n,newLPa2[0]);
    if(VERB>=2)
      for(int i = 1; i < n; i++)
	if(pcontig->HapDelta[0][i])
	  printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
    fflush(stdout);
  }

  if(newLPdeltaMem2) { free(newLPdeltaMem2); newLPdeltaMem2 = 0;}
  delete [] Dcum2;
  delete [] newLPdelta2;
  if(MDEBUG && newLPaPr2[0]) { delete [] newLPaPr2[0]; newLPaPr2[0] = 0;}
  if(MDEBUG) delete [] newLPaPr2;
  if(!VMEM_MINIMIZE && newLPa2[0]) { free(newLPa2[0]); newLPa2[0] = 0;}
  delete [] newLPa2;
  if(MDEBUG) delete [] newLPdPr2[0];
  if(!VMEM_MINIMIZE && newLPd2[0]) { delete [] newLPd2[0]; newLPd2[0] = NULL;}
  if(MDEBUG) delete [] newLPdPr2;
  if(VMEM_MINIMIZE && newLPd20) { delete [] newLPd20; newLPd20 = NULL;}
  delete [] newLPd2;
  delete [] DminM2;

  if(VERB>=2){
    printf("End of Haplotype: freeing memory stage C: pcontig=%p,pcontig->HapDelta[0]=%p,n=%d\n",pcontig,pcontig->HapDelta[0],n);
    if(VERB>=2)
      for(int i = 1; i < n; i++)
	if(pcontig->HapDelta[0][i])
	  printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
    fflush(stdout);
  }

  delete [] addloc2;
  delete [] addid2;
  delete [] ID2;

  delete [] deltamem;// NEW
#if 0
  delete [] LPdelta2mem;
  delete [] delta2mem;
  delete [] delta2;
  delete [] DR2;
  delete [] D2;
  delete [] LPdelta2;
#endif

  delete [] LPadd2;
  delete [] LPdel2;
  delete [] addloc1;
  delete [] addid1;
  delete [] ID1;

#if 0 
  delete [] LPdelta1mem;
  delete [] delta1mem;
  delete [] delta1;
  delete [] DR1;
  delete [] D1;
  delete [] LPdelta1;
#endif

  delete [] LPadd1;
  delete [] LPdel1;

  for(int k = 0; k < MD; k++){
    delete [] outlier1[k];
    delete [] outlier2[k];
  }
  delete [] outlier2;
  delete [] outlier1;
  delete [] logPV2;
  delete [] logPV1;
  delete [] testLPA1;
  delete [] testLPA2;
  delete [] newLPA2;
  delete [] newLPA1;
  delete [] newLPA;
  delete [] testLPA;
  delete [] startLPA2;
  delete [] startLPA1;
  delete [] bestLPA2;
  delete [] bestLPA1;
  delete [] mapWT2;
  delete [] mapWT1;
  delete [] &nmap2[MD][-1];
  delete [] &nmap1[MD][-1];
  for(int m = 0; m < MD; m++){
    delete [] nmapK2[m];
    delete [] nmapK1[m];
    delete [] nmap2[m];
    delete [] nmap1[m];
    delete [] origmapK1[m];
    delete [] origmapK2[m];
    delete [] origmap1[m];
    delete [] origmap2[m];

    delete [] map1a[m];
    delete [] map2a[m];
    delete [] mapK1a[m];
    delete [] mapK2a[m];

    if(HMAP_TMPFIX){
      delete [] map1b[m];
      delete [] map2b[m];
      delete [] mapK1b[m];
      delete [] mapK2b[m];
    }
  }

  /* free global scratch space used by hprobeval() */
  delete [] tmpLPA1;
  delete [] tmpLPA2;

  delete [] map1a; map1a = NULL;
  delete [] map2a; map2a = NULL;
  delete [] mapK1a; mapK1a = NULL;
  delete [] mapK2a; mapK2a = NULL;
  if(HMAP_TMPFIX){
    delete [] map1b; map1b = NULL;
    delete [] map2b; map2b = NULL;
    delete [] mapK1b; mapK1b = NULL;
    delete [] mapK2b; mapK2b = NULL;
  }

  if(VERB>=2){
    printf("End of Haplotype: freeing memory stage D: pcontig=%p,pcontig->HapDelta[0]=%p,n=%d\n",pcontig,pcontig->HapDelta[0],n);
    for(int i = 1; i < n; i++)
      if(pcontig->HapDelta[0][i])
	printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
    fflush(stdout);
  }

  delete [] nmapK2;
  delete [] nmapK1;
  delete [] nmap2;
  delete [] nmap1;
  delete [] origmapK1;
  delete [] origmapK2;
  delete [] origmap1;
  delete [] origmap2;

  delete [] Y2;
  delete [] Y1;
  delete [] Hdel2;
  delete [] Hdel1;
  delete [] Hcuts2;
  delete [] Hcuts1;
  delete [] Delta;
  delete [] SiteScore;

  delete [] pBlock1;

  delete [] forcemap;

  delete [] startLP;
  free(dmem);// d1List,d2List,vLP1,vLP2
  delete [] LPddT;

  delete [] LPddmemp;
  delete [] LPddmem;
//  free(LPddmemp);
//  free(LPddmem);

  Lrange = LRANGE_INIT;

  PoutlierEnd = origPoutlierEnd;/* undo effect of PoutlierEndFinal */
  HapIndelPvalue = origHapIndelPvalue;/* in case iter loop exceeded limit without restoring original Pvalues */
  HapSitePvalue = origHapSitePvalue;

  if(VERB>=2){
    printf("End of Haplotype after freeing memory: pcontig=%p,pcontig->HapDelta[0]=%p,n=%d\n",pcontig,pcontig->HapDelta[0],n);
    for(int i = 1; i < n; i++)
      if(pcontig->HapDelta[0][i])
	printf("pcontig->HapDelta[0][i]=%0.4f\n",pcontig->HapDelta[0][i]);
    fflush(stdout);
  }

  //  score_initOutlier();   /* score_init() updates caused by change in PoutlierEnd & Poutlier */

  minKB = origminKB;
  ZERO_MINKB = origZERO_MINKB;

  globalfallback = origglobalfallback;

  /* END of HaploType only refinement function */
  
  return newLP;
}

/* Find maximum likelihood Haplotype Map pair from non-haplotype map : result is saved in pcontig, with final LP value returned */
double HaploType(int n, double *Hcuts, int *Hdel,/* complete consensus map */
		 int lc,/* If left end of Y is a linear chromosome end */
		 int rc,/* If right end of Y is a linear chromosome end */
		 int MD, /* number of maps */
		 int *MX, double **X, /* X[m=0..MD-1][j=0..MX[m]+1] : map sites */
		 int **map, /* map[m=0..MD-1][j=0..MX[m]+1] is old index in Hcuts[0..n+1] of X[m][j], 
			       map[MD][j=0..n+1] is index in Y[0..N+1] of Hcuts[j] */
		 int **mapK, /* mapK[m=0..MD-1][j=0..MX[m]+1] is old K index offset in Hcuts[0..n+1] of X[m][j] */ 
		 double *TBmapWT, /* If != 0 : TBmapWT[m] is a the -TB based weight for map m to be applied when summing up the total log(LR+LRbias) value */
		 Ccontig *pcontig, /* pointer to complete contig information, including returned Haplotype Information */
		 int *skip, /* skip[1..n] : > 0 if site Hcuts[i] will not be changed (typically these sites have Hdel[i]== 1) */
		 int& Lfrozen, int& Rfrozen /* refine() args */
		 )
{
  /* first initialize a trivial Haplotype Map set */

  /* allocate and initialize setlimit() cache : will be reset whenever map[],mapK[] is updated (typically in UpdateMap()) */
  Csetlimit *limit1 = new Csetlimit[MD*2];
  Csetlimit *limit2 = &limit1[MD];
  if(SETLIMIT_CACHE)
    for(int m = 0; m < MD; m++)
      limit1[m].ileft = limit2[m].ileft = -1;

  if(DEBUG>=2){
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      /* check map[m][J],mapK[m][J] for consistency */
      int lastJ = -1, lasti = -1, lastk = -1;
      for(int J = 1; J <= M; J++){
	int i = map[m][J];
	if(i < 0)
	  continue;
	int k = mapK[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
          #pragma omp critical
	  {
	    printf("m=%d/%d:M=%d,J=%d,map[m][J]=i=%d,mapK[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
          }
        }
	if(lasti >= 0 && !(i-k > lasti)){
           printf("\nmap:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,Hdel[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,Hdel[i],Hdel[i-k]);
	   if(VERB){
	     for(int j = 1; j <= M; j++){
	       int i = map[m][j];
	       if(i < 0)
		 continue;
	       int k = mapK[m][j];
	       printf("\t j=%d:map[m][j]=%d,mapK[m][j]=%d\n",j,i,k);
	     }
	   }
	   fflush(stdout);
	   assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }
  }

  /* save original non-haplotype map in case we decide we cannot generate a haplotype map (NOTE : map[] and mapK[] should never change) */
  int orign = n;
  //  int origN = N;
  int origlc = lc,origrc = rc;
  double *origHcuts = new double[n+2];
  int *origHdel = new int[n+1];
  for(int i = 0; i <= n+1; i++)
    origHcuts[i] = Hcuts[i];
  for(int i = 1; i <= n; i++)
    origHdel[i] = Hdel[i];

  /* initialize Haplotype information : mark all sites AND intervals as Homozygous */
  int *&HapSite = pcontig->HapSite[0] = new int[n+2];// NOTE : HapSite is now an alias for pcontig->HapSite[0] : this is needed so that when repositionH() reallocates HapSite, it also updates pcontig->HapSite[0]
  double *&HapDelta = pcontig->HapDelta[0] = new double[n+2];// NOTE : HapDelta is now an alias for pcontig->HapDelta[0] : this is needed so that when repositionH() reallocates HapDelta, it also updates pcontig->HapDelta[0]
  if(VERB/* HERE >=2 */){
    printf("pcontig=%p,pcontig->HapDelta[0]=%p,pcontig->HapSite[0]=%p,HapSite=%p,n=%d\n",pcontig,pcontig->HapDelta[0],pcontig->HapSite[0],HapSite,n);
    fflush(stdout);
  }
  if(DEBUG && !(HapSite == pcontig->HapSite[0])){
    printf("HapSite=%p, pcontig->HapSite[0]=%p : they should be the same\n", HapSite, pcontig->HapSite[0]);
    printf("&HapSite=%p, &pcontig->HapSite[0] = %p\n",&HapSite, &pcontig->HapSite[0]);
    fflush(stdout);
    assert(HapSite == pcontig->HapSite[0]);
  }

  for(int i = 0; i <= n+1; i++)
    HapDelta[i] = 0.0;
  if(DEBUG) assert(Hdel[0]==1 && Hdel[n+1]==1);
  for(int i = 0; i <= n+1; i++)
    HapSite[i] = (Hdel[i] ? 0 : 3);
  if(DEBUG) assert(HapSite[0]==0 && HapSite[n+1] == 0);

  int **map1 = new int*[MD+1];
  int **map2 = new int*[MD+1];
  int **mapK1 = new int*[MD];
  int **mapK2 = new int*[MD];

  for(int m = 0; m < MD; m++){
    map1[m] = new int[MX[m]+2];
    map2[m] = new int[MX[m]+2];
    mapK1[m] = new int[MX[m]+2];
    mapK2[m] = new int[MX[m]+2];

    memcpy(map1[m],map[m],(MX[m]+2)*sizeof(int));
    memcpy(map2[m],map[m],(MX[m]+2)*sizeof(int));
    memcpy(mapK1[m],mapK[m],(MX[m]+2)*sizeof(int));
    memcpy(mapK2[m],mapK[m],(MX[m]+2)*sizeof(int));
  }
  map1[MD] = new int[n+2];
  map2[MD] = new int[n+2];

  if(DEBUG>=2){
    for(int m = 0; m < MD; m++){
      int M = MX[m];

      /* check map1[m][J],mapK1[m][J] for consistency */
      int lastJ = -1, lasti = -1, lastk = -1;
      for(int J = 1; J <= M; J++){
	int i = map1[m][J];
	if(i < 0)
	  continue;
	int k = mapK1[m][J];
	if(DEBUG &&  !(0 <= k && k < i)){
          #pragma omp critical
	  {
	    printf("m=%d/%d:M=%d,J=%d,map1[m][J]=i=%d,mapK1[m][J]=k=%d\n",m,MD,M,J,i,k);
	    fflush(stdout);
	    assert(0 <= k && k < i);
          }
        }
	if(lasti >= 0 && !(i-k > lasti)){
           printf("\nmap1:m=%d,J=%d,i=%d,k=%d:lastJ=%d,lasti=%d,lastk=%d,HapSite[i,i-k]=%d,%d\n",m,J,i,k,lastJ,lasti,lastk,HapSite[i],HapSite[i-k]);
	   if(VERB){
	     for(int j = 1; j <= M; j++){
	       int i = map1[m][j];
	       if(i < 0)
		 continue;
	       int k = mapK1[m][j];
	       printf("\t j=%d:map1[m][j]=%d,mapK1[m][j]=%d\n",j,i,k);
	     }
	   }
	   fflush(stdout);
	   assert(i-k > lasti);
	}
	lasti = i;
	lastk = k;
	lastJ = J;
      }
    }
  }

  double newLP = HaploTypeR(n,Hcuts,HapSite,HapDelta,lc,rc,MD,MX,X,map1,map2,mapK1,mapK2,limit1,limit2,TBmapWT,pcontig,skip,Lfrozen,Rfrozen);
			      
  if(0 && !pcontig->HapSite[0]){/* WAS112 : restore original non-Haplotype map */
    if(DEBUG) assert(n == orign);
    //    if(DEBUG) assert(N == origN);
    if(DEBUG) assert(lc == origlc);
    if(DEBUG) assert(rc == origrc);

    for(int k = 1; k <= n; k++)
      Hdel[k] = origHdel[k];
    for(int k = 1; k <= n+1; k++)
      Hcuts[k] = origHcuts[k];
  }

  delete [] origHdel;
  delete [] origHcuts;

  for(int m = 0; m < MD; m++){
    delete [] mapK2[m];
    delete [] mapK1[m];
    delete [] map2[m];
    delete [] map1[m];
  }
  delete [] map1[MD];
  delete [] map2[MD];
  delete [] mapK2;
  delete [] mapK1;
  delete [] map2;
  delete [] map1;

  delete [] limit1;
  //  delete [] limit2;

  return newLP;
}
